        -:    0:Source:/home/rc/ZathuraDbg/vendor/imgui/imgui.cpp
        -:    0:Graph:/home/rc/ZathuraDbg/src/cmake-build-debug-coverage/CMakeFiles/Zathura.dir/home/rc/ZathuraDbg/vendor/imgui/imgui.cpp.gcno
        -:    0:Data:/home/rc/ZathuraDbg/src/cmake-build-debug-coverage/CMakeFiles/Zathura.dir/home/rc/ZathuraDbg/vendor/imgui/imgui.cpp.gcda
        -:    0:Runs:1
        -:    1:// dear imgui, v1.91.4
        -:    2:// (main code and documentation)
        -:    3:
        -:    4:// Help:
        -:    5:// - See links below.
        -:    6:// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.
        -:    7:// - Read top of imgui.cpp for more details, links and comments.
        -:    8:
        -:    9:// Resources:
        -:   10:// - FAQ ........................ https://dearimgui.com/faq (in repository as docs/FAQ.md)
        -:   11:// - Homepage ................... https://github.com/ocornut/imgui
        -:   12:// - Releases & changelog ....... https://github.com/ocornut/imgui/releases
        -:   13:// - Gallery .................... https://github.com/ocornut/imgui/issues?q=label%3Agallery (please post your screenshots/video there!)
        -:   14:// - Wiki ....................... https://github.com/ocornut/imgui/wiki (lots of good stuff there)
        -:   15://   - Getting Started            https://github.com/ocornut/imgui/wiki/Getting-Started (how to integrate in an existing app by adding ~25 lines of code)
        -:   16://   - Third-party Extensions     https://github.com/ocornut/imgui/wiki/Useful-Extensions (ImPlot & many more)
        -:   17://   - Bindings/Backends          https://github.com/ocornut/imgui/wiki/Bindings (language bindings, backends for various tech/engines)
        -:   18://   - Glossary                   https://github.com/ocornut/imgui/wiki/Glossary
        -:   19://   - Debug Tools                https://github.com/ocornut/imgui/wiki/Debug-Tools
        -:   20://   - Software using Dear ImGui  https://github.com/ocornut/imgui/wiki/Software-using-dear-imgui
        -:   21:// - Issues & support ........... https://github.com/ocornut/imgui/issues
        -:   22:// - Test Engine & Automation ... https://github.com/ocornut/imgui_test_engine (test suite, test engine to automate your apps)
        -:   23:
        -:   24:// For first-time users having issues compiling/linking/running/loading fonts:
        -:   25:// please post in https://github.com/ocornut/imgui/discussions if you cannot find a solution in resources above.
        -:   26:// Everything else should be asked in 'Issues'! We are building a database of cross-linked knowledge there.
        -:   27:
        -:   28:// Copyright (c) 2014-2024 Omar Cornut
        -:   29:// Developed by Omar Cornut and every direct or indirect contributors to the GitHub.
        -:   30:// See LICENSE.txt for copyright and licensing details (standard MIT License).
        -:   31:// This library is free but needs your support to sustain development and maintenance.
        -:   32:// Businesses: you can support continued development via B2B invoiced technical support, maintenance and sponsoring contracts.
        -:   33:// PLEASE reach out at omar AT dearimgui DOT com. See https://github.com/ocornut/imgui/wiki/Funding
        -:   34:// Businesses: you can also purchase licenses for the Dear ImGui Automation/Test Engine.
        -:   35:
        -:   36:// It is recommended that you don't modify imgui.cpp! It will become difficult for you to update the library.
        -:   37:// Note that 'ImGui::' being a namespace, you can add functions into the namespace from your own source files, without
        -:   38:// modifying imgui.h or imgui.cpp. You may include imgui_internal.h to access internal data structures, but it doesn't
        -:   39:// come with any guarantee of forward compatibility. Discussing your changes on the GitHub Issue Tracker may lead you
        -:   40:// to a better solution or official support for them.
        -:   41:
        -:   42:/*
        -:   43:
        -:   44:Index of this file:
        -:   45:
        -:   46:DOCUMENTATION
        -:   47:
        -:   48:- MISSION STATEMENT
        -:   49:- CONTROLS GUIDE
        -:   50:- PROGRAMMER GUIDE
        -:   51:  - READ FIRST
        -:   52:  - HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI
        -:   53:  - GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE
        -:   54:  - HOW A SIMPLE APPLICATION MAY LOOK LIKE
        -:   55:  - HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE
        -:   56:- API BREAKING CHANGES (read me when you update!)
        -:   57:- FREQUENTLY ASKED QUESTIONS (FAQ)
        -:   58:  - Read all answers online: https://www.dearimgui.com/faq, or in docs/FAQ.md (with a Markdown viewer)
        -:   59:
        -:   60:CODE
        -:   61:(search for "[SECTION]" in the code to find them)
        -:   62:
        -:   63:// [SECTION] INCLUDES
        -:   64:// [SECTION] FORWARD DECLARATIONS
        -:   65:// [SECTION] CONTEXT AND MEMORY ALLOCATORS
        -:   66:// [SECTION] USER FACING STRUCTURES (ImGuiStyle, ImGuiIO, ImGuiPlatformIO)
        -:   67:// [SECTION] MISC HELPERS/UTILITIES (Geometry functions)
        -:   68:// [SECTION] MISC HELPERS/UTILITIES (String, Format, Hash functions)
        -:   69:// [SECTION] MISC HELPERS/UTILITIES (File functions)
        -:   70:// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)
        -:   71:// [SECTION] MISC HELPERS/UTILITIES (Color functions)
        -:   72:// [SECTION] ImGuiStorage
        -:   73:// [SECTION] ImGuiTextFilter
        -:   74:// [SECTION] ImGuiTextBuffer, ImGuiTextIndex
        -:   75:// [SECTION] ImGuiListClipper
        -:   76:// [SECTION] STYLING
        -:   77:// [SECTION] RENDER HELPERS
        -:   78:// [SECTION] INITIALIZATION, SHUTDOWN
        -:   79:// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)
        -:   80:// [SECTION] ID STACK
        -:   81:// [SECTION] INPUTS
        -:   82:// [SECTION] ERROR CHECKING, STATE RECOVERY
        -:   83:// [SECTION] ITEM SUBMISSION
        -:   84:// [SECTION] LAYOUT
        -:   85:// [SECTION] SCROLLING
        -:   86:// [SECTION] TOOLTIPS
        -:   87:// [SECTION] POPUPS
        -:   88:// [SECTION] KEYBOARD/GAMEPAD NAVIGATION
        -:   89:// [SECTION] DRAG AND DROP
        -:   90:// [SECTION] LOGGING/CAPTURING
        -:   91:// [SECTION] SETTINGS
        -:   92:// [SECTION] LOCALIZATION
        -:   93:// [SECTION] VIEWPORTS, PLATFORM WINDOWS
        -:   94:// [SECTION] DOCKING
        -:   95:// [SECTION] PLATFORM DEPENDENT HELPERS
        -:   96:// [SECTION] METRICS/DEBUGGER WINDOW
        -:   97:// [SECTION] DEBUG LOG WINDOW
        -:   98:// [SECTION] OTHER DEBUG TOOLS (ITEM PICKER, ID STACK TOOL)
        -:   99:
        -:  100:*/
        -:  101:
        -:  102://-----------------------------------------------------------------------------
        -:  103:// DOCUMENTATION
        -:  104://-----------------------------------------------------------------------------
        -:  105:
        -:  106:/*
        -:  107:
        -:  108: MISSION STATEMENT
        -:  109: =================
        -:  110:
        -:  111: - Easy to use to create code-driven and data-driven tools.
        -:  112: - Easy to use to create ad hoc short-lived tools and long-lived, more elaborate tools.
        -:  113: - Easy to hack and improve.
        -:  114: - Minimize setup and maintenance.
        -:  115: - Minimize state storage on user side.
        -:  116: - Minimize state synchronization.
        -:  117: - Portable, minimize dependencies, run on target (consoles, phones, etc.).
        -:  118: - Efficient runtime and memory consumption.
        -:  119:
        -:  120: Designed primarily for developers and content-creators, not the typical end-user!
        -:  121: Some of the current weaknesses (which we aim to address in the future) includes:
        -:  122:
        -:  123: - Doesn't look fancy.
        -:  124: - Limited layout features, intricate layouts are typically crafted in code.
        -:  125:
        -:  126:
        -:  127: CONTROLS GUIDE
        -:  128: ==============
        -:  129:
        -:  130: - MOUSE CONTROLS
        -:  131:   - Mouse wheel:                   Scroll vertically.
        -:  132:   - SHIFT+Mouse wheel:             Scroll horizontally.
        -:  133:   - Click [X]:                     Close a window, available when 'bool* p_open' is passed to ImGui::Begin().
        -:  134:   - Click ^, Double-Click title:   Collapse window.
        -:  135:   - Drag on corner/border:         Resize window (double-click to auto fit window to its contents).
        -:  136:   - Drag on any empty space:       Move window (unless io.ConfigWindowsMoveFromTitleBarOnly = true).
        -:  137:   - Left-click outside popup:      Close popup stack (right-click over underlying popup: Partially close popup stack).
        -:  138:
        -:  139: - TEXT EDITOR
        -:  140:   - Hold SHIFT or Drag Mouse:      Select text.
        -:  141:   - CTRL+Left/Right:               Word jump.
        -:  142:   - CTRL+Shift+Left/Right:         Select words.
        -:  143:   - CTRL+A or Double-Click:        Select All.
        -:  144:   - CTRL+X, CTRL+C, CTRL+V:        Use OS clipboard.
        -:  145:   - CTRL+Z, CTRL+Y:                Undo, Redo.
        -:  146:   - ESCAPE:                        Revert text to its original value.
        -:  147:   - On OSX, controls are automatically adjusted to match standard OSX text editing 2ts and behaviors.
        -:  148:
        -:  149: - KEYBOARD CONTROLS
        -:  150:   - Basic:
        -:  151:     - Tab, SHIFT+Tab               Cycle through text editable fields.
        -:  152:     - CTRL+Tab, CTRL+Shift+Tab     Cycle through windows.
        -:  153:     - CTRL+Click                   Input text into a Slider or Drag widget.
        -:  154:   - Extended features with `io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard`:
        -:  155:     - Tab, SHIFT+Tab:              Cycle through every items.
        -:  156:     - Arrow keys                   Move through items using directional navigation. Tweak value.
        -:  157:     - Arrow keys + Alt, Shift      Tweak slower, tweak faster (when using arrow keys).
        -:  158:     - Enter                        Activate item (prefer text input when possible).
        -:  159:     - Space                        Activate item (prefer tweaking with arrows when possible).
        -:  160:     - Escape                       Deactivate item, leave child window, close popup.
        -:  161:     - Page Up, Page Down           Previous page, next page.
        -:  162:     - Home, End                    Scroll to top, scroll to bottom.
        -:  163:     - Alt                          Toggle between scrolling layer and menu layer.
        -:  164:     - CTRL+Tab then Ctrl+Arrows    Move window. Hold SHIFT to resize instead of moving.
        -:  165:   - Output when ImGuiConfigFlags_NavEnableKeyboard set,
        -:  166:     - io.WantCaptureKeyboard flag is set when keyboard is claimed.
        -:  167:     - io.NavActive: true when a window is focused and it doesn't have the ImGuiWindowFlags_NoNavInputs flag set.
        -:  168:     - io.NavVisible: true when the navigation cursor is visible (usually goes to back false when mouse is used).
        -:  169:
        -:  170: - GAMEPAD CONTROLS
        -:  171:   - Enable with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.
        -:  172:   - Particularly useful to use Dear ImGui on a console system (e.g. PlayStation, Switch, Xbox) without a mouse!
        -:  173:   - Download controller mapping PNG/PSD at http://dearimgui.com/controls_sheets
        -:  174:   - Backend support: backend needs to:
        -:  175:      - Set 'io.BackendFlags |= ImGuiBackendFlags_HasGamepad' + call io.AddKeyEvent/AddKeyAnalogEvent() with ImGuiKey_Gamepad_XXX keys.
        -:  176:      - For analog values (0.0f to 1.0f), backend is responsible to handling a dead-zone and rescaling inputs accordingly.
        -:  177:        Backend code will probably need to transform your raw inputs (such as e.g. remapping your 0.2..0.9 raw input range to 0.0..1.0 imgui range, etc.).
        -:  178:      - BEFORE 1.87, BACKENDS USED TO WRITE TO io.NavInputs[]. This is now obsolete. Please call io functions instead!
        -:  179:   - If you need to share inputs between your game and the Dear ImGui interface, the easiest approach is to go all-or-nothing,
        -:  180:     with a buttons combo to toggle the target. Please reach out if you think the game vs navigation input sharing could be improved.
        -:  181:
        -:  182: - REMOTE INPUTS SHARING & MOUSE EMULATION
        -:  183:   - PS4/PS5 users: Consider emulating a mouse cursor with DualShock touch pad or a spare analog stick as a mouse-emulation fallback.
        -:  184:   - Consoles/Tablet/Phone users: Consider using a Synergy 1.x server (on your PC) + run examples/libs/synergy/uSynergy.c (on your console/tablet/phone app)
        -:  185:     in order to share your PC mouse/keyboard.
        -:  186:   - See https://github.com/ocornut/imgui/wiki/Useful-Extensions#remoting for other remoting solutions.
        -:  187:   - On a TV/console system where readability may be lower or mouse inputs may be awkward, you may want to set the io.ConfigNavMoveSetMousePos flag.
        -:  188:     Enabling io.ConfigNavMoveSetMousePos + ImGuiBackendFlags_HasSetMousePos instructs Dear ImGui to move your mouse cursor along with navigation movements.
        -:  189:     When enabled, the NewFrame() function may alter 'io.MousePos' and set 'io.WantSetMousePos' to notify you that it wants the mouse cursor to be moved.
        -:  190:     When that happens your backend NEEDS to move the OS or underlying mouse cursor on the next frame. Some of the backends in examples/ do that.
        -:  191:     (If you set the NavEnableSetMousePos flag but don't honor 'io.WantSetMousePos' properly, Dear ImGui will misbehave as it will see your mouse moving back & forth!)
        -:  192:     (In a setup when you may not have easy control over the mouse cursor, e.g. uSynergy.c doesn't expose moving remote mouse cursor, you may want
        -:  193:     to set a boolean to ignore your other external mouse positions until the external source is moved again.)
        -:  194:
        -:  195:
        -:  196: PROGRAMMER GUIDE
        -:  197: ================
        -:  198:
        -:  199: READ FIRST
        -:  200: ----------
        -:  201: - Remember to check the wonderful Wiki (https://github.com/ocornut/imgui/wiki)
        -:  202: - Your code creates the UI every frame of your application loop, if your code doesn't run the UI is gone!
        -:  203:   The UI can be highly dynamic, there are no construction or destruction steps, less superfluous
        -:  204:   data retention on your side, less state duplication, less state synchronization, fewer bugs.
        -:  205: - Call and read ImGui::ShowDemoWindow() for demo code demonstrating most features.
        -:  206:   Or browse https://pthom.github.io/imgui_manual_online/manual/imgui_manual.html for interactive web version.
        -:  207: - The library is designed to be built from sources. Avoid pre-compiled binaries and packaged versions. See imconfig.h to configure your build.
        -:  208: - Dear ImGui is an implementation of the IMGUI paradigm (immediate-mode graphical user interface, a term coined by Casey Muratori).
        -:  209:   You can learn about IMGUI principles at http://www.johno.se/book/imgui.html, http://mollyrocket.com/861 & more links in Wiki.
        -:  210: - Dear ImGui is a "single pass" rasterizing implementation of the IMGUI paradigm, aimed at ease of use and high-performances.
        -:  211:   For every application frame, your UI code will be called only once. This is in contrast to e.g. Unity's implementation of an IMGUI,
        -:  212:   where the UI code is called multiple times ("multiple passes") from a single entry point. There are pros and cons to both approaches.
        -:  213: - Our origin is on the top-left. In axis aligned bounding boxes, Min = top-left, Max = bottom-right.
        -:  214: - Please make sure you have asserts enabled (IM_ASSERT redirects to assert() by default, but can be redirected).
        -:  215:   If you get an assert, read the messages and comments around the assert.
        -:  216: - This codebase aims to be highly optimized:
        -:  217:   - A typical idle frame should never call malloc/free.
        -:  218:   - We rely on a maximum of constant-time or O(N) algorithms. Limiting searches/scans as much as possible.
        -:  219:   - We put particular energy in making sure performances are decent with typical "Debug" build settings as well.
        -:  220:     Which mean we tend to avoid over-relying on "zero-cost abstraction" as they aren't zero-cost at all.
        -:  221: - This codebase aims to be both highly opinionated and highly flexible:
        -:  222:   - This code works because of the things it choose to solve or not solve.
        -:  223:   - C++: this is a pragmatic C-ish codebase: we don't use fancy C++ features, we don't include C++ headers,
        -:  224:     and ImGui:: is a namespace. We rarely use member functions (and when we did, I am mostly regretting it now).
        -:  225:     This is to increase compatibility, increase maintainability and facilitate use from other languages.
        -:  226:   - C++: ImVec2/ImVec4 do not expose math operators by default, because it is expected that you use your own math types.
        -:  227:     See FAQ "How can I use my own math types instead of ImVec2/ImVec4?" for details about setting up imconfig.h for that.
        -:  228:     We can can optionally export math operators for ImVec2/ImVec4 using IMGUI_DEFINE_MATH_OPERATORS, which we use internally.
        -:  229:   - C++: pay attention that ImVector<> manipulates plain-old-data and does not honor construction/destruction
        -:  230:     (so don't use ImVector in your code or at our own risk!).
        -:  231:   - Building: We don't use nor mandate a build system for the main library.
        -:  232:     This is in an effort to ensure that it works in the real world aka with any esoteric build setup.
        -:  233:     This is also because providing a build system for the main library would be of little-value.
        -:  234:     The build problems are almost never coming from the main library but from specific backends.
        -:  235:
        -:  236:
        -:  237: HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI
        -:  238: ----------------------------------------------
        -:  239: - Update submodule or copy/overwrite every file.
        -:  240: - About imconfig.h:
        -:  241:   - You may modify your copy of imconfig.h, in this case don't overwrite it.
        -:  242:   - or you may locally branch to modify imconfig.h and merge/rebase latest.
        -:  243:   - or you may '#define IMGUI_USER_CONFIG "my_config_file.h"' globally from your build system to
        -:  244:     specify a custom path for your imconfig.h file and instead not have to modify the default one.
        -:  245:
        -:  246: - Overwrite all the sources files except for imconfig.h (if you have modified your copy of imconfig.h)
        -:  247: - Or maintain your own branch where you have imconfig.h modified as a top-most commit which you can regularly rebase over "master".
        -:  248: - You can also use '#define IMGUI_USER_CONFIG "my_config_file.h" to redirect configuration to your own file.
        -:  249: - Read the "API BREAKING CHANGES" section (below). This is where we list occasional API breaking changes.
        -:  250:   If a function/type has been renamed / or marked obsolete, try to fix the name in your code before it is permanently removed
        -:  251:   from the public API. If you have a problem with a missing function/symbols, search for its name in the code, there will
        -:  252:   likely be a comment about it. Please report any issue to the GitHub page!
        -:  253: - To find out usage of old API, you can add '#define IMGUI_DISABLE_OBSOLETE_FUNCTIONS' in your configuration file.
        -:  254: - Try to keep your copy of Dear ImGui reasonably up to date!
        -:  255:
        -:  256:
        -:  257: GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE
        -:  258: ---------------------------------------------------------------
        -:  259: - See https://github.com/ocornut/imgui/wiki/Getting-Started.
        -:  260: - Run and study the examples and demo in imgui_demo.cpp to get acquainted with the library.
        -:  261: - In the majority of cases you should be able to use unmodified backends files available in the backends/ folder.
        -:  262: - Add the Dear ImGui source files + selected backend source files to your projects or using your preferred build system.
        -:  263:   It is recommended you build and statically link the .cpp files as part of your project and NOT as a shared library (DLL).
        -:  264: - You can later customize the imconfig.h file to tweak some compile-time behavior, such as integrating Dear ImGui types with your own maths types.
        -:  265: - When using Dear ImGui, your programming IDE is your friend: follow the declaration of variables, functions and types to find comments about them.
        -:  266: - Dear ImGui never touches or knows about your GPU state. The only function that knows about GPU is the draw function that you provide.
        -:  267:   Effectively it means you can create widgets at any time in your code, regardless of considerations of being in "update" vs "render"
        -:  268:   phases of your own application. All rendering information is stored into command-lists that you will retrieve after calling ImGui::Render().
        -:  269: - Refer to the backends and demo applications in the examples/ folder for instruction on how to setup your code.
        -:  270: - If you are running over a standard OS with a common graphics API, you should be able to use unmodified imgui_impl_*** files from the examples/ folder.
        -:  271:
        -:  272:
        -:  273: HOW A SIMPLE APPLICATION MAY LOOK LIKE
        -:  274: --------------------------------------
        -:  275: EXHIBIT 1: USING THE EXAMPLE BACKENDS (= imgui_impl_XXX.cpp files from the backends/ folder).
        -:  276: The sub-folders in examples/ contain examples applications following this structure.
        -:  277:
        -:  278:     // Application init: create a dear imgui context, setup some options, load fonts
        -:  279:     ImGui::CreateContext();
        -:  280:     ImGuiIO& io = ImGui::GetIO();
        -:  281:     // TODO: Set optional io.ConfigFlags values, e.g. 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard' to enable keyboard controls.
        -:  282:     // TODO: Fill optional fields of the io structure later.
        -:  283:     // TODO: Load TTF/OTF fonts if you don't want to use the default font.
        -:  284:
        -:  285:     // Initialize helper Platform and Renderer backends (here we are using imgui_impl_win32.cpp and imgui_impl_dx11.cpp)
        -:  286:     ImGui_ImplWin32_Init(hwnd);
        -:  287:     ImGui_ImplDX11_Init(g_pd3dDevice, g_pd3dDeviceContext);
        -:  288:
        -:  289:     // Application main loop
        -:  290:     while (true)
        -:  291:     {
        -:  292:         // Feed inputs to dear imgui, start new frame
        -:  293:         ImGui_ImplDX11_NewFrame();
        -:  294:         ImGui_ImplWin32_NewFrame();
        -:  295:         ImGui::NewFrame();
        -:  296:
        -:  297:         // Any application code here
        -:  298:         ImGui::Text("Hello, world!");
        -:  299:
        -:  300:         // Render dear imgui into screen
        -:  301:         ImGui::Render();
        -:  302:         ImGui_ImplDX11_RenderDrawData(ImGui::GetDrawData());
        -:  303:         g_pSwapChain->Present(1, 0);
        -:  304:     }
        -:  305:
        -:  306:     // Shutdown
        -:  307:     ImGui_ImplDX11_Shutdown();
        -:  308:     ImGui_ImplWin32_Shutdown();
        -:  309:     ImGui::DestroyContext();
        -:  310:
        -:  311: EXHIBIT 2: IMPLEMENTING CUSTOM BACKEND / CUSTOM ENGINE
        -:  312:
        -:  313:     // Application init: create a dear imgui context, setup some options, load fonts
        -:  314:     ImGui::CreateContext();
        -:  315:     ImGuiIO& io = ImGui::GetIO();
        -:  316:     // TODO: Set optional io.ConfigFlags values, e.g. 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard' to enable keyboard controls.
        -:  317:     // TODO: Fill optional fields of the io structure later.
        -:  318:     // TODO: Load TTF/OTF fonts if you don't want to use the default font.
        -:  319:
        -:  320:     // Build and load the texture atlas into a texture
        -:  321:     // (In the examples/ app this is usually done within the ImGui_ImplXXX_Init() function from one of the demo Renderer)
        -:  322:     int width, height;
        -:  323:     unsigned char* pixels = nullptr;
        -:  324:     io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);
        -:  325:
        -:  326:     // At this point you've got the texture data and you need to upload that to your graphic system:
        -:  327:     // After we have created the texture, store its pointer/identifier (_in whichever format your engine uses_) in 'io.Fonts->TexID'.
        -:  328:     // This will be passed back to your via the renderer. Basically ImTextureID == void*. Read FAQ for details about ImTextureID.
        -:  329:     MyTexture* texture = MyEngine::CreateTextureFromMemoryPixels(pixels, width, height, TEXTURE_TYPE_RGBA32)
        -:  330:     io.Fonts->SetTexID((void*)texture);
        -:  331:
        -:  332:     // Application main loop
        -:  333:     while (true)
        -:  334:     {
        -:  335:        // Setup low-level inputs, e.g. on Win32: calling GetKeyboardState(), or write to those fields from your Windows message handlers, etc.
        -:  336:        // (In the examples/ app this is usually done within the ImGui_ImplXXX_NewFrame() function from one of the demo Platform Backends)
        -:  337:        io.DeltaTime = 1.0f/60.0f;              // set the time elapsed since the previous frame (in seconds)
        -:  338:        io.DisplaySize.x = 1920.0f;             // set the current display width
        -:  339:        io.DisplaySize.y = 1280.0f;             // set the current display height here
        -:  340:        io.AddMousePosEvent(mouse_x, mouse_y);  // update mouse position
        -:  341:        io.AddMouseButtonEvent(0, mouse_b[0]);  // update mouse button states
        -:  342:        io.AddMouseButtonEvent(1, mouse_b[1]);  // update mouse button states
        -:  343:
        -:  344:        // Call NewFrame(), after this point you can use ImGui::* functions anytime
        -:  345:        // (So you want to try calling NewFrame() as early as you can in your main loop to be able to use Dear ImGui everywhere)
        -:  346:        ImGui::NewFrame();
        -:  347:
        -:  348:        // Most of your application code here
        -:  349:        ImGui::Text("Hello, world!");
        -:  350:        MyGameUpdate(); // may use any Dear ImGui functions, e.g. ImGui::Begin("My window"); ImGui::Text("Hello, world!"); ImGui::End();
        -:  351:        MyGameRender(); // may use any Dear ImGui functions as well!
        -:  352:
        -:  353:        // Render dear imgui, swap buffers
        -:  354:        // (You want to try calling EndFrame/Render as late as you can, to be able to use Dear ImGui in your own game rendering code)
        -:  355:        ImGui::EndFrame();
        -:  356:        ImGui::Render();
        -:  357:        ImDrawData* draw_data = ImGui::GetDrawData();
        -:  358:        MyImGuiRenderFunction(draw_data);
        -:  359:        SwapBuffers();
        -:  360:     }
        -:  361:
        -:  362:     // Shutdown
        -:  363:     ImGui::DestroyContext();
        -:  364:
        -:  365: To decide whether to dispatch mouse/keyboard inputs to Dear ImGui to the rest of your application,
        -:  366: you should read the 'io.WantCaptureMouse', 'io.WantCaptureKeyboard' and 'io.WantTextInput' flags!
        -:  367: Please read the FAQ entry "How can I tell whether to dispatch mouse/keyboard to Dear ImGui or my application?" about this.
        -:  368:
        -:  369:
        -:  370: HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE
        -:  371: ---------------------------------------------
        -:  372: The backends in impl_impl_XXX.cpp files contain many working implementations of a rendering function.
        -:  373:
        -:  374:    void MyImGuiRenderFunction(ImDrawData* draw_data)
        -:  375:    {
        -:  376:       // TODO: Setup render state: alpha-blending enabled, no face culling, no depth testing, scissor enabled
        -:  377:       // TODO: Setup texture sampling state: sample with bilinear filtering (NOT point/nearest filtering). Use 'io.Fonts->Flags |= ImFontAtlasFlags_NoBakedLines;' to allow point/nearest filtering.
        -:  378:       // TODO: Setup viewport covering draw_data->DisplayPos to draw_data->DisplayPos + draw_data->DisplaySize
        -:  379:       // TODO: Setup orthographic projection matrix cover draw_data->DisplayPos to draw_data->DisplayPos + draw_data->DisplaySize
        -:  380:       // TODO: Setup shader: vertex { float2 pos, float2 uv, u32 color }, fragment shader sample color from 1 texture, multiply by vertex color.
        -:  381:       ImVec2 clip_off = draw_data->DisplayPos;
        -:  382:       for (int n = 0; n < draw_data->CmdListsCount; n++)
        -:  383:       {
        -:  384:          const ImDrawList* cmd_list = draw_data->CmdLists[n];
        -:  385:          const ImDrawVert* vtx_buffer = cmd_list->VtxBuffer.Data;  // vertex buffer generated by Dear ImGui
        -:  386:          const ImDrawIdx* idx_buffer = cmd_list->IdxBuffer.Data;   // index buffer generated by Dear ImGui
        -:  387:          for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)
        -:  388:          {
        -:  389:             const ImDrawCmd* pcmd = &cmd_list->CmdBuffer[cmd_i];
        -:  390:             if (pcmd->UserCallback)
        -:  391:             {
        -:  392:                 pcmd->UserCallback(cmd_list, pcmd);
        -:  393:             }
        -:  394:             else
        -:  395:             {
        -:  396:                 // Project scissor/clipping rectangles into framebuffer space
        -:  397:                 ImVec2 clip_min(pcmd->ClipRect.x - clip_off.x, pcmd->ClipRect.y - clip_off.y);
        -:  398:                 ImVec2 clip_max(pcmd->ClipRect.z - clip_off.x, pcmd->ClipRect.w - clip_off.y);
        -:  399:                 if (clip_max.x <= clip_min.x || clip_max.y <= clip_min.y)
        -:  400:                     continue;
        -:  401:
        -:  402:                 // We are using scissoring to clip some objects. All low-level graphics API should support it.
        -:  403:                 // - If your engine doesn't support scissoring yet, you may ignore this at first. You will get some small glitches
        -:  404:                 //   (some elements visible outside their bounds) but you can fix that once everything else works!
        -:  405:                 // - Clipping coordinates are provided in imgui coordinates space:
        -:  406:                 //   - For a given viewport, draw_data->DisplayPos == viewport->Pos and draw_data->DisplaySize == viewport->Size
        -:  407:                 //   - In a single viewport application, draw_data->DisplayPos == (0,0) and draw_data->DisplaySize == io.DisplaySize, but always use GetMainViewport()->Pos/Size instead of hardcoding those values.
        -:  408:                 //   - In the interest of supporting multi-viewport applications (see 'docking' branch on github),
        -:  409:                 //     always subtract draw_data->DisplayPos from clipping bounds to convert them to your viewport space.
        -:  410:                 // - Note that pcmd->ClipRect contains Min+Max bounds. Some graphics API may use Min+Max, other may use Min+Size (size being Max-Min)
        -:  411:                 MyEngineSetScissor(clip_min.x, clip_min.y, clip_max.x, clip_max.y);
        -:  412:
        -:  413:                 // The texture for the draw call is specified by pcmd->GetTexID().
        -:  414:                 // The vast majority of draw calls will use the Dear ImGui texture atlas, which value you have set yourself during initialization.
        -:  415:                 MyEngineBindTexture((MyTexture*)pcmd->GetTexID());
        -:  416:
        -:  417:                 // Render 'pcmd->ElemCount/3' indexed triangles.
        -:  418:                 // By default the indices ImDrawIdx are 16-bit, you can change them to 32-bit in imconfig.h if your engine doesn't support 16-bit indices.
        -:  419:                 MyEngineDrawIndexedTriangles(pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer + pcmd->IdxOffset, vtx_buffer, pcmd->VtxOffset);
        -:  420:             }
        -:  421:          }
        -:  422:       }
        -:  423:    }
        -:  424:
        -:  425:
        -:  426: API BREAKING CHANGES
        -:  427: ====================
        -:  428:
        -:  429: Occasionally introducing changes that are breaking the API. We try to make the breakage minor and easy to fix.
        -:  430: Below is a change-log of API breaking changes only. If you are using one of the functions listed, expect to have to fix some code.
        -:  431: When you are not sure about an old symbol or function name, try using the Search/Find function of your IDE to look for comments or references in all imgui files.
        -:  432: You can read releases logs https://github.com/ocornut/imgui/releases for more details.
        -:  433:
        -:  434:(Docking/Viewport Branch)
        -:  435: - 2024/XX/XX (1.XXXX) - when multi-viewports are enabled, all positions will be in your natural OS coordinates space. It means that:
        -:  436:                          - reference to hard-coded positions such as in SetNextWindowPos(ImVec2(0,0)) are probably not what you want anymore.
        -:  437:                            you may use GetMainViewport()->Pos to offset hard-coded positions, e.g. SetNextWindowPos(GetMainViewport()->Pos)
        -:  438:                          - likewise io.MousePos and GetMousePos() will use OS coordinates.
        -:  439:                            If you query mouse positions to interact with non-imgui coordinates you will need to offset them, e.g. subtract GetWindowViewport()->Pos.
        -:  440:
        -:  441: - 2024/10/18 (1.91.4) - renamed ImGuiCol_NavHighlight to ImGuiCol_NavCursor (for consistency with newly exposed and reworked features). Kept inline redirection enum (will obsolete).
        -:  442: - 2024/10/14 (1.91.4) - moved ImGuiConfigFlags_NavEnableSetMousePos to standalone io.ConfigNavMoveSetMousePos bool.
        -:  443:                         moved ImGuiConfigFlags_NavNoCaptureKeyboard to standalone io.ConfigNavCaptureKeyboard bool (note the inverted value!).
        -:  444:                         kept legacy names (will obsolete) + code that copies settings once the first time. Dynamically changing the old value won't work. Switch to using the new value!
        -:  445: - 2024/10/10 (1.91.4) - the typedef for ImTextureID now defaults to ImU64 instead of void*. (#1641)
        -:  446:                         this removes the requirement to redefine it for backends which are e.g. storing descriptor sets or other 64-bits structures when building on 32-bits archs. It therefore simplify various building scripts/helpers.
        -:  447:                         you may have compile-time issues if you were casting to 'void*' instead of 'ImTextureID' when passing your types to functions taking ImTextureID values, e.g. ImGui::Image().
        -:  448:                         in doubt it is almost always better to do an intermediate intptr_t cast, since it allows casting any pointer/integer type without warning:
        -:  449:                            - May warn:    ImGui::Image((void*)MyTextureData, ...);
        -:  450:                            - May warn:    ImGui::Image((void*)(intptr_t)MyTextureData, ...);
        -:  451:                            - Won't warn:  ImGui::Image((ImTextureID)(intptr_t)MyTextureData), ...);
        -:  452:  -                      note that you can always define ImTextureID to be your own high-level structures (with dedicated constructors) if you like.
        -:  453: - 2024/10/03 (1.91.3) - drags: treat v_min==v_max as a valid clamping range when != 0.0f. Zero is a still special value due to legacy reasons, unless using ImGuiSliderFlags_ClampZeroRange. (#7968, #3361, #76)
        -:  454:                       - drags: extended behavior of ImGuiSliderFlags_AlwaysClamp to include _ClampZeroRange. It considers v_min==v_max==0.0f as a valid clamping range (aka edits not allowed).
        -:  455:                         although unlikely, it you wish to only clamp on text input but want v_min==v_max==0.0f to mean unclamped drags, you can use _ClampOnInput instead of _AlwaysClamp. (#7968, #3361, #76)
        -:  456: - 2024/09/10 (1.91.2) - internals: using multiple overlayed ButtonBehavior() with same ID will now have io.ConfigDebugHighlightIdConflicts=true feature emit a warning. (#8030)
        -:  457:                         it was one of the rare case where using same ID is legal. workarounds: (1) use single ButtonBehavior() call with multiple _MouseButton flags, or (2) surround the calls with PushItemFlag(ImGuiItemFlags_AllowDuplicateId, true); ... PopItemFlag()
        -:  458: - 2024/08/23 (1.91.1) - renamed ImGuiChildFlags_Border to ImGuiChildFlags_Borders for consistency. kept inline redirection flag.
        -:  459: - 2024/08/22 (1.91.1) - moved some functions from ImGuiIO to ImGuiPlatformIO structure:
        -:  460:                            - io.GetClipboardTextFn         -> platform_io.Platform_GetClipboardTextFn + changed 'void* user_data' to 'ImGuiContext* ctx'. Pull your user data from platform_io.ClipboardUserData.
        -:  461:                            - io.SetClipboardTextFn         -> platform_io.Platform_SetClipboardTextFn + same as above line.
        -:  462:                            - io.PlatformOpenInShellFn      -> platform_io.Platform_OpenInShellFn (#7660)
        -:  463:                            - io.PlatformSetImeDataFn       -> platform_io.Platform_SetImeDataFn
        -:  464:                            - io.PlatformLocaleDecimalPoint -> platform_io.Platform_LocaleDecimalPoint (#7389, #6719, #2278)
        -:  465:                            - access those via GetPlatformIO() instead of GetIO().
        -:  466:                         some were introduced very recently and often automatically setup by core library and backends, so for those we are exceptionally not maintaining a legacy redirection symbol.
        -:  467:                       - commented the old ImageButton() signature obsoleted in 1.89 (~August 2022). As a reminder:
        -:  468:                            - old ImageButton() before 1.89 used ImTextureId as item id (created issue with e.g. multiple buttons in same scope, transient texture id values, opaque computation of ID)
        -:  469:                            - new ImageButton() since 1.89 requires an explicit 'const char* str_id'
        -:  470:                            - old ImageButton() before 1.89 had frame_padding' override argument.
        -:  471:                            - new ImageButton() since 1.89 always use style.FramePadding, which you can freely override with PushStyleVar()/PopStyleVar().
        -:  472: - 2024/07/25 (1.91.0) - obsoleted GetContentRegionMax(), GetWindowContentRegionMin() and GetWindowContentRegionMax(). (see #7838 on GitHub for more info)
        -:  473:                         you should never need those functions. you can do everything with GetCursorScreenPos() and GetContentRegionAvail() in a more simple way.
        -:  474:                            - instead of:  GetWindowContentRegionMax().x - GetCursorPos().x
        -:  475:                            - you can use: GetContentRegionAvail().x
        -:  476:                            - instead of:  GetWindowContentRegionMax().x + GetWindowPos().x
        -:  477:                            - you can use: GetCursorScreenPos().x + GetContentRegionAvail().x // when called from left edge of window
        -:  478:                            - instead of:  GetContentRegionMax()
        -:  479:                            - you can use: GetContentRegionAvail() + GetCursorScreenPos() - GetWindowPos() // right edge in local coordinates
        -:  480:                            - instead of:  GetWindowContentRegionMax().x - GetWindowContentRegionMin().x
        -:  481:                            - you can use: GetContentRegionAvail() // when called from left edge of window
        -:  482: - 2024/07/15 (1.91.0) - renamed ImGuiSelectableFlags_DontClosePopups to ImGuiSelectableFlags_NoAutoClosePopups. (#1379, #1468, #2200, #4936, #5216, #7302, #7573)
        -:  483:                         (internals: also renamed ImGuiItemFlags_SelectableDontClosePopup into ImGuiItemFlags_AutoClosePopups with inverted behaviors)
        -:  484: - 2024/07/15 (1.91.0) - obsoleted PushButtonRepeat()/PopButtonRepeat() in favor of using new PushItemFlag(ImGuiItemFlags_ButtonRepeat, ...)/PopItemFlag().
        -:  485: - 2024/07/02 (1.91.0) - commented out obsolete ImGuiModFlags (renamed to ImGuiKeyChord in 1.89). (#4921, #456)
        -:  486:                       - commented out obsolete ImGuiModFlags_XXX values (renamed to ImGuiMod_XXX in 1.89). (#4921, #456)
        -:  487:                            - ImGuiModFlags_Ctrl -> ImGuiMod_Ctrl, ImGuiModFlags_Shift -> ImGuiMod_Shift etc.
        -:  488: - 2024/07/02 (1.91.0) - IO, IME: renamed platform IME hook and added explicit context for consistency and future-proofness.
        -:  489:                            - old: io.SetPlatformImeDataFn(ImGuiViewport* viewport, ImGuiPlatformImeData* data);
        -:  490:                            - new: io.PlatformSetImeDataFn(ImGuiContext* ctx, ImGuiViewport* viewport, ImGuiPlatformImeData* data);
        -:  491: - 2024/06/21 (1.90.9) - BeginChild: added ImGuiChildFlags_NavFlattened as a replacement for the window flag ImGuiWindowFlags_NavFlattened: the feature only ever made sense for BeginChild() anyhow.
        -:  492:                            - old: BeginChild("Name", size, 0, ImGuiWindowFlags_NavFlattened);
        -:  493:                            - new: BeginChild("Name", size, ImGuiChildFlags_NavFlattened, 0);
        -:  494: - 2024/06/21 (1.90.9) - io: ClearInputKeys() (first exposed in 1.89.8) doesn't clear mouse data, newly added ClearInputMouse() does.
        -:  495: - 2024/06/20 (1.90.9) - renamed ImGuiDragDropFlags_SourceAutoExpirePayload to ImGuiDragDropFlags_PayloadAutoExpire.
        -:  496: - 2024/06/18 (1.90.9) - style: renamed ImGuiCol_TabActive -> ImGuiCol_TabSelected, ImGuiCol_TabUnfocused -> ImGuiCol_TabDimmed, ImGuiCol_TabUnfocusedActive -> ImGuiCol_TabDimmedSelected.
        -:  497: - 2024/06/10 (1.90.9) - removed old nested structure: renaming ImGuiStorage::ImGuiStoragePair type to ImGuiStoragePair (simpler for many languages).
        -:  498: - 2024/06/06 (1.90.8) - reordered ImGuiInputTextFlags values. This should not be breaking unless you are using generated headers that have values not matching the main library.
        -:  499: - 2024/06/06 (1.90.8) - removed 'ImGuiButtonFlags_MouseButtonDefault_ = ImGuiButtonFlags_MouseButtonLeft', was mostly unused and misleading.
        -:  500: - 2024/05/27 (1.90.7) - commented out obsolete symbols marked obsolete in 1.88 (May 2022):
        -:  501:                            - old: CaptureKeyboardFromApp(bool)
        -:  502:                            - new: SetNextFrameWantCaptureKeyboard(bool)
        -:  503:                            - old: CaptureMouseFromApp(bool)
        -:  504:                            - new: SetNextFrameWantCaptureMouse(bool)
        -:  505: - 2024/05/22 (1.90.7) - inputs (internals): renamed ImGuiKeyOwner_None to ImGuiKeyOwner_NoOwner, to make use more explicit and reduce confusion with the default it is a non-zero value and cannot be the default value (never made public, but disclosing as I expect a few users caught on owner-aware inputs).
        -:  506:                       - inputs (internals): renamed ImGuiInputFlags_RouteGlobalLow -> ImGuiInputFlags_RouteGlobal, ImGuiInputFlags_RouteGlobal -> ImGuiInputFlags_RouteGlobalOverFocused, ImGuiInputFlags_RouteGlobalHigh -> ImGuiInputFlags_RouteGlobalHighest.
        -:  507:                       - inputs (internals): Shortcut(), SetShortcutRouting(): swapped last two parameters order in function signatures:
        -:  508:                            - old: Shortcut(ImGuiKeyChord key_chord, ImGuiID owner_id = 0, ImGuiInputFlags flags = 0);
        -:  509:                            - new: Shortcut(ImGuiKeyChord key_chord, ImGuiInputFlags flags = 0, ImGuiID owner_id = 0);
        -:  510:                       - inputs (internals): owner-aware versions of IsKeyPressed(), IsKeyChordPressed(), IsMouseClicked(): swapped last two parameters order in function signatures.
        -:  511:                            - old: IsKeyPressed(ImGuiKey key, ImGuiID owner_id, ImGuiInputFlags flags = 0);
        -:  512:                            - new: IsKeyPressed(ImGuiKey key, ImGuiInputFlags flags, ImGuiID owner_id = 0);
        -:  513:                            - old: IsMouseClicked(ImGuiMouseButton button, ImGuiID owner_id, ImGuiInputFlags flags = 0);
        -:  514:                            - new: IsMouseClicked(ImGuiMouseButton button, ImGuiInputFlags flags, ImGuiID owner_id = 0);
        -:  515:                         for various reasons those changes makes sense. They are being made because making some of those API public.
        -:  516:                         only past users of imgui_internal.h with the extra parameters will be affected. Added asserts for valid flags in various functions to detect _some_ misuses, BUT NOT ALL.
        -:  517: - 2024/05/21 (1.90.7) - docking: changed signature of DockSpaceOverViewport() to add explicit dockspace id if desired. pass 0 to use old behavior. (#7611)
        -:  518:                           - old: DockSpaceOverViewport(const ImGuiViewport* viewport = NULL, ImGuiDockNodeFlags flags = 0, ...);
        -:  519:                           - new: DockSpaceOverViewport(ImGuiID dockspace_id = 0, const ImGuiViewport* viewport = NULL, ImGuiDockNodeFlags flags = 0, ...);
        -:  520: - 2024/05/16 (1.90.7) - inputs: on macOS X, Cmd and Ctrl keys are now automatically swapped by io.AddKeyEvent() as this naturally align with how macOS X uses those keys.
        -:  521:                           - it shouldn't really affect you unless you had custom shortcut swapping in place for macOS X apps.
        -:  522:                           - removed ImGuiMod_Shortcut which was previously dynamically remapping to Ctrl or Cmd/Super. It is now unnecessary to specific cross-platform idiomatic shortcuts. (#2343, #4084, #5923, #456)
        -:  523: - 2024/05/14 (1.90.7) - backends: SDL_Renderer2 and SDL_Renderer3 backend now take a SDL_Renderer* in their RenderDrawData() functions.
        -:  524: - 2024/04/18 (1.90.6) - TreeNode: Fixed a layout inconsistency when using an empty/hidden label followed by a SameLine() call. (#7505, #282)
        -:  525:                           - old: TreeNode("##Hidden"); SameLine(); Text("Hello");     // <-- This was actually incorrect! BUT appeared to look ok with the default style where ItemSpacing.x == FramePadding.x * 2 (it didn't look aligned otherwise).
        -:  526:                           - new: TreeNode("##Hidden"); SameLine(0, 0); Text("Hello"); // <-- This is correct for all styles values.
        -:  527:                         with the fix, IF you were successfully using TreeNode("")+SameLine(); you will now have extra spacing between your TreeNode and the following item.
        -:  528:                         You'll need to change the SameLine() call to SameLine(0,0) to remove this extraneous spacing. This seemed like the more sensible fix that's not making things less consistent.
        -:  529:                         (Note: when using this idiom you are likely to also use ImGuiTreeNodeFlags_SpanAvailWidth).
        -:  530: - 2024/03/18 (1.90.5) - merged the radius_x/radius_y parameters in ImDrawList::AddEllipse(), AddEllipseFilled() and PathEllipticalArcTo() into a single ImVec2 parameter. Exceptionally, because those functions were added in 1.90, we are not adding inline redirection functions. The transition is easy and should affect few users. (#2743, #7417)
        -:  531: - 2024/03/08 (1.90.5) - inputs: more formally obsoleted GetKeyIndex() when IMGUI_DISABLE_OBSOLETE_FUNCTIONS is set. It has been unnecessary and a no-op since 1.87 (it returns the same value as passed when used with a 1.87+ backend using io.AddKeyEvent() function). (#4921)
        -:  532:                           - IsKeyPressed(GetKeyIndex(ImGuiKey_XXX)) -> use IsKeyPressed(ImGuiKey_XXX)
        -:  533: - 2024/01/15 (1.90.2) - commented out obsolete ImGuiIO::ImeWindowHandle marked obsolete in 1.87, favor of writing to 'void* ImGuiViewport::PlatformHandleRaw'.
        -:  534: - 2023/12/19 (1.90.1) - commented out obsolete ImGuiKey_KeyPadEnter redirection to ImGuiKey_KeypadEnter.
        -:  535: - 2023/11/06 (1.90.1) - removed CalcListClipping() marked obsolete in 1.86. Prefer using ImGuiListClipper which can return non-contiguous ranges.
        -:  536: - 2023/11/05 (1.90.1) - imgui_freetype: commented out ImGuiFreeType::BuildFontAtlas() obsoleted in 1.81. prefer using #define IMGUI_ENABLE_FREETYPE or see commented code for manual calls.
        -:  537: - 2023/11/05 (1.90.1) - internals,columns: commented out legacy ImGuiColumnsFlags_XXX symbols redirecting to ImGuiOldColumnsFlags_XXX, obsoleted from imgui_internal.h in 1.80.
        -:  538: - 2023/11/09 (1.90.0) - removed IM_OFFSETOF() macro in favor of using offsetof() available in C++11. Kept redirection define (will obsolete).
        -:  539: - 2023/11/07 (1.90.0) - removed BeginChildFrame()/EndChildFrame() in favor of using BeginChild() with the ImGuiChildFlags_FrameStyle flag. kept inline redirection function (will obsolete).
        -:  540:                         those functions were merely PushStyle/PopStyle helpers, the removal isn't so much motivated by needing to add the feature in BeginChild(), but by the necessity to avoid BeginChildFrame() signature mismatching BeginChild() signature and features.
        -:  541: - 2023/11/02 (1.90.0) - BeginChild: upgraded 'bool border = true' parameter to 'ImGuiChildFlags flags' type, added ImGuiChildFlags_Border equivalent. As with our prior "bool-to-flags" API updates, the ImGuiChildFlags_Border value is guaranteed to be == true forever to ensure a smoother transition, meaning all existing calls will still work.
        -:  542:                           - old: BeginChild("Name", size, true)
        -:  543:                           - new: BeginChild("Name", size, ImGuiChildFlags_Border)
        -:  544:                           - old: BeginChild("Name", size, false)
        -:  545:                           - new: BeginChild("Name", size) or BeginChild("Name", 0) or BeginChild("Name", size, ImGuiChildFlags_None)
        -:  546:                         **AMEND FROM THE FUTURE: from 1.91.1, 'ImGuiChildFlags_Border' is called 'ImGuiChildFlags_Borders'**
        -:  547: - 2023/11/02 (1.90.0) - BeginChild: added child-flag ImGuiChildFlags_AlwaysUseWindowPadding as a replacement for the window-flag ImGuiWindowFlags_AlwaysUseWindowPadding: the feature only ever made sense for BeginChild() anyhow.
        -:  548:                           - old: BeginChild("Name", size, 0, ImGuiWindowFlags_AlwaysUseWindowPadding);
        -:  549:                           - new: BeginChild("Name", size, ImGuiChildFlags_AlwaysUseWindowPadding, 0);
        -:  550: - 2023/09/27 (1.90.0) - io: removed io.MetricsActiveAllocations introduced in 1.63. Same as 'g.DebugMemAllocCount - g.DebugMemFreeCount' (still displayed in Metrics, unlikely to be accessed by end-user).
        -:  551: - 2023/09/26 (1.90.0) - debug tools: Renamed ShowStackToolWindow() ("Stack Tool") to ShowIDStackToolWindow() ("ID Stack Tool"), as earlier name was misleading. Kept inline redirection function. (#4631)
        -:  552: - 2023/09/15 (1.90.0) - ListBox, Combo: changed signature of "name getter" callback in old one-liner ListBox()/Combo() apis. kept inline redirection function (will obsolete).
        -:  553:                           - old: bool Combo(const char* label, int* current_item, bool (*getter)(void* user_data, int idx, const char** out_text), ...)
        -:  554:                           - new: bool Combo(const char* label, int* current_item, const char* (*getter)(void* user_data, int idx), ...);
        -:  555:                           - old: bool ListBox(const char* label, int* current_item, bool (*getting)(void* user_data, int idx, const char** out_text), ...);
        -:  556:                           - new: bool ListBox(const char* label, int* current_item, const char* (*getter)(void* user_data, int idx), ...);
        -:  557: - 2023/09/08 (1.90.0) - commented out obsolete redirecting functions:
        -:  558:                           - GetWindowContentRegionWidth()  -> use GetWindowContentRegionMax().x - GetWindowContentRegionMin().x. Consider that generally 'GetContentRegionAvail().x' is more useful.
        -:  559:                           - ImDrawCornerFlags_XXX          -> use ImDrawFlags_RoundCornersXXX flags. Read 1.82 Changelog for details + grep commented names in sources.
        -:  560:                       - commented out runtime support for hardcoded ~0 or 0x01..0x0F rounding flags values for AddRect()/AddRectFilled()/PathRect()/AddImageRounded() -> use ImDrawFlags_RoundCornersXXX flags. Read 1.82 Changelog for details
        -:  561: - 2023/08/25 (1.89.9) - clipper: Renamed IncludeRangeByIndices() (also called ForceDisplayRangeByIndices() before 1.89.6) to IncludeItemsByIndex(). Kept inline redirection function. Sorry!
        -:  562: - 2023/07/12 (1.89.8) - ImDrawData: CmdLists now owned, changed from ImDrawList** to ImVector<ImDrawList*>. Majority of users shouldn't be affected, but you cannot compare to NULL nor reassign manually anymore. Instead use AddDrawList(). (#6406, #4879, #1878)
        -:  563: - 2023/06/28 (1.89.7) - overlapping items: obsoleted 'SetItemAllowOverlap()' (called after item) in favor of calling 'SetNextItemAllowOverlap()' (called before item). 'SetItemAllowOverlap()' didn't and couldn't work reliably since 1.89 (2022-11-15).
        -:  564: - 2023/06/28 (1.89.7) - overlapping items: renamed 'ImGuiTreeNodeFlags_AllowItemOverlap' to 'ImGuiTreeNodeFlags_AllowOverlap', 'ImGuiSelectableFlags_AllowItemOverlap' to 'ImGuiSelectableFlags_AllowOverlap'. Kept redirecting enums (will obsolete).
        -:  565: - 2023/06/28 (1.89.7) - overlapping items: IsItemHovered() now by default return false when querying an item using AllowOverlap mode which is being overlapped. Use ImGuiHoveredFlags_AllowWhenOverlappedByItem to revert to old behavior.
        -:  566: - 2023/06/28 (1.89.7) - overlapping items: Selectable and TreeNode don't allow overlap when active so overlapping widgets won't appear as hovered. While this fixes a common small visual issue, it also means that calling IsItemHovered() after a non-reactive elements - e.g. Text() - overlapping an active one may fail if you don't use IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem). (#6610)
        -:  567: - 2023/06/20 (1.89.7) - moved io.HoverDelayShort/io.HoverDelayNormal to style.HoverDelayShort/style.HoverDelayNormal. As the fields were added in 1.89 and expected to be left unchanged by most users, or only tweaked once during app initialization, we are exceptionally accepting the breakage.
        -:  568: - 2023/05/30 (1.89.6) - backends: renamed "imgui_impl_sdlrenderer.cpp" to "imgui_impl_sdlrenderer2.cpp" and "imgui_impl_sdlrenderer.h" to "imgui_impl_sdlrenderer2.h". This is in prevision for the future release of SDL3.
        -:  569: - 2023/05/22 (1.89.6) - listbox: commented out obsolete/redirecting functions that were marked obsolete more than two years ago:
        -:  570:                           - ListBoxHeader()  -> use BeginListBox() (note how two variants of ListBoxHeader() existed. Check commented versions in imgui.h for reference)
        -:  571:                           - ListBoxFooter()  -> use EndListBox()
        -:  572: - 2023/05/15 (1.89.6) - clipper: commented out obsolete redirection constructor 'ImGuiListClipper(int items_count, float items_height = -1.0f)' that was marked obsolete in 1.79. Use default constructor + clipper.Begin().
        -:  573: - 2023/05/15 (1.89.6) - clipper: renamed ImGuiListClipper::ForceDisplayRangeByIndices() to ImGuiListClipper::IncludeRangeByIndices().
        -:  574: - 2023/03/14 (1.89.4) - commented out redirecting enums/functions names that were marked obsolete two years ago:
        -:  575:                           - ImGuiSliderFlags_ClampOnInput        -> use ImGuiSliderFlags_AlwaysClamp
        -:  576:                           - ImGuiInputTextFlags_AlwaysInsertMode -> use ImGuiInputTextFlags_AlwaysOverwrite
        -:  577:                           - ImDrawList::AddBezierCurve()         -> use ImDrawList::AddBezierCubic()
        -:  578:                           - ImDrawList::PathBezierCurveTo()      -> use ImDrawList::PathBezierCubicCurveTo()
        -:  579: - 2023/03/09 (1.89.4) - renamed PushAllowKeyboardFocus()/PopAllowKeyboardFocus() to PushTabStop()/PopTabStop(). Kept inline redirection functions (will obsolete).
        -:  580: - 2023/03/09 (1.89.4) - tooltips: Added 'bool' return value to BeginTooltip() for API consistency. Please only submit contents and call EndTooltip() if BeginTooltip() returns true. In reality the function will _currently_ always return true, but further changes down the line may change this, best to clarify API sooner.
        -:  581: - 2023/02/15 (1.89.4) - moved the optional "courtesy maths operators" implementation from imgui_internal.h in imgui.h.
        -:  582:                         Even though we encourage using your own maths types and operators by setting up IM_VEC2_CLASS_EXTRA,
        -:  583:                         it has been frequently requested by people to use our own. We had an opt-in define which was
        -:  584:                         previously fulfilled in imgui_internal.h. It is now fulfilled in imgui.h. (#6164)
        -:  585:                           - OK:     #define IMGUI_DEFINE_MATH_OPERATORS / #include "imgui.h" / #include "imgui_internal.h"
        -:  586:                           - Error:  #include "imgui.h" / #define IMGUI_DEFINE_MATH_OPERATORS / #include "imgui_internal.h"
        -:  587: - 2023/02/07 (1.89.3) - backends: renamed "imgui_impl_sdl.cpp" to "imgui_impl_sdl2.cpp" and "imgui_impl_sdl.h" to "imgui_impl_sdl2.h". (#6146) This is in prevision for the future release of SDL3.
        -:  588: - 2022/10/26 (1.89)   - commented out redirecting OpenPopupContextItem() which was briefly the name of OpenPopupOnItemClick() from 1.77 to 1.79.
        -:  589: - 2022/10/12 (1.89)   - removed runtime patching of invalid "%f"/"%0.f" format strings for DragInt()/SliderInt(). This was obsoleted in 1.61 (May 2018). See 1.61 changelog for details.
        -:  590: - 2022/09/26 (1.89)   - renamed and merged keyboard modifiers key enums and flags into a same set. Kept inline redirection enums (will obsolete).
        -:  591:                           - ImGuiKey_ModCtrl  and ImGuiModFlags_Ctrl  -> ImGuiMod_Ctrl
        -:  592:                           - ImGuiKey_ModShift and ImGuiModFlags_Shift -> ImGuiMod_Shift
        -:  593:                           - ImGuiKey_ModAlt   and ImGuiModFlags_Alt   -> ImGuiMod_Alt
        -:  594:                           - ImGuiKey_ModSuper and ImGuiModFlags_Super -> ImGuiMod_Super
        -:  595:                         the ImGuiKey_ModXXX were introduced in 1.87 and mostly used by backends.
        -:  596:                         the ImGuiModFlags_XXX have been exposed in imgui.h but not really used by any public api only by third-party extensions.
        -:  597:                         exceptionally commenting out the older ImGuiKeyModFlags_XXX names ahead of obsolescence schedule to reduce confusion and because they were not meant to be used anyway.
        -:  598: - 2022/09/20 (1.89)   - ImGuiKey is now a typed enum, allowing ImGuiKey_XXX symbols to be named in debuggers.
        -:  599:                         this will require uses of legacy backend-dependent indices to be casted, e.g.
        -:  600:                            - with imgui_impl_glfw:  IsKeyPressed(GLFW_KEY_A) -> IsKeyPressed((ImGuiKey)GLFW_KEY_A);
        -:  601:                            - with imgui_impl_win32: IsKeyPressed('A')        -> IsKeyPressed((ImGuiKey)'A')
        -:  602:                            - etc. However if you are upgrading code you might well use the better, backend-agnostic IsKeyPressed(ImGuiKey_A) now!
        -:  603: - 2022/09/12 (1.89) - removed the bizarre legacy default argument for 'TreePush(const void* ptr = NULL)', always pass a pointer value explicitly. NULL/nullptr is ok but require cast, e.g. TreePush((void*)nullptr);
        -:  604: - 2022/09/05 (1.89) - commented out redirecting functions/enums names that were marked obsolete in 1.77 and 1.78 (June 2020):
        -:  605:                         - DragScalar(), DragScalarN(), DragFloat(), DragFloat2(), DragFloat3(), DragFloat4(): For old signatures ending with (..., const char* format, float power = 1.0f) -> use (..., format ImGuiSliderFlags_Logarithmic) if power != 1.0f.
        -:  606:                         - SliderScalar(), SliderScalarN(), SliderFloat(), SliderFloat2(), SliderFloat3(), SliderFloat4(): For old signatures ending with (..., const char* format, float power = 1.0f) -> use (..., format ImGuiSliderFlags_Logarithmic) if power != 1.0f.
        -:  607:                         - BeginPopupContextWindow(const char*, ImGuiMouseButton, bool) -> use BeginPopupContextWindow(const char*, ImGuiPopupFlags)
        -:  608: - 2022/09/02 (1.89) - obsoleted using SetCursorPos()/SetCursorScreenPos() to extend parent window/cell boundaries.
        -:  609:                       this relates to when moving the cursor position beyond current boundaries WITHOUT submitting an item.
        -:  610:                         - previously this would make the window content size ~200x200:
        -:  611:                              Begin(...) + SetCursorScreenPos(GetCursorScreenPos() + ImVec2(200,200)) + End();
        -:  612:                         - instead, please submit an item:
        -:  613:                              Begin(...) + SetCursorScreenPos(GetCursorScreenPos() + ImVec2(200,200)) + Dummy(ImVec2(0,0)) + End();
        -:  614:                         - alternative:
        -:  615:                              Begin(...) + Dummy(ImVec2(200,200)) + End();
        -:  616:                         - content size is now only extended when submitting an item!
        -:  617:                         - with '#define IMGUI_DISABLE_OBSOLETE_FUNCTIONS' this will now be detected and assert.
        -:  618:                         - without '#define IMGUI_DISABLE_OBSOLETE_FUNCTIONS' this will silently be fixed until we obsolete it.
        -:  619: - 2022/08/03 (1.89) - changed signature of ImageButton() function. Kept redirection function (will obsolete).
        -:  620:                        - added 'const char* str_id' parameter + removed 'int frame_padding = -1' parameter.
        -:  621:                        - old signature: bool ImageButton(ImTextureID tex_id, ImVec2 size, ImVec2 uv0 = ImVec2(0,0), ImVec2 uv1 = ImVec2(1,1), int frame_padding = -1, ImVec4 bg_col = ImVec4(0,0,0,0), ImVec4 tint_col = ImVec4(1,1,1,1));
        -:  622:                          - used the ImTextureID value to create an ID. This was inconsistent with other functions, led to ID conflicts, and caused problems with engines using transient ImTextureID values.
        -:  623:                          - had a FramePadding override which was inconsistent with other functions and made the already-long signature even longer.
        -:  624:                        - new signature: bool ImageButton(const char* str_id, ImTextureID tex_id, ImVec2 size, ImVec2 uv0 = ImVec2(0,0), ImVec2 uv1 = ImVec2(1,1), ImVec4 bg_col = ImVec4(0,0,0,0), ImVec4 tint_col = ImVec4(1,1,1,1));
        -:  625:                          - requires an explicit identifier. You may still use e.g. PushID() calls and then pass an empty identifier.
        -:  626:                          - always uses style.FramePadding for padding, to be consistent with other buttons. You may use PushStyleVar() to alter this.
        -:  627: - 2022/07/08 (1.89) - inputs: removed io.NavInputs[] and ImGuiNavInput enum (following 1.87 changes).
        -:  628:                        - Official backends from 1.87+                  -> no issue.
        -:  629:                        - Official backends from 1.60 to 1.86           -> will build and convert gamepad inputs, unless IMGUI_DISABLE_OBSOLETE_KEYIO is defined. Need updating!
        -:  630:                        - Custom backends not writing to io.NavInputs[] -> no issue.
        -:  631:                        - Custom backends writing to io.NavInputs[]     -> will build and convert gamepad inputs, unless IMGUI_DISABLE_OBSOLETE_KEYIO is defined. Need fixing!
        -:  632:                        - TL;DR: Backends should call io.AddKeyEvent()/io.AddKeyAnalogEvent() with ImGuiKey_GamepadXXX values instead of filling io.NavInput[].
        -:  633: - 2022/06/15 (1.88) - renamed IMGUI_DISABLE_METRICS_WINDOW to IMGUI_DISABLE_DEBUG_TOOLS for correctness. kept support for old define (will obsolete).
        -:  634: - 2022/05/03 (1.88) - backends: osx: removed ImGui_ImplOSX_HandleEvent() from backend API in favor of backend automatically handling event capture. All ImGui_ImplOSX_HandleEvent() calls should be removed as they are now unnecessary.
        -:  635: - 2022/04/05 (1.88) - inputs: renamed ImGuiKeyModFlags to ImGuiModFlags. Kept inline redirection enums (will obsolete). This was never used in public API functions but technically present in imgui.h and ImGuiIO.
        -:  636: - 2022/01/20 (1.87) - inputs: reworded gamepad IO.
        -:  637:                        - Backend writing to io.NavInputs[]            -> backend should call io.AddKeyEvent()/io.AddKeyAnalogEvent() with ImGuiKey_GamepadXXX values.
        -:  638: - 2022/01/19 (1.87) - sliders, drags: removed support for legacy arithmetic operators (+,+-,*,/) when inputing text. This doesn't break any api/code but a feature that used to be accessible by end-users (which seemingly no one used).
        -:  639: - 2022/01/17 (1.87) - inputs: reworked mouse IO.
        -:  640:                        - Backend writing to io.MousePos               -> backend should call io.AddMousePosEvent()
        -:  641:                        - Backend writing to io.MouseDown[]            -> backend should call io.AddMouseButtonEvent()
        -:  642:                        - Backend writing to io.MouseWheel             -> backend should call io.AddMouseWheelEvent()
        -:  643:                        - Backend writing to io.MouseHoveredViewport   -> backend should call io.AddMouseViewportEvent() [Docking branch w/ multi-viewports only]
        -:  644:                       note: for all calls to IO new functions, the Dear ImGui context should be bound/current.
        -:  645:                       read https://github.com/ocornut/imgui/issues/4921 for details.
        -:  646: - 2022/01/10 (1.87) - inputs: reworked keyboard IO. Removed io.KeyMap[], io.KeysDown[] in favor of calling io.AddKeyEvent(). Removed GetKeyIndex(), now unnecessary. All IsKeyXXX() functions now take ImGuiKey values. All features are still functional until IMGUI_DISABLE_OBSOLETE_KEYIO is defined. Read Changelog and Release Notes for details.
        -:  647:                        - IsKeyPressed(MY_NATIVE_KEY_XXX)              -> use IsKeyPressed(ImGuiKey_XXX)
        -:  648:                        - IsKeyPressed(GetKeyIndex(ImGuiKey_XXX))      -> use IsKeyPressed(ImGuiKey_XXX)
        -:  649:                        - Backend writing to io.KeyMap[],io.KeysDown[] -> backend should call io.AddKeyEvent() (+ call io.SetKeyEventNativeData() if you want legacy user code to stil function with legacy key codes).
        -:  650:                        - Backend writing to io.KeyCtrl, io.KeyShift.. -> backend should call io.AddKeyEvent() with ImGuiMod_XXX values. *IF YOU PULLED CODE BETWEEN 2021/01/10 and 2021/01/27: We used to have a io.AddKeyModsEvent() function which was now replaced by io.AddKeyEvent() with ImGuiMod_XXX values.*
        -:  651:                     - one case won't work with backward compatibility: if your custom backend used ImGuiKey as mock native indices (e.g. "io.KeyMap[ImGuiKey_A] = ImGuiKey_A") because those values are now larger than the legacy KeyDown[] array. Will assert.
        -:  652:                     - inputs: added ImGuiKey_ModCtrl/ImGuiKey_ModShift/ImGuiKey_ModAlt/ImGuiKey_ModSuper values to submit keyboard modifiers using io.AddKeyEvent(), instead of writing directly to io.KeyCtrl, io.KeyShift, io.KeyAlt, io.KeySuper.
        -:  653: - 2022/01/05 (1.87) - inputs: renamed ImGuiKey_KeyPadEnter to ImGuiKey_KeypadEnter to align with new symbols. Kept redirection enum.
        -:  654: - 2022/01/05 (1.87) - removed io.ImeSetInputScreenPosFn() in favor of more flexible io.SetPlatformImeDataFn(). Removed 'void* io.ImeWindowHandle' in favor of writing to 'void* ImGuiViewport::PlatformHandleRaw'.
        -:  655: - 2022/01/01 (1.87) - commented out redirecting functions/enums names that were marked obsolete in 1.69, 1.70, 1.71, 1.72 (March-July 2019)
        -:  656:                        - ImGui::SetNextTreeNodeOpen()        -> use ImGui::SetNextItemOpen()
        -:  657:                        - ImGui::GetContentRegionAvailWidth() -> use ImGui::GetContentRegionAvail().x
        -:  658:                        - ImGui::TreeAdvanceToLabelPos()      -> use ImGui::SetCursorPosX(ImGui::GetCursorPosX() + ImGui::GetTreeNodeToLabelSpacing());
        -:  659:                        - ImFontAtlas::CustomRect             -> use ImFontAtlasCustomRect
        -:  660:                        - ImGuiColorEditFlags_RGB/HSV/HEX     -> use ImGuiColorEditFlags_DisplayRGB/HSV/Hex
        -:  661: - 2021/12/20 (1.86) - backends: removed obsolete Marmalade backend (imgui_impl_marmalade.cpp) + example. Find last supported version at https://github.com/ocornut/imgui/wiki/Bindings
        -:  662: - 2021/11/04 (1.86) - removed CalcListClipping() function. Prefer using ImGuiListClipper which can return non-contiguous ranges. Please open an issue if you think you really need this function.
        -:  663: - 2021/08/23 (1.85) - removed GetWindowContentRegionWidth() function. keep inline redirection helper. can use 'GetWindowContentRegionMax().x - GetWindowContentRegionMin().x' instead for generally 'GetContentRegionAvail().x' is more useful.
        -:  664: - 2021/07/26 (1.84) - commented out redirecting functions/enums names that were marked obsolete in 1.67 and 1.69 (March 2019):
        -:  665:                        - ImGui::GetOverlayDrawList() -> use ImGui::GetForegroundDrawList()
        -:  666:                        - ImFont::GlyphRangesBuilder  -> use ImFontGlyphRangesBuilder
        -:  667: - 2021/05/19 (1.83) - backends: obsoleted direct access to ImDrawCmd::TextureId in favor of calling ImDrawCmd::GetTexID().
        -:  668:                        - if you are using official backends from the source tree: you have nothing to do.
        -:  669:                        - if you have copied old backend code or using your own: change access to draw_cmd->TextureId to draw_cmd->GetTexID().
        -:  670: - 2021/03/12 (1.82) - upgraded ImDrawList::AddRect(), AddRectFilled(), PathRect() to use ImDrawFlags instead of ImDrawCornersFlags.
        -:  671:                        - ImDrawCornerFlags_TopLeft  -> use ImDrawFlags_RoundCornersTopLeft
        -:  672:                        - ImDrawCornerFlags_BotRight -> use ImDrawFlags_RoundCornersBottomRight
        -:  673:                        - ImDrawCornerFlags_None     -> use ImDrawFlags_RoundCornersNone etc.
        -:  674:                       flags now sanely defaults to 0 instead of 0x0F, consistent with all other flags in the API.
        -:  675:                       breaking: the default with rounding > 0.0f is now "round all corners" vs old implicit "round no corners":
        -:  676:                        - rounding == 0.0f + flags == 0 --> meant no rounding  --> unchanged (common use)
        -:  677:                        - rounding  > 0.0f + flags != 0 --> meant rounding     --> unchanged (common use)
        -:  678:                        - rounding == 0.0f + flags != 0 --> meant no rounding  --> unchanged (unlikely use)
        -:  679:                        - rounding  > 0.0f + flags == 0 --> meant no rounding  --> BREAKING (unlikely use): will now round all corners --> use ImDrawFlags_RoundCornersNone or rounding == 0.0f.
        -:  680:                       this ONLY matters for hard coded use of 0 + rounding > 0.0f. Use of named ImDrawFlags_RoundCornersNone (new) or ImDrawCornerFlags_None (old) are ok.
        -:  681:                       the old ImDrawCornersFlags used awkward default values of ~0 or 0xF (4 lower bits set) to signify "round all corners" and we sometimes encouraged using them as shortcuts.
        -:  682:                       legacy path still support use of hard coded ~0 or any value from 0x1 or 0xF. They will behave the same with legacy paths enabled (will assert otherwise).
        -:  683: - 2021/03/11 (1.82) - removed redirecting functions/enums names that were marked obsolete in 1.66 (September 2018):
        -:  684:                        - ImGui::SetScrollHere()              -> use ImGui::SetScrollHereY()
        -:  685: - 2021/03/11 (1.82) - clarified that ImDrawList::PathArcTo(), ImDrawList::PathArcToFast() won't render with radius < 0.0f. Previously it sorts of accidentally worked but would generally lead to counter-clockwise paths and have an effect on anti-aliasing.
        -:  686: - 2021/03/10 (1.82) - upgraded ImDrawList::AddPolyline() and PathStroke() "bool closed" parameter to "ImDrawFlags flags". The matching ImDrawFlags_Closed value is guaranteed to always stay == 1 in the future.
        -:  687: - 2021/02/22 (1.82) - (*undone in 1.84*) win32+mingw: Re-enabled IME functions by default even under MinGW. In July 2016, issue #738 had me incorrectly disable those default functions for MinGW. MinGW users should: either link with -limm32, either set their imconfig file  with '#define IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS'.
        -:  688: - 2021/02/17 (1.82) - renamed rarely used style.CircleSegmentMaxError (old default = 1.60f) to style.CircleTessellationMaxError (new default = 0.30f) as the meaning of the value changed.
        -:  689: - 2021/02/03 (1.81) - renamed ListBoxHeader(const char* label, ImVec2 size) to BeginListBox(). Kept inline redirection function (will obsolete).
        -:  690:                     - removed ListBoxHeader(const char* label, int items_count, int height_in_items = -1) in favor of specifying size. Kept inline redirection function (will obsolete).
        -:  691:                     - renamed ListBoxFooter() to EndListBox(). Kept inline redirection function (will obsolete).
        -:  692: - 2021/01/26 (1.81) - removed ImGuiFreeType::BuildFontAtlas(). Kept inline redirection function. Prefer using '#define IMGUI_ENABLE_FREETYPE', but there's a runtime selection path available too. The shared extra flags parameters (very rarely used) are now stored in ImFontAtlas::FontBuilderFlags.
        -:  693:                     - renamed ImFontConfig::RasterizerFlags (used by FreeType) to ImFontConfig::FontBuilderFlags.
        -:  694:                     - renamed ImGuiFreeType::XXX flags to ImGuiFreeTypeBuilderFlags_XXX for consistency with other API.
        -:  695: - 2020/10/12 (1.80) - removed redirecting functions/enums that were marked obsolete in 1.63 (August 2018):
        -:  696:                        - ImGui::IsItemDeactivatedAfterChange() -> use ImGui::IsItemDeactivatedAfterEdit().
        -:  697:                        - ImGuiCol_ModalWindowDarkening       -> use ImGuiCol_ModalWindowDimBg
        -:  698:                        - ImGuiInputTextCallback              -> use ImGuiTextEditCallback
        -:  699:                        - ImGuiInputTextCallbackData          -> use ImGuiTextEditCallbackData
        -:  700: - 2020/12/21 (1.80) - renamed ImDrawList::AddBezierCurve() to AddBezierCubic(), and PathBezierCurveTo() to PathBezierCubicCurveTo(). Kept inline redirection function (will obsolete).
        -:  701: - 2020/12/04 (1.80) - added imgui_tables.cpp file! Manually constructed project files will need the new file added!
        -:  702: - 2020/11/18 (1.80) - renamed undocumented/internals ImGuiColumnsFlags_* to ImGuiOldColumnFlags_* in prevision of incoming Tables API.
        -:  703: - 2020/11/03 (1.80) - renamed io.ConfigWindowsMemoryCompactTimer to io.ConfigMemoryCompactTimer as the feature will apply to other data structures
        -:  704: - 2020/10/14 (1.80) - backends: moved all backends files (imgui_impl_XXXX.cpp, imgui_impl_XXXX.h) from examples/ to backends/.
        -:  705: - 2020/10/12 (1.80) - removed redirecting functions/enums that were marked obsolete in 1.60 (April 2018):
        -:  706:                        - io.RenderDrawListsFn pointer        -> use ImGui::GetDrawData() value and call the render function of your backend
        -:  707:                        - ImGui::IsAnyWindowFocused()         -> use ImGui::IsWindowFocused(ImGuiFocusedFlags_AnyWindow)
        -:  708:                        - ImGui::IsAnyWindowHovered()         -> use ImGui::IsWindowHovered(ImGuiHoveredFlags_AnyWindow)
        -:  709:                        - ImGuiStyleVar_Count_                -> use ImGuiStyleVar_COUNT
        -:  710:                        - ImGuiMouseCursor_Count_             -> use ImGuiMouseCursor_COUNT
        -:  711:                      - removed redirecting functions names that were marked obsolete in 1.61 (May 2018):
        -:  712:                        - InputFloat (... int decimal_precision ...) -> use InputFloat (... const char* format ...) with format = "%.Xf" where X is your value for decimal_precision.
        -:  713:                        - same for InputFloat2()/InputFloat3()/InputFloat4() variants taking a `int decimal_precision` parameter.
        -:  714: - 2020/10/05 (1.79) - removed ImGuiListClipper: Renamed constructor parameters which created an ambiguous alternative to using the ImGuiListClipper::Begin() function, with misleading edge cases (note: imgui_memory_editor <0.40 from imgui_club/ used this old clipper API. Update your copy if needed).
        -:  715: - 2020/09/25 (1.79) - renamed ImGuiSliderFlags_ClampOnInput to ImGuiSliderFlags_AlwaysClamp. Kept redirection enum (will obsolete sooner because previous name was added recently).
        -:  716: - 2020/09/25 (1.79) - renamed style.TabMinWidthForUnselectedCloseButton to style.TabMinWidthForCloseButton.
        -:  717: - 2020/09/21 (1.79) - renamed OpenPopupContextItem() back to OpenPopupOnItemClick(), reverting the change from 1.77. For varieties of reason this is more self-explanatory.
        -:  718: - 2020/09/21 (1.79) - removed return value from OpenPopupOnItemClick() - returned true on mouse release on an item - because it is inconsistent with other popup APIs and makes others misleading. It's also and unnecessary: you can use IsWindowAppearing() after BeginPopup() for a similar result.
        -:  719: - 2020/09/17 (1.79) - removed ImFont::DisplayOffset in favor of ImFontConfig::GlyphOffset. DisplayOffset was applied after scaling and not very meaningful/useful outside of being needed by the default ProggyClean font. If you scaled this value after calling AddFontDefault(), this is now done automatically. It was also getting in the way of better font scaling, so let's get rid of it now!
        -:  720: - 2020/08/17 (1.78) - obsoleted use of the trailing 'float power=1.0f' parameter for DragFloat(), DragFloat2(), DragFloat3(), DragFloat4(), DragFloatRange2(), DragScalar(), DragScalarN(), SliderFloat(), SliderFloat2(), SliderFloat3(), SliderFloat4(), SliderScalar(), SliderScalarN(), VSliderFloat() and VSliderScalar().
        -:  721:                       replaced the 'float power=1.0f' argument with integer-based flags defaulting to 0 (as with all our flags).
        -:  722:                       worked out a backward-compatibility scheme so hopefully most C++ codebase should not be affected. in short, when calling those functions:
        -:  723:                       - if you omitted the 'power' parameter (likely!), you are not affected.
        -:  724:                       - if you set the 'power' parameter to 1.0f (same as previous default value): 1/ your compiler may warn on float>int conversion, 2/ everything else will work. 3/ you can replace the 1.0f value with 0 to fix the warning, and be technically correct.
        -:  725:                       - if you set the 'power' parameter to >1.0f (to enable non-linear editing): 1/ your compiler may warn on float>int conversion, 2/ code will assert at runtime, 3/ in case asserts are disabled, the code will not crash and enable the _Logarithmic flag. 4/ you can replace the >1.0f value with ImGuiSliderFlags_Logarithmic to fix the warning/assert and get a _similar_ effect as previous uses of power >1.0f.
        -:  726:                       see https://github.com/ocornut/imgui/issues/3361 for all details.
        -:  727:                       kept inline redirection functions (will obsolete) apart for: DragFloatRange2(), VSliderFloat(), VSliderScalar(). For those three the 'float power=1.0f' version was removed directly as they were most unlikely ever used.
        -:  728:                       for shared code, you can version check at compile-time with `#if IMGUI_VERSION_NUM >= 17704`.
        -:  729:                     - obsoleted use of v_min > v_max in DragInt, DragFloat, DragScalar to lock edits (introduced in 1.73, was not demoed nor documented very), will be replaced by a more generic ReadOnly feature. You may use the ImGuiSliderFlags_ReadOnly internal flag in the meantime.
        -:  730: - 2020/06/23 (1.77) - removed BeginPopupContextWindow(const char*, int mouse_button, bool also_over_items) in favor of BeginPopupContextWindow(const char*, ImGuiPopupFlags flags) with ImGuiPopupFlags_NoOverItems.
        -:  731: - 2020/06/15 (1.77) - renamed OpenPopupOnItemClick() to OpenPopupContextItem(). Kept inline redirection function (will obsolete). [NOTE: THIS WAS REVERTED IN 1.79]
        -:  732: - 2020/06/15 (1.77) - removed CalcItemRectClosestPoint() entry point which was made obsolete and asserting in December 2017.
        -:  733: - 2020/04/23 (1.77) - removed unnecessary ID (first arg) of ImFontAtlas::AddCustomRectRegular().
        -:  734: - 2020/01/22 (1.75) - ImDrawList::AddCircle()/AddCircleFilled() functions don't accept negative radius any more.
        -:  735: - 2019/12/17 (1.75) - [undid this change in 1.76] made Columns() limited to 64 columns by asserting above that limit. While the current code technically supports it, future code may not so we're putting the restriction ahead.
        -:  736: - 2019/12/13 (1.75) - [imgui_internal.h] changed ImRect() default constructor initializes all fields to 0.0f instead of (FLT_MAX,FLT_MAX,-FLT_MAX,-FLT_MAX). If you used ImRect::Add() to create bounding boxes by adding multiple points into it, you may need to fix your initial value.
        -:  737: - 2019/12/08 (1.75) - removed redirecting functions/enums that were marked obsolete in 1.53 (December 2017):
        -:  738:                       - ShowTestWindow()                    -> use ShowDemoWindow()
        -:  739:                       - IsRootWindowFocused()               -> use IsWindowFocused(ImGuiFocusedFlags_RootWindow)
        -:  740:                       - IsRootWindowOrAnyChildFocused()     -> use IsWindowFocused(ImGuiFocusedFlags_RootAndChildWindows)
        -:  741:                       - SetNextWindowContentWidth(w)        -> use SetNextWindowContentSize(ImVec2(w, 0.0f)
        -:  742:                       - GetItemsLineHeightWithSpacing()     -> use GetFrameHeightWithSpacing()
        -:  743:                       - ImGuiCol_ChildWindowBg              -> use ImGuiCol_ChildBg
        -:  744:                       - ImGuiStyleVar_ChildWindowRounding   -> use ImGuiStyleVar_ChildRounding
        -:  745:                       - ImGuiTreeNodeFlags_AllowOverlapMode -> use ImGuiTreeNodeFlags_AllowItemOverlap
        -:  746:                       - IMGUI_DISABLE_TEST_WINDOWS          -> use IMGUI_DISABLE_DEMO_WINDOWS
        -:  747: - 2019/12/08 (1.75) - obsoleted calling ImDrawList::PrimReserve() with a negative count (which was vaguely documented and rarely if ever used). Instead, we added an explicit PrimUnreserve() API.
        -:  748: - 2019/12/06 (1.75) - removed implicit default parameter to IsMouseDragging(int button = 0) to be consistent with other mouse functions (none of the other functions have it).
        -:  749: - 2019/11/21 (1.74) - ImFontAtlas::AddCustomRectRegular() now requires an ID larger than 0x110000 (instead of 0x10000) to conform with supporting Unicode planes 1-16 in a future update. ID below 0x110000 will now assert.
        -:  750: - 2019/11/19 (1.74) - renamed IMGUI_DISABLE_FORMAT_STRING_FUNCTIONS to IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS for consistency.
        -:  751: - 2019/11/19 (1.74) - renamed IMGUI_DISABLE_MATH_FUNCTIONS to IMGUI_DISABLE_DEFAULT_MATH_FUNCTIONS for consistency.
        -:  752: - 2019/10/22 (1.74) - removed redirecting functions/enums that were marked obsolete in 1.52 (October 2017):
        -:  753:                       - Begin() [old 5 args version]        -> use Begin() [3 args], use SetNextWindowSize() SetNextWindowBgAlpha() if needed
        -:  754:                       - IsRootWindowOrAnyChildHovered()     -> use IsWindowHovered(ImGuiHoveredFlags_RootAndChildWindows)
        -:  755:                       - AlignFirstTextHeightToWidgets()     -> use AlignTextToFramePadding()
        -:  756:                       - SetNextWindowPosCenter()            -> use SetNextWindowPos() with a pivot of (0.5f, 0.5f)
        -:  757:                       - ImFont::Glyph                       -> use ImFontGlyph
        -:  758: - 2019/10/14 (1.74) - inputs: Fixed a miscalculation in the keyboard/mouse "typematic" repeat delay/rate calculation, used by keys and e.g. repeating mouse buttons as well as the GetKeyPressedAmount() function.
        -:  759:                       if you were using a non-default value for io.KeyRepeatRate (previous default was 0.250), you can add +io.KeyRepeatDelay to it to compensate for the fix.
        -:  760:                       The function was triggering on: 0.0 and (delay+rate*N) where (N>=1). Fixed formula responds to (N>=0). Effectively it made io.KeyRepeatRate behave like it was set to (io.KeyRepeatRate + io.KeyRepeatDelay).
        -:  761:                       If you never altered io.KeyRepeatRate nor used GetKeyPressedAmount() this won't affect you.
        -:  762: - 2019/07/15 (1.72) - removed TreeAdvanceToLabelPos() which is rarely used and only does SetCursorPosX(GetCursorPosX() + GetTreeNodeToLabelSpacing()). Kept redirection function (will obsolete).
        -:  763: - 2019/07/12 (1.72) - renamed ImFontAtlas::CustomRect to ImFontAtlasCustomRect. Kept redirection typedef (will obsolete).
        -:  764: - 2019/06/14 (1.72) - removed redirecting functions/enums names that were marked obsolete in 1.51 (June 2017): ImGuiCol_Column*, ImGuiSetCond_*, IsItemHoveredRect(), IsPosHoveringAnyWindow(), IsMouseHoveringAnyWindow(), IsMouseHoveringWindow(), IMGUI_ONCE_UPON_A_FRAME. Grep this log for details and new names, or see how they were implemented until 1.71.
        -:  765: - 2019/06/07 (1.71) - rendering of child window outer decorations (bg color, border, scrollbars) is now performed as part of the parent window. If you have
        -:  766:                       overlapping child windows in a same parent, and relied on their relative z-order to be mapped to their submission order, this will affect your rendering.
        -:  767:                       This optimization is disabled if the parent window has no visual output, because it appears to be the most common situation leading to the creation of overlapping child windows.
        -:  768:                       Please reach out if you are affected.
        -:  769: - 2019/05/13 (1.71) - renamed SetNextTreeNodeOpen() to SetNextItemOpen(). Kept inline redirection function (will obsolete).
        -:  770: - 2019/05/11 (1.71) - changed io.AddInputCharacter(unsigned short c) signature to io.AddInputCharacter(unsigned int c).
        -:  771: - 2019/04/29 (1.70) - improved ImDrawList thick strokes (>1.0f) preserving correct thickness up to 90 degrees angles (e.g. rectangles). If you have custom rendering using thick lines, they will appear thicker now.
        -:  772: - 2019/04/29 (1.70) - removed GetContentRegionAvailWidth(), use GetContentRegionAvail().x instead. Kept inline redirection function (will obsolete).
        -:  773: - 2019/03/04 (1.69) - renamed GetOverlayDrawList() to GetForegroundDrawList(). Kept redirection function (will obsolete).
        -:  774: - 2019/02/26 (1.69) - renamed ImGuiColorEditFlags_RGB/ImGuiColorEditFlags_HSV/ImGuiColorEditFlags_HEX to ImGuiColorEditFlags_DisplayRGB/ImGuiColorEditFlags_DisplayHSV/ImGuiColorEditFlags_DisplayHex. Kept redirection enums (will obsolete).
        -:  775: - 2019/02/14 (1.68) - made it illegal/assert when io.DisplayTime == 0.0f (with an exception for the first frame). If for some reason your time step calculation gives you a zero value, replace it with an arbitrarily small value!
        -:  776: - 2019/02/01 (1.68) - removed io.DisplayVisibleMin/DisplayVisibleMax (which were marked obsolete and removed from viewport/docking branch already).
        -:  777: - 2019/01/06 (1.67) - renamed io.InputCharacters[], marked internal as was always intended. Please don't access directly, and use AddInputCharacter() instead!
        -:  778: - 2019/01/06 (1.67) - renamed ImFontAtlas::GlyphRangesBuilder to ImFontGlyphRangesBuilder. Kept redirection typedef (will obsolete).
        -:  779: - 2018/12/20 (1.67) - made it illegal to call Begin("") with an empty string. This somehow half-worked before but had various undesirable side-effects.
        -:  780: - 2018/12/10 (1.67) - renamed io.ConfigResizeWindowsFromEdges to io.ConfigWindowsResizeFromEdges as we are doing a large pass on configuration flags.
        -:  781: - 2018/10/12 (1.66) - renamed misc/stl/imgui_stl.* to misc/cpp/imgui_stdlib.* in prevision for other C++ helper files.
        -:  782: - 2018/09/28 (1.66) - renamed SetScrollHere() to SetScrollHereY(). Kept redirection function (will obsolete).
        -:  783: - 2018/09/06 (1.65) - renamed stb_truetype.h to imstb_truetype.h, stb_textedit.h to imstb_textedit.h, and stb_rect_pack.h to imstb_rectpack.h.
        -:  784:                       If you were conveniently using the imgui copy of those STB headers in your project you will have to update your include paths.
        -:  785: - 2018/09/05 (1.65) - renamed io.OptCursorBlink/io.ConfigCursorBlink to io.ConfigInputTextCursorBlink. (#1427)
        -:  786: - 2018/08/31 (1.64) - added imgui_widgets.cpp file, extracted and moved widgets code out of imgui.cpp into imgui_widgets.cpp. Re-ordered some of the code remaining in imgui.cpp.
        -:  787:                       NONE OF THE FUNCTIONS HAVE CHANGED. THE CODE IS SEMANTICALLY 100% IDENTICAL, BUT _EVERY_ FUNCTION HAS BEEN MOVED.
        -:  788:                       Because of this, any local modifications to imgui.cpp will likely conflict when you update. Read docs/CHANGELOG.txt for suggestions.
        -:  789: - 2018/08/22 (1.63) - renamed IsItemDeactivatedAfterChange() to IsItemDeactivatedAfterEdit() for consistency with new IsItemEdited() API. Kept redirection function (will obsolete soonish as IsItemDeactivatedAfterChange() is very recent).
        -:  790: - 2018/08/21 (1.63) - renamed ImGuiTextEditCallback to ImGuiInputTextCallback, ImGuiTextEditCallbackData to ImGuiInputTextCallbackData for consistency. Kept redirection types (will obsolete).
        -:  791: - 2018/08/21 (1.63) - removed ImGuiInputTextCallbackData::ReadOnly since it is a duplication of (ImGuiInputTextCallbackData::Flags & ImGuiInputTextFlags_ReadOnly).
        -:  792: - 2018/08/01 (1.63) - removed per-window ImGuiWindowFlags_ResizeFromAnySide beta flag in favor of a global io.ConfigResizeWindowsFromEdges [update 1.67 renamed to ConfigWindowsResizeFromEdges] to enable the feature.
        -:  793: - 2018/08/01 (1.63) - renamed io.OptCursorBlink to io.ConfigCursorBlink [-> io.ConfigInputTextCursorBlink in 1.65], io.OptMacOSXBehaviors to ConfigMacOSXBehaviors for consistency.
        -:  794: - 2018/07/22 (1.63) - changed ImGui::GetTime() return value from float to double to avoid accumulating floating point imprecisions over time.
        -:  795: - 2018/07/08 (1.63) - style: renamed ImGuiCol_ModalWindowDarkening to ImGuiCol_ModalWindowDimBg for consistency with other features. Kept redirection enum (will obsolete).
        -:  796: - 2018/06/08 (1.62) - examples: the imgui_impl_XXX files have been split to separate platform (Win32, GLFW, SDL2, etc.) from renderer (DX11, OpenGL, Vulkan,  etc.).
        -:  797:                       old backends will still work as is, however prefer using the separated backends as they will be updated to support multi-viewports.
        -:  798:                       when adopting new backends follow the main.cpp code of your preferred examples/ folder to know which functions to call.
        -:  799:                       in particular, note that old backends called ImGui::NewFrame() at the end of their ImGui_ImplXXXX_NewFrame() function.
        -:  800: - 2018/06/06 (1.62) - renamed GetGlyphRangesChinese() to GetGlyphRangesChineseFull() to distinguish other variants and discourage using the full set.
        -:  801: - 2018/06/06 (1.62) - TreeNodeEx()/TreeNodeBehavior(): the ImGuiTreeNodeFlags_CollapsingHeader helper now include the ImGuiTreeNodeFlags_NoTreePushOnOpen flag. See Changelog for details.
        -:  802: - 2018/05/03 (1.61) - DragInt(): the default compile-time format string has been changed from "%.0f" to "%d", as we are not using integers internally any more.
        -:  803:                       If you used DragInt() with custom format strings, make sure you change them to use %d or an integer-compatible format.
        -:  804:                       To honor backward-compatibility, the DragInt() code will currently parse and modify format strings to replace %*f with %d, giving time to users to upgrade their code.
        -:  805:                       If you have IMGUI_DISABLE_OBSOLETE_FUNCTIONS enabled, the code will instead assert! You may run a reg-exp search on your codebase for e.g. "DragInt.*%f" to help you find them.
        -:  806: - 2018/04/28 (1.61) - obsoleted InputFloat() functions taking an optional "int decimal_precision" in favor of an equivalent and more flexible "const char* format",
        -:  807:                       consistent with other functions. Kept redirection functions (will obsolete).
        -:  808: - 2018/04/09 (1.61) - IM_DELETE() helper function added in 1.60 doesn't clear the input _pointer_ reference, more consistent with expectation and allows passing r-value.
        -:  809: - 2018/03/20 (1.60) - renamed io.WantMoveMouse to io.WantSetMousePos for consistency and ease of understanding (was added in 1.52, _not_ used by core and only honored by some backend ahead of merging the Nav branch).
        -:  810: - 2018/03/12 (1.60) - removed ImGuiCol_CloseButton, ImGuiCol_CloseButtonActive, ImGuiCol_CloseButtonHovered as the closing cross uses regular button colors now.
        -:  811: - 2018/03/08 (1.60) - changed ImFont::DisplayOffset.y to default to 0 instead of +1. Fixed rounding of Ascent/Descent to match TrueType renderer. If you were adding or subtracting to ImFont::DisplayOffset check if your fonts are correctly aligned vertically.
        -:  812: - 2018/03/03 (1.60) - renamed ImGuiStyleVar_Count_ to ImGuiStyleVar_COUNT and ImGuiMouseCursor_Count_ to ImGuiMouseCursor_COUNT for consistency with other public enums.
        -:  813: - 2018/02/18 (1.60) - BeginDragDropSource(): temporarily removed the optional mouse_button=0 parameter because it is not really usable in many situations at the moment.
        -:  814: - 2018/02/16 (1.60) - obsoleted the io.RenderDrawListsFn callback, you can call your graphics engine render function after ImGui::Render(). Use ImGui::GetDrawData() to retrieve the ImDrawData* to display.
        -:  815: - 2018/02/07 (1.60) - reorganized context handling to be more explicit,
        -:  816:                       - YOU NOW NEED TO CALL ImGui::CreateContext() AT THE BEGINNING OF YOUR APP, AND CALL ImGui::DestroyContext() AT THE END.
        -:  817:                       - removed Shutdown() function, as DestroyContext() serve this purpose.
        -:  818:                       - you may pass a ImFontAtlas* pointer to CreateContext() to share a font atlas between contexts. Otherwise CreateContext() will create its own font atlas instance.
        -:  819:                       - removed allocator parameters from CreateContext(), they are now setup with SetAllocatorFunctions(), and shared by all contexts.
        -:  820:                       - removed the default global context and font atlas instance, which were confusing for users of DLL reloading and users of multiple contexts.
        -:  821: - 2018/01/31 (1.60) - moved sample TTF files from extra_fonts/ to misc/fonts/. If you loaded files directly from the imgui repo you may need to update your paths.
        -:  822: - 2018/01/11 (1.60) - obsoleted IsAnyWindowHovered() in favor of IsWindowHovered(ImGuiHoveredFlags_AnyWindow). Kept redirection function (will obsolete).
        -:  823: - 2018/01/11 (1.60) - obsoleted IsAnyWindowFocused() in favor of IsWindowFocused(ImGuiFocusedFlags_AnyWindow). Kept redirection function (will obsolete).
        -:  824: - 2018/01/03 (1.60) - renamed ImGuiSizeConstraintCallback to ImGuiSizeCallback, ImGuiSizeConstraintCallbackData to ImGuiSizeCallbackData.
        -:  825: - 2017/12/29 (1.60) - removed CalcItemRectClosestPoint() which was weird and not really used by anyone except demo code. If you need it it's easy to replicate on your side.
        -:  826: - 2017/12/24 (1.53) - renamed the emblematic ShowTestWindow() function to ShowDemoWindow(). Kept redirection function (will obsolete).
        -:  827: - 2017/12/21 (1.53) - ImDrawList: renamed style.AntiAliasedShapes to style.AntiAliasedFill for consistency and as a way to explicitly break code that manipulate those flag at runtime. You can now manipulate ImDrawList::Flags
        -:  828: - 2017/12/21 (1.53) - ImDrawList: removed 'bool anti_aliased = true' final parameter of ImDrawList::AddPolyline() and ImDrawList::AddConvexPolyFilled(). Prefer manipulating ImDrawList::Flags if you need to toggle them during the frame.
        -:  829: - 2017/12/14 (1.53) - using the ImGuiWindowFlags_NoScrollWithMouse flag on a child window forwards the mouse wheel event to the parent window, unless either ImGuiWindowFlags_NoInputs or ImGuiWindowFlags_NoScrollbar are also set.
        -:  830: - 2017/12/13 (1.53) - renamed GetItemsLineHeightWithSpacing() to GetFrameHeightWithSpacing(). Kept redirection function (will obsolete).
        -:  831: - 2017/12/13 (1.53) - obsoleted IsRootWindowFocused() in favor of using IsWindowFocused(ImGuiFocusedFlags_RootWindow). Kept redirection function (will obsolete).
        -:  832:                     - obsoleted IsRootWindowOrAnyChildFocused() in favor of using IsWindowFocused(ImGuiFocusedFlags_RootAndChildWindows). Kept redirection function (will obsolete).
        -:  833: - 2017/12/12 (1.53) - renamed ImGuiTreeNodeFlags_AllowOverlapMode to ImGuiTreeNodeFlags_AllowItemOverlap. Kept redirection enum (will obsolete).
        -:  834: - 2017/12/10 (1.53) - removed SetNextWindowContentWidth(), prefer using SetNextWindowContentSize(). Kept redirection function (will obsolete).
        -:  835: - 2017/11/27 (1.53) - renamed ImGuiTextBuffer::append() helper to appendf(), appendv() to appendfv(). If you copied the 'Log' demo in your code, it uses appendv() so that needs to be renamed.
        -:  836: - 2017/11/18 (1.53) - Style, Begin: removed ImGuiWindowFlags_ShowBorders window flag. Borders are now fully set up in the ImGuiStyle structure (see e.g. style.FrameBorderSize, style.WindowBorderSize). Use ImGui::ShowStyleEditor() to look them up.
        -:  837:                       Please note that the style system will keep evolving (hopefully stabilizing in Q1 2018), and so custom styles will probably subtly break over time. It is recommended you use the StyleColorsClassic(), StyleColorsDark(), StyleColorsLight() functions.
        -:  838: - 2017/11/18 (1.53) - Style: removed ImGuiCol_ComboBg in favor of combo boxes using ImGuiCol_PopupBg for consistency.
        -:  839: - 2017/11/18 (1.53) - Style: renamed ImGuiCol_ChildWindowBg to ImGuiCol_ChildBg.
        -:  840: - 2017/11/18 (1.53) - Style: renamed style.ChildWindowRounding to style.ChildRounding, ImGuiStyleVar_ChildWindowRounding to ImGuiStyleVar_ChildRounding.
        -:  841: - 2017/11/02 (1.53) - obsoleted IsRootWindowOrAnyChildHovered() in favor of using IsWindowHovered(ImGuiHoveredFlags_RootAndChildWindows);
        -:  842: - 2017/10/24 (1.52) - renamed IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCS/IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCS to IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS/IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS for consistency.
        -:  843: - 2017/10/20 (1.52) - changed IsWindowHovered() default parameters behavior to return false if an item is active in another window (e.g. click-dragging item from another window to this window). You can use the newly introduced IsWindowHovered() flags to requests this specific behavior if you need it.
        -:  844: - 2017/10/20 (1.52) - marked IsItemHoveredRect()/IsMouseHoveringWindow() as obsolete, in favor of using the newly introduced flags for IsItemHovered() and IsWindowHovered(). See https://github.com/ocornut/imgui/issues/1382 for details.
        -:  845:                       removed the IsItemRectHovered()/IsWindowRectHovered() names introduced in 1.51 since they were merely more consistent names for the two functions we are now obsoleting.
        -:  846:                         IsItemHoveredRect()        --> IsItemHovered(ImGuiHoveredFlags_RectOnly)
        -:  847:                         IsMouseHoveringAnyWindow() --> IsWindowHovered(ImGuiHoveredFlags_AnyWindow)
        -:  848:                         IsMouseHoveringWindow()    --> IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem) [weird, old behavior]
        -:  849: - 2017/10/17 (1.52) - marked the old 5-parameters version of Begin() as obsolete (still available). Use SetNextWindowSize()+Begin() instead!
        -:  850: - 2017/10/11 (1.52) - renamed AlignFirstTextHeightToWidgets() to AlignTextToFramePadding(). Kept inline redirection function (will obsolete).
        -:  851: - 2017/09/26 (1.52) - renamed ImFont::Glyph to ImFontGlyph. Kept redirection typedef (will obsolete).
        -:  852: - 2017/09/25 (1.52) - removed SetNextWindowPosCenter() because SetNextWindowPos() now has the optional pivot information to do the same and more. Kept redirection function (will obsolete).
        -:  853: - 2017/08/25 (1.52) - io.MousePos needs to be set to ImVec2(-FLT_MAX,-FLT_MAX) when mouse is unavailable/missing. Previously ImVec2(-1,-1) was enough but we now accept negative mouse coordinates. In your backend if you need to support unavailable mouse, make sure to replace "io.MousePos = ImVec2(-1,-1)" with "io.MousePos = ImVec2(-FLT_MAX,-FLT_MAX)".
        -:  854: - 2017/08/22 (1.51) - renamed IsItemHoveredRect() to IsItemRectHovered(). Kept inline redirection function (will obsolete). -> (1.52) use IsItemHovered(ImGuiHoveredFlags_RectOnly)!
        -:  855:                     - renamed IsMouseHoveringAnyWindow() to IsAnyWindowHovered() for consistency. Kept inline redirection function (will obsolete).
        -:  856:                     - renamed IsMouseHoveringWindow() to IsWindowRectHovered() for consistency. Kept inline redirection function (will obsolete).
        -:  857: - 2017/08/20 (1.51) - renamed GetStyleColName() to GetStyleColorName() for consistency.
        -:  858: - 2017/08/20 (1.51) - added PushStyleColor(ImGuiCol idx, ImU32 col) overload, which _might_ cause an "ambiguous call" compilation error if you are using ImColor() with implicit cast. Cast to ImU32 or ImVec4 explicily to fix.
        -:  859: - 2017/08/15 (1.51) - marked the weird IMGUI_ONCE_UPON_A_FRAME helper macro as obsolete. prefer using the more explicit ImGuiOnceUponAFrame type.
        -:  860: - 2017/08/15 (1.51) - changed parameter order for BeginPopupContextWindow() from (const char*,int buttons,bool also_over_items) to (const char*,int buttons,bool also_over_items). Note that most calls relied on default parameters completely.
        -:  861: - 2017/08/13 (1.51) - renamed ImGuiCol_Column to ImGuiCol_Separator, ImGuiCol_ColumnHovered to ImGuiCol_SeparatorHovered, ImGuiCol_ColumnActive to ImGuiCol_SeparatorActive. Kept redirection enums (will obsolete).
        -:  862: - 2017/08/11 (1.51) - renamed ImGuiSetCond_Always to ImGuiCond_Always, ImGuiSetCond_Once to ImGuiCond_Once, ImGuiSetCond_FirstUseEver to ImGuiCond_FirstUseEver, ImGuiSetCond_Appearing to ImGuiCond_Appearing. Kept redirection enums (will obsolete).
        -:  863: - 2017/08/09 (1.51) - removed ValueColor() helpers, they are equivalent to calling Text(label) + SameLine() + ColorButton().
        -:  864: - 2017/08/08 (1.51) - removed ColorEditMode() and ImGuiColorEditMode in favor of ImGuiColorEditFlags and parameters to the various Color*() functions. The SetColorEditOptions() allows to initialize default but the user can still change them with right-click context menu.
        -:  865:                     - changed prototype of 'ColorEdit4(const char* label, float col[4], bool show_alpha = true)' to 'ColorEdit4(const char* label, float col[4], ImGuiColorEditFlags flags = 0)', where passing flags = 0x01 is a safe no-op (hello dodgy backward compatibility!). - check and run the demo window, under "Color/Picker Widgets", to understand the various new options.
        -:  866:                     - changed prototype of rarely used 'ColorButton(ImVec4 col, bool small_height = false, bool outline_border = true)' to 'ColorButton(const char* desc_id, ImVec4 col, ImGuiColorEditFlags flags = 0, ImVec2 size = ImVec2(0, 0))'
        -:  867: - 2017/07/20 (1.51) - removed IsPosHoveringAnyWindow(ImVec2), which was partly broken and misleading. ASSERT + redirect user to io.WantCaptureMouse
        -:  868: - 2017/05/26 (1.50) - removed ImFontConfig::MergeGlyphCenterV in favor of a more multipurpose ImFontConfig::GlyphOffset.
        -:  869: - 2017/05/01 (1.50) - renamed ImDrawList::PathFill() (rarely used directly) to ImDrawList::PathFillConvex() for clarity.
        -:  870: - 2016/11/06 (1.50) - BeginChild(const char*) now applies the stack id to the provided label, consistently with other functions as it should always have been. It shouldn't affect you unless (extremely unlikely) you were appending multiple times to a same child from different locations of the stack id. If that's the case, generate an id with GetID() and use it instead of passing string to BeginChild().
        -:  871: - 2016/10/15 (1.50) - avoid 'void* user_data' parameter to io.SetClipboardTextFn/io.GetClipboardTextFn pointers. We pass io.ClipboardUserData to it.
        -:  872: - 2016/09/25 (1.50) - style.WindowTitleAlign is now a ImVec2 (ImGuiAlign enum was removed). set to (0.5f,0.5f) for horizontal+vertical centering, (0.0f,0.0f) for upper-left, etc.
        -:  873: - 2016/07/30 (1.50) - SameLine(x) with x>0.0f is now relative to left of column/group if any, and not always to left of window. This was sort of always the intent and hopefully, breakage should be minimal.
        -:  874: - 2016/05/12 (1.49) - title bar (using ImGuiCol_TitleBg/ImGuiCol_TitleBgActive colors) isn't rendered over a window background (ImGuiCol_WindowBg color) anymore.
        -:  875:                       If your TitleBg/TitleBgActive alpha was 1.0f or you are using the default theme it will not affect you, otherwise if <1.0f you need to tweak your custom theme to readjust for the fact that we don't draw a WindowBg background behind the title bar.
        -:  876:                       This helper function will convert an old TitleBg/TitleBgActive color into a new one with the same visual output, given the OLD color and the OLD WindowBg color:
        -:  877:                       ImVec4 ConvertTitleBgCol(const ImVec4& win_bg_col, const ImVec4& title_bg_col) { float new_a = 1.0f - ((1.0f - win_bg_col.w) * (1.0f - title_bg_col.w)), k = title_bg_col.w / new_a; return ImVec4((win_bg_col.x * win_bg_col.w + title_bg_col.x) * k, (win_bg_col.y * win_bg_col.w + title_bg_col.y) * k, (win_bg_col.z * win_bg_col.w + title_bg_col.z) * k, new_a); }
        -:  878:                       If this is confusing, pick the RGB value from title bar from an old screenshot and apply this as TitleBg/TitleBgActive. Or you may just create TitleBgActive from a tweaked TitleBg color.
        -:  879: - 2016/05/07 (1.49) - removed confusing set of GetInternalState(), GetInternalStateSize(), SetInternalState() functions. Now using CreateContext(), DestroyContext(), GetCurrentContext(), SetCurrentContext().
        -:  880: - 2016/05/02 (1.49) - renamed SetNextTreeNodeOpened() to SetNextTreeNodeOpen(), no redirection.
        -:  881: - 2016/05/01 (1.49) - obsoleted old signature of CollapsingHeader(const char* label, const char* str_id = NULL, bool display_frame = true, bool default_open = false) as extra parameters were badly designed and rarely used. You can replace the "default_open = true" flag in new API with CollapsingHeader(label, ImGuiTreeNodeFlags_DefaultOpen).
        -:  882: - 2016/04/26 (1.49) - changed ImDrawList::PushClipRect(ImVec4 rect) to ImDrawList::PushClipRect(Imvec2 min,ImVec2 max,bool intersect_with_current_clip_rect=false). Note that higher-level ImGui::PushClipRect() is preferable because it will clip at logic/widget level, whereas ImDrawList::PushClipRect() only affect your renderer.
        -:  883: - 2016/04/03 (1.48) - removed style.WindowFillAlphaDefault setting which was redundant. Bake default BG alpha inside style.Colors[ImGuiCol_WindowBg] and all other Bg color values. (ref GitHub issue #337).
        -:  884: - 2016/04/03 (1.48) - renamed ImGuiCol_TooltipBg to ImGuiCol_PopupBg, used by popups/menus and tooltips. popups/menus were previously using ImGuiCol_WindowBg. (ref github issue #337)
        -:  885: - 2016/03/21 (1.48) - renamed GetWindowFont() to GetFont(), GetWindowFontSize() to GetFontSize(). Kept inline redirection function (will obsolete).
        -:  886: - 2016/03/02 (1.48) - InputText() completion/history/always callbacks: if you modify the text buffer manually (without using DeleteChars()/InsertChars() helper) you need to maintain the BufTextLen field. added an assert.
        -:  887: - 2016/01/23 (1.48) - fixed not honoring exact width passed to PushItemWidth(), previously it would add extra FramePadding.x*2 over that width. if you had manual pixel-perfect alignment in place it might affect you.
        -:  888: - 2015/12/27 (1.48) - fixed ImDrawList::AddRect() which used to render a rectangle 1 px too large on each axis.
        -:  889: - 2015/12/04 (1.47) - renamed Color() helpers to ValueColor() - dangerously named, rarely used and probably to be made obsolete.
        -:  890: - 2015/08/29 (1.45) - with the addition of horizontal scrollbar we made various fixes to inconsistencies with dealing with cursor position.
        -:  891:                       GetCursorPos()/SetCursorPos() functions now include the scrolled amount. It shouldn't affect the majority of users, but take note that SetCursorPosX(100.0f) puts you at +100 from the starting x position which may include scrolling, not at +100 from the window left side.
        -:  892:                       GetContentRegionMax()/GetWindowContentRegionMin()/GetWindowContentRegionMax() functions allow include the scrolled amount. Typically those were used in cases where no scrolling would happen so it may not be a problem, but watch out!
        -:  893: - 2015/08/29 (1.45) - renamed style.ScrollbarWidth to style.ScrollbarSize
        -:  894: - 2015/08/05 (1.44) - split imgui.cpp into extra files: imgui_demo.cpp imgui_draw.cpp imgui_internal.h that you need to add to your project.
        -:  895: - 2015/07/18 (1.44) - fixed angles in ImDrawList::PathArcTo(), PathArcToFast() (introduced in 1.43) being off by an extra PI for no justifiable reason
        -:  896: - 2015/07/14 (1.43) - add new ImFontAtlas::AddFont() API. For the old AddFont***, moved the 'font_no' parameter of ImFontAtlas::AddFont** functions to the ImFontConfig structure.
        -:  897:                       you need to render your textured triangles with bilinear filtering to benefit from sub-pixel positioning of text.
        -:  898: - 2015/07/08 (1.43) - switched rendering data to use indexed rendering. this is saving a fair amount of CPU/GPU and enables us to get anti-aliasing for a marginal cost.
        -:  899:                       this necessary change will break your rendering function! the fix should be very easy. sorry for that :(
        -:  900:                     - if you are using a vanilla copy of one of the imgui_impl_XXX.cpp provided in the example, you just need to update your copy and you can ignore the rest.
        -:  901:                     - the signature of the io.RenderDrawListsFn handler has changed!
        -:  902:                       old: ImGui_XXXX_RenderDrawLists(ImDrawList** const cmd_lists, int cmd_lists_count)
        -:  903:                       new: ImGui_XXXX_RenderDrawLists(ImDrawData* draw_data).
        -:  904:                         parameters: 'cmd_lists' becomes 'draw_data->CmdLists', 'cmd_lists_count' becomes 'draw_data->CmdListsCount'
        -:  905:                         ImDrawList: 'commands' becomes 'CmdBuffer', 'vtx_buffer' becomes 'VtxBuffer', 'IdxBuffer' is new.
        -:  906:                         ImDrawCmd:  'vtx_count' becomes 'ElemCount', 'clip_rect' becomes 'ClipRect', 'user_callback' becomes 'UserCallback', 'texture_id' becomes 'TextureId'.
        -:  907:                     - each ImDrawList now contains both a vertex buffer and an index buffer. For each command, render ElemCount/3 triangles using indices from the index buffer.
        -:  908:                     - if you REALLY cannot render indexed primitives, you can call the draw_data->DeIndexAllBuffers() method to de-index the buffers. This is slow and a waste of CPU/GPU. Prefer using indexed rendering!
        -:  909:                     - refer to code in the examples/ folder or ask on the GitHub if you are unsure of how to upgrade. please upgrade!
        -:  910: - 2015/07/10 (1.43) - changed SameLine() parameters from int to float.
        -:  911: - 2015/07/02 (1.42) - renamed SetScrollPosHere() to SetScrollFromCursorPos(). Kept inline redirection function (will obsolete).
        -:  912: - 2015/07/02 (1.42) - renamed GetScrollPosY() to GetScrollY(). Necessary to reduce confusion along with other scrolling functions, because positions (e.g. cursor position) are not equivalent to scrolling amount.
        -:  913: - 2015/06/14 (1.41) - changed ImageButton() default bg_col parameter from (0,0,0,1) (black) to (0,0,0,0) (transparent) - makes a difference when texture have transparence
        -:  914: - 2015/06/14 (1.41) - changed Selectable() API from (label, selected, size) to (label, selected, flags, size). Size override should have been rarely used. Sorry!
        -:  915: - 2015/05/31 (1.40) - renamed GetWindowCollapsed() to IsWindowCollapsed() for consistency. Kept inline redirection function (will obsolete).
        -:  916: - 2015/05/31 (1.40) - renamed IsRectClipped() to IsRectVisible() for consistency. Note that return value is opposite! Kept inline redirection function (will obsolete).
        -:  917: - 2015/05/27 (1.40) - removed the third 'repeat_if_held' parameter from Button() - sorry! it was rarely used and inconsistent. Use PushButtonRepeat(true) / PopButtonRepeat() to enable repeat on desired buttons.
        -:  918: - 2015/05/11 (1.40) - changed BeginPopup() API, takes a string identifier instead of a bool. ImGui needs to manage the open/closed state of popups. Call OpenPopup() to actually set the "open" state of a popup. BeginPopup() returns true if the popup is opened.
        -:  919: - 2015/05/03 (1.40) - removed style.AutoFitPadding, using style.WindowPadding makes more sense (the default values were already the same).
        -:  920: - 2015/04/13 (1.38) - renamed IsClipped() to IsRectClipped(). Kept inline redirection function until 1.50.
        -:  921: - 2015/04/09 (1.38) - renamed ImDrawList::AddArc() to ImDrawList::AddArcFast() for compatibility with future API
        -:  922: - 2015/04/03 (1.38) - removed ImGuiCol_CheckHovered, ImGuiCol_CheckActive, replaced with the more general ImGuiCol_FrameBgHovered, ImGuiCol_FrameBgActive.
        -:  923: - 2014/04/03 (1.38) - removed support for passing -FLT_MAX..+FLT_MAX as the range for a SliderFloat(). Use DragFloat() or Inputfloat() instead.
        -:  924: - 2015/03/17 (1.36) - renamed GetItemBoxMin()/GetItemBoxMax()/IsMouseHoveringBox() to GetItemRectMin()/GetItemRectMax()/IsMouseHoveringRect(). Kept inline redirection function until 1.50.
        -:  925: - 2015/03/15 (1.36) - renamed style.TreeNodeSpacing to style.IndentSpacing, ImGuiStyleVar_TreeNodeSpacing to ImGuiStyleVar_IndentSpacing
        -:  926: - 2015/03/13 (1.36) - renamed GetWindowIsFocused() to IsWindowFocused(). Kept inline redirection function until 1.50.
        -:  927: - 2015/03/08 (1.35) - renamed style.ScrollBarWidth to style.ScrollbarWidth (casing)
        -:  928: - 2015/02/27 (1.34) - renamed OpenNextNode(bool) to SetNextTreeNodeOpened(bool, ImGuiSetCond). Kept inline redirection function until 1.50.
        -:  929: - 2015/02/27 (1.34) - renamed ImGuiSetCondition_*** to ImGuiSetCond_***, and _FirstUseThisSession becomes _Once.
        -:  930: - 2015/02/11 (1.32) - changed text input callback ImGuiTextEditCallback return type from void-->int. reserved for future use, return 0 for now.
        -:  931: - 2015/02/10 (1.32) - renamed GetItemWidth() to CalcItemWidth() to clarify its evolving behavior
        -:  932: - 2015/02/08 (1.31) - renamed GetTextLineSpacing() to GetTextLineHeightWithSpacing()
        -:  933: - 2015/02/01 (1.31) - removed IO.MemReallocFn (unused)
        -:  934: - 2015/01/19 (1.30) - renamed ImGuiStorage::GetIntPtr()/GetFloatPtr() to GetIntRef()/GetIntRef() because Ptr was conflicting with actual pointer storage functions.
        -:  935: - 2015/01/11 (1.30) - big font/image API change! now loads TTF file. allow for multiple fonts. no need for a PNG loader.
        -:  936: - 2015/01/11 (1.30) - removed GetDefaultFontData(). uses io.Fonts->GetTextureData*() API to retrieve uncompressed pixels.
        -:  937:                       - old:  const void* png_data; unsigned int png_size; ImGui::GetDefaultFontData(NULL, NULL, &png_data, &png_size); [..Upload texture to GPU..];
        -:  938:                       - new:  unsigned char* pixels; int width, height; io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height); [..Upload texture to GPU..]; io.Fonts->SetTexID(YourTexIdentifier);
        -:  939:                       you now have more flexibility to load multiple TTF fonts and manage the texture buffer for internal needs. It is now recommended that you sample the font texture with bilinear interpolation.
        -:  940: - 2015/01/11 (1.30) - added texture identifier in ImDrawCmd passed to your render function (we can now render images). make sure to call io.Fonts->SetTexID()
        -:  941: - 2015/01/11 (1.30) - removed IO.PixelCenterOffset (unnecessary, can be handled in user projection matrix)
        -:  942: - 2015/01/11 (1.30) - removed ImGui::IsItemFocused() in favor of ImGui::IsItemActive() which handles all widgets
        -:  943: - 2014/12/10 (1.18) - removed SetNewWindowDefaultPos() in favor of new generic API SetNextWindowPos(pos, ImGuiSetCondition_FirstUseEver)
        -:  944: - 2014/11/28 (1.17) - moved IO.Font*** options to inside the IO.Font-> structure (FontYOffset, FontTexUvForWhite, FontBaseScale, FontFallbackGlyph)
        -:  945: - 2014/11/26 (1.17) - reworked syntax of IMGUI_ONCE_UPON_A_FRAME helper macro to increase compiler compatibility
        -:  946: - 2014/11/07 (1.15) - renamed IsHovered() to IsItemHovered()
        -:  947: - 2014/10/02 (1.14) - renamed IMGUI_INCLUDE_IMGUI_USER_CPP to IMGUI_INCLUDE_IMGUI_USER_INL and imgui_user.cpp to imgui_user.inl (more IDE friendly)
        -:  948: - 2014/09/25 (1.13) - removed 'text_end' parameter from IO.SetClipboardTextFn (the string is now always zero-terminated for simplicity)
        -:  949: - 2014/09/24 (1.12) - renamed SetFontScale() to SetWindowFontScale()
        -:  950: - 2014/09/24 (1.12) - moved IM_MALLOC/IM_REALLOC/IM_FREE preprocessor defines to IO.MemAllocFn/IO.MemReallocFn/IO.MemFreeFn
        -:  951: - 2014/08/30 (1.09) - removed IO.FontHeight (now computed automatically)
        -:  952: - 2014/08/30 (1.09) - moved IMGUI_FONT_TEX_UV_FOR_WHITE preprocessor define to IO.FontTexUvForWhite
        -:  953: - 2014/08/28 (1.09) - changed the behavior of IO.PixelCenterOffset following various rendering fixes
        -:  954:
        -:  955:
        -:  956: FREQUENTLY ASKED QUESTIONS (FAQ)
        -:  957: ================================
        -:  958:
        -:  959: Read all answers online:
        -:  960:   https://www.dearimgui.com/faq or https://github.com/ocornut/imgui/blob/master/docs/FAQ.md (same url)
        -:  961: Read all answers locally (with a text editor or ideally a Markdown viewer):
        -:  962:   docs/FAQ.md
        -:  963: Some answers are copied down here to facilitate searching in code.
        -:  964:
        -:  965: Q&A: Basics
        -:  966: ===========
        -:  967:
        -:  968: Q: Where is the documentation?
        -:  969: A: This library is poorly documented at the moment and expects the user to be acquainted with C/C++.
        -:  970:    - Run the examples/ applications and explore them.
        -:  971:    - Read Getting Started (https://github.com/ocornut/imgui/wiki/Getting-Started) guide.
        -:  972:    - See demo code in imgui_demo.cpp and particularly the ImGui::ShowDemoWindow() function.
        -:  973:    - The demo covers most features of Dear ImGui, so you can read the code and see its output.
        -:  974:    - See documentation and comments at the top of imgui.cpp + effectively imgui.h.
        -:  975:    - 20+ standalone example applications using e.g. OpenGL/DirectX are provided in the
        -:  976:      examples/ folder to explain how to integrate Dear ImGui with your own engine/application.
        -:  977:    - The Wiki (https://github.com/ocornut/imgui/wiki) has many resources and links.
        -:  978:    - The Glossary (https://github.com/ocornut/imgui/wiki/Glossary) page also may be useful.
        -:  979:    - Your programming IDE is your friend, find the type or function declaration to find comments
        -:  980:      associated with it.
        -:  981:
        -:  982: Q: What is this library called?
        -:  983: Q: Which version should I get?
        -:  984: >> This library is called "Dear ImGui", please don't call it "ImGui" :)
        -:  985: >> See https://www.dearimgui.com/faq for details.
        -:  986:
        -:  987: Q&A: Integration
        -:  988: ================
        -:  989:
        -:  990: Q: How to get started?
        -:  991: A: Read https://github.com/ocornut/imgui/wiki/Getting-Started. Read 'PROGRAMMER GUIDE' above. Read examples/README.txt.
        -:  992:
        -:  993: Q: How can I tell whether to dispatch mouse/keyboard to Dear ImGui or my application?
        -:  994: A: You should read the 'io.WantCaptureMouse', 'io.WantCaptureKeyboard' and 'io.WantTextInput' flags!
        -:  995: >> See https://www.dearimgui.com/faq for a fully detailed answer. You really want to read this.
        -:  996:
        -:  997: Q. How can I enable keyboard or gamepad controls?
        -:  998: Q: How can I use this on a machine without mouse, keyboard or screen? (input share, remote display)
        -:  999: Q: I integrated Dear ImGui in my engine and little squares are showing instead of text...
        -: 1000: Q: I integrated Dear ImGui in my engine and some elements are clipping or disappearing when I move windows around...
        -: 1001: Q: I integrated Dear ImGui in my engine and some elements are displaying outside their expected windows boundaries...
        -: 1002: >> See https://www.dearimgui.com/faq
        -: 1003:
        -: 1004: Q&A: Usage
        -: 1005: ----------
        -: 1006:
        -: 1007: Q: About the ID Stack system..
        -: 1008:   - Why is my widget not reacting when I click on it?
        -: 1009:   - How can I have widgets with an empty label?
        -: 1010:   - How can I have multiple widgets with the same label?
        -: 1011:   - How can I have multiple windows with the same label?
        -: 1012: Q: How can I display an image? What is ImTextureID, how does it work?
        -: 1013: Q: How can I use my own math types instead of ImVec2?
        -: 1014: Q: How can I interact with standard C++ types (such as std::string and std::vector)?
        -: 1015: Q: How can I display custom shapes? (using low-level ImDrawList API)
        -: 1016: >> See https://www.dearimgui.com/faq
        -: 1017:
        -: 1018: Q&A: Fonts, Text
        -: 1019: ================
        -: 1020:
        -: 1021: Q: How should I handle DPI in my application?
        -: 1022: Q: How can I load a different font than the default?
        -: 1023: Q: How can I easily use icons in my application?
        -: 1024: Q: How can I load multiple fonts?
        -: 1025: Q: How can I display and input non-Latin characters such as Chinese, Japanese, Korean, Cyrillic?
        -: 1026: >> See https://www.dearimgui.com/faq and https://github.com/ocornut/imgui/blob/master/docs/FONTS.md
        -: 1027:
        -: 1028: Q&A: Concerns
        -: 1029: =============
        -: 1030:
        -: 1031: Q: Who uses Dear ImGui?
        -: 1032: Q: Can you create elaborate/serious tools with Dear ImGui?
        -: 1033: Q: Can you reskin the look of Dear ImGui?
        -: 1034: Q: Why using C++ (as opposed to C)?
        -: 1035: >> See https://www.dearimgui.com/faq
        -: 1036:
        -: 1037: Q&A: Community
        -: 1038: ==============
        -: 1039:
        -: 1040: Q: How can I help?
        -: 1041: A: - Businesses: please reach out to "omar AT dearimgui DOT com" if you work in a place using Dear ImGui!
        -: 1042:      We can discuss ways for your company to fund development via invoiced technical support, maintenance or sponsoring contacts.
        -: 1043:      This is among the most useful thing you can do for Dear ImGui. With increased funding, we sustain and grow work on this project.
        -: 1044:      >>> See https://github.com/ocornut/imgui/wiki/Funding
        -: 1045:    - Businesses: you can also purchase licenses for the Dear ImGui Automation/Test Engine.
        -: 1046:    - If you are experienced with Dear ImGui and C++, look at the GitHub issues, look at the Wiki, and see how you want to help and can help!
        -: 1047:    - Disclose your usage of Dear ImGui via a dev blog post, a tweet, a screenshot, a mention somewhere etc.
        -: 1048:      You may post screenshot or links in the gallery threads. Visuals are ideal as they inspire other programmers.
        -: 1049:      But even without visuals, disclosing your use of dear imgui helps the library grow credibility, and help other teams and programmers with taking decisions.
        -: 1050:    - If you have issues or if you need to hack into the library, even if you don't expect any support it is useful that you share your issues (on GitHub or privately).
        -: 1051:
        -: 1052:*/
        -: 1053:
        -: 1054://-------------------------------------------------------------------------
        -: 1055:// [SECTION] INCLUDES
        -: 1056://-------------------------------------------------------------------------
        -: 1057:
        -: 1058:#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
        -: 1059:#define _CRT_SECURE_NO_WARNINGS
        -: 1060:#endif
        -: 1061:
        -: 1062:#ifndef IMGUI_DEFINE_MATH_OPERATORS
        -: 1063:#define IMGUI_DEFINE_MATH_OPERATORS
        -: 1064:#endif
        -: 1065:
        -: 1066:#include "imgui.h"
        -: 1067:#ifndef IMGUI_DISABLE
        -: 1068:#include "imgui_internal.h"
        -: 1069:
        -: 1070:// System includes
        -: 1071:#include <stdio.h>      // vsnprintf, sscanf, printf
        -: 1072:#include <stdint.h>     // intptr_t
        -: 1073:
        -: 1074:// [Windows] On non-Visual Studio compilers, we default to IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS unless explicitly enabled
        -: 1075:#if defined(_WIN32) && !defined(_MSC_VER) && !defined(IMGUI_ENABLE_WIN32_DEFAULT_IME_FUNCTIONS) && !defined(IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS)
        -: 1076:#define IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS
        -: 1077:#endif
        -: 1078:
        -: 1079:// [Windows] OS specific includes (optional)
        -: 1080:#if defined(_WIN32) && defined(IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS) && defined(IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS) && defined(IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS) && defined(IMGUI_DISABLE_DEFAULT_SHELL_FUNCTIONS) && !defined(IMGUI_DISABLE_WIN32_FUNCTIONS)
        -: 1081:#define IMGUI_DISABLE_WIN32_FUNCTIONS
        -: 1082:#endif
        -: 1083:#if defined(_WIN32) && !defined(IMGUI_DISABLE_WIN32_FUNCTIONS)
        -: 1084:#ifndef WIN32_LEAN_AND_MEAN
        -: 1085:#define WIN32_LEAN_AND_MEAN
        -: 1086:#endif
        -: 1087:#ifndef NOMINMAX
        -: 1088:#define NOMINMAX
        -: 1089:#endif
        -: 1090:#ifndef __MINGW32__
        -: 1091:#include <Windows.h>        // _wfopen, OpenClipboard
        -: 1092:#else
        -: 1093:#include <windows.h>
        -: 1094:#endif
        -: 1095:#if defined(WINAPI_FAMILY) && (WINAPI_FAMILY == WINAPI_FAMILY_APP || WINAPI_FAMILY == WINAPI_FAMILY_GAMES)
        -: 1096:// The UWP and GDK Win32 API subsets don't support clipboard nor IME functions
        -: 1097:#define IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS
        -: 1098:#define IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS
        -: 1099:#define IMGUI_DISABLE_DEFAULT_SHELL_FUNCTIONS
        -: 1100:#endif
        -: 1101:#endif
        -: 1102:
        -: 1103:// [Apple] OS specific includes
        -: 1104:#if defined(__APPLE__)
        -: 1105:#include <TargetConditionals.h>
        -: 1106:#endif
        -: 1107:
        -: 1108:// Visual Studio warnings
        -: 1109:#ifdef _MSC_VER
        -: 1110:#pragma warning (disable: 4127)             // condition expression is constant
        -: 1111:#pragma warning (disable: 4996)             // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen
        -: 1112:#if defined(_MSC_VER) && _MSC_VER >= 1922   // MSVC 2019 16.2 or later
        -: 1113:#pragma warning (disable: 5054)             // operator '|': deprecated between enumerations of different types
        -: 1114:#endif
        -: 1115:#pragma warning (disable: 26451)            // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to an 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).
        -: 1116:#pragma warning (disable: 26495)            // [Static Analyzer] Variable 'XXX' is uninitialized. Always initialize a member variable (type.6).
        -: 1117:#pragma warning (disable: 26812)            // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3).
        -: 1118:#endif
        -: 1119:
        -: 1120:// Clang/GCC warnings with -Weverything
        -: 1121:#if defined(__clang__)
        -: 1122:#if __has_warning("-Wunknown-warning-option")
        -: 1123:#pragma clang diagnostic ignored "-Wunknown-warning-option"         // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!
        -: 1124:#endif
        -: 1125:#pragma clang diagnostic ignored "-Wunknown-pragmas"                // warning: unknown warning group 'xxx'
        -: 1126:#pragma clang diagnostic ignored "-Wold-style-cast"                 // warning: use of old-style cast                            // yes, they are more terse.
        -: 1127:#pragma clang diagnostic ignored "-Wfloat-equal"                    // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants (typically 0.0f) is ok.
        -: 1128:#pragma clang diagnostic ignored "-Wformat-nonliteral"              // warning: format string is not a string literal            // passing non-literal to vsnformat(). yes, user passing incorrect format strings can crash the code.
        -: 1129:#pragma clang diagnostic ignored "-Wexit-time-destructors"          // warning: declaration requires an exit-time destructor     // exit-time destruction order is undefined. if MemFree() leads to users code that has been disabled before exit it might cause problems. ImGui coding style welcomes static/globals.
        -: 1130:#pragma clang diagnostic ignored "-Wglobal-constructors"            // warning: declaration requires a global destructor         // similar to above, not sure what the exact difference is.
        -: 1131:#pragma clang diagnostic ignored "-Wsign-conversion"                // warning: implicit conversion changes signedness
        -: 1132:#pragma clang diagnostic ignored "-Wformat-pedantic"                // warning: format specifies type 'void *' but the argument has type 'xxxx *' // unreasonable, would lead to casting every %p arg to void*. probably enabled by -pedantic.
        -: 1133:#pragma clang diagnostic ignored "-Wint-to-void-pointer-cast"       // warning: cast to 'void *' from smaller integer type 'int'
        -: 1134:#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"  // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0
        -: 1135:#pragma clang diagnostic ignored "-Wdouble-promotion"               // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.
        -: 1136:#pragma clang diagnostic ignored "-Wimplicit-int-float-conversion"  // warning: implicit conversion from 'xxx' to 'float' may lose precision
        -: 1137:#pragma clang diagnostic ignored "-Wunsafe-buffer-usage"            // warning: 'xxx' is an unsafe pointer used for buffer access
        -: 1138:#elif defined(__GNUC__)
        -: 1139:// We disable -Wpragmas because GCC doesn't provide a has_warning equivalent and some forks/patches may not follow the warning/version association.
        -: 1140:#pragma GCC diagnostic ignored "-Wpragmas"                  // warning: unknown option after '#pragma GCC diagnostic' kind
        -: 1141:#pragma GCC diagnostic ignored "-Wunused-function"          // warning: 'xxxx' defined but not used
        -: 1142:#pragma GCC diagnostic ignored "-Wint-to-pointer-cast"      // warning: cast to pointer from integer of different size
        -: 1143:#pragma GCC diagnostic ignored "-Wformat"                   // warning: format '%p' expects argument of type 'void*', but argument 6 has type 'ImGuiWindow*'
        -: 1144:#pragma GCC diagnostic ignored "-Wdouble-promotion"         // warning: implicit conversion from 'float' to 'double' when passing argument to function
        -: 1145:#pragma GCC diagnostic ignored "-Wconversion"               // warning: conversion to 'xxxx' from 'xxxx' may alter its value
        -: 1146:#pragma GCC diagnostic ignored "-Wformat-nonliteral"        // warning: format not a string literal, format string not checked
        -: 1147:#pragma GCC diagnostic ignored "-Wstrict-overflow"          // warning: assuming signed overflow does not occur when assuming that (X - c) > X is always false
        -: 1148:#pragma GCC diagnostic ignored "-Wclass-memaccess"          // [__GNUC__ >= 8] warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead
        -: 1149:#endif
        -: 1150:
        -: 1151:// Debug options
        -: 1152:#define IMGUI_DEBUG_NAV_SCORING     0   // Display navigation scoring preview when hovering items. Hold CTRL to display for all candidates. CTRL+Arrow to change last direction.
        -: 1153:#define IMGUI_DEBUG_NAV_RECTS       0   // Display the reference navigation rectangle for each window
        -: 1154:
        -: 1155:// When using CTRL+TAB (or Gamepad Square+L/R) we delay the visual a little in order to reduce visual noise doing a fast switch.
        -: 1156:static const float NAV_WINDOWING_HIGHLIGHT_DELAY            = 0.20f;    // Time before the highlight and screen dimming starts fading in
        -: 1157:static const float NAV_WINDOWING_LIST_APPEAR_DELAY          = 0.15f;    // Time before the window list starts to appear
        -: 1158:
        -: 1159:static const float NAV_ACTIVATE_HIGHLIGHT_TIMER             = 0.10f;    // Time to highlight an item activated by a shortcut.
        -: 1160:
        -: 1161:// Window resizing from edges (when io.ConfigWindowsResizeFromEdges = true and ImGuiBackendFlags_HasMouseCursors is set in io.BackendFlags by backend)
        -: 1162:static const float WINDOWS_HOVER_PADDING                    = 4.0f;     // Extend outside window for hovering/resizing (maxxed with TouchPadding) and inside windows for borders. Affect FindHoveredWindow().
        -: 1163:static const float WINDOWS_RESIZE_FROM_EDGES_FEEDBACK_TIMER = 0.04f;    // Reduce visual noise by only highlighting the border after a certain time.
        -: 1164:static const float WINDOWS_MOUSE_WHEEL_SCROLL_LOCK_TIMER    = 0.70f;    // Lock scrolled window (so it doesn't pick child windows that are scrolling through) for a certain time, unless mouse moved.
        -: 1165:
        -: 1166:// Tooltip offset
        -: 1167:static const ImVec2 TOOLTIP_DEFAULT_OFFSET_MOUSE = ImVec2(16, 10);      // Multiplied by g.Style.MouseCursorScale
        -: 1168:static const ImVec2 TOOLTIP_DEFAULT_OFFSET_TOUCH = ImVec2(0, -20);      // Multiplied by g.Style.MouseCursorScale
        -: 1169:static const ImVec2 TOOLTIP_DEFAULT_PIVOT_TOUCH = ImVec2(0.5f, 1.0f);   // Multiplied by g.Style.MouseCursorScale
        -: 1170:
        -: 1171:// Docking
        -: 1172:static const float DOCKING_TRANSPARENT_PAYLOAD_ALPHA        = 0.50f;    // For use with io.ConfigDockingTransparentPayload. Apply to Viewport _or_ WindowBg in host viewport.
        -: 1173:
        -: 1174://-------------------------------------------------------------------------
        -: 1175:// [SECTION] FORWARD DECLARATIONS
        -: 1176://-------------------------------------------------------------------------
        -: 1177:
        -: 1178:static void             SetCurrentWindow(ImGuiWindow* window);
        -: 1179:static ImGuiWindow*     CreateNewWindow(const char* name, ImGuiWindowFlags flags);
        -: 1180:static ImVec2           CalcNextScrollFromScrollTargetAndClamp(ImGuiWindow* window);
        -: 1181:
        -: 1182:static void             AddWindowToSortBuffer(ImVector<ImGuiWindow*>* out_sorted_windows, ImGuiWindow* window);
        -: 1183:
        -: 1184:// Settings
        -: 1185:static void             WindowSettingsHandler_ClearAll(ImGuiContext*, ImGuiSettingsHandler*);
        -: 1186:static void*            WindowSettingsHandler_ReadOpen(ImGuiContext*, ImGuiSettingsHandler*, const char* name);
        -: 1187:static void             WindowSettingsHandler_ReadLine(ImGuiContext*, ImGuiSettingsHandler*, void* entry, const char* line);
        -: 1188:static void             WindowSettingsHandler_ApplyAll(ImGuiContext*, ImGuiSettingsHandler*);
        -: 1189:static void             WindowSettingsHandler_WriteAll(ImGuiContext*, ImGuiSettingsHandler*, ImGuiTextBuffer* buf);
        -: 1190:
        -: 1191:// Platform Dependents default implementation for ImGuiPlatformIO functions
        -: 1192:static const char*      Platform_GetClipboardTextFn_DefaultImpl(ImGuiContext* ctx);
        -: 1193:static void             Platform_SetClipboardTextFn_DefaultImpl(ImGuiContext* ctx, const char* text);
        -: 1194:static void             Platform_SetImeDataFn_DefaultImpl(ImGuiContext* ctx, ImGuiViewport* viewport, ImGuiPlatformImeData* data);
        -: 1195:static bool             Platform_OpenInShellFn_DefaultImpl(ImGuiContext* ctx, const char* path);
        -: 1196:
        -: 1197:namespace ImGui
        -: 1198:{
        -: 1199:// Item
        -: 1200:static void             ItemHandleShortcut(ImGuiID id);
        -: 1201:
        -: 1202:// Navigation
        -: 1203:static void             NavUpdate();
        -: 1204:static void             NavUpdateWindowing();
        -: 1205:static void             NavUpdateWindowingOverlay();
        -: 1206:static void             NavUpdateCancelRequest();
        -: 1207:static void             NavUpdateCreateMoveRequest();
        -: 1208:static void             NavUpdateCreateTabbingRequest();
        -: 1209:static float            NavUpdatePageUpPageDown();
        -: 1210:static inline void      NavUpdateAnyRequestFlag();
        -: 1211:static void             NavUpdateCreateWrappingRequest();
        -: 1212:static void             NavEndFrame();
        -: 1213:static bool             NavScoreItem(ImGuiNavItemData* result);
        -: 1214:static void             NavApplyItemToResult(ImGuiNavItemData* result);
        -: 1215:static void             NavProcessItem();
        -: 1216:static void             NavProcessItemForTabbingRequest(ImGuiID id, ImGuiItemFlags item_flags, ImGuiNavMoveFlags move_flags);
        -: 1217:static ImGuiInputSource NavCalcPreferredRefPosSource();
        -: 1218:static ImVec2           NavCalcPreferredRefPos();
        -: 1219:static void             NavSaveLastChildNavWindowIntoParent(ImGuiWindow* nav_window);
        -: 1220:static ImGuiWindow*     NavRestoreLastChildNavWindow(ImGuiWindow* window);
        -: 1221:static void             NavRestoreLayer(ImGuiNavLayer layer);
        -: 1222:static int              FindWindowFocusIndex(ImGuiWindow* window);
        -: 1223:
        -: 1224:// Error Checking and Debug Tools
        -: 1225:static void             ErrorCheckNewFrameSanityChecks();
        -: 1226:static void             ErrorCheckEndFrameSanityChecks();
        -: 1227:static void             UpdateDebugToolItemPicker();
        -: 1228:static void             UpdateDebugToolStackQueries();
        -: 1229:static void             UpdateDebugToolFlashStyleColor();
        -: 1230:
        -: 1231:// Inputs
        -: 1232:static void             UpdateKeyboardInputs();
        -: 1233:static void             UpdateMouseInputs();
        -: 1234:static void             UpdateMouseWheel();
        -: 1235:static void             UpdateKeyRoutingTable(ImGuiKeyRoutingTable* rt);
        -: 1236:
        -: 1237:// Misc
        -: 1238:static void             UpdateSettings();
        -: 1239:static int              UpdateWindowManualResize(ImGuiWindow* window, const ImVec2& size_auto_fit, int* border_hovered, int* border_held, int resize_grip_count, ImU32 resize_grip_col[4], const ImRect& visibility_rect);
        -: 1240:static void             RenderWindowOuterBorders(ImGuiWindow* window);
        -: 1241:static void             RenderWindowDecorations(ImGuiWindow* window, const ImRect& title_bar_rect, bool title_bar_is_highlight, bool handle_borders_and_resize_grips, int resize_grip_count, const ImU32 resize_grip_col[4], float resize_grip_draw_size);
        -: 1242:static void             RenderWindowTitleBarContents(ImGuiWindow* window, const ImRect& title_bar_rect, const char* name, bool* p_open);
        -: 1243:static void             RenderDimmedBackgroundBehindWindow(ImGuiWindow* window, ImU32 col);
        -: 1244:static void             RenderDimmedBackgrounds();
        -: 1245:static void             SetLastItemDataForWindow(ImGuiWindow* window, const ImRect& rect);
        -: 1246:
        -: 1247:// Viewports
        -: 1248:const ImGuiID           IMGUI_VIEWPORT_DEFAULT_ID = 0x11111111; // Using an arbitrary constant instead of e.g. ImHashStr("ViewportDefault", 0); so it's easier to spot in the debugger. The exact value doesn't matter.
        -: 1249:static ImGuiViewportP*  AddUpdateViewport(ImGuiWindow* window, ImGuiID id, const ImVec2& platform_pos, const ImVec2& size, ImGuiViewportFlags flags);
        -: 1250:static void             DestroyViewport(ImGuiViewportP* viewport);
        -: 1251:static void             UpdateViewportsNewFrame();
        -: 1252:static void             UpdateViewportsEndFrame();
        -: 1253:static void             WindowSelectViewport(ImGuiWindow* window);
        -: 1254:static void             WindowSyncOwnedViewport(ImGuiWindow* window, ImGuiWindow* parent_window_in_stack);
        -: 1255:static bool             UpdateTryMergeWindowIntoHostViewport(ImGuiWindow* window, ImGuiViewportP* host_viewport);
        -: 1256:static bool             UpdateTryMergeWindowIntoHostViewports(ImGuiWindow* window);
        -: 1257:static bool             GetWindowAlwaysWantOwnViewport(ImGuiWindow* window);
        -: 1258:static int              FindPlatformMonitorForPos(const ImVec2& pos);
        -: 1259:static int              FindPlatformMonitorForRect(const ImRect& r);
        -: 1260:static void             UpdateViewportPlatformMonitor(ImGuiViewportP* viewport);
        -: 1261:
        -: 1262:}
        -: 1263:
        -: 1264://-----------------------------------------------------------------------------
        -: 1265:// [SECTION] CONTEXT AND MEMORY ALLOCATORS
        -: 1266://-----------------------------------------------------------------------------
        -: 1267:
        -: 1268:// DLL users:
        -: 1269:// - Heaps and globals are not shared across DLL boundaries!
        -: 1270:// - You will need to call SetCurrentContext() + SetAllocatorFunctions() for each static/DLL boundary you are calling from.
        -: 1271:// - Same applies for hot-reloading mechanisms that are reliant on reloading DLL (note that many hot-reloading mechanisms work without DLL).
        -: 1272:// - Using Dear ImGui via a shared library is not recommended, because of function call overhead and because we don't guarantee backward nor forward ABI compatibility.
        -: 1273:// - Confused? In a debugger: add GImGui to your watch window and notice how its value changes depending on your current location (which DLL boundary you are in).
        -: 1274:
        -: 1275:// Current context pointer. Implicitly used by all Dear ImGui functions. Always assumed to be != NULL.
        -: 1276:// - ImGui::CreateContext() will automatically set this pointer if it is NULL.
        -: 1277://   Change to a different context by calling ImGui::SetCurrentContext().
        -: 1278:// - Important: Dear ImGui functions are not thread-safe because of this pointer.
        -: 1279://   If you want thread-safety to allow N threads to access N different contexts:
        -: 1280://   - Change this variable to use thread local storage so each thread can refer to a different context, in your imconfig.h:
        -: 1281://         struct ImGuiContext;
        -: 1282://         extern thread_local ImGuiContext* MyImGuiTLS;
        -: 1283://         #define GImGui MyImGuiTLS
        -: 1284://     And then define MyImGuiTLS in one of your cpp files. Note that thread_local is a C++11 keyword, earlier C++ uses compiler-specific keyword.
        -: 1285://   - Future development aims to make this context pointer explicit to all calls. Also read https://github.com/ocornut/imgui/issues/586
        -: 1286://   - If you need a finite number of contexts, you may compile and use multiple instances of the ImGui code from a different namespace.
        -: 1287:// - DLL users: read comments above.
        -: 1288:#ifndef GImGui
        -: 1289:ImGuiContext*   GImGui = NULL;
        -: 1290:#endif
        -: 1291:
        -: 1292:// Memory Allocator functions. Use SetAllocatorFunctions() to change them.
        -: 1293:// - You probably don't want to modify that mid-program, and if you use global/static e.g. ImVector<> instances you may need to keep them accessible during program destruction.
        -: 1294:// - DLL users: read comments above.
        -: 1295:#ifndef IMGUI_DISABLE_DEFAULT_ALLOCATORS
function _ZL13MallocWrappermPv called 12957 returned 100% blocks executed 100%
    12957: 1296:static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }
    12957: 1296-block 2
function _ZL11FreeWrapperPvS_ called 12979 returned 100% blocks executed 100%
    12979: 1297:static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }
        -: 1298:#else
        -: 1299:static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); IM_UNUSED(size); IM_ASSERT(0); return NULL; }
        -: 1300:static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); IM_UNUSED(ptr); IM_ASSERT(0); }
        -: 1301:#endif
        -: 1302:static ImGuiMemAllocFunc    GImAllocatorAllocFunc = MallocWrapper;
        -: 1303:static ImGuiMemFreeFunc     GImAllocatorFreeFunc = FreeWrapper;
        -: 1304:static void*                GImAllocatorUserData = NULL;
        -: 1305:
        -: 1306://-----------------------------------------------------------------------------
        -: 1307:// [SECTION] USER FACING STRUCTURES (ImGuiStyle, ImGuiIO, ImGuiPlatformIO)
        -: 1308://-----------------------------------------------------------------------------
        -: 1309:
function _ZN10ImGuiStyleC2Ev called 1 returned 100% blocks executed 100%
        1: 1310:ImGuiStyle::ImGuiStyle()
        1: 1310-block 2
call    0 returned 1
call    1 returned 1
call    2 returned 1
call    3 returned 1
call    4 returned 1
call    5 returned 1
call    6 returned 1
call    7 returned 1
call    8 returned 1
call    9 returned 1
call   10 returned 1
call   11 returned 1
call   12 returned 1
call   13 returned 1
call   14 returned 1
        -: 1311:{
        1: 1312:    Alpha                       = 1.0f;             // Global alpha applies to everything in Dear ImGui.
        1: 1313:    DisabledAlpha               = 0.60f;            // Additional alpha multiplier applied by BeginDisabled(). Multiply over current value of Alpha.
        1: 1314:    WindowPadding               = ImVec2(8,8);      // Padding within a window
call    0 returned 1
        1: 1315:    WindowRounding              = 0.0f;             // Radius of window corners rounding. Set to 0.0f to have rectangular windows. Large values tend to lead to variety of artifacts and are not recommended.
        1: 1316:    WindowBorderSize            = 1.0f;             // Thickness of border around windows. Generally set to 0.0f or 1.0f. Other values not well tested.
        1: 1317:    WindowMinSize               = ImVec2(32,32);    // Minimum window size
call    0 returned 1
        1: 1318:    WindowTitleAlign            = ImVec2(0.0f,0.5f);// Alignment for title bar text
call    0 returned 1
        1: 1319:    WindowMenuButtonPosition    = ImGuiDir_Left;    // Position of the collapsing/docking button in the title bar (left/right). Defaults to ImGuiDir_Left.
        1: 1320:    ChildRounding               = 0.0f;             // Radius of child window corners rounding. Set to 0.0f to have rectangular child windows
        1: 1321:    ChildBorderSize             = 1.0f;             // Thickness of border around child windows. Generally set to 0.0f or 1.0f. Other values not well tested.
        1: 1322:    PopupRounding               = 0.0f;             // Radius of popup window corners rounding. Set to 0.0f to have rectangular child windows
        1: 1323:    PopupBorderSize             = 1.0f;             // Thickness of border around popup or tooltip windows. Generally set to 0.0f or 1.0f. Other values not well tested.
        1: 1324:    FramePadding                = ImVec2(4,3);      // Padding within a framed rectangle (used by most widgets)
call    0 returned 1
        1: 1325:    FrameRounding               = 0.0f;             // Radius of frame corners rounding. Set to 0.0f to have rectangular frames (used by most widgets).
        1: 1326:    FrameBorderSize             = 0.0f;             // Thickness of border around frames. Generally set to 0.0f or 1.0f. Other values not well tested.
        1: 1327:    ItemSpacing                 = ImVec2(8,4);      // Horizontal and vertical spacing between widgets/lines
call    0 returned 1
        1: 1328:    ItemInnerSpacing            = ImVec2(4,4);      // Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label)
call    0 returned 1
        1: 1329:    CellPadding                 = ImVec2(4,2);      // Padding within a table cell. Cellpadding.x is locked for entire table. CellPadding.y may be altered between different rows.
call    0 returned 1
        1: 1330:    TouchExtraPadding           = ImVec2(0,0);      // Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!
call    0 returned 1
        1: 1331:    IndentSpacing               = 21.0f;            // Horizontal spacing when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).
        1: 1332:    ColumnsMinSpacing           = 6.0f;             // Minimum horizontal spacing between two columns. Preferably > (FramePadding.x + 1).
        1: 1333:    ScrollbarSize               = 14.0f;            // Width of the vertical scrollbar, Height of the horizontal scrollbar
        1: 1334:    ScrollbarRounding           = 9.0f;             // Radius of grab corners rounding for scrollbar
        1: 1335:    GrabMinSize                 = 12.0f;            // Minimum width/height of a grab box for slider/scrollbar
        1: 1336:    GrabRounding                = 0.0f;             // Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.
        1: 1337:    LogSliderDeadzone           = 4.0f;             // The size in pixels of the dead-zone around zero on logarithmic sliders that cross zero.
        1: 1338:    TabRounding                 = 4.0f;             // Radius of upper corners of a tab. Set to 0.0f to have rectangular tabs.
        1: 1339:    TabBorderSize               = 0.0f;             // Thickness of border around tabs.
        1: 1340:    TabMinWidthForCloseButton   = 0.0f;             // Minimum width for close button to appear on an unselected tab when hovered. Set to 0.0f to always show when hovering, set to FLT_MAX to never show close button unless selected.
        1: 1341:    TabBarBorderSize            = 1.0f;             // Thickness of tab-bar separator, which takes on the tab active color to denote focus.
        1: 1342:    TabBarOverlineSize          = 2.0f;             // Thickness of tab-bar overline, which highlights the selected tab-bar.
        1: 1343:    TableAngledHeadersAngle     = 35.0f * (IM_PI / 180.0f); // Angle of angled headers (supported values range from -50 degrees to +50 degrees).
        1: 1344:    TableAngledHeadersTextAlign = ImVec2(0.5f,0.0f);// Alignment of angled headers within the cell
call    0 returned 1
        1: 1345:    ColorButtonPosition         = ImGuiDir_Right;   // Side of the color button in the ColorEdit4 widget (left/right). Defaults to ImGuiDir_Right.
        1: 1346:    ButtonTextAlign             = ImVec2(0.5f,0.5f);// Alignment of button text when button is larger than text.
call    0 returned 1
        1: 1347:    SelectableTextAlign         = ImVec2(0.0f,0.0f);// Alignment of selectable text. Defaults to (0.0f, 0.0f) (top-left aligned). It's generally important to keep this left-aligned if you want to lay multiple items on a same line.
call    0 returned 1
        1: 1348:    SeparatorTextBorderSize     = 3.0f;             // Thickness of border in SeparatorText()
        1: 1349:    SeparatorTextAlign          = ImVec2(0.0f,0.5f);// Alignment of text within the separator. Defaults to (0.0f, 0.5f) (left aligned, center).
call    0 returned 1
        1: 1350:    SeparatorTextPadding        = ImVec2(20.0f,3.f);// Horizontal offset of text from each edge of the separator + spacing on other axis. Generally small values. .y is recommended to be == FramePadding.y.
call    0 returned 1
        1: 1351:    DisplayWindowPadding        = ImVec2(19,19);    // Window position are clamped to be visible within the display area or monitors by at least this amount. Only applies to regular windows.
call    0 returned 1
        1: 1352:    DisplaySafeAreaPadding      = ImVec2(3,3);      // If you cannot see the edge of your screen (e.g. on a TV) increase the safe area padding. Covers popups/tooltips as well regular windows.
call    0 returned 1
        1: 1353:    DockingSeparatorSize        = 2.0f;             // Thickness of resizing border between docked windows
        1: 1354:    MouseCursorScale            = 1.0f;             // Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). May be removed later.
        1: 1355:    AntiAliasedLines            = true;             // Enable anti-aliased lines/borders. Disable if you are really tight on CPU/GPU.
        1: 1356:    AntiAliasedLinesUseTex      = true;             // Enable anti-aliased lines/borders using textures where possible. Require backend to render with bilinear filtering (NOT point/nearest filtering).
        1: 1357:    AntiAliasedFill             = true;             // Enable anti-aliased filled shapes (rounded rectangles, circles, etc.).
        1: 1358:    CurveTessellationTol        = 1.25f;            // Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.
        1: 1359:    CircleTessellationMaxError  = 0.30f;            // Maximum error (in pixels) allowed when using AddCircle()/AddCircleFilled() or drawing rounded corner rectangles with no explicit segment count specified. Decrease for higher quality but more geometry.
        -: 1360:
        -: 1361:    // Behaviors
        1: 1362:    HoverStationaryDelay        = 0.15f;            // Delay for IsItemHovered(ImGuiHoveredFlags_Stationary). Time required to consider mouse stationary.
        1: 1363:    HoverDelayShort             = 0.15f;            // Delay for IsItemHovered(ImGuiHoveredFlags_DelayShort). Usually used along with HoverStationaryDelay.
        1: 1364:    HoverDelayNormal            = 0.40f;            // Delay for IsItemHovered(ImGuiHoveredFlags_DelayNormal). "
        1: 1365:    HoverFlagsForTooltipMouse   = ImGuiHoveredFlags_Stationary | ImGuiHoveredFlags_DelayShort | ImGuiHoveredFlags_AllowWhenDisabled;    // Default flags when using IsItemHovered(ImGuiHoveredFlags_ForTooltip) or BeginItemTooltip()/SetItemTooltip() while using mouse.
        1: 1366:    HoverFlagsForTooltipNav     = ImGuiHoveredFlags_NoSharedDelay | ImGuiHoveredFlags_DelayNormal | ImGuiHoveredFlags_AllowWhenDisabled;  // Default flags when using IsItemHovered(ImGuiHoveredFlags_ForTooltip) or BeginItemTooltip()/SetItemTooltip() while using keyboard/gamepad.
        -: 1367:
        -: 1368:    // Default theme
        1: 1369:    ImGui::StyleColorsDark(this);
call    0 returned 1
        1: 1370:}
        -: 1371:
        -: 1372:// To scale your entire UI (e.g. if you want your app to use High DPI or generally be DPI aware) you may use this helper function. Scaling the fonts is done separately and is up to you.
        -: 1373:// Important: This operation is lossy because we round all sizes to integer. If you need to change your scale multiples, call this over a freshly initialized ImGuiStyle structure rather than scaling multiple times.
function _ZN10ImGuiStyle13ScaleAllSizesEf called 0 returned 0% blocks executed 0%
    #####: 1374:void ImGuiStyle::ScaleAllSizes(float scale_factor)
        -: 1375:{
    #####: 1376:    WindowPadding = ImTrunc(WindowPadding * scale_factor);
    %%%%%: 1376-block 2
call    0 never executed
call    1 never executed
    #####: 1377:    WindowRounding = ImTrunc(WindowRounding * scale_factor);
call    0 never executed
    #####: 1378:    WindowMinSize = ImTrunc(WindowMinSize * scale_factor);
call    0 never executed
call    1 never executed
    #####: 1379:    ChildRounding = ImTrunc(ChildRounding * scale_factor);
call    0 never executed
    #####: 1380:    PopupRounding = ImTrunc(PopupRounding * scale_factor);
call    0 never executed
    #####: 1381:    FramePadding = ImTrunc(FramePadding * scale_factor);
call    0 never executed
call    1 never executed
    #####: 1382:    FrameRounding = ImTrunc(FrameRounding * scale_factor);
call    0 never executed
    #####: 1383:    ItemSpacing = ImTrunc(ItemSpacing * scale_factor);
call    0 never executed
call    1 never executed
    #####: 1384:    ItemInnerSpacing = ImTrunc(ItemInnerSpacing * scale_factor);
call    0 never executed
call    1 never executed
    #####: 1385:    CellPadding = ImTrunc(CellPadding * scale_factor);
call    0 never executed
call    1 never executed
    #####: 1386:    TouchExtraPadding = ImTrunc(TouchExtraPadding * scale_factor);
call    0 never executed
call    1 never executed
    #####: 1387:    IndentSpacing = ImTrunc(IndentSpacing * scale_factor);
call    0 never executed
    #####: 1388:    ColumnsMinSpacing = ImTrunc(ColumnsMinSpacing * scale_factor);
call    0 never executed
    #####: 1389:    ScrollbarSize = ImTrunc(ScrollbarSize * scale_factor);
call    0 never executed
    #####: 1390:    ScrollbarRounding = ImTrunc(ScrollbarRounding * scale_factor);
call    0 never executed
    #####: 1391:    GrabMinSize = ImTrunc(GrabMinSize * scale_factor);
call    0 never executed
    #####: 1392:    GrabRounding = ImTrunc(GrabRounding * scale_factor);
call    0 never executed
    #####: 1393:    LogSliderDeadzone = ImTrunc(LogSliderDeadzone * scale_factor);
call    0 never executed
    #####: 1394:    TabRounding = ImTrunc(TabRounding * scale_factor);
call    0 never executed
    #####: 1395:    TabMinWidthForCloseButton = (TabMinWidthForCloseButton != FLT_MAX) ? ImTrunc(TabMinWidthForCloseButton * scale_factor) : FLT_MAX;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1395-block 29
call    2 never executed
    %%%%%: 1395-block 30
    #####: 1396:    TabBarOverlineSize = ImTrunc(TabBarOverlineSize * scale_factor);
    %%%%%: 1396-block 31
call    0 never executed
    #####: 1397:    SeparatorTextPadding = ImTrunc(SeparatorTextPadding * scale_factor);
call    0 never executed
call    1 never executed
    #####: 1398:    DockingSeparatorSize = ImTrunc(DockingSeparatorSize * scale_factor);
call    0 never executed
    #####: 1399:    DisplayWindowPadding = ImTrunc(DisplayWindowPadding * scale_factor);
call    0 never executed
call    1 never executed
    #####: 1400:    DisplaySafeAreaPadding = ImTrunc(DisplaySafeAreaPadding * scale_factor);
call    0 never executed
call    1 never executed
    #####: 1401:    MouseCursorScale = ImTrunc(MouseCursorScale * scale_factor);
call    0 never executed
    #####: 1402:}
        -: 1403:
function _ZN7ImGuiIOC2Ev called 1 returned 100% blocks executed 100%
        1: 1404:ImGuiIO::ImGuiIO()
        1: 1404-block 2
call    0 returned 1
call    1 returned 1
call    2 returned 1
call    3 returned 1
call    4 returned 1
call    5 returned 1
        -: 1405:{
        -: 1406:    // Most fields are initialized with zero
        1: 1407:    memset(this, 0, sizeof(*this));
        -: 1408:    IM_STATIC_ASSERT(IM_ARRAYSIZE(ImGuiIO::MouseDown) == ImGuiMouseButton_COUNT && IM_ARRAYSIZE(ImGuiIO::MouseClicked) == ImGuiMouseButton_COUNT);
        -: 1409:
        -: 1410:    // Settings
        1: 1411:    ConfigFlags = ImGuiConfigFlags_None;
        1: 1412:    BackendFlags = ImGuiBackendFlags_None;
        1: 1413:    DisplaySize = ImVec2(-1.0f, -1.0f);
call    0 returned 1
        1: 1414:    DeltaTime = 1.0f / 60.0f;
        1: 1415:    IniSavingRate = 5.0f;
        1: 1416:    IniFilename = "imgui.ini"; // Important: "imgui.ini" is relative to current working dir, most apps will want to lock this to an absolute path (e.g. same path as executables).
        1: 1417:    LogFilename = "imgui_log.txt";
        -: 1418:#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
      667: 1419:    for (int i = 0; i < ImGuiKey_COUNT; i++)
      667: 1419-block 11
branch  0 taken 666
branch  1 taken 1 (fallthrough)
      666: 1420:        KeyMap[i] = -1;
      666: 1420-block 10
        -: 1421:#endif
        1: 1422:    UserData = NULL;
        -: 1423:
        1: 1424:    Fonts = NULL;
        1: 1425:    FontGlobalScale = 1.0f;
        1: 1426:    FontDefault = NULL;
        1: 1427:    FontAllowUserScaling = false;
        1: 1428:    DisplayFramebufferScale = ImVec2(1.0f, 1.0f);
        1: 1428-block 12
call    0 returned 1
        -: 1429:
        -: 1430:    // Keyboard/Gamepad Navigation options
        1: 1431:    ConfigNavSwapGamepadButtons = false;
        1: 1432:    ConfigNavMoveSetMousePos = false;
        1: 1433:    ConfigNavCaptureKeyboard = true;
        1: 1434:    ConfigNavEscapeClearFocusItem = true;
        1: 1435:    ConfigNavEscapeClearFocusWindow = false;
        1: 1436:    ConfigNavCursorVisibleAuto = true;
        1: 1437:    ConfigNavCursorVisibleAlways = false;
        -: 1438:
        -: 1439:    // Docking options (when ImGuiConfigFlags_DockingEnable is set)
        1: 1440:    ConfigDockingNoSplit = false;
        1: 1441:    ConfigDockingWithShift = false;
        1: 1442:    ConfigDockingAlwaysTabBar = false;
        1: 1443:    ConfigDockingTransparentPayload = false;
        -: 1444:
        -: 1445:    // Viewport options (when ImGuiConfigFlags_ViewportsEnable is set)
        1: 1446:    ConfigViewportsNoAutoMerge = false;
        1: 1447:    ConfigViewportsNoTaskBarIcon = false;
        1: 1448:    ConfigViewportsNoDecoration = true;
        1: 1449:    ConfigViewportsNoDefaultParent = false;
        -: 1450:
        -: 1451:    // Miscellaneous options
        1: 1452:    MouseDrawCursor = false;
        -: 1453:#ifdef __APPLE__
        -: 1454:    ConfigMacOSXBehaviors = true;  // Set Mac OS X style defaults based on __APPLE__ compile time flag
        -: 1455:#else
        1: 1456:    ConfigMacOSXBehaviors = false;
        -: 1457:#endif
        1: 1458:    ConfigInputTrickleEventQueue = true;
        1: 1459:    ConfigInputTextCursorBlink = true;
        1: 1460:    ConfigInputTextEnterKeepActive = false;
        1: 1461:    ConfigDragClickToInputText = false;
        1: 1462:    ConfigWindowsResizeFromEdges = true;
        1: 1463:    ConfigWindowsMoveFromTitleBarOnly = false;
        1: 1464:    ConfigScrollbarScrollByPage = true;
        1: 1465:    ConfigMemoryCompactTimer = 60.0f;
        1: 1466:    ConfigDebugIsDebuggerPresent = false;
        1: 1467:    ConfigDebugHighlightIdConflicts = true;
        1: 1468:    ConfigDebugBeginReturnValueOnce = false;
        1: 1469:    ConfigDebugBeginReturnValueLoop = false;
        -: 1470:
        1: 1471:    ConfigErrorRecovery = true;
        1: 1472:    ConfigErrorRecoveryEnableAssert = true;
        1: 1473:    ConfigErrorRecoveryEnableDebugLog = true;
        1: 1474:    ConfigErrorRecoveryEnableTooltip = true;
        -: 1475:
        -: 1476:    // Inputs Behaviors
        1: 1477:    MouseDoubleClickTime = 0.30f;
        1: 1478:    MouseDoubleClickMaxDist = 6.0f;
        1: 1479:    MouseDragThreshold = 6.0f;
        1: 1480:    KeyRepeatDelay = 0.275f;
        1: 1481:    KeyRepeatRate = 0.050f;
        -: 1482:
        -: 1483:    // Platform Functions
        -: 1484:    // Note: Initialize() will setup default clipboard/ime handlers.
        1: 1485:    BackendPlatformName = BackendRendererName = NULL;
        1: 1486:    BackendPlatformUserData = BackendRendererUserData = BackendLanguageUserData = NULL;
        -: 1487:
        -: 1488:    // Input (NB: we already have memset zero the entire structure!)
        1: 1489:    MousePos = ImVec2(-FLT_MAX, -FLT_MAX);
call    0 returned 1
        1: 1490:    MousePosPrev = ImVec2(-FLT_MAX, -FLT_MAX);
call    0 returned 1
        1: 1491:    MouseSource = ImGuiMouseSource_Mouse;
        6: 1492:    for (int i = 0; i < IM_ARRAYSIZE(MouseDownDuration); i++) MouseDownDuration[i] = MouseDownDurationPrev[i] = -1.0f;
        5: 1492-block 16
        6: 1492-block 17
branch  0 taken 5
branch  1 taken 1 (fallthrough)
      667: 1493:    for (int i = 0; i < IM_ARRAYSIZE(KeysData); i++) { KeysData[i].DownDuration = KeysData[i].DownDurationPrev = -1.0f; }
        1: 1493-block 18
      666: 1493-block 19
      667: 1493-block 20
branch  0 taken 666
branch  1 taken 1 (fallthrough)
        1: 1494:    AppAcceptingEvents = true;
        1: 1495:    BackendUsingLegacyKeyArrays = (ImS8)-1;
        1: 1496:    BackendUsingLegacyNavInputArray = true; // assume using legacy array until proven wrong
        1: 1497:}
        -: 1498:
        -: 1499:// Pass in translated ASCII characters for text input.
        -: 1500:// - with glfw you can get those from the callback set in glfwSetCharCallback()
        -: 1501:// - on Windows you can get those using ToAscii+keyboard state, or via the WM_CHAR message
        -: 1502:// FIXME: Should in theory be called "AddCharacterEvent()" to be consistent with new API
function _ZN7ImGuiIO17AddInputCharacterEj called 0 returned 0% blocks executed 0%
    #####: 1503:void ImGuiIO::AddInputCharacter(unsigned int c)
        -: 1504:{
    #####: 1505:    IM_ASSERT(Ctx != NULL);
    %%%%%: 1505-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1505-block 3
call    2 never executed
    #####: 1506:    ImGuiContext& g = *Ctx;
    #####: 1507:    if (c == 0 || !AppAcceptingEvents)
    %%%%%: 1507-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1507-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 1508:        return;
    %%%%%: 1508-block 6
        -: 1509:
    #####: 1510:    ImGuiInputEvent e;
    %%%%%: 1510-block 7
call    0 never executed
    #####: 1511:    e.Type = ImGuiInputEventType_Text;
    #####: 1512:    e.Source = ImGuiInputSource_Keyboard;
    #####: 1513:    e.EventId = g.InputEventsNextEventId++;
    #####: 1514:    e.Text.Char = c;
    #####: 1515:    g.InputEventsQueue.push_back(e);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 1516:}
        -: 1517:
        -: 1518:// UTF16 strings use surrogate pairs to encode codepoints >= 0x10000, so
        -: 1519:// we should save the high surrogate.
function _ZN7ImGuiIO22AddInputCharacterUTF16Et called 0 returned 0% blocks executed 0%
    #####: 1520:void ImGuiIO::AddInputCharacterUTF16(ImWchar16 c)
        -: 1521:{
    #####: 1522:    if ((c == 0 && InputQueueSurrogate == 0) || !AppAcceptingEvents)
    %%%%%: 1522-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1522-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1522-block 4
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 1523:        return;
    %%%%%: 1523-block 5
        -: 1524:
    #####: 1525:    if ((c & 0xFC00) == 0xD800) // High surrogate, must save
    %%%%%: 1525-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1526:    {
    #####: 1527:        if (InputQueueSurrogate != 0)
    %%%%%: 1527-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1528:            AddInputCharacter(IM_UNICODE_CODEPOINT_INVALID);
    %%%%%: 1528-block 8
call    0 never executed
    #####: 1529:        InputQueueSurrogate = c;
    #####: 1530:        return;
    %%%%%: 1530-block 9
        -: 1531:    }
        -: 1532:
    #####: 1533:    ImWchar cp = c;
    #####: 1534:    if (InputQueueSurrogate != 0)
    %%%%%: 1534-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1535:    {
    #####: 1536:        if ((c & 0xFC00) != 0xDC00) // Invalid low surrogate
    %%%%%: 1536-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1537:        {
    #####: 1538:            AddInputCharacter(IM_UNICODE_CODEPOINT_INVALID);
    %%%%%: 1538-block 12
call    0 never executed
        -: 1539:        }
        -: 1540:        else
        -: 1541:        {
        -: 1542:#if IM_UNICODE_CODEPOINT_MAX == 0xFFFF
    #####: 1543:            cp = IM_UNICODE_CODEPOINT_INVALID; // Codepoint will not fit in ImWchar
    %%%%%: 1543-block 13
        -: 1544:#else
        -: 1545:            cp = (ImWchar)(((InputQueueSurrogate - 0xD800) << 10) + (c - 0xDC00) + 0x10000);
        -: 1546:#endif
        -: 1547:        }
        -: 1548:
    #####: 1549:        InputQueueSurrogate = 0;
    %%%%%: 1549-block 14
        -: 1550:    }
    #####: 1551:    AddInputCharacter((unsigned)cp);
    %%%%%: 1551-block 15
call    0 never executed
        -: 1552:}
        -: 1553:
function _ZN7ImGuiIO22AddInputCharactersUTF8EPKc called 0 returned 0% blocks executed 0%
    #####: 1554:void ImGuiIO::AddInputCharactersUTF8(const char* utf8_chars)
        -: 1555:{
    #####: 1556:    if (!AppAcceptingEvents)
    %%%%%: 1556-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1557:        return;
    %%%%%: 1557-block 3
    #####: 1558:    while (*utf8_chars != 0)
    %%%%%: 1558-block 4
    %%%%%: 1558-block 8
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 1559:    {
    #####: 1560:        unsigned int c = 0;
    #####: 1561:        utf8_chars += ImTextCharFromUtf8(&c, utf8_chars, NULL);
    %%%%%: 1561-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1562:        AddInputCharacter(c);
    %%%%%: 1562-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 1563:    }
        -: 1564:}
        -: 1565:
        -: 1566:// Clear all incoming events.
function _ZN7ImGuiIO16ClearEventsQueueEv called 0 returned 0% blocks executed 0%
    #####: 1567:void ImGuiIO::ClearEventsQueue()
        -: 1568:{
    #####: 1569:    IM_ASSERT(Ctx != NULL);
    %%%%%: 1569-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1569-block 3
call    2 never executed
    #####: 1570:    ImGuiContext& g = *Ctx;
    #####: 1571:    g.InputEventsQueue.clear();
    %%%%%: 1571-block 4
call    0 never executed
    #####: 1572:}
        -: 1573:
        -: 1574:// Clear current keyboard/gamepad state + current frame text input buffer. Equivalent to releasing all keys/buttons.
function _ZN7ImGuiIO14ClearInputKeysEv called 0 returned 0% blocks executed 0%
    #####: 1575:void ImGuiIO::ClearInputKeys()
        -: 1576:{
        -: 1577:#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
    #####: 1578:    memset(KeysDown, 0, sizeof(KeysDown));
        -: 1579:#endif
    #####: 1580:    for (int n = 0; n < IM_ARRAYSIZE(KeysData); n++)
    %%%%%: 1580-block 2
    %%%%%: 1580-block 7
    %%%%%: 1580-block 8
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 1581:    {
    #####: 1582:        if (ImGui::IsMouseKey((ImGuiKey)(n + ImGuiKey_KeysData_OFFSET)))
    %%%%%: 1582-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 1583:            continue;
    %%%%%: 1583-block 5
    #####: 1584:        KeysData[n].Down             = false;
    #####: 1585:        KeysData[n].DownDuration     = -1.0f;
    #####: 1586:        KeysData[n].DownDurationPrev = -1.0f;
    %%%%%: 1586-block 6
        -: 1587:    }
    #####: 1588:    KeyCtrl = KeyShift = KeyAlt = KeySuper = false;
    #####: 1589:    KeyMods = ImGuiMod_None;
    #####: 1590:    InputQueueCharacters.resize(0); // Behavior of old ClearInputCharacters().
    %%%%%: 1590-block 9
call    0 never executed
    #####: 1591:}
        -: 1592:
function _ZN7ImGuiIO15ClearInputMouseEv called 0 returned 0% blocks executed 0%
    #####: 1593:void ImGuiIO::ClearInputMouse()
        -: 1594:{
    #####: 1595:    for (ImGuiKey key = ImGuiKey_Mouse_BEGIN; key < ImGuiKey_Mouse_END; key = (ImGuiKey)(key + 1))
    %%%%%: 1595-block 2
    %%%%%: 1595-block 4
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 1596:    {
    #####: 1597:        ImGuiKeyData* key_data = &KeysData[key - ImGuiKey_KeysData_OFFSET];
    #####: 1598:        key_data->Down = false;
    #####: 1599:        key_data->DownDuration = -1.0f;
    #####: 1600:        key_data->DownDurationPrev = -1.0f;
    %%%%%: 1600-block 3
        -: 1601:    }
    #####: 1602:    MousePos = ImVec2(-FLT_MAX, -FLT_MAX);
    %%%%%: 1602-block 5
call    0 never executed
    #####: 1603:    for (int n = 0; n < IM_ARRAYSIZE(MouseDown); n++)
    %%%%%: 1603-block 8
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 1604:    {
    #####: 1605:        MouseDown[n] = false;
    #####: 1606:        MouseDownDuration[n] = MouseDownDurationPrev[n] = -1.0f;
    %%%%%: 1606-block 7
        -: 1607:    }
    #####: 1608:    MouseWheel = MouseWheelH = 0.0f;
    #####: 1609:}
        -: 1610:
        -: 1611:// Removed this as it is ambiguous/misleading and generally incorrect to use with the existence of a higher-level input queue.
        -: 1612:// Current frame character buffer is now also cleared by ClearInputKeys().
        -: 1613:#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
function _ZN7ImGuiIO20ClearInputCharactersEv called 0 returned 0% blocks executed 0%
    #####: 1614:void ImGuiIO::ClearInputCharacters()
        -: 1615:{
    #####: 1616:    InputQueueCharacters.resize(0);
    %%%%%: 1616-block 2
call    0 never executed
    #####: 1617:}
        -: 1618:#endif
        -: 1619:
function _ZL20FindLatestInputEventP12ImGuiContext19ImGuiInputEventTypei called 1622 returned 100% blocks executed 87%
     1622: 1620:static ImGuiInputEvent* FindLatestInputEvent(ImGuiContext* ctx, ImGuiInputEventType type, int arg = -1)
        -: 1621:{
     1622: 1622:    ImGuiContext& g = *ctx;
     2126: 1623:    for (int n = g.InputEventsQueue.Size - 1; n >= 0; n--)
     1622: 1623-block 2
      504: 1623-block 13
     2126: 1623-block 14
branch  0 taken 550
branch  1 taken 1576 (fallthrough)
        -: 1624:    {
      550: 1625:        ImGuiInputEvent* e = &g.InputEventsQueue[n];
      550: 1625-block 3
call    0 returned 550
      550: 1626:        if (e->Type != type)
branch  0 taken 503 (fallthrough)
branch  1 taken 47
      503: 1627:            continue;
      503: 1627-block 5
       47: 1628:        if (type == ImGuiInputEventType_Key && e->Key.Key != arg)
       47: 1628-block 6
branch  0 taken 1 (fallthrough)
branch  1 taken 46
        1: 1628-block 7
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1: 1629:            continue;
        1: 1629-block 8
      46*: 1630:        if (type == ImGuiInputEventType_MouseButton && e->MouseButton.Button != arg)
       46: 1630-block 9
branch  0 taken 0 (fallthrough)
branch  1 taken 46
    %%%%%: 1630-block 10
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 1631:            continue;
    %%%%%: 1631-block 11
       46: 1632:        return e;
       46: 1632-block 12
        -: 1633:    }
     1576: 1634:    return NULL;
     1576: 1634-block 15
        -: 1635:}
        -: 1636:
        -: 1637:// Queue a new key down/up event.
        -: 1638:// - ImGuiKey key:       Translated key (as in, generally ImGuiKey_A matches the key end-user would use to emit an 'A' character)
        -: 1639:// - bool down:          Is the key down? use false to signify a key release.
        -: 1640:// - float analog_value: 0.0f..1.0f
        -: 1641:// IMPORTANT: THIS FUNCTION AND OTHER "ADD" GRABS THE CONTEXT FROM OUR INSTANCE.
        -: 1642:// WE NEED TO ENSURE THAT ALL FUNCTION CALLS ARE FULFILLING THIS, WHICH IS WHY GetKeyData() HAS AN EXPLICIT CONTEXT.
function _ZN7ImGuiIO17AddKeyAnalogEventE8ImGuiKeybf called 53 returned 100% blocks executed 61%
       53: 1643:void ImGuiIO::AddKeyAnalogEvent(ImGuiKey key, bool down, float analog_value)
        -: 1644:{
        -: 1645:    //if (e->Down) { IMGUI_DEBUG_LOG_IO("AddKeyEvent() Key='%s' %d, NativeKeycode = %d, NativeScancode = %d\n", ImGui::GetKeyName(e->Key), e->Down, e->NativeKeycode, e->NativeScancode); }
      53*: 1646:    IM_ASSERT(Ctx != NULL);
       53: 1646-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 53
    %%%%%: 1646-block 3
call    2 never executed
       53: 1647:    if (key == ImGuiKey_None || !AppAcceptingEvents)
       53: 1647-block 4
branch  0 taken 53 (fallthrough)
branch  1 taken 0
       53: 1647-block 5
branch  2 taken 0 (fallthrough)
branch  3 taken 53
      51*: 1648:        return;
    %%%%%: 1648-block 6
       51: 1648-block 56
       53: 1649:    ImGuiContext& g = *Ctx;
      53*: 1650:    IM_ASSERT(ImGui::IsNamedKeyOrMod(key)); // Backend needs to pass a valid ImGuiKey_ constant. 0..511 values are legacy native key codes which are not accepted by this API.
       53: 1650-block 7
call    0 returned 53
branch  1 taken 0 (fallthrough)
branch  2 taken 53
    %%%%%: 1650-block 9
call    3 never executed
      53*: 1651:    IM_ASSERT(ImGui::IsAliasKey(key) == false); // Backend cannot submit ImGuiKey_MouseXXX values they are automatically inferred from AddMouseXXX() events.
       53: 1651-block 10
call    0 returned 53
branch  1 taken 0 (fallthrough)
branch  2 taken 53
    %%%%%: 1651-block 12
call    3 never executed
        -: 1652:
        -: 1653:    // MacOS: swap Cmd(Super) and Ctrl
       53: 1654:    if (g.IO.ConfigMacOSXBehaviors)
       53: 1654-block 13
branch  0 taken 0 (fallthrough)
branch  1 taken 53
        -: 1655:    {
    #####: 1656:        if (key == ImGuiMod_Super)          { key = ImGuiMod_Ctrl; }
    %%%%%: 1656-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1656-block 15
    #####: 1657:        else if (key == ImGuiMod_Ctrl)      { key = ImGuiMod_Super; }
    %%%%%: 1657-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1657-block 17
    #####: 1658:        else if (key == ImGuiKey_LeftSuper) { key = ImGuiKey_LeftCtrl; }
    %%%%%: 1658-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1658-block 19
    #####: 1659:        else if (key == ImGuiKey_RightSuper){ key = ImGuiKey_RightCtrl; }
    %%%%%: 1659-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1659-block 21
    #####: 1660:        else if (key == ImGuiKey_LeftCtrl)  { key = ImGuiKey_LeftSuper; }
    %%%%%: 1660-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1660-block 23
    #####: 1661:        else if (key == ImGuiKey_RightCtrl) { key = ImGuiKey_RightSuper; }
    %%%%%: 1661-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1661-block 25
        -: 1662:    }
        -: 1663:
        -: 1664:    // Verify that backend isn't mixing up using new io.AddKeyEvent() api and old io.KeysDown[] + io.KeyMap[] data.
        -: 1665:#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
      53*: 1666:    IM_ASSERT((BackendUsingLegacyKeyArrays == -1 || BackendUsingLegacyKeyArrays == 0) && "Backend needs to either only use io.AddKeyEvent(), either only fill legacy io.KeysDown[] + io.KeyMap[]. Not both!");
       53: 1666-block 26
branch  0 taken 52 (fallthrough)
branch  1 taken 1
       52: 1666-block 27
branch  2 taken 0 (fallthrough)
branch  3 taken 52
    %%%%%: 1666-block 28
call    4 never executed
       53: 1667:    if (BackendUsingLegacyKeyArrays == -1)
       53: 1667-block 29
branch  0 taken 1 (fallthrough)
branch  1 taken 52
      155: 1668:        for (int n = ImGuiKey_NamedKey_BEGIN; n < ImGuiKey_NamedKey_END; n++)
        1: 1668-block 30
      154: 1668-block 33
      155: 1668-block 34
branch  0 taken 154
branch  1 taken 1 (fallthrough)
     154*: 1669:            IM_ASSERT(KeyMap[n] == -1 && "Backend needs to either only use io.AddKeyEvent(), either only fill legacy io.KeysDown[] + io.KeyMap[]. Not both!");
      154: 1669-block 31
branch  0 taken 0 (fallthrough)
branch  1 taken 154
    %%%%%: 1669-block 32
call    2 never executed
       53: 1670:    BackendUsingLegacyKeyArrays = 0;
        -: 1671:#endif
       53: 1672:    if (ImGui::IsGamepadKey(key))
       53: 1672-block 35
call    0 returned 53
branch  1 taken 0 (fallthrough)
branch  2 taken 53
    #####: 1673:        BackendUsingLegacyNavInputArray = false;
    %%%%%: 1673-block 37
        -: 1674:
        -: 1675:    // Filter duplicate (in particular: key mods and gamepad analog values are commonly spammed)
       53: 1676:    const ImGuiInputEvent* latest_event = FindLatestInputEvent(&g, ImGuiInputEventType_Key, (int)key);
       53: 1676-block 38
call    0 returned 53
branch  1 taken 53 (fallthrough)
branch  2 taken 0 (throw)
       53: 1677:    const ImGuiKeyData* key_data = ImGui::GetKeyData(&g, key);
       53: 1677-block 39
call    0 returned 53
      53*: 1678:    const bool latest_key_down = latest_event ? latest_event->Key.Down : key_data->Down;
branch  0 taken 0 (fallthrough)
branch  1 taken 53
    %%%%%: 1678-block 41
       53: 1678-block 42
      53*: 1679:    const float latest_key_analog = latest_event ? latest_event->Key.AnalogValue : key_data->AnalogValue;
       53: 1679-block 43
branch  0 taken 0 (fallthrough)
branch  1 taken 53
    %%%%%: 1679-block 44
       53: 1679-block 45
       53: 1680:    if (latest_key_down == down && latest_key_analog == analog_value)
       53: 1680-block 46
branch  0 taken 51 (fallthrough)
branch  1 taken 2
       51: 1680-block 47
branch  2 taken 51 (fallthrough)
branch  3 taken 0
       51: 1681:        return;
       51: 1681-block 48
        -: 1682:
        -: 1683:    // Add event
        2: 1684:    ImGuiInputEvent e;
        2: 1684-block 49
call    0 returned 2
        2: 1685:    e.Type = ImGuiInputEventType_Key;
       2*: 1686:    e.Source = ImGui::IsGamepadKey(key) ? ImGuiInputSource_Gamepad : ImGuiInputSource_Keyboard;
call    0 returned 2
branch  1 taken 0 (fallthrough)
branch  2 taken 2
    %%%%%: 1686-block 52
        2: 1686-block 53
        2: 1687:    e.EventId = g.InputEventsNextEventId++;
        2: 1688:    e.Key.Key = key;
        2: 1689:    e.Key.Down = down;
        2: 1690:    e.Key.AnalogValue = analog_value;
        2: 1691:    g.InputEventsQueue.push_back(e);
        2: 1691-block 54
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        -: 1692:}
        -: 1693:
function _ZN7ImGuiIO11AddKeyEventE8ImGuiKeyb called 53 returned 100% blocks executed 86%
       53: 1694:void ImGuiIO::AddKeyEvent(ImGuiKey key, bool down)
        -: 1695:{
       53: 1696:    if (!AppAcceptingEvents)
       53: 1696-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 53
    #####: 1697:        return;
    %%%%%: 1697-block 3
       53: 1698:    AddKeyAnalogEvent(key, down, down ? 1.0f : 0.0f);
       53: 1698-block 4
branch  0 taken 2 (fallthrough)
branch  1 taken 51
        2: 1698-block 5
       51: 1698-block 6
       53: 1698-block 7
call    2 returned 53
        -: 1699:}
        -: 1700:
        -: 1701:// [Optional] Call after AddKeyEvent().
        -: 1702:// Specify native keycode, scancode + Specify index for legacy <1.87 IsKeyXXX() functions with native indices.
        -: 1703:// If you are writing a backend in 2022 or don't use IsKeyXXX() with native values that are not ImGuiKey values, you can avoid calling this.
function _ZN7ImGuiIO21SetKeyEventNativeDataE8ImGuiKeyiii called 1 returned 100% blocks executed 59%
        1: 1704:void ImGuiIO::SetKeyEventNativeData(ImGuiKey key, int native_keycode, int native_scancode, int native_legacy_index)
        -: 1705:{
        1: 1706:    if (key == ImGuiKey_None)
        1: 1706-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 1707:        return;
    %%%%%: 1707-block 3
       1*: 1708:    IM_ASSERT(ImGui::IsNamedKey(key)); // >= 512
        1: 1708-block 4
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    %%%%%: 1708-block 6
call    3 never executed
       1*: 1709:    IM_ASSERT(native_legacy_index == -1 || ImGui::IsLegacyKey((ImGuiKey)native_legacy_index)); // >= 0 && <= 511
        1: 1709-block 7
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 1709-block 8
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 1709-block 10
call    5 never executed
        -: 1710:    IM_UNUSED(native_keycode);  // Yet unused
        -: 1711:    IM_UNUSED(native_scancode); // Yet unused
        -: 1712:
        -: 1713:    // Build native->imgui map so old user code can still call key functions with native 0..511 values.
        -: 1714:#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
       1*: 1715:    const int legacy_key = (native_legacy_index != -1) ? native_legacy_index : native_keycode;
        1: 1715-block 11
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 1715-block 12
        1: 1715-block 13
        1: 1716:    if (!ImGui::IsLegacyKey((ImGuiKey)legacy_key))
        1: 1716-block 14
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    #####: 1717:        return;
    %%%%%: 1717-block 16
        1: 1718:    KeyMap[legacy_key] = key;
        1: 1719:    KeyMap[key] = legacy_key;
        1: 1719-block 17
        -: 1720:#else
        -: 1721:    IM_UNUSED(key);
        -: 1722:    IM_UNUSED(native_legacy_index);
        -: 1723:#endif
        -: 1724:}
        -: 1725:
        -: 1726:// Set master flag for accepting key/mouse/text events (default to true). Useful if you have native dialog boxes that are interrupting your application loop/refresh, and you want to disable events being queued while your app is frozen.
function _ZN7ImGuiIO21SetAppAcceptingEventsEb called 0 returned 0% blocks executed 0%
    #####: 1727:void ImGuiIO::SetAppAcceptingEvents(bool accepting_events)
        -: 1728:{
    #####: 1729:    AppAcceptingEvents = accepting_events;
    #####: 1730:}
        -: 1731:
        -: 1732:// Queue a mouse move event
function _ZN7ImGuiIO16AddMousePosEventEff called 479 returned 100% blocks executed 75%
      479: 1733:void ImGuiIO::AddMousePosEvent(float x, float y)
        -: 1734:{
     479*: 1735:    IM_ASSERT(Ctx != NULL);
      479: 1735-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 479
    %%%%%: 1735-block 3
call    2 never executed
      479: 1736:    ImGuiContext& g = *Ctx;
      479: 1737:    if (!AppAcceptingEvents)
      479: 1737-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 479
    #####: 1738:        return;
    %%%%%: 1738-block 5
    %%%%%: 1738-block 23
        -: 1739:
        -: 1740:    // Apply same flooring as UpdateMouseInputs()
     479*: 1741:    ImVec2 pos((x > -FLT_MAX) ? ImFloor(x) : x, (y > -FLT_MAX) ? ImFloor(y) : y);
      479: 1741-block 6
branch  0 taken 479 (fallthrough)
branch  1 taken 0
      479: 1741-block 7
call    2 returned 479
    %%%%%: 1741-block 8
      479: 1741-block 9
branch  3 taken 479 (fallthrough)
branch  4 taken 0
      479: 1741-block 10
call    5 returned 479
    %%%%%: 1741-block 11
      479: 1741-block 12
call    6 returned 479
        -: 1742:
        -: 1743:    // Filter duplicate
      479: 1744:    const ImGuiInputEvent* latest_event = FindLatestInputEvent(&g, ImGuiInputEventType_MousePos);
call    0 returned 479
branch  1 taken 479 (fallthrough)
branch  2 taken 0 (throw)
      479: 1745:    const ImVec2 latest_pos = latest_event ? ImVec2(latest_event->MousePos.PosX, latest_event->MousePos.PosY) : g.IO.MousePos;
      479: 1745-block 14
branch  0 taken 46 (fallthrough)
branch  1 taken 433
       46: 1745-block 15
call    2 returned 46
      433: 1745-block 16
      479: 1746:    if (latest_pos.x == pos.x && latest_pos.y == pos.y)
      479: 1746-block 17
branch  0 taken 78 (fallthrough)
branch  1 taken 401
       78: 1746-block 18
branch  2 taken 0 (fallthrough)
branch  3 taken 78
    #####: 1747:        return;
    %%%%%: 1747-block 19
        -: 1748:
      479: 1749:    ImGuiInputEvent e;
      479: 1749-block 20
call    0 returned 479
      479: 1750:    e.Type = ImGuiInputEventType_MousePos;
      479: 1751:    e.Source = ImGuiInputSource_Mouse;
      479: 1752:    e.EventId = g.InputEventsNextEventId++;
      479: 1753:    e.MousePos.PosX = pos.x;
      479: 1754:    e.MousePos.PosY = pos.y;
      479: 1755:    e.MousePos.MouseSource = g.InputEventsNextMouseSource;
      479: 1756:    g.InputEventsQueue.push_back(e);
call    0 returned 479
branch  1 taken 479 (fallthrough)
branch  2 taken 0 (throw)
        -: 1757:}
        -: 1758:
function _ZN7ImGuiIO19AddMouseButtonEventEib called 12 returned 100% blocks executed 43%
       12: 1759:void ImGuiIO::AddMouseButtonEvent(int mouse_button, bool down)
        -: 1760:{
      12*: 1761:    IM_ASSERT(Ctx != NULL);
       12: 1761-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 12
    %%%%%: 1761-block 3
call    2 never executed
       12: 1762:    ImGuiContext& g = *Ctx;
      12*: 1763:    IM_ASSERT(mouse_button >= 0 && mouse_button < ImGuiMouseButton_COUNT);
       12: 1763-block 4
branch  0 taken 12 (fallthrough)
branch  1 taken 0
       12: 1763-block 5
branch  2 taken 12 (fallthrough)
branch  3 taken 0
       12: 1763-block 6
    %%%%%: 1763-block 7
call    4 never executed
       12: 1764:    if (!AppAcceptingEvents)
       12: 1764-block 8
branch  0 taken 0 (fallthrough)
branch  1 taken 12
    #####: 1765:        return;
    %%%%%: 1765-block 9
    %%%%%: 1765-block 36
        -: 1766:
        -: 1767:    // On MacOS X: Convert Ctrl(Super)+Left click into Right-click: handle held button.
      12*: 1768:    if (ConfigMacOSXBehaviors && mouse_button == 0 && MouseCtrlLeftAsRightClick)
       12: 1768-block 10
branch  0 taken 0 (fallthrough)
branch  1 taken 12
    %%%%%: 1768-block 11
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1768-block 12
branch  4 never executed (fallthrough)
branch  5 never executed
        -: 1769:    {
        -: 1770:        // Order of both statements matterns: this event will still release mouse button 1
    #####: 1771:        mouse_button = 1;
    #####: 1772:        if (!down)
    %%%%%: 1772-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1773:            MouseCtrlLeftAsRightClick = false;
    %%%%%: 1773-block 14
        -: 1774:    }
        -: 1775:
        -: 1776:    // Filter duplicate
       12: 1777:    const ImGuiInputEvent* latest_event = FindLatestInputEvent(&g, ImGuiInputEventType_MouseButton, (int)mouse_button);
       12: 1777-block 15
call    0 returned 12
branch  1 taken 12 (fallthrough)
branch  2 taken 0 (throw)
      12*: 1778:    const bool latest_button_down = latest_event ? latest_event->MouseButton.Down : g.IO.MouseDown[mouse_button];
       12: 1778-block 16
branch  0 taken 0 (fallthrough)
branch  1 taken 12
    %%%%%: 1778-block 17
       12: 1778-block 18
       12: 1779:    if (latest_button_down == down)
       12: 1779-block 19
branch  0 taken 0 (fallthrough)
branch  1 taken 12
    #####: 1780:        return;
    %%%%%: 1780-block 20
        -: 1781:
        -: 1782:    // On MacOS X: Convert Ctrl(Super)+Left click into Right-click.
        -: 1783:    // - Note that this is actual physical Ctrl which is ImGuiMod_Super for us.
        -: 1784:    // - At this point we want from !down to down, so this is handling the initial press.
      12*: 1785:    if (ConfigMacOSXBehaviors && mouse_button == 0 && down)
       12: 1785-block 21
branch  0 taken 0 (fallthrough)
branch  1 taken 12
    %%%%%: 1785-block 22
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1785-block 23
branch  4 never executed (fallthrough)
branch  5 never executed
        -: 1786:    {
    #####: 1787:        const ImGuiInputEvent* latest_super_event = FindLatestInputEvent(&g, ImGuiInputEventType_Key, (int)ImGuiMod_Super);
    %%%%%: 1787-block 24
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1788:        if (latest_super_event ? latest_super_event->Key.Down : g.IO.KeySuper)
    %%%%%: 1788-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1788-block 26
    %%%%%: 1788-block 27
    %%%%%: 1788-block 28
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 1789:        {
    #####: 1790:            IMGUI_DEBUG_LOG_IO("[io] Super+Left Click aliased into Right Click\n");
    %%%%%: 1790-block 29
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1790-block 30
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####: 1791:            MouseCtrlLeftAsRightClick = true;
    #####: 1792:            AddMouseButtonEvent(1, true); // This is just quicker to write that passing through, as we need to filter duplicate again.
    %%%%%: 1792-block 31
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1793:            return;
    %%%%%: 1793-block 32
        -: 1794:        }
        -: 1795:    }
        -: 1796:
       12: 1797:    ImGuiInputEvent e;
       12: 1797-block 33
call    0 returned 12
       12: 1798:    e.Type = ImGuiInputEventType_MouseButton;
       12: 1799:    e.Source = ImGuiInputSource_Mouse;
       12: 1800:    e.EventId = g.InputEventsNextEventId++;
       12: 1801:    e.MouseButton.Button = mouse_button;
       12: 1802:    e.MouseButton.Down = down;
       12: 1803:    e.MouseButton.MouseSource = g.InputEventsNextMouseSource;
       12: 1804:    g.InputEventsQueue.push_back(e);
call    0 returned 12
branch  1 taken 12 (fallthrough)
branch  2 taken 0 (throw)
        -: 1805:}
        -: 1806:
        -: 1807:// Queue a mouse wheel event (some mouse/API may only have a Y component)
function _ZN7ImGuiIO18AddMouseWheelEventEff called 0 returned 0% blocks executed 0%
    #####: 1808:void ImGuiIO::AddMouseWheelEvent(float wheel_x, float wheel_y)
        -: 1809:{
    #####: 1810:    IM_ASSERT(Ctx != NULL);
    %%%%%: 1810-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1810-block 3
call    2 never executed
    #####: 1811:    ImGuiContext& g = *Ctx;
        -: 1812:
        -: 1813:    // Filter duplicate (unlike most events, wheel values are relative and easy to filter)
    #####: 1814:    if (!AppAcceptingEvents || (wheel_x == 0.0f && wheel_y == 0.0f))
    %%%%%: 1814-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1814-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1814-block 6
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 1815:        return;
    %%%%%: 1815-block 7
        -: 1816:
    #####: 1817:    ImGuiInputEvent e;
    %%%%%: 1817-block 8
call    0 never executed
    #####: 1818:    e.Type = ImGuiInputEventType_MouseWheel;
    #####: 1819:    e.Source = ImGuiInputSource_Mouse;
    #####: 1820:    e.EventId = g.InputEventsNextEventId++;
    #####: 1821:    e.MouseWheel.WheelX = wheel_x;
    #####: 1822:    e.MouseWheel.WheelY = wheel_y;
    #####: 1823:    e.MouseWheel.MouseSource = g.InputEventsNextMouseSource;
    #####: 1824:    g.InputEventsQueue.push_back(e);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 1825:}
        -: 1826:
        -: 1827:// This is not a real event, the data is latched in order to be stored in actual Mouse events.
        -: 1828:// This is so that duplicate events (e.g. Windows sending extraneous WM_MOUSEMOVE) gets filtered and are not leading to actual source changes.
function _ZN7ImGuiIO19AddMouseSourceEventE16ImGuiMouseSource called 0 returned 0% blocks executed 0%
    #####: 1829:void ImGuiIO::AddMouseSourceEvent(ImGuiMouseSource source)
        -: 1830:{
    #####: 1831:    IM_ASSERT(Ctx != NULL);
    %%%%%: 1831-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1831-block 3
call    2 never executed
    #####: 1832:    ImGuiContext& g = *Ctx;
    #####: 1833:    g.InputEventsNextMouseSource = source;
    #####: 1834:}
        -: 1835:
function _ZN7ImGuiIO21AddMouseViewportEventEj called 1077 returned 100% blocks executed 81%
     1077: 1836:void ImGuiIO::AddMouseViewportEvent(ImGuiID viewport_id)
        -: 1837:{
    1077*: 1838:    IM_ASSERT(Ctx != NULL);
     1077: 1838-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 1838-block 3
call    2 never executed
     1077: 1839:    ImGuiContext& g = *Ctx;
        -: 1840:    //IM_ASSERT(g.IO.BackendFlags & ImGuiBackendFlags_HasMouseHoveredViewport);
     1077: 1841:    if (!AppAcceptingEvents)
     1077: 1841-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    1076*: 1842:        return;
    %%%%%: 1842-block 5
     1076: 1842-block 15
        -: 1843:
        -: 1844:    // Filter duplicate
     1077: 1845:    const ImGuiInputEvent* latest_event = FindLatestInputEvent(&g, ImGuiInputEventType_MouseViewport);
     1077: 1845-block 6
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
    1077*: 1846:    const ImGuiID latest_viewport_id = latest_event ? latest_event->MouseViewport.HoveredViewportID : g.IO.MouseHoveredViewport;
     1077: 1846-block 7
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 1846-block 8
     1077: 1846-block 9
     1077: 1847:    if (latest_viewport_id == viewport_id)
     1077: 1847-block 10
branch  0 taken 1076 (fallthrough)
branch  1 taken 1
     1076: 1848:        return;
     1076: 1848-block 11
        -: 1849:
        1: 1850:    ImGuiInputEvent e;
        1: 1850-block 12
call    0 returned 1
        1: 1851:    e.Type = ImGuiInputEventType_MouseViewport;
        1: 1852:    e.Source = ImGuiInputSource_Mouse;
        1: 1853:    e.MouseViewport.HoveredViewportID = viewport_id;
        1: 1854:    g.InputEventsQueue.push_back(e);
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -: 1855:}
        -: 1856:
function _ZN7ImGuiIO13AddFocusEventEb called 1 returned 100% blocks executed 53%
        1: 1857:void ImGuiIO::AddFocusEvent(bool focused)
        -: 1858:{
       1*: 1859:    IM_ASSERT(Ctx != NULL);
        1: 1859-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 1859-block 3
call    2 never executed
        1: 1860:    ImGuiContext& g = *Ctx;
        -: 1861:
        -: 1862:    // Filter duplicate
        1: 1863:    const ImGuiInputEvent* latest_event = FindLatestInputEvent(&g, ImGuiInputEventType_Focus);
        1: 1863-block 4
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
       1*: 1864:    const bool latest_focused = latest_event ? latest_event->AppFocused.Focused : !g.IO.AppFocusLost;
        1: 1864-block 5
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 1864-block 6
        1: 1864-block 7
       1*: 1865:    if (latest_focused == focused || (ConfigDebugIgnoreFocusLoss && !focused))
        1: 1865-block 8
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 1865-block 9
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1865-block 10
branch  4 never executed (fallthrough)
branch  5 never executed
        1: 1866:        return;
        1: 1866-block 11
        -: 1867:
    #####: 1868:    ImGuiInputEvent e;
    %%%%%: 1868-block 12
call    0 never executed
    #####: 1869:    e.Type = ImGuiInputEventType_Focus;
    #####: 1870:    e.EventId = g.InputEventsNextEventId++;
    #####: 1871:    e.AppFocused.Focused = focused;
    #####: 1872:    g.InputEventsQueue.push_back(e);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 1873:}
        -: 1874:
function _ZN15ImGuiPlatformIOC2Ev called 1 returned 100% blocks executed 100%
        1: 1875:ImGuiPlatformIO::ImGuiPlatformIO()
        1: 1875-block 2
call    0 returned 1
call    1 returned 1
        -: 1876:{
        -: 1877:    // Most fields are initialized with zero
        1: 1878:    memset(this, 0, sizeof(*this));
        1: 1879:    Platform_LocaleDecimalPoint = '.';
        1: 1880:}
        -: 1881:
        -: 1882://-----------------------------------------------------------------------------
        -: 1883:// [SECTION] MISC HELPERS/UTILITIES (Geometry functions)
        -: 1884://-----------------------------------------------------------------------------
        -: 1885:
function _Z25ImBezierCubicClosestPointRK6ImVec2S1_S1_S1_S1_i called 0 returned 0% blocks executed 0%
    #####: 1886:ImVec2 ImBezierCubicClosestPoint(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, const ImVec2& p, int num_segments)
        -: 1887:{
    #####: 1888:    IM_ASSERT(num_segments > 0); // Use ImBezierCubicClosestPointCasteljau()
    %%%%%: 1888-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1888-block 3
call    2 never executed
    #####: 1889:    ImVec2 p_last = p1;
    #####: 1890:    ImVec2 p_closest;
    #####: 1891:    float p_closest_dist2 = FLT_MAX;
    #####: 1892:    float t_step = 1.0f / (float)num_segments;
    #####: 1893:    for (int i_step = 1; i_step <= num_segments; i_step++)
    %%%%%: 1893-block 4
    %%%%%: 1893-block 12
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 1894:    {
    #####: 1895:        ImVec2 p_current = ImBezierCubicCalc(p1, p2, p3, p4, t_step * i_step);
    %%%%%: 1895-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1896:        ImVec2 p_line = ImLineClosestPoint(p_last, p_current, p);
    %%%%%: 1896-block 6
call    0 never executed
    #####: 1897:        float dist2 = ImLengthSqr(p - p_line);
call    0 never executed
call    1 never executed
    #####: 1898:        if (dist2 < p_closest_dist2)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1899:        {
    #####: 1900:            p_closest = p_line;
    #####: 1901:            p_closest_dist2 = dist2;
    %%%%%: 1901-block 10
        -: 1902:        }
    #####: 1903:        p_last = p_current;
    %%%%%: 1903-block 11
        -: 1904:    }
    #####: 1905:    return p_closest;
    %%%%%: 1905-block 13
    %%%%%: 1905-block 14
        -: 1906:}
        -: 1907:
        -: 1908:// Closely mimics PathBezierToCasteljau() in imgui_draw.cpp
function _ZL38ImBezierCubicClosestPointCasteljauStepRK6ImVec2RS_S2_Rffffffffffi called 0 returned 0% blocks executed 0%
    #####: 1909:static void ImBezierCubicClosestPointCasteljauStep(const ImVec2& p, ImVec2& p_closest, ImVec2& p_last, float& p_closest_dist2, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4, float tess_tol, int level)
        -: 1910:{
    #####: 1911:    float dx = x4 - x1;
    #####: 1912:    float dy = y4 - y1;
    #####: 1913:    float d2 = ((x2 - x4) * dy - (y2 - y4) * dx);
    #####: 1914:    float d3 = ((x3 - x4) * dy - (y3 - y4) * dx);
    #####: 1915:    d2 = (d2 >= 0) ? d2 : -d2;
    %%%%%: 1915-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1915-block 3
    %%%%%: 1915-block 4
    #####: 1916:    d3 = (d3 >= 0) ? d3 : -d3;
    %%%%%: 1916-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1916-block 6
    %%%%%: 1916-block 7
    #####: 1917:    if ((d2 + d3) * (d2 + d3) < tess_tol * (dx * dx + dy * dy))
    %%%%%: 1917-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1918:    {
    #####: 1919:        ImVec2 p_current(x4, y4);
    %%%%%: 1919-block 9
call    0 never executed
    #####: 1920:        ImVec2 p_line = ImLineClosestPoint(p_last, p_current, p);
call    0 never executed
    #####: 1921:        float dist2 = ImLengthSqr(p - p_line);
call    0 never executed
call    1 never executed
    #####: 1922:        if (dist2 < p_closest_dist2)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1923:        {
    #####: 1924:            p_closest = p_line;
    #####: 1925:            p_closest_dist2 = dist2;
    %%%%%: 1925-block 14
        -: 1926:        }
    #####: 1927:        p_last = p_current;
    %%%%%: 1927-block 15
        -: 1928:    }
    #####: 1929:    else if (level < 10)
    %%%%%: 1929-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1930:    {
    #####: 1931:        float x12 = (x1 + x2)*0.5f,       y12 = (y1 + y2)*0.5f;
    #####: 1932:        float x23 = (x2 + x3)*0.5f,       y23 = (y2 + y3)*0.5f;
    #####: 1933:        float x34 = (x3 + x4)*0.5f,       y34 = (y3 + y4)*0.5f;
    #####: 1934:        float x123 = (x12 + x23)*0.5f,    y123 = (y12 + y23)*0.5f;
    #####: 1935:        float x234 = (x23 + x34)*0.5f,    y234 = (y23 + y34)*0.5f;
    #####: 1936:        float x1234 = (x123 + x234)*0.5f, y1234 = (y123 + y234)*0.5f;
    #####: 1937:        ImBezierCubicClosestPointCasteljauStep(p, p_closest, p_last, p_closest_dist2, x1, y1, x12, y12, x123, y123, x1234, y1234, tess_tol, level + 1);
    %%%%%: 1937-block 17
call    0 never executed
    #####: 1938:        ImBezierCubicClosestPointCasteljauStep(p, p_closest, p_last, p_closest_dist2, x1234, y1234, x234, y234, x34, y34, x4, y4, tess_tol, level + 1);
call    0 never executed
        -: 1939:    }
    #####: 1940:}
        -: 1941:
        -: 1942:// tess_tol is generally the same value you would find in ImGui::GetStyle().CurveTessellationTol
        -: 1943:// Because those ImXXX functions are lower-level than ImGui:: we cannot access this value automatically.
function _Z34ImBezierCubicClosestPointCasteljauRK6ImVec2S1_S1_S1_S1_f called 0 returned 0% blocks executed 0%
    #####: 1944:ImVec2 ImBezierCubicClosestPointCasteljau(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, const ImVec2& p, float tess_tol)
        -: 1945:{
    #####: 1946:    IM_ASSERT(tess_tol > 0.0f);
    %%%%%: 1946-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1946-block 3
call    2 never executed
    #####: 1947:    ImVec2 p_last = p1;
    #####: 1948:    ImVec2 p_closest;
    #####: 1949:    float p_closest_dist2 = FLT_MAX;
    #####: 1950:    ImBezierCubicClosestPointCasteljauStep(p, p_closest, p_last, p_closest_dist2, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, p4.x, p4.y, tess_tol, 0);
    %%%%%: 1950-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1951:    return p_closest;
    %%%%%: 1951-block 5
    %%%%%: 1951-block 6
        -: 1952:}
        -: 1953:
function _Z18ImLineClosestPointRK6ImVec2S1_S1_ called 0 returned 0% blocks executed 0%
    #####: 1954:ImVec2 ImLineClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& p)
        -: 1955:{
    #####: 1956:    ImVec2 ap = p - a;
    %%%%%: 1956-block 2
call    0 never executed
    #####: 1957:    ImVec2 ab_dir = b - a;
call    0 never executed
    #####: 1958:    float dot = ap.x * ab_dir.x + ap.y * ab_dir.y;
    #####: 1959:    if (dot < 0.0f)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1960:        return a;
    %%%%%: 1960-block 5
    #####: 1961:    float ab_len_sqr = ab_dir.x * ab_dir.x + ab_dir.y * ab_dir.y;
    #####: 1962:    if (dot > ab_len_sqr)
    %%%%%: 1962-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1963:        return b;
    %%%%%: 1963-block 7
    #####: 1964:    return a + ab_dir * dot / ab_len_sqr;
    %%%%%: 1964-block 8
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1965:}
        -: 1966:
function _Z23ImTriangleContainsPointRK6ImVec2S1_S1_S1_ called 0 returned 0% blocks executed 0%
    #####: 1967:bool ImTriangleContainsPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p)
        -: 1968:{
    #####: 1969:    bool b1 = ((p.x - b.x) * (a.y - b.y) - (p.y - b.y) * (a.x - b.x)) < 0.0f;
    #####: 1970:    bool b2 = ((p.x - c.x) * (b.y - c.y) - (p.y - c.y) * (b.x - c.x)) < 0.0f;
    #####: 1971:    bool b3 = ((p.x - a.x) * (c.y - a.y) - (p.y - a.y) * (c.x - a.x)) < 0.0f;
    #####: 1972:    return ((b1 == b2) && (b2 == b3));
    %%%%%: 1972-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1972-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1972-block 4
    %%%%%: 1972-block 5
    %%%%%: 1972-block 6
        -: 1973:}
        -: 1974:
function _Z27ImTriangleBarycentricCoordsRK6ImVec2S1_S1_S1_RfS2_S2_ called 0 returned 0% blocks executed 0%
    #####: 1975:void ImTriangleBarycentricCoords(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p, float& out_u, float& out_v, float& out_w)
        -: 1976:{
    #####: 1977:    ImVec2 v0 = b - a;
    %%%%%: 1977-block 2
call    0 never executed
    #####: 1978:    ImVec2 v1 = c - a;
call    0 never executed
    #####: 1979:    ImVec2 v2 = p - a;
call    0 never executed
    #####: 1980:    const float denom = v0.x * v1.y - v1.x * v0.y;
    #####: 1981:    out_v = (v2.x * v1.y - v1.x * v2.y) / denom;
    #####: 1982:    out_w = (v0.x * v2.y - v2.x * v0.y) / denom;
    #####: 1983:    out_u = 1.0f - out_v - out_w;
    #####: 1984:}
        -: 1985:
function _Z22ImTriangleClosestPointRK6ImVec2S1_S1_S1_ called 0 returned 0% blocks executed 0%
    #####: 1986:ImVec2 ImTriangleClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p)
        -: 1987:{
    #####: 1988:    ImVec2 proj_ab = ImLineClosestPoint(a, b, p);
    %%%%%: 1988-block 2
call    0 never executed
    #####: 1989:    ImVec2 proj_bc = ImLineClosestPoint(b, c, p);
call    0 never executed
    #####: 1990:    ImVec2 proj_ca = ImLineClosestPoint(c, a, p);
call    0 never executed
    #####: 1991:    float dist2_ab = ImLengthSqr(p - proj_ab);
call    0 never executed
call    1 never executed
    #####: 1992:    float dist2_bc = ImLengthSqr(p - proj_bc);
call    0 never executed
call    1 never executed
    #####: 1993:    float dist2_ca = ImLengthSqr(p - proj_ca);
call    0 never executed
call    1 never executed
    #####: 1994:    float m = ImMin(dist2_ab, ImMin(dist2_bc, dist2_ca));
call    0 never executed
call    1 never executed
    #####: 1995:    if (m == dist2_ab)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1996:        return proj_ab;
    %%%%%: 1996-block 14
    #####: 1997:    if (m == dist2_bc)
    %%%%%: 1997-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1998:        return proj_bc;
    %%%%%: 1998-block 16
    #####: 1999:    return proj_ca;
    %%%%%: 1999-block 17
        -: 2000:}
        -: 2001:
        -: 2002://-----------------------------------------------------------------------------
        -: 2003:// [SECTION] MISC HELPERS/UTILITIES (String, Format, Hash functions)
        -: 2004://-----------------------------------------------------------------------------
        -: 2005:
        -: 2006:// Consider using _stricmp/_strnicmp under Windows or strcasecmp/strncasecmp. We don't actually use either ImStricmp/ImStrnicmp in the codebase any more.
function _Z9ImStricmpPKcS0_ called 0 returned 0% blocks executed 0%
    #####: 2007:int ImStricmp(const char* str1, const char* str2)
        -: 2008:{
        -: 2009:    int d;
    #####: 2010:    while ((d = ImToUpper(*str2) - ImToUpper(*str1)) == 0 && *str1) { str1++; str2++; }
    %%%%%: 2010-block 2
    %%%%%: 2010-block 3
    %%%%%: 2010-block 4
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2010-block 7
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 2010-block 8
    %%%%%: 2010-block 9
    %%%%%: 2010-block 10
branch  6 never executed
branch  7 never executed (fallthrough)
    #####: 2011:    return d;
    %%%%%: 2011-block 11
        -: 2012:}
        -: 2013:
function _Z10ImStrnicmpPKcS0_m called 0 returned 0% blocks executed 0%
    #####: 2014:int ImStrnicmp(const char* str1, const char* str2, size_t count)
        -: 2015:{
    #####: 2016:    int d = 0;
    #####: 2017:    while (count > 0 && (d = ImToUpper(*str2) - ImToUpper(*str1)) == 0 && *str1) { str1++; str2++; count--; }
    %%%%%: 2017-block 2
    %%%%%: 2017-block 3
    %%%%%: 2017-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2017-block 5
call    2 never executed
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 2017-block 8
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 2017-block 9
    %%%%%: 2017-block 10
    %%%%%: 2017-block 11
branch  8 never executed
branch  9 never executed (fallthrough)
    #####: 2018:    return d;
    %%%%%: 2018-block 12
        -: 2019:}
        -: 2020:
function _Z9ImStrncpyPcPKcm called 0 returned 0% blocks executed 0%
    #####: 2021:void ImStrncpy(char* dst, const char* src, size_t count)
        -: 2022:{
    #####: 2023:    if (count < 1)
    %%%%%: 2023-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2024:        return;
    %%%%%: 2024-block 3
    #####: 2025:    if (count > 1)
    %%%%%: 2025-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2026:        strncpy(dst, src, count - 1);
    %%%%%: 2026-block 5
    #####: 2027:    dst[count - 1] = 0;
    %%%%%: 2027-block 6
        -: 2028:}
        -: 2029:
function _Z8ImStrdupPKc called 16 returned 100% blocks executed 100%
       16: 2030:char* ImStrdup(const char* str)
        -: 2031:{
       16: 2032:    size_t len = strlen(str);
       16: 2033:    void* buf = IM_ALLOC(len + 1);
       16: 2033-block 2
call    0 returned 16
       16: 2034:    return (char*)memcpy(buf, (const void*)str, len + 1);
        -: 2035:}
        -: 2036:
function _Z11ImStrdupcpyPcPmPKc called 0 returned 0% blocks executed 0%
    #####: 2037:char* ImStrdupcpy(char* dst, size_t* p_dst_size, const char* src)
        -: 2038:{
    #####: 2039:    size_t dst_buf_size = p_dst_size ? *p_dst_size : strlen(dst) + 1;
    %%%%%: 2039-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2039-block 3
    %%%%%: 2039-block 4
    #####: 2040:    size_t src_size = strlen(src) + 1;
    #####: 2041:    if (dst_buf_size < src_size)
    %%%%%: 2041-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2042:    {
    #####: 2043:        IM_FREE(dst);
    %%%%%: 2043-block 6
call    0 never executed
    #####: 2044:        dst = (char*)IM_ALLOC(src_size);
call    0 never executed
    #####: 2045:        if (p_dst_size)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2046:            *p_dst_size = src_size;
    %%%%%: 2046-block 9
        -: 2047:    }
    #####: 2048:    return (char*)memcpy(dst, (const void*)src, src_size);
    %%%%%: 2048-block 10
        -: 2049:}
        -: 2050:
function _Z13ImStrchrRangePKcS0_c called 38 returned 100% blocks executed 100%
       38: 2051:const char* ImStrchrRange(const char* str, const char* str_end, char c)
        -: 2052:{
       38: 2053:    const char* p = (const char*)memchr(str, (int)c, str_end - str);
       38: 2054:    return p;
       38: 2054-block 2
        -: 2055:}
        -: 2056:
function _Z9ImStrlenWPKt called 0 returned 0% blocks executed 0%
    #####: 2057:int ImStrlenW(const ImWchar* str)
        -: 2058:{
        -: 2059:    //return (int)wcslen((const wchar_t*)str);  // FIXME-OPT: Could use this when wchar_t are 16-bit
    #####: 2060:    int n = 0;
    #####: 2061:    while (*str++) n++;
    %%%%%: 2061-block 2
    %%%%%: 2061-block 3
    %%%%%: 2061-block 4
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2062:    return n;
    %%%%%: 2062-block 5
        -: 2063:}
        -: 2064:
        -: 2065:// Find end-of-line. Return pointer will point to either first \n, either str_end.
function _Z13ImStreolRangePKcS0_ called 0 returned 0% blocks executed 0%
    #####: 2066:const char* ImStreolRange(const char* str, const char* str_end)
        -: 2067:{
    #####: 2068:    const char* p = (const char*)memchr(str, '\n', str_end - str);
    #####: 2069:    return p ? p : str_end;
    %%%%%: 2069-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2069-block 3
    %%%%%: 2069-block 4
    %%%%%: 2069-block 5
        -: 2070:}
        -: 2071:
function _Z8ImStrbolPKcS0_ called 0 returned 0% blocks executed 0%
    #####: 2072:const char* ImStrbol(const char* buf_mid_line, const char* buf_begin) // find beginning-of-line
        -: 2073:{
    #####: 2074:    while (buf_mid_line > buf_begin && buf_mid_line[-1] != '\n')
    %%%%%: 2074-block 2
    %%%%%: 2074-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2074-block 5
branch  2 never executed
branch  3 never executed (fallthrough)
    #####: 2075:        buf_mid_line--;
    %%%%%: 2075-block 3
    #####: 2076:    return buf_mid_line;
    %%%%%: 2076-block 6
        -: 2077:}
        -: 2078:
function _Z9ImStristrPKcS0_S0_S0_ called 0 returned 0% blocks executed 0%
    #####: 2079:const char* ImStristr(const char* haystack, const char* haystack_end, const char* needle, const char* needle_end)
        -: 2080:{
    #####: 2081:    if (!needle_end)
    %%%%%: 2081-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2082:        needle_end = needle + strlen(needle);
    %%%%%: 2082-block 3
        -: 2083:
    #####: 2084:    const char un0 = (char)ImToUpper(*needle);
    %%%%%: 2084-block 4
call    0 never executed
    #####: 2085:    while ((!haystack_end && *haystack) || (haystack_end && haystack < haystack_end))
    %%%%%: 2085-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2085-block 19
branch  2 never executed
branch  3 never executed (fallthrough)
    %%%%%: 2085-block 20
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 2085-block 21
branch  6 never executed
branch  7 never executed (fallthrough)
        -: 2086:    {
    #####: 2087:        if (ImToUpper(*haystack) == un0)
    %%%%%: 2087-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -: 2088:        {
    #####: 2089:            const char* b = needle + 1;
    #####: 2090:            for (const char* a = haystack + 1; b < needle_end; a++, b++)
    %%%%%: 2090-block 8
    %%%%%: 2090-block 13
    %%%%%: 2090-block 14
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2091:                if (ImToUpper(*a) != ImToUpper(*b))
    %%%%%: 2091-block 9
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2092:                    break;
    %%%%%: 2092-block 12
    #####: 2093:            if (b == needle_end)
    %%%%%: 2093-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2094:                return haystack;
    %%%%%: 2094-block 16
        -: 2095:        }
    #####: 2096:        haystack++;
    %%%%%: 2096-block 17
        -: 2097:    }
    #####: 2098:    return NULL;
    %%%%%: 2098-block 22
        -: 2099:}
        -: 2100:
        -: 2101:// Trim str by offsetting contents when there's leading data + writing a \0 at the trailing position. We use this in situation where the cost is negligible.
function _Z15ImStrTrimBlanksPc called 0 returned 0% blocks executed 0%
    #####: 2102:void ImStrTrimBlanks(char* buf)
        -: 2103:{
    #####: 2104:    char* p = buf;
    #####: 2105:    while (p[0] == ' ' || p[0] == '\t')     // Leading blanks
    %%%%%: 2105-block 2
    %%%%%: 2105-block 4
branch  0 never executed
branch  1 never executed (fallthrough)
    %%%%%: 2105-block 5
branch  2 never executed
branch  3 never executed (fallthrough)
    #####: 2106:        p++;
    %%%%%: 2106-block 3
    #####: 2107:    char* p_start = p;
    #####: 2108:    while (*p != 0)                         // Find end of string
    %%%%%: 2108-block 6
    %%%%%: 2108-block 8
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2109:        p++;
    %%%%%: 2109-block 7
    #####: 2110:    while (p > p_start && (p[-1] == ' ' || p[-1] == '\t'))  // Trailing blanks
    %%%%%: 2110-block 9
    %%%%%: 2110-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2110-block 12
branch  2 never executed
branch  3 never executed (fallthrough)
    %%%%%: 2110-block 13
branch  4 never executed
branch  5 never executed (fallthrough)
    #####: 2111:        p--;
    %%%%%: 2111-block 10
    #####: 2112:    if (p_start != buf)                     // Copy memory if we had leading blanks
    %%%%%: 2112-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2113:        memmove(buf, p_start, p - p_start);
    %%%%%: 2113-block 15
    #####: 2114:    buf[p - p_start] = 0;                   // Zero terminate
    #####: 2115:}
        -: 2116:
function _Z14ImStrSkipBlankPKc called 71 returned 100% blocks executed 100%
       71: 2117:const char* ImStrSkipBlank(const char* str)
        -: 2118:{
      194: 2119:    while (str[0] == ' ' || str[0] == '\t')
       71: 2119-block 2
      194: 2119-block 4
branch  0 taken 123
branch  1 taken 71 (fallthrough)
       71: 2119-block 5
branch  2 taken 0
branch  3 taken 71 (fallthrough)
      123: 2120:        str++;
      123: 2120-block 3
       71: 2121:    return str;
       71: 2121-block 6
        -: 2122:}
        -: 2123:
        -: 2124:// A) MSVC version appears to return -1 on overflow, whereas glibc appears to return total count (which may be >= buf_size).
        -: 2125:// Ideally we would test for only one of those limits at runtime depending on the behavior the vsnprintf(), but trying to deduct it at compile time sounds like a pandora can of worm.
        -: 2126:// B) When buf==NULL vsnprintf() will return the output size.
        -: 2127:#ifndef IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS
        -: 2128:
        -: 2129:// We support stb_sprintf which is much faster (see: https://github.com/nothings/stb/blob/master/stb_sprintf.h)
        -: 2130:// You may set IMGUI_USE_STB_SPRINTF to use our default wrapper, or set IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS
        -: 2131:// and setup the wrapper yourself. (FIXME-OPT: Some of our high-level operations such as ImGuiTextBuffer::appendfv() are
        -: 2132:// designed using two-passes worst case, which probably could be improved using the stbsp_vsprintfcb() function.)
        -: 2133:#ifdef IMGUI_USE_STB_SPRINTF
        -: 2134:#ifndef IMGUI_DISABLE_STB_SPRINTF_IMPLEMENTATION
        -: 2135:#define STB_SPRINTF_IMPLEMENTATION
        -: 2136:#endif
        -: 2137:#ifdef IMGUI_STB_SPRINTF_FILENAME
        -: 2138:#include IMGUI_STB_SPRINTF_FILENAME
        -: 2139:#else
        -: 2140:#include "stb_sprintf.h"
        -: 2141:#endif
        -: 2142:#endif // #ifdef IMGUI_USE_STB_SPRINTF
        -: 2143:
        -: 2144:#if defined(_MSC_VER) && !defined(vsnprintf)
        -: 2145:#define vsnprintf _vsnprintf
        -: 2146:#endif
        -: 2147:
function _Z14ImFormatStringPcmPKcz called 2387 returned 100% blocks executed 75%
     2387: 2148:int ImFormatString(char* buf, size_t buf_size, const char* fmt, ...)
        -: 2149:{
        -: 2150:    va_list args;
     2387: 2151:    va_start(args, fmt);
        -: 2152:#ifdef IMGUI_USE_STB_SPRINTF
        -: 2153:    int w = stbsp_vsnprintf(buf, (int)buf_size, fmt, args);
        -: 2154:#else
     2387: 2155:    int w = vsnprintf(buf, buf_size, fmt, args);
        -: 2156:#endif
     2387: 2157:    va_end(args);
     2387: 2158:    if (buf == NULL)
     2387: 2158-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 2387
    #####: 2159:        return w;
    %%%%%: 2159-block 3
     2387: 2160:    if (w == -1 || w >= (int)buf_size)
     2387: 2160-block 4
branch  0 taken 2387 (fallthrough)
branch  1 taken 0
     2387: 2160-block 5
branch  2 taken 0 (fallthrough)
branch  3 taken 2387
    #####: 2161:        w = (int)buf_size - 1;
    %%%%%: 2161-block 6
     2387: 2162:    buf[w] = 0;
     2387: 2163:    return w;
     2387: 2163-block 7
        -: 2164:}
        -: 2165:
function _Z15ImFormatStringVPcmPKcP13__va_list_tag called 429311 returned 100% blocks executed 86%
   429311: 2166:int ImFormatStringV(char* buf, size_t buf_size, const char* fmt, va_list args)
        -: 2167:{
        -: 2168:#ifdef IMGUI_USE_STB_SPRINTF
        -: 2169:    int w = stbsp_vsnprintf(buf, (int)buf_size, fmt, args);
        -: 2170:#else
   429311: 2171:    int w = vsnprintf(buf, buf_size, fmt, args);
        -: 2172:#endif
   429311: 2173:    if (buf == NULL)
   429311: 2173-block 2
branch  0 taken 318 (fallthrough)
branch  1 taken 428993
      318: 2174:        return w;
      318: 2174-block 3
   428993: 2175:    if (w == -1 || w >= (int)buf_size)
   428993: 2175-block 4
branch  0 taken 428993 (fallthrough)
branch  1 taken 0
   428993: 2175-block 5
branch  2 taken 0 (fallthrough)
branch  3 taken 428993
    #####: 2176:        w = (int)buf_size - 1;
    %%%%%: 2176-block 6
   428993: 2177:    buf[w] = 0;
   428993: 2178:    return w;
   428993: 2178-block 7
        -: 2179:}
        -: 2180:#endif // #ifdef IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS
        -: 2181:
function _Z26ImFormatStringToTempBufferPPKcS1_S0_z called 6462 returned 100% blocks executed 100%
     6462: 2182:void ImFormatStringToTempBuffer(const char** out_buf, const char** out_buf_end, const char* fmt, ...)
        -: 2183:{
        -: 2184:    va_list args;
     6462: 2185:    va_start(args, fmt);
     6462: 2186:    ImFormatStringToTempBufferV(out_buf, out_buf_end, fmt, args);
     6462: 2186-block 2
call    0 returned 6462
branch  1 taken 6462 (fallthrough)
branch  2 taken 0 (throw)
     6462: 2187:    va_end(args);
     6462: 2188:}
     6462: 2188-block 3
        -: 2189:
        -: 2190:// FIXME: Should rework API toward allowing multiple in-flight temp buffers (easier and safer for caller)
        -: 2191:// by making the caller acquire a temp buffer token, with either explicit or destructor release, e.g.
        -: 2192://  ImGuiTempBufferToken token;
        -: 2193://  ImFormatStringToTempBuffer(token, ...);
function _Z27ImFormatStringToTempBufferVPPKcS1_S0_P13__va_list_tag called 428675 returned 100% blocks executed 39%
   428675: 2194:void ImFormatStringToTempBufferV(const char** out_buf, const char** out_buf_end, const char* fmt, va_list args)
        -: 2195:{
   428675: 2196:    ImGuiContext& g = *GImGui;
   428675: 2197:    if (fmt[0] == '%' && fmt[1] == 's' && fmt[2] == 0)
   428675: 2197-block 2
branch  0 taken 61636 (fallthrough)
branch  1 taken 367039
    61636: 2197-block 3
branch  2 taken 6462 (fallthrough)
branch  3 taken 55174
     6462: 2197-block 4
branch  4 taken 0 (fallthrough)
branch  5 taken 6462
        -: 2198:    {
    #####: 2199:        const char* buf = va_arg(args, const char*); // Skip formatting when using "%s"
    %%%%%: 2199-block 5
call    0 never executed
    #####: 2200:        if (buf == NULL)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2201:            buf = "(null)";
    %%%%%: 2201-block 7
    #####: 2202:        *out_buf = buf;
    #####: 2203:        if (out_buf_end) { *out_buf_end = buf + strlen(buf); }
    %%%%%: 2203-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2203-block 9
    #####: 2204:    }
    %%%%%: 2204-block 10
  428675*: 2205:    else if (fmt[0] == '%' && fmt[1] == '.' && fmt[2] == '*' && fmt[3] == 's' && fmt[4] == 0)
   428675: 2205-block 11
branch  0 taken 61636 (fallthrough)
branch  1 taken 367039
    61636: 2205-block 12
branch  2 taken 0 (fallthrough)
branch  3 taken 61636
    %%%%%: 2205-block 13
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 2205-block 14
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 2205-block 15
branch  8 never executed (fallthrough)
branch  9 never executed
        -: 2206:    {
    #####: 2207:        int buf_len = va_arg(args, int); // Skip formatting when using "%.*s"
    %%%%%: 2207-block 16
call    0 never executed
    #####: 2208:        const char* buf = va_arg(args, const char*);
call    0 never executed
    #####: 2209:        if (buf == NULL)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2210:        {
    #####: 2211:            buf = "(null)";
    #####: 2212:            buf_len = ImMin(buf_len, 6);
    %%%%%: 2212-block 19
call    0 never executed
        -: 2213:        }
    #####: 2214:        *out_buf = buf;
    #####: 2215:        *out_buf_end = buf + buf_len; // Disallow not passing 'out_buf_end' here. User is expected to use it.
    #####: 2216:    }
    %%%%%: 2216-block 20
        -: 2217:    else
        -: 2218:    {
   428675: 2219:        int buf_len = ImFormatStringV(g.TempBuffer.Data, g.TempBuffer.Size, fmt, args);
   428675: 2219-block 21
call    0 returned 428675
   428675: 2220:        *out_buf = g.TempBuffer.Data;
   428675: 2221:        if (out_buf_end) { *out_buf_end = g.TempBuffer.Data + buf_len; }
branch  0 taken 422213 (fallthrough)
branch  1 taken 6462
   422213: 2221-block 23
        -: 2222:    }
   428675: 2223:}
        -: 2224:
        -: 2225:// CRC32 needs a 1KB lookup table (not cache friendly)
        -: 2226:// Although the code to generate the table is simple and shorter than the table itself, using a const table allows us to easily:
        -: 2227:// - avoid an unnecessary branch/memory tap, - keep the ImHashXXX functions usable by static constructors, - make it thread-safe.
        -: 2228:static const ImU32 GCrc32LookupTable[256] =
        -: 2229:{
        -: 2230:    0x00000000,0x77073096,0xEE0E612C,0x990951BA,0x076DC419,0x706AF48F,0xE963A535,0x9E6495A3,0x0EDB8832,0x79DCB8A4,0xE0D5E91E,0x97D2D988,0x09B64C2B,0x7EB17CBD,0xE7B82D07,0x90BF1D91,
        -: 2231:    0x1DB71064,0x6AB020F2,0xF3B97148,0x84BE41DE,0x1ADAD47D,0x6DDDE4EB,0xF4D4B551,0x83D385C7,0x136C9856,0x646BA8C0,0xFD62F97A,0x8A65C9EC,0x14015C4F,0x63066CD9,0xFA0F3D63,0x8D080DF5,
        -: 2232:    0x3B6E20C8,0x4C69105E,0xD56041E4,0xA2677172,0x3C03E4D1,0x4B04D447,0xD20D85FD,0xA50AB56B,0x35B5A8FA,0x42B2986C,0xDBBBC9D6,0xACBCF940,0x32D86CE3,0x45DF5C75,0xDCD60DCF,0xABD13D59,
        -: 2233:    0x26D930AC,0x51DE003A,0xC8D75180,0xBFD06116,0x21B4F4B5,0x56B3C423,0xCFBA9599,0xB8BDA50F,0x2802B89E,0x5F058808,0xC60CD9B2,0xB10BE924,0x2F6F7C87,0x58684C11,0xC1611DAB,0xB6662D3D,
        -: 2234:    0x76DC4190,0x01DB7106,0x98D220BC,0xEFD5102A,0x71B18589,0x06B6B51F,0x9FBFE4A5,0xE8B8D433,0x7807C9A2,0x0F00F934,0x9609A88E,0xE10E9818,0x7F6A0DBB,0x086D3D2D,0x91646C97,0xE6635C01,
        -: 2235:    0x6B6B51F4,0x1C6C6162,0x856530D8,0xF262004E,0x6C0695ED,0x1B01A57B,0x8208F4C1,0xF50FC457,0x65B0D9C6,0x12B7E950,0x8BBEB8EA,0xFCB9887C,0x62DD1DDF,0x15DA2D49,0x8CD37CF3,0xFBD44C65,
        -: 2236:    0x4DB26158,0x3AB551CE,0xA3BC0074,0xD4BB30E2,0x4ADFA541,0x3DD895D7,0xA4D1C46D,0xD3D6F4FB,0x4369E96A,0x346ED9FC,0xAD678846,0xDA60B8D0,0x44042D73,0x33031DE5,0xAA0A4C5F,0xDD0D7CC9,
        -: 2237:    0x5005713C,0x270241AA,0xBE0B1010,0xC90C2086,0x5768B525,0x206F85B3,0xB966D409,0xCE61E49F,0x5EDEF90E,0x29D9C998,0xB0D09822,0xC7D7A8B4,0x59B33D17,0x2EB40D81,0xB7BD5C3B,0xC0BA6CAD,
        -: 2238:    0xEDB88320,0x9ABFB3B6,0x03B6E20C,0x74B1D29A,0xEAD54739,0x9DD277AF,0x04DB2615,0x73DC1683,0xE3630B12,0x94643B84,0x0D6D6A3E,0x7A6A5AA8,0xE40ECF0B,0x9309FF9D,0x0A00AE27,0x7D079EB1,
        -: 2239:    0xF00F9344,0x8708A3D2,0x1E01F268,0x6906C2FE,0xF762575D,0x806567CB,0x196C3671,0x6E6B06E7,0xFED41B76,0x89D32BE0,0x10DA7A5A,0x67DD4ACC,0xF9B9DF6F,0x8EBEEFF9,0x17B7BE43,0x60B08ED5,
        -: 2240:    0xD6D6A3E8,0xA1D1937E,0x38D8C2C4,0x4FDFF252,0xD1BB67F1,0xA6BC5767,0x3FB506DD,0x48B2364B,0xD80D2BDA,0xAF0A1B4C,0x36034AF6,0x41047A60,0xDF60EFC3,0xA867DF55,0x316E8EEF,0x4669BE79,
        -: 2241:    0xCB61B38C,0xBC66831A,0x256FD2A0,0x5268E236,0xCC0C7795,0xBB0B4703,0x220216B9,0x5505262F,0xC5BA3BBE,0xB2BD0B28,0x2BB45A92,0x5CB36A04,0xC2D7FFA7,0xB5D0CF31,0x2CD99E8B,0x5BDEAE1D,
        -: 2242:    0x9B64C2B0,0xEC63F226,0x756AA39C,0x026D930A,0x9C0906A9,0xEB0E363F,0x72076785,0x05005713,0x95BF4A82,0xE2B87A14,0x7BB12BAE,0x0CB61B38,0x92D28E9B,0xE5D5BE0D,0x7CDCEFB7,0x0BDBDF21,
        -: 2243:    0x86D3D2D4,0xF1D4E242,0x68DDB3F8,0x1FDA836E,0x81BE16CD,0xF6B9265B,0x6FB077E1,0x18B74777,0x88085AE6,0xFF0F6A70,0x66063BCA,0x11010B5C,0x8F659EFF,0xF862AE69,0x616BFFD3,0x166CCF45,
        -: 2244:    0xA00AE278,0xD70DD2EE,0x4E048354,0x3903B3C2,0xA7672661,0xD06016F7,0x4969474D,0x3E6E77DB,0xAED16A4A,0xD9D65ADC,0x40DF0B66,0x37D83BF0,0xA9BCAE53,0xDEBB9EC5,0x47B2CF7F,0x30B5FFE9,
        -: 2245:    0xBDBDF21C,0xCABAC28A,0x53B39330,0x24B4A3A6,0xBAD03605,0xCDD70693,0x54DE5729,0x23D967BF,0xB3667A2E,0xC4614AB8,0x5D681B02,0x2A6F2B94,0xB40BBE37,0xC30C8EA1,0x5A05DF1B,0x2D02EF8D,
        -: 2246:};
        -: 2247:
        -: 2248:// Known size hash
        -: 2249:// It is ok to call ImHashData on a string with known length but the ### operator won't be supported.
        -: 2250:// FIXME-OPT: Replace with e.g. FNV1a hash? CRC32 pretty much randomly access 1KB. Need to do proper measurements.
function _Z10ImHashDataPKvmj called 75417 returned 100% blocks executed 100%
    75417: 2251:ImGuiID ImHashData(const void* data_p, size_t data_size, ImGuiID seed)
        -: 2252:{
    75417: 2253:    ImU32 crc = ~seed;
    75417: 2254:    const unsigned char* data = (const unsigned char*)data_p;
    75417: 2255:    const ImU32* crc32_lut = GCrc32LookupTable;
   381393: 2256:    while (data_size-- != 0)
    75417: 2256-block 2
   381393: 2256-block 4
branch  0 taken 305976
branch  1 taken 75417 (fallthrough)
   305976: 2257:        crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ *data++];
   305976: 2257-block 3
    75417: 2258:    return ~crc;
    75417: 2258-block 5
        -: 2259:}
        -: 2260:
        -: 2261:// Zero-terminated string hash, with support for ### to reset back to seed value
        -: 2262:// We support a syntax of "label###id" where only "###id" is included in the hash, and only "label" gets displayed.
        -: 2263:// Because this syntax is rarely used we are optimizing for the common case.
        -: 2264:// - If we reach ### in the string we discard the hash so far and reset to the seed.
        -: 2265:// - We don't do 'current += 2; continue;' after handling ### to keep the code smaller/faster (measured ~10% diff in Debug build)
        -: 2266:// FIXME-OPT: Replace with e.g. FNV1a hash? CRC32 pretty much randomly access 1KB. Need to do proper measurements.
function _Z9ImHashStrPKcmj called 217782 returned 100% blocks executed 94%
   217782: 2267:ImGuiID ImHashStr(const char* data_p, size_t data_size, ImGuiID seed)
        -: 2268:{
   217782: 2269:    seed = ~seed;
   217782: 2270:    ImU32 crc = seed;
   217782: 2271:    const unsigned char* data = (const unsigned char*)data_p;
   217782: 2272:    const ImU32* crc32_lut = GCrc32LookupTable;
   217782: 2273:    if (data_size != 0)
   217782: 2273-block 2
branch  0 taken 11 (fallthrough)
branch  1 taken 217771
        -: 2274:    {
      159: 2275:        while (data_size-- != 0)
       11: 2275-block 3
      159: 2275-block 10
branch  0 taken 148
branch  1 taken 11
        -: 2276:        {
      148: 2277:            unsigned char c = *data++;
      148: 2278:            if (c == '#' && data_size >= 2 && data[0] == '#' && data[1] == '#')
      148: 2278-block 4
branch  0 taken 2 (fallthrough)
branch  1 taken 146
        2: 2278-block 5
branch  2 taken 2 (fallthrough)
branch  3 taken 0
        2: 2278-block 6
branch  4 taken 1 (fallthrough)
branch  5 taken 1
        1: 2278-block 7
branch  6 taken 0 (fallthrough)
branch  7 taken 1
    #####: 2279:                crc = seed;
    %%%%%: 2279-block 8
      148: 2280:            crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];
      148: 2280-block 9
        -: 2281:        }
        -: 2282:    }
        -: 2283:    else
        -: 2284:    {
  2515922: 2285:        while (unsigned char c = *data++)
  2515922: 2285-block 11
branch  0 taken 2298151 (fallthrough)
branch  1 taken 217771
        -: 2286:        {
  2298151: 2287:            if (c == '#' && data[0] == '#' && data[1] == '#')
  2298151: 2287-block 12
branch  0 taken 149064 (fallthrough)
branch  1 taken 2149087
   149064: 2287-block 13
branch  2 taken 55147 (fallthrough)
branch  3 taken 93917
    55147: 2287-block 14
branch  4 taken 1077 (fallthrough)
branch  5 taken 54070
     1077: 2288:                crc = seed;
     1077: 2288-block 15
  2298151: 2289:            crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];
  2298151: 2290:        }
  2298151: 2290-block 16
        -: 2291:    }
   217782: 2292:    return ~crc;
   217782: 2292-block 17
        -: 2293:}
        -: 2294:
        -: 2295://-----------------------------------------------------------------------------
        -: 2296:// [SECTION] MISC HELPERS/UTILITIES (File functions)
        -: 2297://-----------------------------------------------------------------------------
        -: 2298:
        -: 2299:// Default file functions
        -: 2300:#ifndef IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS
        -: 2301:
function _Z10ImFileOpenPKcS0_ called 13 returned 100% blocks executed 100%
       13: 2302:ImFileHandle ImFileOpen(const char* filename, const char* mode)
        -: 2303:{
        -: 2304:#if defined(_WIN32) && !defined(IMGUI_DISABLE_WIN32_FUNCTIONS) && !defined(__CYGWIN__) && !defined(__GNUC__)
        -: 2305:    // We need a fopen() wrapper because MSVC/Windows fopen doesn't handle UTF-8 filenames.
        -: 2306:    // Previously we used ImTextCountCharsFromUtf8/ImTextStrFromUtf8 here but we now need to support ImWchar16 and ImWchar32!
        -: 2307:    const int filename_wsize = ::MultiByteToWideChar(CP_UTF8, 0, filename, -1, NULL, 0);
        -: 2308:    const int mode_wsize = ::MultiByteToWideChar(CP_UTF8, 0, mode, -1, NULL, 0);
        -: 2309:
        -: 2310:    // Use stack buffer if possible, otherwise heap buffer. Sizes include zero terminator.
        -: 2311:    // We don't rely on current ImGuiContext as this is implied to be a helper function which doesn't depend on it (see #7314).
        -: 2312:    wchar_t local_temp_stack[FILENAME_MAX];
        -: 2313:    ImVector<wchar_t> local_temp_heap;
        -: 2314:    if (filename_wsize + mode_wsize > IM_ARRAYSIZE(local_temp_stack))
        -: 2315:        local_temp_heap.resize(filename_wsize + mode_wsize);
        -: 2316:    wchar_t* filename_wbuf = local_temp_heap.Data ? local_temp_heap.Data : local_temp_stack;
        -: 2317:    wchar_t* mode_wbuf = filename_wbuf + filename_wsize;
        -: 2318:    ::MultiByteToWideChar(CP_UTF8, 0, filename, -1, filename_wbuf, filename_wsize);
        -: 2319:    ::MultiByteToWideChar(CP_UTF8, 0, mode, -1, mode_wbuf, mode_wsize);
        -: 2320:    return ::_wfopen(filename_wbuf, mode_wbuf);
        -: 2321:#else
       13: 2322:    return fopen(filename, mode);
       13: 2322-block 2
call    0 returned 13
        -: 2323:#endif
        -: 2324:}
        -: 2325:
        -: 2326:// We should in theory be using fseeko()/ftello() with off_t and _fseeki64()/_ftelli64() with __int64, waiting for the PR that does that in a very portable pre-C++11 zero-warnings way.
function _Z11ImFileCloseP8_IO_FILE called 13 returned 100% blocks executed 100%
       13: 2327:bool    ImFileClose(ImFileHandle f)     { return fclose(f) == 0; }
       13: 2327-block 2
call    0 returned 13
function _Z13ImFileGetSizeP8_IO_FILE called 11 returned 100% blocks executed 92%
      11*: 2328:ImU64   ImFileGetSize(ImFileHandle f)   { long off = 0, sz = 0; return ((off = ftell(f)) != -1 && !fseek(f, 0, SEEK_END) && (sz = ftell(f)) != -1 && !fseek(f, off, SEEK_SET)) ? (ImU64)sz : (ImU64)-1; }
       11: 2328-block 2
call    0 returned 11
branch  1 taken 11 (fallthrough)
branch  2 taken 0
       11: 2328-block 4
call    3 returned 11
branch  4 taken 11 (fallthrough)
branch  5 taken 0
       11: 2328-block 6
call    6 returned 11
branch  7 taken 11 (fallthrough)
branch  8 taken 0
       11: 2328-block 8
call    9 returned 11
branch 10 taken 11 (fallthrough)
branch 11 taken 0
       11: 2328-block 10
    %%%%%: 2328-block 11
       11: 2328-block 12
function _Z10ImFileReadPvyyP8_IO_FILE called 11 returned 100% blocks executed 100%
       11: 2329:ImU64   ImFileRead(void* data, ImU64 sz, ImU64 count, ImFileHandle f)           { return fread(data, (size_t)sz, (size_t)count, f); }
       11: 2329-block 2
call    0 returned 11
function _Z11ImFileWritePKvyyP8_IO_FILE called 2 returned 100% blocks executed 100%
        2: 2330:ImU64   ImFileWrite(const void* data, ImU64 sz, ImU64 count, ImFileHandle f)    { return fwrite(data, (size_t)sz, (size_t)count, f); }
        2: 2330-block 2
call    0 returned 2
        -: 2331:#endif // #ifndef IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS
        -: 2332:
        -: 2333:// Helper: Load file content into memory
        -: 2334:// Memory allocated with IM_ALLOC(), must be freed by user using IM_FREE() == ImGui::MemFree()
        -: 2335:// This can't really be used with "rt" because fseek size won't match read size.
function _Z18ImFileLoadToMemoryPKcS0_Pmi called 11 returned 100% blocks executed 66%
       11: 2336:void*   ImFileLoadToMemory(const char* filename, const char* mode, size_t* out_file_size, int padding_bytes)
        -: 2337:{
      11*: 2338:    IM_ASSERT(filename && mode);
       11: 2338-block 2
branch  0 taken 11 (fallthrough)
branch  1 taken 0
       11: 2338-block 3
branch  2 taken 11 (fallthrough)
branch  3 taken 0
       11: 2338-block 4
    %%%%%: 2338-block 5
call    4 never executed
       11: 2339:    if (out_file_size)
       11: 2339-block 6
branch  0 taken 11 (fallthrough)
branch  1 taken 0
       11: 2340:        *out_file_size = 0;
       11: 2340-block 7
        -: 2341:
        -: 2342:    ImFileHandle f;
       11: 2343:    if ((f = ImFileOpen(filename, mode)) == NULL)
       11: 2343-block 8
call    0 returned 11
branch  1 taken 0 (fallthrough)
branch  2 taken 11
    #####: 2344:        return NULL;
    %%%%%: 2344-block 10
        -: 2345:
       11: 2346:    size_t file_size = (size_t)ImFileGetSize(f);
       11: 2346-block 11
call    0 returned 11
       11: 2347:    if (file_size == (size_t)-1)
branch  0 taken 0 (fallthrough)
branch  1 taken 11
        -: 2348:    {
    #####: 2349:        ImFileClose(f);
    %%%%%: 2349-block 13
call    0 never executed
    #####: 2350:        return NULL;
        -: 2351:    }
        -: 2352:
       11: 2353:    void* file_data = IM_ALLOC(file_size + padding_bytes);
       11: 2353-block 15
call    0 returned 11
       11: 2354:    if (file_data == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 11
        -: 2355:    {
    #####: 2356:        ImFileClose(f);
    %%%%%: 2356-block 17
call    0 never executed
    #####: 2357:        return NULL;
        -: 2358:    }
       11: 2359:    if (ImFileRead(file_data, 1, file_size, f) != file_size)
       11: 2359-block 19
call    0 returned 11
branch  1 taken 0 (fallthrough)
branch  2 taken 11
        -: 2360:    {
    #####: 2361:        ImFileClose(f);
    %%%%%: 2361-block 21
call    0 never executed
    #####: 2362:        IM_FREE(file_data);
call    0 never executed
    #####: 2363:        return NULL;
        -: 2364:    }
       11: 2365:    if (padding_bytes > 0)
       11: 2365-block 24
branch  0 taken 0 (fallthrough)
branch  1 taken 11
    #####: 2366:        memset((void*)(((char*)file_data) + file_size), 0, (size_t)padding_bytes);
    %%%%%: 2366-block 25
        -: 2367:
       11: 2368:    ImFileClose(f);
       11: 2368-block 26
call    0 returned 11
       11: 2369:    if (out_file_size)
branch  0 taken 11 (fallthrough)
branch  1 taken 0
       11: 2370:        *out_file_size = file_size;
       11: 2370-block 28
        -: 2371:
       11: 2372:    return file_data;
       11: 2372-block 29
        -: 2373:}
        -: 2374:
        -: 2375://-----------------------------------------------------------------------------
        -: 2376:// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)
        -: 2377://-----------------------------------------------------------------------------
        -: 2378:
        -: 2379:IM_MSVC_RUNTIME_CHECKS_OFF
        -: 2380:
        -: 2381:// Convert UTF-8 to 32-bit character, process single character input.
        -: 2382:// A nearly-branchless UTF-8 decoder, based on work of Christopher Wellons (https://github.com/skeeto/branchless-utf8).
        -: 2383:// We handle UTF-8 decoding error by skipping forward.
function _Z18ImTextCharFromUtf8PjPKcS1_ called 27847 returned 100% blocks executed 68%
    27847: 2384:int ImTextCharFromUtf8(unsigned int* out_char, const char* in_text, const char* in_text_end)
        -: 2385:{
        -: 2386:    static const char lengths[32] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 3, 3, 4, 0 };
        -: 2387:    static const int masks[]  = { 0x00, 0x7f, 0x1f, 0x0f, 0x07 };
        -: 2388:    static const uint32_t mins[] = { 0x400000, 0, 0x80, 0x800, 0x10000 };
        -: 2389:    static const int shiftc[] = { 0, 18, 12, 6, 0 };
        -: 2390:    static const int shifte[] = { 0, 6, 4, 2, 0 };
    27847: 2391:    int len = lengths[*(const unsigned char*)in_text >> 3];
    27847: 2392:    int wanted = len + (len ? 0 : 1);
        -: 2393:
    27847: 2394:    if (in_text_end == NULL)
    27847: 2394-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 27847
    #####: 2395:        in_text_end = in_text + wanted; // Max length, nulls will be taken into account.
    %%%%%: 2395-block 3
        -: 2396:
        -: 2397:    // Copy at most 'len' bytes, stop copying at 0 or past in_text_end. Branch predictor does a good job here,
        -: 2398:    // so it is fast even with excessive branching.
        -: 2399:    unsigned char s[4];
   27847*: 2400:    s[0] = in_text + 0 < in_text_end ? in_text[0] : 0;
    27847: 2400-block 4
branch  0 taken 27847 (fallthrough)
branch  1 taken 0
    27847: 2400-block 5
    %%%%%: 2400-block 6
   27847*: 2401:    s[1] = in_text + 1 < in_text_end ? in_text[1] : 0;
    27847: 2401-block 7
branch  0 taken 27847 (fallthrough)
branch  1 taken 0
    27847: 2401-block 8
    %%%%%: 2401-block 9
   27847*: 2402:    s[2] = in_text + 2 < in_text_end ? in_text[2] : 0;
    27847: 2402-block 10
branch  0 taken 27847 (fallthrough)
branch  1 taken 0
    27847: 2402-block 11
    %%%%%: 2402-block 12
    27847: 2403:    s[3] = in_text + 3 < in_text_end ? in_text[3] : 0;
    27847: 2403-block 13
branch  0 taken 4305 (fallthrough)
branch  1 taken 23542
     4305: 2403-block 14
    23542: 2403-block 15
        -: 2404:
        -: 2405:    // Assume a four-byte character and load four bytes. Unused bits are shifted out.
    27847: 2406:    *out_char  = (uint32_t)(s[0] & masks[len]) << 18;
    27847: 2407:    *out_char |= (uint32_t)(s[1] & 0x3f) << 12;
    27847: 2408:    *out_char |= (uint32_t)(s[2] & 0x3f) <<  6;
    27847: 2409:    *out_char |= (uint32_t)(s[3] & 0x3f) <<  0;
    27847: 2410:    *out_char >>= shiftc[len];
        -: 2411:
        -: 2412:    // Accumulate the various error conditions.
    27847: 2413:    int e = 0;
   27847*: 2414:    e  = (*out_char < mins[len]) << 6; // non-canonical encoding
    27847: 2414-block 16
branch  0 taken 0 (fallthrough)
branch  1 taken 27847
    %%%%%: 2414-block 17
    27847: 2414-block 18
   27847*: 2415:    e |= ((*out_char >> 11) == 0x1b) << 7;  // surrogate half?
    27847: 2415-block 19
branch  0 taken 0 (fallthrough)
branch  1 taken 27847
    %%%%%: 2415-block 20
    27847: 2415-block 21
   27847*: 2416:    e |= (*out_char > IM_UNICODE_CODEPOINT_MAX) << 8;  // out of range?
    27847: 2416-block 22
branch  0 taken 0 (fallthrough)
branch  1 taken 27847
    %%%%%: 2416-block 23
    27847: 2416-block 24
    27847: 2417:    e |= (s[1] & 0xc0) >> 2;
    27847: 2418:    e |= (s[2] & 0xc0) >> 4;
    27847: 2419:    e |= (s[3]       ) >> 6;
    27847: 2420:    e ^= 0x2a; // top two bits of each tail byte correct?
    27847: 2421:    e >>= shifte[len];
        -: 2422:
    27847: 2423:    if (e)
    27847: 2423-block 25
branch  0 taken 0 (fallthrough)
branch  1 taken 27847
        -: 2424:    {
        -: 2425:        // No bytes are consumed when *in_text == 0 || in_text == in_text_end.
        -: 2426:        // One byte is consumed in case of invalid first byte of in_text.
        -: 2427:        // All available bytes (at most `len` bytes) are consumed on incomplete/invalid second to last bytes.
        -: 2428:        // Invalid or incomplete input may consume less bytes than wanted, therefore every byte has to be inspected in s.
    #####: 2429:        wanted = ImMin(wanted, !!s[0] + !!s[1] + !!s[2] + !!s[3]);
    %%%%%: 2429-block 26
call    0 never executed
    #####: 2430:        *out_char = IM_UNICODE_CODEPOINT_INVALID;
        -: 2431:    }
        -: 2432:
    27847: 2433:    return wanted;
    27847: 2433-block 28
        -: 2434:}
        -: 2435:
function _Z17ImTextStrFromUtf8PtiPKcS1_PS1_ called 0 returned 0% blocks executed 0%
    #####: 2436:int ImTextStrFromUtf8(ImWchar* buf, int buf_size, const char* in_text, const char* in_text_end, const char** in_text_remaining)
        -: 2437:{
    #####: 2438:    ImWchar* buf_out = buf;
    #####: 2439:    ImWchar* buf_end = buf + buf_size;
    #####: 2440:    while (buf_out < buf_end - 1 && (!in_text_end || in_text < in_text_end) && *in_text)
    %%%%%: 2440-block 2
    %%%%%: 2440-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2440-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2440-block 7
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 2440-block 8
branch  6 never executed
branch  7 never executed (fallthrough)
        -: 2441:    {
        -: 2442:        unsigned int c;
    #####: 2443:        in_text += ImTextCharFromUtf8(&c, in_text, in_text_end);
    %%%%%: 2443-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 2444:        *buf_out++ = (ImWchar)c;
    %%%%%: 2444-block 4
        -: 2445:    }
    #####: 2446:    *buf_out = 0;
    #####: 2447:    if (in_text_remaining)
    %%%%%: 2447-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2448:        *in_text_remaining = in_text;
    %%%%%: 2448-block 10
    #####: 2449:    return (int)(buf_out - buf);
    %%%%%: 2449-block 11
    %%%%%: 2449-block 12
        -: 2450:}
        -: 2451:
function _Z24ImTextCountCharsFromUtf8PKcS0_ called 0 returned 0% blocks executed 0%
    #####: 2452:int ImTextCountCharsFromUtf8(const char* in_text, const char* in_text_end)
        -: 2453:{
    #####: 2454:    int char_count = 0;
    #####: 2455:    while ((!in_text_end || in_text < in_text_end) && *in_text)
    %%%%%: 2455-block 2
    %%%%%: 2455-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2455-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2455-block 7
branch  4 never executed
branch  5 never executed (fallthrough)
        -: 2456:    {
        -: 2457:        unsigned int c;
    #####: 2458:        in_text += ImTextCharFromUtf8(&c, in_text, in_text_end);
    %%%%%: 2458-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 2459:        char_count++;
    %%%%%: 2459-block 4
        -: 2460:    }
    #####: 2461:    return char_count;
    %%%%%: 2461-block 8
    %%%%%: 2461-block 9
        -: 2462:}
        -: 2463:
        -: 2464:// Based on stb_to_utf8() from github.com/nothings/stb/
function _ZL23ImTextCharToUtf8_inlinePcij called 0 returned 0% blocks executed 0%
    #####: 2465:static inline int ImTextCharToUtf8_inline(char* buf, int buf_size, unsigned int c)
        -: 2466:{
    #####: 2467:    if (c < 0x80)
    %%%%%: 2467-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2468:    {
    #####: 2469:        buf[0] = (char)c;
    #####: 2470:        return 1;
    %%%%%: 2470-block 3
        -: 2471:    }
    #####: 2472:    if (c < 0x800)
    %%%%%: 2472-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2473:    {
    #####: 2474:        if (buf_size < 2) return 0;
    %%%%%: 2474-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2474-block 6
    #####: 2475:        buf[0] = (char)(0xc0 + (c >> 6));
    #####: 2476:        buf[1] = (char)(0x80 + (c & 0x3f));
    #####: 2477:        return 2;
    %%%%%: 2477-block 7
        -: 2478:    }
    #####: 2479:    if (c < 0x10000)
    %%%%%: 2479-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2480:    {
    #####: 2481:        if (buf_size < 3) return 0;
    %%%%%: 2481-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2481-block 10
    #####: 2482:        buf[0] = (char)(0xe0 + (c >> 12));
    #####: 2483:        buf[1] = (char)(0x80 + ((c >> 6) & 0x3f));
    #####: 2484:        buf[2] = (char)(0x80 + ((c ) & 0x3f));
    #####: 2485:        return 3;
    %%%%%: 2485-block 11
        -: 2486:    }
    #####: 2487:    if (c <= 0x10FFFF)
    %%%%%: 2487-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2488:    {
    #####: 2489:        if (buf_size < 4) return 0;
    %%%%%: 2489-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2489-block 14
    #####: 2490:        buf[0] = (char)(0xf0 + (c >> 18));
    #####: 2491:        buf[1] = (char)(0x80 + ((c >> 12) & 0x3f));
    #####: 2492:        buf[2] = (char)(0x80 + ((c >> 6) & 0x3f));
    #####: 2493:        buf[3] = (char)(0x80 + ((c ) & 0x3f));
    #####: 2494:        return 4;
    %%%%%: 2494-block 15
        -: 2495:    }
        -: 2496:    // Invalid code point, the max unicode is 0x10FFFF
    #####: 2497:    return 0;
    %%%%%: 2497-block 16
        -: 2498:}
        -: 2499:
function _Z16ImTextCharToUtf8Pcj called 0 returned 0% blocks executed 0%
    #####: 2500:const char* ImTextCharToUtf8(char out_buf[5], unsigned int c)
        -: 2501:{
    #####: 2502:    int count = ImTextCharToUtf8_inline(out_buf, 5, c);
    %%%%%: 2502-block 2
call    0 never executed
    #####: 2503:    out_buf[count] = 0;
    #####: 2504:    return out_buf;
        -: 2505:}
        -: 2506:
        -: 2507:// Not optimal but we very rarely use this function.
function _Z28ImTextCountUtf8BytesFromCharPKcS0_ called 4305 returned 100% blocks executed 100%
     4305: 2508:int ImTextCountUtf8BytesFromChar(const char* in_text, const char* in_text_end)
        -: 2509:{
     4305: 2510:    unsigned int unused = 0;
     8610: 2511:    return ImTextCharFromUtf8(&unused, in_text, in_text_end);
     4305: 2511-block 2
call    0 returned 4305
branch  1 taken 4305 (fallthrough)
branch  2 taken 0 (throw)
     4305: 2511-block 3
     4305: 2511-block 5
        -: 2512:}
        -: 2513:
function _ZL28ImTextCountUtf8BytesFromCharj called 0 returned 0% blocks executed 0%
    #####: 2514:static inline int ImTextCountUtf8BytesFromChar(unsigned int c)
        -: 2515:{
    #####: 2516:    if (c < 0x80) return 1;
    %%%%%: 2516-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2516-block 3
    #####: 2517:    if (c < 0x800) return 2;
    %%%%%: 2517-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2517-block 5
    #####: 2518:    if (c < 0x10000) return 3;
    %%%%%: 2518-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2518-block 7
    #####: 2519:    if (c <= 0x10FFFF) return 4;
    %%%%%: 2519-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2519-block 9
    #####: 2520:    return 3;
    %%%%%: 2520-block 10
        -: 2521:}
        -: 2522:
function _Z15ImTextStrToUtf8PciPKtS1_ called 0 returned 0% blocks executed 0%
    #####: 2523:int ImTextStrToUtf8(char* out_buf, int out_buf_size, const ImWchar* in_text, const ImWchar* in_text_end)
        -: 2524:{
    #####: 2525:    char* buf_p = out_buf;
    #####: 2526:    const char* buf_end = out_buf + out_buf_size;
    #####: 2527:    while (buf_p < buf_end - 1 && (!in_text_end || in_text < in_text_end) && *in_text)
    %%%%%: 2527-block 2
    %%%%%: 2527-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2527-block 8
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2527-block 9
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 2527-block 10
branch  6 never executed
branch  7 never executed (fallthrough)
        -: 2528:    {
    #####: 2529:        unsigned int c = (unsigned int)(*in_text++);
    #####: 2530:        if (c < 0x80)
    %%%%%: 2530-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2531:            *buf_p++ = (char)c;
    %%%%%: 2531-block 4
        -: 2532:        else
    #####: 2533:            buf_p += ImTextCharToUtf8_inline(buf_p, (int)(buf_end - buf_p - 1), c);
    %%%%%: 2533-block 5
call    0 never executed
        -: 2534:    }
    #####: 2535:    *buf_p = 0;
    #####: 2536:    return (int)(buf_p - out_buf);
    %%%%%: 2536-block 11
        -: 2537:}
        -: 2538:
function _Z27ImTextCountUtf8BytesFromStrPKtS0_ called 0 returned 0% blocks executed 0%
    #####: 2539:int ImTextCountUtf8BytesFromStr(const ImWchar* in_text, const ImWchar* in_text_end)
        -: 2540:{
    #####: 2541:    int bytes_count = 0;
    #####: 2542:    while ((!in_text_end || in_text < in_text_end) && *in_text)
    %%%%%: 2542-block 2
    %%%%%: 2542-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2542-block 8
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2542-block 9
branch  4 never executed
branch  5 never executed (fallthrough)
        -: 2543:    {
    #####: 2544:        unsigned int c = (unsigned int)(*in_text++);
    #####: 2545:        if (c < 0x80)
    %%%%%: 2545-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2546:            bytes_count++;
    %%%%%: 2546-block 4
        -: 2547:        else
    #####: 2548:            bytes_count += ImTextCountUtf8BytesFromChar(c);
    %%%%%: 2548-block 5
call    0 never executed
        -: 2549:    }
    #####: 2550:    return bytes_count;
    %%%%%: 2550-block 10
        -: 2551:}
        -: 2552:
function _Z31ImTextFindPreviousUtf8CodepointPKcS0_ called 0 returned 0% blocks executed 0%
    #####: 2553:const char* ImTextFindPreviousUtf8Codepoint(const char* in_text_start, const char* in_text_curr)
        -: 2554:{
    #####: 2555:    while (in_text_curr > in_text_start)
    %%%%%: 2555-block 2
    %%%%%: 2555-block 5
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 2556:    {
    #####: 2557:        in_text_curr--;
    #####: 2558:        if ((*in_text_curr & 0xC0) != 0x80)
    %%%%%: 2558-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2559:            return in_text_curr;
    %%%%%: 2559-block 4
        -: 2560:    }
    #####: 2561:    return in_text_start;
    %%%%%: 2561-block 6
        -: 2562:}
        -: 2563:
function _Z16ImTextCountLinesPKcS0_ called 0 returned 0% blocks executed 0%
    #####: 2564:int ImTextCountLines(const char* in_text, const char* in_text_end)
        -: 2565:{
    #####: 2566:    if (in_text_end == NULL)
    %%%%%: 2566-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2567:        in_text_end = in_text + strlen(in_text); // FIXME-OPT: Not optimal approach, discourage use for now.
    %%%%%: 2567-block 3
    #####: 2568:    int count = 0;
    #####: 2569:    while (in_text < in_text_end)
    %%%%%: 2569-block 4
    %%%%%: 2569-block 9
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 2570:    {
    #####: 2571:        const char* line_end = (const char*)memchr(in_text, '\n', in_text_end - in_text);
    #####: 2572:        in_text = line_end ? line_end + 1 : in_text_end;
    %%%%%: 2572-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2572-block 6
    %%%%%: 2572-block 7
    #####: 2573:        count++;
    %%%%%: 2573-block 8
        -: 2574:    }
    #####: 2575:    return count;
    %%%%%: 2575-block 10
        -: 2576:}
        -: 2577:
        -: 2578:IM_MSVC_RUNTIME_CHECKS_RESTORE
        -: 2579:
        -: 2580://-----------------------------------------------------------------------------
        -: 2581:// [SECTION] MISC HELPERS/UTILITIES (Color functions)
        -: 2582:// Note: The Convert functions are early design which are not consistent with other API.
        -: 2583://-----------------------------------------------------------------------------
        -: 2584:
function _Z18ImAlphaBlendColorsjj called 0 returned 0% blocks executed 0%
    #####: 2585:IMGUI_API ImU32 ImAlphaBlendColors(ImU32 col_a, ImU32 col_b)
        -: 2586:{
    #####: 2587:    float t = ((col_b >> IM_COL32_A_SHIFT) & 0xFF) / 255.f;
    #####: 2588:    int r = ImLerp((int)(col_a >> IM_COL32_R_SHIFT) & 0xFF, (int)(col_b >> IM_COL32_R_SHIFT) & 0xFF, t);
    %%%%%: 2588-block 2
call    0 never executed
    #####: 2589:    int g = ImLerp((int)(col_a >> IM_COL32_G_SHIFT) & 0xFF, (int)(col_b >> IM_COL32_G_SHIFT) & 0xFF, t);
call    0 never executed
    #####: 2590:    int b = ImLerp((int)(col_a >> IM_COL32_B_SHIFT) & 0xFF, (int)(col_b >> IM_COL32_B_SHIFT) & 0xFF, t);
call    0 never executed
    #####: 2591:    return IM_COL32(r, g, b, 0xFF);
        -: 2592:}
        -: 2593:
function _ZN5ImGui23ColorConvertU32ToFloat4Ej called 44117 returned 100% blocks executed 100%
    44117: 2594:ImVec4 ImGui::ColorConvertU32ToFloat4(ImU32 in)
        -: 2595:{
    44117: 2596:    float s = 1.0f / 255.0f;
    44117: 2597:    return ImVec4(
    44117: 2597-block 4
    44117: 2598:        ((in >> IM_COL32_R_SHIFT) & 0xFF) * s,
    44117: 2599:        ((in >> IM_COL32_G_SHIFT) & 0xFF) * s,
    44117: 2600:        ((in >> IM_COL32_B_SHIFT) & 0xFF) * s,
    44117: 2601:        ((in >> IM_COL32_A_SHIFT) & 0xFF) * s);
    44117: 2601-block 2
call    0 returned 44117
        -: 2602:}
        -: 2603:
function _ZN5ImGui23ColorConvertFloat4ToU32ERK6ImVec4 called 389469 returned 100% blocks executed 100%
   389469: 2604:ImU32 ImGui::ColorConvertFloat4ToU32(const ImVec4& in)
        -: 2605:{
        -: 2606:    ImU32 out;
   389469: 2607:    out  = ((ImU32)IM_F32_TO_INT8_SAT(in.x)) << IM_COL32_R_SHIFT;
   389469: 2607-block 2
call    0 returned 389469
   389469: 2608:    out |= ((ImU32)IM_F32_TO_INT8_SAT(in.y)) << IM_COL32_G_SHIFT;
call    0 returned 389469
   389469: 2609:    out |= ((ImU32)IM_F32_TO_INT8_SAT(in.z)) << IM_COL32_B_SHIFT;
call    0 returned 389469
   389469: 2610:    out |= ((ImU32)IM_F32_TO_INT8_SAT(in.w)) << IM_COL32_A_SHIFT;
call    0 returned 389469
   389469: 2611:    return out;
        -: 2612:}
        -: 2613:
        -: 2614:// Convert rgb floats ([0-1],[0-1],[0-1]) to hsv floats ([0-1],[0-1],[0-1]), from Foley & van Dam p592
        -: 2615:// Optimized http://lolengine.net/blog/2013/01/13/fast-rgb-to-hsv
function _ZN5ImGui20ColorConvertRGBtoHSVEfffRfS0_S0_ called 0 returned 0% blocks executed 0%
    #####: 2616:void ImGui::ColorConvertRGBtoHSV(float r, float g, float b, float& out_h, float& out_s, float& out_v)
        -: 2617:{
    #####: 2618:    float K = 0.f;
    #####: 2619:    if (g < b)
    %%%%%: 2619-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2620:    {
    #####: 2621:        ImSwap(g, b);
    %%%%%: 2621-block 3
call    0 never executed
    #####: 2622:        K = -1.f;
        -: 2623:    }
    #####: 2624:    if (r < g)
    %%%%%: 2624-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2625:    {
    #####: 2626:        ImSwap(r, g);
    %%%%%: 2626-block 6
call    0 never executed
    #####: 2627:        K = -2.f / 6.f - K;
        -: 2628:    }
        -: 2629:
    #####: 2630:    const float chroma = r - (g < b ? g : b);
    %%%%%: 2630-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2630-block 9
    %%%%%: 2630-block 10
    #####: 2631:    out_h = ImFabs(K + (g - b) / (6.f * chroma + 1e-20f));
    #####: 2632:    out_s = chroma / (r + 1e-20f);
    #####: 2633:    out_v = r;
    #####: 2634:}
        -: 2635:
        -: 2636:// Convert hsv floats ([0-1],[0-1],[0-1]) to rgb floats ([0-1],[0-1],[0-1]), from Foley & van Dam p593
        -: 2637:// also http://en.wikipedia.org/wiki/HSL_and_HSV
function _ZN5ImGui20ColorConvertHSVtoRGBEfffRfS0_S0_ called 0 returned 0% blocks executed 0%
    #####: 2638:void ImGui::ColorConvertHSVtoRGB(float h, float s, float v, float& out_r, float& out_g, float& out_b)
        -: 2639:{
    #####: 2640:    if (s == 0.0f)
    %%%%%: 2640-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2641:    {
        -: 2642:        // gray
    #####: 2643:        out_r = out_g = out_b = v;
    #####: 2644:        return;
    %%%%%: 2644-block 3
        -: 2645:    }
        -: 2646:
    #####: 2647:    h = ImFmod(h, 1.0f) / (60.0f / 360.0f);
    #####: 2648:    int   i = (int)h;
    #####: 2649:    float f = h - (float)i;
    #####: 2650:    float p = v * (1.0f - s);
    #####: 2651:    float q = v * (1.0f - s * f);
    #####: 2652:    float t = v * (1.0f - s * (1.0f - f));
        -: 2653:
    #####: 2654:    switch (i)
    %%%%%: 2654-block 4
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 2655:    {
    #####: 2656:    case 0: out_r = v; out_g = t; out_b = p; break;
    %%%%%: 2656-block 5
    #####: 2657:    case 1: out_r = q; out_g = v; out_b = p; break;
    %%%%%: 2657-block 6
    #####: 2658:    case 2: out_r = p; out_g = v; out_b = t; break;
    %%%%%: 2658-block 7
    #####: 2659:    case 3: out_r = p; out_g = q; out_b = v; break;
    %%%%%: 2659-block 8
    #####: 2660:    case 4: out_r = t; out_g = p; out_b = v; break;
    %%%%%: 2660-block 9
    #####: 2661:    case 5: default: out_r = v; out_g = p; out_b = q; break;
    %%%%%: 2661-block 10
        -: 2662:    }
        -: 2663:}
        -: 2664:
        -: 2665://-----------------------------------------------------------------------------
        -: 2666:// [SECTION] ImGuiStorage
        -: 2667:// Helper: Key->value storage
        -: 2668://-----------------------------------------------------------------------------
        -: 2669:
        -: 2670:// std::lower_bound but without the bullshit
function _Z12ImLowerBoundP16ImGuiStoragePairS0_j called 20795 returned 100% blocks executed 100%
    20795: 2671:ImGuiStoragePair* ImLowerBound(ImGuiStoragePair* in_begin, ImGuiStoragePair* in_end, ImGuiID key)
        -: 2672:{
    20795: 2673:    ImGuiStoragePair* in_p = in_begin;
   101315: 2674:    for (size_t count = (size_t)(in_end - in_p); count > 0; )
    20795: 2674-block 2
   101315: 2674-block 6
branch  0 taken 80520
branch  1 taken 20795 (fallthrough)
        -: 2675:    {
    80520: 2676:        size_t count2 = count >> 1;
    80520: 2677:        ImGuiStoragePair* mid = in_p + count2;
    80520: 2678:        if (mid->key < key)
    80520: 2678-block 3
branch  0 taken 38821 (fallthrough)
branch  1 taken 41699
        -: 2679:        {
    38821: 2680:            in_p = ++mid;
    38821: 2681:            count -= count2 + 1;
    38821: 2681-block 4
        -: 2682:        }
        -: 2683:        else
        -: 2684:        {
    41699: 2685:            count = count2;
    41699: 2685-block 5
        -: 2686:        }
        -: 2687:    }
    20795: 2688:    return in_p;
    20795: 2688-block 7
        -: 2689:}
        -: 2690:
        -: 2691:IM_MSVC_RUNTIME_CHECKS_OFF
function _ZL16PairComparerByIDPKvS0_ called 0 returned 0% blocks executed 0%
    #####: 2692:static int IMGUI_CDECL PairComparerByID(const void* lhs, const void* rhs)
        -: 2693:{
        -: 2694:    // We can't just do a subtraction because qsort uses signed integers and subtracting our ID doesn't play well with that.
    #####: 2695:    ImGuiID lhs_v = ((const ImGuiStoragePair*)lhs)->key;
    #####: 2696:    ImGuiID rhs_v = ((const ImGuiStoragePair*)rhs)->key;
    #####: 2697:    return (lhs_v > rhs_v ? +1 : lhs_v < rhs_v ? -1 : 0);
    %%%%%: 2697-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2697-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2697-block 4
    %%%%%: 2697-block 5
    %%%%%: 2697-block 6
    %%%%%: 2697-block 7
    %%%%%: 2697-block 8
        -: 2698:}
        -: 2699:
        -: 2700:// For quicker full rebuild of a storage (instead of an incremental one), you may add all your contents and then sort once.
function _ZN12ImGuiStorage14BuildSortByKeyEv called 0 returned 0% blocks executed 0%
    #####: 2701:void ImGuiStorage::BuildSortByKey()
        -: 2702:{
    #####: 2703:    ImQsort(Data.Data, (size_t)Data.Size, sizeof(ImGuiStoragePair), PairComparerByID);
    %%%%%: 2703-block 2
call    0 never executed
    #####: 2704:}
        -: 2705:
function _ZNK12ImGuiStorage6GetIntEji called 35 returned 100% blocks executed 83%
       35: 2706:int ImGuiStorage::GetInt(ImGuiID key, int default_val) const
        -: 2707:{
       35: 2708:    ImGuiStoragePair* it = ImLowerBound(const_cast<ImGuiStoragePair*>(Data.Data), const_cast<ImGuiStoragePair*>(Data.Data + Data.Size), key);
       35: 2708-block 2
call    0 returned 35
       35: 2709:    if (it == Data.Data + Data.Size || it->key != key)
branch  0 taken 35 (fallthrough)
branch  1 taken 0
       35: 2709-block 4
branch  2 taken 0 (fallthrough)
branch  3 taken 35
    #####: 2710:        return default_val;
    %%%%%: 2710-block 5
       35: 2711:    return it->val_i;
       35: 2711-block 6
        -: 2712:}
        -: 2713:
function _ZNK12ImGuiStorage7GetBoolEjb called 0 returned 0% blocks executed 0%
    #####: 2714:bool ImGuiStorage::GetBool(ImGuiID key, bool default_val) const
        -: 2715:{
    #####: 2716:    return GetInt(key, default_val ? 1 : 0) != 0;
    %%%%%: 2716-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2716-block 3
    %%%%%: 2716-block 4
    %%%%%: 2716-block 5
call    2 never executed
        -: 2717:}
        -: 2718:
function _ZNK12ImGuiStorage8GetFloatEjf called 0 returned 0% blocks executed 0%
    #####: 2719:float ImGuiStorage::GetFloat(ImGuiID key, float default_val) const
        -: 2720:{
    #####: 2721:    ImGuiStoragePair* it = ImLowerBound(const_cast<ImGuiStoragePair*>(Data.Data), const_cast<ImGuiStoragePair*>(Data.Data + Data.Size), key);
    %%%%%: 2721-block 2
call    0 never executed
    #####: 2722:    if (it == Data.Data + Data.Size || it->key != key)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2722-block 4
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2723:        return default_val;
    %%%%%: 2723-block 5
    #####: 2724:    return it->val_f;
    %%%%%: 2724-block 6
        -: 2725:}
        -: 2726:
function _ZNK12ImGuiStorage10GetVoidPtrEj called 19641 returned 100% blocks executed 100%
    19641: 2727:void* ImGuiStorage::GetVoidPtr(ImGuiID key) const
        -: 2728:{
    19641: 2729:    ImGuiStoragePair* it = ImLowerBound(const_cast<ImGuiStoragePair*>(Data.Data), const_cast<ImGuiStoragePair*>(Data.Data + Data.Size), key);
    19641: 2729-block 2
call    0 returned 19641
    19641: 2730:    if (it == Data.Data + Data.Size || it->key != key)
branch  0 taken 19613 (fallthrough)
branch  1 taken 28
    19613: 2730-block 4
branch  2 taken 18 (fallthrough)
branch  3 taken 19595
       46: 2731:        return NULL;
       46: 2731-block 5
    19595: 2732:    return it->val_p;
    19595: 2732-block 6
        -: 2733:}
        -: 2734:
        -: 2735:// References are only valid until a new value is added to the storage. Calling a Set***() function or a Get***Ref() function invalidates the pointer.
function _ZN12ImGuiStorage9GetIntRefEji called 1094 returned 100% blocks executed 100%
     1094: 2736:int* ImGuiStorage::GetIntRef(ImGuiID key, int default_val)
        -: 2737:{
     1094: 2738:    ImGuiStoragePair* it = ImLowerBound(Data.Data, Data.Data + Data.Size, key);
     1094: 2738-block 2
call    0 returned 1094
     1094: 2739:    if (it == Data.Data + Data.Size || it->key != key)
branch  0 taken 1092 (fallthrough)
branch  1 taken 2
     1092: 2739-block 4
branch  2 taken 8 (fallthrough)
branch  3 taken 1084
       10: 2740:        it = Data.insert(it, ImGuiStoragePair(key, default_val));
       10: 2740-block 5
call    0 returned 10
call    1 returned 10
branch  2 taken 10 (fallthrough)
branch  3 taken 0 (throw)
       10: 2740-block 7
     1094: 2741:    return &it->val_i;
     1094: 2741-block 8
     1094: 2741-block 9
        -: 2742:}
        -: 2743:
function _ZN12ImGuiStorage10GetBoolRefEjb called 0 returned 0% blocks executed 0%
    #####: 2744:bool* ImGuiStorage::GetBoolRef(ImGuiID key, bool default_val)
        -: 2745:{
    #####: 2746:    return (bool*)GetIntRef(key, default_val ? 1 : 0);
    %%%%%: 2746-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2746-block 3
    %%%%%: 2746-block 4
    %%%%%: 2746-block 5
call    2 never executed
        -: 2747:}
        -: 2748:
function _ZN12ImGuiStorage11GetFloatRefEjf called 0 returned 0% blocks executed 0%
    #####: 2749:float* ImGuiStorage::GetFloatRef(ImGuiID key, float default_val)
        -: 2750:{
    #####: 2751:    ImGuiStoragePair* it = ImLowerBound(Data.Data, Data.Data + Data.Size, key);
    %%%%%: 2751-block 2
call    0 never executed
    #####: 2752:    if (it == Data.Data + Data.Size || it->key != key)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2752-block 4
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2753:        it = Data.insert(it, ImGuiStoragePair(key, default_val));
    %%%%%: 2753-block 5
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 2753-block 7
    #####: 2754:    return &it->val_f;
    %%%%%: 2754-block 8
    %%%%%: 2754-block 9
        -: 2755:}
        -: 2756:
function _ZN12ImGuiStorage13GetVoidPtrRefEjPv called 0 returned 0% blocks executed 0%
    #####: 2757:void** ImGuiStorage::GetVoidPtrRef(ImGuiID key, void* default_val)
        -: 2758:{
    #####: 2759:    ImGuiStoragePair* it = ImLowerBound(Data.Data, Data.Data + Data.Size, key);
    %%%%%: 2759-block 2
call    0 never executed
    #####: 2760:    if (it == Data.Data + Data.Size || it->key != key)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2760-block 4
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2761:        it = Data.insert(it, ImGuiStoragePair(key, default_val));
    %%%%%: 2761-block 5
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 2761-block 7
    #####: 2762:    return &it->val_p;
    %%%%%: 2762-block 8
    %%%%%: 2762-block 9
        -: 2763:}
        -: 2764:
        -: 2765:// FIXME-OPT: Need a way to reuse the result of lower_bound when doing GetInt()/SetInt() - not too bad because it only happens on explicit interaction (maximum one a frame)
function _ZN12ImGuiStorage6SetIntEji called 0 returned 0% blocks executed 0%
    #####: 2766:void ImGuiStorage::SetInt(ImGuiID key, int val)
        -: 2767:{
    #####: 2768:    ImGuiStoragePair* it = ImLowerBound(Data.Data, Data.Data + Data.Size, key);
    %%%%%: 2768-block 2
call    0 never executed
    #####: 2769:    if (it == Data.Data + Data.Size || it->key != key)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2769-block 4
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2770:        Data.insert(it, ImGuiStoragePair(key, val));
    %%%%%: 2770-block 5
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 2770-block 7
        -: 2771:    else
    #####: 2772:        it->val_i = val;
    %%%%%: 2772-block 8
    #####: 2773:}
    %%%%%: 2773-block 9
        -: 2774:
function _ZN12ImGuiStorage7SetBoolEjb called 0 returned 0% blocks executed 0%
    #####: 2775:void ImGuiStorage::SetBool(ImGuiID key, bool val)
        -: 2776:{
    #####: 2777:    SetInt(key, val ? 1 : 0);
    %%%%%: 2777-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2777-block 3
    %%%%%: 2777-block 4
    %%%%%: 2777-block 5
call    2 never executed
    #####: 2778:}
        -: 2779:
function _ZN12ImGuiStorage8SetFloatEjf called 0 returned 0% blocks executed 0%
    #####: 2780:void ImGuiStorage::SetFloat(ImGuiID key, float val)
        -: 2781:{
    #####: 2782:    ImGuiStoragePair* it = ImLowerBound(Data.Data, Data.Data + Data.Size, key);
    %%%%%: 2782-block 2
call    0 never executed
    #####: 2783:    if (it == Data.Data + Data.Size || it->key != key)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2783-block 4
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2784:        Data.insert(it, ImGuiStoragePair(key, val));
    %%%%%: 2784-block 5
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 2784-block 7
        -: 2785:    else
    #####: 2786:        it->val_f = val;
    %%%%%: 2786-block 8
    #####: 2787:}
    %%%%%: 2787-block 9
        -: 2788:
function _ZN12ImGuiStorage10SetVoidPtrEjPv called 25 returned 100% blocks executed 89%
       25: 2789:void ImGuiStorage::SetVoidPtr(ImGuiID key, void* val)
        -: 2790:{
       25: 2791:    ImGuiStoragePair* it = ImLowerBound(Data.Data, Data.Data + Data.Size, key);
       25: 2791-block 2
call    0 returned 25
       25: 2792:    if (it == Data.Data + Data.Size || it->key != key)
branch  0 taken 18 (fallthrough)
branch  1 taken 7
       18: 2792-block 4
branch  2 taken 18 (fallthrough)
branch  3 taken 0
       25: 2793:        Data.insert(it, ImGuiStoragePair(key, val));
       25: 2793-block 5
call    0 returned 25
call    1 returned 25
branch  2 taken 25 (fallthrough)
branch  3 taken 0 (throw)
       25: 2793-block 7
        -: 2794:    else
    #####: 2795:        it->val_p = val;
    %%%%%: 2795-block 8
       25: 2796:}
       25: 2796-block 9
        -: 2797:
function _ZN12ImGuiStorage9SetAllIntEi called 0 returned 0% blocks executed 0%
    #####: 2798:void ImGuiStorage::SetAllInt(int v)
        -: 2799:{
    #####: 2800:    for (int i = 0; i < Data.Size; i++)
    %%%%%: 2800-block 2
    %%%%%: 2800-block 5
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2801:        Data[i].val_i = v;
    %%%%%: 2801-block 3
call    0 never executed
    #####: 2802:}
        -: 2803:IM_MSVC_RUNTIME_CHECKS_RESTORE
        -: 2804:
        -: 2805://-----------------------------------------------------------------------------
        -: 2806:// [SECTION] ImGuiTextFilter
        -: 2807://-----------------------------------------------------------------------------
        -: 2808:
        -: 2809:// Helper: Parse and apply text filters. In format "aaaaa[,bbbb][,ccccc]"
function _ZN15ImGuiTextFilterC2EPKc called 0 returned 0% blocks executed 0%
    #####: 2810:ImGuiTextFilter::ImGuiTextFilter(const char* default_filter) //-V1077
    %%%%%: 2810-block 2
call    0 never executed
        -: 2811:{
    #####: 2812:    InputBuf[0] = 0;
    #####: 2813:    CountGrep = 0;
    #####: 2814:    if (default_filter)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2815:    {
    #####: 2816:        ImStrncpy(InputBuf, default_filter, IM_ARRAYSIZE(InputBuf));
    %%%%%: 2816-block 4
call    0 never executed
    #####: 2817:        Build();
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 2818:    }
    #####: 2819:}
    %%%%%: 2819-block 6
    $$$$$: 2819-block 7
call    0 never executed
        -: 2820:
function _ZN15ImGuiTextFilter4DrawEPKcf called 0 returned 0% blocks executed 0%
    #####: 2821:bool ImGuiTextFilter::Draw(const char* label, float width)
        -: 2822:{
    #####: 2823:    if (width != 0.0f)
    %%%%%: 2823-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2824:        ImGui::SetNextItemWidth(width);
    %%%%%: 2824-block 3
call    0 never executed
    #####: 2825:    bool value_changed = ImGui::InputText(label, InputBuf, IM_ARRAYSIZE(InputBuf));
    %%%%%: 2825-block 4
call    0 never executed
    #####: 2826:    if (value_changed)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2827:        Build();
    %%%%%: 2827-block 6
call    0 never executed
    #####: 2828:    return value_changed;
    %%%%%: 2828-block 7
        -: 2829:}
        -: 2830:
function _ZNK15ImGuiTextFilter14ImGuiTextRange5splitEcP8ImVectorIS0_E called 0 returned 0% blocks executed 0%
    #####: 2831:void ImGuiTextFilter::ImGuiTextRange::split(char separator, ImVector<ImGuiTextRange>* out) const
        -: 2832:{
    #####: 2833:    out->resize(0);
    %%%%%: 2833-block 2
call    0 never executed
    #####: 2834:    const char* wb = b;
    #####: 2835:    const char* we = wb;
    #####: 2836:    while (we < e)
    %%%%%: 2836-block 9
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 2837:    {
    #####: 2838:        if (*we == separator)
    %%%%%: 2838-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2839:        {
    #####: 2840:            out->push_back(ImGuiTextRange(wb, we));
    %%%%%: 2840-block 5
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$: 2840-block 15
call    4 never executed
    #####: 2841:            wb = we + 1;
    %%%%%: 2841-block 7
        -: 2842:        }
    #####: 2843:        we++;
    %%%%%: 2843-block 8
        -: 2844:    }
    #####: 2845:    if (wb != we)
    %%%%%: 2845-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2846:        out->push_back(ImGuiTextRange(wb, we));
    %%%%%: 2846-block 11
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 2846-block 13
    #####: 2847:}
    %%%%%: 2847-block 14
        -: 2848:
function _ZN15ImGuiTextFilter5BuildEv called 0 returned 0% blocks executed 0%
    #####: 2849:void ImGuiTextFilter::Build()
        -: 2850:{
    #####: 2851:    Filters.resize(0);
    %%%%%: 2851-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 2852:    ImGuiTextRange input_range(InputBuf, InputBuf + strlen(InputBuf));
    %%%%%: 2852-block 3
call    0 never executed
    #####: 2853:    input_range.split(',', &Filters);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 2854:
    #####: 2855:    CountGrep = 0;
    #####: 2856:    for (ImGuiTextRange& f : Filters)
    %%%%%: 2856-block 5
call    0 never executed
call    1 never executed
    %%%%%: 2856-block 28
    %%%%%: 2856-block 29
branch  2 never executed
branch  3 never executed (fallthrough)
        -: 2857:    {
    #####: 2858:        while (f.b < f.e && ImCharIsBlankA(f.b[0]))
    %%%%%: 2858-block 7
    %%%%%: 2858-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2858-block 10
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 2858-block 12
    %%%%%: 2858-block 13
    %%%%%: 2858-block 14
branch  5 never executed
branch  6 never executed (fallthrough)
    #####: 2859:            f.b++;
    %%%%%: 2859-block 8
    #####: 2860:        while (f.e > f.b && ImCharIsBlankA(f.e[-1]))
    %%%%%: 2860-block 15
    %%%%%: 2860-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2860-block 18
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 2860-block 20
    %%%%%: 2860-block 21
    %%%%%: 2860-block 22
branch  5 never executed
branch  6 never executed (fallthrough)
    #####: 2861:            f.e--;
    %%%%%: 2861-block 16
    #####: 2862:        if (f.empty())
    %%%%%: 2862-block 23
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 2863:            continue;
    %%%%%: 2863-block 25
    #####: 2864:        if (f.b[0] != '-')
    %%%%%: 2864-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2865:            CountGrep += 1;
    %%%%%: 2865-block 27
        -: 2866:    }
    #####: 2867:}
    %%%%%: 2867-block 30
        -: 2868:
function _ZNK15ImGuiTextFilter10PassFilterEPKcS1_ called 0 returned 0% blocks executed 0%
    #####: 2869:bool ImGuiTextFilter::PassFilter(const char* text, const char* text_end) const
        -: 2870:{
    #####: 2871:    if (Filters.Size == 0)
    %%%%%: 2871-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2872:        return true;
    %%%%%: 2872-block 3
        -: 2873:
    #####: 2874:    if (text == NULL)
    %%%%%: 2874-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2875:        text = text_end = "";
    %%%%%: 2875-block 5
        -: 2876:
    #####: 2877:    for (const ImGuiTextRange& f : Filters)
    %%%%%: 2877-block 6
call    0 never executed
call    1 never executed
    %%%%%: 2877-block 17
    %%%%%: 2877-block 18
branch  2 never executed
branch  3 never executed (fallthrough)
        -: 2878:    {
    #####: 2879:        if (f.b == f.e)
    %%%%%: 2879-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2880:            continue;
    %%%%%: 2880-block 9
    #####: 2881:        if (f.b[0] == '-')
    %%%%%: 2881-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2882:        {
        -: 2883:            // Subtract
    #####: 2884:            if (ImStristr(text, text_end, f.b + 1, f.e) != NULL)
    %%%%%: 2884-block 11
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 2885:                return false;
    %%%%%: 2885-block 13
        -: 2886:        }
        -: 2887:        else
        -: 2888:        {
        -: 2889:            // Grep
    #####: 2890:            if (ImStristr(text, text_end, f.b, f.e) != NULL)
    %%%%%: 2890-block 14
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 2891:                return true;
    %%%%%: 2891-block 16
        -: 2892:        }
        -: 2893:    }
        -: 2894:
        -: 2895:    // Implicit * grep
    #####: 2896:    if (CountGrep == 0)
    %%%%%: 2896-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2897:        return true;
    %%%%%: 2897-block 20
        -: 2898:
    #####: 2899:    return false;
    %%%%%: 2899-block 21
        -: 2900:}
        -: 2901:
        -: 2902://-----------------------------------------------------------------------------
        -: 2903:// [SECTION] ImGuiTextBuffer, ImGuiTextIndex
        -: 2904://-----------------------------------------------------------------------------
        -: 2905:
        -: 2906:// On some platform vsnprintf() takes va_list by reference and modifies it.
        -: 2907:// va_copy is the 'correct' way to copy a va_list but Visual Studio prior to 2013 doesn't have it.
        -: 2908:#ifndef va_copy
        -: 2909:#if defined(__GNUC__) || defined(__clang__)
        -: 2910:#define va_copy(dest, src) __builtin_va_copy(dest, src)
        -: 2911:#else
        -: 2912:#define va_copy(dest, src) (dest = src)
        -: 2913:#endif
        -: 2914:#endif
        -: 2915:
        -: 2916:char ImGuiTextBuffer::EmptyString[1] = { 0 };
        -: 2917:
function _ZN15ImGuiTextBuffer6appendEPKcS1_ called 4396 returned 100% blocks executed 100%
     4396: 2918:void ImGuiTextBuffer::append(const char* str, const char* str_end)
        -: 2919:{
     4396: 2920:    int len = str_end ? (int)(str_end - str) : (int)strlen(str);
     4396: 2920-block 2
branch  0 taken 4308 (fallthrough)
branch  1 taken 88
     4308: 2920-block 3
       88: 2920-block 4
        -: 2921:
        -: 2922:    // Add zero-terminator the first time
     4396: 2923:    const int write_off = (Buf.Size != 0) ? Buf.Size : 1;
     4396: 2923-block 5
branch  0 taken 3319 (fallthrough)
branch  1 taken 1077
     3319: 2923-block 6
     1077: 2923-block 7
     4396: 2924:    const int needed_sz = write_off + len;
     4396: 2925:    if (write_off + len >= Buf.Capacity)
     4396: 2925-block 8
branch  0 taken 3 (fallthrough)
branch  1 taken 4393
        -: 2926:    {
        3: 2927:        int new_capacity = Buf.Capacity * 2;
        3: 2928:        Buf.reserve(needed_sz > new_capacity ? needed_sz : new_capacity);
        3: 2928-block 9
branch  0 taken 2 (fallthrough)
branch  1 taken 1
        2: 2928-block 10
        1: 2928-block 11
        3: 2928-block 12
call    2 returned 3
branch  3 taken 3 (fallthrough)
branch  4 taken 0 (throw)
        -: 2929:    }
        -: 2930:
     4396: 2931:    Buf.resize(needed_sz);
     4396: 2931-block 14
call    0 returned 4396
     4396: 2932:    memcpy(&Buf[write_off - 1], str, (size_t)len);
call    0 returned 4396
     4396: 2933:    Buf[write_off - 1 + len] = 0;
call    0 returned 4396
     4396: 2934:}
        -: 2935:
function _ZN15ImGuiTextBuffer7appendfEPKcz called 318 returned 100% blocks executed 100%
      318: 2936:void ImGuiTextBuffer::appendf(const char* fmt, ...)
        -: 2937:{
        -: 2938:    va_list args;
      318: 2939:    va_start(args, fmt);
      318: 2940:    appendfv(fmt, args);
      318: 2940-block 2
call    0 returned 318
branch  1 taken 318 (fallthrough)
branch  2 taken 0 (throw)
      318: 2941:    va_end(args);
      318: 2942:}
      318: 2942-block 3
        -: 2943:
        -: 2944:// Helper: Text buffer for logging/accumulating text
function _ZN15ImGuiTextBuffer8appendfvEPKcP13__va_list_tag called 318 returned 100% blocks executed 58%
      318: 2945:void ImGuiTextBuffer::appendfv(const char* fmt, va_list args)
        -: 2946:{
        -: 2947:    va_list args_copy;
      318: 2948:    va_copy(args_copy, args);
        -: 2949:
      318: 2950:    int len = ImFormatStringV(NULL, 0, fmt, args);         // FIXME-OPT: could do a first pass write attempt, likely successful on first pass.
      318: 2950-block 2
call    0 returned 318
      318: 2951:    if (len <= 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 318
        -: 2952:    {
    #####: 2953:        va_end(args_copy);
    #####: 2954:        return;
    %%%%%: 2954-block 4
        -: 2955:    }
        -: 2956:
        -: 2957:    // Add zero-terminator the first time
     318*: 2958:    const int write_off = (Buf.Size != 0) ? Buf.Size : 1;
      318: 2958-block 5
branch  0 taken 318 (fallthrough)
branch  1 taken 0
      318: 2958-block 6
    %%%%%: 2958-block 7
      318: 2959:    const int needed_sz = write_off + len;
      318: 2960:    if (write_off + len >= Buf.Capacity)
      318: 2960-block 8
branch  0 taken 0 (fallthrough)
branch  1 taken 318
        -: 2961:    {
    #####: 2962:        int new_capacity = Buf.Capacity * 2;
    #####: 2963:        Buf.reserve(needed_sz > new_capacity ? needed_sz : new_capacity);
    %%%%%: 2963-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2963-block 10
    %%%%%: 2963-block 11
    %%%%%: 2963-block 12
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
        -: 2964:    }
        -: 2965:
      318: 2966:    Buf.resize(needed_sz);
      318: 2966-block 14
call    0 returned 318
branch  1 taken 318 (fallthrough)
branch  2 taken 0 (throw)
      318: 2967:    ImFormatStringV(&Buf[write_off - 1], (size_t)len + 1, fmt, args_copy);
      318: 2967-block 15
call    0 returned 318
call    1 returned 318
      318: 2968:    va_end(args_copy);
        -: 2969:}
        -: 2970:
function _ZN14ImGuiTextIndex6appendEPKcii called 0 returned 0% blocks executed 0%
    #####: 2971:void ImGuiTextIndex::append(const char* base, int old_size, int new_size)
        -: 2972:{
    #####: 2973:    IM_ASSERT(old_size >= 0 && new_size >= old_size && new_size >= EndOffset);
    %%%%%: 2973-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2973-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2973-block 4
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 2973-block 5
    %%%%%: 2973-block 6
call    6 never executed
    #####: 2974:    if (old_size == new_size)
    %%%%%: 2974-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2975:        return;
    %%%%%: 2975-block 8
    #####: 2976:    if (EndOffset == 0 || base[EndOffset - 1] == '\n')
    %%%%%: 2976-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2976-block 10
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2977:        LineOffsets.push_back(EndOffset);
    %%%%%: 2977-block 11
call    0 never executed
    #####: 2978:    const char* base_end = base + new_size;
    #####: 2979:    for (const char* p = base + old_size; (p = (const char*)memchr(p, '\n', base_end - p)) != 0; )
    %%%%%: 2979-block 12
    %%%%%: 2979-block 16
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2980:        if (++p < base_end) // Don't push a trailing offset on last \n
    %%%%%: 2980-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2981:            LineOffsets.push_back((int)(intptr_t)(p - base));
    %%%%%: 2981-block 14
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 2981-block 15
    #####: 2982:    EndOffset = ImMax(EndOffset, new_size);
    %%%%%: 2982-block 17
call    0 never executed
        -: 2983:}
        -: 2984:
        -: 2985://-----------------------------------------------------------------------------
        -: 2986:// [SECTION] ImGuiListClipper
        -: 2987://-----------------------------------------------------------------------------
        -: 2988:
        -: 2989:// FIXME-TABLE: This prevents us from using ImGuiListClipper _inside_ a table cell.
        -: 2990:// The problem we have is that without a Begin/End scheme for rows using the clipper is ambiguous.
function _ZL26GetSkipItemForListClippingv called 4308 returned 100% blocks executed 80%
     4308: 2991:static bool GetSkipItemForListClipping()
        -: 2992:{
     4308: 2993:    ImGuiContext& g = *GImGui;
    4308*: 2994:    return (g.CurrentTable ? g.CurrentTable->HostSkipItems : g.CurrentWindow->SkipItems);
     4308: 2994-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
    %%%%%: 2994-block 3
     4308: 2994-block 4
     4308: 2994-block 5
        -: 2995:}
        -: 2996:
function _ZL34ImGuiListClipper_SortAndFuseRangesR8ImVectorI21ImGuiListClipperRangeEi called 2154 returned 100% blocks executed 8%
     2154: 2997:static void ImGuiListClipper_SortAndFuseRanges(ImVector<ImGuiListClipperRange>& ranges, int offset = 0)
        -: 2998:{
     2154: 2999:    if (ranges.Size - offset <= 1)
     2154: 2999-block 2
branch  0 taken 2154 (fallthrough)
branch  1 taken 0
     2154: 3000:        return;
     2154: 3000-block 3
        -: 3001:
        -: 3002:    // Helper to order ranges and fuse them together if possible (bubble sort is fine as we are only sorting 2-3 entries)
    #####: 3003:    for (int sort_end = ranges.Size - offset - 1; sort_end > 0; --sort_end)
    %%%%%: 3003-block 4
    %%%%%: 3003-block 14
    %%%%%: 3003-block 15
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3004:        for (int i = offset; i < sort_end + offset; ++i)
    %%%%%: 3004-block 5
    %%%%%: 3004-block 12
    %%%%%: 3004-block 13
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3005:            if (ranges[i].Min > ranges[i + 1].Min)
    %%%%%: 3005-block 6
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3006:                ImSwap(ranges[i], ranges[i + 1]);
    %%%%%: 3006-block 9
call    0 never executed
call    1 never executed
call    2 never executed
        -: 3007:
        -: 3008:    // Now fuse ranges together as much as possible.
    #####: 3009:    for (int i = 1 + offset; i < ranges.Size; i++)
    %%%%%: 3009-block 16
    %%%%%: 3009-block 37
    %%%%%: 3009-block 38
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 3010:    {
    #####: 3011:        IM_ASSERT(!ranges[i].PosToIndexConvert && !ranges[i - 1].PosToIndexConvert);
    %%%%%: 3011-block 17
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3011-block 19
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 3011-block 21
    %%%%%: 3011-block 22
call    6 never executed
    #####: 3012:        if (ranges[i - 1].Max < ranges[i].Min)
    %%%%%: 3012-block 23
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3013:            continue;
    %%%%%: 3013-block 26
    #####: 3014:        ranges[i - 1].Min = ImMin(ranges[i - 1].Min, ranges[i].Min);
    %%%%%: 3014-block 27
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 3015:        ranges[i - 1].Max = ImMax(ranges[i - 1].Max, ranges[i].Max);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 3016:        ranges.erase(ranges.Data + i);
call    0 never executed
    #####: 3017:        i--;
        -: 3018:    }
        -: 3019:}
        -: 3020:
function _ZL43ImGuiListClipper_SeekCursorAndSetupPrevLineff called 4308 returned 100% blocks executed 50%
     4308: 3021:static void ImGuiListClipper_SeekCursorAndSetupPrevLine(float pos_y, float line_height)
        -: 3022:{
        -: 3023:    // Set cursor position and a few other things so that SetScrollHereY() and Columns() can work when seeking cursor.
        -: 3024:    // FIXME: It is problematic that we have to do that here, because custom/equivalent end-user code would stumble on the same issue.
        -: 3025:    // The clipper should probably have a final step to display the last item in a regular manner, maybe with an opt-out flag for data sets which may have costly seek?
     4308: 3026:    ImGuiContext& g = *GImGui;
     4308: 3027:    ImGuiWindow* window = g.CurrentWindow;
     4308: 3028:    float off_y = pos_y - window->DC.CursorPos.y;
     4308: 3029:    window->DC.CursorPos.y = pos_y;
     4308: 3030:    window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, pos_y - g.Style.ItemSpacing.y);
     4308: 3030-block 2
call    0 returned 4308
     4308: 3031:    window->DC.CursorPosPrevLine.y = window->DC.CursorPos.y - line_height;  // Setting those fields so that SetScrollHereY() can properly function after the end of our clipper usage.
     4308: 3032:    window->DC.PrevLineSize.y = (line_height - g.Style.ItemSpacing.y);      // If we end up needing more accurate data (to e.g. use SameLine) we may as well make the clipper have a fourth step to let user process and display the last item in their list.
     4308: 3033:    if (ImGuiOldColumns* columns = window->DC.CurrentColumns)
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
    #####: 3034:        columns->LineMinY = window->DC.CursorPos.y;                         // Setting this so that cell Y position are set properly
    %%%%%: 3034-block 4
     4308: 3035:    if (ImGuiTable* table = g.CurrentTable)
     4308: 3035-block 5
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
        -: 3036:    {
    #####: 3037:        if (table->IsInsideRow)
    %%%%%: 3037-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3038:            ImGui::TableEndRow(table);
    %%%%%: 3038-block 7
call    0 never executed
    #####: 3039:        table->RowPosY2 = window->DC.CursorPos.y;
    #####: 3040:        const int row_increase = (int)((off_y / line_height) + 0.5f);
        -: 3041:        //table->CurrentRow += row_increase; // Can't do without fixing TableEndRow()
    #####: 3042:        table->RowBgColorCounter += row_increase;
    %%%%%: 3042-block 8
        -: 3043:    }
     4308: 3044:}
        -: 3045:
function _ZN16ImGuiListClipperC2Ev called 2154 returned 100% blocks executed 100%
     2154: 3046:ImGuiListClipper::ImGuiListClipper()
        -: 3047:{
     2154: 3048:    memset(this, 0, sizeof(*this));
     2154: 3049:}
        -: 3050:
function _ZN16ImGuiListClipperD2Ev called 2154 returned 100% blocks executed 100%
     2154: 3051:ImGuiListClipper::~ImGuiListClipper()
        -: 3052:{
     2154: 3053:    End();
     2154: 3053-block 2
call    0 returned 2154
     2154: 3054:}
        -: 3055:
function _ZN16ImGuiListClipper5BeginEif called 2154 returned 100% blocks executed 74%
     2154: 3056:void ImGuiListClipper::Begin(int items_count, float items_height)
        -: 3057:{
     2154: 3058:    if (Ctx == NULL)
     2154: 3058-block 2
branch  0 taken 2154 (fallthrough)
branch  1 taken 0
     2154: 3059:        Ctx = ImGui::GetCurrentContext();
     2154: 3059-block 3
call    0 returned 2154
        -: 3060:
     2154: 3061:    ImGuiContext& g = *Ctx;
     2154: 3062:    ImGuiWindow* window = g.CurrentWindow;
    2154*: 3063:    IMGUI_DEBUG_LOG_CLIPPER("Clipper: Begin(%d,%.2f) in '%s'\n", items_count, items_height, window->Name);
     2154: 3063-block 5
branch  0 taken 0 (fallthrough)
branch  1 taken 2154
    %%%%%: 3063-block 6
call    2 never executed
        -: 3064:
     2154: 3065:    if (ImGuiTable* table = g.CurrentTable)
     2154: 3065-block 7
branch  0 taken 0 (fallthrough)
branch  1 taken 2154
    #####: 3066:        if (table->IsInsideRow)
    %%%%%: 3066-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3067:            ImGui::TableEndRow(table);
    %%%%%: 3067-block 9
call    0 never executed
        -: 3068:
     2154: 3069:    StartPosY = window->DC.CursorPos.y;
     2154: 3070:    ItemsHeight = items_height;
     2154: 3071:    ItemsCount = items_count;
     2154: 3072:    DisplayStart = -1;
     2154: 3073:    DisplayEnd = 0;
        -: 3074:
        -: 3075:    // Acquire temporary buffer
     2154: 3076:    if (++g.ClipperTempDataStacked > g.ClipperTempData.Size)
     2154: 3076-block 10
branch  0 taken 1 (fallthrough)
branch  1 taken 2153
        1: 3077:        g.ClipperTempData.resize(g.ClipperTempDataStacked, ImGuiListClipperData());
        1: 3077-block 11
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 3077-block 12
call    3 returned 1
branch  4 taken 1 (fallthrough)
branch  5 taken 0 (throw)
        1: 3077-block 13
call    6 returned 1
    $$$$$: 3077-block 18
call    7 never executed
     2154: 3078:    ImGuiListClipperData* data = &g.ClipperTempData[g.ClipperTempDataStacked - 1];
     2154: 3078-block 15
call    0 returned 2154
     2154: 3079:    data->Reset(this);
call    0 returned 2154
     2154: 3080:    data->LossynessOffset = window->DC.CursorStartPosLossyness.y;
     2154: 3081:    TempData = data;
     2154: 3082:    StartSeekOffsetY = data->LossynessOffset;
     2154: 3083:}
        -: 3084:
function _ZN16ImGuiListClipper3EndEv called 4308 returned 100% blocks executed 71%
     4308: 3085:void ImGuiListClipper::End()
        -: 3086:{
     4308: 3087:    if (auto* data = (ImGuiListClipperData*)TempData)
     4308: 3087-block 2
branch  0 taken 2154 (fallthrough)
branch  1 taken 2154
        -: 3088:    {
        -: 3089:        // In theory here we should assert that we are already at the right position, but it seems saner to just seek at the end and not assert/crash the user.
     2154: 3090:        ImGuiContext& g = *Ctx;
    2154*: 3091:        IMGUI_DEBUG_LOG_CLIPPER("Clipper: End() in '%s'\n", g.CurrentWindow->Name);
     2154: 3091-block 3
branch  0 taken 0 (fallthrough)
branch  1 taken 2154
    %%%%%: 3091-block 4
call    2 never executed
     2154: 3092:        if (ItemsCount >= 0 && ItemsCount < INT_MAX && DisplayStart >= 0)
     2154: 3092-block 5
branch  0 taken 2154 (fallthrough)
branch  1 taken 0
     2154: 3092-block 6
branch  2 taken 2154 (fallthrough)
branch  3 taken 0
     2154: 3092-block 7
branch  4 taken 2154 (fallthrough)
branch  5 taken 0
     2154: 3093:            SeekCursorForItem(ItemsCount);
     2154: 3093-block 8
call    0 returned 2154
        -: 3094:
        -: 3095:        // Restore temporary buffer and fix back pointers which may be invalidated when nesting
    2154*: 3096:        IM_ASSERT(data->ListClipper == this);
     2154: 3096-block 9
branch  0 taken 0 (fallthrough)
branch  1 taken 2154
    %%%%%: 3096-block 10
call    2 never executed
     2154: 3097:        data->StepNo = data->Ranges.Size;
     2154: 3098:        if (--g.ClipperTempDataStacked > 0)
     2154: 3098-block 11
branch  0 taken 0 (fallthrough)
branch  1 taken 2154
        -: 3099:        {
    #####: 3100:            data = &g.ClipperTempData[g.ClipperTempDataStacked - 1];
    %%%%%: 3100-block 12
call    0 never executed
    #####: 3101:            data->ListClipper->TempData = data;
        -: 3102:        }
     2154: 3103:        TempData = NULL;
     2154: 3103-block 14
        -: 3104:    }
     4308: 3105:    ItemsCount = -1;
     4308: 3106:}
        -: 3107:
function _ZN16ImGuiListClipper19IncludeItemsByIndexEii called 0 returned 0% blocks executed 0%
    #####: 3108:void ImGuiListClipper::IncludeItemsByIndex(int item_begin, int item_end)
        -: 3109:{
    #####: 3110:    ImGuiListClipperData* data = (ImGuiListClipperData*)TempData;
    #####: 3111:    IM_ASSERT(DisplayStart < 0); // Only allowed after Begin() and if there has not been a specified range yet.
    %%%%%: 3111-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3111-block 3
call    2 never executed
    #####: 3112:    IM_ASSERT(item_begin <= item_end);
    %%%%%: 3112-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3112-block 5
call    2 never executed
    #####: 3113:    if (item_begin < item_end)
    %%%%%: 3113-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3114:        data->Ranges.push_back(ImGuiListClipperRange::FromIndices(item_begin, item_end));
    %%%%%: 3114-block 7
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 3114-block 9
    #####: 3115:}
    %%%%%: 3115-block 10
        -: 3116:
        -: 3117:// This is already called while stepping.
        -: 3118:// The ONLY reason you may want to call this is if you passed INT_MAX to ImGuiListClipper::Begin() because you couldn't step item count beforehand.
function _ZN16ImGuiListClipper17SeekCursorForItemEi called 4308 returned 100% blocks executed 100%
     4308: 3119:void ImGuiListClipper::SeekCursorForItem(int item_n)
        -: 3120:{
        -: 3121:    // - Perform the add and multiply with double to allow seeking through larger ranges.
        -: 3122:    // - StartPosY starts from ItemsFrozen, by adding SeekOffsetY we generally cancel that out (SeekOffsetY == LossynessOffset - ItemsFrozen * ItemsHeight).
        -: 3123:    // - The reason we store SeekOffsetY instead of inferring it, is because we want to allow user to perform Seek after the last step, where ImGuiListClipperData is already done.
     4308: 3124:    float pos_y = (float)((double)StartPosY + StartSeekOffsetY + (double)item_n * ItemsHeight);
     4308: 3125:    ImGuiListClipper_SeekCursorAndSetupPrevLine(pos_y, ItemsHeight);
     4308: 3125-block 2
call    0 returned 4308
     4308: 3126:}
        -: 3127:
function _ZL29ImGuiListClipper_StepInternalP16ImGuiListClipper called 4308 returned 100% blocks executed 41%
     4308: 3128:static bool ImGuiListClipper_StepInternal(ImGuiListClipper* clipper)
        -: 3129:{
     4308: 3130:    ImGuiContext& g = *clipper->Ctx;
     4308: 3131:    ImGuiWindow* window = g.CurrentWindow;
     4308: 3132:    ImGuiListClipperData* data = (ImGuiListClipperData*)clipper->TempData;
    4308*: 3133:    IM_ASSERT(data != NULL && "Called ImGuiListClipper::Step() too many times, or before ImGuiListClipper::Begin() ?");
     4308: 3133-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
    %%%%%: 3133-block 3
call    2 never executed
        -: 3134:
     4308: 3135:    ImGuiTable* table = g.CurrentTable;
    4308*: 3136:    if (table && table->IsInsideRow)
     4308: 3136-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
    %%%%%: 3136-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3137:        ImGui::TableEndRow(table);
    %%%%%: 3137-block 6
call    0 never executed
        -: 3138:
        -: 3139:    // No items
    4308*: 3140:    if (clipper->ItemsCount == 0 || GetSkipItemForListClipping())
     4308: 3140-block 7
branch  0 taken 4308 (fallthrough)
branch  1 taken 0
     4308: 3140-block 8
call    2 returned 4308
branch  3 taken 0 (fallthrough)
branch  4 taken 4308
    %%%%%: 3140-block 10
     4308: 3140-block 11
     4308: 3140-block 12
branch  5 taken 0 (fallthrough)
branch  6 taken 4308
    #####: 3141:        return false;
    %%%%%: 3141-block 13
        -: 3142:
        -: 3143:    // While we are in frozen row state, keep displaying items one by one, unclipped
        -: 3144:    // FIXME: Could be stored as a table-agnostic state.
    4308*: 3145:    if (data->StepNo == 0 && table != NULL && !table->IsUnfrozenRows)
     4308: 3145-block 14
branch  0 taken 2154 (fallthrough)
branch  1 taken 2154
     2154: 3145-block 15
branch  2 taken 0 (fallthrough)
branch  3 taken 2154
    %%%%%: 3145-block 16
branch  4 never executed (fallthrough)
branch  5 never executed
        -: 3146:    {
    #####: 3147:        clipper->DisplayStart = data->ItemsFrozen;
    #####: 3148:        clipper->DisplayEnd = ImMin(data->ItemsFrozen + 1, clipper->ItemsCount);
    %%%%%: 3148-block 17
call    0 never executed
    #####: 3149:        if (clipper->DisplayStart < clipper->DisplayEnd)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3150:            data->ItemsFrozen++;
    %%%%%: 3150-block 19
    #####: 3151:        return true;
    %%%%%: 3151-block 20
        -: 3152:    }
        -: 3153:
        -: 3154:    // Step 0: Let you process the first element (regardless of it being visible or not, so we can measure the element height)
     4308: 3155:    bool calc_clipping = false;
     4308: 3156:    if (data->StepNo == 0)
     4308: 3156-block 21
branch  0 taken 2154 (fallthrough)
branch  1 taken 2154
        -: 3157:    {
     2154: 3158:        clipper->StartPosY = window->DC.CursorPos.y;
     2154: 3159:        if (clipper->ItemsHeight <= 0.0f)
     2154: 3159-block 22
branch  0 taken 0 (fallthrough)
branch  1 taken 2154
        -: 3160:        {
        -: 3161:            // Submit the first item (or range) so we can measure its height (generally the first range is 0..1)
    #####: 3162:            data->Ranges.push_front(ImGuiListClipperRange::FromIndices(data->ItemsFrozen, data->ItemsFrozen + 1));
    %%%%%: 3162-block 23
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$: 3162-block 122
call    4 never executed
    #####: 3163:            clipper->DisplayStart = ImMax(data->Ranges[0].Min, data->ItemsFrozen);
    %%%%%: 3163-block 25
call    0 never executed
call    1 never executed
    #####: 3164:            clipper->DisplayEnd = ImMin(data->Ranges[0].Max, clipper->ItemsCount);
call    0 never executed
call    1 never executed
    #####: 3165:            data->StepNo = 1;
    #####: 3166:            return true;
        -: 3167:        }
     2154: 3168:        calc_clipping = true;   // If on the first step with known item height, calculate clipping.
     2154: 3168-block 30
        -: 3169:    }
        -: 3170:
        -: 3171:    // Step 1: Let the clipper infer height from first range
     4308: 3172:    if (clipper->ItemsHeight <= 0.0f)
     4308: 3172-block 31
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
        -: 3173:    {
    #####: 3174:        IM_ASSERT(data->StepNo == 1);
    %%%%%: 3174-block 32
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3174-block 33
call    2 never executed
    #####: 3175:        if (table)
    %%%%%: 3175-block 34
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3176:            IM_ASSERT(table->RowPosY1 == clipper->StartPosY && table->RowPosY2 == window->DC.CursorPos.y);
    %%%%%: 3176-block 35
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3176-block 36
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3176-block 37
    %%%%%: 3176-block 38
call    4 never executed
        -: 3177:
    #####: 3178:        clipper->ItemsHeight = (window->DC.CursorPos.y - clipper->StartPosY) / (float)(clipper->DisplayEnd - clipper->DisplayStart);
    #####: 3179:        bool affected_by_floating_point_precision = ImIsFloatAboveGuaranteedIntegerPrecision(clipper->StartPosY) || ImIsFloatAboveGuaranteedIntegerPrecision(window->DC.CursorPos.y);
    %%%%%: 3179-block 40
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3179-block 42
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 3179-block 44
    %%%%%: 3179-block 45
    #####: 3180:        if (affected_by_floating_point_precision)
    %%%%%: 3180-block 46
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3181:            clipper->ItemsHeight = window->DC.PrevLineSize.y + g.Style.ItemSpacing.y; // FIXME: Technically wouldn't allow multi-line entries.
    %%%%%: 3181-block 47
    #####: 3182:        if (clipper->ItemsHeight == 0.0f && clipper->ItemsCount == INT_MAX) // Accept that no item have been submitted if in indeterminate mode.
    %%%%%: 3182-block 48
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3182-block 49
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3183:            return false;
    %%%%%: 3183-block 50
    #####: 3184:        IM_ASSERT(clipper->ItemsHeight > 0.0f && "Unable to calculate item height! First item hasn't moved the cursor vertically!");
    %%%%%: 3184-block 51
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3184-block 52
call    2 never executed
    #####: 3185:        calc_clipping = true;   // If item height had to be calculated, calculate clipping afterwards.
    %%%%%: 3185-block 53
        -: 3186:    }
        -: 3187:
        -: 3188:    // Step 0 or 1: Calculate the actual ranges of visible elements.
     4308: 3189:    const int already_submitted = clipper->DisplayEnd;
     4308: 3190:    if (calc_clipping)
     4308: 3190-block 54
branch  0 taken 2154 (fallthrough)
branch  1 taken 2154
        -: 3191:    {
        -: 3192:        // Record seek offset, this is so ImGuiListClipper::Seek() can be called after ImGuiListClipperData is done
     2154: 3193:        clipper->StartSeekOffsetY = (double)data->LossynessOffset - data->ItemsFrozen * (double)clipper->ItemsHeight;
        -: 3194:
     2154: 3195:        if (g.LogEnabled)
     2154: 3195-block 55
branch  0 taken 0 (fallthrough)
branch  1 taken 2154
        -: 3196:        {
        -: 3197:            // If logging is active, do not perform any clipping
    #####: 3198:            data->Ranges.push_back(ImGuiListClipperRange::FromIndices(0, clipper->ItemsCount));
    %%%%%: 3198-block 56
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 3198-block 58
    $$$$$: 3198-block 123
call    4 never executed
        -: 3199:        }
        -: 3200:        else
        -: 3201:        {
        -: 3202:            // Add range selected to be included for navigation
    2154*: 3203:            const bool is_nav_request = (g.NavMoveScoringItems && g.NavWindow && g.NavWindow->RootWindowForNav == window->RootWindowForNav);
     2154: 3203-block 59
branch  0 taken 0 (fallthrough)
branch  1 taken 2154
    %%%%%: 3203-block 60
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3203-block 61
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 3203-block 62
     2154: 3203-block 63
     2154: 3204:            if (is_nav_request)
     2154: 3204-block 64
branch  0 taken 0 (fallthrough)
branch  1 taken 2154
    #####: 3205:                data->Ranges.push_back(ImGuiListClipperRange::FromPositions(g.NavScoringNoClipRect.Min.y, g.NavScoringNoClipRect.Max.y, 0, 0));
    %%%%%: 3205-block 65
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 3205-block 67
    $$$$$: 3205-block 124
    2154*: 3206:            if (is_nav_request && (g.NavMoveFlags & ImGuiNavMoveFlags_IsTabbing) && g.NavTabbingDir == -1)
     2154: 3206-block 68
branch  0 taken 0 (fallthrough)
branch  1 taken 2154
    %%%%%: 3206-block 69
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3206-block 70
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 3207:                data->Ranges.push_back(ImGuiListClipperRange::FromIndices(clipper->ItemsCount - 1, clipper->ItemsCount));
    %%%%%: 3207-block 71
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 3207-block 73
    $$$$$: 3207-block 125
        -: 3208:
        -: 3209:            // Add focused/active item
     2154: 3210:            ImRect nav_rect_abs = ImGui::WindowRectRelToAbs(window, window->NavRectRel[0]);
     2154: 3210-block 74
call    0 returned 2154
     2154: 3211:            if (g.NavId != 0 && window->NavLastIds[0] == g.NavId)
branch  0 taken 1300 (fallthrough)
branch  1 taken 854
     1300: 3211-block 76
branch  2 taken 0 (fallthrough)
branch  3 taken 1300
    #####: 3212:                data->Ranges.push_back(ImGuiListClipperRange::FromPositions(nav_rect_abs.Min.y, nav_rect_abs.Max.y, 0, 0));
    %%%%%: 3212-block 77
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 3212-block 79
    $$$$$: 3212-block 126
        -: 3213:
        -: 3214:            // Add visible range
     2154: 3215:            float min_y = window->ClipRect.Min.y;
     2154: 3216:            float max_y = window->ClipRect.Max.y;
        -: 3217:
        -: 3218:            // Add box selection range
     2154: 3219:            ImGuiBoxSelectState* bs = &g.BoxSelectState;
    2154*: 3220:            if (bs->IsActive && bs->Window == window)
     2154: 3220-block 80
branch  0 taken 0 (fallthrough)
branch  1 taken 2154
    %%%%%: 3220-block 81
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 3221:            {
        -: 3222:                // FIXME: Selectable() use of half-ItemSpacing isn't consistent in matter of layout, as ItemAdd(bb) stray above ItemSize()'s CursorPos.
        -: 3223:                // RangeSelect's BoxSelect relies on comparing overlap of previous and current rectangle and is sensitive to that.
        -: 3224:                // As a workaround we currently half ItemSpacing worth on each side.
    #####: 3225:                min_y -= g.Style.ItemSpacing.y;
    #####: 3226:                max_y += g.Style.ItemSpacing.y;
        -: 3227:
        -: 3228:                // Box-select on 2D area requires different clipping.
    #####: 3229:                if (bs->UnclipMode)
    %%%%%: 3229-block 82
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3230:                    data->Ranges.push_back(ImGuiListClipperRange::FromPositions(bs->UnclipRect.Min.y, bs->UnclipRect.Max.y, 0, 0));
    %%%%%: 3230-block 83
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 3230-block 85
    $$$$$: 3230-block 127
        -: 3231:            }
        -: 3232:
    2154*: 3233:            const int off_min = (is_nav_request && g.NavMoveClipDir == ImGuiDir_Up) ? -1 : 0;
     2154: 3233-block 86
branch  0 taken 0 (fallthrough)
branch  1 taken 2154
    %%%%%: 3233-block 87
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3233-block 88
     2154: 3233-block 89
    2154*: 3234:            const int off_max = (is_nav_request && g.NavMoveClipDir == ImGuiDir_Down) ? 1 : 0;
     2154: 3234-block 90
branch  0 taken 0 (fallthrough)
branch  1 taken 2154
    %%%%%: 3234-block 91
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3234-block 92
     2154: 3234-block 93
     2154: 3235:            data->Ranges.push_back(ImGuiListClipperRange::FromPositions(min_y, max_y, off_min, off_max));
     2154: 3235-block 94
call    0 returned 2154
call    1 returned 2154
branch  2 taken 2154 (fallthrough)
branch  3 taken 0 (throw)
     2154: 3235-block 96
    $$$$$: 3235-block 128
        -: 3236:        }
        -: 3237:
        -: 3238:        // Convert position ranges to item index ranges
        -: 3239:        // - Very important: when a starting position is after our maximum item, we set Min to (ItemsCount - 1). This allows us to handle most forms of wrapping.
        -: 3240:        // - Due to how Selectable extra padding they tend to be "unaligned" with exact unit in the item list,
        -: 3241:        //   which with the flooring/ceiling tend to lead to 2 items instead of one being submitted.
     4308: 3242:        for (ImGuiListClipperRange& range : data->Ranges)
     2154: 3242-block 97
call    0 returned 2154
call    1 returned 2154
     2154: 3242-block 103
     4308: 3242-block 104
branch  2 taken 2154
branch  3 taken 2154 (fallthrough)
     2154: 3243:            if (range.PosToIndexConvert)
     2154: 3243-block 99
branch  0 taken 2154 (fallthrough)
branch  1 taken 0
        -: 3244:            {
     2154: 3245:                int m1 = (int)(((double)range.Min - window->DC.CursorPos.y - data->LossynessOffset) / clipper->ItemsHeight);
     2154: 3246:                int m2 = (int)((((double)range.Max - window->DC.CursorPos.y - data->LossynessOffset) / clipper->ItemsHeight) + 0.999999f);
     2154: 3247:                range.Min = ImClamp(already_submitted + m1 + range.PosToIndexOffsetMin, already_submitted, clipper->ItemsCount - 1);
     2154: 3247-block 100
call    0 returned 2154
     2154: 3248:                range.Max = ImClamp(already_submitted + m2 + range.PosToIndexOffsetMax, range.Min + 1, clipper->ItemsCount);
call    0 returned 2154
     2154: 3249:                range.PosToIndexConvert = false;
        -: 3250:            }
     2154: 3251:        ImGuiListClipper_SortAndFuseRanges(data->Ranges, data->StepNo);
     2154: 3251-block 105
call    0 returned 2154
        -: 3252:    }
        -: 3253:
        -: 3254:    // Step 0+ (if item height is given in advance) or 1+: Display the next range in line.
     4308: 3255:    while (data->StepNo < data->Ranges.Size)
     4308: 3255-block 106
     4308: 3255-block 117
branch  0 taken 2154
branch  1 taken 2154 (fallthrough)
        -: 3256:    {
     2154: 3257:        clipper->DisplayStart = ImMax(data->Ranges[data->StepNo].Min, already_submitted);
     2154: 3257-block 107
call    0 returned 2154
call    1 returned 2154
     2154: 3258:        clipper->DisplayEnd = ImMin(data->Ranges[data->StepNo].Max, clipper->ItemsCount);
call    0 returned 2154
call    1 returned 2154
     2154: 3259:        if (clipper->DisplayStart > already_submitted) //-V1051
branch  0 taken 0 (fallthrough)
branch  1 taken 2154
    #####: 3260:            clipper->SeekCursorForItem(clipper->DisplayStart);
    %%%%%: 3260-block 112
call    0 never executed
     2154: 3261:        data->StepNo++;
    2154*: 3262:        if (clipper->DisplayStart == clipper->DisplayEnd && data->StepNo < data->Ranges.Size)
     2154: 3262-block 113
branch  0 taken 0 (fallthrough)
branch  1 taken 2154
    %%%%%: 3262-block 114
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3263:            continue;
    %%%%%: 3263-block 115
     2154: 3264:        return true;
     2154: 3264-block 116
        -: 3265:    }
        -: 3266:
        -: 3267:    // After the last step: Let the clipper validate that we have reached the expected Y position (corresponding to element DisplayEnd),
        -: 3268:    // Advance the cursor to the end of the list and then returns 'false' to end the loop.
     2154: 3269:    if (clipper->ItemsCount < INT_MAX)
     2154: 3269-block 118
branch  0 taken 2154 (fallthrough)
branch  1 taken 0
     2154: 3270:        clipper->SeekCursorForItem(clipper->ItemsCount);
     2154: 3270-block 119
call    0 returned 2154
        -: 3271:
     2154: 3272:    return false;
     2154: 3272-block 120
        -: 3273:}
        -: 3274:
function _ZN16ImGuiListClipper4StepEv called 4308 returned 100% blocks executed 55%
     4308: 3275:bool ImGuiListClipper::Step()
        -: 3276:{
     4308: 3277:    ImGuiContext& g = *Ctx;
     4308: 3278:    bool need_items_height = (ItemsHeight <= 0.0f);
     4308: 3279:    bool ret = ImGuiListClipper_StepInternal(this);
     4308: 3279-block 2
call    0 returned 4308
     4308: 3280:    if (ret && (DisplayStart == DisplayEnd))
branch  0 taken 2154 (fallthrough)
branch  1 taken 2154
     2154: 3280-block 4
branch  2 taken 0 (fallthrough)
branch  3 taken 2154
    #####: 3281:        ret = false;
    %%%%%: 3281-block 5
    4308*: 3282:    if (g.CurrentTable && g.CurrentTable->IsUnfrozenRows == false)
     4308: 3282-block 6
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
    %%%%%: 3282-block 7
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3283:        IMGUI_DEBUG_LOG_CLIPPER("Clipper: Step(): inside frozen table row.\n");
    %%%%%: 3283-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3283-block 9
call    2 never executed
    4308*: 3284:    if (need_items_height && ItemsHeight > 0.0f)
     4308: 3284-block 10
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
    %%%%%: 3284-block 11
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3285:        IMGUI_DEBUG_LOG_CLIPPER("Clipper: Step(): computed ItemsHeight: %.2f.\n", ItemsHeight);
    %%%%%: 3285-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3285-block 13
call    2 never executed
     4308: 3286:    if (ret)
     4308: 3286-block 14
branch  0 taken 2154 (fallthrough)
branch  1 taken 2154
        -: 3287:    {
    2154*: 3288:        IMGUI_DEBUG_LOG_CLIPPER("Clipper: Step(): display %d to %d.\n", DisplayStart, DisplayEnd);
     2154: 3288-block 15
branch  0 taken 0 (fallthrough)
branch  1 taken 2154
    %%%%%: 3288-block 16
call    2 never executed
        -: 3289:    }
        -: 3290:    else
        -: 3291:    {
    2154*: 3292:        IMGUI_DEBUG_LOG_CLIPPER("Clipper: Step(): End.\n");
     2154: 3292-block 17
branch  0 taken 0 (fallthrough)
branch  1 taken 2154
    %%%%%: 3292-block 18
call    2 never executed
     2154: 3293:        End();
     2154: 3293-block 19
call    0 returned 2154
        -: 3294:    }
     4308: 3295:    return ret;
     4308: 3295-block 20
        -: 3296:}
        -: 3297:
        -: 3298://-----------------------------------------------------------------------------
        -: 3299:// [SECTION] STYLING
        -: 3300://-----------------------------------------------------------------------------
        -: 3301:
function _ZN5ImGui8GetStyleEv called 40976 returned 100% blocks executed 75%
    40976: 3302:ImGuiStyle& ImGui::GetStyle()
        -: 3303:{
   40976*: 3304:    IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?");
    40976: 3304-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 40976
    %%%%%: 3304-block 3
call    2 never executed
    40976: 3305:    return GImGui->Style;
    40976: 3305-block 4
        -: 3306:}
        -: 3307:
function _ZN5ImGui11GetColorU32Eif called 344187 returned 100% blocks executed 100%
   344187: 3308:ImU32 ImGui::GetColorU32(ImGuiCol idx, float alpha_mul)
        -: 3309:{
   344187: 3310:    ImGuiStyle& style = GImGui->Style;
   344187: 3311:    ImVec4 c = style.Colors[idx];
   344187: 3312:    c.w *= style.Alpha * alpha_mul;
   344187: 3313:    return ColorConvertFloat4ToU32(c);
   344187: 3313-block 2
call    0 returned 344187
        -: 3314:}
        -: 3315:
function _ZN5ImGui11GetColorU32ERK6ImVec4 called 0 returned 0% blocks executed 0%
    #####: 3316:ImU32 ImGui::GetColorU32(const ImVec4& col)
        -: 3317:{
    #####: 3318:    ImGuiStyle& style = GImGui->Style;
    #####: 3319:    ImVec4 c = col;
    #####: 3320:    c.w *= style.Alpha;
    #####: 3321:    return ColorConvertFloat4ToU32(c);
    %%%%%: 3321-block 2
call    0 never executed
        -: 3322:}
        -: 3323:
function _ZN5ImGui17GetStyleColorVec4Ei called 0 returned 0% blocks executed 0%
    #####: 3324:const ImVec4& ImGui::GetStyleColorVec4(ImGuiCol idx)
        -: 3325:{
    #####: 3326:    ImGuiStyle& style = GImGui->Style;
    #####: 3327:    return style.Colors[idx];
    %%%%%: 3327-block 2
        -: 3328:}
        -: 3329:
function _ZN5ImGui11GetColorU32Ejf called 0 returned 0% blocks executed 0%
    #####: 3330:ImU32 ImGui::GetColorU32(ImU32 col, float alpha_mul)
        -: 3331:{
    #####: 3332:    ImGuiStyle& style = GImGui->Style;
    #####: 3333:    alpha_mul *= style.Alpha;
    #####: 3334:    if (alpha_mul >= 1.0f)
    %%%%%: 3334-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3335:        return col;
    %%%%%: 3335-block 3
    #####: 3336:    ImU32 a = (col & IM_COL32_A_MASK) >> IM_COL32_A_SHIFT;
    #####: 3337:    a = (ImU32)(a * alpha_mul); // We don't need to clamp 0..255 because alpha is in 0..1 range.
    #####: 3338:    return (col & ~IM_COL32_A_MASK) | (a << IM_COL32_A_SHIFT);
    %%%%%: 3338-block 4
        -: 3339:}
        -: 3340:
        -: 3341:// FIXME: This may incur a round-trip (if the end user got their data from a float4) but eventually we aim to store the in-flight colors as ImU32
function _ZN5ImGui14PushStyleColorEij called 0 returned 0% blocks executed 0%
    #####: 3342:void ImGui::PushStyleColor(ImGuiCol idx, ImU32 col)
        -: 3343:{
    #####: 3344:    ImGuiContext& g = *GImGui;
    #####: 3345:    ImGuiColorMod backup;
    %%%%%: 3345-block 2
call    0 never executed
    #####: 3346:    backup.Col = idx;
    #####: 3347:    backup.BackupValue = g.Style.Colors[idx];
    #####: 3348:    g.ColorStack.push_back(backup);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3349:    if (g.DebugFlashStyleColorIdx != idx)
    %%%%%: 3349-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3350:        g.Style.Colors[idx] = ColorConvertU32ToFloat4(col);
    %%%%%: 3350-block 5
call    0 never executed
    #####: 3351:}
    %%%%%: 3351-block 6
        -: 3352:
function _ZN5ImGui14PushStyleColorEiRK6ImVec4 called 421753 returned 100% blocks executed 100%
   421753: 3353:void ImGui::PushStyleColor(ImGuiCol idx, const ImVec4& col)
        -: 3354:{
   421753: 3355:    ImGuiContext& g = *GImGui;
   421753: 3356:    ImGuiColorMod backup;
   421753: 3356-block 2
call    0 returned 421753
   421753: 3357:    backup.Col = idx;
   421753: 3358:    backup.BackupValue = g.Style.Colors[idx];
   421753: 3359:    g.ColorStack.push_back(backup);
call    0 returned 421753
branch  1 taken 421753 (fallthrough)
branch  2 taken 0 (throw)
   421753: 3360:    if (g.DebugFlashStyleColorIdx != idx)
   421753: 3360-block 4
branch  0 taken 421753 (fallthrough)
branch  1 taken 0
   421753: 3361:        g.Style.Colors[idx] = col;
   421753: 3361-block 5
   421753: 3362:}
   421753: 3362-block 6
        -: 3363:
function _ZN5ImGui13PopStyleColorEi called 394828 returned 100% blocks executed 64%
   394828: 3364:void ImGui::PopStyleColor(int count)
        -: 3365:{
   394828: 3366:    ImGuiContext& g = *GImGui;
   394828: 3367:    if (g.ColorStack.Size < count)
   394828: 3367-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 394828
        -: 3368:    {
    #####: 3369:        IM_ASSERT_USER_ERROR(0, "Calling PopStyleColor() too many times!");
    %%%%%: 3369-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3369-block 5
call    3 never executed
    #####: 3370:        count = g.ColorStack.Size;
    %%%%%: 3370-block 6
        -: 3371:    }
   816581: 3372:    while (count > 0)
   394828: 3372-block 7
   816581: 3372-block 11
branch  0 taken 421753
branch  1 taken 394828 (fallthrough)
        -: 3373:    {
   421753: 3374:        ImGuiColorMod& backup = g.ColorStack.back();
   421753: 3374-block 8
call    0 returned 421753
   421753: 3375:        g.Style.Colors[backup.Col] = backup.BackupValue;
   421753: 3376:        g.ColorStack.pop_back();
call    0 returned 421753
   421753: 3377:        count--;
        -: 3378:    }
   394828: 3379:}
        -: 3380:
        -: 3381:static const ImGuiCol GWindowDockStyleColors[ImGuiWindowDockStyleCol_COUNT] =
        -: 3382:{
        -: 3383:    ImGuiCol_Text, ImGuiCol_TabHovered, ImGuiCol_Tab, ImGuiCol_TabSelected, ImGuiCol_TabSelectedOverline, ImGuiCol_TabDimmed, ImGuiCol_TabDimmedSelected, ImGuiCol_TabDimmedSelectedOverline,
        -: 3384:};
        -: 3385:
        -: 3386:static const ImGuiDataVarInfo GStyleVarInfo[] =
        -: 3387:{
        -: 3388:    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, Alpha) },                     // ImGuiStyleVar_Alpha
        -: 3389:    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, DisabledAlpha) },             // ImGuiStyleVar_DisabledAlpha
        -: 3390:    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImGuiStyle, WindowPadding) },             // ImGuiStyleVar_WindowPadding
        -: 3391:    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, WindowRounding) },            // ImGuiStyleVar_WindowRounding
        -: 3392:    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, WindowBorderSize) },          // ImGuiStyleVar_WindowBorderSize
        -: 3393:    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImGuiStyle, WindowMinSize) },             // ImGuiStyleVar_WindowMinSize
        -: 3394:    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImGuiStyle, WindowTitleAlign) },          // ImGuiStyleVar_WindowTitleAlign
        -: 3395:    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, ChildRounding) },             // ImGuiStyleVar_ChildRounding
        -: 3396:    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, ChildBorderSize) },           // ImGuiStyleVar_ChildBorderSize
        -: 3397:    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, PopupRounding) },             // ImGuiStyleVar_PopupRounding
        -: 3398:    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, PopupBorderSize) },           // ImGuiStyleVar_PopupBorderSize
        -: 3399:    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImGuiStyle, FramePadding) },              // ImGuiStyleVar_FramePadding
        -: 3400:    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, FrameRounding) },             // ImGuiStyleVar_FrameRounding
        -: 3401:    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, FrameBorderSize) },           // ImGuiStyleVar_FrameBorderSize
        -: 3402:    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImGuiStyle, ItemSpacing) },               // ImGuiStyleVar_ItemSpacing
        -: 3403:    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImGuiStyle, ItemInnerSpacing) },          // ImGuiStyleVar_ItemInnerSpacing
        -: 3404:    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, IndentSpacing) },             // ImGuiStyleVar_IndentSpacing
        -: 3405:    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImGuiStyle, CellPadding) },               // ImGuiStyleVar_CellPadding
        -: 3406:    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, ScrollbarSize) },             // ImGuiStyleVar_ScrollbarSize
        -: 3407:    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, ScrollbarRounding) },         // ImGuiStyleVar_ScrollbarRounding
        -: 3408:    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, GrabMinSize) },               // ImGuiStyleVar_GrabMinSize
        -: 3409:    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, GrabRounding) },              // ImGuiStyleVar_GrabRounding
        -: 3410:    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, TabRounding) },               // ImGuiStyleVar_TabRounding
        -: 3411:    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, TabBorderSize) },             // ImGuiStyleVar_TabBorderSize
        -: 3412:    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, TabBarBorderSize) },          // ImGuiStyleVar_TabBarBorderSize
        -: 3413:    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, TabBarOverlineSize) },        // ImGuiStyleVar_TabBarOverlineSize
        -: 3414:    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, TableAngledHeadersAngle)},    // ImGuiStyleVar_TableAngledHeadersAngle
        -: 3415:    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImGuiStyle, TableAngledHeadersTextAlign)},// ImGuiStyleVar_TableAngledHeadersTextAlign
        -: 3416:    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImGuiStyle, ButtonTextAlign) },           // ImGuiStyleVar_ButtonTextAlign
        -: 3417:    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImGuiStyle, SelectableTextAlign) },       // ImGuiStyleVar_SelectableTextAlign
        -: 3418:    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, SeparatorTextBorderSize)},    // ImGuiStyleVar_SeparatorTextBorderSize
        -: 3419:    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImGuiStyle, SeparatorTextAlign) },        // ImGuiStyleVar_SeparatorTextAlign
        -: 3420:    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImGuiStyle, SeparatorTextPadding) },      // ImGuiStyleVar_SeparatorTextPadding
        -: 3421:    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, DockingSeparatorSize) },      // ImGuiStyleVar_DockingSeparatorSize
        -: 3422:};
        -: 3423:
function _ZN5ImGui15GetStyleVarInfoEi called 30156 returned 100% blocks executed 83%
    30156: 3424:const ImGuiDataVarInfo* ImGui::GetStyleVarInfo(ImGuiStyleVar idx)
        -: 3425:{
   30156*: 3426:    IM_ASSERT(idx >= 0 && idx < ImGuiStyleVar_COUNT);
    30156: 3426-block 2
branch  0 taken 30156 (fallthrough)
branch  1 taken 0
    30156: 3426-block 3
branch  2 taken 30156 (fallthrough)
branch  3 taken 0
    30156: 3426-block 4
    %%%%%: 3426-block 5
call    4 never executed
        -: 3427:    IM_STATIC_ASSERT(IM_ARRAYSIZE(GStyleVarInfo) == ImGuiStyleVar_COUNT);
    30156: 3428:    return &GStyleVarInfo[idx];
    30156: 3428-block 6
        -: 3429:}
        -: 3430:
function _ZN5ImGui12PushStyleVarEif called 4308 returned 100% blocks executed 69%
     4308: 3431:void ImGui::PushStyleVar(ImGuiStyleVar idx, float val)
        -: 3432:{
     4308: 3433:    ImGuiContext& g = *GImGui;
     4308: 3434:    const ImGuiDataVarInfo* var_info = GetStyleVarInfo(idx);
     4308: 3434-block 2
call    0 returned 4308
     4308: 3435:    if (var_info->Type != ImGuiDataType_Float || var_info->Count != 1)
branch  0 taken 4308 (fallthrough)
branch  1 taken 0
     4308: 3435-block 4
branch  2 taken 0 (fallthrough)
branch  3 taken 4308
        -: 3436:    {
    #####: 3437:        IM_ASSERT_USER_ERROR(0, "Calling PushStyleVar() variant with wrong type!");
    %%%%%: 3437-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3437-block 7
call    3 never executed
    #####: 3438:        return;
    %%%%%: 3438-block 8
        -: 3439:    }
     4308: 3440:    float* pvar = (float*)var_info->GetVarPtr(&g.Style);
     4308: 3440-block 9
call    0 returned 4308
     4308: 3441:    g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));
call    0 returned 4308
call    1 returned 4308
branch  2 taken 4308 (fallthrough)
branch  3 taken 0 (throw)
     4308: 3442:    *pvar = val;
     4308: 3442-block 12
        -: 3443:}
        -: 3444:
function _ZN5ImGui13PushStyleVarXEif called 3231 returned 100% blocks executed 69%
     3231: 3445:void ImGui::PushStyleVarX(ImGuiStyleVar idx, float val_x)
        -: 3446:{
     3231: 3447:    ImGuiContext& g = *GImGui;
     3231: 3448:    const ImGuiDataVarInfo* var_info = GetStyleVarInfo(idx);
     3231: 3448-block 2
call    0 returned 3231
     3231: 3449:    if (var_info->Type != ImGuiDataType_Float || var_info->Count != 2)
branch  0 taken 3231 (fallthrough)
branch  1 taken 0
     3231: 3449-block 4
branch  2 taken 0 (fallthrough)
branch  3 taken 3231
        -: 3450:    {
    #####: 3451:        IM_ASSERT_USER_ERROR(0, "Calling PushStyleVar() variant with wrong type!");
    %%%%%: 3451-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3451-block 7
call    3 never executed
    #####: 3452:        return;
    %%%%%: 3452-block 8
        -: 3453:    }
     3231: 3454:    ImVec2* pvar = (ImVec2*)var_info->GetVarPtr(&g.Style);
     3231: 3454-block 9
call    0 returned 3231
     3231: 3455:    g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));
call    0 returned 3231
call    1 returned 3231
branch  2 taken 3231 (fallthrough)
branch  3 taken 0 (throw)
     3231: 3456:    pvar->x = val_x;
     3231: 3456-block 12
        -: 3457:}
        -: 3458:
function _ZN5ImGui13PushStyleVarYEif called 0 returned 0% blocks executed 0%
    #####: 3459:void ImGui::PushStyleVarY(ImGuiStyleVar idx, float val_y)
        -: 3460:{
    #####: 3461:    ImGuiContext& g = *GImGui;
    #####: 3462:    const ImGuiDataVarInfo* var_info = GetStyleVarInfo(idx);
    %%%%%: 3462-block 2
call    0 never executed
    #####: 3463:    if (var_info->Type != ImGuiDataType_Float || var_info->Count != 2)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3463-block 4
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 3464:    {
    #####: 3465:        IM_ASSERT_USER_ERROR(0, "Calling PushStyleVar() variant with wrong type!");
    %%%%%: 3465-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3465-block 7
call    3 never executed
    #####: 3466:        return;
    %%%%%: 3466-block 8
        -: 3467:    }
    #####: 3468:    ImVec2* pvar = (ImVec2*)var_info->GetVarPtr(&g.Style);
    %%%%%: 3468-block 9
call    0 never executed
    #####: 3469:    g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####: 3470:    pvar->y = val_y;
    %%%%%: 3470-block 12
        -: 3471:}
        -: 3472:
function _ZN5ImGui12PushStyleVarEiRK6ImVec2 called 7539 returned 100% blocks executed 69%
     7539: 3473:void ImGui::PushStyleVar(ImGuiStyleVar idx, const ImVec2& val)
        -: 3474:{
     7539: 3475:    ImGuiContext& g = *GImGui;
     7539: 3476:    const ImGuiDataVarInfo* var_info = GetStyleVarInfo(idx);
     7539: 3476-block 2
call    0 returned 7539
     7539: 3477:    if (var_info->Type != ImGuiDataType_Float || var_info->Count != 2)
branch  0 taken 7539 (fallthrough)
branch  1 taken 0
     7539: 3477-block 4
branch  2 taken 0 (fallthrough)
branch  3 taken 7539
        -: 3478:    {
    #####: 3479:        IM_ASSERT_USER_ERROR(0, "Calling PushStyleVar() variant with wrong type!");
    %%%%%: 3479-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3479-block 7
call    3 never executed
    #####: 3480:        return;
    %%%%%: 3480-block 8
        -: 3481:    }
     7539: 3482:    ImVec2* pvar = (ImVec2*)var_info->GetVarPtr(&g.Style);
     7539: 3482-block 9
call    0 returned 7539
     7539: 3483:    g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));
call    0 returned 7539
call    1 returned 7539
branch  2 taken 7539 (fallthrough)
branch  3 taken 0 (throw)
     7539: 3484:    *pvar = val;
     7539: 3484-block 12
        -: 3485:}
        -: 3486:
function _ZN5ImGui11PopStyleVarEi called 9693 returned 100% blocks executed 79%
     9693: 3487:void ImGui::PopStyleVar(int count)
        -: 3488:{
     9693: 3489:    ImGuiContext& g = *GImGui;
     9693: 3490:    if (g.StyleVarStack.Size < count)
     9693: 3490-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 9693
        -: 3491:    {
    #####: 3492:        IM_ASSERT_USER_ERROR(0, "Calling PopStyleVar() too many times!");
    %%%%%: 3492-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3492-block 5
call    3 never executed
    #####: 3493:        count = g.StyleVarStack.Size;
    %%%%%: 3493-block 6
        -: 3494:    }
    24771: 3495:    while (count > 0)
     9693: 3495-block 7
    24771: 3495-block 19
branch  0 taken 15078
branch  1 taken 9693 (fallthrough)
        -: 3496:    {
        -: 3497:        // We avoid a generic memcpy(data, &backup.Backup.., GDataTypeSize[info->Type] * info->Count), the overhead in Debug is not worth it.
    15078: 3498:        ImGuiStyleMod& backup = g.StyleVarStack.back();
    15078: 3498-block 8
call    0 returned 15078
    15078: 3499:        const ImGuiDataVarInfo* info = GetStyleVarInfo(backup.VarIdx);
call    0 returned 15078
    15078: 3500:        void* data = info->GetVarPtr(&g.Style);
call    0 returned 15078
    15078: 3501:        if (info->Type == ImGuiDataType_Float && info->Count == 1)      { ((float*)data)[0] = backup.BackupFloat[0]; }
branch  0 taken 15078 (fallthrough)
branch  1 taken 0
    15078: 3501-block 12
branch  2 taken 4308 (fallthrough)
branch  3 taken 10770
     4308: 3501-block 13
    10770: 3502:        else if (info->Type == ImGuiDataType_Float && info->Count == 2) { ((float*)data)[0] = backup.BackupFloat[0]; ((float*)data)[1] = backup.BackupFloat[1]; }
    10770: 3502-block 14
branch  0 taken 10770 (fallthrough)
branch  1 taken 0
    10770: 3502-block 15
branch  2 taken 10770 (fallthrough)
branch  3 taken 0
    10770: 3502-block 16
    15078: 3503:        g.StyleVarStack.pop_back();
    15078: 3503-block 17
call    0 returned 15078
    15078: 3504:        count--;
        -: 3505:    }
     9693: 3506:}
        -: 3507:
function _ZN5ImGui17GetStyleColorNameEi called 0 returned 0% blocks executed 0%
    #####: 3508:const char* ImGui::GetStyleColorName(ImGuiCol idx)
        -: 3509:{
        -: 3510:    // Create switch-case from enum with regexp: ImGuiCol_{.*}, --> case ImGuiCol_\1: return "\1";
    #####: 3511:    switch (idx)
    %%%%%: 3511-block 2
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
branch 22 never executed
branch 23 never executed
branch 24 never executed
branch 25 never executed
branch 26 never executed
branch 27 never executed
branch 28 never executed
branch 29 never executed
branch 30 never executed
branch 31 never executed
branch 32 never executed
branch 33 never executed
branch 34 never executed
branch 35 never executed
branch 36 never executed
branch 37 never executed
branch 38 never executed
branch 39 never executed
branch 40 never executed
branch 41 never executed
branch 42 never executed
branch 43 never executed
branch 44 never executed
branch 45 never executed
branch 46 never executed
branch 47 never executed
branch 48 never executed
branch 49 never executed
branch 50 never executed
branch 51 never executed
branch 52 never executed
branch 53 never executed
branch 54 never executed
branch 55 never executed
branch 56 never executed
branch 57 never executed
branch 58 never executed
        -: 3512:    {
    #####: 3513:    case ImGuiCol_Text: return "Text";
    %%%%%: 3513-block 3
    #####: 3514:    case ImGuiCol_TextDisabled: return "TextDisabled";
    %%%%%: 3514-block 4
    #####: 3515:    case ImGuiCol_WindowBg: return "WindowBg";
    %%%%%: 3515-block 5
    #####: 3516:    case ImGuiCol_ChildBg: return "ChildBg";
    %%%%%: 3516-block 6
    #####: 3517:    case ImGuiCol_PopupBg: return "PopupBg";
    %%%%%: 3517-block 7
    #####: 3518:    case ImGuiCol_Border: return "Border";
    %%%%%: 3518-block 8
    #####: 3519:    case ImGuiCol_BorderShadow: return "BorderShadow";
    %%%%%: 3519-block 9
    #####: 3520:    case ImGuiCol_FrameBg: return "FrameBg";
    %%%%%: 3520-block 10
    #####: 3521:    case ImGuiCol_FrameBgHovered: return "FrameBgHovered";
    %%%%%: 3521-block 11
    #####: 3522:    case ImGuiCol_FrameBgActive: return "FrameBgActive";
    %%%%%: 3522-block 12
    #####: 3523:    case ImGuiCol_TitleBg: return "TitleBg";
    %%%%%: 3523-block 13
    #####: 3524:    case ImGuiCol_TitleBgActive: return "TitleBgActive";
    %%%%%: 3524-block 14
    #####: 3525:    case ImGuiCol_TitleBgCollapsed: return "TitleBgCollapsed";
    %%%%%: 3525-block 15
    #####: 3526:    case ImGuiCol_MenuBarBg: return "MenuBarBg";
    %%%%%: 3526-block 16
    #####: 3527:    case ImGuiCol_ScrollbarBg: return "ScrollbarBg";
    %%%%%: 3527-block 17
    #####: 3528:    case ImGuiCol_ScrollbarGrab: return "ScrollbarGrab";
    %%%%%: 3528-block 18
    #####: 3529:    case ImGuiCol_ScrollbarGrabHovered: return "ScrollbarGrabHovered";
    %%%%%: 3529-block 19
    #####: 3530:    case ImGuiCol_ScrollbarGrabActive: return "ScrollbarGrabActive";
    %%%%%: 3530-block 20
    #####: 3531:    case ImGuiCol_CheckMark: return "CheckMark";
    %%%%%: 3531-block 21
    #####: 3532:    case ImGuiCol_SliderGrab: return "SliderGrab";
    %%%%%: 3532-block 22
    #####: 3533:    case ImGuiCol_SliderGrabActive: return "SliderGrabActive";
    %%%%%: 3533-block 23
    #####: 3534:    case ImGuiCol_Button: return "Button";
    %%%%%: 3534-block 24
    #####: 3535:    case ImGuiCol_ButtonHovered: return "ButtonHovered";
    %%%%%: 3535-block 25
    #####: 3536:    case ImGuiCol_ButtonActive: return "ButtonActive";
    %%%%%: 3536-block 26
    #####: 3537:    case ImGuiCol_Header: return "Header";
    %%%%%: 3537-block 27
    #####: 3538:    case ImGuiCol_HeaderHovered: return "HeaderHovered";
    %%%%%: 3538-block 28
    #####: 3539:    case ImGuiCol_HeaderActive: return "HeaderActive";
    %%%%%: 3539-block 29
    #####: 3540:    case ImGuiCol_Separator: return "Separator";
    %%%%%: 3540-block 30
    #####: 3541:    case ImGuiCol_SeparatorHovered: return "SeparatorHovered";
    %%%%%: 3541-block 31
    #####: 3542:    case ImGuiCol_SeparatorActive: return "SeparatorActive";
    %%%%%: 3542-block 32
    #####: 3543:    case ImGuiCol_ResizeGrip: return "ResizeGrip";
    %%%%%: 3543-block 33
    #####: 3544:    case ImGuiCol_ResizeGripHovered: return "ResizeGripHovered";
    %%%%%: 3544-block 34
    #####: 3545:    case ImGuiCol_ResizeGripActive: return "ResizeGripActive";
    %%%%%: 3545-block 35
    #####: 3546:    case ImGuiCol_TabHovered: return "TabHovered";
    %%%%%: 3546-block 36
    #####: 3547:    case ImGuiCol_Tab: return "Tab";
    %%%%%: 3547-block 37
    #####: 3548:    case ImGuiCol_TabSelected: return "TabSelected";
    %%%%%: 3548-block 38
    #####: 3549:    case ImGuiCol_TabSelectedOverline: return "TabSelectedOverline";
    %%%%%: 3549-block 39
    #####: 3550:    case ImGuiCol_TabDimmed: return "TabDimmed";
    %%%%%: 3550-block 40
    #####: 3551:    case ImGuiCol_TabDimmedSelected: return "TabDimmedSelected";
    %%%%%: 3551-block 41
    #####: 3552:    case ImGuiCol_TabDimmedSelectedOverline: return "TabDimmedSelectedOverline";
    %%%%%: 3552-block 42
    #####: 3553:    case ImGuiCol_DockingPreview: return "DockingPreview";
    %%%%%: 3553-block 43
    #####: 3554:    case ImGuiCol_DockingEmptyBg: return "DockingEmptyBg";
    %%%%%: 3554-block 44
    #####: 3555:    case ImGuiCol_PlotLines: return "PlotLines";
    %%%%%: 3555-block 45
    #####: 3556:    case ImGuiCol_PlotLinesHovered: return "PlotLinesHovered";
    %%%%%: 3556-block 46
    #####: 3557:    case ImGuiCol_PlotHistogram: return "PlotHistogram";
    %%%%%: 3557-block 47
    #####: 3558:    case ImGuiCol_PlotHistogramHovered: return "PlotHistogramHovered";
    %%%%%: 3558-block 48
    #####: 3559:    case ImGuiCol_TableHeaderBg: return "TableHeaderBg";
    %%%%%: 3559-block 49
    #####: 3560:    case ImGuiCol_TableBorderStrong: return "TableBorderStrong";
    %%%%%: 3560-block 50
    #####: 3561:    case ImGuiCol_TableBorderLight: return "TableBorderLight";
    %%%%%: 3561-block 51
    #####: 3562:    case ImGuiCol_TableRowBg: return "TableRowBg";
    %%%%%: 3562-block 52
    #####: 3563:    case ImGuiCol_TableRowBgAlt: return "TableRowBgAlt";
    %%%%%: 3563-block 53
    #####: 3564:    case ImGuiCol_TextLink: return "TextLink";
    %%%%%: 3564-block 54
    #####: 3565:    case ImGuiCol_TextSelectedBg: return "TextSelectedBg";
    %%%%%: 3565-block 55
    #####: 3566:    case ImGuiCol_DragDropTarget: return "DragDropTarget";
    %%%%%: 3566-block 56
    #####: 3567:    case ImGuiCol_NavCursor: return "NavCursor";
    %%%%%: 3567-block 57
    #####: 3568:    case ImGuiCol_NavWindowingHighlight: return "NavWindowingHighlight";
    %%%%%: 3568-block 58
    #####: 3569:    case ImGuiCol_NavWindowingDimBg: return "NavWindowingDimBg";
    %%%%%: 3569-block 59
    #####: 3570:    case ImGuiCol_ModalWindowDimBg: return "ModalWindowDimBg";
    %%%%%: 3570-block 60
        -: 3571:    }
    #####: 3572:    IM_ASSERT(0);
    %%%%%: 3572-block 61
call    0 never executed
        -: 3573:    return "Unknown";
        -: 3574:}
        -: 3575:
        -: 3576:
        -: 3577://-----------------------------------------------------------------------------
        -: 3578:// [SECTION] RENDER HELPERS
        -: 3579:// Some of those (internal) functions are currently quite a legacy mess - their signature and behavior will change,
        -: 3580:// we need a nicer separation between low-level functions and high-level functions relying on the ImGui context.
        -: 3581:// Also see imgui_draw.cpp for some more which have been reworked to not rely on ImGui:: context.
        -: 3582://-----------------------------------------------------------------------------
        -: 3583:
function _ZN5ImGui19FindRenderedTextEndEPKcS1_ called 147350 returned 100% blocks executed 100%
   147350: 3584:const char* ImGui::FindRenderedTextEnd(const char* text, const char* text_end)
        -: 3585:{
   147350: 3586:    const char* text_display_end = text;
   147350: 3587:    if (!text_end)
   147350: 3587-block 2
branch  0 taken 143045 (fallthrough)
branch  1 taken 4305
   143045: 3588:        text_end = (const char*)-1;
   143045: 3588-block 3
        -: 3589:
   607603: 3590:    while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))
   147350: 3590-block 4
   607603: 3590-block 6
branch  0 taken 603298 (fallthrough)
branch  1 taken 4305
   603298: 3590-block 7
branch  2 taken 491486 (fallthrough)
branch  3 taken 111812
   491486: 3590-block 8
branch  4 taken 460253
branch  5 taken 31233 (fallthrough)
    31233: 3590-block 9
branch  6 taken 0
branch  7 taken 31233 (fallthrough)
   460253: 3591:        text_display_end++;
   460253: 3591-block 5
   147350: 3592:    return text_display_end;
   147350: 3592-block 10
        -: 3593:}
        -: 3594:
        -: 3595:// Internal ImGui functions to render text
        -: 3596:// RenderText***() functions calls ImDrawList::AddText() calls ImBitmapFont::RenderText()
function _ZN5ImGui10RenderTextE6ImVec2PKcS2_b called 3231 returned 100% blocks executed 64%
     3231: 3597:void ImGui::RenderText(ImVec2 pos, const char* text, const char* text_end, bool hide_text_after_hash)
        -: 3598:{
     3231: 3599:    ImGuiContext& g = *GImGui;
     3231: 3600:    ImGuiWindow* window = g.CurrentWindow;
        -: 3601:
        -: 3602:    // Hide anything after a '##' string
        -: 3603:    const char* text_display_end;
     3231: 3604:    if (hide_text_after_hash)
     3231: 3604-block 2
branch  0 taken 3231 (fallthrough)
branch  1 taken 0
        -: 3605:    {
     3231: 3606:        text_display_end = FindRenderedTextEnd(text, text_end);
     3231: 3606-block 3
call    0 returned 3231
        -: 3607:    }
        -: 3608:    else
        -: 3609:    {
    #####: 3610:        if (!text_end)
    %%%%%: 3610-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3611:            text_end = text + strlen(text); // FIXME-OPT
    %%%%%: 3611-block 5
    #####: 3612:        text_display_end = text_end;
    %%%%%: 3612-block 6
        -: 3613:    }
        -: 3614:
     3231: 3615:    if (text != text_display_end)
     3231: 3615-block 7
branch  0 taken 3231 (fallthrough)
branch  1 taken 0
        -: 3616:    {
     3231: 3617:        window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_Text), text, text_display_end);
     3231: 3617-block 8
call    0 returned 3231
call    1 returned 3231
     3231: 3618:        if (g.LogEnabled)
branch  0 taken 0 (fallthrough)
branch  1 taken 3231
    #####: 3619:            LogRenderedText(&pos, text, text_display_end);
    %%%%%: 3619-block 11
call    0 never executed
        -: 3620:    }
     3231: 3621:}
        -: 3622:
function _ZN5ImGui17RenderTextWrappedE6ImVec2PKcS2_f called 99412 returned 100% blocks executed 75%
    99412: 3623:void ImGui::RenderTextWrapped(ImVec2 pos, const char* text, const char* text_end, float wrap_width)
        -: 3624:{
    99412: 3625:    ImGuiContext& g = *GImGui;
    99412: 3626:    ImGuiWindow* window = g.CurrentWindow;
        -: 3627:
    99412: 3628:    if (!text_end)
    99412: 3628-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 99412
    #####: 3629:        text_end = text + strlen(text); // FIXME-OPT
    %%%%%: 3629-block 3
        -: 3630:
    99412: 3631:    if (text != text_end)
    99412: 3631-block 4
branch  0 taken 99412 (fallthrough)
branch  1 taken 0
        -: 3632:    {
    99412: 3633:        window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_Text), text, text_end, wrap_width);
    99412: 3633-block 5
call    0 returned 99412
call    1 returned 99412
    99412: 3634:        if (g.LogEnabled)
branch  0 taken 0 (fallthrough)
branch  1 taken 99412
    #####: 3635:            LogRenderedText(&pos, text, text_end);
    %%%%%: 3635-block 8
call    0 never executed
        -: 3636:    }
    99412: 3637:}
        -: 3638:
        -: 3639:// Default clip_rect uses (pos_min,pos_max)
        -: 3640:// Handle clipping on CPU immediately (vs typically let the GPU clip the triangles that are overlapping the clipping rectangle edges)
        -: 3641:// FIXME-OPT: Since we have or calculate text_size we could coarse clip whole block immediately, especally for text above draw_list->DrawList.
        -: 3642:// Effectively as this is called from widget doing their own coarse clipping it's not very valuable presently. Next time function will take
        -: 3643:// better advantage of the render function taking size into account for coarse clipping.
function _ZN5ImGui19RenderTextClippedExEP10ImDrawListRK6ImVec2S4_PKcS6_PS3_S4_PK6ImRect called 46206 returned 100% blocks executed 91%
    46206: 3644:void ImGui::RenderTextClippedEx(ImDrawList* draw_list, const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_display_end, const ImVec2* text_size_if_known, const ImVec2& align, const ImRect* clip_rect)
        -: 3645:{
        -: 3646:    // Perform CPU side clipping for single clipped element to avoid using scissor state
    46206: 3647:    ImVec2 pos = pos_min;
   46206*: 3648:    const ImVec2 text_size = text_size_if_known ? *text_size_if_known : CalcTextSize(text, text_display_end, false, 0.0f);
    46206: 3648-block 2
branch  0 taken 46206 (fallthrough)
branch  1 taken 0
    46206: 3648-block 3
    %%%%%: 3648-block 4
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
        -: 3649:
    46206: 3650:    const ImVec2* clip_min = clip_rect ? &clip_rect->Min : &pos_min;
    46206: 3650-block 5
branch  0 taken 37597 (fallthrough)
branch  1 taken 8609
    37597: 3650-block 6
     8609: 3650-block 7
    46206: 3651:    const ImVec2* clip_max = clip_rect ? &clip_rect->Max : &pos_max;
    46206: 3651-block 8
branch  0 taken 37597 (fallthrough)
branch  1 taken 8609
    37597: 3651-block 9
     8609: 3651-block 10
    46206: 3652:    bool need_clipping = (pos.x + text_size.x >= clip_max->x) || (pos.y + text_size.y >= clip_max->y);
    46206: 3652-block 11
branch  0 taken 40825 (fallthrough)
branch  1 taken 5381
    40825: 3652-block 12
branch  2 taken 6385 (fallthrough)
branch  3 taken 34440
    11766: 3652-block 13
    34440: 3652-block 14
    46206: 3653:    if (clip_rect) // If we had no explicit clipping rectangle then pos==clip_min
    46206: 3653-block 15
branch  0 taken 37597 (fallthrough)
branch  1 taken 8609
   37597*: 3654:        need_clipping |= (pos.x < clip_min->x) || (pos.y < clip_min->y);
    37597: 3654-block 16
branch  0 taken 37597 (fallthrough)
branch  1 taken 0
    37597: 3654-block 17
branch  2 taken 0 (fallthrough)
branch  3 taken 37597
    %%%%%: 3654-block 18
    37597: 3654-block 19
    37597: 3654-block 20
        -: 3655:
        -: 3656:    // Align whole block. We should defer that to the better rendering function when we'll have support for individual line alignment.
    46206: 3657:    if (align.x > 0.0f) pos.x = ImMax(pos.x, pos.x + (pos_max.x - pos.x - text_size.x) * align.x);
    46206: 3657-block 21
branch  0 taken 12849 (fallthrough)
branch  1 taken 33357
    12849: 3657-block 22
call    2 returned 12849
    46206: 3658:    if (align.y > 0.0f) pos.y = ImMax(pos.y, pos.y + (pos_max.y - pos.y - text_size.y) * align.y);
    46206: 3658-block 24
branch  0 taken 12849 (fallthrough)
branch  1 taken 33357
    12849: 3658-block 25
call    2 returned 12849
        -: 3659:
        -: 3660:    // Render
    46206: 3661:    if (need_clipping)
    46206: 3661-block 27
branch  0 taken 11766 (fallthrough)
branch  1 taken 34440
        -: 3662:    {
    11766: 3663:        ImVec4 fine_clip_rect(clip_min->x, clip_min->y, clip_max->x, clip_max->y);
    11766: 3663-block 28
call    0 returned 11766
    11766: 3664:        draw_list->AddText(NULL, 0.0f, pos, GetColorU32(ImGuiCol_Text), text, text_display_end, 0.0f, &fine_clip_rect);
call    0 returned 11766
call    1 returned 11766
branch  2 taken 11766 (fallthrough)
branch  3 taken 0 (throw)
        -: 3665:    }
        -: 3666:    else
        -: 3667:    {
    34440: 3668:        draw_list->AddText(NULL, 0.0f, pos, GetColorU32(ImGuiCol_Text), text, text_display_end, 0.0f, NULL);
    34440: 3668-block 32
call    0 returned 34440
call    1 returned 34440
branch  2 taken 34440 (fallthrough)
branch  3 taken 0 (throw)
        -: 3669:    }
    46206: 3670:}
    46206: 3670-block 34
        -: 3671:
function _ZN5ImGui17RenderTextClippedERK6ImVec2S2_PKcS4_PS1_S2_PK6ImRect called 40828 returned 100% blocks executed 86%
    40828: 3672:void ImGui::RenderTextClipped(const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align, const ImRect* clip_rect)
        -: 3673:{
        -: 3674:    // Hide anything after a '##' string
    40828: 3675:    const char* text_display_end = FindRenderedTextEnd(text, text_end);
    40828: 3675-block 2
call    0 returned 40828
    40828: 3676:    const int text_len = (int)(text_display_end - text);
    40828: 3677:    if (text_len == 0)
branch  0 taken 3231 (fallthrough)
branch  1 taken 37597
     3231: 3678:        return;
     3231: 3678-block 4
        -: 3679:
    37597: 3680:    ImGuiContext& g = *GImGui;
    37597: 3681:    ImGuiWindow* window = g.CurrentWindow;
    37597: 3682:    RenderTextClippedEx(window->DrawList, pos_min, pos_max, text, text_display_end, text_size_if_known, align, clip_rect);
    37597: 3682-block 5
call    0 returned 37597
    37597: 3683:    if (g.LogEnabled)
branch  0 taken 0 (fallthrough)
branch  1 taken 37597
    #####: 3684:        LogRenderedText(&pos_min, text, text_display_end);
    %%%%%: 3684-block 7
call    0 never executed
        -: 3685:}
        -: 3686:
        -: 3687:// Another overly complex function until we reorganize everything into a nice all-in-one helper.
        -: 3688:// This is made more complex because we have dissociated the layout rectangle (pos_min..pos_max) which define _where_ the ellipsis is, from actual clipping of text and limit of the ellipsis display.
        -: 3689:// This is because in the context of tabs we selectively hide part of the text when the Close Button appears, but we don't want the ellipsis to move.
function _ZN5ImGui18RenderTextEllipsisEP10ImDrawListRK6ImVec2S4_ffPKcS6_PS3_ called 8609 returned 100% blocks executed 79%
     8609: 3690:void ImGui::RenderTextEllipsis(ImDrawList* draw_list, const ImVec2& pos_min, const ImVec2& pos_max, float clip_max_x, float ellipsis_max_x, const char* text, const char* text_end_full, const ImVec2* text_size_if_known)
        -: 3691:{
     8609: 3692:    ImGuiContext& g = *GImGui;
     8609: 3693:    if (text_end_full == NULL)
     8609: 3693-block 2
branch  0 taken 4304 (fallthrough)
branch  1 taken 4305
     4304: 3694:        text_end_full = FindRenderedTextEnd(text);
     4304: 3694-block 3
call    0 returned 4304
    8609*: 3695:    const ImVec2 text_size = text_size_if_known ? *text_size_if_known : CalcTextSize(text, text_end_full, false, 0.0f);
     8609: 3695-block 4
branch  0 taken 8609 (fallthrough)
branch  1 taken 0
     8609: 3695-block 5
    %%%%%: 3695-block 6
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
        -: 3696:
        -: 3697:    //draw_list->AddLine(ImVec2(pos_max.x, pos_min.y - 4), ImVec2(pos_max.x, pos_max.y + 4), IM_COL32(0, 0, 255, 255));
        -: 3698:    //draw_list->AddLine(ImVec2(ellipsis_max_x, pos_min.y-2), ImVec2(ellipsis_max_x, pos_max.y+2), IM_COL32(0, 255, 0, 255));
        -: 3699:    //draw_list->AddLine(ImVec2(clip_max_x, pos_min.y), ImVec2(clip_max_x, pos_max.y), IM_COL32(255, 0, 0, 255));
        -: 3700:    // FIXME: We could technically remove (last_glyph->AdvanceX - last_glyph->X1) from text_size.x here and save a few pixels.
     8609: 3701:    if (text_size.x > pos_max.x - pos_min.x)
     8609: 3701-block 7
branch  0 taken 5381 (fallthrough)
branch  1 taken 3228
        -: 3702:    {
        -: 3703:        // Hello wo...
        -: 3704:        // |       |   |
        -: 3705:        // min   max   ellipsis_max
        -: 3706:        //          <-> this is generally some padding value
        -: 3707:
     5381: 3708:        const ImFont* font = draw_list->_Data->Font;
     5381: 3709:        const float font_size = draw_list->_Data->FontSize;
     5381: 3710:        const float font_scale = draw_list->_Data->FontScale;
     5381: 3711:        const char* text_end_ellipsis = NULL;
     5381: 3712:        const float ellipsis_width = font->EllipsisWidth * font_scale;
        -: 3713:
        -: 3714:        // We can now claim the space between pos_max.x and ellipsis_max.x
     5381: 3715:        const float text_avail_width = ImMax((ImMax(pos_max.x, ellipsis_max_x) - ellipsis_width) - pos_min.x, 1.0f);
     5381: 3715-block 8
call    0 returned 5381
call    1 returned 5381
     5381: 3716:        float text_size_clipped_x = font->CalcTextSizeA(font_size, text_avail_width, 0.0f, text, text_end_full, &text_end_ellipsis).x;
call    0 returned 5381
branch  1 taken 5381 (fallthrough)
branch  2 taken 0 (throw)
     5381: 3717:        if (text == text_end_ellipsis && text_end_ellipsis < text_end_full)
     5381: 3717-block 11
branch  0 taken 4305 (fallthrough)
branch  1 taken 1076
     4305: 3717-block 12
branch  2 taken 4305 (fallthrough)
branch  3 taken 0
        -: 3718:        {
        -: 3719:            // Always display at least 1 character if there's no room for character + ellipsis
     4305: 3720:            text_end_ellipsis = text + ImTextCountUtf8BytesFromChar(text, text_end_full);
     4305: 3720-block 13
call    0 returned 4305
branch  1 taken 4305 (fallthrough)
branch  2 taken 0 (throw)
     4305: 3721:            text_size_clipped_x = font->CalcTextSizeA(font_size, FLT_MAX, 0.0f, text, text_end_ellipsis).x;
     4305: 3721-block 14
call    0 returned 4305
branch  1 taken 4305 (fallthrough)
branch  2 taken 0 (throw)
     4305: 3721-block 15
        -: 3722:        }
    5381*: 3723:        while (text_end_ellipsis > text && ImCharIsBlankA(text_end_ellipsis[-1]))
     5381: 3723-block 16
     5381: 3723-block 19
branch  0 taken 5381 (fallthrough)
branch  1 taken 0
     5381: 3723-block 20
call    2 returned 5381
branch  3 taken 0 (fallthrough)
branch  4 taken 5381
    %%%%%: 3723-block 22
     5381: 3723-block 23
     5381: 3723-block 24
branch  5 taken 0
branch  6 taken 5381 (fallthrough)
        -: 3724:        {
        -: 3725:            // Trim trailing space before ellipsis (FIXME: Supporting non-ascii blanks would be nice, for this we need a function to backtrack in UTF-8 text)
    #####: 3726:            text_end_ellipsis--;
    #####: 3727:            text_size_clipped_x -= font->CalcTextSizeA(font_size, FLT_MAX, 0.0f, text_end_ellipsis, text_end_ellipsis + 1).x; // Ascii blanks are always 1 byte
    %%%%%: 3727-block 17
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 3727-block 18
        -: 3728:        }
        -: 3729:
        -: 3730:        // Render text, render ellipsis
     5381: 3731:        RenderTextClippedEx(draw_list, pos_min, ImVec2(clip_max_x, pos_max.y), text, text_end_ellipsis, &text_size, ImVec2(0.0f, 0.0f));
     5381: 3731-block 25
call    0 returned 5381
call    1 returned 5381
call    2 returned 5381
branch  3 taken 5381 (fallthrough)
branch  4 taken 0 (throw)
    $$$$$: 3731-block 44
    $$$$$: 3731-block 45
     5381: 3732:        ImVec2 ellipsis_pos = ImTrunc(ImVec2(pos_min.x + text_size_clipped_x, pos_min.y));
     5381: 3732-block 28
call    0 returned 5381
call    1 returned 5381
     5381: 3733:        if (ellipsis_pos.x + ellipsis_width <= ellipsis_max_x)
branch  0 taken 1076 (fallthrough)
branch  1 taken 4305
     2152: 3734:            for (int i = 0; i < font->EllipsisCharCount; i++, ellipsis_pos.x += font->EllipsisCharStep * font_scale)
     1076: 3734-block 31
     1076: 3734-block 34
     2152: 3734-block 35
branch  0 taken 1076
branch  1 taken 1076 (fallthrough)
     1076: 3735:                font->RenderChar(draw_list, font_size, ellipsis_pos, GetColorU32(ImGuiCol_Text), font->EllipsisChar);
     1076: 3735-block 32
call    0 returned 1076
call    1 returned 1076
branch  2 taken 1076 (fallthrough)
branch  3 taken 0 (throw)
        -: 3736:    }
        -: 3737:    else
        -: 3738:    {
     3228: 3739:        RenderTextClippedEx(draw_list, pos_min, ImVec2(clip_max_x, pos_max.y), text, text_end_full, &text_size, ImVec2(0.0f, 0.0f));
     3228: 3739-block 37
call    0 returned 3228
call    1 returned 3228
call    2 returned 3228
branch  3 taken 3228 (fallthrough)
branch  4 taken 0 (throw)
     3228: 3739-block 40
    $$$$$: 3739-block 47
    $$$$$: 3739-block 48
        -: 3740:    }
        -: 3741:
     8609: 3742:    if (g.LogEnabled)
     8609: 3742-block 41
branch  0 taken 0 (fallthrough)
branch  1 taken 8609
    #####: 3743:        LogRenderedText(&pos_min, text, text_end_full);
    %%%%%: 3743-block 42
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
     8609: 3744:}
     8609: 3744-block 43
        -: 3745:
        -: 3746:// Render a rectangle shaped with optional rounding and borders
function _ZN5ImGui11RenderFrameE6ImVec2S0_jbf called 39749 returned 100% blocks executed 31%
    39749: 3747:void ImGui::RenderFrame(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool borders, float rounding)
        -: 3748:{
    39749: 3749:    ImGuiContext& g = *GImGui;
    39749: 3750:    ImGuiWindow* window = g.CurrentWindow;
    39749: 3751:    window->DrawList->AddRectFilled(p_min, p_max, fill_col, rounding);
    39749: 3751-block 2
call    0 returned 39749
    39749: 3752:    const float border_size = g.Style.FrameBorderSize;
    39749: 3753:    if (borders && border_size > 0.0f)
branch  0 taken 39749 (fallthrough)
branch  1 taken 0
    39749: 3753-block 4
branch  2 taken 0 (fallthrough)
branch  3 taken 39749
        -: 3754:    {
    #####: 3755:        window->DrawList->AddRect(p_min + ImVec2(1, 1), p_max + ImVec2(1, 1), GetColorU32(ImGuiCol_BorderShadow), rounding, 0, border_size);
    %%%%%: 3755-block 5
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
    $$$$$: 3755-block 14
    $$$$$: 3755-block 15
    $$$$$: 3755-block 16
    #####: 3756:        window->DrawList->AddRect(p_min, p_max, GetColorU32(ImGuiCol_Border), rounding, 0, border_size);
    %%%%%: 3756-block 11
call    0 never executed
call    1 never executed
        -: 3757:    }
    39749: 3758:}
    39749: 3758-block 13
        -: 3759:
function _ZN5ImGui17RenderFrameBorderE6ImVec2S0_f called 0 returned 0% blocks executed 0%
    #####: 3760:void ImGui::RenderFrameBorder(ImVec2 p_min, ImVec2 p_max, float rounding)
        -: 3761:{
    #####: 3762:    ImGuiContext& g = *GImGui;
    #####: 3763:    ImGuiWindow* window = g.CurrentWindow;
    #####: 3764:    const float border_size = g.Style.FrameBorderSize;
    #####: 3765:    if (border_size > 0.0f)
    %%%%%: 3765-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3766:    {
    #####: 3767:        window->DrawList->AddRect(p_min + ImVec2(1, 1), p_max + ImVec2(1, 1), GetColorU32(ImGuiCol_BorderShadow), rounding, 0, border_size);
    %%%%%: 3767-block 3
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
    $$$$$: 3767-block 12
    $$$$$: 3767-block 13
    $$$$$: 3767-block 14
    #####: 3768:        window->DrawList->AddRect(p_min, p_max, GetColorU32(ImGuiCol_Border), rounding, 0, border_size);
    %%%%%: 3768-block 9
call    0 never executed
call    1 never executed
        -: 3769:    }
    #####: 3770:}
    %%%%%: 3770-block 11
        -: 3771:
function _ZN5ImGui15RenderNavCursorERK6ImRectji called 66014 returned 100% blocks executed 27%
    66014: 3772:void ImGui::RenderNavCursor(const ImRect& bb, ImGuiID id, ImGuiNavRenderCursorFlags flags)
        -: 3773:{
    66014: 3774:    ImGuiContext& g = *GImGui;
    66014: 3775:    if (id != g.NavId)
    66014: 3775-block 2
branch  0 taken 65153 (fallthrough)
branch  1 taken 861
    66014: 3776:        return;
    65153: 3776-block 3
    66014: 3776-block 29
      861: 3777:    if (!g.NavCursorVisible && !(flags & ImGuiNavRenderCursorFlags_AlwaysDraw))
      861: 3777-block 4
branch  0 taken 861 (fallthrough)
branch  1 taken 0
      861: 3777-block 5
branch  2 taken 861 (fallthrough)
branch  3 taken 0
      861: 3778:        return;
      861: 3778-block 6
    #####: 3779:    if (id == g.LastItemData.ID && (g.LastItemData.ItemFlags & ImGuiItemFlags_NoNav))
    %%%%%: 3779-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3779-block 8
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3780:        return;
    %%%%%: 3780-block 9
    #####: 3781:    ImGuiWindow* window = g.CurrentWindow;
    #####: 3782:    if (window->DC.NavHideHighlightOneFrame)
    %%%%%: 3782-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3783:        return;
    %%%%%: 3783-block 11
        -: 3784:
    #####: 3785:    float rounding = (flags & ImGuiNavRenderCursorFlags_NoRounding) ? 0.0f : g.Style.FrameRounding;
    %%%%%: 3785-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3785-block 13
    %%%%%: 3785-block 14
    #####: 3786:    ImRect display_rect = bb;
    #####: 3787:    display_rect.ClipWith(window->ClipRect);
    %%%%%: 3787-block 15
call    0 never executed
    #####: 3788:    const float thickness = 2.0f;
    #####: 3789:    if (flags & ImGuiNavRenderCursorFlags_Compact)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3790:    {
    #####: 3791:        window->DrawList->AddRect(display_rect.Min, display_rect.Max, GetColorU32(ImGuiCol_NavCursor), rounding, 0, thickness);
    %%%%%: 3791-block 17
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
        -: 3792:    }
        -: 3793:    else
        -: 3794:    {
    #####: 3795:        const float distance = 3.0f + thickness * 0.5f;
    #####: 3796:        display_rect.Expand(ImVec2(distance, distance));
    %%%%%: 3796-block 19
call    0 never executed
call    1 never executed
    #####: 3797:        bool fully_visible = window->ClipRect.Contains(display_rect);
call    0 never executed
    #####: 3798:        if (!fully_visible)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3799:            window->DrawList->PushClipRect(display_rect.Min, display_rect.Max);
    %%%%%: 3799-block 23
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3800:        window->DrawList->AddRect(display_rect.Min, display_rect.Max, GetColorU32(ImGuiCol_NavCursor), rounding, 0, thickness);
    %%%%%: 3800-block 24
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####: 3801:        if (!fully_visible)
    %%%%%: 3801-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3802:            window->DrawList->PopClipRect();
    %%%%%: 3802-block 27
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 3803:    }
        -: 3804:}
        -: 3805:
function _ZN5ImGui17RenderMouseCursorE6ImVec2fijjj called 0 returned 0% blocks executed 0%
    #####: 3806:void ImGui::RenderMouseCursor(ImVec2 base_pos, float base_scale, ImGuiMouseCursor mouse_cursor, ImU32 col_fill, ImU32 col_border, ImU32 col_shadow)
        -: 3807:{
    #####: 3808:    ImGuiContext& g = *GImGui;
    #####: 3809:    if (mouse_cursor <= ImGuiMouseCursor_None || mouse_cursor >= ImGuiMouseCursor_COUNT) // We intentionally accept out of bound values.
    %%%%%: 3809-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3809-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3810:        mouse_cursor = ImGuiMouseCursor_Arrow;
    %%%%%: 3810-block 4
    #####: 3811:    ImFontAtlas* font_atlas = g.DrawListSharedData.Font->ContainerAtlas;
    #####: 3812:    for (ImGuiViewportP* viewport : g.Viewports)
    %%%%%: 3812-block 5
call    0 never executed
call    1 never executed
    %%%%%: 3812-block 46
    %%%%%: 3812-block 47
branch  2 never executed
branch  3 never executed (fallthrough)
        -: 3813:    {
        -: 3814:        // We scale cursor with current viewport/monitor, however Windows 10 for its own hardware cursor seems to be using a different scale factor.
    #####: 3815:        ImVec2 offset, size, uv[4];
    #####: 3816:        if (!font_atlas->GetMouseCursorTexData(mouse_cursor, &offset, &size, &uv[0], &uv[2]))
    %%%%%: 3816-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 3816-block 8
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 3817:            continue;
    %%%%%: 3817-block 9
    %%%%%: 3817-block 45
    #####: 3818:        const ImVec2 pos = base_pos - offset;
    %%%%%: 3818-block 10
call    0 never executed
    #####: 3819:        const float scale = base_scale * viewport->DpiScale;
    #####: 3820:        if (!viewport->GetMainRect().Overlaps(ImRect(pos, pos + ImVec2(size.x + 2, size.y + 2) * scale)))
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 3821:            continue;
    %%%%%: 3821-block 18
    #####: 3822:        ImDrawList* draw_list = GetForegroundDrawList(viewport);
    %%%%%: 3822-block 19
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3823:        ImTextureID tex_id = font_atlas->TexID;
    #####: 3824:        draw_list->PushTextureID(tex_id);
    %%%%%: 3824-block 20
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3825:        draw_list->AddImage(tex_id, pos + ImVec2(1, 0) * scale, pos + (ImVec2(1, 0) + size) * scale, uv[2], uv[3], col_shadow);
    %%%%%: 3825-block 21
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
branch  8 never executed (fallthrough)
branch  9 never executed (throw)
    $$$$$: 3825-block 49
    $$$$$: 3825-block 50
    $$$$$: 3825-block 51
    $$$$$: 3825-block 52
    $$$$$: 3825-block 53
    $$$$$: 3825-block 54
    $$$$$: 3825-block 55
    #####: 3826:        draw_list->AddImage(tex_id, pos + ImVec2(2, 0) * scale, pos + (ImVec2(2, 0) + size) * scale, uv[2], uv[3], col_shadow);
    %%%%%: 3826-block 29
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
branch  8 never executed (fallthrough)
branch  9 never executed (throw)
    $$$$$: 3826-block 56
    $$$$$: 3826-block 57
    $$$$$: 3826-block 58
    $$$$$: 3826-block 59
    $$$$$: 3826-block 60
    $$$$$: 3826-block 61
    $$$$$: 3826-block 62
    #####: 3827:        draw_list->AddImage(tex_id, pos,                        pos + size * scale,                  uv[2], uv[3], col_border);
    %%%%%: 3827-block 37
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    $$$$$: 3827-block 63
    $$$$$: 3827-block 64
    #####: 3828:        draw_list->AddImage(tex_id, pos,                        pos + size * scale,                  uv[0], uv[1], col_fill);
    %%%%%: 3828-block 40
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    $$$$$: 3828-block 65
    $$$$$: 3828-block 66
    #####: 3829:        draw_list->PopTextureID();
    %%%%%: 3829-block 43
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 3830:    }
    #####: 3831:}
    %%%%%: 3831-block 48
        -: 3832:
        -: 3833://-----------------------------------------------------------------------------
        -: 3834:// [SECTION] INITIALIZATION, SHUTDOWN
        -: 3835://-----------------------------------------------------------------------------
        -: 3836:
        -: 3837:// Internal state access - if you want to share Dear ImGui state between modules (e.g. DLL) or allocate it yourself
        -: 3838:// Note that we still point to some static data and members (such as GFontAtlas), so the state instance you end up using will point to the static data within its module
function _ZN5ImGui17GetCurrentContextEv called 9127 returned 100% blocks executed 100%
     9127: 3839:ImGuiContext* ImGui::GetCurrentContext()
        -: 3840:{
     9127: 3841:    return GImGui;
     9127: 3841-block 2
        -: 3842:}
        -: 3843:
function _ZN5ImGui17SetCurrentContextEP12ImGuiContext called 3 returned 100% blocks executed 100%
        3: 3844:void ImGui::SetCurrentContext(ImGuiContext* ctx)
        -: 3845:{
        -: 3846:#ifdef IMGUI_SET_CURRENT_CONTEXT_FUNC
        -: 3847:    IMGUI_SET_CURRENT_CONTEXT_FUNC(ctx); // For custom thread-based hackery you may want to have control over this.
        -: 3848:#else
        3: 3849:    GImGui = ctx;
        -: 3850:#endif
        3: 3851:}
        -: 3852:
function _ZN5ImGui21SetAllocatorFunctionsEPFPvmS0_EPFvS0_S0_ES0_ called 0 returned 0% blocks executed 0%
    #####: 3853:void ImGui::SetAllocatorFunctions(ImGuiMemAllocFunc alloc_func, ImGuiMemFreeFunc free_func, void* user_data)
        -: 3854:{
    #####: 3855:    GImAllocatorAllocFunc = alloc_func;
    #####: 3856:    GImAllocatorFreeFunc = free_func;
    #####: 3857:    GImAllocatorUserData = user_data;
    #####: 3858:}
        -: 3859:
        -: 3860:// This is provided to facilitate copying allocators from one static/DLL boundary to another (e.g. retrieve default allocator of your executable address space)
function _ZN5ImGui21GetAllocatorFunctionsEPPFPvmS0_EPPFvS0_S0_EPS0_ called 0 returned 0% blocks executed 0%
    #####: 3861:void ImGui::GetAllocatorFunctions(ImGuiMemAllocFunc* p_alloc_func, ImGuiMemFreeFunc* p_free_func, void** p_user_data)
        -: 3862:{
    #####: 3863:    *p_alloc_func = GImAllocatorAllocFunc;
    #####: 3864:    *p_free_func = GImAllocatorFreeFunc;
    #####: 3865:    *p_user_data = GImAllocatorUserData;
    #####: 3866:}
        -: 3867:
function _ZN5ImGui13CreateContextEP11ImFontAtlas called 1 returned 100% blocks executed 77%
        1: 3868:ImGuiContext* ImGui::CreateContext(ImFontAtlas* shared_font_atlas)
        -: 3869:{
        1: 3870:    ImGuiContext* prev_ctx = GetCurrentContext();
        1: 3870-block 2
call    0 returned 1
        1: 3871:    ImGuiContext* ctx = IM_NEW(ImGuiContext)(shared_font_atlas);
call    0 returned 1
call    1 returned 1
call    2 returned 1
branch  3 taken 1 (fallthrough)
branch  4 taken 0 (throw)
    $$$$$: 3871-block 12
branch  5 never executed (fallthrough)
branch  6 never executed
    $$$$$: 3871-block 13
call    7 never executed
        1: 3872:    SetCurrentContext(ctx);
        1: 3872-block 6
call    0 returned 1
        1: 3873:    Initialize();
call    0 returned 1
        1: 3874:    if (prev_ctx != NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 3875:        SetCurrentContext(prev_ctx); // Restore previous context if any, else keep new one.
    %%%%%: 3875-block 9
call    0 never executed
        1: 3876:    return ctx;
        1: 3876-block 10
        1: 3876-block 11
        -: 3877:}
        -: 3878:
function _ZN5ImGui14DestroyContextEP12ImGuiContext called 1 returned 100% blocks executed 91%
        1: 3879:void ImGui::DestroyContext(ImGuiContext* ctx)
        -: 3880:{
        1: 3881:    ImGuiContext* prev_ctx = GetCurrentContext();
        1: 3881-block 2
call    0 returned 1
        1: 3882:    if (ctx == NULL) //-V1051
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 3883:        ctx = prev_ctx;
        1: 3883-block 4
        1: 3884:    SetCurrentContext(ctx);
        1: 3884-block 5
call    0 returned 1
        1: 3885:    Shutdown();
call    0 returned 1
       1*: 3886:    SetCurrentContext((prev_ctx != ctx) ? prev_ctx : NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 3886-block 8
        1: 3886-block 9
        1: 3886-block 10
call    2 returned 1
        1: 3887:    IM_DELETE(ctx);
call    0 returned 1
        1: 3888:}
        -: 3889:
        -: 3890:// IMPORTANT: interactive elements requires a fixed ###xxx suffix, it must be same in ALL languages to allow for automation.
        -: 3891:static const ImGuiLocEntry GLocalizationEntriesEnUS[] =
        -: 3892:{
        -: 3893:    { ImGuiLocKey_VersionStr,           "Dear ImGui " IMGUI_VERSION " (" IM_STRINGIFY(IMGUI_VERSION_NUM) ")" },
        -: 3894:    { ImGuiLocKey_TableSizeOne,         "Size column to fit###SizeOne"          },
        -: 3895:    { ImGuiLocKey_TableSizeAllFit,      "Size all columns to fit###SizeAll"     },
        -: 3896:    { ImGuiLocKey_TableSizeAllDefault,  "Size all columns to default###SizeAll" },
        -: 3897:    { ImGuiLocKey_TableResetOrder,      "Reset order###ResetOrder"              },
        -: 3898:    { ImGuiLocKey_WindowingMainMenuBar, "(Main menu bar)"                       },
        -: 3899:    { ImGuiLocKey_WindowingPopup,       "(Popup)"                               },
        -: 3900:    { ImGuiLocKey_WindowingUntitled,    "(Untitled)"                            },
        -: 3901:    { ImGuiLocKey_OpenLink_s,           "Open '%s'"                             },
        -: 3902:    { ImGuiLocKey_CopyLink,             "Copy Link###CopyLink"                  },
        -: 3903:    { ImGuiLocKey_DockingHideTabBar,            "Hide tab bar###HideTabBar"             },
        -: 3904:    { ImGuiLocKey_DockingHoldShiftToDock,       "Hold SHIFT to enable Docking window."  },
        -: 3905:    { ImGuiLocKey_DockingDragToUndockOrMoveNode,"Click and drag to move or undock whole node."    },
        -: 3906:};
        -: 3907:
function _ZN12ImGuiContextC2EP11ImFontAtlas called 1 returned 100% blocks executed 50%
      155: 3908:ImGuiContext::ImGuiContext(ImFontAtlas* shared_font_atlas)
        1: 3908-block 2
call    0 returned 1
call    1 returned 1
branch  2 taken 1 (fallthrough)
branch  3 taken 0 (throw)
        1: 3908-block 4
call    4 returned 1
branch  5 taken 1 (fallthrough)
branch  6 taken 0 (throw)
        1: 3908-block 5
call    7 returned 1
branch  8 taken 1 (fallthrough)
branch  9 taken 0 (throw)
        1: 3908-block 6
call   10 returned 1
call   11 returned 1
call   12 returned 1
call   13 returned 1
call   14 returned 1
call   15 returned 1
call   16 returned 1
branch 17 taken 1 (fallthrough)
branch 18 taken 0 (throw)
        1: 3908-block 13
call   19 returned 1
call   20 returned 1
call   21 returned 1
call   22 returned 1
call   23 returned 1
call   24 returned 1
branch 25 taken 1 (fallthrough)
branch 26 taken 0 (throw)
        1: 3908-block 19
      154: 3908-block 20
call   27 returned 154
      155: 3908-block 22
branch 28 taken 154
branch 29 taken 1 (fallthrough)
        1: 3908-block 23
call   30 returned 1
branch 31 taken 1 (fallthrough)
branch 32 taken 0 (throw)
        1: 3908-block 24
call   33 returned 1
call   34 returned 1
call   35 returned 1
call   36 returned 1
call   37 returned 1
call   38 returned 1
call   39 returned 1
call   40 returned 1
call   41 returned 1
call   42 returned 1
call   43 returned 1
call   44 returned 1
call   45 returned 1
call   46 returned 1
call   47 returned 1
call   48 returned 1
call   49 returned 1
branch 50 taken 1 (fallthrough)
branch 51 taken 0 (throw)
        1: 3908-block 41
call   52 returned 1
call   53 returned 1
call   54 returned 1
branch 55 taken 1 (fallthrough)
branch 56 taken 0 (throw)
        1: 3908-block 44
call   57 returned 1
branch 58 taken 1 (fallthrough)
branch 59 taken 0 (throw)
        1: 3908-block 45
call   60 returned 1
branch 61 taken 1 (fallthrough)
branch 62 taken 0 (throw)
        1: 3908-block 46
call   63 returned 1
branch 64 taken 1 (fallthrough)
branch 65 taken 0 (throw)
        1: 3908-block 47
call   66 returned 1
call   67 returned 1
call   68 returned 1
branch 69 taken 1 (fallthrough)
branch 70 taken 0 (throw)
        1: 3908-block 50
call   71 returned 1
call   72 returned 1
call   73 returned 1
call   74 returned 1
call   75 returned 1
call   76 returned 1
branch 77 taken 1 (fallthrough)
branch 78 taken 0 (throw)
        1: 3908-block 56
call   79 returned 1
call   80 returned 1
call   81 returned 1
branch 82 taken 1 (fallthrough)
branch 83 taken 0 (throw)
        1: 3908-block 59
call   84 returned 1
call   85 returned 1
call   86 returned 1
call   87 returned 1
call   88 returned 1
branch 89 taken 1 (fallthrough)
branch 90 taken 0 (throw)
        1: 3908-block 64
call   91 returned 1
call   92 returned 1
branch 93 taken 1 (fallthrough)
branch 94 taken 0 (throw)
        1: 3908-block 66
call   95 returned 1
branch 96 taken 1 (fallthrough)
branch 97 taken 0 (throw)
        1: 3908-block 67
call   98 returned 1
branch 99 taken 1 (fallthrough)
branch 100 taken 0 (throw)
        1: 3908-block 68
call   101 returned 1
call   102 returned 1
call   103 returned 1
call   104 returned 1
call   105 returned 1
call   106 returned 1
call   107 returned 1
call   108 returned 1
call   109 returned 1
branch 110 taken 1 (fallthrough)
branch 111 taken 0 (throw)
        1: 3908-block 77
call   112 returned 1
branch 113 taken 1 (fallthrough)
branch 114 taken 0 (throw)
        1: 3908-block 78
call   115 returned 1
call   116 returned 1
branch 117 taken 1 (fallthrough)
branch 118 taken 0 (throw)
        1: 3908-block 80
call   119 returned 1
branch 120 taken 1 (fallthrough)
branch 121 taken 0 (throw)
        1: 3908-block 81
call   122 returned 1
call   123 returned 1
branch 124 taken 1 (fallthrough)
branch 125 taken 0 (throw)
        1: 3908-block 83
call   126 returned 1
call   127 returned 1
call   128 returned 1
branch 129 taken 1 (fallthrough)
branch 130 taken 0 (throw)
        1: 3908-block 86
call   131 returned 1
branch 132 taken 1 (fallthrough)
branch 133 taken 0 (throw)
        1: 3908-block 87
call   134 returned 1
call   135 returned 1
call   136 returned 1
branch 137 taken 1 (fallthrough)
branch 138 taken 0 (throw)
        1: 3908-block 90
call   139 returned 1
call   140 returned 1
        -: 3909:{
        1: 3910:    IO.Ctx = this;
        1: 3911:    InputTextState.Ctx = this;
        -: 3912:
        1: 3913:    Initialized = false;
        1: 3914:    ConfigFlagsCurrFrame = ConfigFlagsLastFrame = ImGuiConfigFlags_None;
        1: 3915:    FontAtlasOwnedByContext = shared_font_atlas ? false : true;
        1: 3916:    Font = NULL;
        1: 3917:    FontSize = FontBaseSize = FontScale = CurrentDpiScale = 0.0f;
       1*: 3918:    IO.Fonts = shared_font_atlas ? shared_font_atlas : IM_NEW(ImFontAtlas)();
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 3918-block 93
call    2 returned 1
branch  3 taken 1 (fallthrough)
branch  4 taken 0 (throw)
        1: 3918-block 94
call    5 returned 1
call    6 returned 1
branch  7 taken 1 (fallthrough)
branch  8 taken 0 (throw)
        1: 3918-block 96
    %%%%%: 3918-block 97
    $$$$$: 3918-block 108
branch  9 never executed (fallthrough)
branch 10 never executed
    $$$$$: 3918-block 109
branch 11 never executed (fallthrough)
branch 12 never executed
    $$$$$: 3918-block 110
call   13 never executed
        1: 3919:    Time = 0.0f;
        1: 3920:    FrameCount = 0;
        1: 3921:    FrameCountEnded = FrameCountPlatformEnded = FrameCountRendered = -1;
        1: 3922:    WithinFrameScope = WithinFrameScopeWithImplicitWindow = WithinEndChild = false;
        1: 3923:    GcCompactAll = false;
        1: 3924:    TestEngineHookItems = false;
        1: 3925:    TestEngine = NULL;
        1: 3926:    memset(ContextName, 0, sizeof(ContextName));
        -: 3927:
        1: 3928:    InputEventsNextMouseSource = ImGuiMouseSource_Mouse;
        1: 3929:    InputEventsNextEventId = 1;
        -: 3930:
        1: 3931:    WindowsActiveCount = 0;
        1: 3932:    CurrentWindow = NULL;
        1: 3933:    HoveredWindow = NULL;
        1: 3934:    HoveredWindowUnderMovingWindow = NULL;
        1: 3935:    HoveredWindowBeforeClear = NULL;
        1: 3936:    MovingWindow = NULL;
        1: 3937:    WheelingWindow = NULL;
        1: 3938:    WheelingWindowStartFrame = WheelingWindowScrolledFrame = -1;
        1: 3939:    WheelingWindowReleaseTimer = 0.0f;
        -: 3940:
        1: 3941:    DebugDrawIdConflicts = 0;
        1: 3942:    DebugHookIdInfo = 0;
        1: 3943:    HoveredId = HoveredIdPreviousFrame = 0;
        1: 3944:    HoveredIdPreviousFrameItemCount = 0;
        1: 3945:    HoveredIdAllowOverlap = false;
        1: 3946:    HoveredIdIsDisabled = false;
        1: 3947:    HoveredIdTimer = HoveredIdNotActiveTimer = 0.0f;
        1: 3948:    ItemUnclipByLog = false;
        1: 3949:    ActiveId = 0;
        1: 3950:    ActiveIdIsAlive = 0;
        1: 3951:    ActiveIdTimer = 0.0f;
        1: 3952:    ActiveIdIsJustActivated = false;
        1: 3953:    ActiveIdAllowOverlap = false;
        1: 3954:    ActiveIdNoClearOnFocusLoss = false;
        1: 3955:    ActiveIdHasBeenPressedBefore = false;
        1: 3956:    ActiveIdHasBeenEditedBefore = false;
        1: 3957:    ActiveIdHasBeenEditedThisFrame = false;
        1: 3958:    ActiveIdFromShortcut = false;
        1: 3959:    ActiveIdClickOffset = ImVec2(-1, -1);
        1: 3959-block 98
call    0 returned 1
        1: 3960:    ActiveIdWindow = NULL;
        1: 3961:    ActiveIdSource = ImGuiInputSource_None;
        1: 3962:    ActiveIdMouseButton = -1;
        1: 3963:    ActiveIdPreviousFrame = 0;
        1: 3964:    ActiveIdPreviousFrameIsAlive = false;
        1: 3965:    ActiveIdPreviousFrameHasBeenEditedBefore = false;
        1: 3966:    ActiveIdPreviousFrameWindow = NULL;
        1: 3967:    LastActiveId = 0;
        1: 3968:    LastActiveIdTimer = 0.0f;
        -: 3969:
        1: 3970:    LastKeyboardKeyPressTime = LastKeyModsChangeTime = LastKeyModsChangeFromNoneTime = -1.0;
        -: 3971:
        1: 3972:    ActiveIdUsingNavDirMask = 0x00;
        1: 3973:    ActiveIdUsingAllKeyboardKeys = false;
        -: 3974:
        1: 3975:    CurrentFocusScopeId = 0;
        1: 3976:    CurrentItemFlags = ImGuiItemFlags_None;
        1: 3977:    DebugShowGroupRects = false;
        -: 3978:
        1: 3979:    CurrentViewport = NULL;
        1: 3980:    MouseViewport = MouseLastHoveredViewport = NULL;
        1: 3981:    PlatformLastFocusedViewportId = 0;
        1: 3982:    ViewportCreatedCount = PlatformWindowsCreatedCount = 0;
        1: 3983:    ViewportFocusedStampCount = 0;
        -: 3984:
        1: 3985:    NavCursorVisible = false;
        1: 3986:    NavHighlightItemUnderNav = false;
        1: 3987:    NavMousePosDirty = false;
        1: 3988:    NavIdIsAlive = false;
        1: 3989:    NavId = 0;
        1: 3990:    NavWindow = NULL;
        1: 3991:    NavFocusScopeId = NavActivateId = NavActivateDownId = NavActivatePressedId = 0;
        1: 3992:    NavLayer = ImGuiNavLayer_Main;
        1: 3993:    NavNextActivateId = 0;
        1: 3994:    NavActivateFlags = NavNextActivateFlags = ImGuiActivateFlags_None;
        1: 3995:    NavHighlightActivatedId = 0;
        1: 3996:    NavHighlightActivatedTimer = 0.0f;
        1: 3997:    NavInputSource = ImGuiInputSource_Keyboard;
        1: 3998:    NavLastValidSelectionUserData = ImGuiSelectionUserData_Invalid;
        1: 3999:    NavCursorHideFrames = 0;
        -: 4000:
        1: 4001:    NavAnyRequest = false;
        1: 4002:    NavInitRequest = false;
        1: 4003:    NavInitRequestFromMove = false;
        1: 4004:    NavMoveSubmitted = false;
        1: 4005:    NavMoveScoringItems = false;
        1: 4006:    NavMoveForwardToNextFrame = false;
        1: 4007:    NavMoveFlags = ImGuiNavMoveFlags_None;
        1: 4008:    NavMoveScrollFlags = ImGuiScrollFlags_None;
        1: 4009:    NavMoveKeyMods = ImGuiMod_None;
        1: 4010:    NavMoveDir = NavMoveDirForDebug = NavMoveClipDir = ImGuiDir_None;
        1: 4011:    NavScoringDebugCount = 0;
        1: 4012:    NavTabbingDir = 0;
        1: 4013:    NavTabbingCounter = 0;
        -: 4014:
        1: 4015:    NavJustMovedFromFocusScopeId = NavJustMovedToId = NavJustMovedToFocusScopeId = 0;
        1: 4016:    NavJustMovedToKeyMods = ImGuiMod_None;
        1: 4017:    NavJustMovedToIsTabbing = false;
        1: 4018:    NavJustMovedToHasSelectionData = false;
        -: 4019:
        -: 4020:    // All platforms use Ctrl+Tab but Ctrl<>Super are swapped on Mac...
        -: 4021:    // FIXME: Because this value is stored, it annoyingly interfere with toggling io.ConfigMacOSXBehaviors updating this..
       1*: 4022:    ConfigNavWindowingKeyNext = IO.ConfigMacOSXBehaviors ? (ImGuiMod_Super | ImGuiKey_Tab) : (ImGuiMod_Ctrl | ImGuiKey_Tab);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 4022-block 100
        1: 4022-block 101
       1*: 4023:    ConfigNavWindowingKeyPrev = IO.ConfigMacOSXBehaviors ? (ImGuiMod_Super | ImGuiMod_Shift | ImGuiKey_Tab) : (ImGuiMod_Ctrl | ImGuiMod_Shift | ImGuiKey_Tab);
        1: 4023-block 102
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 4023-block 103
        1: 4023-block 104
        1: 4024:    NavWindowingTarget = NavWindowingTargetAnim = NavWindowingListWindow = NULL;
        1: 4025:    NavWindowingTimer = NavWindowingHighlightAlpha = 0.0f;
        1: 4026:    NavWindowingToggleLayer = false;
        1: 4027:    NavWindowingToggleKey = ImGuiKey_None;
        -: 4028:
        1: 4029:    DimBgRatio = 0.0f;
        -: 4030:
        1: 4031:    DragDropActive = DragDropWithinSource = DragDropWithinTarget = false;
        1: 4032:    DragDropSourceFlags = ImGuiDragDropFlags_None;
        1: 4033:    DragDropSourceFrameCount = -1;
        1: 4034:    DragDropMouseButton = -1;
        1: 4035:    DragDropTargetId = 0;
        1: 4036:    DragDropAcceptFlags = ImGuiDragDropFlags_None;
        1: 4037:    DragDropAcceptIdCurrRectSurface = 0.0f;
        1: 4038:    DragDropAcceptIdPrev = DragDropAcceptIdCurr = 0;
        1: 4039:    DragDropAcceptFrameCount = -1;
        1: 4040:    DragDropHoldJustPressedId = 0;
        1: 4041:    memset(DragDropPayloadBufLocal, 0, sizeof(DragDropPayloadBufLocal));
        -: 4042:
        1: 4043:    ClipperTempDataStacked = 0;
        -: 4044:
        1: 4045:    CurrentTable = NULL;
        1: 4046:    TablesTempDataStacked = 0;
        1: 4047:    CurrentTabBar = NULL;
        1: 4048:    CurrentMultiSelect = NULL;
        1: 4049:    MultiSelectTempDataStacked = 0;
        -: 4050:
        1: 4051:    HoverItemDelayId = HoverItemDelayIdPreviousFrame = HoverItemUnlockedStationaryId = HoverWindowUnlockedStationaryId = 0;
        1: 4052:    HoverItemDelayTimer = HoverItemDelayClearTimer = 0.0f;
        -: 4053:
        1: 4054:    MouseCursor = ImGuiMouseCursor_Arrow;
        1: 4055:    MouseStationaryTimer = 0.0f;
        -: 4056:
        1: 4057:    TempInputId = 0;
        1: 4058:    memset(&DataTypeZeroValue, 0, sizeof(DataTypeZeroValue));
        1: 4059:    BeginMenuDepth = BeginComboDepth = 0;
        1: 4060:    ColorEditOptions = ImGuiColorEditFlags_DefaultOptions_;
        1: 4061:    ColorEditCurrentID = ColorEditSavedID = 0;
        1: 4062:    ColorEditSavedHue = ColorEditSavedSat = 0.0f;
        1: 4063:    ColorEditSavedColor = 0;
        1: 4064:    WindowResizeRelativeMode = false;
        1: 4065:    ScrollbarSeekMode = 0;
        1: 4066:    ScrollbarClickDeltaToGrabCenter = 0.0f;
        1: 4067:    SliderGrabClickOffset = 0.0f;
        1: 4068:    SliderCurrentAccum = 0.0f;
        1: 4069:    SliderCurrentAccumDirty = false;
        1: 4070:    DragCurrentAccumDirty = false;
        1: 4071:    DragCurrentAccum = 0.0f;
        1: 4072:    DragSpeedDefaultRatio = 1.0f / 100.0f;
        1: 4073:    DisabledAlphaBackup = 0.0f;
        1: 4074:    DisabledStackSize = 0;
        1: 4075:    TooltipOverrideCount = 0;
        1: 4076:    TooltipPreviousWindow = NULL;
        -: 4077:
        1: 4078:    PlatformImeData.InputPos = ImVec2(0.0f, 0.0f);
        1: 4078-block 105
call    0 returned 1
        1: 4079:    PlatformImeDataPrev.InputPos = ImVec2(-1.0f, -1.0f); // Different to ensure initial submission
call    0 returned 1
        1: 4080:    PlatformImeViewport = 0;
        -: 4081:
        1: 4082:    DockNodeWindowMenuHandler = NULL;
        -: 4083:
        1: 4084:    SettingsLoaded = false;
        1: 4085:    SettingsDirtyTimer = 0.0f;
        1: 4086:    HookIdNext = 0;
        -: 4087:
        1: 4088:    memset(LocalizationTable, 0, sizeof(LocalizationTable));
        -: 4089:
        1: 4090:    LogEnabled = false;
        1: 4091:    LogType = ImGuiLogType_None;
        1: 4092:    LogNextPrefix = LogNextSuffix = NULL;
        1: 4093:    LogFile = NULL;
        1: 4094:    LogLinePosY = FLT_MAX;
        1: 4095:    LogLineFirstItem = false;
        1: 4096:    LogDepthRef = 0;
        1: 4097:    LogDepthToExpand = LogDepthToExpandDefault = 2;
        -: 4098:
        1: 4099:    ErrorCallback = NULL;
        1: 4100:    ErrorCallbackUserData = NULL;
        1: 4101:    ErrorFirst = true;
        1: 4102:    ErrorCountCurrentFrame = 0;
        1: 4103:    StackSizesInBeginForCurrentWindow = NULL;
        -: 4104:
        1: 4105:    DebugDrawIdConflictsCount = 0;
        1: 4106:    DebugLogFlags = ImGuiDebugLogFlags_EventError | ImGuiDebugLogFlags_OutputToTTY;
        1: 4107:    DebugLocateId = 0;
        1: 4108:    DebugLogSkippedErrors = 0;
        1: 4109:    DebugLogAutoDisableFlags = ImGuiDebugLogFlags_None;
        1: 4110:    DebugLogAutoDisableFrames = 0;
        1: 4111:    DebugLocateFrames = 0;
        1: 4112:    DebugBeginReturnValueCullDepth = -1;
        1: 4113:    DebugItemPickerActive = false;
        1: 4114:    DebugItemPickerMouseButton = ImGuiMouseButton_Left;
        1: 4115:    DebugItemPickerBreakId = 0;
        1: 4116:    DebugFlashStyleColorTime = 0.0f;
        1: 4117:    DebugFlashStyleColorIdx = ImGuiCol_COUNT;
        1: 4118:    DebugHoveredDockNode = NULL;
        -: 4119:
        -: 4120:    // Same as DebugBreakClearData(). Those fields are scattered in their respective subsystem to stay in hot-data locations
        1: 4121:    DebugBreakInWindow = 0;
        1: 4122:    DebugBreakInTable = 0;
        1: 4123:    DebugBreakInLocateId = false;
        1: 4124:    DebugBreakKeyChord = ImGuiKey_Pause;
        1: 4125:    DebugBreakInShortcutRouting = ImGuiKey_None;
        -: 4126:
        1: 4127:    memset(FramerateSecPerFrame, 0, sizeof(FramerateSecPerFrame));
        1: 4128:    FramerateSecPerFrameIdx = FramerateSecPerFrameCount = 0;
        1: 4129:    FramerateSecPerFrameAccum = 0.0f;
        1: 4130:    WantCaptureMouseNextFrame = WantCaptureKeyboardNextFrame = WantTextInputNextFrame = -1;
        1: 4131:    memset(TempKeychordName, 0, sizeof(TempKeychordName));
        1: 4132:}
    $$$$$: 4132-block 112
call    0 never executed
    $$$$$: 4132-block 114
call    1 never executed
    $$$$$: 4132-block 116
call    2 never executed
    $$$$$: 4132-block 118
call    3 never executed
    $$$$$: 4132-block 120
call    4 never executed
    $$$$$: 4132-block 122
call    5 never executed
    $$$$$: 4132-block 124
call    6 never executed
    $$$$$: 4132-block 126
call    7 never executed
    $$$$$: 4132-block 128
call    8 never executed
    $$$$$: 4132-block 130
call    9 never executed
    $$$$$: 4132-block 132
call   10 never executed
    $$$$$: 4132-block 134
call   11 never executed
    $$$$$: 4132-block 136
call   12 never executed
    $$$$$: 4132-block 138
call   13 never executed
    $$$$$: 4132-block 140
call   14 never executed
    $$$$$: 4132-block 142
call   15 never executed
    $$$$$: 4132-block 144
call   16 never executed
    $$$$$: 4132-block 146
call   17 never executed
    $$$$$: 4132-block 148
call   18 never executed
    $$$$$: 4132-block 150
call   19 never executed
    $$$$$: 4132-block 152
call   20 never executed
    $$$$$: 4132-block 154
call   21 never executed
    $$$$$: 4132-block 156
call   22 never executed
    $$$$$: 4132-block 158
call   23 never executed
    $$$$$: 4132-block 160
call   24 never executed
    $$$$$: 4132-block 162
call   25 never executed
    $$$$$: 4132-block 164
call   26 never executed
    $$$$$: 4132-block 166
call   27 never executed
    $$$$$: 4132-block 168
call   28 never executed
    $$$$$: 4132-block 170
call   29 never executed
    $$$$$: 4132-block 172
call   30 never executed
    $$$$$: 4132-block 174
call   31 never executed
    $$$$$: 4132-block 176
call   32 never executed
    $$$$$: 4132-block 178
call   33 never executed
    $$$$$: 4132-block 180
call   34 never executed
    $$$$$: 4132-block 182
call   35 never executed
    $$$$$: 4132-block 184
call   36 never executed
    $$$$$: 4132-block 186
call   37 never executed
    $$$$$: 4132-block 188
call   38 never executed
    $$$$$: 4132-block 190
call   39 never executed
    $$$$$: 4132-block 192
call   40 never executed
    $$$$$: 4132-block 194
call   41 never executed
    $$$$$: 4132-block 196
call   42 never executed
    $$$$$: 4132-block 198
call   43 never executed
    $$$$$: 4132-block 200
call   44 never executed
    $$$$$: 4132-block 202
call   45 never executed
    $$$$$: 4132-block 204
call   46 never executed
    $$$$$: 4132-block 206
call   47 never executed
    $$$$$: 4132-block 208
call   48 never executed
        -: 4133:
function _ZN5ImGui10InitializeEv called 1 returned 100% blocks executed 87%
        1: 4134:void ImGui::Initialize()
        -: 4135:{
        1: 4136:    ImGuiContext& g = *GImGui;
       1*: 4137:    IM_ASSERT(!g.Initialized && !g.SettingsLoaded);
        1: 4137-block 2
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 4137-block 3
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1: 4137-block 4
    %%%%%: 4137-block 5
call    4 never executed
        -: 4138:
        -: 4139:    // Add .ini handle for ImGuiWindow and ImGuiTable types
        -: 4140:    {
        1: 4141:        ImGuiSettingsHandler ini_handler;
        1: 4141-block 6
call    0 returned 1
        1: 4142:        ini_handler.TypeName = "Window";
        1: 4143:        ini_handler.TypeHash = ImHashStr("Window");
call    0 returned 1
        1: 4144:        ini_handler.ClearAllFn = WindowSettingsHandler_ClearAll;
        1: 4145:        ini_handler.ReadOpenFn = WindowSettingsHandler_ReadOpen;
        1: 4146:        ini_handler.ReadLineFn = WindowSettingsHandler_ReadLine;
        1: 4147:        ini_handler.ApplyAllFn = WindowSettingsHandler_ApplyAll;
        1: 4148:        ini_handler.WriteAllFn = WindowSettingsHandler_WriteAll;
        1: 4149:        AddSettingsHandler(&ini_handler);
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -: 4150:    }
        1: 4151:    TableSettingsAddSettingsHandler();
        1: 4151-block 9
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -: 4152:
        -: 4153:    // Setup default localization table
        1: 4154:    LocalizeRegisterEntries(GLocalizationEntriesEnUS, IM_ARRAYSIZE(GLocalizationEntriesEnUS));
        1: 4154-block 10
call    0 returned 1
        -: 4155:
        -: 4156:    // Setup default ImGuiPlatformIO clipboard/IME handlers.
        1: 4157:    g.PlatformIO.Platform_GetClipboardTextFn = Platform_GetClipboardTextFn_DefaultImpl;    // Platform dependent default implementations
        1: 4158:    g.PlatformIO.Platform_SetClipboardTextFn = Platform_SetClipboardTextFn_DefaultImpl;
        1: 4159:    g.PlatformIO.Platform_OpenInShellFn = Platform_OpenInShellFn_DefaultImpl;
        1: 4160:    g.PlatformIO.Platform_SetImeDataFn = Platform_SetImeDataFn_DefaultImpl;
        -: 4161:
        -: 4162:    // Create default viewport
        1: 4163:    ImGuiViewportP* viewport = IM_NEW(ImGuiViewportP)();
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 4163-block 12
call    3 returned 1
call    4 returned 1
branch  5 taken 1 (fallthrough)
branch  6 taken 0 (throw)
    $$$$$: 4163-block 49
branch  7 never executed (fallthrough)
branch  8 never executed
    $$$$$: 4163-block 50
call    9 never executed
        1: 4164:    viewport->ID = IMGUI_VIEWPORT_DEFAULT_ID;
        1: 4165:    viewport->Idx = 0;
        1: 4166:    viewport->PlatformWindowCreated = true;
        1: 4167:    viewport->Flags = ImGuiViewportFlags_OwnedByApp;
        1: 4168:    g.Viewports.push_back(viewport);
        1: 4168-block 14
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 4169:    g.TempBuffer.resize(1024 * 3 + 1, 0);
        1: 4169-block 15
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
    $$$$$: 4169-block 52
        1: 4170:    g.ViewportCreatedCount++;
        1: 4171:    g.PlatformIO.Viewports.push_back(g.Viewports[0]);
        1: 4171-block 16
call    0 returned 1
call    1 returned 1
branch  2 taken 1 (fallthrough)
branch  3 taken 0 (throw)
    $$$$$: 4171-block 53
        -: 4172:
        -: 4173:    // Build KeysMayBeCharInput[] lookup table (1 bool per named key)
      155: 4174:    for (ImGuiKey key = ImGuiKey_NamedKey_BEGIN; key < ImGuiKey_NamedKey_END; key = (ImGuiKey)(key + 1))
        1: 4174-block 18
      154: 4174-block 44
      155: 4174-block 45
branch  0 taken 154
branch  1 taken 1 (fallthrough)
      154: 4175:        if ((key >= ImGuiKey_0 && key <= ImGuiKey_9) || (key >= ImGuiKey_A && key <= ImGuiKey_Z) || (key >= ImGuiKey_Keypad0 && key <= ImGuiKey_Keypad9)
      154: 4175-block 19
branch  0 taken 130 (fallthrough)
branch  1 taken 24
      130: 4175-block 20
branch  2 taken 120 (fallthrough)
branch  3 taken 10
      144: 4175-block 21
branch  4 taken 120 (fallthrough)
branch  5 taken 24
      120: 4175-block 22
branch  6 taken 94 (fallthrough)
branch  7 taken 26
      118: 4175-block 23
branch  8 taken 54 (fallthrough)
branch  9 taken 64
       54: 4175-block 24
branch 10 taken 44 (fallthrough)
branch 11 taken 10
      108: 4176:            || key == ImGuiKey_Tab || key == ImGuiKey_Space || key == ImGuiKey_Apostrophe || key == ImGuiKey_Comma || key == ImGuiKey_Minus || key == ImGuiKey_Period
      108: 4176-block 25
branch  0 taken 107 (fallthrough)
branch  1 taken 1
      107: 4176-block 26
branch  2 taken 106 (fallthrough)
branch  3 taken 1
      106: 4176-block 27
branch  4 taken 105 (fallthrough)
branch  5 taken 1
      105: 4176-block 28
branch  6 taken 104 (fallthrough)
branch  7 taken 1
      104: 4176-block 29
branch  8 taken 103 (fallthrough)
branch  9 taken 1
      103: 4176-block 30
branch 10 taken 102 (fallthrough)
branch 11 taken 1
      102: 4177:            || key == ImGuiKey_Slash || key == ImGuiKey_Semicolon || key == ImGuiKey_Equal || key == ImGuiKey_LeftBracket || key == ImGuiKey_RightBracket || key == ImGuiKey_GraveAccent
      102: 4177-block 31
branch  0 taken 101 (fallthrough)
branch  1 taken 1
      101: 4177-block 32
branch  2 taken 100 (fallthrough)
branch  3 taken 1
      100: 4177-block 33
branch  4 taken 99 (fallthrough)
branch  5 taken 1
       99: 4177-block 34
branch  6 taken 98 (fallthrough)
branch  7 taken 1
       98: 4177-block 35
branch  8 taken 97 (fallthrough)
branch  9 taken 1
       97: 4177-block 36
branch 10 taken 96 (fallthrough)
branch 11 taken 1
       96: 4178:            || key == ImGuiKey_KeypadDecimal || key == ImGuiKey_KeypadDivide || key == ImGuiKey_KeypadMultiply || key == ImGuiKey_KeypadSubtract || key == ImGuiKey_KeypadAdd || key == ImGuiKey_KeypadEqual)
       96: 4178-block 37
branch  0 taken 95 (fallthrough)
branch  1 taken 1
       95: 4178-block 38
branch  2 taken 94 (fallthrough)
branch  3 taken 1
       94: 4178-block 39
branch  4 taken 93 (fallthrough)
branch  5 taken 1
       93: 4178-block 40
branch  6 taken 92 (fallthrough)
branch  7 taken 1
       92: 4178-block 41
branch  8 taken 91 (fallthrough)
branch  9 taken 1
       91: 4178-block 42
branch 10 taken 1 (fallthrough)
branch 11 taken 90
       64: 4179:            g.KeysMayBeCharInput.SetBit(key);
       64: 4179-block 43
call    0 returned 64
        -: 4180:
        -: 4181:#ifdef IMGUI_HAS_DOCK
        -: 4182:    // Initialize Docking
        1: 4183:    DockContextInitialize(&g);
        1: 4183-block 46
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -: 4184:#endif
        -: 4185:
        1: 4186:    g.Initialized = true;
        1: 4187:}
        1: 4187-block 47
        -: 4188:
        -: 4189:// This function is merely here to free heap allocations.
function _ZN5ImGui8ShutdownEv called 1 returned 100% blocks executed 78%
        1: 4190:void ImGui::Shutdown()
        -: 4191:{
        1: 4192:    ImGuiContext& g = *GImGui;
       1*: 4193:    IM_ASSERT_USER_ERROR(g.IO.BackendPlatformUserData == NULL, "Forgot to shutdown Platform backend?");
        1: 4193-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 4193-block 3
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 4193-block 5
        1: 4193-block 6
        1: 4193-block 7
branch  5 taken 0 (fallthrough)
branch  6 taken 1
    %%%%%: 4193-block 8
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 4193-block 9
call    9 never executed
       1*: 4194:    IM_ASSERT_USER_ERROR(g.IO.BackendRendererUserData == NULL, "Forgot to shutdown Renderer backend?");
        1: 4194-block 10
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 4194-block 11
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 4194-block 13
        1: 4194-block 14
        1: 4194-block 15
branch  5 taken 0 (fallthrough)
branch  6 taken 1
    %%%%%: 4194-block 16
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 4194-block 17
call    9 never executed
        -: 4195:
        -: 4196:    // The fonts atlas can be used prior to calling NewFrame(), so we clear it even if g.Initialized is FALSE (which would happen if we never called NewFrame)
        1: 4197:    if (g.IO.Fonts && g.FontAtlasOwnedByContext)
        1: 4197-block 18
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 4197-block 19
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        -: 4198:    {
        1: 4199:        g.IO.Fonts->Locked = false;
        1: 4200:        IM_DELETE(g.IO.Fonts);
        1: 4200-block 20
call    0 returned 1
        -: 4201:    }
        1: 4202:    g.IO.Fonts = NULL;
        1: 4203:    g.DrawListSharedData.TempBuffer.clear();
        1: 4203-block 21
call    0 returned 1
        -: 4204:
        -: 4205:    // Cleanup of other data are conditional on actually having initialized Dear ImGui.
        1: 4206:    if (!g.Initialized)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 4207:        return;
    %%%%%: 4207-block 23
        -: 4208:
        -: 4209:    // Save settings (unless we haven't attempted to load them: CreateContext/DestroyContext without a call to NewFrame shouldn't save an empty file)
        1: 4210:    if (g.SettingsLoaded && g.IO.IniFilename != NULL)
        1: 4210-block 24
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 4210-block 25
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1: 4211:        SaveIniSettingsToDisk(g.IO.IniFilename);
        1: 4211-block 26
call    0 returned 1
        -: 4212:
        -: 4213:    // Destroy platform windows
        1: 4214:    DestroyPlatformWindows();
        1: 4214-block 27
call    0 returned 1
        -: 4215:
        -: 4216:    // Shutdown extensions
        1: 4217:    DockContextShutdown(&g);
call    0 returned 1
        -: 4218:
        1: 4219:    CallContextHooks(&g, ImGuiContextHookType_Shutdown);
call    0 returned 1
        -: 4220:
        -: 4221:    // Clear everything else
        1: 4222:    g.Windows.clear_delete();
call    0 returned 1
        1: 4223:    g.WindowsFocusOrder.clear();
call    0 returned 1
        1: 4224:    g.WindowsTempSortBuffer.clear();
call    0 returned 1
        1: 4225:    g.CurrentWindow = NULL;
        1: 4226:    g.CurrentWindowStack.clear();
call    0 returned 1
        1: 4227:    g.WindowsById.Clear();
call    0 returned 1
        1: 4228:    g.NavWindow = NULL;
        1: 4229:    g.HoveredWindow = g.HoveredWindowUnderMovingWindow = NULL;
        1: 4230:    g.ActiveIdWindow = g.ActiveIdPreviousFrameWindow = NULL;
        1: 4231:    g.MovingWindow = NULL;
        -: 4232:
        1: 4233:    g.KeysRoutingTable.Clear();
call    0 returned 1
        -: 4234:
        1: 4235:    g.ColorStack.clear();
call    0 returned 1
        1: 4236:    g.StyleVarStack.clear();
call    0 returned 1
        1: 4237:    g.FontStack.clear();
call    0 returned 1
        1: 4238:    g.OpenPopupStack.clear();
call    0 returned 1
        1: 4239:    g.BeginPopupStack.clear();
call    0 returned 1
        1: 4240:    g.TreeNodeStack.clear();
call    0 returned 1
        -: 4241:
        1: 4242:    g.CurrentViewport = g.MouseViewport = g.MouseLastHoveredViewport = NULL;
        1: 4243:    g.Viewports.clear_delete();
call    0 returned 1
        -: 4244:
        1: 4245:    g.TabBars.Clear();
call    0 returned 1
        1: 4246:    g.CurrentTabBarStack.clear();
call    0 returned 1
        1: 4247:    g.ShrinkWidthBuffer.clear();
call    0 returned 1
        -: 4248:
        1: 4249:    g.ClipperTempData.clear_destruct();
call    0 returned 1
        -: 4250:
        1: 4251:    g.Tables.Clear();
call    0 returned 1
        1: 4252:    g.TablesTempData.clear_destruct();
call    0 returned 1
        1: 4253:    g.DrawChannelsTempMergeBuffer.clear();
call    0 returned 1
        -: 4254:
        1: 4255:    g.MultiSelectStorage.Clear();
call    0 returned 1
        1: 4256:    g.MultiSelectTempData.clear_destruct();
call    0 returned 1
        -: 4257:
        1: 4258:    g.ClipboardHandlerData.clear();
call    0 returned 1
        1: 4259:    g.MenusIdSubmittedThisFrame.clear();
call    0 returned 1
        1: 4260:    g.InputTextState.ClearFreeMemory();
call    0 returned 1
        1: 4261:    g.InputTextDeactivatedState.ClearFreeMemory();
call    0 returned 1
        -: 4262:
        1: 4263:    g.SettingsWindows.clear();
call    0 returned 1
        1: 4264:    g.SettingsHandlers.clear();
call    0 returned 1
        -: 4265:
        1: 4266:    if (g.LogFile)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 4267:    {
        -: 4268:#ifndef IMGUI_DISABLE_TTY_FUNCTIONS
    #####: 4269:        if (g.LogFile != stdout)
    %%%%%: 4269-block 59
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4270:#endif
    #####: 4271:            ImFileClose(g.LogFile);
    %%%%%: 4271-block 60
call    0 never executed
    #####: 4272:        g.LogFile = NULL;
    %%%%%: 4272-block 61
        -: 4273:    }
        1: 4274:    g.LogBuffer.clear();
        1: 4274-block 62
call    0 returned 1
        1: 4275:    g.DebugLogBuf.clear();
call    0 returned 1
        1: 4276:    g.DebugLogIndex.clear();
call    0 returned 1
        -: 4277:
        1: 4278:    g.Initialized = false;
        -: 4279:}
        -: 4280:
        -: 4281:// No specific ordering/dependency support, will see as needed
function _ZN5ImGui14AddContextHookEP12ImGuiContextPK16ImGuiContextHook called 0 returned 0% blocks executed 0%
    #####: 4282:ImGuiID ImGui::AddContextHook(ImGuiContext* ctx, const ImGuiContextHook* hook)
        -: 4283:{
    #####: 4284:    ImGuiContext& g = *ctx;
    #####: 4285:    IM_ASSERT(hook->Callback != NULL && hook->HookId == 0 && hook->Type != ImGuiContextHookType_PendingRemoval_);
    %%%%%: 4285-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4285-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4285-block 4
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 4285-block 5
    %%%%%: 4285-block 6
call    6 never executed
    #####: 4286:    g.Hooks.push_back(*hook);
    %%%%%: 4286-block 7
call    0 never executed
    #####: 4287:    g.Hooks.back().HookId = ++g.HookIdNext;
call    0 never executed
    #####: 4288:    return g.HookIdNext;
        -: 4289:}
        -: 4290:
        -: 4291:// Deferred removal, avoiding issue with changing vector while iterating it
function _ZN5ImGui17RemoveContextHookEP12ImGuiContextj called 0 returned 0% blocks executed 0%
    #####: 4292:void ImGui::RemoveContextHook(ImGuiContext* ctx, ImGuiID hook_id)
        -: 4293:{
    #####: 4294:    ImGuiContext& g = *ctx;
    #####: 4295:    IM_ASSERT(hook_id != 0);
    %%%%%: 4295-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4295-block 3
call    2 never executed
    #####: 4296:    for (ImGuiContextHook& hook : g.Hooks)
    %%%%%: 4296-block 4
call    0 never executed
call    1 never executed
    %%%%%: 4296-block 8
    %%%%%: 4296-block 9
branch  2 never executed
branch  3 never executed (fallthrough)
    #####: 4297:        if (hook.HookId == hook_id)
    %%%%%: 4297-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4298:            hook.Type = ImGuiContextHookType_PendingRemoval_;
    %%%%%: 4298-block 7
    #####: 4299:}
        -: 4300:
        -: 4301:// Call context hooks (used by e.g. test engine)
        -: 4302:// We assume a small number of hooks so all stored in same array
function _ZN5ImGui16CallContextHooksEP12ImGuiContext20ImGuiContextHookType called 6463 returned 100% blocks executed 57%
     6463: 4303:void ImGui::CallContextHooks(ImGuiContext* ctx, ImGuiContextHookType hook_type)
        -: 4304:{
     6463: 4305:    ImGuiContext& g = *ctx;
    6463*: 4306:    for (ImGuiContextHook& hook : g.Hooks)
     6463: 4306-block 2
call    0 returned 6463
call    1 returned 6463
    %%%%%: 4306-block 6
     6463: 4306-block 7
branch  2 taken 0
branch  3 taken 6463 (fallthrough)
    #####: 4307:        if (hook.Type == hook_type)
    %%%%%: 4307-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4308:            hook.Callback(&g, &hook);
    %%%%%: 4308-block 5
call    0 never executed
     6463: 4309:}
        -: 4310:
        -: 4311:
        -: 4312://-----------------------------------------------------------------------------
        -: 4313:// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)
        -: 4314://-----------------------------------------------------------------------------
        -: 4315:
        -: 4316:// ImGuiWindow is mostly a dumb struct. It merely has a constructor and a few helper methods
function _ZN11ImGuiWindowC2EP12ImGuiContextPKc called 16 returned 100% blocks executed 84%
       16: 4317:ImGuiWindow::ImGuiWindow(ImGuiContext* ctx, const char* name) : DrawListInst(NULL)
       16: 4317-block 2
call    0 returned 16
call    1 returned 16
call    2 returned 16
call    3 returned 16
call    4 returned 16
call    5 returned 16
call    6 returned 16
call    7 returned 16
call    8 returned 16
call    9 returned 16
call   10 returned 16
call   11 returned 16
call   12 returned 16
call   13 returned 16
call   14 returned 16
call   15 returned 16
call   16 returned 16
call   17 returned 16
call   18 returned 16
branch 19 taken 16 (fallthrough)
branch 20 taken 0 (throw)
       16: 4317-block 21
call   21 returned 16
call   22 returned 16
call   23 returned 16
call   24 returned 16
call   25 returned 16
call   26 returned 16
call   27 returned 16
call   28 returned 16
call   29 returned 16
call   30 returned 16
branch 31 taken 16 (fallthrough)
branch 32 taken 0 (throw)
       16: 4317-block 31
call   33 returned 16
call   34 returned 16
branch 35 taken 16 (fallthrough)
branch 36 taken 0 (throw)
       16: 4317-block 33
call   37 returned 16
        -: 4318:{
       16: 4319:    memset(this, 0, sizeof(*this));
       16: 4320:    Ctx = ctx;
       16: 4321:    Name = ImStrdup(name);
call    0 returned 16
branch  1 taken 16 (fallthrough)
branch  2 taken 0 (throw)
       16: 4322:    NameBufLen = (int)strlen(name) + 1;
       16: 4323:    ID = ImHashStr(name);
       16: 4323-block 35
call    0 returned 16
       16: 4324:    IDStack.push_back(ID);
call    0 returned 16
branch  1 taken 16 (fallthrough)
branch  2 taken 0 (throw)
       16: 4325:    ViewportAllowPlatformMonitorExtend = -1;
       16: 4326:    ViewportPos = ImVec2(FLT_MAX, FLT_MAX);
       16: 4326-block 37
call    0 returned 16
       16: 4327:    MoveId = GetID("#MOVE");
call    0 returned 16
branch  1 taken 16 (fallthrough)
branch  2 taken 0 (throw)
       16: 4328:    TabId = GetID("#TAB");
       16: 4328-block 39
call    0 returned 16
branch  1 taken 16 (fallthrough)
branch  2 taken 0 (throw)
       16: 4329:    ScrollTarget = ImVec2(FLT_MAX, FLT_MAX);
       16: 4329-block 40
call    0 returned 16
       16: 4330:    ScrollTargetCenterRatio = ImVec2(0.5f, 0.5f);
call    0 returned 16
       16: 4331:    AutoFitFramesX = AutoFitFramesY = -1;
       16: 4332:    AutoPosLastDirection = ImGuiDir_None;
       16: 4333:    SetWindowPosAllowFlags = SetWindowSizeAllowFlags = SetWindowCollapsedAllowFlags = SetWindowDockAllowFlags = 0;
       16: 4334:    SetWindowPosVal = SetWindowPosPivot = ImVec2(FLT_MAX, FLT_MAX);
call    0 returned 16
       16: 4335:    LastFrameActive = -1;
       16: 4336:    LastFrameJustFocused = -1;
       16: 4337:    LastTimeActive = -1.0f;
       16: 4338:    FontWindowScale = FontDpiScale = 1.0f;
       16: 4339:    SettingsOffset = -1;
       16: 4340:    DockOrder = -1;
       16: 4341:    DrawList = &DrawListInst;
       16: 4342:    DrawList->_Data = &Ctx->DrawListSharedData;
       16: 4343:    DrawList->_OwnerName = Name;
       16: 4344:    NavPreferredScoringPosRel[0] = NavPreferredScoringPosRel[1] = ImVec2(FLT_MAX, FLT_MAX);
call    0 returned 16
       16: 4345:    IM_PLACEMENT_NEW(&WindowClass) ImGuiWindowClass();
call    0 returned 16
call    1 returned 16
       16: 4346:}
    $$$$$: 4346-block 47
call    0 never executed
    $$$$$: 4346-block 49
call    1 never executed
    $$$$$: 4346-block 51
call    2 never executed
    $$$$$: 4346-block 53
call    3 never executed
    $$$$$: 4346-block 55
call    4 never executed
        -: 4347:
function _ZN11ImGuiWindowD2Ev called 16 returned 100% blocks executed 90%
       16: 4348:ImGuiWindow::~ImGuiWindow()
        -: 4349:{
      16*: 4350:    IM_ASSERT(DrawList == &DrawListInst);
       16: 4350-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 16
    %%%%%: 4350-block 3
call    2 never executed
       16: 4351:    IM_DELETE(Name);
       16: 4351-block 4
call    0 returned 16
       16: 4352:    ColumnsStorage.clear_destruct();
call    0 returned 16
       16: 4353:}
call    0 returned 16
call    1 returned 16
call    2 returned 16
call    3 returned 16
call    4 returned 16
        -: 4354:
function _ZL16SetCurrentWindowP11ImGuiWindow called 34890 returned 100% blocks executed 85%
    34890: 4355:static void SetCurrentWindow(ImGuiWindow* window)
        -: 4356:{
    34890: 4357:    ImGuiContext& g = *GImGui;
    34890: 4358:    g.CurrentWindow = window;
    34890: 4359:    g.StackSizesInBeginForCurrentWindow = g.CurrentWindow ? &g.CurrentWindowStack.back().StackSizesInBegin : NULL;
    34890: 4359-block 2
branch  0 taken 33813 (fallthrough)
branch  1 taken 1077
    33813: 4359-block 3
call    2 returned 33813
     1077: 4359-block 5
   34890*: 4360:    g.CurrentTable = window && window->DC.CurrentTableIdx != -1 ? g.Tables.GetByIndex(window->DC.CurrentTableIdx) : NULL;
    34890: 4360-block 6
branch  0 taken 33813 (fallthrough)
branch  1 taken 1077
    33813: 4360-block 7
branch  2 taken 0 (fallthrough)
branch  3 taken 33813
    %%%%%: 4360-block 8
call    4 never executed
    34890: 4360-block 10
    34890: 4361:    if (window)
    34890: 4361-block 11
branch  0 taken 33813 (fallthrough)
branch  1 taken 1077
        -: 4362:    {
    33813: 4363:        g.FontSize = g.DrawListSharedData.FontSize = window->CalcFontSize();
    33813: 4363-block 12
call    0 returned 33813
    33813: 4364:        g.FontScale = g.DrawListSharedData.FontScale = g.FontSize / g.Font->FontSize;
    33813: 4365:        ImGui::NavUpdateCurrentWindowIsScrollPushableX();
call    0 returned 33813
        -: 4366:    }
    34890: 4367:}
        -: 4368:
function _ZN5ImGui29GcCompactTransientMiscBuffersEv called 0 returned 0% blocks executed 0%
    #####: 4369:void ImGui::GcCompactTransientMiscBuffers()
        -: 4370:{
    #####: 4371:    ImGuiContext& g = *GImGui;
    #####: 4372:    g.ItemFlagsStack.clear();
    %%%%%: 4372-block 2
call    0 never executed
    #####: 4373:    g.GroupStack.clear();
call    0 never executed
    #####: 4374:    g.MultiSelectTempDataStacked = 0;
    #####: 4375:    g.MultiSelectTempData.clear_destruct();
call    0 never executed
    #####: 4376:    TableGcCompactSettings();
call    0 never executed
    #####: 4377:}
        -: 4378:
        -: 4379:// Free up/compact internal window buffers, we can use this when a window becomes unused.
        -: 4380:// Not freed:
        -: 4381:// - ImGuiWindow, ImGuiWindowSettings, Name, StateStorage, ColumnsStorage (may hold useful data)
        -: 4382:// This should have no noticeable visual effect. When the window reappear however, expect new allocation/buffer growth/copy cost.
function _ZN5ImGui31GcCompactTransientWindowBuffersEP11ImGuiWindow called 0 returned 0% blocks executed 0%
    #####: 4383:void ImGui::GcCompactTransientWindowBuffers(ImGuiWindow* window)
        -: 4384:{
    #####: 4385:    window->MemoryCompacted = true;
    #####: 4386:    window->MemoryDrawListIdxCapacity = window->DrawList->IdxBuffer.Capacity;
    #####: 4387:    window->MemoryDrawListVtxCapacity = window->DrawList->VtxBuffer.Capacity;
    #####: 4388:    window->IDStack.clear();
    %%%%%: 4388-block 2
call    0 never executed
    #####: 4389:    window->DrawList->_ClearFreeMemory();
call    0 never executed
    #####: 4390:    window->DC.ChildWindows.clear();
call    0 never executed
    #####: 4391:    window->DC.ItemWidthStack.clear();
call    0 never executed
    #####: 4392:    window->DC.TextWrapPosStack.clear();
call    0 never executed
    #####: 4393:}
        -: 4394:
function _ZN5ImGui29GcAwakeTransientWindowBuffersEP11ImGuiWindow called 0 returned 0% blocks executed 0%
    #####: 4395:void ImGui::GcAwakeTransientWindowBuffers(ImGuiWindow* window)
        -: 4396:{
        -: 4397:    // We stored capacity of the ImDrawList buffer to reduce growth-caused allocation/copy when awakening.
        -: 4398:    // The other buffers tends to amortize much faster.
    #####: 4399:    window->MemoryCompacted = false;
    #####: 4400:    window->DrawList->IdxBuffer.reserve(window->MemoryDrawListIdxCapacity);
    %%%%%: 4400-block 2
call    0 never executed
    #####: 4401:    window->DrawList->VtxBuffer.reserve(window->MemoryDrawListVtxCapacity);
call    0 never executed
    #####: 4402:    window->MemoryDrawListIdxCapacity = window->MemoryDrawListVtxCapacity = 0;
    #####: 4403:}
        -: 4404:
function _ZN5ImGui11SetActiveIDEjP11ImGuiWindow called 12 returned 100% blocks executed 48%
       12: 4405:void ImGui::SetActiveID(ImGuiID id, ImGuiWindow* window)
        -: 4406:{
       12: 4407:    ImGuiContext& g = *GImGui;
        -: 4408:
        -: 4409:    // Clear previous active id
       12: 4410:    if (g.ActiveId != 0)
       12: 4410-block 2
branch  0 taken 6 (fallthrough)
branch  1 taken 6
        -: 4411:    {
        -: 4412:        // While most behaved code would make an effort to not steal active id during window move/drag operations,
        -: 4413:        // we at least need to be resilient to it. Canceling the move is rather aggressive and users of 'master' branch
        -: 4414:        // may prefer the weird ill-defined half working situation ('docking' did assert), so may need to rework that.
       6*: 4415:        if (g.MovingWindow != NULL && g.ActiveId == g.MovingWindow->MoveId)
        6: 4415-block 3
branch  0 taken 0 (fallthrough)
branch  1 taken 6
    %%%%%: 4415-block 4
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 4416:        {
    #####: 4417:            IMGUI_DEBUG_LOG_ACTIVEID("SetActiveID() cancel MovingWindow\n");
    %%%%%: 4417-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4417-block 6
call    2 never executed
    #####: 4418:            g.MovingWindow = NULL;
    %%%%%: 4418-block 7
        -: 4419:        }
        -: 4420:
        -: 4421:        // This could be written in a more general way (e.g associate a hook to ActiveId),
        -: 4422:        // but since this is currently quite an exception we'll leave it as is.
        -: 4423:        // One common scenario leading to this is: pressing Key ->NavMoveRequestApplyResult() -> ClearActiveId()
        6: 4424:        if (g.InputTextState.ID == g.ActiveId)
        6: 4424-block 8
branch  0 taken 0 (fallthrough)
branch  1 taken 6
    #####: 4425:            InputTextDeactivateHook(g.ActiveId);
    %%%%%: 4425-block 9
call    0 never executed
        -: 4426:    }
        -: 4427:
        -: 4428:    // Set active id
       12: 4429:    g.ActiveIdIsJustActivated = (g.ActiveId != id);
       12: 4430:    if (g.ActiveIdIsJustActivated)
       12: 4430-block 10
branch  0 taken 12 (fallthrough)
branch  1 taken 0
        -: 4431:    {
      12*: 4432:        IMGUI_DEBUG_LOG_ACTIVEID("SetActiveID() old:0x%08X (window \"%s\") -> new:0x%08X (window \"%s\")\n", g.ActiveId, g.ActiveIdWindow ? g.ActiveIdWindow->Name : "", id, window ? window->Name : "");
       12: 4432-block 11
branch  0 taken 0 (fallthrough)
branch  1 taken 12
    %%%%%: 4432-block 12
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4432-block 13
    %%%%%: 4432-block 14
    %%%%%: 4432-block 15
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 4432-block 16
    %%%%%: 4432-block 17
    %%%%%: 4432-block 18
call    6 never executed
       12: 4433:        g.ActiveIdTimer = 0.0f;
       12: 4434:        g.ActiveIdHasBeenPressedBefore = false;
       12: 4435:        g.ActiveIdHasBeenEditedBefore = false;
       12: 4436:        g.ActiveIdMouseButton = -1;
       12: 4437:        if (id != 0)
       12: 4437-block 19
branch  0 taken 6 (fallthrough)
branch  1 taken 6
        -: 4438:        {
        6: 4439:            g.LastActiveId = id;
        6: 4440:            g.LastActiveIdTimer = 0.0f;
        6: 4440-block 20
        -: 4441:        }
        -: 4442:    }
       12: 4443:    g.ActiveId = id;
       12: 4444:    g.ActiveIdAllowOverlap = false;
       12: 4445:    g.ActiveIdNoClearOnFocusLoss = false;
       12: 4446:    g.ActiveIdWindow = window;
       12: 4447:    g.ActiveIdHasBeenEditedThisFrame = false;
       12: 4448:    g.ActiveIdFromShortcut = false;
       12: 4449:    if (id)
       12: 4449-block 21
branch  0 taken 6 (fallthrough)
branch  1 taken 6
        -: 4450:    {
        6: 4451:        g.ActiveIdIsAlive = id;
       6*: 4452:        g.ActiveIdSource = (g.NavActivateId == id || g.NavJustMovedToId == id) ? g.NavInputSource : ImGuiInputSource_Mouse;
        6: 4452-block 22
branch  0 taken 6 (fallthrough)
branch  1 taken 0
        6: 4452-block 23
branch  2 taken 0 (fallthrough)
branch  3 taken 6
    %%%%%: 4452-block 24
        6: 4452-block 25
       6*: 4453:        IM_ASSERT(g.ActiveIdSource != ImGuiInputSource_None);
        6: 4453-block 26
branch  0 taken 0 (fallthrough)
branch  1 taken 6
    %%%%%: 4453-block 27
call    2 never executed
        -: 4454:    }
        -: 4455:
        -: 4456:    // Clear declaration of inputs claimed by the widget
        -: 4457:    // (Please note that this is WIP and not all keys/inputs are thoroughly declared by all widgets yet)
       12: 4458:    g.ActiveIdUsingNavDirMask = 0x00;
       12: 4459:    g.ActiveIdUsingAllKeyboardKeys = false;
       12: 4460:}
        -: 4461:
function _ZN5ImGui13ClearActiveIDEv called 6 returned 100% blocks executed 100%
        6: 4462:void ImGui::ClearActiveID()
        -: 4463:{
        6: 4464:    SetActiveID(0, NULL); // g.ActiveId = 0;
        6: 4464-block 2
call    0 returned 6
        6: 4465:}
        -: 4466:
function _ZN5ImGui12SetHoveredIDEj called 212 returned 100% blocks executed 100%
      212: 4467:void ImGui::SetHoveredID(ImGuiID id)
        -: 4468:{
      212: 4469:    ImGuiContext& g = *GImGui;
      212: 4470:    g.HoveredId = id;
      212: 4471:    g.HoveredIdAllowOverlap = false;
      212: 4472:    if (id != 0 && g.HoveredIdPreviousFrame != id)
      212: 4472-block 2
branch  0 taken 212 (fallthrough)
branch  1 taken 0
      212: 4472-block 3
branch  2 taken 10 (fallthrough)
branch  3 taken 202
       10: 4473:        g.HoveredIdTimer = g.HoveredIdNotActiveTimer = 0.0f;
       10: 4473-block 4
      212: 4474:}
        -: 4475:
function _ZN5ImGui12GetHoveredIDEv called 0 returned 0% blocks executed 0%
    #####: 4476:ImGuiID ImGui::GetHoveredID()
        -: 4477:{
    #####: 4478:    ImGuiContext& g = *GImGui;
    #####: 4479:    return g.HoveredId ? g.HoveredId : g.HoveredIdPreviousFrame;
    %%%%%: 4479-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4479-block 3
    %%%%%: 4479-block 4
    %%%%%: 4479-block 5
        -: 4480:}
        -: 4481:
function _ZN5ImGui14MarkItemEditedEj called 0 returned 0% blocks executed 0%
    #####: 4482:void ImGui::MarkItemEdited(ImGuiID id)
        -: 4483:{
        -: 4484:    // This marking is to be able to provide info for IsItemDeactivatedAfterEdit().
        -: 4485:    // ActiveId might have been released by the time we call this (as in the typical press/release button behavior) but still need to fill the data.
    #####: 4486:    ImGuiContext& g = *GImGui;
    #####: 4487:    if (g.LastItemData.ItemFlags & ImGuiItemFlags_NoMarkEdited)
    %%%%%: 4487-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4488:        return;
    %%%%%: 4488-block 3
    #####: 4489:    if (g.ActiveId == id || g.ActiveId == 0)
    %%%%%: 4489-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4489-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 4490:    {
    #####: 4491:        g.ActiveIdHasBeenEditedThisFrame = true;
    #####: 4492:        g.ActiveIdHasBeenEditedBefore = true;
    %%%%%: 4492-block 6
        -: 4493:    }
        -: 4494:
        -: 4495:    // We accept a MarkItemEdited() on drag and drop targets (see https://github.com/ocornut/imgui/issues/1875#issuecomment-978243343)
        -: 4496:    // We accept 'ActiveIdPreviousFrame == id' for InputText() returning an edit after it has been taken ActiveId away (#4714)
    #####: 4497:    IM_ASSERT(g.DragDropActive || g.ActiveId == id || g.ActiveId == 0 || g.ActiveIdPreviousFrame == id || (g.CurrentMultiSelect != NULL && g.BoxSelectState.IsActive));
    %%%%%: 4497-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4497-block 8
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4497-block 9
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 4497-block 10
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 4497-block 11
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%: 4497-block 12
branch 10 never executed (fallthrough)
branch 11 never executed
    %%%%%: 4497-block 13
    %%%%%: 4497-block 14
call   12 never executed
        -: 4498:
        -: 4499:    //IM_ASSERT(g.CurrentWindow->DC.LastItemId == id);
    #####: 4500:    g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_Edited;
    %%%%%: 4500-block 15
        -: 4501:}
        -: 4502:
function _ZN5ImGui24IsWindowContentHoverableEP11ImGuiWindowi called 1423 returned 100% blocks executed 37%
     1423: 4503:bool ImGui::IsWindowContentHoverable(ImGuiWindow* window, ImGuiHoveredFlags flags)
        -: 4504:{
        -: 4505:    // An active popup disable hovering on other windows (apart from its own children)
        -: 4506:    // FIXME-OPT: This could be cached/stored within the window.
     1423: 4507:    ImGuiContext& g = *GImGui;
     1423: 4508:    if (g.NavWindow)
     1423: 4508-block 2
branch  0 taken 1423 (fallthrough)
branch  1 taken 0
     1423: 4509:        if (ImGuiWindow* focused_root_window = g.NavWindow->RootWindowDockTree)
     1423: 4509-block 3
branch  0 taken 1423 (fallthrough)
branch  1 taken 0
     1423: 4510:            if (focused_root_window->WasActive && focused_root_window != window->RootWindowDockTree)
     1423: 4510-block 4
branch  0 taken 1423 (fallthrough)
branch  1 taken 0
     1423: 4510-block 5
branch  2 taken 0 (fallthrough)
branch  3 taken 1423
        -: 4511:            {
        -: 4512:                // For the purpose of those flags we differentiate "standard popup" from "modal popup"
        -: 4513:                // NB: The 'else' is important because Modal windows are also Popups.
    #####: 4514:                bool want_inhibit = false;
    #####: 4515:                if (focused_root_window->Flags & ImGuiWindowFlags_Modal)
    %%%%%: 4515-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4516:                    want_inhibit = true;
    %%%%%: 4516-block 7
    #####: 4517:                else if ((focused_root_window->Flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiHoveredFlags_AllowWhenBlockedByPopup))
    %%%%%: 4517-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4517-block 9
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4518:                    want_inhibit = true;
    %%%%%: 4518-block 10
        -: 4519:
        -: 4520:                // Inhibit hover unless the window is within the stack of our modal/popup
    #####: 4521:                if (want_inhibit)
    %%%%%: 4521-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4522:                    if (!IsWindowWithinBeginStackOf(window->RootWindow, focused_root_window))
    %%%%%: 4522-block 12
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 4523:                        return false;
    %%%%%: 4523-block 14
        -: 4524:            }
        -: 4525:
        -: 4526:    // Filter by viewport
     1423: 4527:    if (window->Viewport != g.MouseViewport)
     1423: 4527-block 15
branch  0 taken 0 (fallthrough)
branch  1 taken 1423
    #####: 4528:        if (g.MovingWindow == NULL || window->RootWindowDockTree != g.MovingWindow->RootWindowDockTree)
    %%%%%: 4528-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4528-block 17
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4529:            return false;
    %%%%%: 4529-block 18
        -: 4530:
     1423: 4531:    return true;
     1423: 4531-block 19
        -: 4532:}
        -: 4533:
function _ZL25CalcDelayFromHoveredFlagsi called 213 returned 100% blocks executed 67%
      213: 4534:static inline float CalcDelayFromHoveredFlags(ImGuiHoveredFlags flags)
        -: 4535:{
      213: 4536:    ImGuiContext& g = *GImGui;
      213: 4537:    if (flags & ImGuiHoveredFlags_DelayNormal)
      213: 4537-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 213
    #####: 4538:        return g.Style.HoverDelayNormal;
    %%%%%: 4538-block 3
      213: 4539:    if (flags & ImGuiHoveredFlags_DelayShort)
      213: 4539-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 213
    #####: 4540:        return g.Style.HoverDelayShort;
    %%%%%: 4540-block 5
      213: 4541:    return 0.0f;
      213: 4541-block 6
        -: 4542:}
        -: 4543:
function _ZL25ApplyHoverFlagsForTooltipii called 0 returned 0% blocks executed 0%
    #####: 4544:static ImGuiHoveredFlags ApplyHoverFlagsForTooltip(ImGuiHoveredFlags user_flags, ImGuiHoveredFlags shared_flags)
        -: 4545:{
        -: 4546:    // Allow instance flags to override shared flags
    #####: 4547:    if (user_flags & (ImGuiHoveredFlags_DelayNone | ImGuiHoveredFlags_DelayShort | ImGuiHoveredFlags_DelayNormal))
    %%%%%: 4547-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4548:        shared_flags &= ~(ImGuiHoveredFlags_DelayNone | ImGuiHoveredFlags_DelayShort | ImGuiHoveredFlags_DelayNormal);
    %%%%%: 4548-block 3
    #####: 4549:    return user_flags | shared_flags;
    %%%%%: 4549-block 4
        -: 4550:}
        -: 4551:
        -: 4552:// This is roughly matching the behavior of internal-facing ItemHoverable()
        -: 4553:// - we allow hovering to be true when ActiveId==window->MoveID, so that clicking on non-interactive items such as a Text() item still returns true with IsItemHovered()
        -: 4554:// - this should work even for non-interactive items that have no ID, so we cannot use LastItemId
function _ZN5ImGui13IsItemHoveredEi called 818178 returned 100% blocks executed 33%
   818178: 4555:bool ImGui::IsItemHovered(ImGuiHoveredFlags flags)
        -: 4556:{
   818178: 4557:    ImGuiContext& g = *GImGui;
   818178: 4558:    ImGuiWindow* window = g.CurrentWindow;
  818178*: 4559:    IM_ASSERT_USER_ERROR((flags & ~ImGuiHoveredFlags_AllowedMaskForIsItemHovered) == 0, "Invalid flags for IsItemHovered()!");
   818178: 4559-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 818178
    %%%%%: 4559-block 3
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 4559-block 5
   818178: 4559-block 6
   818178: 4559-block 7
branch  5 taken 0 (fallthrough)
branch  6 taken 818178
    %%%%%: 4559-block 8
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 4559-block 9
call    9 never executed
        -: 4560:
  818178*: 4561:    if (g.NavHighlightItemUnderNav && g.NavCursorVisible && !(flags & ImGuiHoveredFlags_NoNavOverride))
   818178: 4561-block 10
branch  0 taken 0 (fallthrough)
branch  1 taken 818178
    %%%%%: 4561-block 11
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4561-block 12
branch  4 never executed (fallthrough)
branch  5 never executed
        -: 4562:    {
    #####: 4563:        if (!IsItemFocused())
    %%%%%: 4563-block 13
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 4564:            return false;
    %%%%%: 4564-block 15
    #####: 4565:        if ((g.LastItemData.ItemFlags & ImGuiItemFlags_Disabled) && !(flags & ImGuiHoveredFlags_AllowWhenDisabled))
    %%%%%: 4565-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4565-block 17
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4566:            return false;
    %%%%%: 4566-block 18
        -: 4567:
    #####: 4568:        if (flags & ImGuiHoveredFlags_ForTooltip)
    %%%%%: 4568-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4569:            flags = ApplyHoverFlagsForTooltip(flags, g.Style.HoverFlagsForTooltipNav);
    %%%%%: 4569-block 20
call    0 never executed
        -: 4570:    }
        -: 4571:    else
        -: 4572:    {
        -: 4573:        // Test for bounding box overlap, as updated as ItemAdd()
   818178: 4574:        ImGuiItemStatusFlags status_flags = g.LastItemData.StatusFlags;
   818178: 4575:        if (!(status_flags & ImGuiItemStatusFlags_HoveredRect))
   818178: 4575-block 22
branch  0 taken 817965 (fallthrough)
branch  1 taken 213
   817965: 4576:            return false;
   817965: 4576-block 23
        -: 4577:
      213: 4578:        if (flags & ImGuiHoveredFlags_ForTooltip)
      213: 4578-block 24
branch  0 taken 0 (fallthrough)
branch  1 taken 213
    #####: 4579:            flags = ApplyHoverFlagsForTooltip(flags, g.Style.HoverFlagsForTooltipMouse);
    %%%%%: 4579-block 25
call    0 never executed
        -: 4580:
        -: 4581:        // Done with rectangle culling so we can perform heavier checks now
        -: 4582:        // Test if we are hovering the right window (our window could be behind another window)
        -: 4583:        // [2021/03/02] Reworked / reverted the revert, finally. Note we want e.g. BeginGroup/ItemAdd/EndGroup to work as well. (#3851)
        -: 4584:        // [2017/10/16] Reverted commit 344d48be3 and testing RootWindow instead. I believe it is correct to NOT test for RootWindow but this leaves us unable
        -: 4585:        // to use IsItemHovered() after EndChild() itself. Until a solution is found I believe reverting to the test from 2017/09/27 is safe since this was
        -: 4586:        // the test that has been running for a long while.
     213*: 4587:        if (g.HoveredWindow != window && (status_flags & ImGuiItemStatusFlags_HoveredWindow) == 0)
      213: 4587-block 26
branch  0 taken 0 (fallthrough)
branch  1 taken 213
    %%%%%: 4587-block 27
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4588:            if ((flags & ImGuiHoveredFlags_AllowWhenOverlappedByWindow) == 0)
    %%%%%: 4588-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4589:                return false;
    %%%%%: 4589-block 29
        -: 4590:
        -: 4591:        // Test if another item is active (e.g. being dragged)
      213: 4592:        const ImGuiID id = g.LastItemData.ID;
      213: 4593:        if ((flags & ImGuiHoveredFlags_AllowWhenBlockedByActiveItem) == 0)
      213: 4593-block 30
branch  0 taken 213 (fallthrough)
branch  1 taken 0
     213*: 4594:            if (g.ActiveId != 0 && g.ActiveId != id && !g.ActiveIdAllowOverlap)
      213: 4594-block 31
branch  0 taken 39 (fallthrough)
branch  1 taken 174
       39: 4594-block 32
branch  2 taken 0 (fallthrough)
branch  3 taken 39
    %%%%%: 4594-block 33
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 4595:                if (g.ActiveId != window->MoveId && g.ActiveId != window->TabId)
    %%%%%: 4595-block 34
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4595-block 35
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4596:                    return false;
    %%%%%: 4596-block 36
        -: 4597:
        -: 4598:        // Test if interactions on this window are blocked by an active popup or modal.
        -: 4599:        // The ImGuiHoveredFlags_AllowWhenBlockedByPopup flag will be tested here.
     213*: 4600:        if (!IsWindowContentHoverable(window, flags) && !(g.LastItemData.ItemFlags & ImGuiItemFlags_NoWindowHoverableCheck))
      213: 4600-block 37
call    0 returned 213
branch  1 taken 0 (fallthrough)
branch  2 taken 213
    %%%%%: 4600-block 39
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 4600-block 40
      213: 4600-block 41
      213: 4600-block 42
branch  5 taken 0 (fallthrough)
branch  6 taken 213
    #####: 4601:            return false;
    %%%%%: 4601-block 43
        -: 4602:
        -: 4603:        // Test if the item is disabled
     213*: 4604:        if ((g.LastItemData.ItemFlags & ImGuiItemFlags_Disabled) && !(flags & ImGuiHoveredFlags_AllowWhenDisabled))
      213: 4604-block 44
branch  0 taken 0 (fallthrough)
branch  1 taken 213
    %%%%%: 4604-block 45
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4605:            return false;
    %%%%%: 4605-block 46
        -: 4606:
        -: 4607:        // Special handling for calling after Begin() which represent the title bar or tab.
        -: 4608:        // When the window is skipped/collapsed (SkipItems==true) that last item (always ->MoveId submitted by Begin)
        -: 4609:        // will never be overwritten so we need to detect the case.
     213*: 4610:        if (id == window->MoveId && window->WriteAccessed)
      213: 4610-block 47
branch  0 taken 0 (fallthrough)
branch  1 taken 213
    %%%%%: 4610-block 48
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4611:            return false;
    %%%%%: 4611-block 49
        -: 4612:
        -: 4613:        // Test if using AllowOverlap and overlapped
     213*: 4614:        if ((g.LastItemData.ItemFlags & ImGuiItemFlags_AllowOverlap) && id != 0)
      213: 4614-block 50
branch  0 taken 0 (fallthrough)
branch  1 taken 213
    %%%%%: 4614-block 51
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4615:            if ((flags & ImGuiHoveredFlags_AllowWhenOverlappedByItem) == 0)
    %%%%%: 4615-block 52
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4616:                if (g.HoveredIdPreviousFrame != g.LastItemData.ID)
    %%%%%: 4616-block 53
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4617:                    return false;
    %%%%%: 4617-block 54
        -: 4618:    }
        -: 4619:
        -: 4620:    // Handle hover delay
        -: 4621:    // (some ideas: https://www.nngroup.com/articles/timing-exposing-content)
      213: 4622:    const float delay = CalcDelayFromHoveredFlags(flags);
      213: 4622-block 55
call    0 returned 213
      213: 4623:    if (delay > 0.0f || (flags & ImGuiHoveredFlags_Stationary))
branch  0 taken 213 (fallthrough)
branch  1 taken 0
      213: 4623-block 57
branch  2 taken 0 (fallthrough)
branch  3 taken 213
        -: 4624:    {
    #####: 4625:        ImGuiID hover_delay_id = (g.LastItemData.ID != 0) ? g.LastItemData.ID : window->GetIDFromPos(g.LastItemData.Rect.Min);
    %%%%%: 4625-block 58
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4625-block 59
    %%%%%: 4625-block 60
call    2 never executed
    #####: 4626:        if ((flags & ImGuiHoveredFlags_NoSharedDelay) && (g.HoverItemDelayIdPreviousFrame != hover_delay_id))
    %%%%%: 4626-block 62
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4626-block 63
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4627:            g.HoverItemDelayTimer = 0.0f;
    %%%%%: 4627-block 64
    #####: 4628:        g.HoverItemDelayId = hover_delay_id;
        -: 4629:
        -: 4630:        // When changing hovered item we requires a bit of stationary delay before activating hover timer,
        -: 4631:        // but once unlocked on a given item we also moving.
        -: 4632:        //if (g.HoverDelayTimer >= delay && (g.HoverDelayTimer - g.IO.DeltaTime < delay || g.MouseStationaryTimer - g.IO.DeltaTime < g.Style.HoverStationaryDelay)) { IMGUI_DEBUG_LOG("HoverDelayTimer = %f/%f, MouseStationaryTimer = %f\n", g.HoverDelayTimer, delay, g.MouseStationaryTimer); }
    #####: 4633:        if ((flags & ImGuiHoveredFlags_Stationary) != 0 && g.HoverItemUnlockedStationaryId != hover_delay_id)
    %%%%%: 4633-block 65
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4633-block 66
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4634:            return false;
    %%%%%: 4634-block 67
        -: 4635:
    #####: 4636:        if (g.HoverItemDelayTimer < delay)
    %%%%%: 4636-block 68
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4637:            return false;
    %%%%%: 4637-block 69
        -: 4638:    }
        -: 4639:
      213: 4640:    return true;
      213: 4640-block 70
        -: 4641:}
        -: 4642:
        -: 4643:// Internal facing ItemHoverable() used when submitting widgets. Differs slightly from IsItemHovered().
        -: 4644:// (this does not rely on LastItemData it can be called from a ButtonBehavior() call not following an ItemAdd() call)
        -: 4645:// FIXME-LEGACY: the 'ImGuiItemFlags item_flags' parameter was added on 2023-06-28.
        -: 4646:// If you used this in your legacy/custom widgets code:
        -: 4647:// - Commonly: if your ItemHoverable() call comes after an ItemAdd() call: pass 'item_flags = g.LastItemData.ItemFlags'.
        -: 4648:// - Rare: otherwise you may pass 'item_flags = 0' (ImGuiItemFlags_None) unless you want to benefit from special behavior handled by ItemHoverable.
function _ZN5ImGui13ItemHoverableERK6ImRectji called 109747 returned 100% blocks executed 46%
   109747: 4649:bool ImGui::ItemHoverable(const ImRect& bb, ImGuiID id, ImGuiItemFlags item_flags)
        -: 4650:{
   109747: 4651:    ImGuiContext& g = *GImGui;
   109747: 4652:    ImGuiWindow* window = g.CurrentWindow;
        -: 4653:
        -: 4654:    // Detect ID conflicts
        -: 4655:#ifndef IMGUI_DISABLE_DEBUG_TOOLS
   109747: 4656:    if (id != 0 && g.HoveredIdPreviousFrame == id && (item_flags & ImGuiItemFlags_AllowDuplicateId) == 0)
   109747: 4656-block 2
branch  0 taken 108670 (fallthrough)
branch  1 taken 1077
   108670: 4656-block 3
branch  2 taken 210 (fallthrough)
branch  3 taken 108460
      210: 4656-block 4
branch  4 taken 210 (fallthrough)
branch  5 taken 0
        -: 4657:    {
      210: 4658:        g.HoveredIdPreviousFrameItemCount++;
      210: 4659:        if (g.DebugDrawIdConflicts == id)
      210: 4659-block 5
branch  0 taken 0 (fallthrough)
branch  1 taken 210
    #####: 4660:            window->DrawList->AddRect(bb.Min - ImVec2(1,1), bb.Max + ImVec2(1,1), IM_COL32(255, 0, 0, 255), 0.0f, ImDrawFlags_None, 2.0f);
    %%%%%: 4660-block 6
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    %%%%%: 4660-block 11
    $$$$$: 4660-block 66
    $$$$$: 4660-block 67
    $$$$$: 4660-block 68
        -: 4661:    }
        -: 4662:#endif
        -: 4663:
   109747: 4664:    if (g.HoveredWindow != window)
   109747: 4664-block 12
branch  0 taken 97866 (fallthrough)
branch  1 taken 11881
    97866: 4665:        return false;
    97866: 4665-block 13
    11881: 4666:    if (!IsMouseHoveringRect(bb.Min, bb.Max))
    11881: 4666-block 14
call    0 returned 11881
branch  1 taken 11669 (fallthrough)
branch  2 taken 212
    11669: 4667:        return false;
    11669: 4667-block 16
        -: 4668:
     212*: 4669:    if (g.HoveredId != 0 && g.HoveredId != id && !g.HoveredIdAllowOverlap)
      212: 4669-block 17
branch  0 taken 0 (fallthrough)
branch  1 taken 212
    %%%%%: 4669-block 18
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4669-block 19
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 4670:        return false;
    %%%%%: 4670-block 20
     212*: 4671:    if (g.ActiveId != 0 && g.ActiveId != id && !g.ActiveIdAllowOverlap)
      212: 4671-block 21
branch  0 taken 39 (fallthrough)
branch  1 taken 173
       39: 4671-block 22
branch  2 taken 0 (fallthrough)
branch  3 taken 39
    %%%%%: 4671-block 23
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 4672:        if (!g.ActiveIdFromShortcut)
    %%%%%: 4672-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4673:            return false;
    %%%%%: 4673-block 25
        -: 4674:
        -: 4675:    // Done with rectangle culling so we can perform heavier checks now.
     212*: 4676:    if (!(item_flags & ImGuiItemFlags_NoWindowHoverableCheck) && !IsWindowContentHoverable(window, ImGuiHoveredFlags_None))
      212: 4676-block 26
branch  0 taken 212 (fallthrough)
branch  1 taken 0
      212: 4676-block 27
call    2 returned 212
branch  3 taken 0 (fallthrough)
branch  4 taken 212
    %%%%%: 4676-block 29
      212: 4676-block 30
      212: 4676-block 31
branch  5 taken 0 (fallthrough)
branch  6 taken 212
        -: 4677:    {
    #####: 4678:        g.HoveredIdIsDisabled = true;
    #####: 4679:        return false;
    %%%%%: 4679-block 32
        -: 4680:    }
        -: 4681:
        -: 4682:    // We exceptionally allow this function to be called with id==0 to allow using it for easy high-level
        -: 4683:    // hover test in widgets code. We could also decide to split this function is two.
      212: 4684:    if (id != 0)
      212: 4684-block 33
branch  0 taken 212 (fallthrough)
branch  1 taken 0
        -: 4685:    {
        -: 4686:        // Drag source doesn't report as hovered
     212*: 4687:        if (g.DragDropActive && g.DragDropPayload.SourceId == id && !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoDisableHover))
      212: 4687-block 34
branch  0 taken 0 (fallthrough)
branch  1 taken 212
    %%%%%: 4687-block 35
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4687-block 36
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 4688:            return false;
    %%%%%: 4688-block 37
        -: 4689:
      212: 4690:        SetHoveredID(id);
      212: 4690-block 38
call    0 returned 212
        -: 4691:
        -: 4692:        // AllowOverlap mode (rarely used) requires previous frame HoveredId to be null or to match.
        -: 4693:        // This allows using patterns where a later submitted widget overlaps a previous one. Generally perceived as a front-to-back hit-test.
      212: 4694:        if (item_flags & ImGuiItemFlags_AllowOverlap)
branch  0 taken 0 (fallthrough)
branch  1 taken 212
        -: 4695:        {
    #####: 4696:            g.HoveredIdAllowOverlap = true;
    #####: 4697:            if (g.HoveredIdPreviousFrame != id)
    %%%%%: 4697-block 40
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4698:                return false;
    %%%%%: 4698-block 41
        -: 4699:        }
        -: 4700:
        -: 4701:        // Display shortcut (only works with mouse)
        -: 4702:        // (ImGuiItemStatusFlags_HasShortcut in LastItemData denotes we want a tooltip)
     212*: 4703:        if (id == g.LastItemData.ID && (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_HasShortcut) && g.ActiveId != id)
      212: 4703-block 42
branch  0 taken 212 (fallthrough)
branch  1 taken 0
      212: 4703-block 43
branch  2 taken 0 (fallthrough)
branch  3 taken 212
    %%%%%: 4703-block 44
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 4704:            if (IsItemHovered(ImGuiHoveredFlags_ForTooltip | ImGuiHoveredFlags_DelayNormal))
    %%%%%: 4704-block 45
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 4705:                SetTooltip("%s", GetKeyChordName(g.LastItemData.Shortcut));
    %%%%%: 4705-block 47
call    0 never executed
call    1 never executed
        -: 4706:    }
        -: 4707:
        -: 4708:    // When disabled we'll return false but still set HoveredId
      212: 4709:    if (item_flags & ImGuiItemFlags_Disabled)
      212: 4709-block 49
branch  0 taken 0 (fallthrough)
branch  1 taken 212
        -: 4710:    {
        -: 4711:        // Release active id if turning disabled
    #####: 4712:        if (g.ActiveId == id && id != 0)
    %%%%%: 4712-block 50
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4712-block 51
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4713:            ClearActiveID();
    %%%%%: 4713-block 52
call    0 never executed
    #####: 4714:        g.HoveredIdIsDisabled = true;
    #####: 4715:        return false;
    %%%%%: 4715-block 53
        -: 4716:    }
        -: 4717:
        -: 4718:#ifndef IMGUI_DISABLE_DEBUG_TOOLS
      212: 4719:    if (id != 0)
      212: 4719-block 54
branch  0 taken 212 (fallthrough)
branch  1 taken 0
        -: 4720:    {
        -: 4721:        // [DEBUG] Item Picker tool!
        -: 4722:        // We perform the check here because reaching is path is rare (1~ time a frame),
        -: 4723:        // making the cost of this tool near-zero! We could get better call-stack and support picking non-hovered
        -: 4724:        // items if we performed the test in ItemAdd(), but that would incur a bigger runtime cost.
     212*: 4725:        if (g.DebugItemPickerActive && g.HoveredIdPreviousFrame == id)
      212: 4725-block 55
branch  0 taken 0 (fallthrough)
branch  1 taken 212
    %%%%%: 4725-block 56
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4726:            GetForegroundDrawList()->AddRect(bb.Min, bb.Max, IM_COL32(255, 255, 0, 255));
    %%%%%: 4726-block 57
call    0 never executed
call    1 never executed
      212: 4727:        if (g.DebugItemPickerBreakId == id)
      212: 4727-block 59
branch  0 taken 0 (fallthrough)
branch  1 taken 212
    #####: 4728:            IM_DEBUG_BREAK();
    %%%%%: 4728-block 60
call    0 never executed
        -: 4729:    }
        -: 4730:#endif
        -: 4731:
     212*: 4732:    if (g.NavHighlightItemUnderNav && (item_flags & ImGuiItemFlags_NoNavDisableMouseHover) == 0)
      212: 4732-block 61
branch  0 taken 0 (fallthrough)
branch  1 taken 212
    %%%%%: 4732-block 62
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4733:        return false;
    %%%%%: 4733-block 63
        -: 4734:
      212: 4735:    return true;
      212: 4735-block 64
        -: 4736:}
        -: 4737:
        -: 4738:// FIXME: This is inlined/duplicated in ItemAdd()
        -: 4739:// FIXME: The id != 0 path is not used by our codebase, may get rid of it?
function _ZN5ImGui11IsClippedExERK6ImRectj called 0 returned 0% blocks executed 0%
    #####: 4740:bool ImGui::IsClippedEx(const ImRect& bb, ImGuiID id)
        -: 4741:{
    #####: 4742:    ImGuiContext& g = *GImGui;
    #####: 4743:    ImGuiWindow* window = g.CurrentWindow;
    #####: 4744:    if (!bb.Overlaps(window->ClipRect))
    %%%%%: 4744-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 4745:        if (id == 0 || (id != g.ActiveId && id != g.ActiveIdPreviousFrame && id != g.NavId && id != g.NavActivateId))
    %%%%%: 4745-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4745-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4745-block 6
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 4745-block 7
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 4745-block 8
branch  8 never executed (fallthrough)
branch  9 never executed
    #####: 4746:            if (!g.ItemUnclipByLog)
    %%%%%: 4746-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4747:                return true;
    %%%%%: 4747-block 10
    #####: 4748:    return false;
    %%%%%: 4748-block 11
        -: 4749:}
        -: 4750:
        -: 4751:// This is also inlined in ItemAdd()
        -: 4752:// Note: if ImGuiItemStatusFlags_HasDisplayRect is set, user needs to set g.LastItemData.DisplayRect.
function _ZN5ImGui15SetLastItemDataEjiiRK6ImRect called 17445 returned 100% blocks executed 100%
    17445: 4753:void ImGui::SetLastItemData(ImGuiID item_id, ImGuiItemFlags in_flags, ImGuiItemStatusFlags item_flags, const ImRect& item_rect)
        -: 4754:{
    17445: 4755:    ImGuiContext& g = *GImGui;
    17445: 4756:    g.LastItemData.ID = item_id;
    17445: 4757:    g.LastItemData.ItemFlags = in_flags;
    17445: 4758:    g.LastItemData.StatusFlags = item_flags;
    17445: 4759:    g.LastItemData.Rect = g.LastItemData.NavRect = item_rect;
    17445: 4760:}
        -: 4761:
function _ZN5ImGui19CalcWrapWidthForPosERK6ImVec2f called 0 returned 0% blocks executed 0%
    #####: 4762:float ImGui::CalcWrapWidthForPos(const ImVec2& pos, float wrap_pos_x)
        -: 4763:{
    #####: 4764:    if (wrap_pos_x < 0.0f)
    %%%%%: 4764-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4765:        return 0.0f;
    %%%%%: 4765-block 3
        -: 4766:
    #####: 4767:    ImGuiContext& g = *GImGui;
    #####: 4768:    ImGuiWindow* window = g.CurrentWindow;
    #####: 4769:    if (wrap_pos_x == 0.0f)
    %%%%%: 4769-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4770:    {
        -: 4771:        // We could decide to setup a default wrapping max point for auto-resizing windows,
        -: 4772:        // or have auto-wrap (with unspecified wrapping pos) behave as a ContentSize extending function?
        -: 4773:        //if (window->Hidden && (window->Flags & ImGuiWindowFlags_AlwaysAutoResize))
        -: 4774:        //    wrap_pos_x = ImMax(window->WorkRect.Min.x + g.FontSize * 10.0f, window->WorkRect.Max.x);
        -: 4775:        //else
    #####: 4776:        wrap_pos_x = window->WorkRect.Max.x;
    %%%%%: 4776-block 5
        -: 4777:    }
    #####: 4778:    else if (wrap_pos_x > 0.0f)
    %%%%%: 4778-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4779:    {
    #####: 4780:        wrap_pos_x += window->Pos.x - window->Scroll.x; // wrap_pos_x is provided is window local space
    %%%%%: 4780-block 7
        -: 4781:    }
        -: 4782:
    #####: 4783:    return ImMax(wrap_pos_x - pos.x, 1.0f);
    %%%%%: 4783-block 8
call    0 never executed
        -: 4784:}
        -: 4785:
        -: 4786:// IM_ALLOC() == ImGui::MemAlloc()
function _ZN5ImGui8MemAllocEm called 12957 returned 100% blocks executed 100%
    12957: 4787:void* ImGui::MemAlloc(size_t size)
        -: 4788:{
    12957: 4789:    void* ptr = (*GImAllocatorAllocFunc)(size, GImAllocatorUserData);
    12957: 4789-block 2
call    0 returned 12957
        -: 4790:#ifndef IMGUI_DISABLE_DEBUG_TOOLS
    12957: 4791:    if (ImGuiContext* ctx = GImGui)
branch  0 taken 12954 (fallthrough)
branch  1 taken 3
    12954: 4792:        DebugAllocHook(&ctx->DebugAllocInfo, ctx->FrameCount, ptr, size);
    12954: 4792-block 4
call    0 returned 12954
        -: 4793:#endif
    12957: 4794:    return ptr;
    12957: 4794-block 5
        -: 4795:}
        -: 4796:
        -: 4797:// IM_FREE() == ImGui::MemFree()
function _ZN5ImGui7MemFreeEPv called 12979 returned 100% blocks executed 100%
    12979: 4798:void ImGui::MemFree(void* ptr)
        -: 4799:{
        -: 4800:#ifndef IMGUI_DISABLE_DEBUG_TOOLS
    12979: 4801:    if (ptr != NULL)
    12979: 4801-block 2
branch  0 taken 12957 (fallthrough)
branch  1 taken 22
    12957: 4802:        if (ImGuiContext* ctx = GImGui)
    12957: 4802-block 3
branch  0 taken 12941 (fallthrough)
branch  1 taken 16
    12941: 4803:            DebugAllocHook(&ctx->DebugAllocInfo, ctx->FrameCount, ptr, (size_t)-1);
    12941: 4803-block 4
call    0 returned 12941
        -: 4804:#endif
    12979: 4805:    return (*GImAllocatorFreeFunc)(ptr, GImAllocatorUserData);
    12979: 4805-block 5
call    0 returned 12979
        -: 4806:}
        -: 4807:
        -: 4808:// We record the number of allocation in recent frames, as a way to audit/sanitize our guiding principles of "no allocations on idle/repeating frames"
function _ZN5ImGui14DebugAllocHookEP19ImGuiDebugAllocInfoiPvm called 25895 returned 100% blocks executed 100%
    25895: 4809:void ImGui::DebugAllocHook(ImGuiDebugAllocInfo* info, int frame_count, void* ptr, size_t size)
        -: 4810:{
    25895: 4811:    ImGuiDebugAllocEntry* entry = &info->LastEntriesBuf[info->LastEntriesIdx];
        -: 4812:    IM_UNUSED(ptr);
    25895: 4813:    if (entry->FrameCount != frame_count)
    25895: 4813-block 2
branch  0 taken 7 (fallthrough)
branch  1 taken 25888
        -: 4814:    {
        7: 4815:        info->LastEntriesIdx = (info->LastEntriesIdx + 1) % IM_ARRAYSIZE(info->LastEntriesBuf);
        7: 4816:        entry = &info->LastEntriesBuf[info->LastEntriesIdx];
        7: 4817:        entry->FrameCount = frame_count;
        7: 4818:        entry->AllocCount = entry->FreeCount = 0;
        7: 4818-block 3
        -: 4819:    }
    25895: 4820:    if (size != (size_t)-1)
    25895: 4820-block 4
branch  0 taken 12954 (fallthrough)
branch  1 taken 12941
        -: 4821:    {
    12954: 4822:        entry->AllocCount++;
    12954: 4823:        info->TotalAllocCount++;
    12954: 4823-block 5
        -: 4824:        //printf("[%05d] MemAlloc(%d) -> 0x%p\n", frame_count, size, ptr);
        -: 4825:    }
        -: 4826:    else
        -: 4827:    {
    12941: 4828:        entry->FreeCount++;
    12941: 4829:        info->TotalFreeCount++;
    12941: 4829-block 6
        -: 4830:        //printf("[%05d] MemFree(0x%p)\n", frame_count, ptr);
        -: 4831:    }
    25895: 4832:}
        -: 4833:
function _ZN5ImGui16GetClipboardTextEv called 0 returned 0% blocks executed 0%
    #####: 4834:const char* ImGui::GetClipboardText()
        -: 4835:{
    #####: 4836:    ImGuiContext& g = *GImGui;
    #####: 4837:    return g.PlatformIO.Platform_GetClipboardTextFn ? g.PlatformIO.Platform_GetClipboardTextFn(&g) : "";
    %%%%%: 4837-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4837-block 3
call    2 never executed
    %%%%%: 4837-block 5
    %%%%%: 4837-block 6
        -: 4838:}
        -: 4839:
function _ZN5ImGui16SetClipboardTextEPKc called 0 returned 0% blocks executed 0%
    #####: 4840:void ImGui::SetClipboardText(const char* text)
        -: 4841:{
    #####: 4842:    ImGuiContext& g = *GImGui;
    #####: 4843:    if (g.PlatformIO.Platform_SetClipboardTextFn != NULL)
    %%%%%: 4843-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4844:        g.PlatformIO.Platform_SetClipboardTextFn(&g, text);
    %%%%%: 4844-block 3
call    0 never executed
    #####: 4845:}
        -: 4846:
function _ZN5ImGui10GetVersionEv called 0 returned 0% blocks executed 0%
    #####: 4847:const char* ImGui::GetVersion()
        -: 4848:{
    #####: 4849:    return IMGUI_VERSION;
    %%%%%: 4849-block 2
        -: 4850:}
        -: 4851:
function _ZN5ImGui5GetIOEv called 71452 returned 100% blocks executed 75%
    71452: 4852:ImGuiIO& ImGui::GetIO()
        -: 4853:{
   71452*: 4854:    IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?");
    71452: 4854-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 71452
    %%%%%: 4854-block 3
call    2 never executed
    71452: 4855:    return GImGui->IO;
    71452: 4855-block 4
        -: 4856:}
        -: 4857:
function _ZN5ImGui13GetPlatformIOEv called 2158 returned 100% blocks executed 75%
     2158: 4858:ImGuiPlatformIO& ImGui::GetPlatformIO()
        -: 4859:{
    2158*: 4860:    IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext()?");
     2158: 4860-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 2158
    %%%%%: 4860-block 3
call    2 never executed
     2158: 4861:    return GImGui->PlatformIO;
     2158: 4861-block 4
        -: 4862:}
        -: 4863:
        -: 4864:// Pass this to your backend rendering function! Valid after Render() and until the next call to NewFrame()
function _ZN5ImGui11GetDrawDataEv called 1077 returned 100% blocks executed 83%
     1077: 4865:ImDrawData* ImGui::GetDrawData()
        -: 4866:{
     1077: 4867:    ImGuiContext& g = *GImGui;
     1077: 4868:    ImGuiViewportP* viewport = g.Viewports[0];
     1077: 4868-block 2
call    0 returned 1077
    1077*: 4869:    return viewport->DrawDataP.Valid ? &viewport->DrawDataP : NULL;
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 4869-block 4
    %%%%%: 4869-block 5
     1077: 4869-block 6
        -: 4870:}
        -: 4871:
function _ZN5ImGui7GetTimeEv called 656 returned 100% blocks executed 100%
      656: 4872:double ImGui::GetTime()
        -: 4873:{
      656: 4874:    return GImGui->Time;
      656: 4874-block 2
        -: 4875:}
        -: 4876:
function _ZN5ImGui13GetFrameCountEv called 0 returned 0% blocks executed 0%
    #####: 4877:int ImGui::GetFrameCount()
        -: 4878:{
    #####: 4879:    return GImGui->FrameCount;
    %%%%%: 4879-block 2
        -: 4880:}
        -: 4881:
function _ZL23GetViewportBgFgDrawListP14ImGuiViewportPmPKc called 0 returned 0% blocks executed 0%
    #####: 4882:static ImDrawList* GetViewportBgFgDrawList(ImGuiViewportP* viewport, size_t drawlist_no, const char* drawlist_name)
        -: 4883:{
        -: 4884:    // Create the draw list on demand, because they are not frequently used for all viewports
    #####: 4885:    ImGuiContext& g = *GImGui;
    #####: 4886:    IM_ASSERT(drawlist_no < IM_ARRAYSIZE(viewport->BgFgDrawLists));
    %%%%%: 4886-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4886-block 3
call    2 never executed
    #####: 4887:    ImDrawList* draw_list = viewport->BgFgDrawLists[drawlist_no];
    #####: 4888:    if (draw_list == NULL)
    %%%%%: 4888-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4889:    {
    #####: 4890:        draw_list = IM_NEW(ImDrawList)(&g.DrawListSharedData);
    %%%%%: 4890-block 5
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    $$$$$: 4890-block 17
branch  5 never executed (fallthrough)
branch  6 never executed
    $$$$$: 4890-block 18
call    7 never executed
    #####: 4891:        draw_list->_OwnerName = drawlist_name;
    #####: 4892:        viewport->BgFgDrawLists[drawlist_no] = draw_list;
    %%%%%: 4892-block 8
        -: 4893:    }
        -: 4894:
        -: 4895:    // Our ImDrawList system requires that there is always a command
    #####: 4896:    if (viewport->BgFgDrawListsLastFrame[drawlist_no] != g.FrameCount)
    %%%%%: 4896-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4897:    {
    #####: 4898:        draw_list->_ResetForNewFrame();
    %%%%%: 4898-block 10
call    0 never executed
    #####: 4899:        draw_list->PushTextureID(g.IO.Fonts->TexID);
call    0 never executed
    #####: 4900:        draw_list->PushClipRect(viewport->Pos, viewport->Pos + viewport->Size, false);
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####: 4901:        viewport->BgFgDrawListsLastFrame[drawlist_no] = g.FrameCount;
    %%%%%: 4901-block 14
        -: 4902:    }
    #####: 4903:    return draw_list;
    %%%%%: 4903-block 15
    %%%%%: 4903-block 16
        -: 4904:}
        -: 4905:
function _ZN5ImGui21GetBackgroundDrawListEP13ImGuiViewport called 0 returned 0% blocks executed 0%
    #####: 4906:ImDrawList* ImGui::GetBackgroundDrawList(ImGuiViewport* viewport)
        -: 4907:{
    #####: 4908:    if (viewport == NULL)
    %%%%%: 4908-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4909:        viewport = GImGui->CurrentWindow->Viewport;
    %%%%%: 4909-block 3
    #####: 4910:    return GetViewportBgFgDrawList((ImGuiViewportP*)viewport, 0, "##Background");
    %%%%%: 4910-block 4
call    0 never executed
        -: 4911:}
        -: 4912:
function _ZN5ImGui21GetForegroundDrawListEP13ImGuiViewport called 0 returned 0% blocks executed 0%
    #####: 4913:ImDrawList* ImGui::GetForegroundDrawList(ImGuiViewport* viewport)
        -: 4914:{
    #####: 4915:    if (viewport == NULL)
    %%%%%: 4915-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4916:        viewport = GImGui->CurrentWindow->Viewport;
    %%%%%: 4916-block 3
    #####: 4917:    return GetViewportBgFgDrawList((ImGuiViewportP*)viewport, 1, "##Foreground");
    %%%%%: 4917-block 4
call    0 never executed
        -: 4918:}
        -: 4919:
function _ZN5ImGui21GetDrawListSharedDataEv called 0 returned 0% blocks executed 0%
    #####: 4920:ImDrawListSharedData* ImGui::GetDrawListSharedData()
        -: 4921:{
    #####: 4922:    return &GImGui->DrawListSharedData;
    %%%%%: 4922-block 2
        -: 4923:}
        -: 4924:
function _ZN5ImGui22StartMouseMovingWindowEP11ImGuiWindow called 3 returned 100% blocks executed 75%
        3: 4925:void ImGui::StartMouseMovingWindow(ImGuiWindow* window)
        -: 4926:{
        -: 4927:    // Set ActiveId even if the _NoMove flag is set. Without it, dragging away from a window with _NoMove would activate hover on other windows.
        -: 4928:    // We _also_ call this when clicking in a window empty space when io.ConfigWindowsMoveFromTitleBarOnly is set, but clear g.MovingWindow afterward.
        -: 4929:    // This is because we want ActiveId to be set even when the window is not permitted to move.
        3: 4930:    ImGuiContext& g = *GImGui;
        3: 4931:    FocusWindow(window);
        3: 4931-block 2
call    0 returned 3
        3: 4932:    SetActiveID(window->MoveId, window);
call    0 returned 3
        3: 4933:    if (g.IO.ConfigNavCursorVisibleAuto)
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3: 4934:        g.NavCursorVisible = false;
        3: 4934-block 5
        3: 4935:    g.ActiveIdClickOffset = g.IO.MouseClickedPos[0] - window->RootWindowDockTree->Pos;
        3: 4935-block 6
call    0 returned 3
        3: 4936:    g.ActiveIdNoClearOnFocusLoss = true;
        3: 4937:    SetActiveIdUsingAllKeyboardKeys();
call    0 returned 3
        -: 4938:
        3: 4939:    bool can_move_window = true;
        3: 4940:    if ((window->Flags & ImGuiWindowFlags_NoMove) || (window->RootWindowDockTree->Flags & ImGuiWindowFlags_NoMove))
branch  0 taken 1 (fallthrough)
branch  1 taken 2
        1: 4940-block 9
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        3: 4941:        can_move_window = false;
        3: 4941-block 10
        3: 4942:    if (ImGuiDockNode* node = window->DockNodeAsHost)
        3: 4942-block 11
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####: 4943:        if (node->VisibleWindow && (node->VisibleWindow->Flags & ImGuiWindowFlags_NoMove))
    %%%%%: 4943-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4943-block 13
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4944:            can_move_window = false;
    %%%%%: 4944-block 14
        3: 4945:    if (can_move_window)
        3: 4945-block 15
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####: 4946:        g.MovingWindow = window;
    %%%%%: 4946-block 16
        3: 4947:}
        -: 4948:
        -: 4949:// We use 'undock == false' when dragging from title bar to allow moving groups of floating nodes without undocking them.
function _ZN5ImGui28StartMouseMovingWindowOrNodeEP11ImGuiWindowP13ImGuiDockNodeb called 0 returned 0% blocks executed 0%
    #####: 4950:void ImGui::StartMouseMovingWindowOrNode(ImGuiWindow* window, ImGuiDockNode* node, bool undock)
        -: 4951:{
    #####: 4952:    ImGuiContext& g = *GImGui;
    #####: 4953:    bool can_undock_node = false;
    #####: 4954:    if (undock && node != NULL && node->VisibleWindow && (node->VisibleWindow->Flags & ImGuiWindowFlags_NoMove) == 0 && (node->MergedFlags & ImGuiDockNodeFlags_NoUndocking) == 0)
    %%%%%: 4954-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4954-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4954-block 4
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 4954-block 5
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 4954-block 6
branch  8 never executed (fallthrough)
branch  9 never executed
        -: 4955:    {
        -: 4956:        // Can undock if:
        -: 4957:        // - part of a hierarchy with more than one visible node (if only one is visible, we'll just move the root window)
        -: 4958:        // - part of a dockspace node hierarchy: so we can undock the last single visible node too (trivia: undocking from a fixed/central node will create a new node and copy windows)
    #####: 4959:        ImGuiDockNode* root_node = DockNodeGetRootNode(node);
    %%%%%: 4959-block 7
call    0 never executed
    #####: 4960:        if (root_node->OnlyNodeWithWindows != node || root_node->CentralNode != NULL)   // -V1051 PVS-Studio thinks node should be root_node and is wrong about that.
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4960-block 9
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4961:            can_undock_node = true;
    %%%%%: 4961-block 10
        -: 4962:    }
        -: 4963:
    #####: 4964:    const bool clicked = IsMouseClicked(0);
    %%%%%: 4964-block 11
call    0 never executed
    #####: 4965:    const bool dragging = IsMouseDragging(0);
call    0 never executed
    #####: 4966:    if (can_undock_node && dragging)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4966-block 14
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4967:        DockContextQueueUndockNode(&g, node); // Will lead to DockNodeStartMouseMovingWindow() -> StartMouseMovingWindow() being called next frame
    %%%%%: 4967-block 15
call    0 never executed
    #####: 4968:    else if (!can_undock_node && (clicked || dragging) && g.MovingWindow != window)
    %%%%%: 4968-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4968-block 17
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4968-block 18
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 4968-block 19
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 4969:        StartMouseMovingWindow(window);
    %%%%%: 4969-block 20
call    0 never executed
    #####: 4970:}
        -: 4971:
        -: 4972:// Handle mouse moving window
        -: 4973:// Note: moving window with the navigation keys (Square + d-pad / CTRL+TAB + Arrows) are processed in NavUpdateWindowing()
        -: 4974:// FIXME: We don't have strong guarantee that g.MovingWindow stay synched with g.ActiveId == g.MovingWindow->MoveId.
        -: 4975:// This is currently enforced by the fact that BeginDragDropSource() is setting all g.ActiveIdUsingXXXX flags to inhibit navigation inputs,
        -: 4976:// but if we should more thoroughly test cases where g.ActiveId or g.MovingWindow gets changed and not the other.
function _ZN5ImGui31UpdateMouseMovingWindowNewFrameEv called 1077 returned 100% blocks executed 17%
     1077: 4977:void ImGui::UpdateMouseMovingWindowNewFrame()
        -: 4978:{
     1077: 4979:    ImGuiContext& g = *GImGui;
     1077: 4980:    if (g.MovingWindow != NULL)
     1077: 4980-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
        -: 4981:    {
        -: 4982:        // We actually want to move the root window. g.MovingWindow == window we clicked on (could be a child window).
        -: 4983:        // We track it to preserve Focus and so that generally ActiveIdWindow == MovingWindow and ActiveId == MovingWindow->MoveId for consistency.
    #####: 4984:        KeepAliveID(g.ActiveId);
    %%%%%: 4984-block 3
call    0 never executed
    #####: 4985:        IM_ASSERT(g.MovingWindow && g.MovingWindow->RootWindowDockTree);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4985-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4985-block 6
    %%%%%: 4985-block 7
call    4 never executed
    #####: 4986:        ImGuiWindow* moving_window = g.MovingWindow->RootWindowDockTree;
        -: 4987:
        -: 4988:        // When a window stop being submitted while being dragged, it may will its viewport until next Begin()
    #####: 4989:        const bool window_disappared = (!moving_window->WasActive && !moving_window->Active);
    %%%%%: 4989-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4989-block 9
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4989-block 10
    %%%%%: 4989-block 11
    #####: 4990:        if (g.IO.MouseDown[0] && IsMousePosValid(&g.IO.MousePos) && !window_disappared)
    %%%%%: 4990-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4990-block 13
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 4990-block 15
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 4990-block 16
    %%%%%: 4990-block 17
    %%%%%: 4990-block 18
branch  7 never executed (fallthrough)
branch  8 never executed
        -: 4991:        {
    #####: 4992:            ImVec2 pos = g.IO.MousePos - g.ActiveIdClickOffset;
    %%%%%: 4992-block 19
call    0 never executed
    #####: 4993:            if (moving_window->Pos.x != pos.x || moving_window->Pos.y != pos.y)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4993-block 21
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 4994:            {
    #####: 4995:                SetWindowPos(moving_window, pos, ImGuiCond_Always);
    %%%%%: 4995-block 22
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 4996:                if (moving_window->Viewport && moving_window->ViewportOwned) // Synchronize viewport immediately because some overlays may relies on clipping rectangle before we Begin() into the window.
    %%%%%: 4996-block 23
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4996-block 24
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 4997:                {
    #####: 4998:                    moving_window->Viewport->Pos = pos;
    #####: 4999:                    moving_window->Viewport->UpdateWorkRect();
    %%%%%: 4999-block 25
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5000:                }
        -: 5001:            }
    #####: 5002:            FocusWindow(g.MovingWindow);
    %%%%%: 5002-block 26
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5003:        }
        -: 5004:        else
        -: 5005:        {
    #####: 5006:            if (!window_disappared)
    %%%%%: 5006-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5007:            {
        -: 5008:                // Try to merge the window back into the main viewport.
        -: 5009:                // This works because MouseViewport should be != MovingWindow->Viewport on release (as per code in UpdateViewports)
    #####: 5010:                if (g.ConfigFlagsCurrFrame & ImGuiConfigFlags_ViewportsEnable)
    %%%%%: 5010-block 29
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5011:                    UpdateTryMergeWindowIntoHostViewport(moving_window, g.MouseViewport);
    %%%%%: 5011-block 30
call    0 never executed
        -: 5012:
        -: 5013:                // Restore the mouse viewport so that we don't hover the viewport _under_ the moved window during the frame we released the mouse button.
    #####: 5014:                if (moving_window->Viewport && !IsDragDropPayloadBeingAccepted())
    %%%%%: 5014-block 31
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5014-block 32
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 5014-block 34
    %%%%%: 5014-block 35
    %%%%%: 5014-block 36
branch  5 never executed (fallthrough)
branch  6 never executed
    #####: 5015:                    g.MouseViewport = moving_window->Viewport;
    %%%%%: 5015-block 37
        -: 5016:
        -: 5017:                // Clear the NoInput window flag set by the Viewport system
    #####: 5018:                if (moving_window->Viewport)
    %%%%%: 5018-block 38
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5019:                    moving_window->Viewport->Flags &= ~ImGuiViewportFlags_NoInputs;
    %%%%%: 5019-block 39
        -: 5020:            }
        -: 5021:
    #####: 5022:            g.MovingWindow = NULL;
    #####: 5023:            ClearActiveID();
    %%%%%: 5023-block 40
call    0 never executed
        -: 5024:        }
        -: 5025:    }
        -: 5026:    else
        -: 5027:    {
        -: 5028:        // When clicking/dragging from a window that has the _NoMove flag, we still set the ActiveId in order to prevent hovering others.
     1077: 5029:        if (g.ActiveIdWindow && g.ActiveIdWindow->MoveId == g.ActiveId)
     1077: 5029-block 41
branch  0 taken 154 (fallthrough)
branch  1 taken 923
      154: 5029-block 42
branch  2 taken 115 (fallthrough)
branch  3 taken 39
        -: 5030:        {
      115: 5031:            KeepAliveID(g.ActiveId);
      115: 5031-block 43
call    0 returned 115
      115: 5032:            if (!g.IO.MouseDown[0])
branch  0 taken 3 (fallthrough)
branch  1 taken 112
        3: 5033:                ClearActiveID();
        3: 5033-block 45
call    0 returned 3
        -: 5034:        }
        -: 5035:    }
     1077: 5036:}
     1077: 5036-block 46
        -: 5037:
        -: 5038:// Initiate focusing and moving window when clicking on empty space or title bar.
        -: 5039:// Initiate focusing window when clicking on a disabled item.
        -: 5040:// Handle left-click and right-click focus.
function _ZN5ImGui31UpdateMouseMovingWindowEndFrameEv called 1077 returned 100% blocks executed 46%
     1077: 5041:void ImGui::UpdateMouseMovingWindowEndFrame()
        -: 5042:{
     1077: 5043:    ImGuiContext& g = *GImGui;
     1077: 5044:    if (g.ActiveId != 0 || (g.HoveredId != 0 && !g.HoveredIdIsDisabled))
     1077: 5044-block 2
branch  0 taken 926 (fallthrough)
branch  1 taken 151
      926: 5044-block 3
branch  2 taken 173 (fallthrough)
branch  3 taken 753
      173: 5044-block 4
branch  4 taken 173 (fallthrough)
branch  5 taken 0
      324: 5045:        return;
      324: 5045-block 5
        -: 5046:
        -: 5047:    // Unless we just made a window/popup appear
      753: 5048:    if (g.NavWindow && g.NavWindow->Appearing)
      753: 5048-block 6
branch  0 taken 753 (fallthrough)
branch  1 taken 0
      753: 5048-block 7
branch  2 taken 1 (fallthrough)
branch  3 taken 752
        1: 5049:        return;
        1: 5049-block 8
        -: 5050:
        -: 5051:    // Click on empty space to focus window and start moving
        -: 5052:    // (after we're done with all our widgets, so e.g. clicking on docking tab-bar which have set HoveredId already and not get us here!)
      752: 5053:    if (g.IO.MouseClicked[0])
      752: 5053-block 9
branch  0 taken 3 (fallthrough)
branch  1 taken 749
        -: 5054:    {
        -: 5055:        // Handle the edge case of a popup being closed while clicking in its empty space.
        -: 5056:        // If we try to focus it, FocusWindow() > ClosePopupsOverWindow() will accidentally close any parent popups because they are not linked together any more.
       3*: 5057:        ImGuiWindow* root_window = g.HoveredWindow ? g.HoveredWindow->RootWindow : NULL;
        3: 5057-block 10
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3: 5057-block 11
    %%%%%: 5057-block 12
       3*: 5058:        const bool is_closed_popup = root_window && (root_window->Flags & ImGuiWindowFlags_Popup) && !IsPopupOpen(root_window->PopupId, ImGuiPopupFlags_AnyPopupLevel);
        3: 5058-block 13
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3: 5058-block 14
branch  2 taken 0 (fallthrough)
branch  3 taken 3
    %%%%%: 5058-block 15
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 5058-block 17
        3: 5058-block 18
        -: 5059:
        3: 5060:        if (root_window != NULL && !is_closed_popup)
        3: 5060-block 19
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3: 5060-block 20
branch  2 taken 3 (fallthrough)
branch  3 taken 0
        -: 5061:        {
        3: 5062:            StartMouseMovingWindow(g.HoveredWindow); //-V595
        3: 5062-block 21
call    0 returned 3
        -: 5063:
        -: 5064:            // Cancel moving if clicked outside of title bar
        3: 5065:            if (g.IO.ConfigWindowsMoveFromTitleBarOnly)
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####: 5066:                if (!(root_window->Flags & ImGuiWindowFlags_NoTitleBar) || root_window->DockIsActive)
    %%%%%: 5066-block 23
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5066-block 24
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 5067:                    if (!root_window->TitleBarRect().Contains(g.IO.MouseClickedPos[0]))
    %%%%%: 5067-block 25
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 5068:                        g.MovingWindow = NULL;
    %%%%%: 5068-block 28
        -: 5069:
        -: 5070:            // Cancel moving if clicked over an item which was disabled or inhibited by popups
        -: 5071:            // (when g.HoveredIdIsDisabled == true && g.HoveredId == 0 we are inhibited by popups, when g.HoveredIdIsDisabled == true && g.HoveredId != 0 we are over a disabled item)0 already)
        3: 5072:            if (g.HoveredIdIsDisabled)
        3: 5072-block 29
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####: 5073:                g.MovingWindow = NULL;
    %%%%%: 5073-block 30
        -: 5074:        }
    #####: 5075:        else if (root_window == NULL && g.NavWindow != NULL)
    %%%%%: 5075-block 32
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5075-block 33
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 5076:        {
        -: 5077:            // Clicking on void disable focus
    #####: 5078:            FocusWindow(NULL, ImGuiFocusRequestFlags_UnlessBelowModal);
    %%%%%: 5078-block 34
call    0 never executed
        -: 5079:        }
        -: 5080:    }
        -: 5081:
        -: 5082:    // With right mouse button we close popups without changing focus based on where the mouse is aimed
        -: 5083:    // Instead, focus will be restored to the window under the bottom-most closed popup.
        -: 5084:    // (The left mouse button path calls FocusWindow on the hovered window, which will lead NewFrame->ClosePopupsOverWindow to trigger)
     752*: 5085:    if (g.IO.MouseClicked[1] && g.HoveredId == 0)
      752: 5085-block 36
branch  0 taken 0 (fallthrough)
branch  1 taken 752
    %%%%%: 5085-block 37
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 5086:    {
        -: 5087:        // Find the top-most window between HoveredWindow and the top-most Modal Window.
        -: 5088:        // This is where we can trim the popup stack.
    #####: 5089:        ImGuiWindow* modal = GetTopMostPopupModal();
    %%%%%: 5089-block 38
call    0 never executed
    #####: 5090:        bool hovered_window_above_modal = g.HoveredWindow && (modal == NULL || IsWindowAbove(g.HoveredWindow, modal));
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5090-block 40
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5090-block 41
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 5090-block 43
    %%%%%: 5090-block 44
    #####: 5091:        ClosePopupsOverWindow(hovered_window_above_modal ? g.HoveredWindow : modal, true);
    %%%%%: 5091-block 45
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5091-block 46
    %%%%%: 5091-block 47
    %%%%%: 5091-block 48
call    2 never executed
        -: 5092:    }
        -: 5093:}
        -: 5094:
        -: 5095:// This is called during NewFrame()->UpdateViewportsNewFrame() only.
        -: 5096:// Need to keep in sync with SetWindowPos()
function _ZL15TranslateWindowP11ImGuiWindowRK6ImVec2 called 0 returned 0% blocks executed 0%
    #####: 5097:static void TranslateWindow(ImGuiWindow* window, const ImVec2& delta)
        -: 5098:{
    #####: 5099:    window->Pos += delta;
    %%%%%: 5099-block 2
call    0 never executed
    #####: 5100:    window->ClipRect.Translate(delta);
call    0 never executed
    #####: 5101:    window->OuterRectClipped.Translate(delta);
call    0 never executed
    #####: 5102:    window->InnerRect.Translate(delta);
call    0 never executed
    #####: 5103:    window->DC.CursorPos += delta;
call    0 never executed
    #####: 5104:    window->DC.CursorStartPos += delta;
call    0 never executed
    #####: 5105:    window->DC.CursorMaxPos += delta;
call    0 never executed
    #####: 5106:    window->DC.IdealMaxPos += delta;
call    0 never executed
    #####: 5107:}
        -: 5108:
function _ZL11ScaleWindowP11ImGuiWindowf called 0 returned 0% blocks executed 0%
    #####: 5109:static void ScaleWindow(ImGuiWindow* window, float scale)
        -: 5110:{
    #####: 5111:    ImVec2 origin = window->Viewport->Pos;
    #####: 5112:    window->Pos = ImFloor((window->Pos - origin) * scale + origin);
    %%%%%: 5112-block 2
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 5113:    window->Size = ImTrunc(window->Size * scale);
call    0 never executed
call    1 never executed
    #####: 5114:    window->SizeFull = ImTrunc(window->SizeFull * scale);
call    0 never executed
call    1 never executed
    #####: 5115:    window->ContentSize = ImTrunc(window->ContentSize * scale);
call    0 never executed
call    1 never executed
    #####: 5116:}
        -: 5117:
function _ZL24IsWindowActiveAndVisibleP11ImGuiWindow called 30010 returned 100% blocks executed 100%
    30010: 5118:static bool IsWindowActiveAndVisible(ImGuiWindow* window)
        -: 5119:{
    30010: 5120:    return (window->Active) && (!window->Hidden);
    30010: 5120-block 2
branch  0 taken 28209 (fallthrough)
branch  1 taken 1801
    28209: 5120-block 3
branch  2 taken 28184 (fallthrough)
branch  3 taken 25
    28184: 5120-block 4
     1826: 5120-block 5
    30010: 5120-block 6
        -: 5121:}
        -: 5122:
        -: 5123:// The reason this is exposed in imgui_internal.h is: on touch-based system that don't have hovering, we want to dispatch inputs to the right target (imgui vs imgui+app)
function _ZN5ImGui34UpdateHoveredWindowAndCaptureFlagsEv called 1077 returned 100% blocks executed 73%
     1077: 5124:void ImGui::UpdateHoveredWindowAndCaptureFlags()
        -: 5125:{
     1077: 5126:    ImGuiContext& g = *GImGui;
     1077: 5127:    ImGuiIO& io = g.IO;
        -: 5128:
        -: 5129:    // FIXME-DPI: This storage was added on 2021/03/31 for test engine, but if we want to multiply WINDOWS_HOVER_PADDING
        -: 5130:    // by DpiScale, we need to make this window-agnostic anyhow, maybe need storing inside ImGuiWindow.
     1077: 5131:    g.WindowsHoverPadding = ImMax(g.Style.TouchExtraPadding, ImVec2(WINDOWS_HOVER_PADDING, WINDOWS_HOVER_PADDING));
     1077: 5131-block 2
call    0 returned 1077
call    1 returned 1077
        -: 5132:
        -: 5133:    // Find the window hovered by mouse:
        -: 5134:    // - Child windows can extend beyond the limit of their parent so we need to derive HoveredRootWindow from HoveredWindow.
        -: 5135:    // - When moving a window we can skip the search, which also conveniently bypasses the fact that window->WindowRectClipped is lagging as this point of the frame.
        -: 5136:    // - We also support the moved window toggling the NoInputs flag after moving has started in order to be able to detect windows below it, which is useful for e.g. docking mechanisms.
     1077: 5137:    bool clear_hovered_windows = false;
     1077: 5138:    FindHoveredWindowEx(g.IO.MousePos, false, &g.HoveredWindow, &g.HoveredWindowUnderMovingWindow);
call    0 returned 1077
    1077*: 5139:    IM_ASSERT(g.HoveredWindow == NULL || g.HoveredWindow == g.MovingWindow || g.HoveredWindow->Viewport == g.MouseViewport);
branch  0 taken 1076 (fallthrough)
branch  1 taken 1
     1076: 5139-block 6
branch  2 taken 1076 (fallthrough)
branch  3 taken 0
     1076: 5139-block 7
branch  4 taken 0 (fallthrough)
branch  5 taken 1076
    %%%%%: 5139-block 8
call    6 never executed
     1077: 5140:    g.HoveredWindowBeforeClear = g.HoveredWindow;
        -: 5141:
        -: 5142:    // Modal windows prevents mouse from hovering behind them.
     1077: 5143:    ImGuiWindow* modal_window = GetTopMostPopupModal();
     1077: 5143-block 9
call    0 returned 1077
    1077*: 5144:    if (modal_window && g.HoveredWindow && !IsWindowWithinBeginStackOf(g.HoveredWindow->RootWindow, modal_window)) // FIXME-MERGE: RootWindowDockTree ?
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 5144-block 11
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5144-block 12
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 5144-block 14
     1077: 5144-block 15
     1077: 5144-block 16
branch  7 taken 0 (fallthrough)
branch  8 taken 1077
    #####: 5145:        clear_hovered_windows = true;
    %%%%%: 5145-block 17
        -: 5146:
        -: 5147:    // Disabled mouse hovering (we don't currently clear MousePos, we could)
     1077: 5148:    if (io.ConfigFlags & ImGuiConfigFlags_NoMouse)
     1077: 5148-block 18
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####: 5149:        clear_hovered_windows = true;
    %%%%%: 5149-block 19
        -: 5150:
        -: 5151:    // We track click ownership. When clicked outside of a window the click is owned by the application and
        -: 5152:    // won't report hovering nor request capture even while dragging over our windows afterward.
     1077: 5153:    const bool has_open_popup = (g.OpenPopupStack.Size > 0);
     1077: 5154:    const bool has_open_modal = (modal_window != NULL);
     1077: 5155:    int mouse_earliest_down = -1;
     1077: 5156:    bool mouse_any_down = false;
     6462: 5157:    for (int i = 0; i < IM_ARRAYSIZE(io.MouseDown); i++)
     1077: 5157-block 20
     5385: 5157-block 36
     6462: 5157-block 37
branch  0 taken 5385
branch  1 taken 1077 (fallthrough)
        -: 5158:    {
     5385: 5159:        if (io.MouseClicked[i])
     5385: 5159-block 21
branch  0 taken 6 (fallthrough)
branch  1 taken 5379
        -: 5160:        {
       6*: 5161:            io.MouseDownOwned[i] = (g.HoveredWindow != NULL) || has_open_popup;
        6: 5161-block 22
branch  0 taken 0 (fallthrough)
branch  1 taken 6
    %%%%%: 5161-block 23
branch  2 never executed (fallthrough)
branch  3 never executed
        6: 5161-block 24
    %%%%%: 5161-block 25
       6*: 5162:            io.MouseDownOwnedUnlessPopupClose[i] = (g.HoveredWindow != NULL) || has_open_modal;
        6: 5162-block 26
branch  0 taken 0 (fallthrough)
branch  1 taken 6
    %%%%%: 5162-block 27
branch  2 never executed (fallthrough)
branch  3 never executed
        6: 5162-block 28
    %%%%%: 5162-block 29
        6: 5162-block 30
        -: 5163:        }
     5385: 5164:        mouse_any_down |= io.MouseDown[i];
     5385: 5165:        if (io.MouseDown[i] || io.MouseReleased[i]) // Increase release frame for our evaluation of earliest button (#1392)
     5385: 5165-block 31
branch  0 taken 5231 (fallthrough)
branch  1 taken 154
     5231: 5165-block 32
branch  2 taken 6 (fallthrough)
branch  3 taken 5225
     160*: 5166:            if (mouse_earliest_down == -1 || io.MouseClickedTime[i] < io.MouseClickedTime[mouse_earliest_down])
      160: 5166-block 33
branch  0 taken 0 (fallthrough)
branch  1 taken 160
    %%%%%: 5166-block 34
branch  2 never executed (fallthrough)
branch  3 never executed
      160: 5167:                mouse_earliest_down = i;
      160: 5167-block 35
        -: 5168:    }
    1077*: 5169:    const bool mouse_avail = (mouse_earliest_down == -1) || io.MouseDownOwned[mouse_earliest_down];
     1077: 5169-block 38
branch  0 taken 160 (fallthrough)
branch  1 taken 917
      160: 5169-block 39
branch  2 taken 160 (fallthrough)
branch  3 taken 0
     1077: 5169-block 40
    %%%%%: 5169-block 41
    1077*: 5170:    const bool mouse_avail_unless_popup_close = (mouse_earliest_down == -1) || io.MouseDownOwnedUnlessPopupClose[mouse_earliest_down];
     1077: 5170-block 42
branch  0 taken 160 (fallthrough)
branch  1 taken 917
      160: 5170-block 43
branch  2 taken 160 (fallthrough)
branch  3 taken 0
     1077: 5170-block 44
    %%%%%: 5170-block 45
        -: 5171:
        -: 5172:    // If mouse was first clicked outside of ImGui bounds we also cancel out hovering.
        -: 5173:    // FIXME: For patterns of drag and drop across OS windows, we may need to rework/remove this test (first committed 311c0ca9 on 2015/02)
    1077*: 5174:    const bool mouse_dragging_extern_payload = g.DragDropActive && (g.DragDropSourceFlags & ImGuiDragDropFlags_SourceExtern) != 0;
     1077: 5174-block 46
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 5174-block 47
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5174-block 48
     1077: 5174-block 49
    1077*: 5175:    if (!mouse_avail && !mouse_dragging_extern_payload)
     1077: 5175-block 50
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 5175-block 51
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 5176:        clear_hovered_windows = true;
    %%%%%: 5176-block 52
        -: 5177:
     1077: 5178:    if (clear_hovered_windows)
     1077: 5178-block 53
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####: 5179:        g.HoveredWindow = g.HoveredWindowUnderMovingWindow = NULL;
    %%%%%: 5179-block 54
        -: 5180:
        -: 5181:    // Update io.WantCaptureMouse for the user application (true = dispatch mouse info to Dear ImGui only, false = dispatch mouse to Dear ImGui + underlying app)
        -: 5182:    // Update io.WantCaptureMouseAllowPopupClose (experimental) to give a chance for app to react to popup closure with a drag
     1077: 5183:    if (g.WantCaptureMouseNextFrame != -1)
     1077: 5183-block 55
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
        -: 5184:    {
    #####: 5185:        io.WantCaptureMouse = io.WantCaptureMouseUnlessPopupClose = (g.WantCaptureMouseNextFrame != 0);
    %%%%%: 5185-block 56
        -: 5186:    }
        -: 5187:    else
        -: 5188:    {
     1077: 5189:        io.WantCaptureMouse = (mouse_avail && (g.HoveredWindow != NULL || mouse_any_down)) || has_open_popup;
     1077: 5189-block 57
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 5189-block 58
branch  2 taken 1 (fallthrough)
branch  3 taken 1076
        1: 5189-block 59
branch  4 taken 1 (fallthrough)
branch  5 taken 0
        1: 5189-block 60
branch  6 taken 0 (fallthrough)
branch  7 taken 1
     1076: 5189-block 61
        1: 5189-block 62
     1077: 5190:        io.WantCaptureMouseUnlessPopupClose = (mouse_avail_unless_popup_close && (g.HoveredWindow != NULL || mouse_any_down)) || has_open_modal;
     1077: 5190-block 63
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 5190-block 64
branch  2 taken 1 (fallthrough)
branch  3 taken 1076
        1: 5190-block 65
branch  4 taken 1 (fallthrough)
branch  5 taken 0
        1: 5190-block 66
branch  6 taken 0 (fallthrough)
branch  7 taken 1
     1076: 5190-block 67
        1: 5190-block 68
     1077: 5190-block 69
        -: 5191:    }
        -: 5192:
        -: 5193:    // Update io.WantCaptureKeyboard for the user application (true = dispatch keyboard info to Dear ImGui only, false = dispatch keyboard info to Dear ImGui + underlying app)
     1077: 5194:    io.WantCaptureKeyboard = false;
     1077: 5195:    if ((io.ConfigFlags & ImGuiConfigFlags_NoKeyboard) == 0)
     1077: 5195-block 70
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
        -: 5196:    {
     1077: 5197:        if ((g.ActiveId != 0) || (modal_window != NULL))
     1077: 5197-block 71
branch  0 taken 923 (fallthrough)
branch  1 taken 154
      923: 5197-block 72
branch  2 taken 0 (fallthrough)
branch  3 taken 923
      154: 5198:            io.WantCaptureKeyboard = true;
      154: 5198-block 73
      923: 5199:        else if (io.NavActive && (io.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) && io.ConfigNavCaptureKeyboard)
      923: 5199-block 74
branch  0 taken 632 (fallthrough)
branch  1 taken 291
      632: 5199-block 75
branch  2 taken 632 (fallthrough)
branch  3 taken 0
      632: 5199-block 76
branch  4 taken 632 (fallthrough)
branch  5 taken 0
      632: 5200:            io.WantCaptureKeyboard = true;
      632: 5200-block 77
        -: 5201:    }
     1077: 5202:    if (g.WantCaptureKeyboardNextFrame != -1) // Manual override
     1077: 5202-block 79
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####: 5203:        io.WantCaptureKeyboard = (g.WantCaptureKeyboardNextFrame != 0);
    %%%%%: 5203-block 80
        -: 5204:
        -: 5205:    // Update io.WantTextInput flag, this is to allow systems without a keyboard (e.g. mobile, hand-held) to show a software keyboard if possible
    1077*: 5206:    io.WantTextInput = (g.WantTextInputNextFrame != -1) ? (g.WantTextInputNextFrame != 0) : false;
     1077: 5206-block 81
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 5206-block 82
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5206-block 83
     1077: 5206-block 84
     1077: 5207:}
        -: 5208:
        -: 5209:// Calling SetupDrawListSharedData() is followed by SetCurrentFont() which sets up the remaining data.
function _ZL23SetupDrawListSharedDatav called 1077 returned 100% blocks executed 100%
     1077: 5210:static void SetupDrawListSharedData()
        -: 5211:{
     1077: 5212:    ImGuiContext& g = *GImGui;
     1077: 5213:    ImRect virtual_space(FLT_MAX, FLT_MAX, -FLT_MAX, -FLT_MAX);
     2154: 5214:    for (ImGuiViewportP* viewport : g.Viewports)
     1077: 5214-block 2
call    0 returned 1077
call    1 returned 1077
     2154: 5214-block 7
branch  2 taken 1077
branch  3 taken 1077 (fallthrough)
     1077: 5215:        virtual_space.Add(viewport->GetMainRect());
     1077: 5215-block 4
call    0 returned 1077
call    1 returned 1077
     1077: 5216:    g.DrawListSharedData.ClipRectFullscreen = virtual_space.ToVec4();
     1077: 5216-block 8
call    0 returned 1077
     1077: 5217:    g.DrawListSharedData.CurveTessellationTol = g.Style.CurveTessellationTol;
     1077: 5218:    g.DrawListSharedData.SetCircleTessellationMaxError(g.Style.CircleTessellationMaxError);
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077: 5219:    g.DrawListSharedData.InitialFlags = ImDrawListFlags_None;
     1077: 5220:    if (g.Style.AntiAliasedLines)
     1077: 5220-block 10
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 5221:        g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AntiAliasedLines;
     1077: 5221-block 11
     1077: 5222:    if (g.Style.AntiAliasedLinesUseTex && !(g.IO.Fonts->Flags & ImFontAtlasFlags_NoBakedLines))
     1077: 5222-block 12
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 5222-block 13
branch  2 taken 1077 (fallthrough)
branch  3 taken 0
     1077: 5223:        g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AntiAliasedLinesUseTex;
     1077: 5223-block 14
     1077: 5224:    if (g.Style.AntiAliasedFill)
     1077: 5224-block 15
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 5225:        g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AntiAliasedFill;
     1077: 5225-block 16
     1077: 5226:    if (g.IO.BackendFlags & ImGuiBackendFlags_RendererHasVtxOffset)
     1077: 5226-block 17
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 5227:        g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AllowVtxOffset;
     1077: 5227-block 18
     1077: 5228:}
     1077: 5228-block 19
        -: 5229:
function _ZN5ImGui8NewFrameEv called 1077 returned 100% blocks executed 71%
     1077: 5230:void ImGui::NewFrame()
        -: 5231:{
    1077*: 5232:    IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?");
     1077: 5232-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 5232-block 3
call    2 never executed
     1077: 5233:    ImGuiContext& g = *GImGui;
        -: 5234:
        -: 5235:    // Remove pending delete hooks before frame start.
        -: 5236:    // This deferred removal avoid issues of removal while iterating the hook vector
    1077*: 5237:    for (int n = g.Hooks.Size - 1; n >= 0; n--)
     1077: 5237-block 4
    %%%%%: 5237-block 9
     1077: 5237-block 10
branch  0 taken 0
branch  1 taken 1077 (fallthrough)
    #####: 5238:        if (g.Hooks[n].Type == ImGuiContextHookType_PendingRemoval_)
    %%%%%: 5238-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 5239:            g.Hooks.erase(&g.Hooks[n]);
    %%%%%: 5239-block 7
call    0 never executed
call    1 never executed
        -: 5240:
     1077: 5241:    CallContextHooks(&g, ImGuiContextHookType_NewFramePre);
     1077: 5241-block 11
call    0 returned 1077
        -: 5242:
        -: 5243:    // Check and assert for various common IO and Configuration mistakes
     1077: 5244:    g.ConfigFlagsLastFrame = g.ConfigFlagsCurrFrame;
     1077: 5245:    ErrorCheckNewFrameSanityChecks();
call    0 returned 1077
     1077: 5246:    g.ConfigFlagsCurrFrame = g.IO.ConfigFlags;
        -: 5247:
        -: 5248:    // Load settings on first frame, save settings when modified (after a delay)
     1077: 5249:    UpdateSettings();
call    0 returned 1077
        -: 5250:
     1077: 5251:    g.Time += g.IO.DeltaTime;
     1077: 5252:    g.WithinFrameScope = true;
     1077: 5253:    g.FrameCount += 1;
     1077: 5254:    g.TooltipOverrideCount = 0;
     1077: 5255:    g.WindowsActiveCount = 0;
     1077: 5256:    g.MenusIdSubmittedThisFrame.resize(0);
call    0 returned 1077
        -: 5257:
        -: 5258:    // Calculate frame-rate for the user, as a purely luxurious feature
     1077: 5259:    g.FramerateSecPerFrameAccum += g.IO.DeltaTime - g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx];
     1077: 5260:    g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx] = g.IO.DeltaTime;
     1077: 5261:    g.FramerateSecPerFrameIdx = (g.FramerateSecPerFrameIdx + 1) % IM_ARRAYSIZE(g.FramerateSecPerFrame);
     1077: 5262:    g.FramerateSecPerFrameCount = ImMin(g.FramerateSecPerFrameCount + 1, IM_ARRAYSIZE(g.FramerateSecPerFrame));
call    0 returned 1077
    1077*: 5263:    g.IO.Framerate = (g.FramerateSecPerFrameAccum > 0.0f) ? (1.0f / (g.FramerateSecPerFrameAccum / (float)g.FramerateSecPerFrameCount)) : FLT_MAX;
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 5263-block 17
    %%%%%: 5263-block 18
        -: 5264:
        -: 5265:    // Process input queue (trickle as many events as possible), turn events into writes to IO structure
     1077: 5266:    g.InputEventsTrail.resize(0);
     1077: 5266-block 19
call    0 returned 1077
     1077: 5267:    UpdateInputEvents(g.IO.ConfigInputTrickleEventQueue);
call    0 returned 1077
        -: 5268:
        -: 5269:    // Update viewports (after processing input queue, so io.MouseHoveredViewport is set)
     1077: 5270:    UpdateViewportsNewFrame();
call    0 returned 1077
        -: 5271:
        -: 5272:    // Setup current font and draw list shared data
        -: 5273:    // FIXME-VIEWPORT: the concept of a single ClipRectFullscreen is not ideal!
     1077: 5274:    g.IO.Fonts->Locked = true;
     1077: 5275:    SetupDrawListSharedData();
call    0 returned 1077
     1077: 5276:    SetCurrentFont(GetDefaultFont());
call    0 returned 1077
call    1 returned 1077
    1077*: 5277:    IM_ASSERT(g.Font->IsLoaded());
call    0 returned 1077
branch  1 taken 0 (fallthrough)
branch  2 taken 1077
    %%%%%: 5277-block 27
call    3 never executed
        -: 5278:
        -: 5279:    // Mark rendering data as invalid to prevent user who may have a handle on it to use it.
     2154: 5280:    for (ImGuiViewportP* viewport : g.Viewports)
     1077: 5280-block 28
call    0 returned 1077
call    1 returned 1077
     2154: 5280-block 31
branch  2 taken 1077
branch  3 taken 1077 (fallthrough)
        -: 5281:    {
     1077: 5282:        viewport->DrawData = NULL;
     1077: 5283:        viewport->DrawDataP.Valid = false;
     1077: 5283-block 30
        -: 5284:    }
        -: 5285:
        -: 5286:    // Drag and drop keep the source ID alive so even if the source disappear our state is consistent
    1077*: 5287:    if (g.DragDropActive && g.DragDropPayload.SourceId == g.ActiveId)
     1077: 5287-block 32
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 5287-block 33
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 5288:        KeepAliveID(g.DragDropPayload.SourceId);
    %%%%%: 5288-block 34
call    0 never executed
        -: 5289:
        -: 5290:    // [DEBUG]
     1077: 5291:    if (!g.IO.ConfigDebugHighlightIdConflicts || !g.IO.KeyCtrl) // Count is locked while holding CTRL
     1077: 5291-block 35
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 5291-block 36
branch  2 taken 1077 (fallthrough)
branch  3 taken 0
     1077: 5292:        g.DebugDrawIdConflicts = 0;
     1077: 5292-block 37
     1077: 5293:    if (g.IO.ConfigDebugHighlightIdConflicts && g.HoveredIdPreviousFrameItemCount > 1)
     1077: 5293-block 38
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 5293-block 39
branch  2 taken 0 (fallthrough)
branch  3 taken 1077
    #####: 5294:        g.DebugDrawIdConflicts = g.HoveredIdPreviousFrame;
    %%%%%: 5294-block 40
        -: 5295:
        -: 5296:    // Update HoveredId data
     1077: 5297:    if (!g.HoveredIdPreviousFrame)
     1077: 5297-block 41
branch  0 taken 865 (fallthrough)
branch  1 taken 212
      865: 5298:        g.HoveredIdTimer = 0.0f;
      865: 5298-block 42
     1077: 5299:    if (!g.HoveredIdPreviousFrame || (g.HoveredId && g.ActiveId == g.HoveredId))
     1077: 5299-block 43
branch  0 taken 212 (fallthrough)
branch  1 taken 865
      212: 5299-block 44
branch  2 taken 204 (fallthrough)
branch  3 taken 8
      204: 5299-block 45
branch  4 taken 39 (fallthrough)
branch  5 taken 165
      904: 5300:        g.HoveredIdNotActiveTimer = 0.0f;
      904: 5300-block 46
     1077: 5301:    if (g.HoveredId)
     1077: 5301-block 47
branch  0 taken 212 (fallthrough)
branch  1 taken 865
      212: 5302:        g.HoveredIdTimer += g.IO.DeltaTime;
      212: 5302-block 48
     1077: 5303:    if (g.HoveredId && g.ActiveId != g.HoveredId)
     1077: 5303-block 49
branch  0 taken 212 (fallthrough)
branch  1 taken 865
      212: 5303-block 50
branch  2 taken 173 (fallthrough)
branch  3 taken 39
      173: 5304:        g.HoveredIdNotActiveTimer += g.IO.DeltaTime;
      173: 5304-block 51
     1077: 5305:    g.HoveredIdPreviousFrame = g.HoveredId;
     1077: 5306:    g.HoveredIdPreviousFrameItemCount = 0;
     1077: 5307:    g.HoveredId = 0;
     1077: 5308:    g.HoveredIdAllowOverlap = false;
     1077: 5309:    g.HoveredIdIsDisabled = false;
        -: 5310:
        -: 5311:    // Clear ActiveID if the item is not alive anymore.
        -: 5312:    // In 1.87, the common most call to KeepAliveID() was moved from GetID() to ItemAdd().
        -: 5313:    // As a result, custom widget using ButtonBehavior() _without_ ItemAdd() need to call KeepAliveID() themselves.
    1077*: 5314:    if (g.ActiveId != 0 && g.ActiveIdIsAlive != g.ActiveId && g.ActiveIdPreviousFrame == g.ActiveId)
     1077: 5314-block 52
branch  0 taken 154 (fallthrough)
branch  1 taken 923
      154: 5314-block 53
branch  2 taken 0 (fallthrough)
branch  3 taken 154
    %%%%%: 5314-block 54
branch  4 never executed (fallthrough)
branch  5 never executed
        -: 5315:    {
    #####: 5316:        IMGUI_DEBUG_LOG_ACTIVEID("NewFrame(): ClearActiveID() because it isn't marked alive anymore!\n");
    %%%%%: 5316-block 55
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5316-block 56
call    2 never executed
    #####: 5317:        ClearActiveID();
    %%%%%: 5317-block 57
call    0 never executed
        -: 5318:    }
        -: 5319:
        -: 5320:    // Update ActiveId data (clear reference to active widget if the widget isn't alive anymore)
     1077: 5321:    if (g.ActiveId)
     1077: 5321-block 58
branch  0 taken 154 (fallthrough)
branch  1 taken 923
      154: 5322:        g.ActiveIdTimer += g.IO.DeltaTime;
      154: 5322-block 59
     1077: 5323:    g.LastActiveIdTimer += g.IO.DeltaTime;
     1077: 5324:    g.ActiveIdPreviousFrame = g.ActiveId;
     1077: 5325:    g.ActiveIdPreviousFrameWindow = g.ActiveIdWindow;
     1077: 5326:    g.ActiveIdPreviousFrameHasBeenEditedBefore = g.ActiveIdHasBeenEditedBefore;
     1077: 5327:    g.ActiveIdIsAlive = 0;
     1077: 5328:    g.ActiveIdHasBeenEditedThisFrame = false;
     1077: 5329:    g.ActiveIdPreviousFrameIsAlive = false;
     1077: 5330:    g.ActiveIdIsJustActivated = false;
    1077*: 5331:    if (g.TempInputId != 0 && g.ActiveId != g.TempInputId)
     1077: 5331-block 60
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 5331-block 61
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 5332:        g.TempInputId = 0;
    %%%%%: 5332-block 62
     1077: 5333:    if (g.ActiveId == 0)
     1077: 5333-block 63
branch  0 taken 923 (fallthrough)
branch  1 taken 154
        -: 5334:    {
      923: 5335:        g.ActiveIdUsingNavDirMask = 0x00;
      923: 5336:        g.ActiveIdUsingAllKeyboardKeys = false;
      923: 5336-block 64
        -: 5337:    }
        -: 5338:
        -: 5339:    // Record when we have been stationary as this state is preserved while over same item.
        -: 5340:    // FIXME: The way this is expressed means user cannot alter HoverStationaryDelay during the frame to use varying values.
        -: 5341:    // To allow this we should store HoverItemMaxStationaryTime+ID and perform the >= check in IsItemHovered() function.
    1077*: 5342:    if (g.HoverItemDelayId != 0 && g.MouseStationaryTimer >= g.Style.HoverStationaryDelay)
     1077: 5342-block 65
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 5342-block 66
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 5343:        g.HoverItemUnlockedStationaryId = g.HoverItemDelayId;
    %%%%%: 5343-block 67
     1077: 5344:    else if (g.HoverItemDelayId == 0)
     1077: 5344-block 68
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 5345:        g.HoverItemUnlockedStationaryId = 0;
     1077: 5345-block 69
     1077: 5346:    if (g.HoveredWindow != NULL && g.MouseStationaryTimer >= g.Style.HoverStationaryDelay)
     1077: 5346-block 70
branch  0 taken 1075 (fallthrough)
branch  1 taken 2
     1075: 5346-block 71
branch  2 taken 418 (fallthrough)
branch  3 taken 657
      418: 5347:        g.HoverWindowUnlockedStationaryId = g.HoveredWindow->ID;
      418: 5347-block 72
      659: 5348:    else if (g.HoveredWindow == NULL)
      659: 5348-block 73
branch  0 taken 2 (fallthrough)
branch  1 taken 657
        2: 5349:        g.HoverWindowUnlockedStationaryId = 0;
        2: 5349-block 74
        -: 5350:
        -: 5351:    // Update hover delay for IsItemHovered() with delays and tooltips
     1077: 5352:    g.HoverItemDelayIdPreviousFrame = g.HoverItemDelayId;
     1077: 5353:    if (g.HoverItemDelayId != 0)
     1077: 5353-block 75
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
        -: 5354:    {
    #####: 5355:        g.HoverItemDelayTimer += g.IO.DeltaTime;
    #####: 5356:        g.HoverItemDelayClearTimer = 0.0f;
    #####: 5357:        g.HoverItemDelayId = 0;
    %%%%%: 5357-block 76
        -: 5358:    }
     1077: 5359:    else if (g.HoverItemDelayTimer > 0.0f)
     1077: 5359-block 77
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
        -: 5360:    {
        -: 5361:        // This gives a little bit of leeway before clearing the hover timer, allowing mouse to cross gaps
        -: 5362:        // We could expose 0.25f as style.HoverClearDelay but I am not sure of the logic yet, this is particularly subtle.
    #####: 5363:        g.HoverItemDelayClearTimer += g.IO.DeltaTime;
    #####: 5364:        if (g.HoverItemDelayClearTimer >= ImMax(0.25f, g.IO.DeltaTime * 2.0f)) // ~7 frames at 30 Hz + allow for low framerate
    %%%%%: 5364-block 78
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 5365:            g.HoverItemDelayTimer = g.HoverItemDelayClearTimer = 0.0f; // May want a decaying timer, in which case need to clamp at max first, based on max of caller last requested timer.
    %%%%%: 5365-block 80
        -: 5366:    }
        -: 5367:
        -: 5368:    // Drag and drop
     1077: 5369:    g.DragDropAcceptIdPrev = g.DragDropAcceptIdCurr;
     1077: 5370:    g.DragDropAcceptIdCurr = 0;
     1077: 5371:    g.DragDropAcceptIdCurrRectSurface = FLT_MAX;
     1077: 5372:    g.DragDropWithinSource = false;
     1077: 5373:    g.DragDropWithinTarget = false;
     1077: 5374:    g.DragDropHoldJustPressedId = 0;
     1077: 5375:    g.TooltipPreviousWindow = NULL;
        -: 5376:
        -: 5377:    // Close popups on focus lost (currently wip/opt-in)
        -: 5378:    //if (g.IO.AppFocusLost)
        -: 5379:    //    ClosePopupsExceptModals();
        -: 5380:
        -: 5381:    // Update keyboard input state
     1077: 5382:    UpdateKeyboardInputs();
     1077: 5382-block 81
call    0 returned 1077
        -: 5383:
        -: 5384:    //IM_ASSERT(g.IO.KeyCtrl == IsKeyDown(ImGuiKey_LeftCtrl) || IsKeyDown(ImGuiKey_RightCtrl));
        -: 5385:    //IM_ASSERT(g.IO.KeyShift == IsKeyDown(ImGuiKey_LeftShift) || IsKeyDown(ImGuiKey_RightShift));
        -: 5386:    //IM_ASSERT(g.IO.KeyAlt == IsKeyDown(ImGuiKey_LeftAlt) || IsKeyDown(ImGuiKey_RightAlt));
        -: 5387:    //IM_ASSERT(g.IO.KeySuper == IsKeyDown(ImGuiKey_LeftSuper) || IsKeyDown(ImGuiKey_RightSuper));
        -: 5388:
        -: 5389:    // Update keyboard/gamepad navigation
     1077: 5390:    NavUpdate();
call    0 returned 1077
        -: 5391:
        -: 5392:    // Update mouse input state
     1077: 5393:    UpdateMouseInputs();
call    0 returned 1077
        -: 5394:
        -: 5395:    // Undocking
        -: 5396:    // (needs to be before UpdateMouseMovingWindowNewFrame so the window is already offset and following the mouse on the detaching frame)
     1077: 5397:    DockContextNewFrameUpdateUndocking(&g);
call    0 returned 1077
        -: 5398:
        -: 5399:    // Mark all windows as not visible and compact unused memory.
    1077*: 5400:    IM_ASSERT(g.WindowsFocusOrder.Size <= g.Windows.Size);
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 5400-block 86
call    2 never executed
    1077*: 5401:    const float memory_compact_start_time = (g.GcCompactAll || g.IO.ConfigMemoryCompactTimer < 0.0f) ? FLT_MAX : (float)g.Time - g.IO.ConfigMemoryCompactTimer;
     1077: 5401-block 87
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 5401-block 88
branch  2 taken 1077 (fallthrough)
branch  3 taken 0
     1077: 5401-block 89
    %%%%%: 5401-block 90
    18153: 5402:    for (ImGuiWindow* window : g.Windows)
     1077: 5402-block 91
call    0 returned 1077
call    1 returned 1077
    17076: 5402-block 97
    18153: 5402-block 98
branch  2 taken 17076
branch  3 taken 1077 (fallthrough)
        -: 5403:    {
    17076: 5404:        window->WasActive = window->Active;
    17076: 5405:        window->Active = false;
    17076: 5406:        window->WriteAccessed = false;
    17076: 5407:        window->BeginCountPreviousFrame = window->BeginCount;
    17076: 5408:        window->BeginCount = 0;
        -: 5409:
        -: 5410:        // Garbage collect transient buffers of recently unused windows
    17076: 5411:        if (!window->WasActive && !window->MemoryCompacted && window->LastTimeActive < memory_compact_start_time)
    17076: 5411-block 93
branch  0 taken 1799 (fallthrough)
branch  1 taken 15277
     1799: 5411-block 94
branch  2 taken 1799 (fallthrough)
branch  3 taken 0
     1799: 5411-block 95
branch  4 taken 0 (fallthrough)
branch  5 taken 1799
    #####: 5412:            GcCompactTransientWindowBuffers(window);
    %%%%%: 5412-block 96
call    0 never executed
        -: 5413:    }
        -: 5414:
        -: 5415:    // Find hovered window
        -: 5416:    // (needs to be before UpdateMouseMovingWindowNewFrame so we fill g.HoveredWindowUnderMovingWindow on the mouse release frame)
        -: 5417:    // (currently needs to be done after the WasActive=Active loop and FindHoveredWindowEx uses ->Active)
     1077: 5418:    UpdateHoveredWindowAndCaptureFlags();
     1077: 5418-block 99
call    0 returned 1077
        -: 5419:
        -: 5420:    // Handle user moving window with mouse (at the beginning of the frame to avoid input lag or sheering)
     1077: 5421:    UpdateMouseMovingWindowNewFrame();
call    0 returned 1077
        -: 5422:
        -: 5423:    // Background darkening/whitening
    1077*: 5424:    if (GetTopMostPopupModal() != NULL || (g.NavWindowingTarget != NULL && g.NavWindowingHighlightAlpha > 0.0f))
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0
     1077: 5424-block 103
branch  3 taken 0 (fallthrough)
branch  4 taken 1077
    %%%%%: 5424-block 104
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 5424-block 105
     1077: 5424-block 106
     1077: 5424-block 107
branch  7 taken 0 (fallthrough)
branch  8 taken 1077
    #####: 5425:        g.DimBgRatio = ImMin(g.DimBgRatio + g.IO.DeltaTime * 6.0f, 1.0f);
    %%%%%: 5425-block 108
call    0 never executed
        -: 5426:    else
     1077: 5427:        g.DimBgRatio = ImMax(g.DimBgRatio - g.IO.DeltaTime * 10.0f, 0.0f);
     1077: 5427-block 110
call    0 returned 1077
        -: 5428:
     1077: 5429:    g.MouseCursor = ImGuiMouseCursor_Arrow;
     1077: 5430:    g.WantCaptureMouseNextFrame = g.WantCaptureKeyboardNextFrame = g.WantTextInputNextFrame = -1;
        -: 5431:
        -: 5432:    // Platform IME data: reset for the frame
     1077: 5433:    g.PlatformImeDataPrev = g.PlatformImeData;
     1077: 5434:    g.PlatformImeData.WantVisible = false;
        -: 5435:
        -: 5436:    // Mouse wheel scrolling, scale
     1077: 5437:    UpdateMouseWheel();
     1077: 5437-block 112
call    0 returned 1077
        -: 5438:
        -: 5439:    // Garbage collect transient buffers of recently unused tables
     2153: 5440:    for (int i = 0; i < g.TablesLastTimeActive.Size; i++)
     1076: 5440-block 123
     2153: 5440-block 124
branch  0 taken 1076
branch  1 taken 1077 (fallthrough)
    1076*: 5441:        if (g.TablesLastTimeActive[i] >= 0.0f && g.TablesLastTimeActive[i] < memory_compact_start_time)
     1076: 5441-block 114
call    0 returned 1076
branch  1 taken 1076 (fallthrough)
branch  2 taken 0
     1076: 5441-block 116
call    3 returned 1076
branch  4 taken 0 (fallthrough)
branch  5 taken 1076
    %%%%%: 5441-block 118
     1076: 5441-block 119
     1076: 5441-block 120
branch  6 taken 0 (fallthrough)
branch  7 taken 1076
    #####: 5442:            TableGcCompactTransientBuffers(g.Tables.GetByIndex(i));
    %%%%%: 5442-block 121
call    0 never executed
call    1 never executed
     2153: 5443:    for (ImGuiTableTempData& table_temp_data : g.TablesTempData)
     1077: 5443-block 125
call    0 returned 1077
call    1 returned 1077
     1076: 5443-block 130
     2153: 5443-block 131
branch  2 taken 1076
branch  3 taken 1077 (fallthrough)
     1076: 5444:        if (table_temp_data.LastTimeActive >= 0.0f && table_temp_data.LastTimeActive < memory_compact_start_time)
     1076: 5444-block 127
branch  0 taken 1076 (fallthrough)
branch  1 taken 0
     1076: 5444-block 128
branch  2 taken 0 (fallthrough)
branch  3 taken 1076
    #####: 5445:            TableGcCompactTransientBuffers(&table_temp_data);
    %%%%%: 5445-block 129
call    0 never executed
     1077: 5446:    if (g.GcCompactAll)
     1077: 5446-block 132
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####: 5447:        GcCompactTransientMiscBuffers();
    %%%%%: 5447-block 133
call    0 never executed
     1077: 5448:    g.GcCompactAll = false;
        -: 5449:
        -: 5450:    // Closing the focused window restore focus to the first active root window in descending z-order
     1077: 5451:    if (g.NavWindow && !g.NavWindow->WasActive)
     1077: 5451-block 134
branch  0 taken 1076 (fallthrough)
branch  1 taken 1
     1076: 5451-block 135
branch  2 taken 0 (fallthrough)
branch  3 taken 1076
    #####: 5452:        FocusTopMostWindowUnderOne(NULL, NULL, NULL, ImGuiFocusRequestFlags_RestoreFocusedChild);
    %%%%%: 5452-block 136
call    0 never executed
        -: 5453:
        -: 5454:    // No window should be open at the beginning of the frame.
        -: 5455:    // But in order to allow the user to call NewFrame() multiple times without calling Render(), we are doing an explicit clear.
     1077: 5456:    g.CurrentWindowStack.resize(0);
     1077: 5456-block 137
call    0 returned 1077
     1077: 5457:    g.BeginPopupStack.resize(0);
call    0 returned 1077
     1077: 5458:    g.ItemFlagsStack.resize(0);
call    0 returned 1077
     1077: 5459:    g.ItemFlagsStack.push_back(ImGuiItemFlags_AutoClosePopups); // Default flags
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077: 5460:    g.CurrentItemFlags = g.ItemFlagsStack.back();
     1077: 5460-block 141
call    0 returned 1077
     1077: 5461:    g.GroupStack.resize(0);
call    0 returned 1077
        -: 5462:
        -: 5463:    // Docking
     1077: 5464:    DockContextNewFrameUpdateDocking(&g);
call    0 returned 1077
        -: 5465:
        -: 5466:    // [DEBUG] Update debug features
        -: 5467:#ifndef IMGUI_DISABLE_DEBUG_TOOLS
     1077: 5468:    UpdateDebugToolItemPicker();
call    0 returned 1077
     1077: 5469:    UpdateDebugToolStackQueries();
call    0 returned 1077
     1077: 5470:    UpdateDebugToolFlashStyleColor();
call    0 returned 1077
    1077*: 5471:    if (g.DebugLocateFrames > 0 && --g.DebugLocateFrames == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 5471-block 148
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5471-block 149
     1077: 5471-block 150
     1077: 5471-block 151
branch  4 taken 0 (fallthrough)
branch  5 taken 1077
        -: 5472:    {
    #####: 5473:        g.DebugLocateId = 0;
    #####: 5474:        g.DebugBreakInLocateId = false;
    %%%%%: 5474-block 152
        -: 5475:    }
    1077*: 5476:    if (g.DebugLogAutoDisableFrames > 0 && --g.DebugLogAutoDisableFrames == 0)
     1077: 5476-block 153
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 5476-block 154
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5476-block 155
     1077: 5476-block 156
     1077: 5476-block 157
branch  4 taken 0 (fallthrough)
branch  5 taken 1077
        -: 5477:    {
    #####: 5478:        DebugLog("(Debug Log: Auto-disabled some ImGuiDebugLogFlags after 2 frames)\n");
    %%%%%: 5478-block 158
call    0 never executed
    #####: 5479:        g.DebugLogFlags &= ~g.DebugLogAutoDisableFlags;
    #####: 5480:        g.DebugLogAutoDisableFlags = ImGuiDebugLogFlags_None;
        -: 5481:    }
        -: 5482:#endif
        -: 5483:
        -: 5484:    // Create implicit/fallback window - which we will only render it if the user has added something to it.
        -: 5485:    // We don't use "Debug" to avoid colliding with user trying to create a "Debug" window with custom flags.
        -: 5486:    // This fallback is particularly important as it prevents ImGui:: calls from crashing.
     1077: 5487:    g.WithinFrameScopeWithImplicitWindow = true;
     1077: 5488:    SetNextWindowSize(ImVec2(400, 400), ImGuiCond_FirstUseEver);
     1077: 5488-block 160
call    0 returned 1077
call    1 returned 1077
     1077: 5489:    Begin("Debug##Default");
call    0 returned 1077
    1077*: 5490:    IM_ASSERT(g.CurrentWindow->IsFallbackWindow == true);
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 5490-block 164
call    2 never executed
        -: 5491:
        -: 5492:    // Store stack sizes
     1077: 5493:    g.ErrorCountCurrentFrame = 0;
     1077: 5494:    ErrorRecoveryStoreState(&g.StackSizesInNewFrame);
     1077: 5494-block 165
call    0 returned 1077
        -: 5495:
        -: 5496:    // [DEBUG] When io.ConfigDebugBeginReturnValue is set, we make Begin()/BeginChild() return false at different level of the window-stack,
        -: 5497:    // allowing to validate correct Begin/End behavior in user code.
        -: 5498:#ifndef IMGUI_DISABLE_DEBUG_TOOLS
     1077: 5499:    if (g.IO.ConfigDebugBeginReturnValueLoop)
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####: 5500:        g.DebugBeginReturnValueCullDepth = (g.DebugBeginReturnValueCullDepth == -1) ? 0 : ((g.DebugBeginReturnValueCullDepth + ((g.FrameCount % 4) == 0 ? 1 : 0)) % 10);
    %%%%%: 5500-block 167
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5500-block 168
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5500-block 169
    %%%%%: 5500-block 170
    %%%%%: 5500-block 171
    %%%%%: 5500-block 172
    %%%%%: 5500-block 173
        -: 5501:    else
     1077: 5502:        g.DebugBeginReturnValueCullDepth = -1;
     1077: 5502-block 174
        -: 5503:#endif
        -: 5504:
     1077: 5505:    CallContextHooks(&g, ImGuiContextHookType_NewFramePost);
     1077: 5505-block 175
call    0 returned 1077
     1077: 5506:}
        -: 5507:
        -: 5508:// FIXME: Add a more explicit sort order in the window structure.
function _ZL19ChildWindowComparerPKvS0_ called 6462 returned 100% blocks executed 67%
     6462: 5509:static int IMGUI_CDECL ChildWindowComparer(const void* lhs, const void* rhs)
        -: 5510:{
     6462: 5511:    const ImGuiWindow* const a = *(const ImGuiWindow* const *)lhs;
     6462: 5512:    const ImGuiWindow* const b = *(const ImGuiWindow* const *)rhs;
     6462: 5513:    if (int d = (a->Flags & ImGuiWindowFlags_Popup) - (b->Flags & ImGuiWindowFlags_Popup))
     6462: 5513-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 6462
    #####: 5514:        return d;
    %%%%%: 5514-block 3
     6462: 5515:    if (int d = (a->Flags & ImGuiWindowFlags_Tooltip) - (b->Flags & ImGuiWindowFlags_Tooltip))
     6462: 5515-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 6462
    #####: 5516:        return d;
    %%%%%: 5516-block 5
     6462: 5517:    return (a->BeginOrderWithinParent - b->BeginOrderWithinParent);
     6462: 5517-block 6
        -: 5518:}
        -: 5519:
function _ZL21AddWindowToSortBufferP8ImVectorIP11ImGuiWindowES1_ called 17092 returned 100% blocks executed 100%
    17092: 5520:static void AddWindowToSortBuffer(ImVector<ImGuiWindow*>* out_sorted_windows, ImGuiWindow* window)
        -: 5521:{
    17092: 5522:    out_sorted_windows->push_back(window);
    17092: 5522-block 2
call    0 returned 17092
    17092: 5523:    if (window->Active)
branch  0 taken 15291 (fallthrough)
branch  1 taken 1801
        -: 5524:    {
    15291: 5525:        int count = window->DC.ChildWindows.Size;
    15291: 5526:        ImQsort(window->DC.ChildWindows.Data, (size_t)count, sizeof(ImGuiWindow*), ChildWindowComparer);
    15291: 5526-block 4
call    0 returned 15291
    28215: 5527:        for (int i = 0; i < count; i++)
    12924: 5527-block 9
    28215: 5527-block 10
branch  0 taken 12924
branch  1 taken 15291 (fallthrough)
        -: 5528:        {
    12924: 5529:            ImGuiWindow* child = window->DC.ChildWindows[i];
    12924: 5529-block 6
call    0 returned 12924
    12924: 5530:            if (child->Active)
branch  0 taken 12924 (fallthrough)
branch  1 taken 0
    12924: 5531:                AddWindowToSortBuffer(out_sorted_windows, child);
    12924: 5531-block 8
call    0 returned 12924
        -: 5532:        }
        -: 5533:    }
    17092: 5534:}
        -: 5535:
function _ZL19AddWindowToDrawDataP11ImGuiWindowi called 15271 returned 100% blocks executed 92%
    15271: 5536:static void AddWindowToDrawData(ImGuiWindow* window, int layer)
        -: 5537:{
    15271: 5538:    ImGuiContext& g = *GImGui;
    15271: 5539:    ImGuiViewportP* viewport = window->Viewport;
   15271*: 5540:    IM_ASSERT(viewport != NULL);
    15271: 5540-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 15271
    %%%%%: 5540-block 3
call    2 never executed
    15271: 5541:    g.IO.MetricsRenderWindows++;
    15271: 5542:    if (window->DrawList->_Splitter._Count > 1)
    15271: 5542-block 4
branch  0 taken 1077 (fallthrough)
branch  1 taken 14194
     1077: 5543:        window->DrawList->ChannelsMerge(); // Merge if user forgot to merge back. Also required in Docking branch for ImGuiWindowFlags_DockNodeHost windows.
     1077: 5543-block 5
call    0 returned 1077
    15271: 5544:    ImGui::AddDrawListToDrawDataEx(&viewport->DrawDataP, viewport->DrawDataBuilder.Layers[layer], window->DrawList);
    15271: 5544-block 6
call    0 returned 15271
    28189: 5545:    for (ImGuiWindow* child : window->DC.ChildWindows)
call    0 returned 15271
call    1 returned 15271
    12918: 5545-block 12
    28189: 5545-block 13
branch  2 taken 12918
branch  3 taken 15271 (fallthrough)
    12918: 5546:        if (IsWindowActiveAndVisible(child)) // Clipped children may have been marked not active
    12918: 5546-block 9
call    0 returned 12918
branch  1 taken 12913 (fallthrough)
branch  2 taken 5
    12913: 5547:            AddWindowToDrawData(child, layer);
    12913: 5547-block 11
call    0 returned 12913
    15271: 5548:}
        -: 5549:
function _ZL21GetWindowDisplayLayerP11ImGuiWindow called 2358 returned 100% blocks executed 100%
     2358: 5550:static inline int GetWindowDisplayLayer(ImGuiWindow* window)
        -: 5551:{
     2358: 5552:    return (window->Flags & ImGuiWindowFlags_Tooltip) ? 1 : 0;
     2358: 5552-block 2
        -: 5553:}
        -: 5554:
        -: 5555:// Layer is locked for the root window, however child windows may use a different viewport (e.g. extruding menu)
function _ZL23AddRootWindowToDrawDataP11ImGuiWindow called 2358 returned 100% blocks executed 100%
     2358: 5556:static inline void AddRootWindowToDrawData(ImGuiWindow* window)
        -: 5557:{
     2358: 5558:    AddWindowToDrawData(window, GetWindowDisplayLayer(window));
     2358: 5558-block 2
call    0 returned 2358
call    1 returned 2358
     2358: 5559:}
        -: 5560:
function _ZL30FlattenDrawDataIntoSingleLayerP17ImDrawDataBuilder called 1077 returned 100% blocks executed 100%
     1077: 5561:static void FlattenDrawDataIntoSingleLayer(ImDrawDataBuilder* builder)
        -: 5562:{
     1077: 5563:    int n = builder->Layers[0]->Size;
     1077: 5564:    int full_size = n;
     2154: 5565:    for (int i = 1; i < IM_ARRAYSIZE(builder->Layers); i++)
     1077: 5565-block 2
     2154: 5565-block 4
branch  0 taken 1077
branch  1 taken 1077 (fallthrough)
     1077: 5566:        full_size += builder->Layers[i]->Size;
     1077: 5566-block 3
     1077: 5567:    builder->Layers[0]->resize(full_size);
     1077: 5567-block 5
call    0 returned 1077
     2154: 5568:    for (int layer_n = 1; layer_n < IM_ARRAYSIZE(builder->Layers); layer_n++)
     1077: 5568-block 11
     2154: 5568-block 12
branch  0 taken 1077
branch  1 taken 1077 (fallthrough)
        -: 5569:    {
     1077: 5570:        ImVector<ImDrawList*>* layer = builder->Layers[layer_n];
     1077: 5571:        if (layer->empty())
     1077: 5571-block 7
call    0 returned 1077
branch  1 taken 873 (fallthrough)
branch  2 taken 204
      873: 5572:            continue;
      873: 5572-block 9
      204: 5573:        memcpy(builder->Layers[0]->Data + n, layer->Data, layer->Size * sizeof(ImDrawList*));
      204: 5574:        n += layer->Size;
      204: 5575:        layer->resize(0);
      204: 5575-block 10
call    0 returned 204
        -: 5576:    }
     1077: 5577:}
        -: 5578:
function _ZL20InitViewportDrawDataP14ImGuiViewportP called 1077 returned 100% blocks executed 86%
     1077: 5579:static void InitViewportDrawData(ImGuiViewportP* viewport)
        -: 5580:{
     1077: 5581:    ImGuiIO& io = ImGui::GetIO();
     1077: 5581-block 2
call    0 returned 1077
     1077: 5582:    ImDrawData* draw_data = &viewport->DrawDataP;
        -: 5583:
     1077: 5584:    viewport->DrawData = draw_data; // Make publicly accessible
     1077: 5585:    viewport->DrawDataBuilder.Layers[0] = &draw_data->CmdLists;
     1077: 5586:    viewport->DrawDataBuilder.Layers[1] = &viewport->DrawDataBuilder.LayerData1;
     1077: 5587:    viewport->DrawDataBuilder.Layers[0]->resize(0);
call    0 returned 1077
     1077: 5588:    viewport->DrawDataBuilder.Layers[1]->resize(0);
call    0 returned 1077
        -: 5589:
        -: 5590:    // When minimized, we report draw_data->DisplaySize as zero to be consistent with non-viewport mode,
        -: 5591:    // and to allow applications/backends to easily skip rendering.
        -: 5592:    // FIXME: Note that we however do NOT attempt to report "zero drawlist / vertices" into the ImDrawData structure.
        -: 5593:    // This is because the work has been done already, and its wasted! We should fix that and add optimizations for
        -: 5594:    // it earlier in the pipeline, rather than pretend to hide the data at the end of the pipeline.
     1077: 5595:    const bool is_minimized = (viewport->Flags & ImGuiViewportFlags_IsMinimized) != 0;
        -: 5596:
     1077: 5597:    draw_data->Valid = true;
     1077: 5598:    draw_data->CmdListsCount = 0;
     1077: 5599:    draw_data->TotalVtxCount = draw_data->TotalIdxCount = 0;
     1077: 5600:    draw_data->DisplayPos = viewport->Pos;
    1077*: 5601:    draw_data->DisplaySize = is_minimized ? ImVec2(0.0f, 0.0f) : viewport->Size;
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 5601-block 6
call    2 never executed
     1077: 5601-block 7
     1077: 5602:    draw_data->FramebufferScale = io.DisplayFramebufferScale; // FIXME-VIEWPORT: This may vary on a per-monitor/viewport basis?
     1077: 5603:    draw_data->OwnerViewport = viewport;
     1077: 5604:}
        -: 5605:
        -: 5606:// Push a clipping rectangle for both ImGui logic (hit-testing etc.) and low-level ImDrawList rendering.
        -: 5607:// - When using this function it is sane to ensure that float are perfectly rounded to integer values,
        -: 5608://   so that e.g. (int)(max.x-min.x) in user's render produce correct result.
        -: 5609:// - If the code here changes, may need to update code of functions like NextColumn() and PushColumnClipRect():
        -: 5610://   some frequently called functions which to modify both channels and clipping simultaneously tend to use the
        -: 5611://   more specialized SetWindowClipRectBeforeSetChannel() to avoid extraneous updates of underlying ImDrawCmds.
        -: 5612:// - This is analoguous to PushFont()/PopFont() in the sense that are a mixing a global stack and a window stack,
        -: 5613://   which in the case of ClipRect is not so problematic but tends to be more restrictive for fonts.
function _ZN5ImGui12PushClipRectERK6ImVec2S2_b called 34889 returned 100% blocks executed 100%
    34889: 5614:void ImGui::PushClipRect(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect)
        -: 5615:{
    34889: 5616:    ImGuiWindow* window = GetCurrentWindow();
    34889: 5616-block 2
call    0 returned 34889
    34889: 5617:    window->DrawList->PushClipRect(clip_rect_min, clip_rect_max, intersect_with_current_clip_rect);
call    0 returned 34889
    34889: 5618:    window->ClipRect = window->DrawList->_ClipRectStack.back();
call    0 returned 34889
call    1 returned 34889
    34889: 5619:}
        -: 5620:
function _ZN5ImGui11PopClipRectEv called 18521 returned 100% blocks executed 100%
    18521: 5621:void ImGui::PopClipRect()
        -: 5622:{
    18521: 5623:    ImGuiWindow* window = GetCurrentWindow();
    18521: 5623-block 2
call    0 returned 18521
    18521: 5624:    window->DrawList->PopClipRect();
call    0 returned 18521
    18521: 5625:    window->ClipRect = window->DrawList->_ClipRectStack.back();
call    0 returned 18521
call    1 returned 18521
    18521: 5626:}
        -: 5627:
function _ZL31FindFrontMostVisibleChildWindowP11ImGuiWindow called 0 returned 0% blocks executed 0%
    #####: 5628:static ImGuiWindow* FindFrontMostVisibleChildWindow(ImGuiWindow* window)
        -: 5629:{
    #####: 5630:    for (int n = window->DC.ChildWindows.Size - 1; n >= 0; n--)
    %%%%%: 5630-block 2
    %%%%%: 5630-block 9
    %%%%%: 5630-block 10
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 5631:        if (IsWindowActiveAndVisible(window->DC.ChildWindows[n]))
    %%%%%: 5631-block 3
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 5632:            return FindFrontMostVisibleChildWindow(window->DC.ChildWindows[n]);
    %%%%%: 5632-block 6
call    0 never executed
call    1 never executed
    #####: 5633:    return window;
    %%%%%: 5633-block 11
        -: 5634:}
        -: 5635:
function _ZN5ImGuiL34RenderDimmedBackgroundBehindWindowEP11ImGuiWindowj called 0 returned 0% blocks executed 0%
    #####: 5636:static void ImGui::RenderDimmedBackgroundBehindWindow(ImGuiWindow* window, ImU32 col)
        -: 5637:{
    #####: 5638:    if ((col & IM_COL32_A_MASK) == 0)
    %%%%%: 5638-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5639:        return;
    %%%%%: 5639-block 3
        -: 5640:
    #####: 5641:    ImGuiViewportP* viewport = window->Viewport;
    #####: 5642:    ImRect viewport_rect = viewport->GetMainRect();
    %%%%%: 5642-block 4
call    0 never executed
        -: 5643:
        -: 5644:    // Draw behind window by moving the draw command at the FRONT of the draw list
        -: 5645:    {
        -: 5646:        // Draw list have been trimmed already, hence the explicit recreation of a draw command if missing.
        -: 5647:        // FIXME: This is creating complication, might be simpler if we could inject a drawlist in drawdata at a given position and not attempt to manipulate ImDrawCmd order.
    #####: 5648:        ImDrawList* draw_list = window->RootWindowDockTree->DrawList;
    #####: 5649:        draw_list->ChannelsMerge();
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5650:        if (draw_list->CmdBuffer.Size == 0)
    %%%%%: 5650-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5651:            draw_list->AddDrawCmd();
    %%%%%: 5651-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5652:        draw_list->PushClipRect(viewport_rect.Min - ImVec2(1, 1), viewport_rect.Max + ImVec2(1, 1), false); // FIXME: Need to stricty ensure ImDrawCmd are not merged (ElemCount==6 checks below will verify that)
    %%%%%: 5652-block 8
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    $$$$$: 5652-block 33
    $$$$$: 5652-block 34
    $$$$$: 5652-block 35
    $$$$$: 5652-block 36
    #####: 5653:        draw_list->AddRectFilled(viewport_rect.Min, viewport_rect.Max, col);
    %%%%%: 5653-block 13
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5654:        ImDrawCmd cmd = draw_list->CmdBuffer.back();
    %%%%%: 5654-block 14
call    0 never executed
    #####: 5655:        IM_ASSERT(cmd.ElemCount == 6);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5655-block 16
call    2 never executed
    #####: 5656:        draw_list->CmdBuffer.pop_back();
    %%%%%: 5656-block 17
call    0 never executed
    #####: 5657:        draw_list->CmdBuffer.push_front(cmd);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5658:        draw_list->AddDrawCmd(); // We need to create a command as CmdBuffer.back().IdxOffset won't be correct if we append to same command.
    %%%%%: 5658-block 19
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5659:        draw_list->PopClipRect();
    %%%%%: 5659-block 20
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5660:    }
        -: 5661:
        -: 5662:    // Draw over sibling docking nodes in a same docking tree
    #####: 5663:    if (window->RootWindow->DockIsActive)
    %%%%%: 5663-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5664:    {
    #####: 5665:        ImDrawList* draw_list = FindFrontMostVisibleChildWindow(window->RootWindowDockTree)->DrawList;
    %%%%%: 5665-block 22
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5666:        draw_list->ChannelsMerge();
    %%%%%: 5666-block 23
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5667:        if (draw_list->CmdBuffer.Size == 0)
    %%%%%: 5667-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5668:            draw_list->AddDrawCmd();
    %%%%%: 5668-block 25
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5669:        draw_list->PushClipRect(viewport_rect.Min, viewport_rect.Max, false);
    %%%%%: 5669-block 26
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5670:        RenderRectFilledWithHole(draw_list, window->RootWindowDockTree->Rect(), window->RootWindow->Rect(), col, 0.0f);// window->RootWindowDockTree->WindowRounding);
    %%%%%: 5670-block 27
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    $$$$$: 5670-block 38
    $$$$$: 5670-block 39
    #####: 5671:        draw_list->PopClipRect();
    %%%%%: 5671-block 30
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5672:    }
        -: 5673:}
        -: 5674:
function _ZN5ImGui43FindBottomMostVisibleWindowWithinBeginStackEP11ImGuiWindow called 0 returned 0% blocks executed 0%
    #####: 5675:ImGuiWindow* ImGui::FindBottomMostVisibleWindowWithinBeginStack(ImGuiWindow* parent_window)
        -: 5676:{
    #####: 5677:    ImGuiContext& g = *GImGui;
    #####: 5678:    ImGuiWindow* bottom_most_visible_window = parent_window;
    #####: 5679:    for (int i = FindWindowDisplayIndex(parent_window); i >= 0; i--)
    %%%%%: 5679-block 2
call    0 never executed
    %%%%%: 5679-block 19
    %%%%%: 5679-block 20
branch  1 never executed
branch  2 never executed (fallthrough)
        -: 5680:    {
    #####: 5681:        ImGuiWindow* window = g.Windows[i];
    %%%%%: 5681-block 4
call    0 never executed
    #####: 5682:        if (window->Flags & ImGuiWindowFlags_ChildWindow)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5683:            continue;
    %%%%%: 5683-block 6
    #####: 5684:        if (!IsWindowWithinBeginStackOf(window, parent_window))
    %%%%%: 5684-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 5685:            break;
    %%%%%: 5685-block 9
    #####: 5686:        if (IsWindowActiveAndVisible(window) && GetWindowDisplayLayer(window) <= GetWindowDisplayLayer(parent_window))
    %%%%%: 5686-block 10
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 5686-block 12
call    3 never executed
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 5686-block 15
    %%%%%: 5686-block 16
    %%%%%: 5686-block 17
branch  7 never executed (fallthrough)
branch  8 never executed
    #####: 5687:            bottom_most_visible_window = window;
    %%%%%: 5687-block 18
        -: 5688:    }
    #####: 5689:    return bottom_most_visible_window;
    %%%%%: 5689-block 21
        -: 5690:}
        -: 5691:
        -: 5692:// Important: AddWindowToDrawData() has not been called yet, meaning DockNodeHost windows needs a DrawList->ChannelsMerge() before usage.
        -: 5693:// We call ChannelsMerge() lazily here at it is faster that doing a full iteration of g.Windows[] prior to calling RenderDimmedBackgrounds().
function _ZN5ImGuiL23RenderDimmedBackgroundsEv called 1077 returned 100% blocks executed 9%
     1077: 5694:static void ImGui::RenderDimmedBackgrounds()
        -: 5695:{
     1077: 5696:    ImGuiContext& g = *GImGui;
     1077: 5697:    ImGuiWindow* modal_window = GetTopMostAndVisiblePopupModal();
     1077: 5697-block 2
call    0 returned 1077
     1077: 5698:    if (g.DimBgRatio <= 0.0f && g.NavWindowingHighlightAlpha <= 0.0f)
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 5698-block 4
branch  2 taken 1077 (fallthrough)
branch  3 taken 0
     1077: 5699:        return;
     1077: 5699-block 5
     1077: 5699-block 72
    #####: 5700:    const bool dim_bg_for_modal = (modal_window != NULL);
    #####: 5701:    const bool dim_bg_for_window_list = (g.NavWindowingTargetAnim != NULL && g.NavWindowingTargetAnim->Active);
    %%%%%: 5701-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5701-block 7
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5701-block 8
    %%%%%: 5701-block 9
    #####: 5702:    if (!dim_bg_for_modal && !dim_bg_for_window_list)
    %%%%%: 5702-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5702-block 11
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 5703:        return;
    %%%%%: 5703-block 12
        -: 5704:
    #####: 5705:    ImGuiViewport* viewports_already_dimmed[2] = { NULL, NULL };
    #####: 5706:    if (dim_bg_for_modal)
    %%%%%: 5706-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5707:    {
        -: 5708:        // Draw dimming behind modal or a begin stack child, whichever comes first in draw order.
    #####: 5709:        ImGuiWindow* dim_behind_window = FindBottomMostVisibleWindowWithinBeginStack(modal_window);
    %%%%%: 5709-block 14
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5710:        RenderDimmedBackgroundBehindWindow(dim_behind_window, GetColorU32(modal_window->DC.ModalDimBgColor, g.DimBgRatio));
    %%%%%: 5710-block 15
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####: 5711:        viewports_already_dimmed[0] = modal_window->Viewport;
    %%%%%: 5711-block 17
        -: 5712:    }
    #####: 5713:    else if (dim_bg_for_window_list)
    %%%%%: 5713-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5714:    {
        -: 5715:        // Draw dimming behind CTRL+Tab target window and behind CTRL+Tab UI window
    #####: 5716:        RenderDimmedBackgroundBehindWindow(g.NavWindowingTargetAnim, GetColorU32(ImGuiCol_NavWindowingDimBg, g.DimBgRatio));
    %%%%%: 5716-block 19
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####: 5717:        if (g.NavWindowingListWindow != NULL && g.NavWindowingListWindow->Viewport && g.NavWindowingListWindow->Viewport != g.NavWindowingTargetAnim->Viewport)
    %%%%%: 5717-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5717-block 22
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5717-block 23
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 5718:            RenderDimmedBackgroundBehindWindow(g.NavWindowingListWindow, GetColorU32(ImGuiCol_NavWindowingDimBg, g.DimBgRatio));
    %%%%%: 5718-block 24
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####: 5719:        viewports_already_dimmed[0] = g.NavWindowingTargetAnim->Viewport;
    #####: 5720:        viewports_already_dimmed[1] = g.NavWindowingListWindow ? g.NavWindowingListWindow->Viewport : NULL;
    %%%%%: 5720-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5720-block 27
    %%%%%: 5720-block 28
        -: 5721:
        -: 5722:        // Draw border around CTRL+Tab target window
    #####: 5723:        ImGuiWindow* window = g.NavWindowingTargetAnim;
    #####: 5724:        ImGuiViewport* viewport = window->Viewport;
    #####: 5725:        float distance = g.FontSize;
    #####: 5726:        ImRect bb = window->Rect();
    %%%%%: 5726-block 29
call    0 never executed
    #####: 5727:        bb.Expand(distance);
call    0 never executed
    #####: 5728:        if (bb.GetWidth() >= viewport->Size.x && bb.GetHeight() >= viewport->Size.y)
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 5728-block 33
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 5728-block 35
    %%%%%: 5728-block 36
    %%%%%: 5728-block 37
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 5729:            bb.Expand(-distance - 1.0f); // If a window fits the entire viewport, adjust its highlight inward
    %%%%%: 5729-block 38
call    0 never executed
    #####: 5730:        window->DrawList->ChannelsMerge();
    %%%%%: 5730-block 39
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5731:        if (window->DrawList->CmdBuffer.Size == 0)
    %%%%%: 5731-block 40
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5732:            window->DrawList->AddDrawCmd();
    %%%%%: 5732-block 41
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5733:        window->DrawList->PushClipRect(viewport->Pos, viewport->Pos + viewport->Size);
    %%%%%: 5733-block 42
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$: 5733-block 74
    #####: 5734:        window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(ImGuiCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha), window->WindowRounding, 0, 3.0f);
    %%%%%: 5734-block 44
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####: 5735:        window->DrawList->PopClipRect();
    %%%%%: 5735-block 46
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5736:    }
        -: 5737:
        -: 5738:    // Draw dimming background on _other_ viewports than the ones our windows are in
    #####: 5739:    for (ImGuiViewportP* viewport : g.Viewports)
    %%%%%: 5739-block 48
call    0 never executed
call    1 never executed
    %%%%%: 5739-block 69
    %%%%%: 5739-block 70
branch  2 never executed
branch  3 never executed (fallthrough)
        -: 5740:    {
    #####: 5741:        if (viewport == viewports_already_dimmed[0] || viewport == viewports_already_dimmed[1])
    %%%%%: 5741-block 50
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5741-block 51
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 5742:            continue;
    %%%%%: 5742-block 52
    #####: 5743:        if (modal_window && viewport->Window && IsWindowAbove(viewport->Window, modal_window))
    %%%%%: 5743-block 53
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5743-block 54
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5743-block 55
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    %%%%%: 5743-block 56
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 5743-block 57
    %%%%%: 5743-block 58
    %%%%%: 5743-block 59
branch  9 never executed (fallthrough)
branch 10 never executed
    #####: 5744:            continue;
    %%%%%: 5744-block 60
    #####: 5745:        ImDrawList* draw_list = GetForegroundDrawList(viewport);
    %%%%%: 5745-block 61
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5746:        const ImU32 dim_bg_col = GetColorU32(dim_bg_for_modal ? ImGuiCol_ModalWindowDimBg : ImGuiCol_NavWindowingDimBg, g.DimBgRatio);
    %%%%%: 5746-block 62
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5746-block 63
    %%%%%: 5746-block 64
    %%%%%: 5746-block 65
call    2 never executed
    #####: 5747:        draw_list->AddRectFilled(viewport->Pos, viewport->Pos + viewport->Size, dim_bg_col);
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 5747-block 68
    $$$$$: 5747-block 76
        -: 5748:    }
        -: 5749:}
        -: 5750:
        -: 5751:// This is normally called by Render(). You may want to call it directly if you want to avoid calling Render() but the gain will be very minimal.
function _ZN5ImGui8EndFrameEv called 1077 returned 100% blocks executed 59%
     1077: 5752:void ImGui::EndFrame()
        -: 5753:{
     1077: 5754:    ImGuiContext& g = *GImGui;
    1077*: 5755:    IM_ASSERT(g.Initialized);
     1077: 5755-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 5755-block 3
call    2 never executed
        -: 5756:
        -: 5757:    // Don't process EndFrame() multiple times.
     1077: 5758:    if (g.FrameCountEnded == g.FrameCount)
     1077: 5758-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####: 5759:        return;
    %%%%%: 5759-block 5
    1077*: 5760:    IM_ASSERT(g.WithinFrameScope && "Forgot to call ImGui::NewFrame()?");
     1077: 5760-block 6
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 5760-block 7
call    2 never executed
        -: 5761:
     1077: 5762:    CallContextHooks(&g, ImGuiContextHookType_EndFramePre);
     1077: 5762-block 8
call    0 returned 1077
        -: 5763:
        -: 5764:    // [EXPERIMENTAL] Recover from errors
     1077: 5765:    if (g.IO.ConfigErrorRecovery)
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 5766:        ErrorRecoveryTryToRecoverState(&g.StackSizesInNewFrame);
     1077: 5766-block 10
call    0 returned 1077
     1077: 5767:    ErrorCheckEndFrameSanityChecks();
     1077: 5767-block 11
call    0 returned 1077
     1077: 5768:    ErrorCheckEndFrameFinalizeErrorTooltip();
call    0 returned 1077
        -: 5769:
        -: 5770:    // Notify Platform/OS when our Input Method Editor cursor has moved (e.g. CJK inputs using Microsoft IME)
     1077: 5771:    ImGuiPlatformImeData* ime_data = &g.PlatformImeData;
     1077: 5772:    if (g.PlatformIO.Platform_SetImeDataFn != NULL && memcmp(ime_data, &g.PlatformImeDataPrev, sizeof(ImGuiPlatformImeData)) != 0)
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 5772-block 14
branch  2 taken 0 (fallthrough)
branch  3 taken 1077
        -: 5773:    {
    #####: 5774:        ImGuiViewport* viewport = FindViewportByID(g.PlatformImeViewport);
    %%%%%: 5774-block 15
call    0 never executed
    #####: 5775:        IMGUI_DEBUG_LOG_IO("[io] Calling Platform_SetImeDataFn(): WantVisible: %d, InputPos (%.2f,%.2f)\n", ime_data->WantVisible, ime_data->InputPos.x, ime_data->InputPos.y);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5775-block 17
call    2 never executed
    #####: 5776:        if (viewport == NULL)
    %%%%%: 5776-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5777:            viewport = GetMainViewport();
    %%%%%: 5777-block 19
call    0 never executed
    #####: 5778:        g.PlatformIO.Platform_SetImeDataFn(&g, viewport, ime_data);
    %%%%%: 5778-block 21
call    0 never executed
        -: 5779:    }
        -: 5780:
        -: 5781:    // Hide implicit/fallback "Debug" window if it hasn't been used
     1077: 5782:    g.WithinFrameScopeWithImplicitWindow = false;
     1077: 5783:    if (g.CurrentWindow && !g.CurrentWindow->WriteAccessed)
     1077: 5783-block 22
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 5783-block 23
branch  2 taken 1077 (fallthrough)
branch  3 taken 0
     1077: 5784:        g.CurrentWindow->Active = false;
     1077: 5784-block 24
     1077: 5785:    End();
     1077: 5785-block 25
call    0 returned 1077
        -: 5786:
        -: 5787:    // Update navigation: CTRL+Tab, wrap-around requests
     1077: 5788:    NavEndFrame();
call    0 returned 1077
        -: 5789:
        -: 5790:    // Update docking
     1077: 5791:    DockContextEndFrame(&g);
call    0 returned 1077
        -: 5792:
     1077: 5793:    SetCurrentViewport(NULL, NULL);
call    0 returned 1077
        -: 5794:
        -: 5795:    // Drag and Drop: Elapse payload (if delivered, or if source stops being submitted)
     1077: 5796:    if (g.DragDropActive)
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
        -: 5797:    {
    #####: 5798:        bool is_delivered = g.DragDropPayload.Delivery;
    #####: 5799:        bool is_elapsed = (g.DragDropSourceFrameCount + 1 < g.FrameCount) && ((g.DragDropSourceFlags & ImGuiDragDropFlags_PayloadAutoExpire) || g.DragDropMouseButton == -1 || !IsMouseDown(g.DragDropMouseButton));
    %%%%%: 5799-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5799-block 31
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5799-block 32
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 5799-block 33
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 5799-block 35
    %%%%%: 5799-block 36
    #####: 5800:        if (is_delivered || is_elapsed)
    %%%%%: 5800-block 37
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5800-block 38
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 5801:            ClearDragDrop();
    %%%%%: 5801-block 39
call    0 never executed
        -: 5802:    }
        -: 5803:
        -: 5804:    // Drag and Drop: Fallback for missing source tooltip. This is not ideal but better than nothing.
        -: 5805:    // If you want to handle source item disappearing: instead of submitting your description tooltip
        -: 5806:    // in the BeginDragDropSource() block of the dragged item, you can submit them from a safe single spot
        -: 5807:    // (e.g. end of your item loop, or before EndFrame) by reading payload data.
        -: 5808:    // In the typical case, the contents of drag tooltip should be possible to infer solely from payload data.
    1077*: 5809:    if (g.DragDropActive && g.DragDropSourceFrameCount + 1 < g.FrameCount && !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoPreviewTooltip))
     1077: 5809-block 40
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 5809-block 41
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5809-block 42
branch  4 never executed (fallthrough)
branch  5 never executed
        -: 5810:    {
    #####: 5811:        g.DragDropWithinSource = true;
    #####: 5812:        SetTooltip("...");
    %%%%%: 5812-block 43
call    0 never executed
    #####: 5813:        g.DragDropWithinSource = false;
        -: 5814:    }
        -: 5815:
        -: 5816:    // End frame
     1077: 5817:    g.WithinFrameScope = false;
     1077: 5818:    g.FrameCountEnded = g.FrameCount;
        -: 5819:
        -: 5820:    // Initiate moving window + handle left-click and right-click focus
     1077: 5821:    UpdateMouseMovingWindowEndFrame();
     1077: 5821-block 45
call    0 returned 1077
        -: 5822:
        -: 5823:    // Update user-facing viewport list (g.Viewports -> g.PlatformIO.Viewports after filtering out some)
     1077: 5824:    UpdateViewportsEndFrame();
call    0 returned 1077
        -: 5825:
        -: 5826:    // Sort the window list so that all child windows are after their parent
        -: 5827:    // We cannot do that on FocusWindow() because children may not exist yet
     1077: 5828:    g.WindowsTempSortBuffer.resize(0);
call    0 returned 1077
     1077: 5829:    g.WindowsTempSortBuffer.reserve(g.Windows.Size);
call    0 returned 1077
    18169: 5830:    for (ImGuiWindow* window : g.Windows)
call    0 returned 1077
call    1 returned 1077
    17092: 5830-block 55
    18169: 5830-block 56
branch  2 taken 17092
branch  3 taken 1077 (fallthrough)
        -: 5831:    {
    17092: 5832:        if (window->Active && (window->Flags & ImGuiWindowFlags_ChildWindow))       // if a child is active its parent will add it
    17092: 5832-block 51
branch  0 taken 15291 (fallthrough)
branch  1 taken 1801
    15291: 5832-block 52
branch  2 taken 12924 (fallthrough)
branch  3 taken 2367
    12924: 5833:            continue;
    12924: 5833-block 53
     4168: 5834:        AddWindowToSortBuffer(&g.WindowsTempSortBuffer, window);
     4168: 5834-block 54
call    0 returned 4168
        -: 5835:    }
        -: 5836:
        -: 5837:    // This usually assert if there is a mismatch between the ImGuiWindowFlags_ChildWindow / ParentWindow values and DC.ChildWindows[] in parents, aka we've done something wrong.
    1077*: 5838:    IM_ASSERT(g.Windows.Size == g.WindowsTempSortBuffer.Size);
     1077: 5838-block 57
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 5838-block 58
call    2 never executed
     1077: 5839:    g.Windows.swap(g.WindowsTempSortBuffer);
     1077: 5839-block 59
call    0 returned 1077
     1077: 5840:    g.IO.MetricsActiveWindows = g.WindowsActiveCount;
        -: 5841:
        -: 5842:    // Unlock font atlas
     1077: 5843:    g.IO.Fonts->Locked = false;
        -: 5844:
        -: 5845:    // Clear Input data for next frame
     1077: 5846:    g.IO.MousePosPrev = g.IO.MousePos;
     1077: 5847:    g.IO.AppFocusLost = false;
     1077: 5848:    g.IO.MouseWheel = g.IO.MouseWheelH = 0.0f;
     1077: 5849:    g.IO.InputQueueCharacters.resize(0);
call    0 returned 1077
        -: 5850:
     1077: 5851:    CallContextHooks(&g, ImGuiContextHookType_EndFramePost);
call    0 returned 1077
        -: 5852:}
        -: 5853:
        -: 5854:// Prepare the data for rendering so you can call GetDrawData()
        -: 5855:// (As with anything within the ImGui:: namspace this doesn't touch your GPU or graphics API at all:
        -: 5856:// it is the role of the ImGui_ImplXXXX_RenderDrawData() function provided by the renderer backend)
function _ZN5ImGui6RenderEv called 1077 returned 100% blocks executed 76%
     1077: 5857:void ImGui::Render()
        -: 5858:{
     1077: 5859:    ImGuiContext& g = *GImGui;
    1077*: 5860:    IM_ASSERT(g.Initialized);
     1077: 5860-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 5860-block 3
call    2 never executed
        -: 5861:
     1077: 5862:    if (g.FrameCountEnded != g.FrameCount)
     1077: 5862-block 4
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 5863:        EndFrame();
     1077: 5863-block 5
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077: 5864:    if (g.FrameCountRendered == g.FrameCount)
     1077: 5864-block 6
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####: 5865:        return;
    %%%%%: 5865-block 7
     1077: 5866:    g.FrameCountRendered = g.FrameCount;
        -: 5867:
     1077: 5868:    g.IO.MetricsRenderWindows = 0;
     1077: 5869:    CallContextHooks(&g, ImGuiContextHookType_RenderPre);
     1077: 5869-block 8
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -: 5870:
        -: 5871:    // Add background ImDrawList (for each active viewport)
     2154: 5872:    for (ImGuiViewportP* viewport : g.Viewports)
     1077: 5872-block 9
call    0 returned 1077
call    1 returned 1077
     1077: 5872-block 15
     2154: 5872-block 16
branch  2 taken 1077
branch  3 taken 1077 (fallthrough)
        -: 5873:    {
     1077: 5874:        InitViewportDrawData(viewport);
     1077: 5874-block 11
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077: 5875:        if (viewport->BgFgDrawLists[0] != NULL)
     1077: 5875-block 12
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####: 5876:            AddDrawListToDrawDataEx(&viewport->DrawDataP, viewport->DrawDataBuilder.Layers[0], GetBackgroundDrawList(viewport));
    %%%%%: 5876-block 13
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 5876-block 14
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
        -: 5877:    }
        -: 5878:
        -: 5879:    // Draw modal/window whitening backgrounds
     1077: 5880:    RenderDimmedBackgrounds();
     1077: 5880-block 17
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -: 5881:
        -: 5882:    // Add ImDrawList to render
        -: 5883:    ImGuiWindow* windows_to_render_top_most[2];
    1077*: 5884:    windows_to_render_top_most[0] = (g.NavWindowingTarget && !(g.NavWindowingTarget->Flags & ImGuiWindowFlags_NoBringToFrontOnFocus)) ? g.NavWindowingTarget->RootWindowDockTree : NULL;
     1077: 5884-block 18
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 5884-block 19
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5884-block 20
     1077: 5884-block 21
    1077*: 5885:    windows_to_render_top_most[1] = (g.NavWindowingTarget ? g.NavWindowingListWindow : NULL);
     1077: 5885-block 22
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 5885-block 23
     1077: 5885-block 24
    18169: 5886:    for (ImGuiWindow* window : g.Windows)
     1077: 5886-block 25
call    0 returned 1077
call    1 returned 1077
    17092: 5886-block 36
    18169: 5886-block 37
branch  2 taken 17092
branch  3 taken 1077 (fallthrough)
        -: 5887:    {
        -: 5888:        IM_MSVC_WARNING_SUPPRESS(6011); // Static Analysis false positive "warning C6011: Dereferencing NULL pointer 'window'"
    17092: 5889:        if (IsWindowActiveAndVisible(window) && (window->Flags & ImGuiWindowFlags_ChildWindow) == 0 && window != windows_to_render_top_most[0] && window != windows_to_render_top_most[1])
    17092: 5889-block 27
call    0 returned 17092
branch  1 taken 15271 (fallthrough)
branch  2 taken 1821
    15271: 5889-block 29
branch  3 taken 2358 (fallthrough)
branch  4 taken 12913
     2358: 5889-block 30
branch  5 taken 2358 (fallthrough)
branch  6 taken 0
     2358: 5889-block 31
branch  7 taken 2358 (fallthrough)
branch  8 taken 0
     2358: 5889-block 32
    14734: 5889-block 33
    17092: 5889-block 34
branch  9 taken 2358 (fallthrough)
branch 10 taken 14734
     2358: 5890:            AddRootWindowToDrawData(window);
     2358: 5890-block 35
call    0 returned 2358
branch  1 taken 2358 (fallthrough)
branch  2 taken 0 (throw)
        -: 5891:    }
     3231: 5892:    for (int n = 0; n < IM_ARRAYSIZE(windows_to_render_top_most); n++)
     1077: 5892-block 38
     2154: 5892-block 46
     3231: 5892-block 47
branch  0 taken 2154
branch  1 taken 1077 (fallthrough)
    2154*: 5893:        if (windows_to_render_top_most[n] && IsWindowActiveAndVisible(windows_to_render_top_most[n])) // NavWindowingTarget is always temporarily displayed as the top-most window
     2154: 5893-block 39
branch  0 taken 0 (fallthrough)
branch  1 taken 2154
    %%%%%: 5893-block 40
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 5893-block 42
     2154: 5893-block 43
     2154: 5893-block 44
branch  5 taken 0 (fallthrough)
branch  6 taken 2154
    #####: 5894:            AddRootWindowToDrawData(windows_to_render_top_most[n]);
    %%%%%: 5894-block 45
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5895:
        -: 5896:    // Draw software mouse cursor if requested by io.MouseDrawCursor flag
    1077*: 5897:    if (g.IO.MouseDrawCursor && g.MouseCursor != ImGuiMouseCursor_None)
     1077: 5897-block 48
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 5897-block 49
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 5898:        RenderMouseCursor(g.IO.MousePos, g.Style.MouseCursorScale, g.MouseCursor, IM_COL32_WHITE, IM_COL32_BLACK, IM_COL32(0, 0, 0, 48));
    %%%%%: 5898-block 50
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5899:
        -: 5900:    // Setup ImDrawData structures for end-user
     1077: 5901:    g.IO.MetricsRenderVertices = g.IO.MetricsRenderIndices = 0;
     2154: 5902:    for (ImGuiViewportP* viewport : g.Viewports)
     1077: 5902-block 51
call    0 returned 1077
call    1 returned 1077
     2154: 5902-block 65
branch  2 taken 1077
branch  3 taken 1077 (fallthrough)
        -: 5903:    {
     1077: 5904:        FlattenDrawDataIntoSingleLayer(&viewport->DrawDataBuilder);
     1077: 5904-block 53
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -: 5905:
        -: 5906:        // Add foreground ImDrawList (for each active viewport)
     1077: 5907:        if (viewport->BgFgDrawLists[1] != NULL)
     1077: 5907-block 54
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####: 5908:            AddDrawListToDrawDataEx(&viewport->DrawDataP, viewport->DrawDataBuilder.Layers[0], GetForegroundDrawList(viewport));
    %%%%%: 5908-block 55
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 5908-block 56
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
        -: 5909:
        -: 5910:        // We call _PopUnusedDrawCmd() last thing, as RenderDimmedBackgrounds() rely on a valid command being there (especially in docking branch).
     1077: 5911:        ImDrawData* draw_data = &viewport->DrawDataP;
    1077*: 5912:        IM_ASSERT(draw_data->CmdLists.Size == draw_data->CmdListsCount);
     1077: 5912-block 57
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 5912-block 58
call    2 never executed
    15272: 5913:        for (ImDrawList* draw_list : draw_data->CmdLists)
     1077: 5913-block 59
call    0 returned 1077
call    1 returned 1077
    14195: 5913-block 62
    15272: 5913-block 63
branch  2 taken 14195
branch  3 taken 1077 (fallthrough)
    14195: 5914:            draw_list->_PopUnusedDrawCmd();
    14195: 5914-block 61
call    0 returned 14195
branch  1 taken 14195 (fallthrough)
branch  2 taken 0 (throw)
        -: 5915:
     1077: 5916:        g.IO.MetricsRenderVertices += draw_data->TotalVtxCount;
     1077: 5917:        g.IO.MetricsRenderIndices += draw_data->TotalIdxCount;
     1077: 5917-block 64
        -: 5918:    }
        -: 5919:
     1077: 5920:    CallContextHooks(&g, ImGuiContextHookType_RenderPost);
     1077: 5920-block 66
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -: 5921:}
        -: 5922:
        -: 5923:// Calculate text size. Text can be multi-line. Optionally ignore text after a ## marker.
        -: 5924:// CalcTextSize("") should return ImVec2(0.0f, g.FontSize)
function _ZN5ImGui12CalcTextSizeEPKcS1_bf called 527665 returned 100% blocks executed 100%
   527665: 5925:ImVec2 ImGui::CalcTextSize(const char* text, const char* text_end, bool hide_text_after_double_hash, float wrap_width)
        -: 5926:{
   527665: 5927:    ImGuiContext& g = *GImGui;
        -: 5928:
        -: 5929:    const char* text_display_end;
   527665: 5930:    if (hide_text_after_double_hash)
   527665: 5930-block 2
branch  0 taken 94682 (fallthrough)
branch  1 taken 432983
    94682: 5931:        text_display_end = FindRenderedTextEnd(text, text_end);      // Hide anything after a '##' string
    94682: 5931-block 3
call    0 returned 94682
        -: 5932:    else
   432983: 5933:        text_display_end = text_end;
   432983: 5933-block 4
        -: 5934:
   527665: 5935:    ImFont* font = g.Font;
   527665: 5936:    const float font_size = g.FontSize;
   527665: 5937:    if (text == text_display_end)
   527665: 5937-block 5
branch  0 taken 32310 (fallthrough)
branch  1 taken 495355
    32310: 5938:        return ImVec2(0.0f, font_size);
    32310: 5938-block 6
call    0 returned 32310
    32310: 5938-block 8
   495355: 5939:    ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);
   495355: 5939-block 9
call    0 returned 495355
branch  1 taken 495355 (fallthrough)
branch  2 taken 0 (throw)
        -: 5940:
        -: 5941:    // Round
        -: 5942:    // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
        -: 5943:    // FIXME: Investigate using ceilf or e.g.
        -: 5944:    // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
        -: 5945:    // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
   495355: 5946:    text_size.x = IM_TRUNC(text_size.x + 0.99999f);
        -: 5947:
   495355: 5948:    return text_size;
   495355: 5948-block 10
        -: 5949:}
        -: 5950:
        -: 5951:// Find window given position, search front-to-back
        -: 5952:// - Typically write output back to g.HoveredWindow and g.HoveredWindowUnderMovingWindow.
        -: 5953:// - FIXME: Note that we have an inconsequential lag here: OuterRectClipped is updated in Begin(), so windows moved programmatically
        -: 5954://   with SetWindowPos() and not SetNextWindowPos() will have that rectangle lagging by a frame at the time FindHoveredWindow() is
        -: 5955://   called, aka before the next Begin(). Moving window isn't affected.
        -: 5956:// - The 'find_first_and_in_any_viewport = true' mode is only used by TestEngine. It is simpler to maintain here.
function _ZN5ImGui19FindHoveredWindowExERK6ImVec2bPP11ImGuiWindowS5_ called 1077 returned 100% blocks executed 67%
     1077: 5957:void ImGui::FindHoveredWindowEx(const ImVec2& pos, bool find_first_and_in_any_viewport, ImGuiWindow** out_hovered_window, ImGuiWindow** out_hovered_window_under_moving_window)
        -: 5958:{
     1077: 5959:    ImGuiContext& g = *GImGui;
     1077: 5960:    ImGuiWindow* hovered_window = NULL;
     1077: 5961:    ImGuiWindow* hovered_window_under_moving_window = NULL;
        -: 5962:
        -: 5963:    // Special handling for the window being moved: Ignore the mouse viewport check (because it may reset/lose its viewport during the undocking frame)
     1077: 5964:    ImGuiViewportP* backup_moving_window_viewport = NULL;
     1077: 5965:    if (find_first_and_in_any_viewport == false && g.MovingWindow)
     1077: 5965-block 2
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 5965-block 3
branch  2 taken 0 (fallthrough)
branch  3 taken 1077
        -: 5966:    {
    #####: 5967:        backup_moving_window_viewport = g.MovingWindow->Viewport;
    #####: 5968:        g.MovingWindow->Viewport = g.MouseViewport;
    #####: 5969:        if (!(g.MovingWindow->Flags & ImGuiWindowFlags_NoMouseInputs))
    %%%%%: 5969-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5970:            hovered_window = g.MovingWindow;
    %%%%%: 5970-block 5
        -: 5971:    }
        -: 5972:
     1077: 5973:    ImVec2 padding_regular = g.Style.TouchExtraPadding;
    1077*: 5974:    ImVec2 padding_for_resize = g.IO.ConfigWindowsResizeFromEdges ? g.WindowsHoverPadding : padding_regular;
     1077: 5974-block 6
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 5974-block 7
    %%%%%: 5974-block 8
    14259: 5975:    for (int i = g.Windows.Size - 1; i >= 0; i--)
     1077: 5975-block 9
    13182: 5975-block 49
    14259: 5975-block 50
branch  0 taken 14258
branch  1 taken 1 (fallthrough)
        -: 5976:    {
    14258: 5977:        ImGuiWindow* window = g.Windows[i];
    14258: 5977-block 10
call    0 returned 14258
        -: 5978:        IM_MSVC_WARNING_SUPPRESS(28182); // [Static Analyzer] Dereferencing NULL pointer.
    14258: 5979:        if (!window->WasActive || window->Hidden)
branch  0 taken 12460 (fallthrough)
branch  1 taken 1798
    12460: 5979-block 12
branch  2 taken 9 (fallthrough)
branch  3 taken 12451
    13182: 5980:            continue;
     1807: 5980-block 13
    13182: 5980-block 47
    12451: 5981:        if (window->Flags & ImGuiWindowFlags_NoMouseInputs)
    12451: 5981-block 14
branch  0 taken 204 (fallthrough)
branch  1 taken 12247
      204: 5982:            continue;
      204: 5982-block 15
   12247*: 5983:        IM_ASSERT(window->Viewport);
    12247: 5983-block 16
branch  0 taken 0 (fallthrough)
branch  1 taken 12247
    %%%%%: 5983-block 17
call    2 never executed
   12247*: 5984:        if (window->Viewport != g.MouseViewport)
    12247: 5984-block 18
branch  0 taken 0 (fallthrough)
branch  1 taken 12247
    #####: 5985:            continue;
    %%%%%: 5985-block 19
        -: 5986:
        -: 5987:        // Using the clipped AABB, a child window will typically be clipped by its parent (not always)
   12247*: 5988:        ImVec2 hit_padding = (window->Flags & (ImGuiWindowFlags_NoResize | ImGuiWindowFlags_AlwaysAutoResize)) ? padding_regular : padding_for_resize;
    12247: 5988-block 20
branch  0 taken 12247 (fallthrough)
branch  1 taken 0
    12247: 5988-block 21
    %%%%%: 5988-block 22
    12247: 5989:        if (!window->OuterRectClipped.ContainsWithPad(pos, hit_padding))
    12247: 5989-block 23
call    0 returned 12247
branch  1 taken 11171 (fallthrough)
branch  2 taken 1076
    11171: 5990:            continue;
    11171: 5990-block 25
        -: 5991:
        -: 5992:        // Support for one rectangular hole in any given window
        -: 5993:        // FIXME: Consider generalizing hit-testing override (with more generic data, callback, etc.) (#1512)
     1076: 5994:        if (window->HitTestHoleSize.x != 0)
     1076: 5994-block 26
branch  0 taken 0 (fallthrough)
branch  1 taken 1076
        -: 5995:        {
    #####: 5996:            ImVec2 hole_pos(window->Pos.x + (float)window->HitTestHoleOffset.x, window->Pos.y + (float)window->HitTestHoleOffset.y);
    %%%%%: 5996-block 27
call    0 never executed
    #####: 5997:            ImVec2 hole_size((float)window->HitTestHoleSize.x, (float)window->HitTestHoleSize.y);
call    0 never executed
    #####: 5998:            if (ImRect(hole_pos, hole_pos + hole_size).Contains(pos))
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 5999:                continue;
    %%%%%: 5999-block 33
        -: 6000:        }
        -: 6001:
     1076: 6002:        if (find_first_and_in_any_viewport)
     1076: 6002-block 35
branch  0 taken 0 (fallthrough)
branch  1 taken 1076
        -: 6003:        {
    #####: 6004:            hovered_window = window;
    1076*: 6005:            break;
    %%%%%: 6005-block 36
     1076: 6005-block 48
        -: 6006:        }
        -: 6007:        else
        -: 6008:        {
     1076: 6009:            if (hovered_window == NULL)
     1076: 6009-block 37
branch  0 taken 1076 (fallthrough)
branch  1 taken 0
     1076: 6010:                hovered_window = window;
     1076: 6010-block 38
        -: 6011:            IM_MSVC_WARNING_SUPPRESS(28182); // [Static Analyzer] Dereferencing NULL pointer.
    1076*: 6012:            if (hovered_window_under_moving_window == NULL && (!g.MovingWindow || window->RootWindowDockTree != g.MovingWindow->RootWindowDockTree))
     1076: 6012-block 39
branch  0 taken 1076 (fallthrough)
branch  1 taken 0
     1076: 6012-block 40
branch  2 taken 0 (fallthrough)
branch  3 taken 1076
    %%%%%: 6012-block 41
branch  4 never executed (fallthrough)
branch  5 never executed
     1076: 6013:                hovered_window_under_moving_window = window;
     1076: 6013-block 42
     1076: 6014:            if (hovered_window && hovered_window_under_moving_window)
     1076: 6014-block 43
branch  0 taken 1076 (fallthrough)
branch  1 taken 0
     1076: 6014-block 44
branch  2 taken 1076 (fallthrough)
branch  3 taken 0
     1076: 6015:                break;
     1076: 6015-block 45
        -: 6016:        }
        -: 6017:    }
        -: 6018:
     1077: 6019:    *out_hovered_window = hovered_window;
     1077: 6020:    if (out_hovered_window_under_moving_window != NULL)
     1077: 6020-block 51
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 6021:        *out_hovered_window_under_moving_window = hovered_window_under_moving_window;
     1077: 6021-block 52
     1077: 6022:    if (find_first_and_in_any_viewport == false && g.MovingWindow)
     1077: 6022-block 53
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 6022-block 54
branch  2 taken 0 (fallthrough)
branch  3 taken 1077
    #####: 6023:        g.MovingWindow->Viewport = backup_moving_window_viewport;
    %%%%%: 6023-block 55
     1077: 6024:}
        -: 6025:
function _ZN5ImGui12IsItemActiveEv called 11837 returned 100% blocks executed 100%
    11837: 6026:bool ImGui::IsItemActive()
        -: 6027:{
    11837: 6028:    ImGuiContext& g = *GImGui;
    11837: 6029:    if (g.ActiveId)
    11837: 6029-block 2
branch  0 taken 1661 (fallthrough)
branch  1 taken 10176
     1661: 6030:        return g.ActiveId == g.LastItemData.ID;
     1661: 6030-block 3
    10176: 6031:    return false;
    10176: 6031-block 4
        -: 6032:}
        -: 6033:
function _ZN5ImGui15IsItemActivatedEv called 0 returned 0% blocks executed 0%
    #####: 6034:bool ImGui::IsItemActivated()
        -: 6035:{
    #####: 6036:    ImGuiContext& g = *GImGui;
    #####: 6037:    if (g.ActiveId)
    %%%%%: 6037-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6038:        if (g.ActiveId == g.LastItemData.ID && g.ActiveIdPreviousFrame != g.LastItemData.ID)
    %%%%%: 6038-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6038-block 4
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 6039:            return true;
    %%%%%: 6039-block 5
    #####: 6040:    return false;
    %%%%%: 6040-block 6
        -: 6041:}
        -: 6042:
function _ZN5ImGui17IsItemDeactivatedEv called 0 returned 0% blocks executed 0%
    #####: 6043:bool ImGui::IsItemDeactivated()
        -: 6044:{
    #####: 6045:    ImGuiContext& g = *GImGui;
    #####: 6046:    if (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_HasDeactivated)
    %%%%%: 6046-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6047:        return (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_Deactivated) != 0;
    %%%%%: 6047-block 3
    #####: 6048:    return (g.ActiveIdPreviousFrame == g.LastItemData.ID && g.ActiveIdPreviousFrame != 0 && g.ActiveId != g.LastItemData.ID);
    %%%%%: 6048-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6048-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6048-block 6
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 6048-block 7
    %%%%%: 6048-block 8
    %%%%%: 6048-block 9
        -: 6049:}
        -: 6050:
function _ZN5ImGui26IsItemDeactivatedAfterEditEv called 0 returned 0% blocks executed 0%
    #####: 6051:bool ImGui::IsItemDeactivatedAfterEdit()
        -: 6052:{
    #####: 6053:    ImGuiContext& g = *GImGui;
    #####: 6054:    return IsItemDeactivated() && (g.ActiveIdPreviousFrameHasBeenEditedBefore || (g.ActiveId == 0 && g.ActiveIdHasBeenEditedBefore));
    %%%%%: 6054-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 6054-block 4
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 6054-block 5
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 6054-block 6
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 6054-block 7
    %%%%%: 6054-block 8
    %%%%%: 6054-block 9
        -: 6055:}
        -: 6056:
        -: 6057:// == GetItemID() == GetFocusID()
function _ZN5ImGui13IsItemFocusedEv called 0 returned 0% blocks executed 0%
    #####: 6058:bool ImGui::IsItemFocused()
        -: 6059:{
    #####: 6060:    ImGuiContext& g = *GImGui;
    #####: 6061:    if (g.NavId != g.LastItemData.ID || g.NavId == 0)
    %%%%%: 6061-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6061-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 6062:        return false;
    %%%%%: 6062-block 4
        -: 6063:
        -: 6064:    // Special handling for the dummy item after Begin() which represent the title bar or tab.
        -: 6065:    // When the window is collapsed (SkipItems==true) that last item will never be overwritten so we need to detect the case.
    #####: 6066:    ImGuiWindow* window = g.CurrentWindow;
    #####: 6067:    if (g.LastItemData.ID == window->ID && window->WriteAccessed)
    %%%%%: 6067-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6067-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 6068:        return false;
    %%%%%: 6068-block 7
        -: 6069:
    #####: 6070:    return true;
    %%%%%: 6070-block 8
        -: 6071:}
        -: 6072:
        -: 6073:// Important: this can be useful but it is NOT equivalent to the behavior of e.g.Button()!
        -: 6074:// Most widgets have specific reactions based on mouse-up/down state, mouse position etc.
function _ZN5ImGui13IsItemClickedEi called 0 returned 0% blocks executed 0%
    #####: 6075:bool ImGui::IsItemClicked(ImGuiMouseButton mouse_button)
        -: 6076:{
    #####: 6077:    return IsMouseClicked(mouse_button) && IsItemHovered(ImGuiHoveredFlags_None);
    %%%%%: 6077-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 6077-block 4
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 6077-block 6
    %%%%%: 6077-block 7
    %%%%%: 6077-block 8
        -: 6078:}
        -: 6079:
function _ZN5ImGui17IsItemToggledOpenEv called 0 returned 0% blocks executed 0%
    #####: 6080:bool ImGui::IsItemToggledOpen()
        -: 6081:{
    #####: 6082:    ImGuiContext& g = *GImGui;
    #####: 6083:    return (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_ToggledOpen) ? true : false;
    %%%%%: 6083-block 2
        -: 6084:}
        -: 6085:
        -: 6086:// Call after a Selectable() or TreeNode() involved in multi-selection.
        -: 6087:// Useful if you need the per-item information before reaching EndMultiSelect(), e.g. for rendering purpose.
        -: 6088:// This is only meant to be called inside a BeginMultiSelect()/EndMultiSelect() block.
        -: 6089:// (Outside of multi-select, it would be misleading/ambiguous to report this signal, as widgets
        -: 6090:// return e.g. a pressed event and user code is in charge of altering selection in ways we cannot predict.)
function _ZN5ImGui22IsItemToggledSelectionEv called 0 returned 0% blocks executed 0%
    #####: 6091:bool ImGui::IsItemToggledSelection()
        -: 6092:{
    #####: 6093:    ImGuiContext& g = *GImGui;
    #####: 6094:    IM_ASSERT(g.CurrentMultiSelect != NULL); // Can only be used inside a BeginMultiSelect()/EndMultiSelect()
    %%%%%: 6094-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6094-block 3
call    2 never executed
    #####: 6095:    return (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_ToggledSelection) ? true : false;
    %%%%%: 6095-block 4
        -: 6096:}
        -: 6097:
        -: 6098:// IMPORTANT: If you are trying to check whether your mouse should be dispatched to Dear ImGui or to your underlying app,
        -: 6099:// you should not use this function! Use the 'io.WantCaptureMouse' boolean for that!
        -: 6100:// Refer to FAQ entry "How can I tell whether to dispatch mouse/keyboard to Dear ImGui or my application?" for details.
function _ZN5ImGui16IsAnyItemHoveredEv called 0 returned 0% blocks executed 0%
    #####: 6101:bool ImGui::IsAnyItemHovered()
        -: 6102:{
    #####: 6103:    ImGuiContext& g = *GImGui;
    #####: 6104:    return g.HoveredId != 0 || g.HoveredIdPreviousFrame != 0;
    %%%%%: 6104-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6104-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6104-block 4
    %%%%%: 6104-block 5
    %%%%%: 6104-block 6
        -: 6105:}
        -: 6106:
function _ZN5ImGui15IsAnyItemActiveEv called 0 returned 0% blocks executed 0%
    #####: 6107:bool ImGui::IsAnyItemActive()
        -: 6108:{
    #####: 6109:    ImGuiContext& g = *GImGui;
    #####: 6110:    return g.ActiveId != 0;
    %%%%%: 6110-block 2
        -: 6111:}
        -: 6112:
function _ZN5ImGui16IsAnyItemFocusedEv called 0 returned 0% blocks executed 0%
    #####: 6113:bool ImGui::IsAnyItemFocused()
        -: 6114:{
    #####: 6115:    ImGuiContext& g = *GImGui;
    #####: 6116:    return g.NavId != 0 && g.NavCursorVisible;
    %%%%%: 6116-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6116-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6116-block 4
    %%%%%: 6116-block 5
    %%%%%: 6116-block 6
        -: 6117:}
        -: 6118:
function _ZN5ImGui13IsItemVisibleEv called 0 returned 0% blocks executed 0%
    #####: 6119:bool ImGui::IsItemVisible()
        -: 6120:{
    #####: 6121:    ImGuiContext& g = *GImGui;
    #####: 6122:    return (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_Visible) != 0;
    %%%%%: 6122-block 2
        -: 6123:}
        -: 6124:
function _ZN5ImGui12IsItemEditedEv called 0 returned 0% blocks executed 0%
    #####: 6125:bool ImGui::IsItemEdited()
        -: 6126:{
    #####: 6127:    ImGuiContext& g = *GImGui;
    #####: 6128:    return (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_Edited) != 0;
    %%%%%: 6128-block 2
        -: 6129:}
        -: 6130:
        -: 6131:// Allow next item to be overlapped by subsequent items.
        -: 6132:// This works by requiring HoveredId to match for two subsequent frames,
        -: 6133:// so if a following items overwrite it our interactions will naturally be disabled.
function _ZN5ImGui23SetNextItemAllowOverlapEv called 0 returned 0% blocks executed 0%
    #####: 6134:void ImGui::SetNextItemAllowOverlap()
        -: 6135:{
    #####: 6136:    ImGuiContext& g = *GImGui;
    #####: 6137:    g.NextItemData.ItemFlags |= ImGuiItemFlags_AllowOverlap;
    #####: 6138:}
        -: 6139:
        -: 6140:#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
        -: 6141:// Allow last item to be overlapped by a subsequent item. Both may be activated during the same frame before the later one takes priority.
        -: 6142:// FIXME-LEGACY: Use SetNextItemAllowOverlap() *before* your item instead.
function _ZN5ImGui19SetItemAllowOverlapEv called 0 returned 0% blocks executed 0%
    #####: 6143:void ImGui::SetItemAllowOverlap()
        -: 6144:{
    #####: 6145:    ImGuiContext& g = *GImGui;
    #####: 6146:    ImGuiID id = g.LastItemData.ID;
    #####: 6147:    if (g.HoveredId == id)
    %%%%%: 6147-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6148:        g.HoveredIdAllowOverlap = true;
    %%%%%: 6148-block 3
    #####: 6149:    if (g.ActiveId == id) // Before we made this obsolete, most calls to SetItemAllowOverlap() used to avoid this path by testing g.ActiveId != id.
    %%%%%: 6149-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6150:        g.ActiveIdAllowOverlap = true;
    %%%%%: 6150-block 5
    #####: 6151:}
        -: 6152:#endif
        -: 6153:
        -: 6154:// This is a shortcut for not taking ownership of 100+ keys, frequently used by drag operations.
        -: 6155:// FIXME: It might be undesirable that this will likely disable KeyOwner-aware shortcuts systems. Consider a more fine-tuned version if needed?
function _ZN5ImGui31SetActiveIdUsingAllKeyboardKeysEv called 3 returned 100% blocks executed 75%
        3: 6156:void ImGui::SetActiveIdUsingAllKeyboardKeys()
        -: 6157:{
        3: 6158:    ImGuiContext& g = *GImGui;
       3*: 6159:    IM_ASSERT(g.ActiveId != 0);
        3: 6159-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%: 6159-block 3
call    2 never executed
        3: 6160:    g.ActiveIdUsingNavDirMask = (1 << ImGuiDir_COUNT) - 1;
        3: 6161:    g.ActiveIdUsingAllKeyboardKeys = true;
        3: 6162:    NavMoveRequestCancel();
        3: 6162-block 4
call    0 returned 3
        3: 6163:}
        -: 6164:
function _ZN5ImGui9GetItemIDEv called 0 returned 0% blocks executed 0%
    #####: 6165:ImGuiID ImGui::GetItemID()
        -: 6166:{
    #####: 6167:    ImGuiContext& g = *GImGui;
    #####: 6168:    return g.LastItemData.ID;
    %%%%%: 6168-block 2
        -: 6169:}
        -: 6170:
function _ZN5ImGui14GetItemRectMinEv called 0 returned 0% blocks executed 0%
    #####: 6171:ImVec2 ImGui::GetItemRectMin()
        -: 6172:{
    #####: 6173:    ImGuiContext& g = *GImGui;
    #####: 6174:    return g.LastItemData.Rect.Min;
    %%%%%: 6174-block 2
        -: 6175:}
        -: 6176:
function _ZN5ImGui14GetItemRectMaxEv called 0 returned 0% blocks executed 0%
    #####: 6177:ImVec2 ImGui::GetItemRectMax()
        -: 6178:{
    #####: 6179:    ImGuiContext& g = *GImGui;
    #####: 6180:    return g.LastItemData.Rect.Max;
    %%%%%: 6180-block 2
        -: 6181:}
        -: 6182:
function _ZN5ImGui15GetItemRectSizeEv called 0 returned 0% blocks executed 0%
    #####: 6183:ImVec2 ImGui::GetItemRectSize()
        -: 6184:{
    #####: 6185:    ImGuiContext& g = *GImGui;
    #####: 6186:    return g.LastItemData.Rect.GetSize();
    %%%%%: 6186-block 2
call    0 never executed
        -: 6187:}
        -: 6188:
        -: 6189:// Prior to v1.90 2023/10/16, the BeginChild() function took a 'bool border = false' parameter instead of 'ImGuiChildFlags child_flags = 0'.
        -: 6190:// ImGuiChildFlags_Borders is defined as always == 1 in order to allow old code passing 'true'. Read comments in imgui.h for details!
function _ZN5ImGui10BeginChildEPKcRK6ImVec2ii called 6462 returned 100% blocks executed 100%
     6462: 6191:bool ImGui::BeginChild(const char* str_id, const ImVec2& size_arg, ImGuiChildFlags child_flags, ImGuiWindowFlags window_flags)
        -: 6192:{
     6462: 6193:    ImGuiID id = GetCurrentWindow()->GetID(str_id);
     6462: 6193-block 2
call    0 returned 6462
call    1 returned 6462
     6462: 6194:    return BeginChildEx(str_id, id, size_arg, child_flags, window_flags);
call    0 returned 6462
        -: 6195:}
        -: 6196:
function _ZN5ImGui10BeginChildEjRK6ImVec2ii called 0 returned 0% blocks executed 0%
    #####: 6197:bool ImGui::BeginChild(ImGuiID id, const ImVec2& size_arg, ImGuiChildFlags child_flags, ImGuiWindowFlags window_flags)
        -: 6198:{
    #####: 6199:    return BeginChildEx(NULL, id, size_arg, child_flags, window_flags);
    %%%%%: 6199-block 2
call    0 never executed
        -: 6200:}
        -: 6201:
function _ZN5ImGui12BeginChildExEPKcjRK6ImVec2ii called 6462 returned 100% blocks executed 50%
     6462: 6202:bool ImGui::BeginChildEx(const char* name, ImGuiID id, const ImVec2& size_arg, ImGuiChildFlags child_flags, ImGuiWindowFlags window_flags)
        -: 6203:{
     6462: 6204:    ImGuiContext& g = *GImGui;
     6462: 6205:    ImGuiWindow* parent_window = g.CurrentWindow;
    6462*: 6206:    IM_ASSERT(id != 0);
     6462: 6206-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 6462
    %%%%%: 6206-block 3
call    2 never executed
        -: 6207:
        -: 6208:    // Sanity check as it is likely that some user will accidentally pass ImGuiWindowFlags into the ImGuiChildFlags argument.
     6462: 6209:    const ImGuiChildFlags ImGuiChildFlags_SupportedMask_ = ImGuiChildFlags_Borders | ImGuiChildFlags_AlwaysUseWindowPadding | ImGuiChildFlags_ResizeX | ImGuiChildFlags_ResizeY | ImGuiChildFlags_AutoResizeX | ImGuiChildFlags_AutoResizeY | ImGuiChildFlags_AlwaysAutoResize | ImGuiChildFlags_FrameStyle | ImGuiChildFlags_NavFlattened;
        -: 6210:    IM_UNUSED(ImGuiChildFlags_SupportedMask_);
    6462*: 6211:    IM_ASSERT((child_flags & ~ImGuiChildFlags_SupportedMask_) == 0 && "Illegal ImGuiChildFlags value. Did you pass ImGuiWindowFlags values instead of ImGuiChildFlags?");
     6462: 6211-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 6462
    %%%%%: 6211-block 5
call    2 never executed
    6462*: 6212:    IM_ASSERT((window_flags & ImGuiWindowFlags_AlwaysAutoResize) == 0 && "Cannot specify ImGuiWindowFlags_AlwaysAutoResize for BeginChild(). Use ImGuiChildFlags_AlwaysAutoResize!");
     6462: 6212-block 6
branch  0 taken 0 (fallthrough)
branch  1 taken 6462
    %%%%%: 6212-block 7
call    2 never executed
     6462: 6213:    if (child_flags & ImGuiChildFlags_AlwaysAutoResize)
     6462: 6213-block 8
branch  0 taken 0 (fallthrough)
branch  1 taken 6462
        -: 6214:    {
    #####: 6215:        IM_ASSERT((child_flags & (ImGuiChildFlags_ResizeX | ImGuiChildFlags_ResizeY)) == 0 && "Cannot use ImGuiChildFlags_ResizeX or ImGuiChildFlags_ResizeY with ImGuiChildFlags_AlwaysAutoResize!");
    %%%%%: 6215-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6215-block 10
call    2 never executed
    #####: 6216:        IM_ASSERT((child_flags & (ImGuiChildFlags_AutoResizeX | ImGuiChildFlags_AutoResizeY)) != 0 && "Must use ImGuiChildFlags_AutoResizeX or ImGuiChildFlags_AutoResizeY with ImGuiChildFlags_AlwaysAutoResize!");
    %%%%%: 6216-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6216-block 12
call    2 never executed
        -: 6217:    }
        -: 6218:#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
     6462: 6219:    if (window_flags & ImGuiWindowFlags_AlwaysUseWindowPadding)
     6462: 6219-block 13
branch  0 taken 0 (fallthrough)
branch  1 taken 6462
    #####: 6220:        child_flags |= ImGuiChildFlags_AlwaysUseWindowPadding;
    %%%%%: 6220-block 14
     6462: 6221:    if (window_flags & ImGuiWindowFlags_NavFlattened)
     6462: 6221-block 15
branch  0 taken 0 (fallthrough)
branch  1 taken 6462
    #####: 6222:        child_flags |= ImGuiChildFlags_NavFlattened;
    %%%%%: 6222-block 16
        -: 6223:#endif
     6462: 6224:    if (child_flags & ImGuiChildFlags_AutoResizeX)
     6462: 6224-block 17
branch  0 taken 0 (fallthrough)
branch  1 taken 6462
    #####: 6225:        child_flags &= ~ImGuiChildFlags_ResizeX;
    %%%%%: 6225-block 18
     6462: 6226:    if (child_flags & ImGuiChildFlags_AutoResizeY)
     6462: 6226-block 19
branch  0 taken 0 (fallthrough)
branch  1 taken 6462
    #####: 6227:        child_flags &= ~ImGuiChildFlags_ResizeY;
    %%%%%: 6227-block 20
        -: 6228:
        -: 6229:    // Set window flags
     6462: 6230:    window_flags |= ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoDocking;
     6462: 6231:    window_flags |= (parent_window->Flags & ImGuiWindowFlags_NoMove); // Inherit the NoMove flag
     6462: 6232:    if (child_flags & (ImGuiChildFlags_AutoResizeX | ImGuiChildFlags_AutoResizeY | ImGuiChildFlags_AlwaysAutoResize))
     6462: 6232-block 21
branch  0 taken 0 (fallthrough)
branch  1 taken 6462
    #####: 6233:        window_flags |= ImGuiWindowFlags_AlwaysAutoResize;
    %%%%%: 6233-block 22
     6462: 6234:    if ((child_flags & (ImGuiChildFlags_ResizeX | ImGuiChildFlags_ResizeY)) == 0)
     6462: 6234-block 23
branch  0 taken 6462 (fallthrough)
branch  1 taken 0
     6462: 6235:        window_flags |= ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings;
     6462: 6235-block 24
        -: 6236:
        -: 6237:    // Special framed style
     6462: 6238:    if (child_flags & ImGuiChildFlags_FrameStyle)
     6462: 6238-block 25
branch  0 taken 0 (fallthrough)
branch  1 taken 6462
        -: 6239:    {
    #####: 6240:        PushStyleColor(ImGuiCol_ChildBg, g.Style.Colors[ImGuiCol_FrameBg]);
    %%%%%: 6240-block 26
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6241:        PushStyleVar(ImGuiStyleVar_ChildRounding, g.Style.FrameRounding);
    %%%%%: 6241-block 27
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6242:        PushStyleVar(ImGuiStyleVar_ChildBorderSize, g.Style.FrameBorderSize);
    %%%%%: 6242-block 28
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6243:        PushStyleVar(ImGuiStyleVar_WindowPadding, g.Style.FramePadding);
    %%%%%: 6243-block 29
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6244:        child_flags |= ImGuiChildFlags_Borders | ImGuiChildFlags_AlwaysUseWindowPadding;
    #####: 6245:        window_flags |= ImGuiWindowFlags_NoMove;
    %%%%%: 6245-block 30
        -: 6246:    }
        -: 6247:
        -: 6248:    // Forward size
        -: 6249:    // Important: Begin() has special processing to switch condition to ImGuiCond_FirstUseEver for a given axis when ImGuiChildFlags_ResizeXXX is set.
        -: 6250:    // (the alternative would to store conditional flags per axis, which is possible but more code)
     6462: 6251:    const ImVec2 size_avail = GetContentRegionAvail();
     6462: 6251-block 31
call    0 returned 6462
    6462*: 6252:    const ImVec2 size_default((child_flags & ImGuiChildFlags_AutoResizeX) ? 0.0f : size_avail.x, (child_flags & ImGuiChildFlags_AutoResizeY) ? 0.0f : size_avail.y);
branch  0 taken 6462 (fallthrough)
branch  1 taken 0
     6462: 6252-block 33
    %%%%%: 6252-block 34
     6462: 6252-block 35
branch  2 taken 6462 (fallthrough)
branch  3 taken 0
     6462: 6252-block 36
    %%%%%: 6252-block 37
     6462: 6252-block 38
call    4 returned 6462
     6462: 6253:    ImVec2 size = CalcItemSize(size_arg, size_default.x, size_default.y);
call    0 returned 6462
branch  1 taken 6462 (fallthrough)
branch  2 taken 0 (throw)
        -: 6254:
        -: 6255:    // A SetNextWindowSize() call always has priority (#8020)
        -: 6256:    // (since the code in Begin() never supported SizeVal==0.0f aka auto-resize via SetNextWindowSize() call, we don't support it here for now)
        -: 6257:    // FIXME: We only support ImGuiCond_Always in this path. Supporting other paths would requires to obtain window pointer.
    6462*: 6258:    if ((g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSize) != 0 && (g.NextWindowData.SizeCond & ImGuiCond_Always) != 0)
     6462: 6258-block 40
branch  0 taken 0 (fallthrough)
branch  1 taken 6462
    %%%%%: 6258-block 41
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 6259:    {
    #####: 6260:        if (g.NextWindowData.SizeVal.x > 0.0f)
    %%%%%: 6260-block 42
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6261:        {
    #####: 6262:            size.x = g.NextWindowData.SizeVal.x;
    #####: 6263:            child_flags &= ~ImGuiChildFlags_ResizeX;
    %%%%%: 6263-block 43
        -: 6264:        }
    #####: 6265:        if (g.NextWindowData.SizeVal.y > 0.0f)
    %%%%%: 6265-block 44
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6266:        {
    #####: 6267:            size.y = g.NextWindowData.SizeVal.y;
    #####: 6268:            child_flags &= ~ImGuiChildFlags_ResizeY;
    %%%%%: 6268-block 45
        -: 6269:        }
        -: 6270:    }
     6462: 6271:    SetNextWindowSize(size);
     6462: 6271-block 46
call    0 returned 6462
        -: 6272:
        -: 6273:    // Forward child flags
     6462: 6274:    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasChildFlags;
     6462: 6275:    g.NextWindowData.ChildFlags = child_flags;
        -: 6276:
        -: 6277:    // Build up name. If you need to append to a same child from multiple location in the ID stack, use BeginChild(ImGuiID id) with a stable value.
        -: 6278:    // FIXME: 2023/11/14: commented out shorted version. We had an issue with multiple ### in child window path names, which the trailing hash helped workaround.
        -: 6279:    // e.g. "ParentName###ParentIdentifier/ChildName###ChildIdentifier" would get hashed incorrectly by ImHashStr(), trailing _%08X somehow fixes it.
        -: 6280:    const char* temp_window_name;
        -: 6281:    /*if (name && parent_window->IDStack.back() == parent_window->ID)
        -: 6282:        ImFormatStringToTempBuffer(&temp_window_name, NULL, "%s/%s", parent_window->Name, name); // May omit ID if in root of ID stack
        -: 6283:    else*/
     6462: 6284:    if (name)
branch  0 taken 6462 (fallthrough)
branch  1 taken 0
     6462: 6285:        ImFormatStringToTempBuffer(&temp_window_name, NULL, "%s/%s_%08X", parent_window->Name, name, id);
     6462: 6285-block 48
call    0 returned 6462
branch  1 taken 6462 (fallthrough)
branch  2 taken 0 (throw)
        -: 6286:    else
    #####: 6287:        ImFormatStringToTempBuffer(&temp_window_name, NULL, "%s/%08X", parent_window->Name, id);
    %%%%%: 6287-block 49
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6288:
        -: 6289:    // Set style
     6462: 6290:    const float backup_border_size = g.Style.ChildBorderSize;
     6462: 6291:    if ((child_flags & ImGuiChildFlags_Borders) == 0)
     6462: 6291-block 50
branch  0 taken 6462 (fallthrough)
branch  1 taken 0
     6462: 6292:        g.Style.ChildBorderSize = 0.0f;
     6462: 6292-block 51
        -: 6293:
        -: 6294:    // Begin into window
     6462: 6295:    const bool ret = Begin(temp_window_name, NULL, window_flags);
     6462: 6295-block 52
call    0 returned 6462
branch  1 taken 6462 (fallthrough)
branch  2 taken 0 (throw)
        -: 6296:
        -: 6297:    // Restore style
     6462: 6298:    g.Style.ChildBorderSize = backup_border_size;
     6462: 6299:    if (child_flags & ImGuiChildFlags_FrameStyle)
     6462: 6299-block 53
branch  0 taken 0 (fallthrough)
branch  1 taken 6462
        -: 6300:    {
    #####: 6301:        PopStyleVar(3);
    %%%%%: 6301-block 54
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6302:        PopStyleColor();
    %%%%%: 6302-block 55
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6303:    }
        -: 6304:
     6462: 6305:    ImGuiWindow* child_window = g.CurrentWindow;
     6462: 6306:    child_window->ChildId = id;
        -: 6307:
        -: 6308:    // Set the cursor to handle case where the user called SetNextWindowPos()+BeginChild() manually.
        -: 6309:    // While this is not really documented/defined, it seems that the expected thing to do.
     6462: 6310:    if (child_window->BeginCount == 1)
     6462: 6310-block 56
branch  0 taken 6462 (fallthrough)
branch  1 taken 0
     6462: 6311:        parent_window->DC.CursorPos = child_window->Pos;
     6462: 6311-block 57
        -: 6312:
        -: 6313:    // Process navigation-in immediately so NavInit can run on first frame
        -: 6314:    // Can enter a child if (A) it has navigable items or (B) it can be scrolled.
     6462: 6315:    const ImGuiID temp_id_for_activation = ImHashStr("##Child", 0, id);
     6462: 6315-block 58
call    0 returned 6462
     6462: 6316:    if (g.ActiveId == temp_id_for_activation)
branch  0 taken 0 (fallthrough)
branch  1 taken 6462
    #####: 6317:        ClearActiveID();
    %%%%%: 6317-block 60
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    6462*: 6318:    if (g.NavActivateId == id && !(child_flags & ImGuiChildFlags_NavFlattened) && (child_window->DC.NavLayersActiveMask != 0 || child_window->DC.NavWindowHasScrollY))
     6462: 6318-block 61
branch  0 taken 0 (fallthrough)
branch  1 taken 6462
    %%%%%: 6318-block 62
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6318-block 63
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 6318-block 64
branch  6 never executed (fallthrough)
branch  7 never executed
        -: 6319:    {
    #####: 6320:        FocusWindow(child_window);
    %%%%%: 6320-block 65
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6321:        NavInitWindow(child_window, false);
    %%%%%: 6321-block 66
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6322:        SetActiveID(temp_id_for_activation, child_window); // Steal ActiveId with another arbitrary id so that key-press won't activate child item
    %%%%%: 6322-block 67
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6323:        g.ActiveIdSource = g.NavInputSource;
    %%%%%: 6323-block 68
        -: 6324:    }
     6462: 6325:    return ret;
     6462: 6325-block 69
     6462: 6325-block 70
        -: 6326:}
        -: 6327:
function _ZN5ImGui8EndChildEv called 6462 returned 100% blocks executed 76%
     6462: 6328:void ImGui::EndChild()
        -: 6329:{
     6462: 6330:    ImGuiContext& g = *GImGui;
     6462: 6331:    ImGuiWindow* child_window = g.CurrentWindow;
        -: 6332:
    6462*: 6333:    IM_ASSERT(g.WithinEndChild == false);
     6462: 6333-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 6462
    %%%%%: 6333-block 3
call    2 never executed
    6462*: 6334:    IM_ASSERT(child_window->Flags & ImGuiWindowFlags_ChildWindow);   // Mismatched BeginChild()/EndChild() calls
     6462: 6334-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 6462
    %%%%%: 6334-block 5
call    2 never executed
        -: 6335:
     6462: 6336:    g.WithinEndChild = true;
     6462: 6337:    ImVec2 child_size = child_window->Size;
     6462: 6338:    End();
     6462: 6338-block 6
call    0 returned 6462
branch  1 taken 6462 (fallthrough)
branch  2 taken 0 (throw)
     6462: 6339:    if (child_window->BeginCount == 1)
     6462: 6339-block 7
branch  0 taken 6462 (fallthrough)
branch  1 taken 0
        -: 6340:    {
     6462: 6341:        ImGuiWindow* parent_window = g.CurrentWindow;
     6462: 6342:        ImRect bb(parent_window->DC.CursorPos, parent_window->DC.CursorPos + child_size);
     6462: 6342-block 8
call    0 returned 6462
call    1 returned 6462
     6462: 6343:        ItemSize(child_size);
call    0 returned 6462
branch  1 taken 6462 (fallthrough)
branch  2 taken 0 (throw)
     6462: 6344:        const bool nav_flattened = (child_window->ChildFlags & ImGuiChildFlags_NavFlattened) != 0;
     6462: 6345:        if ((child_window->DC.NavLayersActiveMask != 0 || child_window->DC.NavWindowHasScrollY) && !nav_flattened)
     6462: 6345-block 11
branch  0 taken 4310 (fallthrough)
branch  1 taken 2152
     4310: 6345-block 12
branch  2 taken 3228 (fallthrough)
branch  3 taken 1082
     5380: 6345-block 13
branch  4 taken 5380 (fallthrough)
branch  5 taken 0
        -: 6346:        {
     5380: 6347:            ItemAdd(bb, child_window->ChildId);
     5380: 6347-block 14
call    0 returned 5380
branch  1 taken 5380 (fallthrough)
branch  2 taken 0 (throw)
     5380: 6348:            RenderNavCursor(bb, child_window->ChildId);
     5380: 6348-block 15
call    0 returned 5380
branch  1 taken 5380 (fallthrough)
branch  2 taken 0 (throw)
        -: 6349:
        -: 6350:            // When browsing a window that has no activable items (scroll only) we keep a highlight on the child (pass g.NavId to trick into always displaying)
     5380: 6351:            if (child_window->DC.NavLayersActiveMask == 0 && child_window == g.NavWindow)
     5380: 6351-block 16
branch  0 taken 3228 (fallthrough)
branch  1 taken 2152
     3228: 6351-block 17
branch  2 taken 390 (fallthrough)
branch  3 taken 2838
      390: 6352:                RenderNavCursor(ImRect(bb.Min - ImVec2(2, 2), bb.Max + ImVec2(2, 2)), g.NavId, ImGuiNavRenderCursorFlags_Compact);
      390: 6352-block 18
call    0 returned 390
call    1 returned 390
call    2 returned 390
call    3 returned 390
call    4 returned 390
call    5 returned 390
branch  6 taken 390 (fallthrough)
branch  7 taken 0 (throw)
      390: 6352-block 24
    $$$$$: 6352-block 33
    $$$$$: 6352-block 34
    $$$$$: 6352-block 35
    $$$$$: 6352-block 36
    $$$$$: 6352-block 37
        -: 6353:        }
        -: 6354:        else
        -: 6355:        {
        -: 6356:            // Not navigable into
        -: 6357:            // - This is a bit of a fringe use case, mostly useful for undecorated, non-scrolling contents childs, or empty childs.
        -: 6358:            // - We could later decide to not apply this path if ImGuiChildFlags_FrameStyle or ImGuiChildFlags_Borders is set.
     1082: 6359:            ItemAdd(bb, child_window->ChildId, NULL, ImGuiItemFlags_NoNav);
     1082: 6359-block 26
call    0 returned 1082
branch  1 taken 1082 (fallthrough)
branch  2 taken 0 (throw)
        -: 6360:
        -: 6361:            // But when flattened we directly reach items, adjust active layer mask accordingly
     1082: 6362:            if (nav_flattened)
     1082: 6362-block 27
branch  0 taken 0 (fallthrough)
branch  1 taken 1082
    #####: 6363:                parent_window->DC.NavLayersActiveMaskNext |= child_window->DC.NavLayersActiveMaskNext;
    %%%%%: 6363-block 28
        -: 6364:        }
     6462: 6365:        if (g.HoveredWindow == child_window)
     6462: 6365-block 29
branch  0 taken 654 (fallthrough)
branch  1 taken 5808
      654: 6366:            g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredWindow;
      654: 6366-block 30
        -: 6367:    }
     6462: 6368:    g.WithinEndChild = false;
     6462: 6369:    g.LogLinePosY = -FLT_MAX; // To enforce a carriage return
     6462: 6370:}
     6462: 6370-block 32
        -: 6371:
function _ZL28SetWindowConditionAllowFlagsP11ImGuiWindowib called 56 returned 100% blocks executed 100%
       56: 6372:static void SetWindowConditionAllowFlags(ImGuiWindow* window, ImGuiCond flags, bool enabled)
        -: 6373:{
       56: 6374:    window->SetWindowPosAllowFlags       = enabled ? (window->SetWindowPosAllowFlags       | flags) : (window->SetWindowPosAllowFlags       & ~flags);
       56: 6374-block 2
branch  0 taken 24 (fallthrough)
branch  1 taken 32
       24: 6374-block 3
       32: 6374-block 4
       56: 6375:    window->SetWindowSizeAllowFlags      = enabled ? (window->SetWindowSizeAllowFlags      | flags) : (window->SetWindowSizeAllowFlags      & ~flags);
       56: 6375-block 5
branch  0 taken 24 (fallthrough)
branch  1 taken 32
       24: 6375-block 6
       32: 6375-block 7
       56: 6376:    window->SetWindowCollapsedAllowFlags = enabled ? (window->SetWindowCollapsedAllowFlags | flags) : (window->SetWindowCollapsedAllowFlags & ~flags);
       56: 6376-block 8
branch  0 taken 24 (fallthrough)
branch  1 taken 32
       24: 6376-block 9
       32: 6376-block 10
       56: 6377:    window->SetWindowDockAllowFlags      = enabled ? (window->SetWindowDockAllowFlags      | flags) : (window->SetWindowDockAllowFlags      & ~flags);
       56: 6377-block 11
branch  0 taken 24 (fallthrough)
branch  1 taken 32
       24: 6377-block 12
       32: 6377-block 13
       56: 6378:}
        -: 6379:
function _ZN5ImGui14FindWindowByIDEj called 18542 returned 100% blocks executed 100%
    18542: 6380:ImGuiWindow* ImGui::FindWindowByID(ImGuiID id)
        -: 6381:{
    18542: 6382:    ImGuiContext& g = *GImGui;
    18542: 6383:    return (ImGuiWindow*)g.WindowsById.GetVoidPtr(id);
    18542: 6383-block 2
call    0 returned 18542
        -: 6384:}
        -: 6385:
function _ZN5ImGui16FindWindowByNameEPKc called 18531 returned 100% blocks executed 100%
    18531: 6386:ImGuiWindow* ImGui::FindWindowByName(const char* name)
        -: 6387:{
    18531: 6388:    ImGuiID id = ImHashStr(name);
    18531: 6388-block 2
call    0 returned 18531
    18531: 6389:    return FindWindowByID(id);
call    0 returned 18531
        -: 6390:}
        -: 6391:
function _ZL19ApplyWindowSettingsP11ImGuiWindowP19ImGuiWindowSettings called 7 returned 100% blocks executed 83%
        7: 6392:static void ApplyWindowSettings(ImGuiWindow* window, ImGuiWindowSettings* settings)
        -: 6393:{
        7: 6394:    const ImGuiViewport* main_viewport = ImGui::GetMainViewport();
        7: 6394-block 2
call    0 returned 7
        7: 6395:    window->ViewportPos = main_viewport->Pos;
        7: 6396:    if (settings->ViewportId)
branch  0 taken 0 (fallthrough)
branch  1 taken 7
        -: 6397:    {
    #####: 6398:        window->ViewportId = settings->ViewportId;
    #####: 6399:        window->ViewportPos = ImVec2(settings->ViewportPos.x, settings->ViewportPos.y);
    %%%%%: 6399-block 4
call    0 never executed
        -: 6400:    }
        7: 6401:    window->Pos = ImTrunc(ImVec2(settings->Pos.x + window->ViewportPos.x, settings->Pos.y + window->ViewportPos.y));
        7: 6401-block 6
call    0 returned 7
call    1 returned 7
        7: 6402:    if (settings->Size.x > 0 && settings->Size.y > 0)
branch  0 taken 7 (fallthrough)
branch  1 taken 0
        7: 6402-block 9
branch  2 taken 7 (fallthrough)
branch  3 taken 0
        7: 6403:        window->Size = window->SizeFull = ImTrunc(ImVec2(settings->Size.x, settings->Size.y));
        7: 6403-block 10
call    0 returned 7
call    1 returned 7
        7: 6404:    window->Collapsed = settings->Collapsed;
        7: 6405:    window->DockId = settings->DockId;
        7: 6406:    window->DockOrder = settings->DockOrder;
        7: 6407:}
        -: 6408:
function _ZL28UpdateWindowInFocusOrderListP11ImGuiWindowbi called 16368 returned 100% blocks executed 54%
    16368: 6409:static void UpdateWindowInFocusOrderList(ImGuiWindow* window, bool just_created, ImGuiWindowFlags new_flags)
        -: 6410:{
    16368: 6411:    ImGuiContext& g = *GImGui;
        -: 6412:
   16368*: 6413:    const bool new_is_explicit_child = (new_flags & ImGuiWindowFlags_ChildWindow) != 0 && ((new_flags & ImGuiWindowFlags_Popup) == 0 || (new_flags & ImGuiWindowFlags_ChildMenu) != 0);
    16368: 6413-block 2
branch  0 taken 7539 (fallthrough)
branch  1 taken 8829
     7539: 6413-block 3
branch  2 taken 0 (fallthrough)
branch  3 taken 7539
    %%%%%: 6413-block 4
branch  4 never executed (fallthrough)
branch  5 never executed
     7539: 6413-block 5
     8829: 6413-block 6
    16368: 6414:    const bool child_flag_changed = new_is_explicit_child != window->IsExplicitChild;
    16368: 6415:    if ((just_created || child_flag_changed) && !new_is_explicit_child)
    16368: 6415-block 7
branch  0 taken 16352 (fallthrough)
branch  1 taken 16
    16352: 6415-block 8
branch  2 taken 0 (fallthrough)
branch  3 taken 16352
       16: 6415-block 9
branch  4 taken 9 (fallthrough)
branch  5 taken 7
        -: 6416:    {
       9*: 6417:        IM_ASSERT(!g.WindowsFocusOrder.contains(window));
        9: 6417-block 10
call    0 returned 9
branch  1 taken 0 (fallthrough)
branch  2 taken 9
    %%%%%: 6417-block 12
call    3 never executed
        9: 6418:        g.WindowsFocusOrder.push_back(window);
        9: 6418-block 13
call    0 returned 9
        9: 6419:        window->FocusOrder = (short)(g.WindowsFocusOrder.Size - 1);
        -: 6420:    }
   16359*: 6421:    else if (!just_created && child_flag_changed && new_is_explicit_child)
    16359: 6421-block 15
branch  0 taken 16352 (fallthrough)
branch  1 taken 7
    16352: 6421-block 16
branch  2 taken 0 (fallthrough)
branch  3 taken 16352
    %%%%%: 6421-block 17
branch  4 never executed (fallthrough)
branch  5 never executed
        -: 6422:    {
    #####: 6423:        IM_ASSERT(g.WindowsFocusOrder[window->FocusOrder] == window);
    %%%%%: 6423-block 18
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 6423-block 20
call    3 never executed
    #####: 6424:        for (int n = window->FocusOrder + 1; n < g.WindowsFocusOrder.Size; n++)
    %%%%%: 6424-block 21
    %%%%%: 6424-block 24
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6425:            g.WindowsFocusOrder[n]->FocusOrder--;
    %%%%%: 6425-block 22
call    0 never executed
    #####: 6426:        g.WindowsFocusOrder.erase(g.WindowsFocusOrder.Data + window->FocusOrder);
    %%%%%: 6426-block 25
call    0 never executed
    #####: 6427:        window->FocusOrder = -1;
        -: 6428:    }
    16368: 6429:    window->IsExplicitChild = new_is_explicit_child;
    16368: 6430:}
        -: 6431:
function _ZL24InitOrLoadWindowSettingsP11ImGuiWindowP19ImGuiWindowSettings called 16 returned 100% blocks executed 100%
       16: 6432:static void InitOrLoadWindowSettings(ImGuiWindow* window, ImGuiWindowSettings* settings)
        -: 6433:{
        -: 6434:    // Initial window state with e.g. default/arbitrary window position
        -: 6435:    // Use SetNextWindowPos() with the appropriate condition flag to change the initial position of a window.
       16: 6436:    const ImGuiViewport* main_viewport = ImGui::GetMainViewport();
       16: 6436-block 2
call    0 returned 16
       16: 6437:    window->Pos = main_viewport->Pos + ImVec2(60, 60);
call    0 returned 16
call    1 returned 16
       16: 6438:    window->Size = window->SizeFull = ImVec2(0, 0);
call    0 returned 16
       16: 6439:    window->ViewportPos = main_viewport->Pos;
       16: 6440:    window->SetWindowPosAllowFlags = window->SetWindowSizeAllowFlags = window->SetWindowCollapsedAllowFlags = window->SetWindowDockAllowFlags = ImGuiCond_Always | ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing;
        -: 6441:
       16: 6442:    if (settings != NULL)
branch  0 taken 7 (fallthrough)
branch  1 taken 9
        -: 6443:    {
        7: 6444:        SetWindowConditionAllowFlags(window, ImGuiCond_FirstUseEver, false);
        7: 6444-block 7
call    0 returned 7
        7: 6445:        ApplyWindowSettings(window, settings);
call    0 returned 7
        -: 6446:    }
       16: 6447:    window->DC.CursorStartPos = window->DC.CursorMaxPos = window->DC.IdealMaxPos = window->Pos; // So first call to CalcWindowContentSizes() doesn't return crazy values
        -: 6448:
       16: 6449:    if ((window->Flags & ImGuiWindowFlags_AlwaysAutoResize) != 0)
       16: 6449-block 9
branch  0 taken 1 (fallthrough)
branch  1 taken 15
        -: 6450:    {
        1: 6451:        window->AutoFitFramesX = window->AutoFitFramesY = 2;
        1: 6452:        window->AutoFitOnlyGrows = false;
        1: 6452-block 10
        -: 6453:    }
        -: 6454:    else
        -: 6455:    {
       15: 6456:        if (window->Size.x <= 0.0f)
       15: 6456-block 11
branch  0 taken 8 (fallthrough)
branch  1 taken 7
        8: 6457:            window->AutoFitFramesX = 2;
        8: 6457-block 12
       15: 6458:        if (window->Size.y <= 0.0f)
       15: 6458-block 13
branch  0 taken 8 (fallthrough)
branch  1 taken 7
        8: 6459:            window->AutoFitFramesY = 2;
        8: 6459-block 14
       15: 6460:        window->AutoFitOnlyGrows = (window->AutoFitFramesX > 0) || (window->AutoFitFramesY > 0);
       15: 6460-block 15
branch  0 taken 7 (fallthrough)
branch  1 taken 8
        7: 6460-block 16
branch  2 taken 0 (fallthrough)
branch  3 taken 7
        8: 6460-block 17
        7: 6460-block 18
       15: 6460-block 19
        -: 6461:    }
       16: 6462:}
        -: 6463:
function _ZL15CreateNewWindowPKci called 16 returned 100% blocks executed 84%
       16: 6464:static ImGuiWindow* CreateNewWindow(const char* name, ImGuiWindowFlags flags)
        -: 6465:{
        -: 6466:    // Create window the first time
        -: 6467:    //IMGUI_DEBUG_LOG("CreateNewWindow '%s', flags = 0x%08X\n", name, flags);
       16: 6468:    ImGuiContext& g = *GImGui;
       16: 6469:    ImGuiWindow* window = IM_NEW(ImGuiWindow)(&g, name);
       16: 6469-block 2
call    0 returned 16
branch  1 taken 16 (fallthrough)
branch  2 taken 0 (throw)
       16: 6469-block 3
call    3 returned 16
call    4 returned 16
branch  5 taken 16 (fallthrough)
branch  6 taken 0 (throw)
    $$$$$: 6469-block 17
branch  7 never executed (fallthrough)
branch  8 never executed
    $$$$$: 6469-block 18
call    9 never executed
       16: 6470:    window->Flags = flags;
       16: 6471:    g.WindowsById.SetVoidPtr(window->ID, window);
       16: 6471-block 5
call    0 returned 16
branch  1 taken 16 (fallthrough)
branch  2 taken 0 (throw)
        -: 6472:
       16: 6473:    ImGuiWindowSettings* settings = NULL;
       16: 6474:    if (!(flags & ImGuiWindowFlags_NoSavedSettings))
       16: 6474-block 6
branch  0 taken 7 (fallthrough)
branch  1 taken 9
        7: 6475:        if ((settings = ImGui::FindWindowSettingsByWindow(window)) != 0)
        7: 6475-block 7
call    0 returned 7
branch  1 taken 7 (fallthrough)
branch  2 taken 0 (throw)
        7: 6475-block 8
branch  3 taken 7 (fallthrough)
branch  4 taken 0
        7: 6476:            window->SettingsOffset = g.SettingsWindows.offset_from_ptr(settings);
        7: 6476-block 9
call    0 returned 7
branch  1 taken 7 (fallthrough)
branch  2 taken 0 (throw)
        7: 6476-block 10
        -: 6477:
       16: 6478:    InitOrLoadWindowSettings(window, settings);
       16: 6478-block 11
call    0 returned 16
branch  1 taken 16 (fallthrough)
branch  2 taken 0 (throw)
        -: 6479:
       16: 6480:    if (flags & ImGuiWindowFlags_NoBringToFrontOnFocus)
       16: 6480-block 12
branch  0 taken 1 (fallthrough)
branch  1 taken 15
        1: 6481:        g.Windows.push_front(window); // Quite slow but rare and only once
        1: 6481-block 13
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -: 6482:    else
       15: 6483:        g.Windows.push_back(window);
       15: 6483-block 14
call    0 returned 15
branch  1 taken 15 (fallthrough)
branch  2 taken 0 (throw)
        -: 6484:
       16: 6485:    return window;
       16: 6485-block 15
       16: 6485-block 16
        -: 6486:}
        -: 6487:
function _ZL24GetWindowForTitleDisplayP11ImGuiWindow called 0 returned 0% blocks executed 0%
    #####: 6488:static ImGuiWindow* GetWindowForTitleDisplay(ImGuiWindow* window)
        -: 6489:{
    #####: 6490:    return window->DockNodeAsHost ? window->DockNodeAsHost->VisibleWindow : window;
    %%%%%: 6490-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6490-block 3
    %%%%%: 6490-block 4
    %%%%%: 6490-block 5
        -: 6491:}
        -: 6492:
function _ZL30GetWindowForTitleAndMenuHeightP11ImGuiWindow called 48678 returned 100% blocks executed 100%
    48678: 6493:static ImGuiWindow* GetWindowForTitleAndMenuHeight(ImGuiWindow* window)
        -: 6494:{
    48678: 6495:    return (window->DockNodeAsHost && window->DockNodeAsHost->VisibleWindow) ? window->DockNodeAsHost->VisibleWindow : window;
    48678: 6495-block 2
branch  0 taken 3228 (fallthrough)
branch  1 taken 45450
     3228: 6495-block 3
branch  2 taken 3225 (fallthrough)
branch  3 taken 3
     3225: 6495-block 4
    45453: 6495-block 5
    48678: 6495-block 6
        -: 6496:}
        -: 6497:
function _ZL17CalcWindowMinSizeP11ImGuiWindow called 48678 returned 100% blocks executed 90%
    48678: 6498:static inline ImVec2 CalcWindowMinSize(ImGuiWindow* window)
        -: 6499:{
        -: 6500:    // We give windows non-zero minimum size to facilitate understanding problematic cases (e.g. empty popups)
        -: 6501:    // FIXME: Essentially we want to restrict manual resizing to WindowMinSize+Decoration, and allow api resizing to be smaller.
        -: 6502:    // Perhaps should tend further a neater test for this.
    48678: 6503:    ImGuiContext& g = *GImGui;
    48678: 6504:    ImVec2 size_min;
    48678: 6505:    if ((window->Flags & ImGuiWindowFlags_ChildWindow) && !(window->Flags & ImGuiWindowFlags_Popup))
    48678: 6505-block 2
branch  0 taken 38772 (fallthrough)
branch  1 taken 9906
    38772: 6505-block 3
branch  2 taken 38772 (fallthrough)
branch  3 taken 0
        -: 6506:    {
   38772*: 6507:        size_min.x = (window->ChildFlags & ImGuiChildFlags_ResizeX) ? g.Style.WindowMinSize.x : 4.0f;
    38772: 6507-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 38772
    %%%%%: 6507-block 5
    38772: 6507-block 6
   38772*: 6508:        size_min.y = (window->ChildFlags & ImGuiChildFlags_ResizeY) ? g.Style.WindowMinSize.y : 4.0f;
    38772: 6508-block 7
branch  0 taken 0 (fallthrough)
branch  1 taken 38772
    %%%%%: 6508-block 8
    38772: 6508-block 9
    38772: 6508-block 10
        -: 6509:    }
        -: 6510:    else
        -: 6511:    {
     9906: 6512:        size_min.x = ((window->Flags & ImGuiWindowFlags_AlwaysAutoResize) == 0) ? g.Style.WindowMinSize.x : 4.0f;
     9906: 6512-block 11
branch  0 taken 9693 (fallthrough)
branch  1 taken 213
     9693: 6512-block 12
      213: 6512-block 13
     9906: 6513:        size_min.y = ((window->Flags & ImGuiWindowFlags_AlwaysAutoResize) == 0) ? g.Style.WindowMinSize.y : 4.0f;
     9906: 6513-block 14
branch  0 taken 9693 (fallthrough)
branch  1 taken 213
     9693: 6513-block 15
      213: 6513-block 16
     9906: 6513-block 17
        -: 6514:    }
        -: 6515:
        -: 6516:    // Reduce artifacts with very small windows
    48678: 6517:    ImGuiWindow* window_for_height = GetWindowForTitleAndMenuHeight(window);
    48678: 6517-block 18
call    0 returned 48678
    48678: 6518:    size_min.y = ImMax(size_min.y, window_for_height->TitleBarHeight + window_for_height->MenuBarHeight + ImMax(0.0f, g.Style.WindowRounding - 1.0f));
call    0 returned 48678
call    1 returned 48678
    48678: 6519:    return size_min;
        -: 6520:}
        -: 6521:
function _ZL29CalcWindowSizeAfterConstraintP11ImGuiWindowRK6ImVec2 called 32523 returned 100% blocks executed 29%
    32523: 6522:static ImVec2 CalcWindowSizeAfterConstraint(ImGuiWindow* window, const ImVec2& size_desired)
        -: 6523:{
    32523: 6524:    ImGuiContext& g = *GImGui;
    32523: 6525:    ImVec2 new_size = size_desired;
    32523: 6526:    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSizeConstraint)
    32523: 6526-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 32523
        -: 6527:    {
        -: 6528:        // See comments in SetNextWindowSizeConstraints() for details about setting size_min an size_max.
    #####: 6529:        ImRect cr = g.NextWindowData.SizeConstraintRect;
    #####: 6530:        new_size.x = (cr.Min.x >= 0 && cr.Max.x >= 0) ? ImClamp(new_size.x, cr.Min.x, cr.Max.x) : window->SizeFull.x;
    %%%%%: 6530-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6530-block 4
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6530-block 5
call    4 never executed
    %%%%%: 6530-block 6
    #####: 6531:        new_size.y = (cr.Min.y >= 0 && cr.Max.y >= 0) ? ImClamp(new_size.y, cr.Min.y, cr.Max.y) : window->SizeFull.y;
    %%%%%: 6531-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6531-block 8
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6531-block 9
call    4 never executed
    %%%%%: 6531-block 10
    #####: 6532:        if (g.NextWindowData.SizeCallback)
    %%%%%: 6532-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6533:        {
    #####: 6534:            ImGuiSizeCallbackData data;
    %%%%%: 6534-block 12
call    0 never executed
    #####: 6535:            data.UserData = g.NextWindowData.SizeCallbackUserData;
    #####: 6536:            data.Pos = window->Pos;
    #####: 6537:            data.CurrentSize = window->SizeFull;
    #####: 6538:            data.DesiredSize = new_size;
    #####: 6539:            g.NextWindowData.SizeCallback(&data);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6540:            new_size = data.DesiredSize;
    %%%%%: 6540-block 14
        -: 6541:        }
    #####: 6542:        new_size.x = IM_TRUNC(new_size.x);
    #####: 6543:        new_size.y = IM_TRUNC(new_size.y);
    %%%%%: 6543-block 15
        -: 6544:    }
        -: 6545:
        -: 6546:    // Minimum size
    32523: 6547:    ImVec2 size_min = CalcWindowMinSize(window);
    32523: 6547-block 16
call    0 returned 32523
branch  1 taken 32523 (fallthrough)
branch  2 taken 0 (throw)
    65046: 6548:    return ImMax(new_size, size_min);
    32523: 6548-block 17
call    0 returned 32523
    32523: 6548-block 19
        -: 6549:}
        -: 6550:
function _ZL22CalcWindowContentSizesP11ImGuiWindowP6ImVec2S2_ called 16368 returned 100% blocks executed 62%
    16368: 6551:static void CalcWindowContentSizes(ImGuiWindow* window, ImVec2* content_size_current, ImVec2* content_size_ideal)
        -: 6552:{
    16368: 6553:    bool preserve_old_content_sizes = false;
   16368*: 6554:    if (window->Collapsed && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)
    16368: 6554-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 16368
    %%%%%: 6554-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6554-block 4
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 6555:        preserve_old_content_sizes = true;
    %%%%%: 6555-block 5
   16368*: 6556:    else if (window->Hidden && window->HiddenFramesCannotSkipItems == 0 && window->HiddenFramesCanSkipItems > 0)
    16368: 6556-block 6
branch  0 taken 21 (fallthrough)
branch  1 taken 16347
       21: 6556-block 7
branch  2 taken 0 (fallthrough)
branch  3 taken 21
    %%%%%: 6556-block 8
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 6557:        preserve_old_content_sizes = true;
    %%%%%: 6557-block 9
    16368: 6558:    if (preserve_old_content_sizes)
    16368: 6558-block 10
branch  0 taken 0 (fallthrough)
branch  1 taken 16368
        -: 6559:    {
    #####: 6560:        *content_size_current = window->ContentSize;
    #####: 6561:        *content_size_ideal = window->ContentSizeIdeal;
    #####: 6562:        return;
    %%%%%: 6562-block 11
        -: 6563:    }
        -: 6564:
   16368*: 6565:    content_size_current->x = (window->ContentSizeExplicit.x != 0.0f) ? window->ContentSizeExplicit.x : IM_TRUNC(window->DC.CursorMaxPos.x - window->DC.CursorStartPos.x);
    16368: 6565-block 12
branch  0 taken 0 (fallthrough)
branch  1 taken 16368
    %%%%%: 6565-block 13
    16368: 6565-block 14
   16368*: 6566:    content_size_current->y = (window->ContentSizeExplicit.y != 0.0f) ? window->ContentSizeExplicit.y : IM_TRUNC(window->DC.CursorMaxPos.y - window->DC.CursorStartPos.y);
    16368: 6566-block 15
branch  0 taken 0 (fallthrough)
branch  1 taken 16368
    %%%%%: 6566-block 16
    16368: 6566-block 17
   16368*: 6567:    content_size_ideal->x = (window->ContentSizeExplicit.x != 0.0f) ? window->ContentSizeExplicit.x : IM_TRUNC(ImMax(window->DC.CursorMaxPos.x, window->DC.IdealMaxPos.x) - window->DC.CursorStartPos.x);
    16368: 6567-block 18
branch  0 taken 0 (fallthrough)
branch  1 taken 16368
    %%%%%: 6567-block 19
    16368: 6567-block 20
call    2 returned 16368
   16368*: 6568:    content_size_ideal->y = (window->ContentSizeExplicit.y != 0.0f) ? window->ContentSizeExplicit.y : IM_TRUNC(ImMax(window->DC.CursorMaxPos.y, window->DC.IdealMaxPos.y) - window->DC.CursorStartPos.y);
    16368: 6568-block 22
branch  0 taken 0 (fallthrough)
branch  1 taken 16368
    %%%%%: 6568-block 23
    16368: 6568-block 24
call    2 returned 16368
    16368: 6568-block 26
        -: 6569:}
        -: 6570:
function _ZL21CalcWindowAutoFitSizeP11ImGuiWindowRK6ImVec2 called 16368 returned 100% blocks executed 76%
    16368: 6571:static ImVec2 CalcWindowAutoFitSize(ImGuiWindow* window, const ImVec2& size_contents)
        -: 6572:{
    16368: 6573:    ImGuiContext& g = *GImGui;
    16368: 6574:    ImGuiStyle& style = g.Style;
    16368: 6575:    const float decoration_w_without_scrollbars = window->DecoOuterSizeX1 + window->DecoOuterSizeX2 - window->ScrollbarSizes.x;
    16368: 6576:    const float decoration_h_without_scrollbars = window->DecoOuterSizeY1 + window->DecoOuterSizeY2 - window->ScrollbarSizes.y;
    16368: 6577:    ImVec2 size_pad = window->WindowPadding * 2.0f;
    16368: 6577-block 2
call    0 returned 16368
    16368: 6578:    ImVec2 size_desired = size_contents + size_pad + ImVec2(decoration_w_without_scrollbars, decoration_h_without_scrollbars);
call    0 returned 16368
call    1 returned 16368
call    2 returned 16368
    16368: 6579:    if (window->Flags & ImGuiWindowFlags_Tooltip)
branch  0 taken 213 (fallthrough)
branch  1 taken 16155
        -: 6580:    {
        -: 6581:        // Tooltip always resize
      213: 6582:        return size_desired;
      213: 6582-block 7
        -: 6583:    }
        -: 6584:    else
        -: 6585:    {
        -: 6586:        // Maximum window size is determined by the viewport size or monitor size
    16155: 6587:        ImVec2 size_min = CalcWindowMinSize(window);
    16155: 6587-block 8
call    0 returned 16155
branch  1 taken 16155 (fallthrough)
branch  2 taken 0 (throw)
    16155: 6588:        ImVec2 size_max = ImVec2(FLT_MAX, FLT_MAX);
        -: 6589:
        -: 6590:        // Child windows are layed within their parent (unless they are also popups/menus) and thus have no restriction
    16155: 6591:        if ((window->Flags & ImGuiWindowFlags_ChildWindow) == 0 || (window->Flags & ImGuiWindowFlags_Popup) != 0)
    16155: 6591-block 9
branch  0 taken 12924 (fallthrough)
branch  1 taken 3231
    12924: 6591-block 10
branch  2 taken 0 (fallthrough)
branch  3 taken 12924
        -: 6592:        {
     3231: 6593:            if (!window->ViewportOwned)
     3231: 6593-block 11
branch  0 taken 3231 (fallthrough)
branch  1 taken 0
     3231: 6594:                size_max = ImGui::GetMainViewport()->WorkSize - style.DisplaySafeAreaPadding * 2.0f;
     3231: 6594-block 12
call    0 returned 3231
call    1 returned 3231
branch  2 taken 3231 (fallthrough)
branch  3 taken 0 (throw)
     3231: 6594-block 14
call    4 returned 3231
    $$$$$: 6594-block 49
     3231: 6595:            const int monitor_idx = window->ViewportAllowPlatformMonitorExtend;
    3231*: 6596:            if (monitor_idx >= 0 && monitor_idx < g.PlatformIO.Monitors.Size)
     3231: 6596-block 16
branch  0 taken 0 (fallthrough)
branch  1 taken 3231
    %%%%%: 6596-block 17
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 6597:                size_max = g.PlatformIO.Monitors[monitor_idx].WorkSize - style.DisplaySafeAreaPadding * 2.0f;
    %%%%%: 6597-block 18
call    0 never executed
call    1 never executed
call    2 never executed
        -: 6598:        }
        -: 6599:
    16155: 6600:        ImVec2 size_auto_fit = ImClamp(size_desired, size_min, ImMax(size_min, size_max));
    16155: 6600-block 22
call    0 returned 16155
call    1 returned 16155
        -: 6601:
        -: 6602:        // FIXME: CalcWindowAutoFitSize() doesn't take into account that only one axis may be auto-fit when calculating scrollbars,
        -: 6603:        // we may need to compute/store three variants of size_auto_fit, for x/y/xy.
        -: 6604:        // Here we implement a workaround for child windows only, but a full solution would apply to normal windows as well:
   16155*: 6605:        if ((window->ChildFlags & ImGuiChildFlags_ResizeX) && !(window->ChildFlags & ImGuiChildFlags_ResizeY))
branch  0 taken 0 (fallthrough)
branch  1 taken 16155
    %%%%%: 6605-block 25
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 6606:            size_auto_fit.y = window->SizeFull.y;
    %%%%%: 6606-block 26
    16155: 6607:        else if (!(window->ChildFlags & ImGuiChildFlags_ResizeX) && (window->ChildFlags & ImGuiChildFlags_ResizeY))
    16155: 6607-block 27
branch  0 taken 16155 (fallthrough)
branch  1 taken 0
    16155: 6607-block 28
branch  2 taken 0 (fallthrough)
branch  3 taken 16155
    #####: 6608:            size_auto_fit.x = window->SizeFull.x;
    %%%%%: 6608-block 29
        -: 6609:
        -: 6610:        // When the window cannot fit all contents (either because of constraints, either because screen is too small),
        -: 6611:        // we are growing the size on the other axis to compensate for expected scrollbar. FIXME: Might turn bigger than ViewportSize-WindowPadding.
    16155: 6612:        ImVec2 size_auto_fit_after_constraint = CalcWindowSizeAfterConstraint(window, size_auto_fit);
    16155: 6612-block 30
call    0 returned 16155
branch  1 taken 16155 (fallthrough)
branch  2 taken 0 (throw)
   16155*: 6613:        bool will_have_scrollbar_x = (size_auto_fit_after_constraint.x - size_pad.x - decoration_w_without_scrollbars < size_contents.x && !(window->Flags & ImGuiWindowFlags_NoScrollbar) && (window->Flags & ImGuiWindowFlags_HorizontalScrollbar)) || (window->Flags & ImGuiWindowFlags_AlwaysHorizontalScrollbar);
    16155: 6613-block 31
branch  0 taken 1076 (fallthrough)
branch  1 taken 15079
     1076: 6613-block 32
branch  2 taken 1076 (fallthrough)
branch  3 taken 0
     1076: 6613-block 33
branch  4 taken 1076 (fallthrough)
branch  5 taken 0
    16155: 6613-block 34
branch  6 taken 0 (fallthrough)
branch  7 taken 16155
    %%%%%: 6613-block 35
    16155: 6613-block 36
    16155: 6614:        bool will_have_scrollbar_y = (size_auto_fit_after_constraint.y - size_pad.y - decoration_h_without_scrollbars < size_contents.y && !(window->Flags & ImGuiWindowFlags_NoScrollbar)) || (window->Flags & ImGuiWindowFlags_AlwaysVerticalScrollbar);
    16155: 6614-block 37
branch  0 taken 1076 (fallthrough)
branch  1 taken 15079
     1076: 6614-block 38
branch  2 taken 0 (fallthrough)
branch  3 taken 1076
    15079: 6614-block 39
branch  4 taken 0 (fallthrough)
branch  5 taken 15079
     1076: 6614-block 40
    15079: 6614-block 41
    16155: 6615:        if (will_have_scrollbar_x)
    16155: 6615-block 42
branch  0 taken 0 (fallthrough)
branch  1 taken 16155
    #####: 6616:            size_auto_fit.y += style.ScrollbarSize;
    %%%%%: 6616-block 43
    16155: 6617:        if (will_have_scrollbar_y)
    16155: 6617-block 44
branch  0 taken 1076 (fallthrough)
branch  1 taken 15079
     1076: 6618:            size_auto_fit.x += style.ScrollbarSize;
     1076: 6618-block 45
    16155: 6619:        return size_auto_fit;
    16155: 6619-block 46
        -: 6620:    }
        -: 6621:}
        -: 6622:
function _ZN5ImGui25CalcWindowNextAutoFitSizeEP11ImGuiWindow called 0 returned 0% blocks executed 0%
    #####: 6623:ImVec2 ImGui::CalcWindowNextAutoFitSize(ImGuiWindow* window)
        -: 6624:{
    #####: 6625:    ImVec2 size_contents_current;
    #####: 6626:    ImVec2 size_contents_ideal;
    #####: 6627:    CalcWindowContentSizes(window, &size_contents_current, &size_contents_ideal);
    %%%%%: 6627-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6628:    ImVec2 size_auto_fit = CalcWindowAutoFitSize(window, size_contents_ideal);
    %%%%%: 6628-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6629:    ImVec2 size_final = CalcWindowSizeAfterConstraint(window, size_auto_fit);
    %%%%%: 6629-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6630:    return size_final;
    %%%%%: 6630-block 5
    %%%%%: 6630-block 6
        -: 6631:}
        -: 6632:
function _ZL19GetWindowBgColorIdxP11ImGuiWindow called 15286 returned 100% blocks executed 100%
    15286: 6633:static ImGuiCol GetWindowBgColorIdx(ImGuiWindow* window)
        -: 6634:{
    15286: 6635:    if (window->Flags & (ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_Popup))
    15286: 6635-block 2
branch  0 taken 213 (fallthrough)
branch  1 taken 15073
      213: 6636:        return ImGuiCol_PopupBg;
      213: 6636-block 3
    15073: 6637:    if ((window->Flags & ImGuiWindowFlags_ChildWindow) && !window->DockIsActive)
    15073: 6637-block 4
branch  0 taken 11842 (fallthrough)
branch  1 taken 3231
    11842: 6637-block 5
branch  2 taken 6462 (fallthrough)
branch  3 taken 5380
     6462: 6638:        return ImGuiCol_ChildBg;
     6462: 6638-block 6
     8611: 6639:    return ImGuiCol_WindowBg;
     8611: 6639-block 7
        -: 6640:}
        -: 6641:
function _ZL30CalcResizePosSizeFromAnyCornerP11ImGuiWindowRK6ImVec2S3_PS1_S4_ called 0 returned 0% blocks executed 0%
    #####: 6642:static void CalcResizePosSizeFromAnyCorner(ImGuiWindow* window, const ImVec2& corner_target, const ImVec2& corner_norm, ImVec2* out_pos, ImVec2* out_size)
        -: 6643:{
    #####: 6644:    ImVec2 pos_min = ImLerp(corner_target, window->Pos, corner_norm);                // Expected window upper-left
    %%%%%: 6644-block 2
call    0 never executed
    #####: 6645:    ImVec2 pos_max = ImLerp(window->Pos + window->Size, corner_target, corner_norm); // Expected window lower-right
call    0 never executed
call    1 never executed
    #####: 6646:    ImVec2 size_expected = pos_max - pos_min;
call    0 never executed
    #####: 6647:    ImVec2 size_constrained = CalcWindowSizeAfterConstraint(window, size_expected);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6648:    *out_pos = pos_min;
    #####: 6649:    if (corner_norm.x == 0.0f)
    %%%%%: 6649-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6650:        out_pos->x -= (size_constrained.x - size_expected.x);
    %%%%%: 6650-block 8
    #####: 6651:    if (corner_norm.y == 0.0f)
    %%%%%: 6651-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6652:        out_pos->y -= (size_constrained.y - size_expected.y);
    %%%%%: 6652-block 10
    #####: 6653:    *out_size = size_constrained;
    #####: 6654:}
    %%%%%: 6654-block 11
        -: 6655:
        -: 6656:// Data for resizing from resize grip / corner
        -: 6657:struct ImGuiResizeGripDef
        -: 6658:{
        -: 6659:    ImVec2  CornerPosN;
        -: 6660:    ImVec2  InnerDir;
        -: 6661:    int     AngleMin12, AngleMax12;
        -: 6662:};
        -: 6663:static const ImGuiResizeGripDef resize_grip_def[4] =
        -: 6664:{
        -: 6665:    { ImVec2(1, 1), ImVec2(-1, -1), 0, 3 },  // Lower-right
        -: 6666:    { ImVec2(0, 1), ImVec2(+1, -1), 3, 6 },  // Lower-left
        -: 6667:    { ImVec2(0, 0), ImVec2(+1, +1), 6, 9 },  // Upper-left (Unused)
        -: 6668:    { ImVec2(1, 0), ImVec2(-1, +1), 9, 12 }  // Upper-right (Unused)
        -: 6669:};
        -: 6670:
        -: 6671:// Data for resizing from borders
        -: 6672:struct ImGuiResizeBorderDef
        -: 6673:{
        -: 6674:    ImVec2  InnerDir;               // Normal toward inside
        -: 6675:    ImVec2  SegmentN1, SegmentN2;   // End positions, normalized (0,0: upper left)
        -: 6676:    float   OuterAngle;             // Angle toward outside
        -: 6677:};
        -: 6678:static const ImGuiResizeBorderDef resize_border_def[4] =
        -: 6679:{
        -: 6680:    { ImVec2(+1, 0), ImVec2(0, 1), ImVec2(0, 0), IM_PI * 1.00f }, // Left
        -: 6681:    { ImVec2(-1, 0), ImVec2(1, 0), ImVec2(1, 1), IM_PI * 0.00f }, // Right
        -: 6682:    { ImVec2(0, +1), ImVec2(0, 0), ImVec2(1, 0), IM_PI * 1.50f }, // Up
        -: 6683:    { ImVec2(0, -1), ImVec2(1, 1), ImVec2(0, 1), IM_PI * 0.50f }  // Down
        -: 6684:};
        -: 6685:
function _ZL19GetResizeBorderRectP11ImGuiWindowiff called 0 returned 0% blocks executed 0%
    #####: 6686:static ImRect GetResizeBorderRect(ImGuiWindow* window, int border_n, float perp_padding, float thickness)
        -: 6687:{
    #####: 6688:    ImRect rect = window->Rect();
    %%%%%: 6688-block 2
call    0 never executed
    #####: 6689:    if (thickness == 0.0f)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6690:        rect.Max -= ImVec2(1, 1);
    %%%%%: 6690-block 4
call    0 never executed
call    1 never executed
    #####: 6691:    if (border_n == ImGuiDir_Left)  { return ImRect(rect.Min.x - thickness,    rect.Min.y + perp_padding, rect.Min.x + thickness,    rect.Max.y - perp_padding); }
    %%%%%: 6691-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6691-block 8
call    2 never executed
    %%%%%: 6691-block 10
    #####: 6692:    if (border_n == ImGuiDir_Right) { return ImRect(rect.Max.x - thickness,    rect.Min.y + perp_padding, rect.Max.x + thickness,    rect.Max.y - perp_padding); }
    %%%%%: 6692-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6692-block 12
call    2 never executed
    %%%%%: 6692-block 14
    #####: 6693:    if (border_n == ImGuiDir_Up)    { return ImRect(rect.Min.x + perp_padding, rect.Min.y - thickness,    rect.Max.x - perp_padding, rect.Min.y + thickness);    }
    %%%%%: 6693-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6693-block 16
call    2 never executed
    %%%%%: 6693-block 18
    #####: 6694:    if (border_n == ImGuiDir_Down)  { return ImRect(rect.Min.x + perp_padding, rect.Max.y - thickness,    rect.Max.x - perp_padding, rect.Max.y + thickness);    }
    %%%%%: 6694-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6694-block 20
call    2 never executed
    %%%%%: 6694-block 22
    #####: 6695:    IM_ASSERT(0);
    %%%%%: 6695-block 23
call    0 never executed
        -: 6696:    return ImRect();
        -: 6697:}
        -: 6698:
        -: 6699:// 0..3: corners (Lower-right, Lower-left, Unused, Unused)
function _ZN5ImGui23GetWindowResizeCornerIDEP11ImGuiWindowi called 0 returned 0% blocks executed 0%
    #####: 6700:ImGuiID ImGui::GetWindowResizeCornerID(ImGuiWindow* window, int n)
        -: 6701:{
    #####: 6702:    IM_ASSERT(n >= 0 && n < 4);
    %%%%%: 6702-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6702-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6702-block 4
    %%%%%: 6702-block 5
call    4 never executed
    #####: 6703:    ImGuiID id = window->DockIsActive ? window->DockNode->HostWindow->ID : window->ID;
    %%%%%: 6703-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6703-block 7
    %%%%%: 6703-block 8
    #####: 6704:    id = ImHashStr("#RESIZE", 0, id);
    %%%%%: 6704-block 9
call    0 never executed
    #####: 6705:    id = ImHashData(&n, sizeof(int), id);
call    0 never executed
    #####: 6706:    return id;
        -: 6707:}
        -: 6708:
        -: 6709:// Borders (Left, Right, Up, Down)
function _ZN5ImGui23GetWindowResizeBorderIDEP11ImGuiWindow8ImGuiDir called 0 returned 0% blocks executed 0%
    #####: 6710:ImGuiID ImGui::GetWindowResizeBorderID(ImGuiWindow* window, ImGuiDir dir)
        -: 6711:{
    #####: 6712:    IM_ASSERT(dir >= 0 && dir < 4);
    %%%%%: 6712-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6712-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6712-block 4
    %%%%%: 6712-block 5
call    4 never executed
    #####: 6713:    int n = (int)dir + 4;
    #####: 6714:    ImGuiID id = window->DockIsActive ? window->DockNode->HostWindow->ID : window->ID;
    %%%%%: 6714-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6714-block 7
    %%%%%: 6714-block 8
    #####: 6715:    id = ImHashStr("#RESIZE", 0, id);
    %%%%%: 6715-block 9
call    0 never executed
    #####: 6716:    id = ImHashData(&n, sizeof(int), id);
call    0 never executed
    #####: 6717:    return id;
        -: 6718:}
        -: 6719:
        -: 6720:// Handle resize for: Resize Grips, Borders, Gamepad
        -: 6721:// Return true when using auto-fit (double-click on resize grip)
function _ZN5ImGuiL24UpdateWindowManualResizeEP11ImGuiWindowRK6ImVec2PiS5_iPjRK6ImRect called 10983 returned 100% blocks executed 4%
    10983: 6722:static int ImGui::UpdateWindowManualResize(ImGuiWindow* window, const ImVec2& size_auto_fit, int* border_hovered, int* border_held, int resize_grip_count, ImU32 resize_grip_col[4], const ImRect& visibility_rect)
        -: 6723:{
    10983: 6724:    ImGuiContext& g = *GImGui;
    10983: 6725:    ImGuiWindowFlags flags = window->Flags;
        -: 6726:
    10983: 6727:    if ((flags & ImGuiWindowFlags_NoResize) || (flags & ImGuiWindowFlags_AlwaysAutoResize) || window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)
    10983: 6727-block 2
branch  0 taken 1077 (fallthrough)
branch  1 taken 9906
     1077: 6727-block 3
branch  2 taken 1077 (fallthrough)
branch  3 taken 0
     1077: 6727-block 4
branch  4 taken 1077 (fallthrough)
branch  5 taken 0
     1077: 6727-block 5
branch  6 taken 0 (fallthrough)
branch  7 taken 1077
     9906: 6728:        return false;
     9906: 6728-block 6
     1077: 6729:    if (window->WasActive == false) // Early out to avoid running this code for e.g. a hidden implicit/fallback Debug window.
     1077: 6729-block 7
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 6730:        return false;
     1077: 6730-block 8
        -: 6731:
    #####: 6732:    int ret_auto_fit_mask = 0x00;
    #####: 6733:    const float grip_draw_size = IM_TRUNC(ImMax(g.FontSize * 1.35f, window->WindowRounding + 1.0f + g.FontSize * 0.2f));
    %%%%%: 6733-block 9
call    0 never executed
    #####: 6734:    const float grip_hover_inner_size = (resize_grip_count > 0) ? IM_TRUNC(grip_draw_size * 0.75f) : 0.0f;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6734-block 11
    %%%%%: 6734-block 12
    #####: 6735:    const float grip_hover_outer_size = g.IO.ConfigWindowsResizeFromEdges ? WINDOWS_HOVER_PADDING : 0.0f;
    %%%%%: 6735-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6735-block 14
    %%%%%: 6735-block 15
        -: 6736:
    #####: 6737:    ImRect clamp_rect = visibility_rect;
    #####: 6738:    const bool window_move_from_title_bar = g.IO.ConfigWindowsMoveFromTitleBarOnly && !(window->Flags & ImGuiWindowFlags_NoTitleBar);
    %%%%%: 6738-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6738-block 17
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6738-block 18
    %%%%%: 6738-block 19
    #####: 6739:    if (window_move_from_title_bar)
    %%%%%: 6739-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6740:        clamp_rect.Min.y -= window->TitleBarHeight;
    %%%%%: 6740-block 21
        -: 6741:
    #####: 6742:    ImVec2 pos_target(FLT_MAX, FLT_MAX);
    #####: 6743:    ImVec2 size_target(FLT_MAX, FLT_MAX);
        -: 6744:
        -: 6745:    // Clip mouse interaction rectangles within the viewport rectangle (in practice the narrowing is going to happen most of the time).
        -: 6746:    // - Not narrowing would mostly benefit the situation where OS windows _without_ decoration have a threshold for hovering when outside their limits.
        -: 6747:    //   This is however not the case with current backends under Win32, but a custom borderless window implementation would benefit from it.
        -: 6748:    // - When decoration are enabled we typically benefit from that distance, but then our resize elements would be conflicting with OS resize elements, so we also narrow.
        -: 6749:    // - Note that we are unable to tell if the platform setup allows hovering with a distance threshold (on Win32, decorated window have such threshold).
        -: 6750:    // We only clip interaction so we overwrite window->ClipRect, cannot call PushClipRect() yet as DrawList is not yet setup.
    #####: 6751:    const bool clip_with_viewport_rect = !(g.IO.BackendFlags & ImGuiBackendFlags_HasMouseHoveredViewport) || (g.IO.MouseHoveredViewport != window->ViewportId) || !(window->Viewport->Flags & ImGuiViewportFlags_NoDecoration);
    %%%%%: 6751-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6751-block 23
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6751-block 24
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 6751-block 25
    %%%%%: 6751-block 26
    #####: 6752:    if (clip_with_viewport_rect)
    %%%%%: 6752-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6753:        window->ClipRect = window->Viewport->GetMainRect();
    %%%%%: 6753-block 28
call    0 never executed
        -: 6754:
        -: 6755:    // Resize grips and borders are on layer 1
    #####: 6756:    window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;
        -: 6757:
        -: 6758:    // Manual resize grips
    #####: 6759:    PushID("#RESIZE");
    %%%%%: 6759-block 29
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6760:    for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)
    %%%%%: 6760-block 30
    %%%%%: 6760-block 92
    %%%%%: 6760-block 93
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 6761:    {
    #####: 6762:        const ImGuiResizeGripDef& def = resize_grip_def[resize_grip_n];
    #####: 6763:        const ImVec2 corner = ImLerp(window->Pos, window->Pos + window->Size, def.CornerPosN);
    %%%%%: 6763-block 31
call    0 never executed
call    1 never executed
        -: 6764:
        -: 6765:        // Using the FlattenChilds button flag we make the resize button accessible even if we are hovering over a child window
        -: 6766:        bool hovered, held;
    #####: 6767:        ImRect resize_rect(corner - def.InnerDir * grip_hover_outer_size, corner + def.InnerDir * grip_hover_inner_size);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 6768:        if (resize_rect.Min.x > resize_rect.Max.x) ImSwap(resize_rect.Min.x, resize_rect.Max.x);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6768-block 39
call    2 never executed
    #####: 6769:        if (resize_rect.Min.y > resize_rect.Max.y) ImSwap(resize_rect.Min.y, resize_rect.Max.y);
    %%%%%: 6769-block 40
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6769-block 41
call    2 never executed
    #####: 6770:        ImGuiID resize_grip_id = window->GetID(resize_grip_n); // == GetWindowResizeCornerID()
    %%%%%: 6770-block 42
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6771:        ItemAdd(resize_rect, resize_grip_id, NULL, ImGuiItemFlags_NoNav);
    %%%%%: 6771-block 43
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6772:        ButtonBehavior(resize_rect, resize_grip_id, &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_NoNavFocus);
    %%%%%: 6772-block 44
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6773:        //GetForegroundDrawList(window)->AddRect(resize_rect.Min, resize_rect.Max, IM_COL32(255, 255, 0, 255));
    #####: 6774:        if (hovered || held)
    %%%%%: 6774-block 45
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6774-block 46
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 6775:            SetMouseCursor((resize_grip_n & 1) ? ImGuiMouseCursor_ResizeNESW : ImGuiMouseCursor_ResizeNWSE);
    %%%%%: 6775-block 47
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6775-block 48
    %%%%%: 6775-block 49
    %%%%%: 6775-block 50
call    2 never executed
        -: 6776:
    #####: 6777:        if (held && g.IO.MouseDoubleClicked[0])
    %%%%%: 6777-block 51
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6777-block 52
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 6778:        {
        -: 6779:            // Auto-fit when double-clicking
    #####: 6780:            size_target = CalcWindowSizeAfterConstraint(window, size_auto_fit);
    %%%%%: 6780-block 53
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6781:            ret_auto_fit_mask = 0x03; // Both axises
    #####: 6782:            ClearActiveID();
    %%%%%: 6782-block 54
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6783:        }
    #####: 6784:        else if (held)
    %%%%%: 6784-block 56
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6785:        {
        -: 6786:            // Resize from any of the four corners
        -: 6787:            // We don't use an incremental MouseDelta but rather compute an absolute target size based on mouse position
    #####: 6788:            ImVec2 clamp_min = ImVec2(def.CornerPosN.x == 1.0f ? clamp_rect.Min.x : -FLT_MAX, (def.CornerPosN.y == 1.0f || (def.CornerPosN.y == 0.0f && window_move_from_title_bar)) ? clamp_rect.Min.y : -FLT_MAX);
    %%%%%: 6788-block 57
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6788-block 58
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6788-block 59
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 6788-block 60
    %%%%%: 6788-block 61
    %%%%%: 6788-block 62
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 6788-block 63
    %%%%%: 6788-block 64
    %%%%%: 6788-block 65
call    8 never executed
    #####: 6789:            ImVec2 clamp_max = ImVec2(def.CornerPosN.x == 0.0f ? clamp_rect.Max.x : +FLT_MAX, def.CornerPosN.y == 0.0f ? clamp_rect.Max.y : +FLT_MAX);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6789-block 67
    %%%%%: 6789-block 68
    %%%%%: 6789-block 69
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6789-block 70
    %%%%%: 6789-block 71
    %%%%%: 6789-block 72
call    4 never executed
    #####: 6790:            ImVec2 corner_target = g.IO.MousePos - g.ActiveIdClickOffset + ImLerp(def.InnerDir * grip_hover_outer_size, def.InnerDir * -grip_hover_inner_size, def.CornerPosN); // Corner of the window corresponding to our corner grip
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 6791:            corner_target = ImClamp(corner_target, clamp_min, clamp_max);
call    0 never executed
    #####: 6792:            CalcResizePosSizeFromAnyCorner(window, corner_target, def.CornerPosN, &pos_target, &size_target);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6793:        }
        -: 6794:
        -: 6795:        // Only lower-left grip is visible before hovering/activating
    #####: 6796:        if (resize_grip_n == 0 || held || hovered)
    %%%%%: 6796-block 81
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6796-block 82
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6796-block 83
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 6797:            resize_grip_col[resize_grip_n] = GetColorU32(held ? ImGuiCol_ResizeGripActive : hovered ? ImGuiCol_ResizeGripHovered : ImGuiCol_ResizeGrip);
    %%%%%: 6797-block 84
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6797-block 85
    %%%%%: 6797-block 86
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6797-block 87
    %%%%%: 6797-block 88
    %%%%%: 6797-block 89
    %%%%%: 6797-block 90
call    4 never executed
        -: 6798:    }
        -: 6799:
    #####: 6800:    int resize_border_mask = 0x00;
    #####: 6801:    if (window->Flags & ImGuiWindowFlags_ChildWindow)
    %%%%%: 6801-block 94
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6802:        resize_border_mask |= ((window->ChildFlags & ImGuiChildFlags_ResizeX) ? 0x02 : 0) | ((window->ChildFlags & ImGuiChildFlags_ResizeY) ? 0x08 : 0);
    %%%%%: 6802-block 95
        -: 6803:    else
    #####: 6804:        resize_border_mask = g.IO.ConfigWindowsResizeFromEdges ? 0x0F : 0x00;
    %%%%%: 6804-block 96
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6804-block 97
    %%%%%: 6804-block 98
    %%%%%: 6804-block 99
    #####: 6805:    for (int border_n = 0; border_n < 4; border_n++)
    %%%%%: 6805-block 100
    %%%%%: 6805-block 203
    %%%%%: 6805-block 204
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 6806:    {
    #####: 6807:        if ((resize_border_mask & (1 << border_n)) == 0)
    %%%%%: 6807-block 101
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6808:            continue;
    %%%%%: 6808-block 102
    #####: 6809:        const ImGuiResizeBorderDef& def = resize_border_def[border_n];
    #####: 6810:        const ImGuiAxis axis = (border_n == ImGuiDir_Left || border_n == ImGuiDir_Right) ? ImGuiAxis_X : ImGuiAxis_Y;
    %%%%%: 6810-block 103
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6810-block 104
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6810-block 105
    %%%%%: 6810-block 106
        -: 6811:
        -: 6812:        bool hovered, held;
    #####: 6813:        ImRect border_rect = GetResizeBorderRect(window, border_n, grip_hover_inner_size, WINDOWS_HOVER_PADDING);
    %%%%%: 6813-block 107
call    0 never executed
    #####: 6814:        ImGuiID border_id = window->GetID(border_n + 4); // == GetWindowResizeBorderID()
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6815:        ItemAdd(border_rect, border_id, NULL, ImGuiItemFlags_NoNav);
    %%%%%: 6815-block 109
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6816:        ButtonBehavior(border_rect, border_id, &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_NoNavFocus);
    %%%%%: 6816-block 110
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6817:        //GetForegroundDrawList(window)->AddRect(border_rect.Min, border_rect.Max, IM_COL32(255, 255, 0, 255));
    #####: 6818:        if (hovered && g.HoveredIdTimer <= WINDOWS_RESIZE_FROM_EDGES_FEEDBACK_TIMER)
    %%%%%: 6818-block 111
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6818-block 112
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 6819:            hovered = false;
    %%%%%: 6819-block 113
    #####: 6820:        if (hovered || held)
    %%%%%: 6820-block 114
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6820-block 115
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 6821:            SetMouseCursor((axis == ImGuiAxis_X) ? ImGuiMouseCursor_ResizeEW : ImGuiMouseCursor_ResizeNS);
    %%%%%: 6821-block 116
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6821-block 117
    %%%%%: 6821-block 118
    %%%%%: 6821-block 119
call    2 never executed
    #####: 6822:        if (held && g.IO.MouseDoubleClicked[0])
    %%%%%: 6822-block 120
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6822-block 121
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 6823:        {
        -: 6824:            // Double-clicking bottom or right border auto-fit on this axis
        -: 6825:            // FIXME: CalcWindowAutoFitSize() doesn't take into account that only one side may be auto-fit when calculating scrollbars.
        -: 6826:            // FIXME: Support top and right borders: rework CalcResizePosSizeFromAnyCorner() to be reusable in both cases.
    #####: 6827:            if (border_n == 1 || border_n == 3) // Right and bottom border
    %%%%%: 6827-block 122
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6827-block 123
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 6828:            {
    #####: 6829:                size_target[axis] = CalcWindowSizeAfterConstraint(window, size_auto_fit)[axis];
    %%%%%: 6829-block 124
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 6829-block 125
call    3 never executed
call    4 never executed
    $$$$$: 6829-block 266
    #####: 6830:                ret_auto_fit_mask |= (1 << axis);
    #####: 6831:                hovered = held = false; // So border doesn't show highlighted at new position
        -: 6832:            }
    #####: 6833:            ClearActiveID();
    %%%%%: 6833-block 128
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6834:        }
    #####: 6835:        else if (held)
    %%%%%: 6835-block 130
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6836:        {
        -: 6837:            // Switch to relative resizing mode when border geometry moved (e.g. resizing a child altering parent scroll), in order to avoid resizing feedback loop.
        -: 6838:            // Currently only using relative mode on resizable child windows, as the problem to solve is more likely noticeable for them, but could apply for all windows eventually.
        -: 6839:            // FIXME: May want to generalize this idiom at lower-level, so more widgets can use it!
    #####: 6840:            const bool just_scrolled_manually_while_resizing = (g.WheelingWindow != NULL && g.WheelingWindowScrolledFrame == g.FrameCount && IsWindowChildOf(window, g.WheelingWindow, false, true));
    %%%%%: 6840-block 131
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6840-block 132
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6840-block 133
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 6840-block 135
    %%%%%: 6840-block 136
    #####: 6841:            if (g.ActiveIdIsJustActivated || just_scrolled_manually_while_resizing)
    %%%%%: 6841-block 137
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6841-block 138
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 6842:            {
    #####: 6843:                g.WindowResizeBorderExpectedRect = border_rect;
    #####: 6844:                g.WindowResizeRelativeMode = false;
    %%%%%: 6844-block 139
        -: 6845:            }
    #####: 6846:            if ((window->Flags & ImGuiWindowFlags_ChildWindow) && memcmp(&g.WindowResizeBorderExpectedRect, &border_rect, sizeof(ImRect)) != 0)
    %%%%%: 6846-block 140
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6846-block 141
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 6847:                g.WindowResizeRelativeMode = true;
    %%%%%: 6847-block 142
        -: 6848:
    #####: 6849:            const ImVec2 border_curr = (window->Pos + ImMin(def.SegmentN1, def.SegmentN2) * window->Size);
    %%%%%: 6849-block 143
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 6850:            const float border_target_rel_mode_for_axis = border_curr[axis] + g.IO.MouseDelta[axis];
call    0 never executed
call    1 never executed
    #####: 6851:            const float border_target_abs_mode_for_axis = g.IO.MousePos[axis] - g.ActiveIdClickOffset[axis] + WINDOWS_HOVER_PADDING; // Match ButtonBehavior() padding above.
call    0 never executed
call    1 never executed
        -: 6852:
        -: 6853:            // Use absolute mode position
    #####: 6854:            ImVec2 border_target = window->Pos;
    #####: 6855:            border_target[axis] = border_target_abs_mode_for_axis;
call    0 never executed
        -: 6856:
        -: 6857:            // Use relative mode target for child window, ignore resize when moving back toward the ideal absolute position.
    #####: 6858:            bool ignore_resize = false;
    #####: 6859:            if (g.WindowResizeRelativeMode)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6860:            {
        -: 6861:                //GetForegroundDrawList()->AddText(GetMainViewport()->WorkPos, IM_COL32_WHITE, "Relative Mode");
    #####: 6862:                border_target[axis] = border_target_rel_mode_for_axis;
    %%%%%: 6862-block 152
call    0 never executed
    #####: 6863:                if (g.IO.MouseDelta[axis] == 0.0f || (g.IO.MouseDelta[axis] > 0.0f) == (border_target_rel_mode_for_axis > border_target_abs_mode_for_axis))
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 6863-block 155
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 6863-block 157
    %%%%%: 6863-block 158
    %%%%%: 6863-block 159
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 6864:                    ignore_resize = true;
    %%%%%: 6864-block 160
        -: 6865:            }
        -: 6866:
        -: 6867:            // Clamp, apply
    #####: 6868:            ImVec2 clamp_min(border_n == ImGuiDir_Right ? clamp_rect.Min.x : -FLT_MAX, border_n == ImGuiDir_Down || (border_n == ImGuiDir_Up && window_move_from_title_bar) ? clamp_rect.Min.y : -FLT_MAX);
    %%%%%: 6868-block 161
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6868-block 162
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6868-block 163
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 6868-block 164
    %%%%%: 6868-block 165
    %%%%%: 6868-block 166
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 6868-block 167
    %%%%%: 6868-block 168
    %%%%%: 6868-block 169
call    8 never executed
    #####: 6869:            ImVec2 clamp_max(border_n == ImGuiDir_Left ? clamp_rect.Max.x : +FLT_MAX, border_n == ImGuiDir_Up ? clamp_rect.Max.y : +FLT_MAX);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6869-block 171
    %%%%%: 6869-block 172
    %%%%%: 6869-block 173
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6869-block 174
    %%%%%: 6869-block 175
    %%%%%: 6869-block 176
call    4 never executed
    #####: 6870:            border_target = ImClamp(border_target, clamp_min, clamp_max);
call    0 never executed
    #####: 6871:            if (flags & ImGuiWindowFlags_ChildWindow) // Clamp resizing of childs within parent
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6872:            {
    #####: 6873:                ImGuiWindow* parent_window = window->ParentWindow;
    #####: 6874:                ImGuiWindowFlags parent_flags = parent_window->Flags;
    #####: 6875:                ImRect border_limit_rect = parent_window->InnerRect;
    #####: 6876:                border_limit_rect.Expand(ImVec2(-ImMax(parent_window->WindowPadding.x, parent_window->WindowBorderSize), -ImMax(parent_window->WindowPadding.y, parent_window->WindowBorderSize)));
    %%%%%: 6876-block 179
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 6877:                if ((axis == ImGuiAxis_X) && ((parent_flags & (ImGuiWindowFlags_HorizontalScrollbar | ImGuiWindowFlags_AlwaysHorizontalScrollbar)) == 0 || (parent_flags & ImGuiWindowFlags_NoScrollbar)))
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6877-block 184
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6877-block 185
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 6878:                    border_target.x = ImClamp(border_target.x, border_limit_rect.Min.x, border_limit_rect.Max.x);
    %%%%%: 6878-block 186
call    0 never executed
    #####: 6879:                if ((axis == ImGuiAxis_Y) && (parent_flags & ImGuiWindowFlags_NoScrollbar))
    %%%%%: 6879-block 188
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6879-block 189
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 6880:                    border_target.y = ImClamp(border_target.y, border_limit_rect.Min.y, border_limit_rect.Max.y);
    %%%%%: 6880-block 190
call    0 never executed
        -: 6881:            }
    #####: 6882:            if (!ignore_resize)
    %%%%%: 6882-block 193
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6883:                CalcResizePosSizeFromAnyCorner(window, border_target, ImMin(def.SegmentN1, def.SegmentN2), &pos_target, &size_target);
    %%%%%: 6883-block 194
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 6883-block 196
    $$$$$: 6883-block 267
        -: 6884:        }
    #####: 6885:        if (hovered)
    %%%%%: 6885-block 198
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6886:            *border_hovered = border_n;
    %%%%%: 6886-block 199
    #####: 6887:        if (held)
    %%%%%: 6887-block 200
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6888:            *border_held = border_n;
    %%%%%: 6888-block 201
        -: 6889:    }
    #####: 6890:    PopID();
    %%%%%: 6890-block 205
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6891:
        -: 6892:    // Restore nav layer
    #####: 6893:    window->DC.NavLayerCurrent = ImGuiNavLayer_Main;
        -: 6894:
        -: 6895:    // Navigation resize (keyboard/gamepad)
        -: 6896:    // FIXME: This cannot be moved to NavUpdateWindowing() because CalcWindowSizeAfterConstraint() need to callback into user.
        -: 6897:    // Not even sure the callback works here.
    #####: 6898:    if (g.NavWindowingTarget && g.NavWindowingTarget->RootWindowDockTree == window)
    %%%%%: 6898-block 206
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6898-block 207
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 6899:    {
    #####: 6900:        ImVec2 nav_resize_dir;
    #####: 6901:        if (g.NavInputSource == ImGuiInputSource_Keyboard && g.IO.KeyShift)
    %%%%%: 6901-block 208
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6901-block 209
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 6902:            nav_resize_dir = GetKeyMagnitude2d(ImGuiKey_LeftArrow, ImGuiKey_RightArrow, ImGuiKey_UpArrow, ImGuiKey_DownArrow);
    %%%%%: 6902-block 210
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6903:        if (g.NavInputSource == ImGuiInputSource_Gamepad)
    %%%%%: 6903-block 211
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6904:            nav_resize_dir = GetKeyMagnitude2d(ImGuiKey_GamepadDpadLeft, ImGuiKey_GamepadDpadRight, ImGuiKey_GamepadDpadUp, ImGuiKey_GamepadDpadDown);
    %%%%%: 6904-block 212
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6905:        if (nav_resize_dir.x != 0.0f || nav_resize_dir.y != 0.0f)
    %%%%%: 6905-block 213
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6905-block 214
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 6906:        {
    #####: 6907:            const float NAV_RESIZE_SPEED = 600.0f;
    #####: 6908:            const float resize_step = NAV_RESIZE_SPEED * g.IO.DeltaTime * ImMin(g.IO.DisplayFramebufferScale.x, g.IO.DisplayFramebufferScale.y);
    %%%%%: 6908-block 215
call    0 never executed
    #####: 6909:            g.NavWindowingAccumDeltaSize += nav_resize_dir * resize_step;
call    0 never executed
call    1 never executed
    #####: 6910:            g.NavWindowingAccumDeltaSize = ImMax(g.NavWindowingAccumDeltaSize, clamp_rect.Min - window->Pos - window->Size); // We need Pos+Size >= clmap_rect.Min, so Size >= clmap_rect.Min - Pos, so size_delta >= clmap_rect.Min - window->Pos - window->Size
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 6911:            g.NavWindowingToggleLayer = false;
    #####: 6912:            g.NavHighlightItemUnderNav = true;
    #####: 6913:            resize_grip_col[0] = GetColorU32(ImGuiCol_ResizeGripActive);
call    0 never executed
    #####: 6914:            ImVec2 accum_floored = ImTrunc(g.NavWindowingAccumDeltaSize);
call    0 never executed
    #####: 6915:            if (accum_floored.x != 0.0f || accum_floored.y != 0.0f)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6915-block 224
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 6916:            {
        -: 6917:                // FIXME-NAV: Should store and accumulate into a separate size buffer to handle sizing constraints properly, right now a constraint will make us stuck.
    #####: 6918:                size_target = CalcWindowSizeAfterConstraint(window, window->SizeFull + accum_floored);
    %%%%%: 6918-block 225
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$: 6918-block 270
    #####: 6919:                g.NavWindowingAccumDeltaSize -= accum_floored;
    %%%%%: 6919-block 227
call    0 never executed
        -: 6920:            }
        -: 6921:        }
        -: 6922:    }
        -: 6923:
        -: 6924:    // Apply back modified position/size to window
    #####: 6925:    const ImVec2 curr_pos = window->Pos;
    #####: 6926:    const ImVec2 curr_size = window->SizeFull;
    #####: 6927:    if (size_target.x != FLT_MAX && (window->Size.x != size_target.x || window->SizeFull.x != size_target.x))
    %%%%%: 6927-block 230
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6927-block 231
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6927-block 232
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 6928:        window->Size.x = window->SizeFull.x = size_target.x;
    %%%%%: 6928-block 233
    #####: 6929:    if (size_target.y != FLT_MAX && (window->Size.y != size_target.y || window->SizeFull.y != size_target.y))
    %%%%%: 6929-block 234
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6929-block 235
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6929-block 236
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 6930:        window->Size.y = window->SizeFull.y = size_target.y;
    %%%%%: 6930-block 237
    #####: 6931:    if (pos_target.x != FLT_MAX && window->Pos.x != ImTrunc(pos_target.x))
    %%%%%: 6931-block 238
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6931-block 239
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 6931-block 241
    %%%%%: 6931-block 242
    %%%%%: 6931-block 243
branch  5 never executed (fallthrough)
branch  6 never executed
    #####: 6932:        window->Pos.x = ImTrunc(pos_target.x);
    %%%%%: 6932-block 244
call    0 never executed
    #####: 6933:    if (pos_target.y != FLT_MAX && window->Pos.y != ImTrunc(pos_target.y))
    %%%%%: 6933-block 246
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6933-block 247
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 6933-block 249
    %%%%%: 6933-block 250
    %%%%%: 6933-block 251
branch  5 never executed (fallthrough)
branch  6 never executed
    #####: 6934:        window->Pos.y = ImTrunc(pos_target.y);
    %%%%%: 6934-block 252
call    0 never executed
    #####: 6935:    if (curr_pos.x != window->Pos.x || curr_pos.y != window->Pos.y || curr_size.x != window->SizeFull.x || curr_size.y != window->SizeFull.y)
    %%%%%: 6935-block 254
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6935-block 255
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6935-block 256
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 6935-block 257
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 6936:        MarkIniSettingsDirty(window);
    %%%%%: 6936-block 258
call    0 never executed
        -: 6937:
        -: 6938:    // Recalculate next expected border expected coordinates
    #####: 6939:    if (*border_held != -1)
    %%%%%: 6939-block 259
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6940:        g.WindowResizeBorderExpectedRect = GetResizeBorderRect(window, *border_held, grip_hover_inner_size, WINDOWS_HOVER_PADDING);
    %%%%%: 6940-block 260
call    0 never executed
        -: 6941:
    #####: 6942:    return ret_auto_fit_mask;
    %%%%%: 6942-block 261
        -: 6943:}
        -: 6944:
function _ZL14ClampWindowPosP11ImGuiWindowRK6ImRect called 1290 returned 100% blocks executed 50%
     1290: 6945:static inline void ClampWindowPos(ImGuiWindow* window, const ImRect& visibility_rect)
        -: 6946:{
     1290: 6947:    ImGuiContext& g = *GImGui;
     1290: 6948:    ImVec2 size_for_clamping = window->Size;
    1290*: 6949:    if (g.IO.ConfigWindowsMoveFromTitleBarOnly && window->DockNodeAsHost)
     1290: 6949-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1290
    %%%%%: 6949-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 6950:        size_for_clamping.y = ImGui::GetFrameHeight(); // Not using window->TitleBarHeight() as DockNodeAsHost will report 0.0f here.
    %%%%%: 6950-block 4
call    0 never executed
    1290*: 6951:    else if (g.IO.ConfigWindowsMoveFromTitleBarOnly && !(window->Flags & ImGuiWindowFlags_NoTitleBar))
     1290: 6951-block 6
branch  0 taken 0 (fallthrough)
branch  1 taken 1290
    %%%%%: 6951-block 7
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 6952:        size_for_clamping.y = window->TitleBarHeight;
    %%%%%: 6952-block 8
     1290: 6953:    window->Pos = ImClamp(window->Pos, visibility_rect.Min - size_for_clamping, visibility_rect.Max);
     1290: 6953-block 9
call    0 returned 1290
call    1 returned 1290
     1290: 6954:}
        -: 6955:
function _ZL29RenderWindowOuterSingleBorderP11ImGuiWindowijf called 0 returned 0% blocks executed 0%
    #####: 6956:static void RenderWindowOuterSingleBorder(ImGuiWindow* window, int border_n, ImU32 border_col, float border_size)
        -: 6957:{
    #####: 6958:    const ImGuiResizeBorderDef& def = resize_border_def[border_n];
    #####: 6959:    const float rounding = window->WindowRounding;
    #####: 6960:    const ImRect border_r = GetResizeBorderRect(window, border_n, rounding, 0.0f);
    %%%%%: 6960-block 2
call    0 never executed
    #####: 6961:    window->DrawList->PathArcTo(ImLerp(border_r.Min, border_r.Max, def.SegmentN1) + ImVec2(0.5f, 0.5f) + def.InnerDir * rounding, rounding, def.OuterAngle - IM_PI * 0.25f, def.OuterAngle);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
    $$$$$: 6961-block 17
    $$$$$: 6961-block 18
    $$$$$: 6961-block 19
    $$$$$: 6961-block 20
    $$$$$: 6961-block 21
    #####: 6962:    window->DrawList->PathArcTo(ImLerp(border_r.Min, border_r.Max, def.SegmentN2) + ImVec2(0.5f, 0.5f) + def.InnerDir * rounding, rounding, def.OuterAngle, def.OuterAngle + IM_PI * 0.25f);
    %%%%%: 6962-block 9
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
    $$$$$: 6962-block 22
    $$$$$: 6962-block 23
    $$$$$: 6962-block 24
    $$$$$: 6962-block 25
    $$$$$: 6962-block 26
    #####: 6963:    window->DrawList->PathStroke(border_col, ImDrawFlags_None, border_size);
    %%%%%: 6963-block 15
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6964:}
    %%%%%: 6964-block 16
        -: 6965:
function _ZN5ImGuiL24RenderWindowOuterBordersEP11ImGuiWindow called 10984 returned 100% blocks executed 36%
    10984: 6966:static void ImGui::RenderWindowOuterBorders(ImGuiWindow* window)
        -: 6967:{
    10984: 6968:    ImGuiContext& g = *GImGui;
    10984: 6969:    const float border_size = window->WindowBorderSize;
    10984: 6970:    const ImU32 border_col = GetColorU32(ImGuiCol_Border);
    10984: 6970-block 2
call    0 returned 10984
    10984: 6971:    if (border_size > 0.0f && (window->Flags & ImGuiWindowFlags_NoBackground) == 0)
branch  0 taken 213 (fallthrough)
branch  1 taken 10771
      213: 6971-block 4
branch  2 taken 213 (fallthrough)
branch  3 taken 0
      213: 6972:        window->DrawList->AddRect(window->Pos, window->Pos + window->Size, border_col, window->WindowRounding, 0, window->WindowBorderSize);
      213: 6972-block 5
call    0 returned 213
call    1 returned 213
branch  2 taken 213 (fallthrough)
branch  3 taken 0 (throw)
      213: 6972-block 7
    $$$$$: 6972-block 32
call    4 never executed
    10771: 6973:    else if (border_size > 0.0f)
    10771: 6973-block 8
branch  0 taken 0 (fallthrough)
branch  1 taken 10771
        -: 6974:    {
    #####: 6975:        if (window->ChildFlags & ImGuiChildFlags_ResizeX) // Similar code as 'resize_border_mask' computation in UpdateWindowManualResize() but we specifically only always draw explicit child resize border.
    %%%%%: 6975-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6976:            RenderWindowOuterSingleBorder(window, 1, border_col, border_size);
    %%%%%: 6976-block 10
call    0 never executed
    #####: 6977:        if (window->ChildFlags & ImGuiChildFlags_ResizeY)
    %%%%%: 6977-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6978:            RenderWindowOuterSingleBorder(window, 3, border_col, border_size);
    %%%%%: 6978-block 12
call    0 never executed
        -: 6979:    }
    10984: 6980:    if (window->ResizeBorderHovered != -1 || window->ResizeBorderHeld != -1)
    10984: 6980-block 13
branch  0 taken 10984 (fallthrough)
branch  1 taken 0
    10984: 6980-block 14
branch  2 taken 0 (fallthrough)
branch  3 taken 10984
        -: 6981:    {
    #####: 6982:        const int border_n = (window->ResizeBorderHeld != -1) ? window->ResizeBorderHeld : window->ResizeBorderHovered;
    %%%%%: 6982-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6982-block 16
    %%%%%: 6982-block 17
    #####: 6983:        const ImU32 border_col_resizing = GetColorU32((window->ResizeBorderHeld != -1) ? ImGuiCol_SeparatorActive : ImGuiCol_SeparatorHovered);
    %%%%%: 6983-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6983-block 19
    %%%%%: 6983-block 20
    %%%%%: 6983-block 21
call    2 never executed
    #####: 6984:        RenderWindowOuterSingleBorder(window, border_n, border_col_resizing, ImMax(2.0f, window->WindowBorderSize)); // Thicker than usual
call    0 never executed
call    1 never executed
        -: 6985:    }
   10984*: 6986:    if (g.Style.FrameBorderSize > 0 && !(window->Flags & ImGuiWindowFlags_NoTitleBar) && !window->DockIsActive)
    10984: 6986-block 24
branch  0 taken 0 (fallthrough)
branch  1 taken 10984
    %%%%%: 6986-block 25
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6986-block 26
branch  4 never executed (fallthrough)
branch  5 never executed
        -: 6987:    {
    #####: 6988:        float y = window->Pos.y + window->TitleBarHeight - 1;
    #####: 6989:        window->DrawList->AddLine(ImVec2(window->Pos.x + border_size, y), ImVec2(window->Pos.x + window->Size.x - border_size, y), border_col, g.Style.FrameBorderSize);
    %%%%%: 6989-block 27
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 6989-block 30
    $$$$$: 6989-block 33
        -: 6990:    }
    10984: 6991:}
    10984: 6991-block 31
        -: 6992:
        -: 6993:// Draw background and borders
        -: 6994:// Draw and handle scrollbars
function _ZN5ImGuiL23RenderWindowDecorationsEP11ImGuiWindowRK6ImRectbbiPKjf called 16363 returned 100% blocks executed 40%
    16363: 6995:void ImGui::RenderWindowDecorations(ImGuiWindow* window, const ImRect& title_bar_rect, bool title_bar_is_highlight, bool handle_borders_and_resize_grips, int resize_grip_count, const ImU32 resize_grip_col[4], float resize_grip_draw_size)
        -: 6996:{
    16363: 6997:    ImGuiContext& g = *GImGui;
    16363: 6998:    ImGuiStyle& style = g.Style;
    16363: 6999:    ImGuiWindowFlags flags = window->Flags;
        -: 7000:
        -: 7001:    // Ensure that ScrollBar doesn't read last frame's SkipItems
   16363*: 7002:    IM_ASSERT(window->BeginCount == 0);
    16363: 7002-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 16363
    %%%%%: 7002-block 3
call    2 never executed
    16363: 7003:    window->SkipItems = false;
        -: 7004:
        -: 7005:    // Draw window + handle manual resize
        -: 7006:    // As we highlight the title bar when want_focus is set, multiple reappearing windows will have their title bar highlighted on their reappearing frame.
    16363: 7007:    const float window_rounding = window->WindowRounding;
    16363: 7008:    const float window_border_size = window->WindowBorderSize;
    16363: 7009:    if (window->Collapsed)
    16363: 7009-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 16363
        -: 7010:    {
        -: 7011:        // Title bar only
    #####: 7012:        const float backup_border_size = style.FrameBorderSize;
    #####: 7013:        g.Style.FrameBorderSize = window->WindowBorderSize;
    #####: 7014:        ImU32 title_bar_col = GetColorU32((title_bar_is_highlight && g.NavCursorVisible) ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBgCollapsed);
    %%%%%: 7014-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7014-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7014-block 7
    %%%%%: 7014-block 8
    %%%%%: 7014-block 9
call    4 never executed
    #####: 7015:        if (window->ViewportOwned)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7016:            title_bar_col |= IM_COL32_A_MASK; // No alpha (we don't support is_docking_transparent_payload here because simpler and less meaningful, but could with a bit of code shuffle/reuse)
    %%%%%: 7016-block 11
    #####: 7017:        RenderFrame(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, true, window_rounding);
    %%%%%: 7017-block 12
call    0 never executed
    #####: 7018:        g.Style.FrameBorderSize = backup_border_size;
        -: 7019:    }
        -: 7020:    else
        -: 7021:    {
        -: 7022:        // Window background
    16363: 7023:        if (!(flags & ImGuiWindowFlags_NoBackground))
    16363: 7023-block 14
branch  0 taken 15286 (fallthrough)
branch  1 taken 1077
        -: 7024:        {
    15286: 7025:            bool is_docking_transparent_payload = false;
   15286*: 7026:            if (g.DragDropActive && (g.FrameCount - g.DragDropAcceptFrameCount) <= 1 && g.IO.ConfigDockingTransparentPayload)
    15286: 7026-block 15
branch  0 taken 0 (fallthrough)
branch  1 taken 15286
    %%%%%: 7026-block 16
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7026-block 17
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 7027:                if (g.DragDropPayload.IsDataType(IMGUI_PAYLOAD_TYPE_WINDOW) && *(ImGuiWindow**)g.DragDropPayload.Data == window)
    %%%%%: 7027-block 18
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 7027-block 20
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 7027-block 21
    %%%%%: 7027-block 22
    %%%%%: 7027-block 23
branch  5 never executed (fallthrough)
branch  6 never executed
    #####: 7028:                    is_docking_transparent_payload = true;
    %%%%%: 7028-block 24
        -: 7029:
    15286: 7030:            ImU32 bg_col = GetColorU32(GetWindowBgColorIdx(window));
    15286: 7030-block 25
call    0 returned 15286
call    1 returned 15286
    15286: 7031:            if (window->ViewportOwned)
branch  0 taken 0 (fallthrough)
branch  1 taken 15286
        -: 7032:            {
    #####: 7033:                bg_col |= IM_COL32_A_MASK; // No alpha
    #####: 7034:                if (is_docking_transparent_payload)
    %%%%%: 7034-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7035:                    window->Viewport->Alpha *= DOCKING_TRANSPARENT_PAYLOAD_ALPHA;
    %%%%%: 7035-block 29
        -: 7036:            }
        -: 7037:            else
        -: 7038:            {
        -: 7039:                // Adjust alpha. For docking
    15286: 7040:                bool override_alpha = false;
    15286: 7041:                float alpha = 1.0f;
    15286: 7042:                if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasBgAlpha)
    15286: 7042-block 30
branch  0 taken 0 (fallthrough)
branch  1 taken 15286
        -: 7043:                {
    #####: 7044:                    alpha = g.NextWindowData.BgAlphaVal;
    #####: 7045:                    override_alpha = true;
    %%%%%: 7045-block 31
        -: 7046:                }
    15286: 7047:                if (is_docking_transparent_payload)
    15286: 7047-block 32
branch  0 taken 0 (fallthrough)
branch  1 taken 15286
        -: 7048:                {
    #####: 7049:                    alpha *= DOCKING_TRANSPARENT_PAYLOAD_ALPHA; // FIXME-DOCK: Should that be an override?
    #####: 7050:                    override_alpha = true;
    %%%%%: 7050-block 33
        -: 7051:                }
    15286: 7052:                if (override_alpha)
    15286: 7052-block 34
branch  0 taken 0 (fallthrough)
branch  1 taken 15286
    #####: 7053:                    bg_col = (bg_col & ~IM_COL32_A_MASK) | (IM_F32_TO_INT8_SAT(alpha) << IM_COL32_A_SHIFT);
    %%%%%: 7053-block 35
call    0 never executed
        -: 7054:            }
        -: 7055:
        -: 7056:            // Render, for docked windows and host windows we ensure bg goes before decorations
    15286: 7057:            if (window->DockIsActive)
    15286: 7057-block 37
branch  0 taken 5380 (fallthrough)
branch  1 taken 9906
     5380: 7058:                window->DockNode->LastBgColor = bg_col;
     5380: 7058-block 38
    15286: 7059:            ImDrawList* bg_draw_list = window->DockIsActive ? window->DockNode->HostWindow->DrawList : window->DrawList;
    15286: 7059-block 39
branch  0 taken 5380 (fallthrough)
branch  1 taken 9906
     5380: 7059-block 40
     9906: 7059-block 41
    15286: 7060:            if (window->DockIsActive || (flags & ImGuiWindowFlags_DockNodeHost))
    15286: 7060-block 42
branch  0 taken 9906 (fallthrough)
branch  1 taken 5380
     9906: 7060-block 43
branch  2 taken 0 (fallthrough)
branch  3 taken 9906
     5380: 7061:                bg_draw_list->ChannelsSetCurrent(DOCKING_HOST_DRAW_CHANNEL_BG);
     5380: 7061-block 44
call    0 returned 5380
    15286: 7062:            bg_draw_list->AddRectFilled(window->Pos + ImVec2(0, window->TitleBarHeight), window->Pos + window->Size, bg_col, window_rounding, (flags & ImGuiWindowFlags_NoTitleBar) ? 0 : ImDrawFlags_RoundCornersBottom);
    15286: 7062-block 45
branch  0 taken 8829 (fallthrough)
branch  1 taken 6457
     8829: 7062-block 46
     6457: 7062-block 47
    15286: 7062-block 48
call    2 returned 15286
call    3 returned 15286
call    4 returned 15286
call    5 returned 15286
branch  6 taken 15286 (fallthrough)
branch  7 taken 0 (throw)
    $$$$$: 7062-block 161
    $$$$$: 7062-block 162
    $$$$$: 7062-block 163
call    8 never executed
    15286: 7063:            if (window->DockIsActive || (flags & ImGuiWindowFlags_DockNodeHost))
    15286: 7063-block 52
branch  0 taken 9906 (fallthrough)
branch  1 taken 5380
     9906: 7063-block 53
branch  2 taken 0 (fallthrough)
branch  3 taken 9906
     5380: 7064:                bg_draw_list->ChannelsSetCurrent(DOCKING_HOST_DRAW_CHANNEL_FG);
     5380: 7064-block 54
call    0 returned 5380
        -: 7065:        }
    16363: 7066:        if (window->DockIsActive)
    16363: 7066-block 55
branch  0 taken 5380 (fallthrough)
branch  1 taken 10983
     5380: 7067:            window->DockNode->IsBgDrawnThisFrame = true;
     5380: 7067-block 56
        -: 7068:
        -: 7069:        // Title bar
        -: 7070:        // (when docked, DockNode are drawing their own title bar. Individual windows however do NOT set the _NoTitleBar flag,
        -: 7071:        // in order for their pos/size to be matching their undocking state.)
    16363: 7072:        if (!(flags & ImGuiWindowFlags_NoTitleBar) && !window->DockIsActive)
    16363: 7072-block 57
branch  0 taken 6457 (fallthrough)
branch  1 taken 9906
     6457: 7072-block 58
branch  2 taken 1077 (fallthrough)
branch  3 taken 5380
        -: 7073:        {
     1077: 7074:            ImU32 title_bar_col = GetColorU32(title_bar_is_highlight ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBg);
     1077: 7074-block 59
branch  0 taken 1 (fallthrough)
branch  1 taken 1076
        1: 7074-block 60
     1076: 7074-block 61
     1077: 7074-block 62
call    2 returned 1077
     1077: 7075:            if (window->ViewportOwned)
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####: 7076:                title_bar_col |= IM_COL32_A_MASK; // No alpha
    %%%%%: 7076-block 64
     1077: 7077:            window->DrawList->AddRectFilled(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, window_rounding, ImDrawFlags_RoundCornersTop);
     1077: 7077-block 65
call    0 returned 1077
        -: 7078:        }
        -: 7079:
        -: 7080:        // Menu bar
    16363: 7081:        if (flags & ImGuiWindowFlags_MenuBar)
    16363: 7081-block 66
branch  0 taken 1077 (fallthrough)
branch  1 taken 15286
        -: 7082:        {
     1077: 7083:            ImRect menu_bar_rect = window->MenuBarRect();
     1077: 7083-block 67
call    0 returned 1077
     1077: 7084:            menu_bar_rect.ClipWith(window->Rect());  // Soft clipping, in particular child window don't have minimum size covering the menu bar so this is useful for them.
call    0 returned 1077
call    1 returned 1077
    1077*: 7085:            window->DrawList->AddRectFilled(menu_bar_rect.Min + ImVec2(window_border_size, 0), menu_bar_rect.Max - ImVec2(window_border_size, 0), GetColorU32(ImGuiCol_MenuBarBg), (flags & ImGuiWindowFlags_NoTitleBar) ? window_rounding : 0.0f, ImDrawFlags_RoundCornersTop);
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 7085-block 71
    %%%%%: 7085-block 72
     1077: 7085-block 73
call    2 returned 1077
call    3 returned 1077
call    4 returned 1077
call    5 returned 1077
call    6 returned 1077
call    7 returned 1077
branch  8 taken 1077 (fallthrough)
branch  9 taken 0 (throw)
    $$$$$: 7085-block 164
    $$$$$: 7085-block 165
    $$$$$: 7085-block 166
    $$$$$: 7085-block 167
    1077*: 7086:            if (style.FrameBorderSize > 0.0f && menu_bar_rect.Max.y < window->Pos.y + window->Size.y)
     1077: 7086-block 79
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 7086-block 80
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 7087:                window->DrawList->AddLine(menu_bar_rect.GetBL(), menu_bar_rect.GetBR(), GetColorU32(ImGuiCol_Border), style.FrameBorderSize);
    %%%%%: 7087-block 81
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    %%%%%: 7087-block 85
    $$$$$: 7087-block 168
    $$$$$: 7087-block 169
        -: 7088:        }
        -: 7089:
        -: 7090:        // Docking: Unhide tab bar (small triangle in the corner), drag from small triangle to quickly undock
    16363: 7091:        ImGuiDockNode* node = window->DockNode;
   16363*: 7092:        if (window->DockIsActive && node->IsHiddenTabBar() && !node->IsNoTabBar())
    16363: 7092-block 87
branch  0 taken 5380 (fallthrough)
branch  1 taken 10983
     5380: 7092-block 88
call    2 returned 5380
branch  3 taken 0 (fallthrough)
branch  4 taken 5380
    %%%%%: 7092-block 90
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 7092-block 92
    16363: 7092-block 93
    16363: 7092-block 94
branch  8 taken 0 (fallthrough)
branch  9 taken 16363
        -: 7093:        {
    #####: 7094:            float unhide_sz_draw = ImTrunc(g.FontSize * 0.70f);
    %%%%%: 7094-block 95
call    0 never executed
    #####: 7095:            float unhide_sz_hit = ImTrunc(g.FontSize * 0.55f);
call    0 never executed
    #####: 7096:            ImVec2 p = node->Pos;
    #####: 7097:            ImRect r(p, p + ImVec2(unhide_sz_hit, unhide_sz_hit));
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 7098:            ImGuiID unhide_id = window->GetID("#UNHIDE");
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7099:            KeepAliveID(unhide_id);
    %%%%%: 7099-block 101
call    0 never executed
        -: 7100:            bool hovered, held;
    #####: 7101:            if (ButtonBehavior(r, unhide_id, &hovered, &held, ImGuiButtonFlags_FlattenChildren))
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 7101-block 103
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 7102:                node->WantHiddenTabBarToggle = true;
    %%%%%: 7102-block 104
    #####: 7103:            else if (held && IsMouseDragging(0))
    %%%%%: 7103-block 105
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7103-block 106
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 7103-block 108
    %%%%%: 7103-block 109
    %%%%%: 7103-block 110
branch  5 never executed (fallthrough)
branch  6 never executed
    #####: 7104:                StartMouseMovingWindowOrNode(window, node, true); // Undock from tab-bar triangle = same as window/collapse menu button
    %%%%%: 7104-block 111
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 7105:
        -: 7106:            // FIXME-DOCK: Ideally we'd use ImGuiCol_TitleBgActive/ImGuiCol_TitleBg here, but neither is guaranteed to be visible enough at this sort of size..
    #####: 7107:            ImU32 col = GetColorU32(((held && hovered) || (node->IsFocused && !hovered)) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);
    %%%%%: 7107-block 112
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7107-block 113
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7107-block 114
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 7107-block 115
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 7107-block 116
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%: 7107-block 117
    %%%%%: 7107-block 118
    %%%%%: 7107-block 119
    %%%%%: 7107-block 120
    %%%%%: 7107-block 121
call   10 never executed
    #####: 7108:            window->DrawList->AddTriangleFilled(p, p + ImVec2(unhide_sz_draw, 0.0f), p + ImVec2(0.0f, unhide_sz_draw), col);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    %%%%%: 7108-block 127
    $$$$$: 7108-block 171
    $$$$$: 7108-block 172
    $$$$$: 7108-block 173
    $$$$$: 7108-block 174
        -: 7109:        }
        -: 7110:
        -: 7111:        // Scrollbars
    16363: 7112:        if (window->ScrollbarX)
    16363: 7112-block 128
branch  0 taken 2152 (fallthrough)
branch  1 taken 14211
     2152: 7113:            Scrollbar(ImGuiAxis_X);
     2152: 7113-block 129
call    0 returned 2152
    16363: 7114:        if (window->ScrollbarY)
    16363: 7114-block 130
branch  0 taken 5382 (fallthrough)
branch  1 taken 10981
     5382: 7115:            Scrollbar(ImGuiAxis_Y);
     5382: 7115-block 131
call    0 returned 5382
        -: 7116:
        -: 7117:        // Render resize grips (after their input handling so we don't have a frame of latency)
    16363: 7118:        if (handle_borders_and_resize_grips && !(flags & ImGuiWindowFlags_NoResize))
    16363: 7118-block 132
branch  0 taken 10983 (fallthrough)
branch  1 taken 5380
    10983: 7118-block 133
branch  2 taken 1077 (fallthrough)
branch  3 taken 9906
        -: 7119:        {
     3231: 7120:            for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)
     1077: 7120-block 134
     2154: 7120-block 155
     3231: 7120-block 156
branch  0 taken 2154
branch  1 taken 1077 (fallthrough)
        -: 7121:            {
     2154: 7122:                const ImU32 col = resize_grip_col[resize_grip_n];
     2154: 7123:                if ((col & IM_COL32_A_MASK) == 0)
     2154: 7123-block 135
branch  0 taken 2154 (fallthrough)
branch  1 taken 0
     2154: 7124:                    continue;
     2154: 7124-block 136
    #####: 7125:                const ImGuiResizeGripDef& grip = resize_grip_def[resize_grip_n];
    #####: 7126:                const ImVec2 corner = ImLerp(window->Pos, window->Pos + window->Size, grip.CornerPosN);
    %%%%%: 7126-block 137
call    0 never executed
call    1 never executed
    #####: 7127:                window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? ImVec2(window_border_size, resize_grip_draw_size) : ImVec2(resize_grip_draw_size, window_border_size)));
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7127-block 140
call    2 never executed
    %%%%%: 7127-block 141
call    3 never executed
    %%%%%: 7127-block 142
call    4 never executed
call    5 never executed
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed (throw)
    $$$$$: 7127-block 176
    $$$$$: 7127-block 177
    $$$$$: 7127-block 178
    #####: 7128:                window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? ImVec2(resize_grip_draw_size, window_border_size) : ImVec2(window_border_size, resize_grip_draw_size)));
    %%%%%: 7128-block 145
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7128-block 146
call    2 never executed
    %%%%%: 7128-block 147
call    3 never executed
    %%%%%: 7128-block 148
call    4 never executed
call    5 never executed
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed (throw)
    $$$$$: 7128-block 179
    $$$$$: 7128-block 180
    $$$$$: 7128-block 181
    #####: 7129:                window->DrawList->PathArcToFast(ImVec2(corner.x + grip.InnerDir.x * (window_rounding + window_border_size), corner.y + grip.InnerDir.y * (window_rounding + window_border_size)), window_rounding, grip.AngleMin12, grip.AngleMax12);
    %%%%%: 7129-block 151
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$: 7129-block 182
    #####: 7130:                window->DrawList->PathFillConvex(col);
    %%%%%: 7130-block 153
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 7131:            }
        -: 7132:        }
        -: 7133:
        -: 7134:        // Borders (for dock node host they will be rendered over after the tab bar)
    16363: 7135:        if (handle_borders_and_resize_grips && !window->DockNodeAsHost)
    16363: 7135-block 157
branch  0 taken 10983 (fallthrough)
branch  1 taken 5380
    10983: 7135-block 158
branch  2 taken 9907 (fallthrough)
branch  3 taken 1076
     9907: 7136:            RenderWindowOuterBorders(window);
     9907: 7136-block 159
call    0 returned 9907
        -: 7137:    }
    16363: 7138:}
    16363: 7138-block 160
        -: 7139:
        -: 7140:// When inside a dock node, this is handled in DockNodeCalcTabBarLayout() instead.
        -: 7141:// Render title text, collapse button, close button
function _ZN5ImGuiL28RenderWindowTitleBarContentsEP11ImGuiWindowRK6ImRectPKcPb called 1077 returned 100% blocks executed 62%
     1077: 7142:void ImGui::RenderWindowTitleBarContents(ImGuiWindow* window, const ImRect& title_bar_rect, const char* name, bool* p_open)
        -: 7143:{
     1077: 7144:    ImGuiContext& g = *GImGui;
     1077: 7145:    ImGuiStyle& style = g.Style;
     1077: 7146:    ImGuiWindowFlags flags = window->Flags;
        -: 7147:
     1077: 7148:    const bool has_close_button = (p_open != NULL);
    1077*: 7149:    const bool has_collapse_button = !(flags & ImGuiWindowFlags_NoCollapse) && (style.WindowMenuButtonPosition != ImGuiDir_None);
     1077: 7149-block 2
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 7149-block 3
branch  2 taken 1077 (fallthrough)
branch  3 taken 0
     1077: 7149-block 4
    %%%%%: 7149-block 5
        -: 7150:
        -: 7151:    // Close & Collapse button are on the Menu NavLayer and don't default focus (unless there's nothing else on that layer)
        -: 7152:    // FIXME-NAV: Might want (or not?) to set the equivalent of ImGuiButtonFlags_NoNavFocus so that mouse clicks on standard title bar items don't necessarily set nav/keyboard ref?
     1077: 7153:    const ImGuiItemFlags item_flags_backup = g.CurrentItemFlags;
     1077: 7154:    g.CurrentItemFlags |= ImGuiItemFlags_NoNavDefaultFocus;
     1077: 7155:    window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;
        -: 7156:
        -: 7157:    // Layout buttons
        -: 7158:    // FIXME: Would be nice to generalize the subtleties expressed here into reusable code.
     1077: 7159:    float pad_l = style.FramePadding.x;
     1077: 7160:    float pad_r = style.FramePadding.x;
     1077: 7161:    float button_sz = g.FontSize;
     1077: 7162:    ImVec2 close_button_pos;
     1077: 7163:    ImVec2 collapse_button_pos;
     1077: 7164:    if (has_close_button)
     1077: 7164-block 6
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
        -: 7165:    {
    #####: 7166:        close_button_pos = ImVec2(title_bar_rect.Max.x - pad_r - button_sz, title_bar_rect.Min.y + style.FramePadding.y);
    %%%%%: 7166-block 7
call    0 never executed
    #####: 7167:        pad_r += button_sz + style.ItemInnerSpacing.x;
        -: 7168:    }
     1077: 7169:    if (has_collapse_button && style.WindowMenuButtonPosition == ImGuiDir_Right)
     1077: 7169-block 9
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 7169-block 10
branch  2 taken 1077 (fallthrough)
branch  3 taken 0
        -: 7170:    {
     1077: 7171:        collapse_button_pos = ImVec2(title_bar_rect.Max.x - pad_r - button_sz, title_bar_rect.Min.y + style.FramePadding.y);
     1077: 7171-block 11
call    0 returned 1077
     1077: 7172:        pad_r += button_sz + style.ItemInnerSpacing.x;
        -: 7173:    }
     1077: 7174:    if (has_collapse_button && style.WindowMenuButtonPosition == ImGuiDir_Left)
     1077: 7174-block 13
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 7174-block 14
branch  2 taken 0 (fallthrough)
branch  3 taken 1077
        -: 7175:    {
    #####: 7176:        collapse_button_pos = ImVec2(title_bar_rect.Min.x + pad_l, title_bar_rect.Min.y + style.FramePadding.y);
    %%%%%: 7176-block 15
call    0 never executed
    #####: 7177:        pad_l += button_sz + style.ItemInnerSpacing.x;
        -: 7178:    }
        -: 7179:
        -: 7180:    // Collapse button (submitting first so it gets priority when choosing a navigation init fallback)
     1077: 7181:    if (has_collapse_button)
     1077: 7181-block 17
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 7182:        if (CollapseButton(window->GetID("#COLLAPSE"), collapse_button_pos, NULL))
     1077: 7182-block 18
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077: 7182-block 19
call    3 returned 1077
branch  4 taken 1077 (fallthrough)
branch  5 taken 0 (throw)
     1077: 7182-block 20
branch  6 taken 0 (fallthrough)
branch  7 taken 1077
    #####: 7183:            window->WantCollapseToggle = true; // Defer actual collapsing to next frame as we are too far in the Begin() function
    %%%%%: 7183-block 21
        -: 7184:
        -: 7185:    // Close button
     1077: 7186:    if (has_close_button)
     1077: 7186-block 22
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####: 7187:        if (CloseButton(window->GetID("#CLOSE"), close_button_pos))
    %%%%%: 7187-block 23
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 7187-block 24
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    %%%%%: 7187-block 25
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 7188:            *p_open = false;
    %%%%%: 7188-block 26
        -: 7189:
     1077: 7190:    window->DC.NavLayerCurrent = ImGuiNavLayer_Main;
     1077: 7191:    g.CurrentItemFlags = item_flags_backup;
        -: 7192:
        -: 7193:    // Title bar text (with: horizontal alignment, avoiding collapse/close button, optional "unsaved document" marker)
        -: 7194:    // FIXME: Refactor text alignment facilities along with RenderText helpers, this is WAY too much messy code..
    1077*: 7195:    const float marker_size_x = (flags & ImGuiWindowFlags_UnsavedDocument) ? button_sz * 0.80f : 0.0f;
     1077: 7195-block 27
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 7195-block 28
     1077: 7195-block 29
     1077: 7196:    const ImVec2 text_size = CalcTextSize(name, NULL, true) + ImVec2(marker_size_x, 0.0f);
     1077: 7196-block 30
call    0 returned 1077
call    1 returned 1077
branch  2 taken 1077 (fallthrough)
branch  3 taken 0 (throw)
     1077: 7196-block 32
call    4 returned 1077
    $$$$$: 7196-block 59
    $$$$$: 7196-block 60
        -: 7197:
        -: 7198:    // As a nice touch we try to ensure that centered title text doesn't get affected by visibility of Close/Collapse button,
        -: 7199:    // while uncentered title text will still reach edges correctly.
     1077: 7200:    if (pad_l > style.FramePadding.x)
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####: 7201:        pad_l += g.Style.ItemInnerSpacing.x;
    %%%%%: 7201-block 34
     1077: 7202:    if (pad_r > style.FramePadding.x)
     1077: 7202-block 35
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 7203:        pad_r += g.Style.ItemInnerSpacing.x;
     1077: 7203-block 36
     1077: 7204:    if (style.WindowTitleAlign.x > 0.0f && style.WindowTitleAlign.x < 1.0f)
     1077: 7204-block 37
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 7204-block 38
branch  2 taken 1077 (fallthrough)
branch  3 taken 0
        -: 7205:    {
     1077: 7206:        float centerness = ImSaturate(1.0f - ImFabs(style.WindowTitleAlign.x - 0.5f) * 2.0f); // 0.0f on either edges, 1.0f on center
     1077: 7206-block 39
call    0 returned 1077
     1077: 7207:        float pad_extend = ImMin(ImMax(pad_l, pad_r), title_bar_rect.GetWidth() - pad_l - pad_r - text_size.x);
call    0 returned 1077
call    1 returned 1077
call    2 returned 1077
     1077: 7208:        pad_l = ImMax(pad_l, pad_extend * centerness);
call    0 returned 1077
     1077: 7209:        pad_r = ImMax(pad_r, pad_extend * centerness);
call    0 returned 1077
        -: 7210:    }
        -: 7211:
     1077: 7212:    ImRect layout_r(title_bar_rect.Min.x + pad_l, title_bar_rect.Min.y, title_bar_rect.Max.x - pad_r, title_bar_rect.Max.y);
     1077: 7212-block 45
call    0 returned 1077
     1077: 7213:    ImRect clip_r(layout_r.Min.x, layout_r.Min.y, ImMin(layout_r.Max.x + g.Style.ItemInnerSpacing.x, title_bar_rect.Max.x), layout_r.Max.y);
call    0 returned 1077
call    1 returned 1077
     1077: 7214:    if (flags & ImGuiWindowFlags_UnsavedDocument)
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
        -: 7215:    {
    #####: 7216:        ImVec2 marker_pos;
    #####: 7217:        marker_pos.x = ImClamp(layout_r.Min.x + (layout_r.GetWidth() - text_size.x) * style.WindowTitleAlign.x + text_size.x, layout_r.Min.x, layout_r.Max.x);
    %%%%%: 7217-block 49
call    0 never executed
call    1 never executed
    #####: 7218:        marker_pos.y = (layout_r.Min.y + layout_r.Max.y) * 0.5f;
    #####: 7219:        if (marker_pos.x > layout_r.Min.x)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 7220:        {
    #####: 7221:            RenderBullet(window->DrawList, marker_pos, GetColorU32(ImGuiCol_Text));
    %%%%%: 7221-block 52
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####: 7222:            clip_r.Max.x = ImMin(clip_r.Max.x, marker_pos.x - (int)(marker_size_x * 0.5f));
    %%%%%: 7222-block 54
call    0 never executed
        -: 7223:        }
        -: 7224:    }
        -: 7225:    //if (g.IO.KeyShift) window->DrawList->AddRect(layout_r.Min, layout_r.Max, IM_COL32(255, 128, 0, 255)); // [DEBUG]
        -: 7226:    //if (g.IO.KeyCtrl) window->DrawList->AddRect(clip_r.Min, clip_r.Max, IM_COL32(255, 128, 0, 255)); // [DEBUG]
     1077: 7227:    RenderTextClipped(layout_r.Min, layout_r.Max, name, NULL, &text_size, style.WindowTitleAlign, &clip_r);
     1077: 7227-block 57
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077: 7228:}
     1077: 7228-block 58
        -: 7229:
function _ZN5ImGui30UpdateWindowParentAndRootLinksEP11ImGuiWindowiS1_ called 16373 returned 100% blocks executed 79%
    16373: 7230:void ImGui::UpdateWindowParentAndRootLinks(ImGuiWindow* window, ImGuiWindowFlags flags, ImGuiWindow* parent_window)
        -: 7231:{
    16373: 7232:    window->ParentWindow = parent_window;
    16373: 7233:    window->RootWindow = window->RootWindowPopupTree = window->RootWindowDockTree = window->RootWindowForTitleBarHighlight = window->RootWindowForNav = window;
    16373: 7234:    if (parent_window && (flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Tooltip))
    16373: 7234-block 2
branch  0 taken 12929 (fallthrough)
branch  1 taken 3444
    12929: 7234-block 3
branch  2 taken 12929 (fallthrough)
branch  3 taken 0
    12929: 7234-block 4
branch  4 taken 12929 (fallthrough)
branch  5 taken 0
        -: 7235:    {
    12929: 7236:        window->RootWindowDockTree = parent_window->RootWindowDockTree;
    12929: 7237:        if (!window->DockIsActive && !(parent_window->Flags & ImGuiWindowFlags_DockNodeHost))
    12929: 7237-block 5
branch  0 taken 7544 (fallthrough)
branch  1 taken 5385
     7544: 7237-block 6
branch  2 taken 7539 (fallthrough)
branch  3 taken 5
     7539: 7238:            window->RootWindow = parent_window->RootWindow;
     7539: 7238-block 7
        -: 7239:    }
    16373: 7240:    if (parent_window && (flags & ImGuiWindowFlags_Popup))
    16373: 7240-block 8
branch  0 taken 12929 (fallthrough)
branch  1 taken 3444
    12929: 7240-block 9
branch  2 taken 0 (fallthrough)
branch  3 taken 12929
    #####: 7241:        window->RootWindowPopupTree = parent_window->RootWindowPopupTree;
    %%%%%: 7241-block 10
    16373: 7242:    if (parent_window && !(flags & ImGuiWindowFlags_Modal) && (flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Popup))) // FIXME: simply use _NoTitleBar ?
    16373: 7242-block 11
branch  0 taken 12929 (fallthrough)
branch  1 taken 3444
    12929: 7242-block 12
branch  2 taken 12929 (fallthrough)
branch  3 taken 0
    12929: 7242-block 13
branch  4 taken 12929 (fallthrough)
branch  5 taken 0
    12929: 7243:        window->RootWindowForTitleBarHighlight = parent_window->RootWindowForTitleBarHighlight;
    12929: 7243-block 14
    16373: 7244:    while (window->RootWindowForNav->ChildFlags & ImGuiChildFlags_NavFlattened)
    16373: 7244-block 15
    16373: 7244-block 19
branch  0 taken 0
branch  1 taken 16373 (fallthrough)
        -: 7245:    {
    #####: 7246:        IM_ASSERT(window->RootWindowForNav->ParentWindow != NULL);
    %%%%%: 7246-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7246-block 17
call    2 never executed
    #####: 7247:        window->RootWindowForNav = window->RootWindowForNav->ParentWindow;
    %%%%%: 7247-block 18
        -: 7248:    }
    16373: 7249:}
        -: 7250:
        -: 7251:// [EXPERIMENTAL] Called by Begin(). NextWindowData is valid at this point.
        -: 7252:// This is designed as a toy/test-bed for
function _ZN5ImGui23UpdateWindowSkipRefreshEP11ImGuiWindow called 17445 returned 100% blocks executed 11%
    17445: 7253:void ImGui::UpdateWindowSkipRefresh(ImGuiWindow* window)
        -: 7254:{
    17445: 7255:    ImGuiContext& g = *GImGui;
    17445: 7256:    window->SkipRefresh = false;
    17445: 7257:    if ((g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasRefreshPolicy) == 0)
    17445: 7257-block 2
branch  0 taken 17445 (fallthrough)
branch  1 taken 0
    17445: 7258:        return;
    17445: 7258-block 3
    #####: 7259:    if (g.NextWindowData.RefreshFlagsVal & ImGuiWindowRefreshFlags_TryToAvoidRefresh)
    %%%%%: 7259-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 7260:    {
        -: 7261:        // FIXME-IDLE: Tests for e.g. mouse clicks or keyboard while focused.
    #####: 7262:        if (window->Appearing) // If currently appearing
    %%%%%: 7262-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7263:            return;
    %%%%%: 7263-block 6
    #####: 7264:        if (window->Hidden) // If was hidden (previous frame)
    %%%%%: 7264-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7265:            return;
    %%%%%: 7265-block 8
    #####: 7266:        if ((g.NextWindowData.RefreshFlagsVal & ImGuiWindowRefreshFlags_RefreshOnHover) && g.HoveredWindow)
    %%%%%: 7266-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7266-block 10
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 7267:            if (window->RootWindow == g.HoveredWindow->RootWindow || IsWindowWithinBeginStackOf(g.HoveredWindow->RootWindow, window))
    %%%%%: 7267-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7267-block 12
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 7267-block 14
    %%%%%: 7267-block 15
    %%%%%: 7267-block 16
branch  5 never executed (fallthrough)
branch  6 never executed
    #####: 7268:                return;
    %%%%%: 7268-block 17
    #####: 7269:        if ((g.NextWindowData.RefreshFlagsVal & ImGuiWindowRefreshFlags_RefreshOnFocus) && g.NavWindow)
    %%%%%: 7269-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7269-block 19
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 7270:            if (window->RootWindow == g.NavWindow->RootWindow || IsWindowWithinBeginStackOf(g.NavWindow->RootWindow, window))
    %%%%%: 7270-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7270-block 21
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 7270-block 23
    %%%%%: 7270-block 24
    %%%%%: 7270-block 25
branch  5 never executed (fallthrough)
branch  6 never executed
    #####: 7271:                return;
    %%%%%: 7271-block 26
    #####: 7272:        window->DrawList = NULL;
    #####: 7273:        window->SkipRefresh = true;
    %%%%%: 7273-block 27
        -: 7274:    }
        -: 7275:}
        -: 7276:
function _ZL29SetWindowActiveForSkipRefreshP11ImGuiWindow called 0 returned 0% blocks executed 0%
    #####: 7277:static void SetWindowActiveForSkipRefresh(ImGuiWindow* window)
        -: 7278:{
    #####: 7279:    window->Active = true;
    #####: 7280:    for (ImGuiWindow* child : window->DC.ChildWindows)
    %%%%%: 7280-block 2
call    0 never executed
call    1 never executed
    %%%%%: 7280-block 6
    %%%%%: 7280-block 7
branch  2 never executed
branch  3 never executed (fallthrough)
    #####: 7281:        if (!child->Hidden)
    %%%%%: 7281-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 7282:        {
    #####: 7283:            child->Active = child->SkipRefresh = true;
    #####: 7284:            SetWindowActiveForSkipRefresh(child);
    %%%%%: 7284-block 5
call    0 never executed
        -: 7285:        }
    #####: 7286:}
        -: 7287:
        -: 7288:// When a modal popup is open, newly created windows that want focus (i.e. are not popups and do not specify ImGuiWindowFlags_NoFocusOnAppearing)
        -: 7289:// should be positioned behind that modal window, unless the window was created inside the modal begin-stack.
        -: 7290:// In case of multiple stacked modals newly created window honors begin stack order and does not go below its own modal parent.
        -: 7291:// - WindowA            // FindBlockingModal() returns Modal1
        -: 7292://   - WindowB          //                  .. returns Modal1
        -: 7293://   - Modal1           //                  .. returns Modal2
        -: 7294://      - WindowC       //                  .. returns Modal2
        -: 7295://          - WindowD   //                  .. returns Modal2
        -: 7296://          - Modal2    //                  .. returns Modal2
        -: 7297://            - WindowE //                  .. returns NULL
        -: 7298:// Notes:
        -: 7299:// - FindBlockingModal(NULL) == NULL is generally equivalent to GetTopMostPopupModal() == NULL.
        -: 7300://   Only difference is here we check for ->Active/WasActive but it may be unnecessary.
function _ZN5ImGui17FindBlockingModalEP11ImGuiWindow called 8 returned 100% blocks executed 15%
        8: 7301:ImGuiWindow* ImGui::FindBlockingModal(ImGuiWindow* window)
        -: 7302:{
        8: 7303:    ImGuiContext& g = *GImGui;
        8: 7304:    if (g.OpenPopupStack.Size <= 0)
        8: 7304-block 2
branch  0 taken 8 (fallthrough)
branch  1 taken 0
        8: 7305:        return NULL;
        8: 7305-block 3
        -: 7306:
        -: 7307:    // Find a modal that has common parent with specified window. Specified window should be positioned behind that modal.
    #####: 7308:    for (ImGuiPopupData& popup_data : g.OpenPopupStack)
    %%%%%: 7308-block 4
call    0 never executed
call    1 never executed
    %%%%%: 7308-block 18
    %%%%%: 7308-block 19
branch  2 never executed
branch  3 never executed (fallthrough)
        -: 7309:    {
    #####: 7310:        ImGuiWindow* popup_window = popup_data.Window;
    #####: 7311:        if (popup_window == NULL || !(popup_window->Flags & ImGuiWindowFlags_Modal))
    %%%%%: 7311-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7311-block 7
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 7312:            continue;
    %%%%%: 7312-block 8
    #####: 7313:        if (!popup_window->Active && !popup_window->WasActive)      // Check WasActive, because this code may run before popup renders on current frame, also check Active to handle newly created windows.
    %%%%%: 7313-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7313-block 10
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 7314:            continue;
    %%%%%: 7314-block 11
    #####: 7315:        if (window == NULL)                                         // FindBlockingModal(NULL) test for if FocusWindow(NULL) is naturally possible via a mouse click.
    %%%%%: 7315-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7316:            return popup_window;
    %%%%%: 7316-block 13
    #####: 7317:        if (IsWindowWithinBeginStackOf(window, popup_window))       // Window may be over modal
    %%%%%: 7317-block 14
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 7318:            continue;
    %%%%%: 7318-block 16
    #####: 7319:        return popup_window;                                        // Place window right below first block modal
    %%%%%: 7319-block 17
        -: 7320:    }
    #####: 7321:    return NULL;
    %%%%%: 7321-block 20
        -: 7322:}
        -: 7323:
        -: 7324:// Push a new Dear ImGui window to add widgets to.
        -: 7325:// - A default window called "Debug" is automatically stacked at the beginning of every frame so you can use widgets without explicitly calling a Begin/End pair.
        -: 7326:// - Begin/End can be called multiple times during the frame with the same window name to append content.
        -: 7327:// - The window name is used as a unique identifier to preserve window information across frames (and save rudimentary information to the .ini file).
        -: 7328://   You can use the "##" or "###" markers to use the same label with different id, or same id with different label. See documentation at the top of this file.
        -: 7329:// - Return false when window is collapsed, so you can early out in your code. You always need to call ImGui::End() even if false is returned.
        -: 7330:// - Passing 'bool* p_open' displays a Close button on the upper-right corner of the window, the pointed value will be set to false when the button is pressed.
function _ZN5ImGui5BeginEPKcPbi called 17445 returned 100% blocks executed 74%
    17445: 7331:bool ImGui::Begin(const char* name, bool* p_open, ImGuiWindowFlags flags)
        -: 7332:{
    17445: 7333:    ImGuiContext& g = *GImGui;
    17445: 7334:    const ImGuiStyle& style = g.Style;
   17445*: 7335:    IM_ASSERT(name != NULL && name[0] != '\0');     // Window name required
    17445: 7335-block 2
branch  0 taken 17445 (fallthrough)
branch  1 taken 0
    17445: 7335-block 3
branch  2 taken 17445 (fallthrough)
branch  3 taken 0
    17445: 7335-block 4
    %%%%%: 7335-block 5
call    4 never executed
   17445*: 7336:    IM_ASSERT(g.WithinFrameScope);                  // Forgot to call ImGui::NewFrame()
    17445: 7336-block 6
branch  0 taken 0 (fallthrough)
branch  1 taken 17445
    %%%%%: 7336-block 7
call    2 never executed
   17445*: 7337:    IM_ASSERT(g.FrameCountEnded != g.FrameCount);   // Called ImGui::Render() or ImGui::EndFrame() and haven't called ImGui::NewFrame() again yet
    17445: 7337-block 8
branch  0 taken 0 (fallthrough)
branch  1 taken 17445
    %%%%%: 7337-block 9
call    2 never executed
        -: 7338:
        -: 7339:    // Find or create
    17445: 7340:    ImGuiWindow* window = FindWindowByName(name);
    17445: 7340-block 10
call    0 returned 17445
    17445: 7341:    const bool window_just_created = (window == NULL);
    17445: 7342:    if (window_just_created)
branch  0 taken 16 (fallthrough)
branch  1 taken 17429
       16: 7343:        window = CreateNewWindow(name, flags);
       16: 7343-block 12
call    0 returned 16
branch  1 taken 16 (fallthrough)
branch  2 taken 0 (throw)
       16: 7343-block 13
        -: 7344:
        -: 7345:    // [DEBUG] Debug break requested by user
    17445: 7346:    if (g.DebugBreakInWindow == window->ID)
    17445: 7346-block 14
branch  0 taken 0 (fallthrough)
branch  1 taken 17445
    #####: 7347:        IM_DEBUG_BREAK();
    %%%%%: 7347-block 15
call    0 never executed
        -: 7348:
        -: 7349:    // Automatically disable manual moving/resizing when NoInputs is set
    17445: 7350:    if ((flags & ImGuiWindowFlags_NoInputs) == ImGuiWindowFlags_NoInputs)
    17445: 7350-block 16
branch  0 taken 213 (fallthrough)
branch  1 taken 17232
      213: 7351:        flags |= ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize;
      213: 7351-block 17
        -: 7352:
    17445: 7353:    const int current_frame = g.FrameCount;
    17445: 7354:    const bool first_begin_of_the_frame = (window->LastFrameActive != current_frame);
    17445: 7355:    window->IsFallbackWindow = (g.CurrentWindowStack.Size == 0 && g.WithinFrameScopeWithImplicitWindow);
    17445: 7355-block 18
branch  0 taken 1077 (fallthrough)
branch  1 taken 16368
     1077: 7355-block 19
branch  2 taken 1077 (fallthrough)
branch  3 taken 0
     1077: 7355-block 20
    16368: 7355-block 21
        -: 7356:
        -: 7357:    // Update the Appearing flag (note: the BeginDocked() path may also set this to true later)
    17445: 7358:    bool window_just_activated_by_user = (window->LastFrameActive < current_frame - 1); // Not using !WasActive because the implicit "Debug" window would always toggle off->on
    17445: 7359:    if (flags & ImGuiWindowFlags_Popup)
    17445: 7359-block 22
branch  0 taken 0 (fallthrough)
branch  1 taken 17445
        -: 7360:    {
    #####: 7361:        ImGuiPopupData& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
    %%%%%: 7361-block 23
call    0 never executed
    #####: 7362:        window_just_activated_by_user |= (window->PopupId != popup_ref.PopupId); // We recycle popups so treat window as activated if popup id changed
    #####: 7363:        window_just_activated_by_user |= (window != popup_ref.Window);
        -: 7364:    }
        -: 7365:
        -: 7366:    // Update Flags, LastFrameActive, BeginOrderXXX fields
    17445: 7367:    const bool window_was_appearing = window->Appearing;
    17445: 7368:    if (first_begin_of_the_frame)
    17445: 7368-block 25
branch  0 taken 16368 (fallthrough)
branch  1 taken 1077
        -: 7369:    {
    16368: 7370:        UpdateWindowInFocusOrderList(window, window_just_created, flags);
    16368: 7370-block 26
call    0 returned 16368
branch  1 taken 16368 (fallthrough)
branch  2 taken 0 (throw)
    16368: 7371:        window->Appearing = window_just_activated_by_user;
    16368: 7372:        if (window->Appearing)
    16368: 7372-block 27
branch  0 taken 24 (fallthrough)
branch  1 taken 16344
       24: 7373:            SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, true);
       24: 7373-block 28
call    0 returned 24
    16368: 7374:        window->FlagsPreviousFrame = window->Flags;
    16368: 7375:        window->Flags = (ImGuiWindowFlags)flags;
    16368: 7376:        window->ChildFlags = (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasChildFlags) ? g.NextWindowData.ChildFlags : 0;
    16368: 7376-block 29
branch  0 taken 6462 (fallthrough)
branch  1 taken 9906
     6462: 7376-block 30
     9906: 7376-block 31
    16368: 7377:        window->LastFrameActive = current_frame;
    16368: 7378:        window->LastTimeActive = (float)g.Time;
    16368: 7379:        window->BeginOrderWithinParent = 0;
    16368: 7380:        window->BeginOrderWithinContext = (short)(g.WindowsActiveCount++);
    16368: 7380-block 32
        -: 7381:    }
        -: 7382:    else
        -: 7383:    {
     1077: 7384:        flags = window->Flags;
     1077: 7384-block 33
        -: 7385:    }
        -: 7386:
        -: 7387:    // Docking
        -: 7388:    // (NB: during the frame dock nodes are created, it is possible that (window->DockIsActive == false) even though (window->DockNode->Windows.Size > 1)
   17445*: 7389:    IM_ASSERT(window->DockNode == NULL || window->DockNodeAsHost == NULL); // Cannot be both
    17445: 7389-block 34
branch  0 taken 6457 (fallthrough)
branch  1 taken 10988
     6457: 7389-block 35
branch  2 taken 0 (fallthrough)
branch  3 taken 6457
    %%%%%: 7389-block 36
call    4 never executed
    17445: 7390:    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasDock)
    17445: 7390-block 37
branch  0 taken 0 (fallthrough)
branch  1 taken 17445
    #####: 7391:        SetWindowDock(window, g.NextWindowData.DockId, g.NextWindowData.DockCond);
    %%%%%: 7391-block 38
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    17445: 7392:    if (first_begin_of_the_frame)
    17445: 7392-block 39
branch  0 taken 16368 (fallthrough)
branch  1 taken 1077
        -: 7393:    {
    16368: 7394:        bool has_dock_node = (window->DockId != 0 || window->DockNode != NULL);
    16368: 7394-block 40
branch  0 taken 10983 (fallthrough)
branch  1 taken 5385
    10983: 7394-block 41
branch  2 taken 0 (fallthrough)
branch  3 taken 10983
     5385: 7394-block 42
    10983: 7394-block 43
   16368*: 7395:        bool new_auto_dock_node = !has_dock_node && GetWindowAlwaysWantOwnTabBar(window);
    16368: 7395-block 44
branch  0 taken 10983 (fallthrough)
branch  1 taken 5385
    10983: 7395-block 45
call    2 returned 10983
branch  3 taken 0 (fallthrough)
branch  4 taken 10983
    %%%%%: 7395-block 47
    16368: 7395-block 48
    16368: 7396:        bool dock_node_was_visible = window->DockNodeIsVisible;
    16368: 7397:        bool dock_tab_was_visible = window->DockTabIsVisible;
    16368: 7398:        if (has_dock_node || new_auto_dock_node)
    16368: 7398-block 49
branch  0 taken 10983 (fallthrough)
branch  1 taken 5385
    10983: 7398-block 50
branch  2 taken 0 (fallthrough)
branch  3 taken 10983
        -: 7399:        {
     5385: 7400:            BeginDocked(window, p_open);
     5385: 7400-block 51
call    0 returned 5385
branch  1 taken 5385 (fallthrough)
branch  2 taken 0 (throw)
     5385: 7401:            flags = window->Flags;
     5385: 7402:            if (window->DockIsActive)
     5385: 7402-block 52
branch  0 taken 5385 (fallthrough)
branch  1 taken 0
        -: 7403:            {
    5385*: 7404:                IM_ASSERT(window->DockNode != NULL);
     5385: 7404-block 53
branch  0 taken 0 (fallthrough)
branch  1 taken 5385
    %%%%%: 7404-block 54
call    2 never executed
     5385: 7405:                g.NextWindowData.Flags &= ~ImGuiNextWindowDataFlags_HasSizeConstraint; // Docking currently override constraints
     5385: 7405-block 55
        -: 7406:            }
        -: 7407:
        -: 7408:            // Amend the Appearing flag
     5385: 7409:            if (window->DockTabIsVisible && !dock_tab_was_visible && dock_node_was_visible && !window->Appearing && !window_was_appearing)
     5385: 7409-block 56
branch  0 taken 5380 (fallthrough)
branch  1 taken 5
     5380: 7409-block 57
branch  2 taken 5 (fallthrough)
branch  3 taken 5375
        5: 7409-block 58
branch  4 taken 5 (fallthrough)
branch  5 taken 0
        5: 7409-block 59
branch  6 taken 5 (fallthrough)
branch  7 taken 0
        5: 7409-block 60
branch  8 taken 0 (fallthrough)
branch  9 taken 5
        -: 7410:            {
    #####: 7411:                window->Appearing = true;
    #####: 7412:                SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, true);
    %%%%%: 7412-block 61
call    0 never executed
        -: 7413:            }
        -: 7414:        }
        -: 7415:        else
        -: 7416:        {
    10983: 7417:            window->DockIsActive = window->DockNodeIsVisible = window->DockTabIsVisible = false;
    10983: 7417-block 63
        -: 7418:        }
        -: 7419:    }
        -: 7420:
        -: 7421:    // Parent window is latched only on the first call to Begin() of the frame, so further append-calls can be done from a different window stack
    17445: 7422:    ImGuiWindow* parent_window_in_stack = (window->DockIsActive && window->DockNode->HostWindow) ? window->DockNode->HostWindow : g.CurrentWindowStack.empty() ? NULL : g.CurrentWindowStack.back().Window;
    17445: 7422-block 65
branch  0 taken 6462 (fallthrough)
branch  1 taken 10983
     6462: 7422-block 66
branch  2 taken 6462 (fallthrough)
branch  3 taken 0
     6462: 7422-block 67
    10983: 7422-block 68
call    4 returned 10983
branch  5 taken 1077 (fallthrough)
branch  6 taken 9906
     1077: 7422-block 70
     9906: 7422-block 71
call    7 returned 9906
    10983: 7422-block 73
    17445: 7423:    ImGuiWindow* parent_window = first_begin_of_the_frame ? ((flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Popup)) ? parent_window_in_stack : NULL) : window->ParentWindow;
    17445: 7423-block 74
branch  0 taken 16368 (fallthrough)
branch  1 taken 1077
    16368: 7423-block 75
branch  2 taken 12924 (fallthrough)
branch  3 taken 3444
    12924: 7423-block 76
     3444: 7423-block 77
    16368: 7423-block 78
     1077: 7423-block 79
   17445*: 7424:    IM_ASSERT(parent_window != NULL || !(flags & ImGuiWindowFlags_ChildWindow));
    17445: 7424-block 80
branch  0 taken 3444 (fallthrough)
branch  1 taken 14001
     3444: 7424-block 81
branch  2 taken 0 (fallthrough)
branch  3 taken 3444
    %%%%%: 7424-block 82
call    4 never executed
        -: 7425:
        -: 7426:    // We allow window memory to be compacted so recreate the base stack when needed.
    17445: 7427:    if (window->IDStack.Size == 0)
    17445: 7427-block 83
branch  0 taken 0 (fallthrough)
branch  1 taken 17445
    #####: 7428:        window->IDStack.push_back(window->ID);
    %%%%%: 7428-block 84
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 7429:
        -: 7430:    // Add to stack
    17445: 7431:    g.CurrentWindow = window;
    17445: 7432:    g.CurrentWindowStack.resize(g.CurrentWindowStack.Size + 1);
    17445: 7432-block 85
call    0 returned 17445
branch  1 taken 17445 (fallthrough)
branch  2 taken 0 (throw)
    17445: 7433:    ImGuiWindowStackData& window_stack_data = g.CurrentWindowStack.back();
    17445: 7433-block 86
call    0 returned 17445
    17445: 7434:    window_stack_data.Window = window;
    17445: 7435:    window_stack_data.ParentLastItemDataBackup = g.LastItemData;
   17445*: 7436:    window_stack_data.DisabledOverrideReenable = (flags & ImGuiWindowFlags_Tooltip) && (g.CurrentItemFlags & ImGuiItemFlags_Disabled);
branch  0 taken 213 (fallthrough)
branch  1 taken 17232
      213: 7436-block 88
branch  2 taken 0 (fallthrough)
branch  3 taken 213
    %%%%%: 7436-block 89
    17445: 7436-block 90
    17445: 7437:    ErrorRecoveryStoreState(&window_stack_data.StackSizesInBegin);
    17445: 7437-block 91
call    0 returned 17445
    17445: 7438:    g.StackSizesInBeginForCurrentWindow = &window_stack_data.StackSizesInBegin;
    17445: 7439:    if (flags & ImGuiWindowFlags_ChildMenu)
branch  0 taken 0 (fallthrough)
branch  1 taken 17445
    #####: 7440:        g.BeginMenuDepth++;
    %%%%%: 7440-block 93
        -: 7441:
        -: 7442:    // Update ->RootWindow and others pointers (before any possible call to FocusWindow)
    17445: 7443:    if (first_begin_of_the_frame)
    17445: 7443-block 94
branch  0 taken 16368 (fallthrough)
branch  1 taken 1077
        -: 7444:    {
    16368: 7445:        UpdateWindowParentAndRootLinks(window, flags, parent_window);
    16368: 7445-block 95
call    0 returned 16368
    16368: 7446:        window->ParentWindowInBeginStack = parent_window_in_stack;
        -: 7447:
        -: 7448:        // Focus route
        -: 7449:        // There's little point to expose a flag to set this: because the interesting cases won't be using parent_window_in_stack,
        -: 7450:        // Use for e.g. linking a tool window in a standalone viewport to a document window, regardless of their Begin() stack parenting. (#6798)
    16368: 7451:        window->ParentWindowForFocusRoute = (window->RootWindow != window) ? parent_window_in_stack : NULL;
branch  0 taken 7539 (fallthrough)
branch  1 taken 8829
     7539: 7451-block 97
     8829: 7451-block 98
    16368: 7452:        if (window->ParentWindowForFocusRoute == NULL && window->DockNode != NULL)
    16368: 7452-block 99
branch  0 taken 8829 (fallthrough)
branch  1 taken 7539
     8829: 7452-block 100
branch  2 taken 5385 (fallthrough)
branch  3 taken 3444
     5385: 7453:            if (window->DockNode->MergedFlags & ImGuiDockNodeFlags_DockedWindowsInFocusRoute)
     5385: 7453-block 101
branch  0 taken 0 (fallthrough)
branch  1 taken 5385
    #####: 7454:                window->ParentWindowForFocusRoute = window->DockNode->HostWindow;
    %%%%%: 7454-block 102
        -: 7455:
        -: 7456:        // Override with SetNextWindowClass() field or direct call to SetWindowParentWindowForFocusRoute()
    16368: 7457:        if (window->WindowClass.FocusRouteParentWindowId != 0)
    16368: 7457-block 103
branch  0 taken 0 (fallthrough)
branch  1 taken 16368
        -: 7458:        {
    #####: 7459:            window->ParentWindowForFocusRoute = FindWindowByID(window->WindowClass.FocusRouteParentWindowId);
    %%%%%: 7459-block 104
call    0 never executed
    #####: 7460:            IM_ASSERT(window->ParentWindowForFocusRoute != 0); // Invalid value for FocusRouteParentWindowId.
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7460-block 106
call    2 never executed
        -: 7461:        }
        -: 7462:    }
        -: 7463:
        -: 7464:    // Add to focus scope stack
   17445*: 7465:    PushFocusScope((window->ChildFlags & ImGuiChildFlags_NavFlattened) ? g.CurrentFocusScopeId : window->ID);
    17445: 7465-block 107
branch  0 taken 0 (fallthrough)
branch  1 taken 17445
    %%%%%: 7465-block 108
    17445: 7465-block 109
    17445: 7465-block 110
call    2 returned 17445
branch  3 taken 17445 (fallthrough)
branch  4 taken 0 (throw)
    17445: 7466:    window->NavRootFocusScopeId = g.CurrentFocusScopeId;
        -: 7467:
        -: 7468:    // Add to popup stacks: update OpenPopupStack[] data, push to BeginPopupStack[]
    17445: 7469:    if (flags & ImGuiWindowFlags_Popup)
    17445: 7469-block 111
branch  0 taken 0 (fallthrough)
branch  1 taken 17445
        -: 7470:    {
    #####: 7471:        ImGuiPopupData& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
    %%%%%: 7471-block 112
call    0 never executed
    #####: 7472:        popup_ref.Window = window;
    #####: 7473:        popup_ref.ParentNavLayer = parent_window_in_stack->DC.NavLayerCurrent;
    #####: 7474:        g.BeginPopupStack.push_back(popup_ref);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7475:        window->PopupId = popup_ref.PopupId;
    %%%%%: 7475-block 114
        -: 7476:    }
        -: 7477:
        -: 7478:    // Process SetNextWindow***() calls
        -: 7479:    // (FIXME: Consider splitting the HasXXX flags into X/Y components
    17445: 7480:    bool window_pos_set_by_api = false;
    17445: 7481:    bool window_size_x_set_by_api = false, window_size_y_set_by_api = false;
    17445: 7482:    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasPos)
    17445: 7482-block 115
branch  0 taken 8616 (fallthrough)
branch  1 taken 8829
        -: 7483:    {
     8616: 7484:        window_pos_set_by_api = (window->SetWindowPosAllowFlags & g.NextWindowData.PosCond) != 0;
    8616*: 7485:        if (window_pos_set_by_api && ImLengthSqr(g.NextWindowData.PosPivotVal) > 0.00001f)
     8616: 7485-block 116
branch  0 taken 8616 (fallthrough)
branch  1 taken 0
     8616: 7485-block 117
call    2 returned 8616
branch  3 taken 0 (fallthrough)
branch  4 taken 8616
    %%%%%: 7485-block 119
     8616: 7485-block 120
     8616: 7485-block 121
branch  5 taken 0 (fallthrough)
branch  6 taken 8616
        -: 7486:        {
        -: 7487:            // May be processed on the next frame if this is our first frame and we are measuring size
        -: 7488:            // FIXME: Look into removing the branch so everything can go through this same code path for consistency.
    #####: 7489:            window->SetWindowPosVal = g.NextWindowData.PosVal;
    #####: 7490:            window->SetWindowPosPivot = g.NextWindowData.PosPivotVal;
    #####: 7491:            window->SetWindowPosAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);
    %%%%%: 7491-block 122
        -: 7492:        }
        -: 7493:        else
        -: 7494:        {
     8616: 7495:            SetWindowPos(window, g.NextWindowData.PosVal, g.NextWindowData.PosCond);
     8616: 7495-block 123
call    0 returned 8616
branch  1 taken 8616 (fallthrough)
branch  2 taken 0 (throw)
        -: 7496:        }
        -: 7497:    }
    17445: 7498:    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSize)
    17445: 7498-block 124
branch  0 taken 17232 (fallthrough)
branch  1 taken 213
        -: 7499:    {
    17232: 7500:        window_size_x_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.x > 0.0f);
    17232: 7500-block 125
branch  0 taken 15078 (fallthrough)
branch  1 taken 2154
    15078: 7500-block 126
branch  2 taken 15073 (fallthrough)
branch  3 taken 5
    15073: 7500-block 127
     2159: 7500-block 128
    17232: 7501:        window_size_y_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.y > 0.0f);
    17232: 7501-block 129
branch  0 taken 15078 (fallthrough)
branch  1 taken 2154
    15078: 7501-block 130
branch  2 taken 15076 (fallthrough)
branch  3 taken 2
    15076: 7501-block 131
     2156: 7501-block 132
   17232*: 7502:        if ((window->ChildFlags & ImGuiChildFlags_ResizeX) && (window->SetWindowSizeAllowFlags & ImGuiCond_FirstUseEver) == 0) // Axis-specific conditions for BeginChild()
    17232: 7502-block 133
branch  0 taken 0 (fallthrough)
branch  1 taken 17232
    %%%%%: 7502-block 134
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 7503:            g.NextWindowData.SizeVal.x = window->SizeFull.x;
    %%%%%: 7503-block 135
   17232*: 7504:        if ((window->ChildFlags & ImGuiChildFlags_ResizeY) && (window->SetWindowSizeAllowFlags & ImGuiCond_FirstUseEver) == 0)
    17232: 7504-block 136
branch  0 taken 0 (fallthrough)
branch  1 taken 17232
    %%%%%: 7504-block 137
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 7505:            g.NextWindowData.SizeVal.y = window->SizeFull.y;
    %%%%%: 7505-block 138
    17232: 7506:        SetWindowSize(window, g.NextWindowData.SizeVal, g.NextWindowData.SizeCond);
    17232: 7506-block 139
call    0 returned 17232
branch  1 taken 17232 (fallthrough)
branch  2 taken 0 (throw)
        -: 7507:    }
    17445: 7508:    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasScroll)
    17445: 7508-block 140
branch  0 taken 0 (fallthrough)
branch  1 taken 17445
        -: 7509:    {
    #####: 7510:        if (g.NextWindowData.ScrollVal.x >= 0.0f)
    %%%%%: 7510-block 141
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 7511:        {
    #####: 7512:            window->ScrollTarget.x = g.NextWindowData.ScrollVal.x;
    #####: 7513:            window->ScrollTargetCenterRatio.x = 0.0f;
    %%%%%: 7513-block 142
        -: 7514:        }
    #####: 7515:        if (g.NextWindowData.ScrollVal.y >= 0.0f)
    %%%%%: 7515-block 143
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 7516:        {
    #####: 7517:            window->ScrollTarget.y = g.NextWindowData.ScrollVal.y;
    #####: 7518:            window->ScrollTargetCenterRatio.y = 0.0f;
    %%%%%: 7518-block 144
        -: 7519:        }
        -: 7520:    }
    17445: 7521:    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasContentSize)
    17445: 7521-block 145
branch  0 taken 0 (fallthrough)
branch  1 taken 17445
    #####: 7522:        window->ContentSizeExplicit = g.NextWindowData.ContentSizeVal;
    %%%%%: 7522-block 146
    17445: 7523:    else if (first_begin_of_the_frame)
    17445: 7523-block 147
branch  0 taken 16368 (fallthrough)
branch  1 taken 1077
    16368: 7524:        window->ContentSizeExplicit = ImVec2(0.0f, 0.0f);
    16368: 7524-block 148
call    0 returned 16368
    17445: 7525:    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasWindowClass)
    17445: 7525-block 150
branch  0 taken 0 (fallthrough)
branch  1 taken 17445
    #####: 7526:        window->WindowClass = g.NextWindowData.WindowClass;
    %%%%%: 7526-block 151
    17445: 7527:    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasCollapsed)
    17445: 7527-block 152
branch  0 taken 0 (fallthrough)
branch  1 taken 17445
    #####: 7528:        SetWindowCollapsed(window, g.NextWindowData.CollapsedVal, g.NextWindowData.CollapsedCond);
    %%%%%: 7528-block 153
call    0 never executed
    17445: 7529:    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasFocus)
    17445: 7529-block 154
branch  0 taken 0 (fallthrough)
branch  1 taken 17445
    #####: 7530:        FocusWindow(window);
    %%%%%: 7530-block 155
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    17445: 7531:    if (window->Appearing)
    17445: 7531-block 156
branch  0 taken 25 (fallthrough)
branch  1 taken 17420
       25: 7532:        SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, false);
       25: 7532-block 157
call    0 returned 25
        -: 7533:
        -: 7534:    // [EXPERIMENTAL] Skip Refresh mode
    17445: 7535:    UpdateWindowSkipRefresh(window);
    17445: 7535-block 158
call    0 returned 17445
branch  1 taken 17445 (fallthrough)
branch  2 taken 0 (throw)
        -: 7536:
        -: 7537:    // Nested root windows (typically tooltips) override disabled state
   17445*: 7538:    if (window_stack_data.DisabledOverrideReenable && window->RootWindow == window)
    17445: 7538-block 159
branch  0 taken 0 (fallthrough)
branch  1 taken 17445
    %%%%%: 7538-block 160
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 7539:        BeginDisabledOverrideReenable();
    %%%%%: 7539-block 161
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 7540:
        -: 7541:    // We intentionally set g.CurrentWindow to NULL to prevent usage until when the viewport is set, then will call SetCurrentWindow()
    17445: 7542:    g.CurrentWindow = NULL;
        -: 7543:
        -: 7544:    // When reusing window again multiple times a frame, just append content (don't need to setup again)
    17445: 7545:    if (first_begin_of_the_frame && !window->SkipRefresh)
    17445: 7545-block 162
branch  0 taken 16368 (fallthrough)
branch  1 taken 1077
    16368: 7545-block 163
branch  2 taken 16368 (fallthrough)
branch  3 taken 0
        -: 7546:    {
        -: 7547:        // Initialize
   16368*: 7548:        const bool window_is_child_tooltip = (flags & ImGuiWindowFlags_ChildWindow) && (flags & ImGuiWindowFlags_Tooltip); // FIXME-WIP: Undocumented behavior of Child+Tooltip for pinned tooltip (#1345)
    16368: 7548-block 164
branch  0 taken 12924 (fallthrough)
branch  1 taken 3444
    12924: 7548-block 165
branch  2 taken 0 (fallthrough)
branch  3 taken 12924
    %%%%%: 7548-block 166
    16368: 7548-block 167
    16368: 7549:        const bool window_just_appearing_after_hidden_for_resize = (window->HiddenFramesCannotSkipItems > 0);
    16368: 7550:        window->Active = true;
    16368: 7551:        window->HasCloseButton = (p_open != NULL);
    16368: 7552:        window->ClipRect = ImVec4(-FLT_MAX, -FLT_MAX, +FLT_MAX, +FLT_MAX);
    16368: 7552-block 168
call    0 returned 16368
call    1 returned 16368
    16368: 7553:        window->IDStack.resize(1);
call    0 returned 16368
branch  1 taken 16368 (fallthrough)
branch  2 taken 0 (throw)
    16368: 7554:        window->DrawList->_ResetForNewFrame();
    16368: 7554-block 171
call    0 returned 16368
branch  1 taken 16368 (fallthrough)
branch  2 taken 0 (throw)
    16368: 7555:        window->DC.CurrentTableIdx = -1;
    16368: 7556:        if (flags & ImGuiWindowFlags_DockNodeHost)
    16368: 7556-block 172
branch  0 taken 1077 (fallthrough)
branch  1 taken 15291
        -: 7557:        {
     1077: 7558:            window->DrawList->ChannelsSplit(2);
     1077: 7558-block 173
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077: 7559:            window->DrawList->ChannelsSetCurrent(DOCKING_HOST_DRAW_CHANNEL_FG); // Render decorations on channel 1 as we will render the backgrounds manually later
     1077: 7559-block 174
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -: 7560:        }
        -: 7561:
        -: 7562:        // Restore buffer capacity when woken from a compacted state, to avoid
    16368: 7563:        if (window->MemoryCompacted)
    16368: 7563-block 175
branch  0 taken 0 (fallthrough)
branch  1 taken 16368
    #####: 7564:            GcAwakeTransientWindowBuffers(window);
    %%%%%: 7564-block 176
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 7565:
        -: 7566:        // Update stored window name when it changes (which can _only_ happen with the "###" operator, so the ID would stay unchanged).
        -: 7567:        // The title bar always display the 'name' parameter, so we only update the string storage if it needs to be visible to the end-user elsewhere.
    16368: 7568:        bool window_title_visible_elsewhere = false;
    16368: 7569:        if ((window->Viewport && window->Viewport->Window == window) || (window->DockIsActive))
    16368: 7569-block 177
branch  0 taken 16352 (fallthrough)
branch  1 taken 16
    16352: 7569-block 178
branch  2 taken 16352 (fallthrough)
branch  3 taken 0
    16368: 7569-block 179
branch  4 taken 5385 (fallthrough)
branch  5 taken 10983
     5385: 7570:            window_title_visible_elsewhere = true;
     5385: 7570-block 180
   10983*: 7571:        else if (g.NavWindowingListWindow != NULL && (window->Flags & ImGuiWindowFlags_NoNavFocus) == 0)   // Window titles visible when using CTRL+TAB
    10983: 7571-block 181
branch  0 taken 0 (fallthrough)
branch  1 taken 10983
    %%%%%: 7571-block 182
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 7572:            window_title_visible_elsewhere = true;
    %%%%%: 7572-block 183
    16368: 7573:        if (window_title_visible_elsewhere && !window_just_created && strcmp(name, window->Name) != 0)
    16368: 7573-block 184
branch  0 taken 5385 (fallthrough)
branch  1 taken 10983
     5385: 7573-block 185
branch  2 taken 5380 (fallthrough)
branch  3 taken 5
     5380: 7573-block 186
branch  4 taken 0 (fallthrough)
branch  5 taken 5380
        -: 7574:        {
    #####: 7575:            size_t buf_len = (size_t)window->NameBufLen;
    #####: 7576:            window->Name = ImStrdupcpy(window->Name, &buf_len, name);
    %%%%%: 7576-block 187
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7577:            window->NameBufLen = (int)buf_len;
    %%%%%: 7577-block 188
        -: 7578:        }
        -: 7579:
        -: 7580:        // UPDATE CONTENTS SIZE, UPDATE HIDDEN STATUS
        -: 7581:
        -: 7582:        // Update contents size from last frame for auto-fitting (or use explicit size)
    16368: 7583:        CalcWindowContentSizes(window, &window->ContentSize, &window->ContentSizeIdeal);
    16368: 7583-block 189
call    0 returned 16368
branch  1 taken 16368 (fallthrough)
branch  2 taken 0 (throw)
        -: 7584:
        -: 7585:        // FIXME: These flags are decremented before they are used. This means that in order to have these fields produce their intended behaviors
        -: 7586:        // for one frame we must set them to at least 2, which is counter-intuitive. HiddenFramesCannotSkipItems is a more complicated case because
        -: 7587:        // it has a single usage before this code block and may be set below before it is finally checked.
    16368: 7588:        if (window->HiddenFramesCanSkipItems > 0)
    16368: 7588-block 190
branch  0 taken 0 (fallthrough)
branch  1 taken 16368
    #####: 7589:            window->HiddenFramesCanSkipItems--;
    %%%%%: 7589-block 191
    16368: 7590:        if (window->HiddenFramesCannotSkipItems > 0)
    16368: 7590-block 192
branch  0 taken 21 (fallthrough)
branch  1 taken 16347
       21: 7591:            window->HiddenFramesCannotSkipItems--;
       21: 7591-block 193
    16368: 7592:        if (window->HiddenFramesForRenderOnly > 0)
    16368: 7592-block 194
branch  0 taken 0 (fallthrough)
branch  1 taken 16368
    #####: 7593:            window->HiddenFramesForRenderOnly--;
    %%%%%: 7593-block 195
        -: 7594:
        -: 7595:        // Hide new windows for one frame until they calculate their size
    16368: 7596:        if (window_just_created && (!window_size_x_set_by_api || !window_size_y_set_by_api))
    16368: 7596-block 196
branch  0 taken 16 (fallthrough)
branch  1 taken 16352
       16: 7596-block 197
branch  2 taken 9 (fallthrough)
branch  3 taken 7
        9: 7596-block 198
branch  4 taken 0 (fallthrough)
branch  5 taken 9
        7: 7597:            window->HiddenFramesCannotSkipItems = 1;
        7: 7597-block 199
        -: 7598:
        -: 7599:        // Hide popup/tooltip window when re-opening while we measure size (because we recycle the windows)
        -: 7600:        // We reset Size/ContentSize for reappearing popups/tooltips early in this function, so further code won't be tempted to use the old size.
    16368: 7601:        if (window_just_activated_by_user && (flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) != 0)
    16368: 7601-block 200
branch  0 taken 24 (fallthrough)
branch  1 taken 16344
       24: 7601-block 201
branch  2 taken 9 (fallthrough)
branch  3 taken 15
        -: 7602:        {
        9: 7603:            window->HiddenFramesCannotSkipItems = 1;
        9: 7604:            if (flags & ImGuiWindowFlags_AlwaysAutoResize)
        9: 7604-block 202
branch  0 taken 9 (fallthrough)
branch  1 taken 0
        -: 7605:            {
        9: 7606:                if (!window_size_x_set_by_api)
        9: 7606-block 203
branch  0 taken 9 (fallthrough)
branch  1 taken 0
        9: 7607:                    window->Size.x = window->SizeFull.x = 0.f;
        9: 7607-block 204
        9: 7608:                if (!window_size_y_set_by_api)
        9: 7608-block 205
branch  0 taken 9 (fallthrough)
branch  1 taken 0
        9: 7609:                    window->Size.y = window->SizeFull.y = 0.f;
        9: 7609-block 206
        9: 7610:                window->ContentSize = window->ContentSizeIdeal = ImVec2(0.f, 0.f);
        9: 7610-block 207
call    0 returned 9
        -: 7611:            }
        -: 7612:        }
        -: 7613:
        -: 7614:        // SELECT VIEWPORT
        -: 7615:        // We need to do this before using any style/font sizes, as viewport with a different DPI may affect font sizes.
        -: 7616:
    16368: 7617:        WindowSelectViewport(window);
    16368: 7617-block 209
call    0 returned 16368
branch  1 taken 16368 (fallthrough)
branch  2 taken 0 (throw)
    16368: 7618:        SetCurrentViewport(window, window->Viewport);
    16368: 7618-block 210
call    0 returned 16368
branch  1 taken 16368 (fallthrough)
branch  2 taken 0 (throw)
   16368*: 7619:        window->FontDpiScale = (g.IO.ConfigFlags & ImGuiConfigFlags_DpiEnableScaleFonts) ? window->Viewport->DpiScale : 1.0f;
    16368: 7619-block 211
branch  0 taken 0 (fallthrough)
branch  1 taken 16368
    %%%%%: 7619-block 212
    16368: 7619-block 213
    16368: 7620:        SetCurrentWindow(window);
    16368: 7620-block 214
call    0 returned 16368
branch  1 taken 16368 (fallthrough)
branch  2 taken 0 (throw)
    16368: 7621:        flags = window->Flags;
        -: 7622:
        -: 7623:        // LOCK BORDER SIZE AND PADDING FOR THE FRAME (so that altering them doesn't cause inconsistencies)
        -: 7624:        // We read Style data after the call to UpdateSelectWindowViewport() which might be swapping the style.
        -: 7625:
    16368: 7626:        if (!window->DockIsActive && (flags & ImGuiWindowFlags_ChildWindow))
    16368: 7626-block 215
branch  0 taken 10983 (fallthrough)
branch  1 taken 5385
    10983: 7626-block 216
branch  2 taken 7539 (fallthrough)
branch  3 taken 3444
     7539: 7627:            window->WindowBorderSize = style.ChildBorderSize;
     7539: 7627-block 217
        -: 7628:        else
     8829: 7629:            window->WindowBorderSize = ((flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) && !(flags & ImGuiWindowFlags_Modal)) ? style.PopupBorderSize : style.WindowBorderSize;
     8829: 7629-block 218
branch  0 taken 213 (fallthrough)
branch  1 taken 8616
      213: 7629-block 219
branch  2 taken 213 (fallthrough)
branch  3 taken 0
      213: 7629-block 220
     8616: 7629-block 221
     8829: 7629-block 222
    16368: 7630:        window->WindowPadding = style.WindowPadding;
    16368: 7631:        if (!window->DockIsActive && (flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup) && !(window->ChildFlags & ImGuiChildFlags_AlwaysUseWindowPadding) && window->WindowBorderSize == 0.0f)
    16368: 7631-block 223
branch  0 taken 10983 (fallthrough)
branch  1 taken 5385
    10983: 7631-block 224
branch  2 taken 7539 (fallthrough)
branch  3 taken 3444
     7539: 7631-block 225
branch  4 taken 7539 (fallthrough)
branch  5 taken 0
     7539: 7631-block 226
branch  6 taken 7539 (fallthrough)
branch  7 taken 0
     7539: 7631-block 227
branch  8 taken 7539 (fallthrough)
branch  9 taken 0
    7539*: 7632:            window->WindowPadding = ImVec2(0.0f, (flags & ImGuiWindowFlags_MenuBar) ? style.WindowPadding.y : 0.0f);
     7539: 7632-block 228
branch  0 taken 0 (fallthrough)
branch  1 taken 7539
    %%%%%: 7632-block 229
     7539: 7632-block 230
     7539: 7632-block 231
call    2 returned 7539
        -: 7633:
        -: 7634:        // Lock menu offset so size calculation can use it as menu-bar windows need a minimum size.
    16368: 7635:        window->DC.MenuBarOffset.x = ImMax(ImMax(window->WindowPadding.x, style.ItemSpacing.x), g.NextWindowData.MenuBarOffsetMinVal.x);
    16368: 7635-block 233
call    0 returned 16368
call    1 returned 16368
    16368: 7636:        window->DC.MenuBarOffset.y = g.NextWindowData.MenuBarOffsetMinVal.y;
    16368: 7637:        window->TitleBarHeight = (flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : g.FontSize + g.Style.FramePadding.y * 2.0f;
branch  0 taken 6462 (fallthrough)
branch  1 taken 9906
     6462: 7637-block 236
     9906: 7637-block 237
    16368: 7638:        window->MenuBarHeight = (flags & ImGuiWindowFlags_MenuBar) ? window->DC.MenuBarOffset.y + g.FontSize + g.Style.FramePadding.y * 2.0f : 0.0f;
    16368: 7638-block 238
branch  0 taken 1077 (fallthrough)
branch  1 taken 15291
     1077: 7638-block 239
    15291: 7638-block 240
        -: 7639:
        -: 7640:        // Depending on condition we use previous or current window size to compare against contents size to decide if a scrollbar should be visible.
        -: 7641:        // Those flags will be altered further down in the function depending on more conditions.
    16368: 7642:        bool use_current_size_for_scrollbar_x = window_just_created;
    16368: 7643:        bool use_current_size_for_scrollbar_y = window_just_created;
    16368: 7644:        if (window_size_x_set_by_api && window->ContentSizeExplicit.x != 0.0f)
    16368: 7644-block 241
branch  0 taken 15073 (fallthrough)
branch  1 taken 1295
    15073: 7644-block 242
branch  2 taken 0 (fallthrough)
branch  3 taken 15073
    #####: 7645:            use_current_size_for_scrollbar_x = true;
    %%%%%: 7645-block 243
    16368: 7646:        if (window_size_y_set_by_api && window->ContentSizeExplicit.y != 0.0f) // #7252
    16368: 7646-block 244
branch  0 taken 15076 (fallthrough)
branch  1 taken 1292
    15076: 7646-block 245
branch  2 taken 0 (fallthrough)
branch  3 taken 15076
    #####: 7647:            use_current_size_for_scrollbar_y = true;
    %%%%%: 7647-block 246
        -: 7648:
        -: 7649:        // Collapse window by double-clicking on title bar
        -: 7650:        // At this point we don't have a clipping rectangle setup yet, so we can use the title bar area for hit detection and drawing
    16368: 7651:        if (!(flags & ImGuiWindowFlags_NoTitleBar) && !(flags & ImGuiWindowFlags_NoCollapse) && !window->DockIsActive)
    16368: 7651-block 247
branch  0 taken 6462 (fallthrough)
branch  1 taken 9906
     6462: 7651-block 248
branch  2 taken 2154 (fallthrough)
branch  3 taken 4308
     2154: 7651-block 249
branch  4 taken 1077 (fallthrough)
branch  5 taken 1077
        -: 7652:        {
        -: 7653:            // We don't use a regular button+id to test for double-click on title bar (mostly due to legacy reason, could be fixed),
        -: 7654:            // so verify that we don't have items over the title bar.
     1077: 7655:            ImRect title_bar_rect = window->TitleBarRect();
     1077: 7655-block 250
call    0 returned 1077
    1077*: 7656:            if (g.HoveredWindow == window && g.HoveredId == 0 && g.HoveredIdPreviousFrame == 0 && g.ActiveId == 0 && IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max))
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 7656-block 252
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7656-block 253
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 7656-block 254
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 7656-block 255
call    8 never executed
branch  9 never executed (fallthrough)
branch 10 never executed
    %%%%%: 7656-block 257
     1077: 7656-block 258
     1077: 7656-block 259
branch 11 taken 0 (fallthrough)
branch 12 taken 1077
    #####: 7657:                if (g.IO.MouseClickedCount[0] == 2 && GetKeyOwner(ImGuiKey_MouseLeft) == ImGuiKeyOwner_NoOwner)
    %%%%%: 7657-block 260
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7657-block 261
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 7657-block 263
    %%%%%: 7657-block 264
    %%%%%: 7657-block 265
branch  5 never executed (fallthrough)
branch  6 never executed
    #####: 7658:                    window->WantCollapseToggle = true;
    %%%%%: 7658-block 266
     1077: 7659:            if (window->WantCollapseToggle)
     1077: 7659-block 267
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
        -: 7660:            {
    #####: 7661:                window->Collapsed = !window->Collapsed;
    #####: 7662:                if (!window->Collapsed)
    %%%%%: 7662-block 268
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7663:                    use_current_size_for_scrollbar_y = true;
    %%%%%: 7663-block 269
    #####: 7664:                MarkIniSettingsDirty(window);
    %%%%%: 7664-block 270
call    0 never executed
        -: 7665:            }
     1077: 7666:        }
     1077: 7666-block 271
        -: 7667:        else
        -: 7668:        {
    15291: 7669:            window->Collapsed = false;
    15291: 7669-block 272
        -: 7670:        }
    16368: 7671:        window->WantCollapseToggle = false;
        -: 7672:
        -: 7673:        // SIZE
        -: 7674:
        -: 7675:        // Outer Decoration Sizes
        -: 7676:        // (we need to clear ScrollbarSize immediately as CalcWindowAutoFitSize() needs it and can be called from other locations).
    16368: 7677:        const ImVec2 scrollbar_sizes_from_last_frame = window->ScrollbarSizes;
    16368: 7678:        window->DecoOuterSizeX1 = 0.0f;
    16368: 7679:        window->DecoOuterSizeX2 = 0.0f;
    16368: 7680:        window->DecoOuterSizeY1 = window->TitleBarHeight + window->MenuBarHeight;
    16368: 7681:        window->DecoOuterSizeY2 = 0.0f;
    16368: 7682:        window->ScrollbarSizes = ImVec2(0.0f, 0.0f);
    16368: 7682-block 273
call    0 returned 16368
        -: 7683:
        -: 7684:        // Calculate auto-fit size, handle automatic resize
    16368: 7685:        const ImVec2 size_auto_fit = CalcWindowAutoFitSize(window, window->ContentSizeIdeal);
call    0 returned 16368
branch  1 taken 16368 (fallthrough)
branch  2 taken 0 (throw)
    16368: 7686:        if ((flags & ImGuiWindowFlags_AlwaysAutoResize) && !window->Collapsed)
    16368: 7686-block 275
branch  0 taken 213 (fallthrough)
branch  1 taken 16155
      213: 7686-block 276
branch  2 taken 213 (fallthrough)
branch  3 taken 0
        -: 7687:        {
        -: 7688:            // Using SetNextWindowSize() overrides ImGuiWindowFlags_AlwaysAutoResize, so it can be used on tooltips/popups, etc.
      213: 7689:            if (!window_size_x_set_by_api)
      213: 7689-block 277
branch  0 taken 213 (fallthrough)
branch  1 taken 0
        -: 7690:            {
      213: 7691:                window->SizeFull.x = size_auto_fit.x;
      213: 7692:                use_current_size_for_scrollbar_x = true;
      213: 7692-block 278
        -: 7693:            }
      213: 7694:            if (!window_size_y_set_by_api)
      213: 7694-block 279
branch  0 taken 213 (fallthrough)
branch  1 taken 0
        -: 7695:            {
      213: 7696:                window->SizeFull.y = size_auto_fit.y;
      213: 7697:                use_current_size_for_scrollbar_y = true;
      213: 7697-block 280
        -: 7698:            }
        -: 7699:        }
    16155: 7700:        else if (window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)
    16155: 7700-block 282
branch  0 taken 16145 (fallthrough)
branch  1 taken 10
    16145: 7700-block 283
branch  2 taken 0 (fallthrough)
branch  3 taken 16145
        -: 7701:        {
        -: 7702:            // Auto-fit may only grow window during the first few frames
        -: 7703:            // We still process initial auto-fit on collapsed windows to get a window width, but otherwise don't honor ImGuiWindowFlags_AlwaysAutoResize when collapsed.
       10: 7704:            if (!window_size_x_set_by_api && window->AutoFitFramesX > 0)
       10: 7704-block 284
branch  0 taken 5 (fallthrough)
branch  1 taken 5
        5: 7704-block 285
branch  2 taken 5 (fallthrough)
branch  3 taken 0
        -: 7705:            {
       5*: 7706:                window->SizeFull.x = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.x, size_auto_fit.x) : size_auto_fit.x;
        5: 7706-block 286
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    %%%%%: 7706-block 287
call    2 never executed
        5: 7706-block 288
        5: 7707:                use_current_size_for_scrollbar_x = true;
        5: 7707-block 289
        -: 7708:            }
       10: 7709:            if (!window_size_y_set_by_api && window->AutoFitFramesY > 0)
       10: 7709-block 290
branch  0 taken 2 (fallthrough)
branch  1 taken 8
        2: 7709-block 291
branch  2 taken 2 (fallthrough)
branch  3 taken 0
        -: 7710:            {
       2*: 7711:                window->SizeFull.y = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.y, size_auto_fit.y) : size_auto_fit.y;
        2: 7711-block 292
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%: 7711-block 293
call    2 never executed
        2: 7711-block 294
        2: 7712:                use_current_size_for_scrollbar_y = true;
        2: 7712-block 295
        -: 7713:            }
       10: 7714:            if (!window->Collapsed)
       10: 7714-block 296
branch  0 taken 10 (fallthrough)
branch  1 taken 0
       10: 7715:                MarkIniSettingsDirty(window);
       10: 7715-block 297
call    0 returned 10
        -: 7716:        }
        -: 7717:
        -: 7718:        // Apply minimum/maximum window size constraints and final size
    16368: 7719:        window->SizeFull = CalcWindowSizeAfterConstraint(window, window->SizeFull);
    16368: 7719-block 298
call    0 returned 16368
branch  1 taken 16368 (fallthrough)
branch  2 taken 0 (throw)
   16368*: 7720:        window->Size = window->Collapsed && !(flags & ImGuiWindowFlags_ChildWindow) ? window->TitleBarRect().GetSize() : window->SizeFull;
    16368: 7720-block 299
branch  0 taken 0 (fallthrough)
branch  1 taken 16368
    %%%%%: 7720-block 300
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7720-block 301
call    4 never executed
call    5 never executed
    16368: 7720-block 303
        -: 7721:
        -: 7722:        // POSITION
        -: 7723:
        -: 7724:        // Popup latch its initial position, will position itself when it appears next frame
    16368: 7725:        if (window_just_activated_by_user)
    16368: 7725-block 304
branch  0 taken 24 (fallthrough)
branch  1 taken 16344
        -: 7726:        {
       24: 7727:            window->AutoPosLastDirection = ImGuiDir_None;
      24*: 7728:            if ((flags & ImGuiWindowFlags_Popup) != 0 && !(flags & ImGuiWindowFlags_Modal) && !window_pos_set_by_api) // FIXME: BeginPopup() could use SetNextWindowPos()
       24: 7728-block 305
branch  0 taken 0 (fallthrough)
branch  1 taken 24
    %%%%%: 7728-block 306
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7728-block 307
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 7729:                window->Pos = g.BeginPopupStack.back().OpenPopupPos;
    %%%%%: 7729-block 308
call    0 never executed
        -: 7730:        }
        -: 7731:
        -: 7732:        // Position child window
    16368: 7733:        if (flags & ImGuiWindowFlags_ChildWindow)
    16368: 7733-block 310
branch  0 taken 12924 (fallthrough)
branch  1 taken 3444
        -: 7734:        {
   12924*: 7735:            IM_ASSERT(parent_window && parent_window->Active);
    12924: 7735-block 311
branch  0 taken 12924 (fallthrough)
branch  1 taken 0
    12924: 7735-block 312
branch  2 taken 12924 (fallthrough)
branch  3 taken 0
    12924: 7735-block 313
    %%%%%: 7735-block 314
call    4 never executed
    12924: 7736:            window->BeginOrderWithinParent = (short)parent_window->DC.ChildWindows.Size;
    12924: 7737:            parent_window->DC.ChildWindows.push_back(window);
    12924: 7737-block 315
call    0 returned 12924
branch  1 taken 12924 (fallthrough)
branch  2 taken 0 (throw)
    12924: 7738:            if (!(flags & ImGuiWindowFlags_Popup) && !window_pos_set_by_api && !window_is_child_tooltip)
    12924: 7738-block 316
branch  0 taken 12924 (fallthrough)
branch  1 taken 0
    12924: 7738-block 317
branch  2 taken 6462 (fallthrough)
branch  3 taken 6462
     6462: 7738-block 318
branch  4 taken 6462 (fallthrough)
branch  5 taken 0
     6462: 7739:                window->Pos = parent_window->DC.CursorPos;
     6462: 7739-block 319
        -: 7740:        }
        -: 7741:
   16368*: 7742:        const bool window_pos_with_pivot = (window->SetWindowPosVal.x != FLT_MAX && window->HiddenFramesCannotSkipItems == 0);
    16368: 7742-block 320
branch  0 taken 0 (fallthrough)
branch  1 taken 16368
    %%%%%: 7742-block 321
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7742-block 322
    16368: 7742-block 323
    16368: 7743:        if (window_pos_with_pivot)
    16368: 7743-block 324
branch  0 taken 0 (fallthrough)
branch  1 taken 16368
    #####: 7744:            SetWindowPos(window, window->SetWindowPosVal - window->Size * window->SetWindowPosPivot, 0); // Position given a pivot (e.g. for centering)
    %%%%%: 7744-block 325
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 7744-block 328
    $$$$$: 7744-block 727
    $$$$$: 7744-block 728
    16368: 7745:        else if ((flags & ImGuiWindowFlags_ChildMenu) != 0)
    16368: 7745-block 329
branch  0 taken 0 (fallthrough)
branch  1 taken 16368
    #####: 7746:            window->Pos = FindBestWindowPosForPopup(window);
    %%%%%: 7746-block 330
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
   16368*: 7747:        else if ((flags & ImGuiWindowFlags_Popup) != 0 && !window_pos_set_by_api && window_just_appearing_after_hidden_for_resize)
    16368: 7747-block 331
branch  0 taken 0 (fallthrough)
branch  1 taken 16368
    %%%%%: 7747-block 332
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7747-block 333
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 7748:            window->Pos = FindBestWindowPosForPopup(window);
    %%%%%: 7748-block 334
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 7748-block 335
    16368: 7749:        else if ((flags & ImGuiWindowFlags_Tooltip) != 0 && !window_pos_set_by_api && !window_is_child_tooltip)
    16368: 7749-block 336
branch  0 taken 213 (fallthrough)
branch  1 taken 16155
      213: 7749-block 337
branch  2 taken 213 (fallthrough)
branch  3 taken 0
      213: 7749-block 338
branch  4 taken 213 (fallthrough)
branch  5 taken 0
      213: 7750:            window->Pos = FindBestWindowPosForPopup(window);
      213: 7750-block 339
call    0 returned 213
branch  1 taken 213 (fallthrough)
branch  2 taken 0 (throw)
        -: 7751:
        -: 7752:        // Late create viewport if we don't fit within our current host viewport.
   16368*: 7753:        if (window->ViewportAllowPlatformMonitorExtend >= 0 && !window->ViewportOwned && !(window->Viewport->Flags & ImGuiViewportFlags_IsMinimized))
    16368: 7753-block 340
branch  0 taken 0 (fallthrough)
branch  1 taken 16368
    %%%%%: 7753-block 341
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7753-block 342
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 7754:            if (!window->Viewport->GetMainRect().Contains(window->Rect()))
    %%%%%: 7754-block 343
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
        -: 7755:            {
        -: 7756:                // This is based on the assumption that the DPI will be known ahead (same as the DPI of the selection done in UpdateSelectWindowViewport)
        -: 7757:                //ImGuiViewport* old_viewport = window->Viewport;
    #####: 7758:                window->Viewport = AddUpdateViewport(window, window->ID, window->Pos, window->Size, ImGuiViewportFlags_NoFocusOnAppearing);
    %%%%%: 7758-block 347
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 7759:
        -: 7760:                // FIXME-DPI
        -: 7761:                //IM_ASSERT(old_viewport->DpiScale == window->Viewport->DpiScale); // FIXME-DPI: Something went wrong
    #####: 7762:                SetCurrentViewport(window, window->Viewport);
    %%%%%: 7762-block 348
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7763:                window->FontDpiScale = (g.IO.ConfigFlags & ImGuiConfigFlags_DpiEnableScaleFonts) ? window->Viewport->DpiScale : 1.0f;
    %%%%%: 7763-block 349
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7763-block 350
    %%%%%: 7763-block 351
    #####: 7764:                SetCurrentWindow(window);
    %%%%%: 7764-block 352
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 7765:            }
        -: 7766:
    16368: 7767:        if (window->ViewportOwned)
    16368: 7767-block 353
branch  0 taken 0 (fallthrough)
branch  1 taken 16368
    #####: 7768:            WindowSyncOwnedViewport(window, parent_window_in_stack);
    %%%%%: 7768-block 354
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 7769:
        -: 7770:        // Calculate the range of allowed position for that window (to be movable and visible past safe area padding)
        -: 7771:        // When clamping to stay visible, we will enforce that window->Pos stays inside of visibility_rect.
    16368: 7772:        ImRect viewport_rect(window->Viewport->GetMainRect());
    16368: 7772-block 355
call    0 returned 16368
    16368: 7773:        ImRect viewport_work_rect(window->Viewport->GetWorkRect());
call    0 returned 16368
    16368: 7774:        ImVec2 visibility_padding = ImMax(style.DisplayWindowPadding, style.DisplaySafeAreaPadding);
call    0 returned 16368
    16368: 7775:        ImRect visibility_rect(viewport_work_rect.Min + visibility_padding, viewport_work_rect.Max - visibility_padding);
call    0 returned 16368
call    1 returned 16368
call    2 returned 16368
        -: 7776:
        -: 7777:        // Clamp position/size so window stays visible within its viewport or monitor
        -: 7778:        // Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.
        -: 7779:        // FIXME: Similar to code in GetWindowAllowedExtentRect()
    16368: 7780:        if (!window_pos_set_by_api && !(flags & ImGuiWindowFlags_ChildWindow))
branch  0 taken 7752 (fallthrough)
branch  1 taken 8616
     7752: 7780-block 362
branch  2 taken 1290 (fallthrough)
branch  3 taken 6462
        -: 7781:        {
    1290*: 7782:            if (!window->ViewportOwned && viewport_rect.GetWidth() > 0 && viewport_rect.GetHeight() > 0.0f)
     1290: 7782-block 363
branch  0 taken 1290 (fallthrough)
branch  1 taken 0
     1290: 7782-block 364
call    2 returned 1290
branch  3 taken 1290 (fallthrough)
branch  4 taken 0
     1290: 7782-block 366
call    5 returned 1290
branch  6 taken 1290 (fallthrough)
branch  7 taken 0
     1290: 7782-block 368
    %%%%%: 7782-block 369
     1290: 7782-block 370
branch  8 taken 1290 (fallthrough)
branch  9 taken 0
        -: 7783:            {
     1290: 7784:                ClampWindowPos(window, visibility_rect);
     1290: 7784-block 371
call    0 returned 1290
branch  1 taken 1290 (fallthrough)
branch  2 taken 0 (throw)
        -: 7785:            }
    #####: 7786:            else if (window->ViewportOwned && g.PlatformIO.Monitors.Size > 0)
    %%%%%: 7786-block 372
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7786-block 373
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 7787:            {
    #####: 7788:                if (g.MovingWindow != NULL && window->RootWindowDockTree == g.MovingWindow->RootWindowDockTree)
    %%%%%: 7788-block 374
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7788-block 375
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 7789:                {
        -: 7790:                    // While moving windows we allow them to straddle monitors (#7299, #3071)
    #####: 7791:                    visibility_rect = g.PlatformMonitorsFullWorkRect;
    %%%%%: 7791-block 376
        -: 7792:                }
        -: 7793:                else
        -: 7794:                {
        -: 7795:                    // When not moving ensure visible in its monitor
        -: 7796:                    // Lost windows (e.g. a monitor disconnected) will naturally moved to the fallback/dummy monitor aka the main viewport.
    #####: 7797:                    const ImGuiPlatformMonitor* monitor = GetViewportPlatformMonitor(window->Viewport);
    %%%%%: 7797-block 377
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7798:                    visibility_rect = ImRect(monitor->WorkPos, monitor->WorkPos + monitor->WorkSize);
    %%%%%: 7798-block 378
call    0 never executed
call    1 never executed
        -: 7799:                }
    #####: 7800:                visibility_rect.Expand(-visibility_padding);
    %%%%%: 7800-block 381
call    0 never executed
call    1 never executed
    #####: 7801:                ClampWindowPos(window, visibility_rect);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 7802:            }
        -: 7803:        }
    16368: 7804:        window->Pos = ImTrunc(window->Pos);
    16368: 7804-block 384
call    0 returned 16368
        -: 7805:
        -: 7806:        // Lock window rounding for the frame (so that altering them doesn't cause inconsistencies)
        -: 7807:        // Large values tend to lead to variety of artifacts and are not recommended.
    16368: 7808:        if (window->ViewportOwned || window->DockIsActive)
branch  0 taken 16368 (fallthrough)
branch  1 taken 0
    16368: 7808-block 386
branch  2 taken 5385 (fallthrough)
branch  3 taken 10983
     5385: 7809:            window->WindowRounding = 0.0f;
     5385: 7809-block 387
        -: 7810:        else
   10983*: 7811:            window->WindowRounding = (flags & ImGuiWindowFlags_ChildWindow) ? style.ChildRounding : ((flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiWindowFlags_Modal)) ? style.PopupRounding : style.WindowRounding;
    10983: 7811-block 388
branch  0 taken 7539 (fallthrough)
branch  1 taken 3444
     7539: 7811-block 389
     3444: 7811-block 390
branch  2 taken 0 (fallthrough)
branch  3 taken 3444
    %%%%%: 7811-block 391
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 7811-block 392
     3444: 7811-block 393
     3444: 7811-block 394
    10983: 7811-block 395
        -: 7812:
        -: 7813:        // For windows with title bar or menu bar, we clamp to FrameHeight(FontSize + FramePadding.y * 2.0f) to completely hide artifacts.
        -: 7814:        //if ((window->Flags & ImGuiWindowFlags_MenuBar) || !(window->Flags & ImGuiWindowFlags_NoTitleBar))
        -: 7815:        //    window->WindowRounding = ImMin(window->WindowRounding, g.FontSize + style.FramePadding.y * 2.0f);
        -: 7816:
        -: 7817:        // Apply window focus (new and reactivated windows are moved to front)
    16368: 7818:        bool want_focus = false;
    16368: 7819:        if (window_just_activated_by_user && !(flags & ImGuiWindowFlags_NoFocusOnAppearing))
    16368: 7819-block 396
branch  0 taken 24 (fallthrough)
branch  1 taken 16344
       24: 7819-block 397
branch  2 taken 24 (fallthrough)
branch  3 taken 0
        -: 7820:        {
       24: 7821:            if (flags & ImGuiWindowFlags_Popup)
       24: 7821-block 398
branch  0 taken 0 (fallthrough)
branch  1 taken 24
    #####: 7822:                want_focus = true;
    %%%%%: 7822-block 399
       24: 7823:            else if ((window->DockIsActive || (flags & ImGuiWindowFlags_ChildWindow) == 0) && !(flags & ImGuiWindowFlags_Tooltip))
       24: 7823-block 400
branch  0 taken 19 (fallthrough)
branch  1 taken 5
       19: 7823-block 401
branch  2 taken 12 (fallthrough)
branch  3 taken 7
       17: 7823-block 402
branch  4 taken 8 (fallthrough)
branch  5 taken 9
        8: 7824:                want_focus = true;
        8: 7824-block 403
        -: 7825:        }
        -: 7826:
        -: 7827:        // [Test Engine] Register whole window in the item system (before submitting further decorations)
        -: 7828:#ifdef IMGUI_ENABLE_TEST_ENGINE
        -: 7829:        if (g.TestEngineHookItems)
        -: 7830:        {
        -: 7831:            IM_ASSERT(window->IDStack.Size == 1);
        -: 7832:            window->IDStack.Size = 0; // As window->IDStack[0] == window->ID here, make sure TestEngine doesn't erroneously see window as parent of itself.
        -: 7833:            IMGUI_TEST_ENGINE_ITEM_ADD(window->ID, window->Rect(), NULL);
        -: 7834:            IMGUI_TEST_ENGINE_ITEM_INFO(window->ID, window->Name, (g.HoveredWindow == window) ? ImGuiItemStatusFlags_HoveredRect : 0);
        -: 7835:            window->IDStack.Size = 1;
        -: 7836:        }
        -: 7837:#endif
        -: 7838:
        -: 7839:        // Decide if we are going to handle borders and resize grips
    16368: 7840:        const bool handle_borders_and_resize_grips = (window->DockNodeAsHost || !window->DockIsActive);
    16368: 7840-block 404
branch  0 taken 15292 (fallthrough)
branch  1 taken 1076
    15292: 7840-block 405
branch  2 taken 9907 (fallthrough)
branch  3 taken 5385
    10983: 7840-block 406
     5385: 7840-block 407
        -: 7841:
        -: 7842:        // Handle manual resize: Resize Grips, Borders, Gamepad
    16368: 7843:        int border_hovered = -1, border_held = -1;
    16368: 7844:        ImU32 resize_grip_col[4] = {};
   16368*: 7845:        const int resize_grip_count = ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup)) ? 0 : g.IO.ConfigWindowsResizeFromEdges ? 2 : 1; // Allow resize from lower-left if we have the mouse cursor feedback for it.
    16368: 7845-block 408
branch  0 taken 12924 (fallthrough)
branch  1 taken 3444
    12924: 7845-block 409
branch  2 taken 0 (fallthrough)
branch  3 taken 12924
     3444: 7845-block 410
branch  4 taken 3444 (fallthrough)
branch  5 taken 0
     3444: 7845-block 411
    %%%%%: 7845-block 412
     3444: 7845-block 413
    12924: 7845-block 414
    16368: 7846:        const float resize_grip_draw_size = IM_TRUNC(ImMax(g.FontSize * 1.10f, window->WindowRounding + 1.0f + g.FontSize * 0.2f));
    16368: 7846-block 415
call    0 returned 16368
    16368: 7847:        if (handle_borders_and_resize_grips && !window->Collapsed)
branch  0 taken 10983 (fallthrough)
branch  1 taken 5385
    10983: 7847-block 417
branch  2 taken 10983 (fallthrough)
branch  3 taken 0
    10983: 7848:            if (int auto_fit_mask = UpdateWindowManualResize(window, size_auto_fit, &border_hovered, &border_held, resize_grip_count, &resize_grip_col[0], visibility_rect))
    10983: 7848-block 418
call    0 returned 10983
branch  1 taken 10983 (fallthrough)
branch  2 taken 0 (throw)
    10983: 7848-block 419
branch  3 taken 0 (fallthrough)
branch  4 taken 10983
        -: 7849:            {
    #####: 7850:                if (auto_fit_mask & (1 << ImGuiAxis_X))
    %%%%%: 7850-block 420
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7851:                    use_current_size_for_scrollbar_x = true;
    %%%%%: 7851-block 421
    #####: 7852:                if (auto_fit_mask & (1 << ImGuiAxis_Y))
    %%%%%: 7852-block 422
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7853:                    use_current_size_for_scrollbar_y = true;
    %%%%%: 7853-block 423
        -: 7854:            }
    16368: 7855:        window->ResizeBorderHovered = (signed char)border_hovered;
    16368: 7856:        window->ResizeBorderHeld = (signed char)border_held;
        -: 7857:
        -: 7858:        // Synchronize window --> viewport again and one last time (clamping and manual resize may have affected either)
    16368: 7859:        if (window->ViewportOwned)
    16368: 7859-block 424
branch  0 taken 0 (fallthrough)
branch  1 taken 16368
        -: 7860:        {
    #####: 7861:            if (!window->Viewport->PlatformRequestMove)
    %%%%%: 7861-block 425
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7862:                window->Viewport->Pos = window->Pos;
    %%%%%: 7862-block 426
    #####: 7863:            if (!window->Viewport->PlatformRequestResize)
    %%%%%: 7863-block 427
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7864:                window->Viewport->Size = window->Size;
    %%%%%: 7864-block 428
    #####: 7865:            window->Viewport->UpdateWorkRect();
    %%%%%: 7865-block 429
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7866:            viewport_rect = window->Viewport->GetMainRect();
    %%%%%: 7866-block 430
call    0 never executed
        -: 7867:        }
        -: 7868:
        -: 7869:        // Save last known viewport position within the window itself (so it can be saved in .ini file and restored)
    16368: 7870:        window->ViewportPos = window->Viewport->Pos;
        -: 7871:
        -: 7872:        // SCROLLBAR VISIBILITY
        -: 7873:
        -: 7874:        // Update scrollbar visibility (based on the Size that was effective during last frame or the auto-resized Size).
    16368: 7875:        if (!window->Collapsed)
    16368: 7875-block 431
branch  0 taken 16368 (fallthrough)
branch  1 taken 0
        -: 7876:        {
        -: 7877:            // When reading the current size we need to read it after size constraints have been applied.
        -: 7878:            // Intentionally use previous frame values for InnerRect and ScrollbarSizes.
        -: 7879:            // And when we use window->DecorationUp here it doesn't have ScrollbarSizes.y applied yet.
    16368: 7880:            ImVec2 avail_size_from_current_frame = ImVec2(window->SizeFull.x, window->SizeFull.y - (window->DecoOuterSizeY1 + window->DecoOuterSizeY2));
    16368: 7880-block 432
call    0 returned 16368
    16368: 7881:            ImVec2 avail_size_from_last_frame = window->InnerRect.GetSize() + scrollbar_sizes_from_last_frame;
call    0 returned 16368
call    1 returned 16368
    16368: 7882:            ImVec2 needed_size_from_last_frame = window_just_created ? ImVec2(0, 0) : window->ContentSize + window->WindowPadding * 2.0f;
branch  0 taken 16 (fallthrough)
branch  1 taken 16352
       16: 7882-block 436
call    2 returned 16
    16352: 7882-block 437
call    3 returned 16352
call    4 returned 16352
    16368: 7883:            float size_x_for_scrollbars = use_current_size_for_scrollbar_x ? avail_size_from_current_frame.x : avail_size_from_last_frame.x;
    16368: 7883-block 439
branch  0 taken 228 (fallthrough)
branch  1 taken 16140
      228: 7883-block 440
    16140: 7883-block 441
    16368: 7884:            float size_y_for_scrollbars = use_current_size_for_scrollbar_y ? avail_size_from_current_frame.y : avail_size_from_last_frame.y;
    16368: 7884-block 442
branch  0 taken 228 (fallthrough)
branch  1 taken 16140
      228: 7884-block 443
    16140: 7884-block 444
        -: 7885:            //bool scrollbar_y_from_last_frame = window->ScrollbarY; // FIXME: May want to use that in the ScrollbarX expression? How many pros vs cons?
    16368: 7886:            window->ScrollbarY = (flags & ImGuiWindowFlags_AlwaysVerticalScrollbar) || ((needed_size_from_last_frame.y > size_y_for_scrollbars) && !(flags & ImGuiWindowFlags_NoScrollbar));
    16368: 7886-block 445
branch  0 taken 16368 (fallthrough)
branch  1 taken 0
    16368: 7886-block 446
branch  2 taken 8609 (fallthrough)
branch  3 taken 7759
     8609: 7886-block 447
branch  4 taken 5382 (fallthrough)
branch  5 taken 3227
     5382: 7886-block 448
    10986: 7886-block 449
    16368: 7887:            window->ScrollbarX = (flags & ImGuiWindowFlags_AlwaysHorizontalScrollbar) || ((needed_size_from_last_frame.x > size_x_for_scrollbars - (window->ScrollbarY ? style.ScrollbarSize : 0.0f)) && !(flags & ImGuiWindowFlags_NoScrollbar) && (flags & ImGuiWindowFlags_HorizontalScrollbar));
    16368: 7887-block 450
branch  0 taken 16368 (fallthrough)
branch  1 taken 0
    16368: 7887-block 451
branch  2 taken 5382 (fallthrough)
branch  3 taken 10986
     5382: 7887-block 452
    10986: 7887-block 453
    16368: 7887-block 454
branch  4 taken 8605 (fallthrough)
branch  5 taken 7763
     8605: 7887-block 455
branch  6 taken 6455 (fallthrough)
branch  7 taken 2150
     6455: 7887-block 456
branch  8 taken 2152 (fallthrough)
branch  9 taken 4303
     2152: 7887-block 457
    14216: 7887-block 458
    16368: 7888:            if (window->ScrollbarX && !window->ScrollbarY)
    16368: 7888-block 459
branch  0 taken 2152 (fallthrough)
branch  1 taken 14216
     2152: 7888-block 460
branch  2 taken 1075 (fallthrough)
branch  3 taken 1077
    1075*: 7889:                window->ScrollbarY = (needed_size_from_last_frame.y > size_y_for_scrollbars - style.ScrollbarSize) && !(flags & ImGuiWindowFlags_NoScrollbar);
     1075: 7889-block 461
branch  0 taken 0 (fallthrough)
branch  1 taken 1075
    %%%%%: 7889-block 462
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7889-block 463
     1075: 7889-block 464
     1075: 7889-block 465
    16368: 7890:            window->ScrollbarSizes = ImVec2(window->ScrollbarY ? style.ScrollbarSize : 0.0f, window->ScrollbarX ? style.ScrollbarSize : 0.0f);
    16368: 7890-block 466
branch  0 taken 2152 (fallthrough)
branch  1 taken 14216
     2152: 7890-block 467
    14216: 7890-block 468
    16368: 7890-block 469
branch  2 taken 5382 (fallthrough)
branch  3 taken 10986
     5382: 7890-block 470
    10986: 7890-block 471
    16368: 7890-block 472
call    4 returned 16368
        -: 7891:
        -: 7892:            // Amend the partially filled window->DecorationXXX values.
    16368: 7893:            window->DecoOuterSizeX2 += window->ScrollbarSizes.x;
    16368: 7894:            window->DecoOuterSizeY2 += window->ScrollbarSizes.y;
        -: 7895:        }
        -: 7896:
        -: 7897:        // UPDATE RECTANGLES (1- THOSE NOT AFFECTED BY SCROLLING)
        -: 7898:        // Update various regions. Variables they depend on should be set above in this function.
        -: 7899:        // We set this up after processing the resize grip so that our rectangles doesn't lag by a frame.
        -: 7900:
        -: 7901:        // Outer rectangle
        -: 7902:        // Not affected by window border size. Used by:
        -: 7903:        // - FindHoveredWindow() (w/ extra padding when border resize is enabled)
        -: 7904:        // - Begin() initial clipping rect for drawing window background and borders.
        -: 7905:        // - Begin() clipping whole child
    16368: 7906:        const ImRect host_rect = ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup) && !window_is_child_tooltip) ? parent_window->ClipRect : viewport_rect;
    16368: 7906-block 474
branch  0 taken 12924 (fallthrough)
branch  1 taken 3444
    12924: 7906-block 475
branch  2 taken 12924 (fallthrough)
branch  3 taken 0
    12924: 7906-block 476
branch  4 taken 12924 (fallthrough)
branch  5 taken 0
    12924: 7906-block 477
     3444: 7906-block 478
    16368: 7907:        const ImRect outer_rect = window->Rect();
    16368: 7907-block 479
call    0 returned 16368
    16368: 7908:        const ImRect title_bar_rect = window->TitleBarRect();
call    0 returned 16368
    16368: 7909:        window->OuterRectClipped = outer_rect;
    16368: 7910:        if (window->DockIsActive)
branch  0 taken 5385 (fallthrough)
branch  1 taken 10983
     5385: 7911:            window->OuterRectClipped.Min.y += window->TitleBarHeight;
     5385: 7911-block 482
    16368: 7912:        window->OuterRectClipped.ClipWith(host_rect);
    16368: 7912-block 483
call    0 returned 16368
        -: 7913:
        -: 7914:        // Inner rectangle
        -: 7915:        // Not affected by window border size. Used by:
        -: 7916:        // - InnerClipRect
        -: 7917:        // - ScrollToRectEx()
        -: 7918:        // - NavUpdatePageUpPageDown()
        -: 7919:        // - Scrollbar()
    16368: 7920:        window->InnerRect.Min.x = window->Pos.x + window->DecoOuterSizeX1;
    16368: 7921:        window->InnerRect.Min.y = window->Pos.y + window->DecoOuterSizeY1;
    16368: 7922:        window->InnerRect.Max.x = window->Pos.x + window->Size.x - window->DecoOuterSizeX2;
    16368: 7923:        window->InnerRect.Max.y = window->Pos.y + window->Size.y - window->DecoOuterSizeY2;
        -: 7924:
        -: 7925:        // Inner clipping rectangle.
        -: 7926:        // - Extend a outside of normal work region up to borders.
        -: 7927:        // - This is to allow e.g. Selectable or CollapsingHeader or some separators to cover that space.
        -: 7928:        // - It also makes clipped items be more noticeable.
        -: 7929:        // - And is consistent on both axis (prior to 2024/05/03 ClipRect used WindowPadding.x * 0.5f on left and right edge), see #3312
        -: 7930:        // - Force round operator last to ensure that e.g. (int)(max.x-min.x) in user's render code produce correct result.
        -: 7931:        // Note that if our window is collapsed we will end up with an inverted (~null) clipping rectangle which is the correct behavior.
        -: 7932:        // Affected by window/frame border size. Used by:
        -: 7933:        // - Begin() initial clip rect
    16368: 7934:        float top_border_size = (((flags & ImGuiWindowFlags_MenuBar) || !(flags & ImGuiWindowFlags_NoTitleBar)) ? style.FrameBorderSize : window->WindowBorderSize);
branch  0 taken 15291 (fallthrough)
branch  1 taken 1077
    15291: 7934-block 485
branch  2 taken 6462 (fallthrough)
branch  3 taken 8829
     7539: 7934-block 486
     8829: 7934-block 487
        -: 7935:
        -: 7936:        // Try to match the fact that our border is drawn centered over the window rectangle, rather than inner.
        -: 7937:        // This is why we do a *0.5f here. We don't currently even technically support large values for WindowBorderSize,
        -: 7938:        // see e.g #7887 #7888, but may do after we move the window border to become an inner border (and then we can remove the 0.5f here).
    16368: 7939:        window->InnerClipRect.Min.x = ImFloor(0.5f + window->InnerRect.Min.x + window->WindowBorderSize * 0.5f);
    16368: 7939-block 488
call    0 returned 16368
    16368: 7940:        window->InnerClipRect.Min.y = ImFloor(0.5f + window->InnerRect.Min.y + top_border_size * 0.5f);
call    0 returned 16368
    16368: 7941:        window->InnerClipRect.Max.x = ImFloor(window->InnerRect.Max.x - window->WindowBorderSize * 0.5f);
call    0 returned 16368
    16368: 7942:        window->InnerClipRect.Max.y = ImFloor(window->InnerRect.Max.y - window->WindowBorderSize * 0.5f);
call    0 returned 16368
    16368: 7943:        window->InnerClipRect.ClipWithFull(host_rect);
call    0 returned 16368
        -: 7944:
        -: 7945:        // Default item width. Make it proportional to window size if window manually resizes
    16368: 7946:        if (window->Size.x > 0.0f && !(flags & ImGuiWindowFlags_Tooltip) && !(flags & ImGuiWindowFlags_AlwaysAutoResize))
branch  0 taken 16368 (fallthrough)
branch  1 taken 0
    16368: 7946-block 494
branch  2 taken 16155 (fallthrough)
branch  3 taken 213
    16155: 7946-block 495
branch  4 taken 16155 (fallthrough)
branch  5 taken 0
    16155: 7947:            window->ItemWidthDefault = ImTrunc(window->Size.x * 0.65f);
    16155: 7947-block 496
call    0 returned 16155
        -: 7948:        else
      213: 7949:            window->ItemWidthDefault = ImTrunc(g.FontSize * 16.0f);
      213: 7949-block 498
call    0 returned 213
        -: 7950:
        -: 7951:        // SCROLLING
        -: 7952:
        -: 7953:        // Lock down maximum scrolling
        -: 7954:        // The value of ScrollMax are ahead from ScrollbarX/ScrollbarY which is intentionally using InnerRect from previous rect in order to accommodate
        -: 7955:        // for right/bottom aligned items without creating a scrollbar.
    16368: 7956:        window->ScrollMax.x = ImMax(0.0f, window->ContentSize.x + window->WindowPadding.x * 2.0f - window->InnerRect.GetWidth());
    16368: 7956-block 500
call    0 returned 16368
call    1 returned 16368
    16368: 7957:        window->ScrollMax.y = ImMax(0.0f, window->ContentSize.y + window->WindowPadding.y * 2.0f - window->InnerRect.GetHeight());
call    0 returned 16368
call    1 returned 16368
        -: 7958:
        -: 7959:        // Apply scrolling
    16368: 7960:        window->Scroll = CalcNextScrollFromScrollTargetAndClamp(window);
call    0 returned 16368
branch  1 taken 16368 (fallthrough)
branch  2 taken 0 (throw)
    16368: 7961:        window->ScrollTarget = ImVec2(FLT_MAX, FLT_MAX);
    16368: 7961-block 505
call    0 returned 16368
    16368: 7962:        window->DecoInnerSizeX1 = window->DecoInnerSizeY1 = 0.0f;
        -: 7963:
        -: 7964:        // DRAWING
        -: 7965:
        -: 7966:        // Setup draw list and outer clipping rectangle
   16368*: 7967:        IM_ASSERT(window->DrawList->CmdBuffer.Size == 1 && window->DrawList->CmdBuffer[0].ElemCount == 0);
branch  0 taken 16368 (fallthrough)
branch  1 taken 0
    16368: 7967-block 507
call    2 returned 16368
branch  3 taken 16368 (fallthrough)
branch  4 taken 0
    16368: 7967-block 509
    %%%%%: 7967-block 510
call    5 never executed
    16368: 7968:        window->DrawList->PushTextureID(g.Font->ContainerAtlas->TexID);
    16368: 7968-block 511
call    0 returned 16368
branch  1 taken 16368 (fallthrough)
branch  2 taken 0 (throw)
    16368: 7969:        PushClipRect(host_rect.Min, host_rect.Max, false);
    16368: 7969-block 512
call    0 returned 16368
branch  1 taken 16368 (fallthrough)
branch  2 taken 0 (throw)
        -: 7970:
        -: 7971:        // Child windows can render their decoration (bg color, border, scrollbars, etc.) within their parent to save a draw call (since 1.71)
        -: 7972:        // When using overlapping child windows, this will break the assumption that child z-order is mapped to submission order.
        -: 7973:        // FIXME: User code may rely on explicit sorting of overlapping child window and would need to disable this somehow. Please get in contact if you are affected (github #4493)
    16368: 7974:        const bool is_undocked_or_docked_visible = !window->DockIsActive || window->DockTabIsVisible;
    16368: 7974-block 513
branch  0 taken 5385 (fallthrough)
branch  1 taken 10983
     5385: 7974-block 514
branch  2 taken 5380 (fallthrough)
branch  3 taken 5
    16363: 7974-block 515
        5: 7974-block 516
    16368: 7975:        if (is_undocked_or_docked_visible)
    16368: 7975-block 517
branch  0 taken 16363 (fallthrough)
branch  1 taken 5
        -: 7976:        {
    16363: 7977:            bool render_decorations_in_parent = false;
    16363: 7978:            if ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup) && !window_is_child_tooltip)
    16363: 7978-block 518
branch  0 taken 12919 (fallthrough)
branch  1 taken 3444
    12919: 7978-block 519
branch  2 taken 12919 (fallthrough)
branch  3 taken 0
    12919: 7978-block 520
branch  4 taken 12919 (fallthrough)
branch  5 taken 0
        -: 7979:            {
        -: 7980:                // - We test overlap with the previous child window only (testing all would end up being O(log N) not a good investment here)
        -: 7981:                // - We disable this when the parent window has zero vertices, which is a common pattern leading to laying out multiple overlapping childs
    12919: 7982:                ImGuiWindow* previous_child = parent_window->DC.ChildWindows.Size >= 2 ? parent_window->DC.ChildWindows[parent_window->DC.ChildWindows.Size - 2] : NULL;
    12919: 7982-block 521
branch  0 taken 5381 (fallthrough)
branch  1 taken 7538
     5381: 7982-block 522
call    2 returned 5381
     7538: 7982-block 524
   12919*: 7983:                bool previous_child_overlapping = previous_child ? previous_child->Rect().Overlaps(window->Rect()) : false;
    12919: 7983-block 525
branch  0 taken 5381 (fallthrough)
branch  1 taken 7538
     5381: 7983-block 526
call    2 returned 5381
call    3 returned 5381
call    4 returned 5381
branch  5 taken 0 (fallthrough)
branch  6 taken 5381
    %%%%%: 7983-block 530
    12919: 7983-block 531
    12919: 7984:                bool parent_is_empty = (parent_window->DrawList->VtxBuffer.Size == 0);
    12919: 7985:                if (window->DrawList->CmdBuffer.back().ElemCount == 0 && !parent_is_empty && !previous_child_overlapping)
    12919: 7985-block 532
call    0 returned 12919
branch  1 taken 12919 (fallthrough)
branch  2 taken 0
    12919: 7985-block 534
branch  3 taken 9687 (fallthrough)
branch  4 taken 3232
     9687: 7985-block 535
branch  5 taken 9687 (fallthrough)
branch  6 taken 0
     9687: 7985-block 536
     3232: 7985-block 537
    12919: 7985-block 538
branch  7 taken 9687 (fallthrough)
branch  8 taken 3232
     9687: 7986:                    render_decorations_in_parent = true;
     9687: 7986-block 539
        -: 7987:            }
    16363: 7988:            if (render_decorations_in_parent)
    16363: 7988-block 540
branch  0 taken 9687 (fallthrough)
branch  1 taken 6676
     9687: 7989:                window->DrawList = parent_window->DrawList;
     9687: 7989-block 541
        -: 7990:
        -: 7991:            // Handle title bar, scrollbar, resize grips and resize borders
   16363*: 7992:            const ImGuiWindow* window_to_highlight = g.NavWindowingTarget ? g.NavWindowingTarget : g.NavWindow;
    16363: 7992-block 542
branch  0 taken 0 (fallthrough)
branch  1 taken 16363
    %%%%%: 7992-block 543
    16363: 7992-block 544
   16363*: 7993:            const bool title_bar_is_highlight = want_focus || (window_to_highlight && (window->RootWindowForTitleBarHighlight == window_to_highlight->RootWindowForTitleBarHighlight || (window->DockNode && window->DockNode == window_to_highlight->DockNode)));
    16363: 7993-block 545
branch  0 taken 16360 (fallthrough)
branch  1 taken 3
    16360: 7993-block 546
branch  2 taken 16360 (fallthrough)
branch  3 taken 0
    16360: 7993-block 547
branch  4 taken 2365 (fallthrough)
branch  5 taken 13995
     2365: 7993-block 548
branch  6 taken 0 (fallthrough)
branch  7 taken 2365
    %%%%%: 7993-block 549
branch  8 never executed (fallthrough)
branch  9 never executed
    13998: 7993-block 550
     2365: 7993-block 551
    16363: 7994:            RenderWindowDecorations(window, title_bar_rect, title_bar_is_highlight, handle_borders_and_resize_grips, resize_grip_count, resize_grip_col, resize_grip_draw_size);
    16363: 7994-block 552
call    0 returned 16363
branch  1 taken 16363 (fallthrough)
branch  2 taken 0 (throw)
        -: 7995:
    16363: 7996:            if (render_decorations_in_parent)
    16363: 7996-block 553
branch  0 taken 9687 (fallthrough)
branch  1 taken 6676
     9687: 7997:                window->DrawList = &window->DrawListInst;
     9687: 7997-block 554
        -: 7998:        }
        -: 7999:
        -: 8000:        // UPDATE RECTANGLES (2- THOSE AFFECTED BY SCROLLING)
        -: 8001:
        -: 8002:        // Work rectangle.
        -: 8003:        // Affected by window padding and border size. Used by:
        -: 8004:        // - Columns() for right-most edge
        -: 8005:        // - TreeNode(), CollapsingHeader() for right-most edge
        -: 8006:        // - BeginTabBar() for right-most edge
    16368: 8007:        const bool allow_scrollbar_x = !(flags & ImGuiWindowFlags_NoScrollbar) && (flags & ImGuiWindowFlags_HorizontalScrollbar);
    16368: 8007-block 555
branch  0 taken 12060 (fallthrough)
branch  1 taken 4308
    12060: 8007-block 556
branch  2 taken 2154 (fallthrough)
branch  3 taken 9906
     2154: 8007-block 557
    14214: 8007-block 558
    16368: 8008:        const bool allow_scrollbar_y = !(flags & ImGuiWindowFlags_NoScrollbar);
   16368*: 8009:        const float work_rect_size_x = (window->ContentSizeExplicit.x != 0.0f ? window->ContentSizeExplicit.x : ImMax(allow_scrollbar_x ? window->ContentSize.x : 0.0f, window->Size.x - window->WindowPadding.x * 2.0f - (window->DecoOuterSizeX1 + window->DecoOuterSizeX2)));
    16368: 8009-block 559
branch  0 taken 0 (fallthrough)
branch  1 taken 16368
    %%%%%: 8009-block 560
    16368: 8009-block 561
branch  2 taken 2154 (fallthrough)
branch  3 taken 14214
     2154: 8009-block 562
    14214: 8009-block 563
    16368: 8009-block 564
call    4 returned 16368
   16368*: 8010:        const float work_rect_size_y = (window->ContentSizeExplicit.y != 0.0f ? window->ContentSizeExplicit.y : ImMax(allow_scrollbar_y ? window->ContentSize.y : 0.0f, window->Size.y - window->WindowPadding.y * 2.0f - (window->DecoOuterSizeY1 + window->DecoOuterSizeY2)));
    16368: 8010-block 565
branch  0 taken 0 (fallthrough)
branch  1 taken 16368
    %%%%%: 8010-block 566
    16368: 8010-block 567
branch  2 taken 12060 (fallthrough)
branch  3 taken 4308
    12060: 8010-block 568
     4308: 8010-block 569
    16368: 8010-block 570
call    4 returned 16368
    16368: 8011:        window->WorkRect.Min.x = ImTrunc(window->InnerRect.Min.x - window->Scroll.x + ImMax(window->WindowPadding.x, window->WindowBorderSize));
    16368: 8011-block 571
call    0 returned 16368
call    1 returned 16368
    16368: 8012:        window->WorkRect.Min.y = ImTrunc(window->InnerRect.Min.y - window->Scroll.y + ImMax(window->WindowPadding.y, window->WindowBorderSize));
call    0 returned 16368
call    1 returned 16368
    16368: 8013:        window->WorkRect.Max.x = window->WorkRect.Min.x + work_rect_size_x;
    16368: 8014:        window->WorkRect.Max.y = window->WorkRect.Min.y + work_rect_size_y;
    16368: 8015:        window->ParentWorkRect = window->WorkRect;
        -: 8016:
        -: 8017:        // [LEGACY] Content Region
        -: 8018:        // FIXME-OBSOLETE: window->ContentRegionRect.Max is currently very misleading / partly faulty, but some BeginChild() patterns relies on it.
        -: 8019:        // Unless explicit content size is specified by user, this currently represent the region leading to no scrolling.
        -: 8020:        // Used by:
        -: 8021:        // - Mouse wheel scrolling + many other things
    16368: 8022:        window->ContentRegionRect.Min.x = window->Pos.x - window->Scroll.x + window->WindowPadding.x + window->DecoOuterSizeX1;
    16368: 8023:        window->ContentRegionRect.Min.y = window->Pos.y - window->Scroll.y + window->WindowPadding.y + window->DecoOuterSizeY1;
   16368*: 8024:        window->ContentRegionRect.Max.x = window->ContentRegionRect.Min.x + (window->ContentSizeExplicit.x != 0.0f ? window->ContentSizeExplicit.x : (window->Size.x - window->WindowPadding.x * 2.0f - (window->DecoOuterSizeX1 + window->DecoOuterSizeX2)));
branch  0 taken 0 (fallthrough)
branch  1 taken 16368
    %%%%%: 8024-block 576
    16368: 8024-block 577
   16368*: 8025:        window->ContentRegionRect.Max.y = window->ContentRegionRect.Min.y + (window->ContentSizeExplicit.y != 0.0f ? window->ContentSizeExplicit.y : (window->Size.y - window->WindowPadding.y * 2.0f - (window->DecoOuterSizeY1 + window->DecoOuterSizeY2)));
    16368: 8025-block 578
branch  0 taken 0 (fallthrough)
branch  1 taken 16368
    %%%%%: 8025-block 579
    16368: 8025-block 580
        -: 8026:
        -: 8027:        // Setup drawing context
        -: 8028:        // (NB: That term "drawing context / DC" lost its meaning a long time ago. Initially was meant to hold transient data only. Nowadays difference between window-> and window->DC-> is dubious.)
    16368: 8029:        window->DC.Indent.x = window->DecoOuterSizeX1 + window->WindowPadding.x - window->Scroll.x;
    16368: 8030:        window->DC.GroupOffset.x = 0.0f;
    16368: 8031:        window->DC.ColumnsOffset.x = 0.0f;
        -: 8032:
        -: 8033:        // Record the loss of precision of CursorStartPos which can happen due to really large scrolling amount.
        -: 8034:        // This is used by clipper to compensate and fix the most common use case of large scroll area. Easy and cheap, next best thing compared to switching everything to double or ImU64.
    16368: 8035:        double start_pos_highp_x = (double)window->Pos.x + window->WindowPadding.x - (double)window->Scroll.x + window->DecoOuterSizeX1 + window->DC.ColumnsOffset.x;
    16368: 8036:        double start_pos_highp_y = (double)window->Pos.y + window->WindowPadding.y - (double)window->Scroll.y + window->DecoOuterSizeY1;
    16368: 8037:        window->DC.CursorStartPos  = ImVec2((float)start_pos_highp_x, (float)start_pos_highp_y);
    16368: 8037-block 581
call    0 returned 16368
    16368: 8038:        window->DC.CursorStartPosLossyness = ImVec2((float)(start_pos_highp_x - window->DC.CursorStartPos.x), (float)(start_pos_highp_y - window->DC.CursorStartPos.y));
call    0 returned 16368
    16368: 8039:        window->DC.CursorPos = window->DC.CursorStartPos;
    16368: 8040:        window->DC.CursorPosPrevLine = window->DC.CursorPos;
    16368: 8041:        window->DC.CursorMaxPos = window->DC.CursorStartPos;
    16368: 8042:        window->DC.IdealMaxPos = window->DC.CursorStartPos;
    16368: 8043:        window->DC.CurrLineSize = window->DC.PrevLineSize = ImVec2(0.0f, 0.0f);
call    0 returned 16368
    16368: 8044:        window->DC.CurrLineTextBaseOffset = window->DC.PrevLineTextBaseOffset = 0.0f;
    16368: 8045:        window->DC.IsSameLine = window->DC.IsSetPos = false;
        -: 8046:
    16368: 8047:        window->DC.NavLayerCurrent = ImGuiNavLayer_Main;
    16368: 8048:        window->DC.NavLayersActiveMask = window->DC.NavLayersActiveMaskNext;
    16368: 8049:        window->DC.NavLayersActiveMaskNext = 0x00;
    16368: 8050:        window->DC.NavIsScrollPushableX = true;
    16368: 8051:        window->DC.NavHideHighlightOneFrame = false;
    16368: 8052:        window->DC.NavWindowHasScrollY = (window->ScrollMax.y > 0.0f);
        -: 8053:
    16368: 8054:        window->DC.MenuBarAppending = false;
    16368: 8055:        window->DC.MenuColumns.Update(style.ItemSpacing.x, window_just_activated_by_user);
call    0 returned 16368
branch  1 taken 16368 (fallthrough)
branch  2 taken 0 (throw)
    16368: 8056:        window->DC.TreeDepth = 0;
    16368: 8057:        window->DC.TreeHasStackDataDepthMask = 0x00;
    16368: 8058:        window->DC.ChildWindows.resize(0);
    16368: 8058-block 585
call    0 returned 16368
branch  1 taken 16368 (fallthrough)
branch  2 taken 0 (throw)
    16368: 8059:        window->DC.StateStorage = &window->StateStorage;
    16368: 8060:        window->DC.CurrentColumns = NULL;
    16368: 8061:        window->DC.LayoutType = ImGuiLayoutType_Vertical;
    16368: 8062:        window->DC.ParentLayoutType = parent_window ? parent_window->DC.LayoutType : ImGuiLayoutType_Vertical;
    16368: 8062-block 586
branch  0 taken 12924 (fallthrough)
branch  1 taken 3444
    12924: 8062-block 587
     3444: 8062-block 588
        -: 8063:
    16368: 8064:        window->DC.ItemWidth = window->ItemWidthDefault;
    16368: 8065:        window->DC.TextWrapPos = -1.0f; // disabled
    16368: 8066:        window->DC.ItemWidthStack.resize(0);
    16368: 8066-block 589
call    0 returned 16368
branch  1 taken 16368 (fallthrough)
branch  2 taken 0 (throw)
    16368: 8067:        window->DC.TextWrapPosStack.resize(0);
    16368: 8067-block 590
call    0 returned 16368
branch  1 taken 16368 (fallthrough)
branch  2 taken 0 (throw)
    16368: 8068:        if (flags & ImGuiWindowFlags_Modal)
    16368: 8068-block 591
branch  0 taken 0 (fallthrough)
branch  1 taken 16368
    #####: 8069:            window->DC.ModalDimBgColor = ColorConvertFloat4ToU32(GetStyleColorVec4(ImGuiCol_ModalWindowDimBg));
    %%%%%: 8069-block 592
call    0 never executed
call    1 never executed
        -: 8070:
    16368: 8071:        if (window->AutoFitFramesX > 0)
    16368: 8071-block 595
branch  0 taken 12 (fallthrough)
branch  1 taken 16356
       12: 8072:            window->AutoFitFramesX--;
       12: 8072-block 596
    16368: 8073:        if (window->AutoFitFramesY > 0)
    16368: 8073-block 597
branch  0 taken 6 (fallthrough)
branch  1 taken 16362
        6: 8074:            window->AutoFitFramesY--;
        6: 8074-block 598
        -: 8075:
        -: 8076:        // Clear SetNextWindowXXX data (can aim to move this higher in the function)
    16368: 8077:        g.NextWindowData.ClearFlags();
    16368: 8077-block 599
call    0 returned 16368
        -: 8078:
        -: 8079:        // Apply focus (we need to call FocusWindow() AFTER setting DC.CursorStartPos so our initial navigation reference rectangle can start around there)
        -: 8080:        // We ImGuiFocusRequestFlags_UnlessBelowModal to:
        -: 8081:        // - Avoid focusing a window that is created outside of a modal. This will prevent active modal from being closed.
        -: 8082:        // - Position window behind the modal that is not a begin-parent of this window.
    16368: 8083:        if (want_focus)
branch  0 taken 8 (fallthrough)
branch  1 taken 16360
        8: 8084:            FocusWindow(window, ImGuiFocusRequestFlags_UnlessBelowModal);
        8: 8084-block 601
call    0 returned 8
branch  1 taken 8 (fallthrough)
branch  2 taken 0 (throw)
    16368: 8085:        if (want_focus && window == g.NavWindow)
    16368: 8085-block 602
branch  0 taken 8 (fallthrough)
branch  1 taken 16360
        8: 8085-block 603
branch  2 taken 8 (fallthrough)
branch  3 taken 0
        8: 8086:            NavInitWindow(window, false); // <-- this is in the way for us to be able to defer and sort reappearing FocusWindow() calls
        8: 8086-block 604
call    0 returned 8
branch  1 taken 8 (fallthrough)
branch  2 taken 0 (throw)
        -: 8087:
        -: 8088:        // Close requested by platform window (apply to all windows in this viewport)
   16368*: 8089:        if (p_open != NULL && window->Viewport->PlatformRequestClose && window->Viewport != GetMainViewport())
    16368: 8089-block 605
branch  0 taken 5385 (fallthrough)
branch  1 taken 10983
     5385: 8089-block 606
branch  2 taken 0 (fallthrough)
branch  3 taken 5385
    %%%%%: 8089-block 607
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    %%%%%: 8089-block 608
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 8089-block 609
    16368: 8089-block 610
    16368: 8089-block 611
branch  9 taken 0 (fallthrough)
branch 10 taken 16368
        -: 8090:        {
    #####: 8091:            IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Window '%s' closed by PlatformRequestClose\n", window->Name);
    %%%%%: 8091-block 612
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8091-block 613
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####: 8092:            *p_open = false;
    #####: 8093:            g.NavWindowingToggleLayer = false; // Assume user mapped PlatformRequestClose on ALT-F4 so we disable ALT for menu toggle. False positive not an issue. // FIXME-NAV: Try removing.
    %%%%%: 8093-block 614
        -: 8094:        }
        -: 8095:
        -: 8096:        // Title bar
    16368: 8097:        if (!(flags & ImGuiWindowFlags_NoTitleBar) && !window->DockIsActive)
    16368: 8097-block 615
branch  0 taken 6462 (fallthrough)
branch  1 taken 9906
     6462: 8097-block 616
branch  2 taken 1077 (fallthrough)
branch  3 taken 5385
     1077: 8098:            RenderWindowTitleBarContents(window, ImRect(title_bar_rect.Min.x + window->WindowBorderSize, title_bar_rect.Min.y, title_bar_rect.Max.x - window->WindowBorderSize, title_bar_rect.Max.y), name, p_open);
     1077: 8098-block 617
call    0 returned 1077
call    1 returned 1077
branch  2 taken 1077 (fallthrough)
branch  3 taken 0 (throw)
     1077: 8098-block 619
    $$$$$: 8098-block 729
        -: 8099:
        -: 8100:        // Clear hit test shape every frame
    16368: 8101:        window->HitTestHoleSize.x = window->HitTestHoleSize.y = 0;
        -: 8102:
    16368: 8103:        if (flags & ImGuiWindowFlags_Tooltip)
    16368: 8103-block 620
branch  0 taken 213 (fallthrough)
branch  1 taken 16155
      213: 8104:            g.TooltipPreviousWindow = window;
      213: 8104-block 621
        -: 8105:
        -: 8106:        // Pressing CTRL+C while holding on a window copy its content to the clipboard
        -: 8107:        // This works but 1. doesn't handle multiple Begin/End pairs, 2. recursing into another Begin/End pair - so we need to work that out and add better logging scope.
        -: 8108:        // Maybe we can support CTRL+C on every element?
        -: 8109:        /*
        -: 8110:        //if (g.NavWindow == window && g.ActiveId == 0)
        -: 8111:        if (g.ActiveId == window->MoveId)
        -: 8112:            if (g.IO.KeyCtrl && IsKeyPressed(ImGuiKey_C))
        -: 8113:                LogToClipboard();
        -: 8114:        */
        -: 8115:
    16368: 8116:        if (g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable)
    16368: 8116-block 622
branch  0 taken 16368 (fallthrough)
branch  1 taken 0
        -: 8117:        {
        -: 8118:            // Docking: Dragging a dockable window (or any of its child) turns it into a drag and drop source.
        -: 8119:            // We need to do this _before_ we overwrite window->DC.LastItemId below because BeginDockableDragDropSource() also overwrites it.
   16368*: 8120:            if (g.MovingWindow == window && (window->RootWindowDockTree->Flags & ImGuiWindowFlags_NoDocking) == 0)
    16368: 8120-block 623
branch  0 taken 0 (fallthrough)
branch  1 taken 16368
    %%%%%: 8120-block 624
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 8121:                BeginDockableDragDropSource(window);
    %%%%%: 8121-block 625
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 8122:
        -: 8123:            // Docking: Any dockable window can act as a target. For dock node hosts we call BeginDockableDragDropTarget() in DockNodeUpdate() instead.
   16368*: 8124:            if (g.DragDropActive && !(flags & ImGuiWindowFlags_NoDocking))
    16368: 8124-block 626
branch  0 taken 0 (fallthrough)
branch  1 taken 16368
    %%%%%: 8124-block 627
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 8125:                if (g.MovingWindow == NULL || g.MovingWindow->RootWindowDockTree != window)
    %%%%%: 8125-block 628
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8125-block 629
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 8126:                    if ((window == window->RootWindowDockTree) && !(window->Flags & ImGuiWindowFlags_DockNodeHost))
    %%%%%: 8126-block 630
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8126-block 631
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 8127:                        BeginDockableDragDropTarget(window);
    %%%%%: 8127-block 632
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 8128:        }
        -: 8129:
        -: 8130:        // We fill last item data based on Title Bar/Tab, in order for IsItemHovered() and IsItemActive() to be usable after Begin().
        -: 8131:        // This is useful to allow creating context menus on title bar only, etc.
    16368: 8132:        SetLastItemDataForWindow(window, title_bar_rect);
    16368: 8132-block 633
call    0 returned 16368
branch  1 taken 16368 (fallthrough)
branch  2 taken 0 (throw)
        -: 8133:
        -: 8134:        // [DEBUG]
        -: 8135:#ifndef IMGUI_DISABLE_DEBUG_TOOLS
   16368*: 8136:        if (g.DebugLocateId != 0 && (window->ID == g.DebugLocateId || window->MoveId == g.DebugLocateId))
    16368: 8136-block 634
branch  0 taken 0 (fallthrough)
branch  1 taken 16368
    %%%%%: 8136-block 635
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 8136-block 636
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 8137:            DebugLocateItemResolveWithLastItem();
    %%%%%: 8137-block 637
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 8138:#endif
        -: 8139:
        -: 8140:        // [Test Engine] Register title bar / tab with MoveId.
        -: 8141:#ifdef IMGUI_ENABLE_TEST_ENGINE
        -: 8142:        if (!(window->Flags & ImGuiWindowFlags_NoTitleBar))
        -: 8143:            IMGUI_TEST_ENGINE_ITEM_ADD(g.LastItemData.ID, g.LastItemData.Rect, &g.LastItemData);
        -: 8144:#endif
    16368: 8145:    }
    16368: 8145-block 638
        -: 8146:    else
        -: 8147:    {
        -: 8148:        // Skip refresh always mark active
     1077: 8149:        if (window->SkipRefresh)
     1077: 8149-block 639
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####: 8150:            SetWindowActiveForSkipRefresh(window);
    %%%%%: 8150-block 640
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 8151:
        -: 8152:        // Append
     1077: 8153:        SetCurrentViewport(window, window->Viewport);
     1077: 8153-block 641
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077: 8154:        SetCurrentWindow(window);
     1077: 8154-block 642
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077: 8155:        g.NextWindowData.ClearFlags();
     1077: 8155-block 643
call    0 returned 1077
     1077: 8156:        SetLastItemDataForWindow(window, window->TitleBarRect());
call    0 returned 1077
call    1 returned 1077
branch  2 taken 1077 (fallthrough)
branch  3 taken 0 (throw)
     1077: 8156-block 646
    $$$$$: 8156-block 731
        -: 8157:    }
        -: 8158:
    17445: 8159:    if (!(flags & ImGuiWindowFlags_DockNodeHost) && !window->SkipRefresh)
    17445: 8159-block 647
branch  0 taken 16368 (fallthrough)
branch  1 taken 1077
    16368: 8159-block 648
branch  2 taken 16368 (fallthrough)
branch  3 taken 0
    16368: 8160:        PushClipRect(window->InnerClipRect.Min, window->InnerClipRect.Max, true);
    16368: 8160-block 649
call    0 returned 16368
branch  1 taken 16368 (fallthrough)
branch  2 taken 0 (throw)
        -: 8161:
        -: 8162:    // Clear 'accessed' flag last thing (After PushClipRect which will set the flag. We want the flag to stay false when the default "Debug" window is unused)
    17445: 8163:    window->WriteAccessed = false;
    17445: 8164:    window->BeginCount++;
        -: 8165:
        -: 8166:    // Update visibility
    17445: 8167:    if (first_begin_of_the_frame && !window->SkipRefresh)
    17445: 8167-block 650
branch  0 taken 16368 (fallthrough)
branch  1 taken 1077
    16368: 8167-block 651
branch  2 taken 16368 (fallthrough)
branch  3 taken 0
        -: 8168:    {
        -: 8169:        // When we are about to select this tab (which will only be visible on the _next frame_), flag it with a non-zero HiddenFramesCannotSkipItems.
        -: 8170:        // This will have the important effect of actually returning true in Begin() and not setting SkipItems, allowing an earlier submission of the window contents.
        -: 8171:        // This is analogous to regular windows being hidden from one frame.
        -: 8172:        // It is especially important as e.g. nested TabBars would otherwise generate flicker in the form of one empty frame, or focus requests won't be processed.
    16368: 8173:        if (window->DockIsActive && !window->DockTabIsVisible)
    16368: 8173-block 652
branch  0 taken 5385 (fallthrough)
branch  1 taken 10983
     5385: 8173-block 653
branch  2 taken 5 (fallthrough)
branch  3 taken 5380
        -: 8174:        {
        5: 8175:            if (window->LastFrameJustFocused == g.FrameCount)
        5: 8175-block 654
branch  0 taken 5 (fallthrough)
branch  1 taken 0
        5: 8176:                window->HiddenFramesCannotSkipItems = 1;
        5: 8176-block 655
        -: 8177:            else
    #####: 8178:                window->HiddenFramesCanSkipItems = 1;
    %%%%%: 8178-block 656
        -: 8179:        }
        -: 8180:
    16368: 8181:        if ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_ChildMenu))
    16368: 8181-block 657
branch  0 taken 12924 (fallthrough)
branch  1 taken 3444
    12924: 8181-block 658
branch  2 taken 12924 (fallthrough)
branch  3 taken 0
        -: 8182:        {
        -: 8183:            // Child window can be out of sight and have "negative" clip windows.
        -: 8184:            // Mark them as collapsed so commands are skipped earlier (we can't manually collapse them because they have no title bar).
   12924*: 8185:            IM_ASSERT((flags & ImGuiWindowFlags_NoTitleBar) != 0 || window->DockIsActive);
    12924: 8185-block 659
branch  0 taken 5385 (fallthrough)
branch  1 taken 7539
     5385: 8185-block 660
branch  2 taken 0 (fallthrough)
branch  3 taken 5385
    %%%%%: 8185-block 661
call    4 never executed
   12924*: 8186:            const bool nav_request = (window->ChildFlags & ImGuiChildFlags_NavFlattened) && (g.NavAnyRequest && g.NavWindow && g.NavWindow->RootWindowForNav == window->RootWindowForNav);
    12924: 8186-block 662
branch  0 taken 0 (fallthrough)
branch  1 taken 12924
    %%%%%: 8186-block 663
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 8186-block 664
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 8186-block 665
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 8186-block 666
    12924: 8186-block 667
    12924: 8187:            if (!g.LogEnabled && !nav_request)
    12924: 8187-block 668
branch  0 taken 12924 (fallthrough)
branch  1 taken 0
    12924: 8187-block 669
branch  2 taken 12924 (fallthrough)
branch  3 taken 0
    12924: 8188:                if (window->OuterRectClipped.Min.x >= window->OuterRectClipped.Max.x || window->OuterRectClipped.Min.y >= window->OuterRectClipped.Max.y)
    12924: 8188-block 670
branch  0 taken 12924 (fallthrough)
branch  1 taken 0
    12924: 8188-block 671
branch  2 taken 2 (fallthrough)
branch  3 taken 12922
        -: 8189:                {
       2*: 8190:                    if (window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)
        2: 8190-block 672
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%: 8190-block 673
branch  2 never executed (fallthrough)
branch  3 never executed
        2: 8191:                        window->HiddenFramesCannotSkipItems = 1;
        2: 8191-block 674
        -: 8192:                    else
    #####: 8193:                        window->HiddenFramesCanSkipItems = 1;
    %%%%%: 8193-block 675
        -: 8194:                }
        -: 8195:
        -: 8196:            // Hide along with parent or if parent is collapsed
    12924: 8197:            if (parent_window && (parent_window->Collapsed || parent_window->HiddenFramesCanSkipItems > 0))
    12924: 8197-block 677
branch  0 taken 12924 (fallthrough)
branch  1 taken 0
    12924: 8197-block 678
branch  2 taken 12924 (fallthrough)
branch  3 taken 0
    12924: 8197-block 679
branch  4 taken 0 (fallthrough)
branch  5 taken 12924
    #####: 8198:                window->HiddenFramesCanSkipItems = 1;
    %%%%%: 8198-block 680
    12924: 8199:            if (parent_window && (parent_window->Collapsed || parent_window->HiddenFramesCannotSkipItems > 0))
    12924: 8199-block 681
branch  0 taken 12924 (fallthrough)
branch  1 taken 0
    12924: 8199-block 682
branch  2 taken 12924 (fallthrough)
branch  3 taken 0
    12924: 8199-block 683
branch  4 taken 6 (fallthrough)
branch  5 taken 12918
        6: 8200:                window->HiddenFramesCannotSkipItems = 1;
        6: 8200-block 684
        -: 8201:        }
        -: 8202:
        -: 8203:        // Don't render if style alpha is 0.0 at the time of Begin(). This is arbitrary and inconsistent but has been there for a long while (may remove at some point)
    16368: 8204:        if (style.Alpha <= 0.0f)
    16368: 8204-block 685
branch  0 taken 0 (fallthrough)
branch  1 taken 16368
    #####: 8205:            window->HiddenFramesCanSkipItems = 1;
    %%%%%: 8205-block 686
        -: 8206:
        -: 8207:        // Update the Hidden flag
    16368: 8208:        bool hidden_regular = (window->HiddenFramesCanSkipItems > 0) || (window->HiddenFramesCannotSkipItems > 0);
    16368: 8208-block 687
branch  0 taken 16368 (fallthrough)
branch  1 taken 0
    16368: 8208-block 688
branch  2 taken 21 (fallthrough)
branch  3 taken 16347
       21: 8208-block 689
    16347: 8208-block 690
    16368: 8209:        window->Hidden = hidden_regular || (window->HiddenFramesForRenderOnly > 0);
    16368: 8209-block 691
branch  0 taken 16347 (fallthrough)
branch  1 taken 21
    16347: 8209-block 692
branch  2 taken 0 (fallthrough)
branch  3 taken 16347
       21: 8209-block 693
    16347: 8209-block 694
        -: 8210:
        -: 8211:        // Disable inputs for requested number of frames
    16368: 8212:        if (window->DisableInputsFrames > 0)
    16368: 8212-block 695
branch  0 taken 0 (fallthrough)
branch  1 taken 16368
        -: 8213:        {
    #####: 8214:            window->DisableInputsFrames--;
    #####: 8215:            window->Flags |= ImGuiWindowFlags_NoInputs;
    %%%%%: 8215-block 696
        -: 8216:        }
        -: 8217:
        -: 8218:        // Update the SkipItems flag, used to early out of all items functions (no layout required)
    16368: 8219:        bool skip_items = false;
    16368: 8220:        if (window->Collapsed || !window->Active || hidden_regular)
    16368: 8220-block 697
branch  0 taken 16368 (fallthrough)
branch  1 taken 0
    16368: 8220-block 698
branch  2 taken 16368 (fallthrough)
branch  3 taken 0
    16368: 8220-block 699
branch  4 taken 21 (fallthrough)
branch  5 taken 16347
       21: 8221:            if (window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0 && window->HiddenFramesCannotSkipItems <= 0)
       21: 8221-block 700
branch  0 taken 15 (fallthrough)
branch  1 taken 6
       15: 8221-block 701
branch  2 taken 15 (fallthrough)
branch  3 taken 0
       15: 8221-block 702
branch  4 taken 0 (fallthrough)
branch  5 taken 15
    #####: 8222:                skip_items = true;
    %%%%%: 8222-block 703
    16368: 8223:        window->SkipItems = skip_items;
        -: 8224:
        -: 8225:        // Restore NavLayersActiveMaskNext to previous value when not visible, so a CTRL+Tab back can use a safe value.
    16368: 8226:        if (window->SkipItems)
    16368: 8226-block 704
branch  0 taken 0 (fallthrough)
branch  1 taken 16368
    #####: 8227:            window->DC.NavLayersActiveMaskNext = window->DC.NavLayersActiveMask;
    %%%%%: 8227-block 705
        -: 8228:
        -: 8229:        // Sanity check: there are two spots which can set Appearing = true
        -: 8230:        // - when 'window_just_activated_by_user' is set -> HiddenFramesCannotSkipItems is set -> SkipItems always false
        -: 8231:        // - in BeginDocked() path when DockNodeIsVisible == DockTabIsVisible == true -> hidden _should_ be all zero // FIXME: Not formally proven, hence the assert.
   16368*: 8232:        if (window->SkipItems && !window->Appearing)
    16368: 8232-block 706
branch  0 taken 0 (fallthrough)
branch  1 taken 16368
    %%%%%: 8232-block 707
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 8233:            IM_ASSERT(window->Appearing == false); // Please report on GitHub if this triggers: https://github.com/ocornut/imgui/issues/4177
    %%%%%: 8233-block 708
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8233-block 709
call    2 never executed
    16368: 8234:    }
    16368: 8234-block 710
     1077: 8235:    else if (first_begin_of_the_frame)
     1077: 8235-block 711
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
        -: 8236:    {
        -: 8237:        // Skip refresh mode
    #####: 8238:        window->SkipItems = true;
    %%%%%: 8238-block 712
        -: 8239:    }
        -: 8240:
        -: 8241:    // [DEBUG] io.ConfigDebugBeginReturnValue override return value to test Begin/End and BeginChild/EndChild behaviors.
        -: 8242:    // (The implicit fallback window is NOT automatically ended allowing it to always be able to receive commands without crashing)
        -: 8243:#ifndef IMGUI_DISABLE_DEBUG_TOOLS
    17445: 8244:    if (!window->IsFallbackWindow)
    17445: 8244-block 713
branch  0 taken 16368 (fallthrough)
branch  1 taken 1077
   16368*: 8245:        if ((g.IO.ConfigDebugBeginReturnValueOnce && window_just_created) || (g.IO.ConfigDebugBeginReturnValueLoop && g.DebugBeginReturnValueCullDepth == g.CurrentWindowStack.Size))
    16368: 8245-block 714
branch  0 taken 0 (fallthrough)
branch  1 taken 16368
    %%%%%: 8245-block 715
branch  2 never executed (fallthrough)
branch  3 never executed
    16368: 8245-block 716
branch  4 taken 0 (fallthrough)
branch  5 taken 16368
    %%%%%: 8245-block 717
branch  6 never executed (fallthrough)
branch  7 never executed
        -: 8246:        {
    #####: 8247:            if (window->AutoFitFramesX > 0) { window->AutoFitFramesX++; }
    %%%%%: 8247-block 718
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8247-block 719
    #####: 8248:            if (window->AutoFitFramesY > 0) { window->AutoFitFramesY++; }
    %%%%%: 8248-block 720
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8248-block 721
    #####: 8249:            return false;
    %%%%%: 8249-block 722
        -: 8250:        }
        -: 8251:#endif
        -: 8252:
    17445: 8253:    return !window->SkipItems;
    17445: 8253-block 723
        -: 8254:}
        -: 8255:
function _ZN5ImGuiL24SetLastItemDataForWindowEP11ImGuiWindowRK6ImRect called 17445 returned 100% blocks executed 100%
    17445: 8256:static void ImGui::SetLastItemDataForWindow(ImGuiWindow* window, const ImRect& rect)
        -: 8257:{
    17445: 8258:    ImGuiContext& g = *GImGui;
    17445: 8259:    if (window->DockIsActive)
    17445: 8259-block 2
branch  0 taken 6462 (fallthrough)
branch  1 taken 10983
     6462: 8260:        SetLastItemData(window->MoveId, g.CurrentItemFlags, window->DockTabItemStatusFlags, window->DockTabItemRect);
     6462: 8260-block 3
call    0 returned 6462
        -: 8261:    else
    10983: 8262:        SetLastItemData(window->MoveId, g.CurrentItemFlags, IsMouseHoveringRect(rect.Min, rect.Max, false) ? ImGuiItemStatusFlags_HoveredRect : 0, rect);
    10983: 8262-block 4
call    0 returned 10983
branch  1 taken 6 (fallthrough)
branch  2 taken 10977
        6: 8262-block 6
    10977: 8262-block 7
    10983: 8262-block 8
call    3 returned 10983
    17445: 8263:}
        -: 8264:
function _ZN5ImGui3EndEv called 17445 returned 100% blocks executed 62%
    17445: 8265:void ImGui::End()
        -: 8266:{
    17445: 8267:    ImGuiContext& g = *GImGui;
    17445: 8268:    ImGuiWindow* window = g.CurrentWindow;
        -: 8269:
        -: 8270:    // Error checking: verify that user hasn't called End() too many times!
    17445: 8271:    if (g.CurrentWindowStack.Size <= 1 && g.WithinFrameScopeWithImplicitWindow)
    17445: 8271-block 2
branch  0 taken 1077 (fallthrough)
branch  1 taken 16368
     1077: 8271-block 3
branch  2 taken 0 (fallthrough)
branch  3 taken 1077
        -: 8272:    {
    #####: 8273:        IM_ASSERT_USER_ERROR(g.CurrentWindowStack.Size > 1, "Calling End() too many times!");
    %%%%%: 8273-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8273-block 5
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 8273-block 7
    %%%%%: 8273-block 8
    %%%%%: 8273-block 9
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 8273-block 10
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 8273-block 11
call    9 never executed
    #####: 8274:        return;
    %%%%%: 8274-block 12
        -: 8275:    }
    17445: 8276:    ImGuiWindowStackData& window_stack_data = g.CurrentWindowStack.back();
    17445: 8276-block 13
call    0 returned 17445
        -: 8277:
        -: 8278:    // Error checking: verify that user doesn't directly call End() on a child window.
    17445: 8279:    if ((window->Flags & ImGuiWindowFlags_ChildWindow) && !(window->Flags & ImGuiWindowFlags_DockNodeHost) && !window->DockIsActive)
branch  0 taken 14001 (fallthrough)
branch  1 taken 3444
    14001: 8279-block 15
branch  2 taken 12924 (fallthrough)
branch  3 taken 1077
    12924: 8279-block 16
branch  4 taken 6462 (fallthrough)
branch  5 taken 6462
    6462*: 8280:        IM_ASSERT_USER_ERROR(g.WithinEndChild, "Must call EndChild() and not End()!");
     6462: 8280-block 17
branch  0 taken 0 (fallthrough)
branch  1 taken 6462
    %%%%%: 8280-block 18
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 8280-block 20
     6462: 8280-block 21
     6462: 8280-block 22
branch  5 taken 0 (fallthrough)
branch  6 taken 6462
    %%%%%: 8280-block 23
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 8280-block 24
call    9 never executed
        -: 8281:
        -: 8282:    // Close anything that is open
    17445: 8283:    if (window->DC.CurrentColumns)
    17445: 8283-block 25
branch  0 taken 0 (fallthrough)
branch  1 taken 17445
    #####: 8284:        EndColumns();
    %%%%%: 8284-block 26
call    0 never executed
    17445: 8285:    if (!(window->Flags & ImGuiWindowFlags_DockNodeHost) && !window->SkipRefresh)   // Pop inner window clip rectangle
    17445: 8285-block 27
branch  0 taken 16368 (fallthrough)
branch  1 taken 1077
    16368: 8285-block 28
branch  2 taken 16368 (fallthrough)
branch  3 taken 0
    16368: 8286:        PopClipRect();
    16368: 8286-block 29
call    0 returned 16368
    17445: 8287:    PopFocusScope();
    17445: 8287-block 30
call    0 returned 17445
   17445*: 8288:    if (window_stack_data.DisabledOverrideReenable && window->RootWindow == window)
branch  0 taken 0 (fallthrough)
branch  1 taken 17445
    %%%%%: 8288-block 32
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 8289:        EndDisabledOverrideReenable();
    %%%%%: 8289-block 33
call    0 never executed
        -: 8290:
    17445: 8291:    if (window->SkipRefresh)
    17445: 8291-block 34
branch  0 taken 0 (fallthrough)
branch  1 taken 17445
        -: 8292:    {
    #####: 8293:        IM_ASSERT(window->DrawList == NULL);
    %%%%%: 8293-block 35
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8293-block 36
call    2 never executed
    #####: 8294:        window->DrawList = &window->DrawListInst;
    %%%%%: 8294-block 37
        -: 8295:    }
        -: 8296:
        -: 8297:    // Stop logging
    17445: 8298:    if (!(window->Flags & ImGuiWindowFlags_ChildWindow))    // FIXME: add more options for scope of logging
    17445: 8298-block 38
branch  0 taken 3444 (fallthrough)
branch  1 taken 14001
     3444: 8299:        LogFinish();
     3444: 8299-block 39
call    0 returned 3444
        -: 8300:
    17445: 8301:    if (window->DC.IsSetPos)
    17445: 8301-block 40
branch  0 taken 0 (fallthrough)
branch  1 taken 17445
    #####: 8302:        ErrorCheckUsingSetCursorPosToExtendParentBoundaries();
    %%%%%: 8302-block 41
call    0 never executed
        -: 8303:
        -: 8304:    // Docking: report contents sizes to parent to allow for auto-resize
    17445: 8305:    if (window->DockNode && window->DockTabIsVisible)
    17445: 8305-block 42
branch  0 taken 6462 (fallthrough)
branch  1 taken 10983
     6462: 8305-block 43
branch  2 taken 6456 (fallthrough)
branch  3 taken 6
     6456: 8306:        if (ImGuiWindow* host_window = window->DockNode->HostWindow)         // FIXME-DOCK
     6456: 8306-block 44
branch  0 taken 6456 (fallthrough)
branch  1 taken 0
     6456: 8307:            host_window->DC.CursorMaxPos = window->DC.CursorMaxPos + window->WindowPadding - host_window->WindowPadding;
     6456: 8307-block 45
call    0 returned 6456
call    1 returned 6456
        -: 8308:
        -: 8309:    // Pop from window stack
    17445: 8310:    g.LastItemData = window_stack_data.ParentLastItemDataBackup;
    17445: 8311:    if (window->Flags & ImGuiWindowFlags_ChildMenu)
    17445: 8311-block 48
branch  0 taken 0 (fallthrough)
branch  1 taken 17445
    #####: 8312:        g.BeginMenuDepth--;
    %%%%%: 8312-block 49
    17445: 8313:    if (window->Flags & ImGuiWindowFlags_Popup)
    17445: 8313-block 50
branch  0 taken 0 (fallthrough)
branch  1 taken 17445
    #####: 8314:        g.BeginPopupStack.pop_back();
    %%%%%: 8314-block 51
call    0 never executed
        -: 8315:
        -: 8316:    // Error handling, state recovery
    17445: 8317:    if (g.IO.ConfigErrorRecovery)
    17445: 8317-block 52
branch  0 taken 17445 (fallthrough)
branch  1 taken 0
    17445: 8318:        ErrorRecoveryTryToRecoverWindowState(&window_stack_data.StackSizesInBegin);
    17445: 8318-block 53
call    0 returned 17445
        -: 8319:
    17445: 8320:    g.CurrentWindowStack.pop_back();
    17445: 8320-block 54
call    0 returned 17445
    17445: 8321:    SetCurrentWindow(g.CurrentWindowStack.Size == 0 ? NULL : g.CurrentWindowStack.back().Window);
branch  0 taken 16368 (fallthrough)
branch  1 taken 1077
    16368: 8321-block 56
call    2 returned 16368
     1077: 8321-block 58
    17445: 8321-block 59
call    3 returned 17445
    17445: 8322:    if (g.CurrentWindow)
branch  0 taken 16368 (fallthrough)
branch  1 taken 1077
    16368: 8323:        SetCurrentViewport(g.CurrentWindow, g.CurrentWindow->Viewport);
    16368: 8323-block 61
call    0 returned 16368
        -: 8324:}
        -: 8325:
function _ZN5ImGui23BringWindowToFocusFrontEP11ImGuiWindow called 14 returned 100% blocks executed 85%
       14: 8326:void ImGui::BringWindowToFocusFront(ImGuiWindow* window)
        -: 8327:{
       14: 8328:    ImGuiContext& g = *GImGui;
      14*: 8329:    IM_ASSERT(window == window->RootWindow);
       14: 8329-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 14
    %%%%%: 8329-block 3
call    2 never executed
        -: 8330:
       14: 8331:    const int cur_order = window->FocusOrder;
      14*: 8332:    IM_ASSERT(g.WindowsFocusOrder[cur_order] == window);
       14: 8332-block 4
call    0 returned 14
branch  1 taken 0 (fallthrough)
branch  2 taken 14
    %%%%%: 8332-block 6
call    3 never executed
       14: 8333:    if (g.WindowsFocusOrder.back() == window)
       14: 8333-block 7
call    0 returned 14
branch  1 taken 13 (fallthrough)
branch  2 taken 1
       13: 8334:        return;
       13: 8334-block 9
        -: 8335:
        1: 8336:    const int new_order = g.WindowsFocusOrder.Size - 1;
        6: 8337:    for (int n = cur_order; n < new_order; n++)
        1: 8337-block 10
        5: 8337-block 17
        6: 8337-block 18
branch  0 taken 5
branch  1 taken 1 (fallthrough)
        -: 8338:    {
        5: 8339:        g.WindowsFocusOrder[n] = g.WindowsFocusOrder[n + 1];
        5: 8339-block 11
call    0 returned 5
call    1 returned 5
        5: 8340:        g.WindowsFocusOrder[n]->FocusOrder--;
call    0 returned 5
       5*: 8341:        IM_ASSERT(g.WindowsFocusOrder[n]->FocusOrder == n);
call    0 returned 5
branch  1 taken 0 (fallthrough)
branch  2 taken 5
    %%%%%: 8341-block 16
call    3 never executed
        -: 8342:    }
        1: 8343:    g.WindowsFocusOrder[new_order] = window;
        1: 8343-block 19
call    0 returned 1
        1: 8344:    window->FocusOrder = (short)new_order;
        -: 8345:}
        -: 8346:
function _ZN5ImGui25BringWindowToDisplayFrontEP11ImGuiWindow called 2 returned 100% blocks executed 29%
        2: 8347:void ImGui::BringWindowToDisplayFront(ImGuiWindow* window)
        -: 8348:{
        2: 8349:    ImGuiContext& g = *GImGui;
        2: 8350:    ImGuiWindow* current_front_window = g.Windows.back();
        2: 8350-block 2
call    0 returned 2
       2*: 8351:    if (current_front_window == window || current_front_window->RootWindowDockTree == window) // Cheap early out (could be better)
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%: 8351-block 4
branch  2 never executed (fallthrough)
branch  3 never executed
        2: 8352:        return;
        2: 8352-block 5
    #####: 8353:    for (int i = g.Windows.Size - 2; i >= 0; i--) // We can ignore the top-most window
    %%%%%: 8353-block 6
    %%%%%: 8353-block 13
    %%%%%: 8353-block 14
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 8354:        if (g.Windows[i] == window)
    %%%%%: 8354-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -: 8355:        {
    #####: 8356:            memmove(&g.Windows[i], &g.Windows[i + 1], (size_t)(g.Windows.Size - i - 1) * sizeof(ImGuiWindow*));
    %%%%%: 8356-block 9
call    0 never executed
call    1 never executed
    #####: 8357:            g.Windows[g.Windows.Size - 1] = window;
call    0 never executed
    #####: 8358:            break;
        -: 8359:        }
        -: 8360:}
        -: 8361:
function _ZN5ImGui24BringWindowToDisplayBackEP11ImGuiWindow called 0 returned 0% blocks executed 0%
    #####: 8362:void ImGui::BringWindowToDisplayBack(ImGuiWindow* window)
        -: 8363:{
    #####: 8364:    ImGuiContext& g = *GImGui;
    #####: 8365:    if (g.Windows[0] == window)
    %%%%%: 8365-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 8366:        return;
    %%%%%: 8366-block 4
    #####: 8367:    for (int i = 0; i < g.Windows.Size; i++)
    %%%%%: 8367-block 5
    %%%%%: 8367-block 12
    %%%%%: 8367-block 13
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 8368:        if (g.Windows[i] == window)
    %%%%%: 8368-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -: 8369:        {
    #####: 8370:            memmove(&g.Windows[1], &g.Windows[0], (size_t)i * sizeof(ImGuiWindow*));
    %%%%%: 8370-block 8
call    0 never executed
call    1 never executed
    #####: 8371:            g.Windows[0] = window;
call    0 never executed
    #####: 8372:            break;
        -: 8373:        }
        -: 8374:}
        -: 8375:
function _ZN5ImGui26BringWindowToDisplayBehindEP11ImGuiWindowS1_ called 0 returned 0% blocks executed 0%
    #####: 8376:void ImGui::BringWindowToDisplayBehind(ImGuiWindow* window, ImGuiWindow* behind_window)
        -: 8377:{
    #####: 8378:    IM_ASSERT(window != NULL && behind_window != NULL);
    %%%%%: 8378-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8378-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 8378-block 4
    %%%%%: 8378-block 5
call    4 never executed
    #####: 8379:    ImGuiContext& g = *GImGui;
    #####: 8380:    window = window->RootWindow;
    #####: 8381:    behind_window = behind_window->RootWindow;
    #####: 8382:    int pos_wnd = FindWindowDisplayIndex(window);
    %%%%%: 8382-block 6
call    0 never executed
    #####: 8383:    int pos_beh = FindWindowDisplayIndex(behind_window);
call    0 never executed
    #####: 8384:    if (pos_wnd < pos_beh)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 8385:    {
    #####: 8386:        size_t copy_bytes = (pos_beh - pos_wnd - 1) * sizeof(ImGuiWindow*);
    #####: 8387:        memmove(&g.Windows.Data[pos_wnd], &g.Windows.Data[pos_wnd + 1], copy_bytes);
    #####: 8388:        g.Windows[pos_beh - 1] = window;
    %%%%%: 8388-block 9
call    0 never executed
        -: 8389:    }
        -: 8390:    else
        -: 8391:    {
    #####: 8392:        size_t copy_bytes = (pos_wnd - pos_beh) * sizeof(ImGuiWindow*);
    #####: 8393:        memmove(&g.Windows.Data[pos_beh + 1], &g.Windows.Data[pos_beh], copy_bytes);
    #####: 8394:        g.Windows[pos_beh] = window;
    %%%%%: 8394-block 11
call    0 never executed
        -: 8395:    }
    #####: 8396:}
        -: 8397:
function _ZN5ImGui22FindWindowDisplayIndexEP11ImGuiWindow called 0 returned 0% blocks executed 0%
    #####: 8398:int ImGui::FindWindowDisplayIndex(ImGuiWindow* window)
        -: 8399:{
    #####: 8400:    ImGuiContext& g = *GImGui;
    #####: 8401:    return g.Windows.index_from_ptr(g.Windows.find(window));
    %%%%%: 8401-block 2
call    0 never executed
call    1 never executed
        -: 8402:}
        -: 8403:
        -: 8404:// Moving window to front of display and set focus (which happens to be back of our sorted list)
function _ZN5ImGui11FocusWindowEP11ImGuiWindowi called 14 returned 100% blocks executed 56%
       14: 8405:void ImGui::FocusWindow(ImGuiWindow* window, ImGuiFocusRequestFlags flags)
        -: 8406:{
       14: 8407:    ImGuiContext& g = *GImGui;
        -: 8408:
        -: 8409:    // Modal check?
       14: 8410:    if ((flags & ImGuiFocusRequestFlags_UnlessBelowModal) && (g.NavWindow != window)) // Early out in common case.
       14: 8410-block 2
branch  0 taken 8 (fallthrough)
branch  1 taken 6
        8: 8410-block 3
branch  2 taken 8 (fallthrough)
branch  3 taken 0
        8: 8411:        if (ImGuiWindow* blocking_modal = FindBlockingModal(window))
        8: 8411-block 4
call    0 returned 8
branch  1 taken 0 (fallthrough)
branch  2 taken 8
        -: 8412:        {
        -: 8413:            // This block would typically be reached in two situations:
        -: 8414:            // - API call to FocusWindow() with a window under a modal and ImGuiFocusRequestFlags_UnlessBelowModal flag.
        -: 8415:            // - User clicking on void or anything behind a modal while a modal is open (window == NULL)
    #####: 8416:            IMGUI_DEBUG_LOG_FOCUS("[focus] FocusWindow(\"%s\", UnlessBelowModal): prevented by \"%s\".\n", window ? window->Name : "<NULL>", blocking_modal->Name);
    %%%%%: 8416-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8416-block 7
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 8416-block 8
    %%%%%: 8416-block 9
    %%%%%: 8416-block 10
call    4 never executed
    #####: 8417:            if (window && window == window->RootWindow && (window->Flags & ImGuiWindowFlags_NoBringToFrontOnFocus) == 0)
    %%%%%: 8417-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8417-block 12
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 8417-block 13
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 8418:                BringWindowToDisplayBehind(window, blocking_modal); // Still bring right under modal. (FIXME: Could move in focus list too?)
    %%%%%: 8418-block 14
call    0 never executed
    #####: 8419:            ClosePopupsOverWindow(GetTopMostPopupModal(), false); // Note how we need to use GetTopMostPopupModal() aad NOT blocking_modal, to handle nested modals
    %%%%%: 8419-block 15
call    0 never executed
call    1 never executed
    #####: 8420:            return;
        -: 8421:        }
        -: 8422:
        -: 8423:    // Find last focused child (if any) and focus it instead.
      14*: 8424:    if ((flags & ImGuiFocusRequestFlags_RestoreFocusedChild) && window != NULL)
       14: 8424-block 18
branch  0 taken 0 (fallthrough)
branch  1 taken 14
    %%%%%: 8424-block 19
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 8425:        window = NavRestoreLastChildNavWindow(window);
    %%%%%: 8425-block 20
call    0 never executed
        -: 8426:
        -: 8427:    // Apply focus
       14: 8428:    if (g.NavWindow != window)
       14: 8428-block 22
branch  0 taken 11 (fallthrough)
branch  1 taken 3
        -: 8429:    {
       11: 8430:        SetNavWindow(window);
       11: 8430-block 23
call    0 returned 11
       11: 8431:        if (window && g.NavHighlightItemUnderNav)
branch  0 taken 11 (fallthrough)
branch  1 taken 0
       11: 8431-block 25
branch  2 taken 0 (fallthrough)
branch  3 taken 11
    #####: 8432:            g.NavMousePosDirty = true;
    %%%%%: 8432-block 26
      11*: 8433:        g.NavId = window ? window->NavLastIds[0] : 0; // Restore NavId
       11: 8433-block 27
branch  0 taken 11 (fallthrough)
branch  1 taken 0
       11: 8433-block 28
    %%%%%: 8433-block 29
       11: 8434:        g.NavLayer = ImGuiNavLayer_Main;
      11*: 8435:        SetNavFocusScope(window ? window->NavRootFocusScopeId : 0);
       11: 8435-block 30
branch  0 taken 11 (fallthrough)
branch  1 taken 0
       11: 8435-block 31
    %%%%%: 8435-block 32
       11: 8435-block 33
call    2 returned 11
       11: 8436:        g.NavIdIsAlive = false;
       11: 8437:        g.NavLastValidSelectionUserData = ImGuiSelectionUserData_Invalid;
        -: 8438:
        -: 8439:        // Close popups if any
       11: 8440:        ClosePopupsOverWindow(window, false);
call    0 returned 11
        -: 8441:    }
        -: 8442:
        -: 8443:    // Move the root window to the top of the pile
      14*: 8444:    IM_ASSERT(window == NULL || window->RootWindowDockTree != NULL);
       14: 8444-block 35
branch  0 taken 14 (fallthrough)
branch  1 taken 0
       14: 8444-block 36
branch  2 taken 0 (fallthrough)
branch  3 taken 14
    %%%%%: 8444-block 37
call    4 never executed
      14*: 8445:    ImGuiWindow* focus_front_window = window ? window->RootWindow : NULL;
       14: 8445-block 38
branch  0 taken 14 (fallthrough)
branch  1 taken 0
       14: 8445-block 39
    %%%%%: 8445-block 40
      14*: 8446:    ImGuiWindow* display_front_window = window ? window->RootWindowDockTree : NULL;
       14: 8446-block 41
branch  0 taken 14 (fallthrough)
branch  1 taken 0
       14: 8446-block 42
    %%%%%: 8446-block 43
      14*: 8447:    ImGuiDockNode* dock_node = window ? window->DockNode : NULL;
       14: 8447-block 44
branch  0 taken 14 (fallthrough)
branch  1 taken 0
       14: 8447-block 45
    %%%%%: 8447-block 46
      14*: 8448:    bool active_id_window_is_dock_node_host = (g.ActiveIdWindow && dock_node && dock_node->HostWindow == g.ActiveIdWindow);
       14: 8448-block 47
branch  0 taken 3 (fallthrough)
branch  1 taken 11
        3: 8448-block 48
branch  2 taken 3 (fallthrough)
branch  3 taken 0
        3: 8448-block 49
branch  4 taken 0 (fallthrough)
branch  5 taken 3
    %%%%%: 8448-block 50
       14: 8448-block 51
        -: 8449:
        -: 8450:    // Steal active widgets. Some of the cases it triggers includes:
        -: 8451:    // - Focus a window while an InputText in another window is active, if focus happens before the old InputText can run.
        -: 8452:    // - When using Nav to activate menu items (due to timing of activating on press->new window appears->losing ActiveId)
        -: 8453:    // - Using dock host items (tab, collapse button) can trigger this before we redirect the ActiveIdWindow toward the child window.
       14: 8454:    if (g.ActiveId != 0 && g.ActiveIdWindow && g.ActiveIdWindow->RootWindow != focus_front_window)
       14: 8454-block 52
branch  0 taken 3 (fallthrough)
branch  1 taken 11
        3: 8454-block 53
branch  2 taken 3 (fallthrough)
branch  3 taken 0
        3: 8454-block 54
branch  4 taken 0 (fallthrough)
branch  5 taken 3
    #####: 8455:        if (!g.ActiveIdNoClearOnFocusLoss && !active_id_window_is_dock_node_host)
    %%%%%: 8455-block 55
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8455-block 56
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 8456:            ClearActiveID();
    %%%%%: 8456-block 57
call    0 never executed
        -: 8457:
        -: 8458:    // Passing NULL allow to disable keyboard focus
       14: 8459:    if (!window)
       14: 8459-block 58
branch  0 taken 0 (fallthrough)
branch  1 taken 14
    #####: 8460:        return;
    %%%%%: 8460-block 59
       14: 8461:    window->LastFrameJustFocused = g.FrameCount;
        -: 8462:
        -: 8463:    // Select in dock node
        -: 8464:    // For #2304 we avoid applying focus immediately before the tabbar is visible.
        -: 8465:    //if (dock_node && dock_node->TabBar)
        -: 8466:    //    dock_node->TabBar->SelectedTabId = dock_node->TabBar->NextSelectedTabId = window->TabId;
        -: 8467:
        -: 8468:    // Bring to front
       14: 8469:    BringWindowToFocusFront(focus_front_window);
       14: 8469-block 60
call    0 returned 14
       14: 8470:    if (((window->Flags | focus_front_window->Flags | display_front_window->Flags) & ImGuiWindowFlags_NoBringToFrontOnFocus) == 0)
branch  0 taken 2 (fallthrough)
branch  1 taken 12
        2: 8471:        BringWindowToDisplayFront(display_front_window);
        2: 8471-block 62
call    0 returned 2
        -: 8472:}
        -: 8473:
function _ZN5ImGui26FocusTopMostWindowUnderOneEP11ImGuiWindowS1_P13ImGuiViewporti called 0 returned 0% blocks executed 0%
    #####: 8474:void ImGui::FocusTopMostWindowUnderOne(ImGuiWindow* under_this_window, ImGuiWindow* ignore_window, ImGuiViewport* filter_viewport, ImGuiFocusRequestFlags flags)
        -: 8475:{
    #####: 8476:    ImGuiContext& g = *GImGui;
    #####: 8477:    int start_idx = g.WindowsFocusOrder.Size - 1;
    #####: 8478:    if (under_this_window != NULL)
    %%%%%: 8478-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 8479:    {
        -: 8480:        // Aim at root window behind us, if we are in a child window that's our own root (see #4640)
    #####: 8481:        int offset = -1;
    #####: 8482:        while (under_this_window->Flags & ImGuiWindowFlags_ChildWindow)
    %%%%%: 8482-block 3
    %%%%%: 8482-block 5
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 8483:        {
    #####: 8484:            under_this_window = under_this_window->ParentWindow;
    #####: 8485:            offset = 0;
    %%%%%: 8485-block 4
        -: 8486:        }
    #####: 8487:        start_idx = FindWindowFocusIndex(under_this_window) + offset;
    %%%%%: 8487-block 6
call    0 never executed
        -: 8488:    }
    #####: 8489:    for (int i = start_idx; i >= 0; i--)
    %%%%%: 8489-block 8
    %%%%%: 8489-block 19
    %%%%%: 8489-block 20
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 8490:    {
        -: 8491:        // We may later decide to test for different NoXXXInputs based on the active navigation input (mouse vs nav) but that may feel more confusing to the user.
    #####: 8492:        ImGuiWindow* window = g.WindowsFocusOrder[i];
    %%%%%: 8492-block 9
call    0 never executed
    #####: 8493:        if (window == ignore_window || !window->WasActive)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8493-block 11
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 8494:            continue;
    %%%%%: 8494-block 12
    #####: 8495:        if (filter_viewport != NULL && window->Viewport != filter_viewport)
    %%%%%: 8495-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8495-block 14
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 8496:            continue;
    %%%%%: 8496-block 15
    #####: 8497:        if ((window->Flags & (ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs)) != (ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs))
    %%%%%: 8497-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 8498:        {
        -: 8499:            // FIXME-DOCK: When ImGuiFocusRequestFlags_RestoreFocusedChild is set...
        -: 8500:            // This is failing (lagging by one frame) for docked windows.
        -: 8501:            // If A and B are docked into window and B disappear, at the NewFrame() call site window->NavLastChildNavWindow will still point to B.
        -: 8502:            // We might leverage the tab order implicitly stored in window->DockNodeAsHost->TabBar (essentially the 'most_recently_selected_tab' code in tab bar will do that but on next update)
        -: 8503:            // to tell which is the "previous" window. Or we may leverage 'LastFrameFocused/LastFrameJustFocused' and have this function handle child window itself?
    #####: 8504:            FocusWindow(window, flags);
    %%%%%: 8504-block 17
call    0 never executed
    #####: 8505:            return;
        -: 8506:        }
        -: 8507:    }
    #####: 8508:    FocusWindow(NULL, flags);
    %%%%%: 8508-block 21
call    0 never executed
        -: 8509:}
        -: 8510:
        -: 8511:// Important: this alone doesn't alter current ImDrawList state. This is called by PushFont/PopFont only.
function _ZN5ImGui14SetCurrentFontEP6ImFont called 80775 returned 100% blocks executed 83%
    80775: 8512:void ImGui::SetCurrentFont(ImFont* font)
        -: 8513:{
    80775: 8514:    ImGuiContext& g = *GImGui;
   80775*: 8515:    IM_ASSERT(font && font->IsLoaded());    // Font Atlas not created. Did you call io.Fonts->GetTexDataAsRGBA32 / GetTexDataAsAlpha8 ?
    80775: 8515-block 2
branch  0 taken 80775 (fallthrough)
branch  1 taken 0
    80775: 8515-block 3
call    2 returned 80775
branch  3 taken 80775 (fallthrough)
branch  4 taken 0
    80775: 8515-block 5
    %%%%%: 8515-block 6
call    5 never executed
   80775*: 8516:    IM_ASSERT(font->Scale > 0.0f);
    80775: 8516-block 7
branch  0 taken 0 (fallthrough)
branch  1 taken 80775
    %%%%%: 8516-block 8
call    2 never executed
    80775: 8517:    g.Font = font;
    80775: 8518:    g.FontBaseSize = ImMax(1.0f, g.IO.FontGlobalScale * g.Font->FontSize * g.Font->Scale);
    80775: 8518-block 9
call    0 returned 80775
    80775: 8519:    g.FontSize = g.CurrentWindow ? g.CurrentWindow->CalcFontSize() : 0.0f;
branch  0 taken 79698 (fallthrough)
branch  1 taken 1077
    79698: 8519-block 11
call    2 returned 79698
     1077: 8519-block 12
    80775: 8520:    g.FontScale = g.FontSize / g.Font->FontSize;
        -: 8521:
    80775: 8522:    ImFontAtlas* atlas = g.Font->ContainerAtlas;
    80775: 8523:    g.DrawListSharedData.TexUvWhitePixel = atlas->TexUvWhitePixel;
    80775: 8524:    g.DrawListSharedData.TexUvLines = atlas->TexUvLines;
    80775: 8525:    g.DrawListSharedData.Font = g.Font;
    80775: 8526:    g.DrawListSharedData.FontSize = g.FontSize;
    80775: 8527:    g.DrawListSharedData.FontScale = g.FontScale;
    80775: 8528:}
        -: 8529:
        -: 8530:// Use ImDrawList::_SetTextureID(), making our shared g.FontStack[] authorative against window-local ImDrawList.
        -: 8531:// - Whereas ImDrawList::PushTextureID()/PopTextureID() is not to be used across Begin() calls.
        -: 8532:// - Note that we don't propagate current texture id when e.g. Begin()-ing into a new window, we never really did...
        -: 8533://   - Some code paths never really fully worked with multiple atlas textures.
        -: 8534://   - The right-ish solution may be to remove _SetTextureID() and make AddText/RenderText lazily call PushTextureID()/PopTextureID()
        -: 8535://     the same way AddImage() does, but then all other primitives would also need to? I don't think we should tackle this problem
        -: 8536://     because we have a concrete need and a test bed for multiple atlas textures.
function _ZN5ImGui8PushFontEP6ImFont called 39849 returned 100% blocks executed 71%
    39849: 8537:void ImGui::PushFont(ImFont* font)
        -: 8538:{
    39849: 8539:    ImGuiContext& g = *GImGui;
    39849: 8540:    if (font == NULL)
    39849: 8540-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 39849
    #####: 8541:        font = GetDefaultFont();
    %%%%%: 8541-block 3
call    0 never executed
    39849: 8542:    g.FontStack.push_back(font);
    39849: 8542-block 5
call    0 returned 39849
    39849: 8543:    SetCurrentFont(font);
call    0 returned 39849
    39849: 8544:    g.CurrentWindow->DrawList->_SetTextureID(font->ContainerAtlas->TexID);
call    0 returned 39849
    39849: 8545:}
        -: 8546:
function _ZN5ImGui7PopFontEv called 39849 returned 100% blocks executed 71%
    39849: 8547:void  ImGui::PopFont()
        -: 8548:{
    39849: 8549:    ImGuiContext& g = *GImGui;
    39849: 8550:    if (g.FontStack.Size <= 0)
    39849: 8550-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 39849
        -: 8551:    {
    #####: 8552:        IM_ASSERT_USER_ERROR(0, "Calling PopFont() too many times!");
    %%%%%: 8552-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 8552-block 5
call    3 never executed
    #####: 8553:        return;
    %%%%%: 8553-block 6
        -: 8554:    }
    39849: 8555:    g.FontStack.pop_back();
    39849: 8555-block 7
call    0 returned 39849
    39849: 8556:    ImFont* font = g.FontStack.Size == 0 ? GetDefaultFont() : g.FontStack.back();
branch  0 taken 8616 (fallthrough)
branch  1 taken 31233
     8616: 8556-block 9
call    2 returned 8616
    31233: 8556-block 11
call    3 returned 31233
    39849: 8557:    SetCurrentFont(font);
    39849: 8557-block 13
call    0 returned 39849
    39849: 8558:    g.CurrentWindow->DrawList->_SetTextureID(font->ContainerAtlas->TexID);
call    0 returned 39849
        -: 8559:}
        -: 8560:
function _ZN5ImGui12PushItemFlagEib called 0 returned 0% blocks executed 0%
    #####: 8561:void ImGui::PushItemFlag(ImGuiItemFlags option, bool enabled)
        -: 8562:{
    #####: 8563:    ImGuiContext& g = *GImGui;
    #####: 8564:    ImGuiItemFlags item_flags = g.CurrentItemFlags;
    #####: 8565:    IM_ASSERT(item_flags == g.ItemFlagsStack.back());
    %%%%%: 8565-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 8565-block 4
call    3 never executed
    #####: 8566:    if (enabled)
    %%%%%: 8566-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 8567:        item_flags |= option;
    %%%%%: 8567-block 6
        -: 8568:    else
    #####: 8569:        item_flags &= ~option;
    %%%%%: 8569-block 7
    #####: 8570:    g.CurrentItemFlags = item_flags;
    #####: 8571:    g.ItemFlagsStack.push_back(item_flags);
    %%%%%: 8571-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 8572:}
    %%%%%: 8572-block 9
        -: 8573:
function _ZN5ImGui11PopItemFlagEv called 0 returned 0% blocks executed 0%
    #####: 8574:void ImGui::PopItemFlag()
        -: 8575:{
    #####: 8576:    ImGuiContext& g = *GImGui;
    #####: 8577:    if (g.ItemFlagsStack.Size <= 1)
    %%%%%: 8577-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 8578:    {
    #####: 8579:        IM_ASSERT_USER_ERROR(0, "Calling PopItemFlag() too many times!");
    %%%%%: 8579-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 8579-block 5
call    3 never executed
    #####: 8580:        return;
    %%%%%: 8580-block 6
        -: 8581:    }
    #####: 8582:    g.ItemFlagsStack.pop_back();
    %%%%%: 8582-block 7
call    0 never executed
    #####: 8583:    g.CurrentItemFlags = g.ItemFlagsStack.back();
call    0 never executed
        -: 8584:}
        -: 8585:
        -: 8586:// BeginDisabled()/EndDisabled()
        -: 8587:// - Those can be nested but it cannot be used to enable an already disabled section (a single BeginDisabled(true) in the stack is enough to keep everything disabled)
        -: 8588:// - Visually this is currently altering alpha, but it is expected that in a future styling system this would work differently.
        -: 8589:// - Feedback welcome at https://github.com/ocornut/imgui/issues/211
        -: 8590:// - BeginDisabled(false)/EndDisabled() essentially does nothing but is provided to facilitate use of boolean expressions.
        -: 8591://   (as a micro-optimization: if you have tens of thousands of BeginDisabled(false)/EndDisabled() pairs, you might want to reformulate your code to avoid making those calls)
        -: 8592:// - Note: mixing up BeginDisabled() and PushItemFlag(ImGuiItemFlags_Disabled) is currently NOT SUPPORTED.
function _ZN5ImGui13BeginDisabledEb called 0 returned 0% blocks executed 0%
    #####: 8593:void ImGui::BeginDisabled(bool disabled)
        -: 8594:{
    #####: 8595:    ImGuiContext& g = *GImGui;
    #####: 8596:    bool was_disabled = (g.CurrentItemFlags & ImGuiItemFlags_Disabled) != 0;
    #####: 8597:    if (!was_disabled && disabled)
    %%%%%: 8597-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8597-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 8598:    {
    #####: 8599:        g.DisabledAlphaBackup = g.Style.Alpha;
    #####: 8600:        g.Style.Alpha *= g.Style.DisabledAlpha; // PushStyleVar(ImGuiStyleVar_Alpha, g.Style.Alpha * g.Style.DisabledAlpha);
    %%%%%: 8600-block 4
        -: 8601:    }
    #####: 8602:    if (was_disabled || disabled)
    %%%%%: 8602-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8602-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 8603:        g.CurrentItemFlags |= ImGuiItemFlags_Disabled;
    %%%%%: 8603-block 7
    #####: 8604:    g.ItemFlagsStack.push_back(g.CurrentItemFlags); // FIXME-OPT: can we simply skip this and use DisabledStackSize?
    %%%%%: 8604-block 8
call    0 never executed
    #####: 8605:    g.DisabledStackSize++;
    #####: 8606:}
        -: 8607:
function _ZN5ImGui11EndDisabledEv called 0 returned 0% blocks executed 0%
    #####: 8608:void ImGui::EndDisabled()
        -: 8609:{
    #####: 8610:    ImGuiContext& g = *GImGui;
    #####: 8611:    if (g.DisabledStackSize <= 0)
    %%%%%: 8611-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 8612:    {
    #####: 8613:        IM_ASSERT_USER_ERROR(0, "Calling EndDisabled() too many times!");
    %%%%%: 8613-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 8613-block 5
call    3 never executed
    #####: 8614:        return;
    %%%%%: 8614-block 6
        -: 8615:    }
    #####: 8616:    g.DisabledStackSize--;
    #####: 8617:    bool was_disabled = (g.CurrentItemFlags & ImGuiItemFlags_Disabled) != 0;
        -: 8618:    //PopItemFlag();
    #####: 8619:    g.ItemFlagsStack.pop_back();
    %%%%%: 8619-block 7
call    0 never executed
    #####: 8620:    g.CurrentItemFlags = g.ItemFlagsStack.back();
call    0 never executed
    #####: 8621:    if (was_disabled && (g.CurrentItemFlags & ImGuiItemFlags_Disabled) == 0)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8621-block 10
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 8622:        g.Style.Alpha = g.DisabledAlphaBackup; //PopStyleVar();
    %%%%%: 8622-block 11
        -: 8623:}
        -: 8624:
        -: 8625:// Could have been called BeginDisabledDisable() but it didn't want to be award nominated for most awkward function name.
        -: 8626:// Ideally we would use a shared e.g. BeginDisabled()->BeginDisabledEx() but earlier needs to be optimal.
        -: 8627:// The whole code for this is awkward, will reevaluate if we find a way to implement SetNextItemDisabled().
function _ZN5ImGui29BeginDisabledOverrideReenableEv called 0 returned 0% blocks executed 0%
    #####: 8628:void ImGui::BeginDisabledOverrideReenable()
        -: 8629:{
    #####: 8630:    ImGuiContext& g = *GImGui;
    #####: 8631:    IM_ASSERT(g.CurrentItemFlags & ImGuiItemFlags_Disabled);
    %%%%%: 8631-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8631-block 3
call    2 never executed
    #####: 8632:    g.Style.Alpha = g.DisabledAlphaBackup;
    #####: 8633:    g.CurrentItemFlags &= ~ImGuiItemFlags_Disabled;
    #####: 8634:    g.ItemFlagsStack.push_back(g.CurrentItemFlags);
    %%%%%: 8634-block 4
call    0 never executed
    #####: 8635:    g.DisabledStackSize++;
    #####: 8636:}
        -: 8637:
function _ZN5ImGui27EndDisabledOverrideReenableEv called 0 returned 0% blocks executed 0%
    #####: 8638:void ImGui::EndDisabledOverrideReenable()
        -: 8639:{
    #####: 8640:    ImGuiContext& g = *GImGui;
    #####: 8641:    g.DisabledStackSize--;
    #####: 8642:    IM_ASSERT(g.DisabledStackSize > 0);
    %%%%%: 8642-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8642-block 3
call    2 never executed
    #####: 8643:    g.ItemFlagsStack.pop_back();
    %%%%%: 8643-block 4
call    0 never executed
    #####: 8644:    g.CurrentItemFlags = g.ItemFlagsStack.back();
call    0 never executed
    #####: 8645:    g.Style.Alpha = g.DisabledAlphaBackup * g.Style.DisabledAlpha;
    #####: 8646:}
        -: 8647:
function _ZN5ImGui15PushTextWrapPosEf called 0 returned 0% blocks executed 0%
    #####: 8648:void ImGui::PushTextWrapPos(float wrap_pos_x)
        -: 8649:{
    #####: 8650:    ImGuiContext& g = *GImGui;
    #####: 8651:    ImGuiWindow* window = g.CurrentWindow;
    #####: 8652:    window->DC.TextWrapPosStack.push_back(window->DC.TextWrapPos);
    %%%%%: 8652-block 2
call    0 never executed
    #####: 8653:    window->DC.TextWrapPos = wrap_pos_x;
    #####: 8654:}
        -: 8655:
function _ZN5ImGui14PopTextWrapPosEv called 0 returned 0% blocks executed 0%
    #####: 8656:void ImGui::PopTextWrapPos()
        -: 8657:{
    #####: 8658:    ImGuiContext& g = *GImGui;
    #####: 8659:    ImGuiWindow* window = g.CurrentWindow;
    #####: 8660:    if (window->DC.TextWrapPosStack.Size <= 0)
    %%%%%: 8660-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 8661:    {
    #####: 8662:        IM_ASSERT_USER_ERROR(0, "Calling PopTextWrapPos() too many times!");
    %%%%%: 8662-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 8662-block 5
call    3 never executed
    #####: 8663:        return;
    %%%%%: 8663-block 6
        -: 8664:    }
    #####: 8665:    window->DC.TextWrapPos = window->DC.TextWrapPosStack.back();
    %%%%%: 8665-block 7
call    0 never executed
    #####: 8666:    window->DC.TextWrapPosStack.pop_back();
call    0 never executed
        -: 8667:}
        -: 8668:
function _ZL21GetCombinedRootWindowP11ImGuiWindowbb called 5379 returned 100% blocks executed 100%
     5379: 8669:static ImGuiWindow* GetCombinedRootWindow(ImGuiWindow* window, bool popup_hierarchy, bool dock_hierarchy)
        -: 8670:{
     5379: 8671:    ImGuiWindow* last_window = NULL;
    13141: 8672:    while (last_window != window)
     5379: 8672-block 2
    13141: 8672-block 7
branch  0 taken 7762
branch  1 taken 5379 (fallthrough)
        -: 8673:    {
     7762: 8674:        last_window = window;
     7762: 8675:        window = window->RootWindow;
     7762: 8676:        if (popup_hierarchy)
     7762: 8676-block 3
branch  0 taken 5612 (fallthrough)
branch  1 taken 2150
     5612: 8677:            window = window->RootWindowPopupTree;
     5612: 8677-block 4
     7762: 8678:		if (dock_hierarchy)
     7762: 8678-block 5
branch  0 taken 2150 (fallthrough)
branch  1 taken 5612
     2150: 8679:			window = window->RootWindowDockTree;
     2150: 8679-block 6
        -: 8680:	}
     5379: 8681:    return window;
     5379: 8681-block 8
        -: 8682:}
        -: 8683:
function _ZN5ImGui15IsWindowChildOfEP11ImGuiWindowS1_bb called 3227 returned 100% blocks executed 83%
     3227: 8684:bool ImGui::IsWindowChildOf(ImGuiWindow* window, ImGuiWindow* potential_parent, bool popup_hierarchy, bool dock_hierarchy)
        -: 8685:{
     3227: 8686:    ImGuiWindow* window_root = GetCombinedRootWindow(window, popup_hierarchy, dock_hierarchy);
     3227: 8686-block 2
call    0 returned 3227
     3227: 8687:    if (window_root == potential_parent)
branch  0 taken 0 (fallthrough)
branch  1 taken 3227
    #####: 8688:        return true;
    %%%%%: 8688-block 4
     6264: 8689:    while (window != NULL)
     3227: 8689-block 5
     6264: 8689-block 11
branch  0 taken 6264
branch  1 taken 0 (fallthrough)
        -: 8690:    {
     6264: 8691:        if (window == potential_parent)
     6264: 8691-block 6
branch  0 taken 1075 (fallthrough)
branch  1 taken 5189
     1075: 8692:            return true;
     1075: 8692-block 7
     5189: 8693:        if (window == window_root) // end of chain
     5189: 8693-block 8
branch  0 taken 2152 (fallthrough)
branch  1 taken 3037
     2152: 8694:            return false;
     2152: 8694-block 9
     3037: 8695:        window = window->ParentWindow;
     3037: 8695-block 10
        -: 8696:    }
    #####: 8697:    return false;
    %%%%%: 8697-block 12
        -: 8698:}
        -: 8699:
function _ZN5ImGui26IsWindowWithinBeginStackOfEP11ImGuiWindowS1_ called 0 returned 0% blocks executed 0%
    #####: 8700:bool ImGui::IsWindowWithinBeginStackOf(ImGuiWindow* window, ImGuiWindow* potential_parent)
        -: 8701:{
    #####: 8702:    if (window->RootWindow == potential_parent)
    %%%%%: 8702-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 8703:        return true;
    %%%%%: 8703-block 3
    #####: 8704:    while (window != NULL)
    %%%%%: 8704-block 4
    %%%%%: 8704-block 8
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 8705:    {
    #####: 8706:        if (window == potential_parent)
    %%%%%: 8706-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 8707:            return true;
    %%%%%: 8707-block 6
    #####: 8708:        window = window->ParentWindowInBeginStack;
    %%%%%: 8708-block 7
        -: 8709:    }
    #####: 8710:    return false;
    %%%%%: 8710-block 9
        -: 8711:}
        -: 8712:
function _ZN5ImGui13IsWindowAboveEP11ImGuiWindowS1_ called 0 returned 0% blocks executed 0%
    #####: 8713:bool ImGui::IsWindowAbove(ImGuiWindow* potential_above, ImGuiWindow* potential_below)
        -: 8714:{
    #####: 8715:    ImGuiContext& g = *GImGui;
        -: 8716:
        -: 8717:    // It would be saner to ensure that display layer is always reflected in the g.Windows[] order, which would likely requires altering all manipulations of that array
    #####: 8718:    const int display_layer_delta = GetWindowDisplayLayer(potential_above) - GetWindowDisplayLayer(potential_below);
    %%%%%: 8718-block 2
call    0 never executed
call    1 never executed
    #####: 8719:    if (display_layer_delta != 0)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 8720:        return display_layer_delta > 0;
    %%%%%: 8720-block 5
        -: 8721:
    #####: 8722:    for (int i = g.Windows.Size - 1; i >= 0; i--)
    %%%%%: 8722-block 6
    %%%%%: 8722-block 12
    %%%%%: 8722-block 13
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 8723:    {
    #####: 8724:        ImGuiWindow* candidate_window = g.Windows[i];
    %%%%%: 8724-block 7
call    0 never executed
    #####: 8725:        if (candidate_window == potential_above)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 8726:            return true;
    %%%%%: 8726-block 9
    #####: 8727:        if (candidate_window == potential_below)
    %%%%%: 8727-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 8728:            return false;
    %%%%%: 8728-block 11
        -: 8729:    }
    #####: 8730:    return false;
    %%%%%: 8730-block 14
        -: 8731:}
        -: 8732:
        -: 8733:// Is current window hovered and hoverable (e.g. not blocked by a popup/modal)? See ImGuiHoveredFlags_ for options.
        -: 8734:// IMPORTANT: If you are trying to check whether your mouse should be dispatched to Dear ImGui or to your underlying app,
        -: 8735:// you should not use this function! Use the 'io.WantCaptureMouse' boolean for that!
        -: 8736:// Refer to FAQ entry "How can I tell whether to dispatch mouse/keyboard to Dear ImGui or my application?" for details.
function _ZN5ImGui15IsWindowHoveredEi called 3621 returned 100% blocks executed 69%
     3621: 8737:bool ImGui::IsWindowHovered(ImGuiHoveredFlags flags)
        -: 8738:{
     3621: 8739:    ImGuiContext& g = *GImGui;
    3621*: 8740:    IM_ASSERT_USER_ERROR((flags & ~ImGuiHoveredFlags_AllowedMaskForIsWindowHovered) == 0, "Invalid flags for IsWindowHovered()!");
     3621: 8740-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 3621
    %%%%%: 8740-block 3
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 8740-block 5
     3621: 8740-block 6
     3621: 8740-block 7
branch  5 taken 0 (fallthrough)
branch  6 taken 3621
    %%%%%: 8740-block 8
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 8740-block 9
call    9 never executed
        -: 8741:
     3621: 8742:    ImGuiWindow* ref_window = g.HoveredWindow;
     3621: 8743:    ImGuiWindow* cur_window = g.CurrentWindow;
     3621: 8744:    if (ref_window == NULL)
     3621: 8744-block 10
branch  0 taken 3 (fallthrough)
branch  1 taken 3618
        3: 8745:        return false;
        3: 8745-block 11
        -: 8746:
     3618: 8747:    if ((flags & ImGuiHoveredFlags_AnyWindow) == 0)
     3618: 8747-block 12
branch  0 taken 3618 (fallthrough)
branch  1 taken 0
        -: 8748:    {
    3618*: 8749:        IM_ASSERT(cur_window); // Not inside a Begin()/End()
     3618: 8749-block 13
branch  0 taken 0 (fallthrough)
branch  1 taken 3618
    %%%%%: 8749-block 14
call    2 never executed
     3618: 8750:        const bool popup_hierarchy = (flags & ImGuiHoveredFlags_NoPopupHierarchy) == 0;
     3618: 8751:        const bool dock_hierarchy = (flags & ImGuiHoveredFlags_DockHierarchy) != 0;
     3618: 8752:        if (flags & ImGuiHoveredFlags_RootWindow)
     3618: 8752-block 15
branch  0 taken 2152 (fallthrough)
branch  1 taken 1466
     2152: 8753:            cur_window = GetCombinedRootWindow(cur_window, popup_hierarchy, dock_hierarchy);
     2152: 8753-block 16
call    0 returned 2152
        -: 8754:
        -: 8755:        bool result;
     3618: 8756:        if (flags & ImGuiHoveredFlags_ChildWindows)
     3618: 8756-block 17
branch  0 taken 2152 (fallthrough)
branch  1 taken 1466
     2152: 8757:            result = IsWindowChildOf(ref_window, cur_window, popup_hierarchy, dock_hierarchy);
     2152: 8757-block 18
call    0 returned 2152
        -: 8758:        else
     1466: 8759:            result = (ref_window == cur_window);
     1466: 8759-block 19
     3618: 8760:        if (!result)
     3618: 8760-block 20
branch  0 taken 2620 (fallthrough)
branch  1 taken 998
     2620: 8761:            return false;
     2620: 8761-block 21
        -: 8762:    }
        -: 8763:
      998: 8764:    if (!IsWindowContentHoverable(ref_window, flags))
      998: 8764-block 22
call    0 returned 998
branch  1 taken 0 (fallthrough)
branch  2 taken 998
    #####: 8765:        return false;
    %%%%%: 8765-block 24
      998: 8766:    if (!(flags & ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))
      998: 8766-block 25
branch  0 taken 998 (fallthrough)
branch  1 taken 0
      998: 8767:        if (g.ActiveId != 0 && !g.ActiveIdAllowOverlap && g.ActiveId != ref_window->MoveId)
      998: 8767-block 26
branch  0 taken 196 (fallthrough)
branch  1 taken 802
      196: 8767-block 27
branch  2 taken 196 (fallthrough)
branch  3 taken 0
      196: 8767-block 28
branch  4 taken 0 (fallthrough)
branch  5 taken 196
    #####: 8768:            return false;
    %%%%%: 8768-block 29
        -: 8769:
        -: 8770:    // When changing hovered window we requires a bit of stationary delay before activating hover timer.
        -: 8771:    // FIXME: We don't support delay other than stationary one for now, other delay would need a way
        -: 8772:    // to fulfill the possibility that multiple IsWindowHovered() with varying flag could return true
        -: 8773:    // for different windows of the hierarchy. Possibly need a Hash(Current+Flags) ==> (Timer) cache.
        -: 8774:    // We can implement this for _Stationary because the data is linked to HoveredWindow rather than CurrentWindow.
      998: 8775:    if (flags & ImGuiHoveredFlags_ForTooltip)
      998: 8775-block 30
branch  0 taken 0 (fallthrough)
branch  1 taken 998
    #####: 8776:        flags = ApplyHoverFlagsForTooltip(flags, g.Style.HoverFlagsForTooltipMouse);
    %%%%%: 8776-block 31
call    0 never executed
     998*: 8777:    if ((flags & ImGuiHoveredFlags_Stationary) != 0 && g.HoverWindowUnlockedStationaryId != ref_window->ID)
      998: 8777-block 32
branch  0 taken 0 (fallthrough)
branch  1 taken 998
    %%%%%: 8777-block 33
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 8778:        return false;
    %%%%%: 8778-block 34
        -: 8779:
      998: 8780:    return true;
      998: 8780-block 35
        -: 8781:}
        -: 8782:
function _ZN5ImGui15IsWindowFocusedEi called 3231 returned 100% blocks executed 58%
     3231: 8783:bool ImGui::IsWindowFocused(ImGuiFocusedFlags flags)
        -: 8784:{
     3231: 8785:    ImGuiContext& g = *GImGui;
     3231: 8786:    ImGuiWindow* ref_window = g.NavWindow;
     3231: 8787:    ImGuiWindow* cur_window = g.CurrentWindow;
        -: 8788:
     3231: 8789:    if (ref_window == NULL)
     3231: 8789-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 3231
    #####: 8790:        return false;
    %%%%%: 8790-block 3
     3231: 8791:    if (flags & ImGuiFocusedFlags_AnyWindow)
     3231: 8791-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 3231
    #####: 8792:        return true;
    %%%%%: 8792-block 5
        -: 8793:
    3231*: 8794:    IM_ASSERT(cur_window); // Not inside a Begin()/End()
     3231: 8794-block 6
branch  0 taken 0 (fallthrough)
branch  1 taken 3231
    %%%%%: 8794-block 7
call    2 never executed
     3231: 8795:    const bool popup_hierarchy = (flags & ImGuiFocusedFlags_NoPopupHierarchy) == 0;
     3231: 8796:    const bool dock_hierarchy = (flags & ImGuiFocusedFlags_DockHierarchy) != 0;
     3231: 8797:    if (flags & ImGuiHoveredFlags_RootWindow)
     3231: 8797-block 8
branch  0 taken 0 (fallthrough)
branch  1 taken 3231
    #####: 8798:        cur_window = GetCombinedRootWindow(cur_window, popup_hierarchy, dock_hierarchy);
    %%%%%: 8798-block 9
call    0 never executed
        -: 8799:
     3231: 8800:    if (flags & ImGuiHoveredFlags_ChildWindows)
     3231: 8800-block 10
branch  0 taken 0 (fallthrough)
branch  1 taken 3231
    #####: 8801:        return IsWindowChildOf(ref_window, cur_window, popup_hierarchy, dock_hierarchy);
    %%%%%: 8801-block 11
call    0 never executed
        -: 8802:    else
     3231: 8803:        return (ref_window == cur_window);
     3231: 8803-block 12
        -: 8804:}
        -: 8805:
function _ZN5ImGui15GetWindowDockIDEv called 0 returned 0% blocks executed 0%
    #####: 8806:ImGuiID ImGui::GetWindowDockID()
        -: 8807:{
    #####: 8808:    ImGuiContext& g = *GImGui;
    #####: 8809:    return g.CurrentWindow->DockId;
    %%%%%: 8809-block 2
        -: 8810:}
        -: 8811:
function _ZN5ImGui14IsWindowDockedEv called 0 returned 0% blocks executed 0%
    #####: 8812:bool ImGui::IsWindowDocked()
        -: 8813:{
    #####: 8814:    ImGuiContext& g = *GImGui;
    #####: 8815:    return g.CurrentWindow->DockIsActive;
    %%%%%: 8815-block 2
        -: 8816:}
        -: 8817:
        -: 8818:// Can we focus this window with CTRL+TAB (or PadMenu + PadFocusPrev/PadFocusNext)
        -: 8819:// Note that NoNavFocus makes the window not reachable with CTRL+TAB but it can still be focused with mouse or programmatically.
        -: 8820:// If you want a window to never be focused, you may use the e.g. NoInputs flag.
function _ZN5ImGui20IsWindowNavFocusableEP11ImGuiWindow called 0 returned 0% blocks executed 0%
    #####: 8821:bool ImGui::IsWindowNavFocusable(ImGuiWindow* window)
        -: 8822:{
    #####: 8823:    return window->WasActive && window == window->RootWindow && !(window->Flags & ImGuiWindowFlags_NoNavFocus);
    %%%%%: 8823-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8823-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 8823-block 4
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 8823-block 5
    %%%%%: 8823-block 6
    %%%%%: 8823-block 7
        -: 8824:}
        -: 8825:
function _ZN5ImGui14GetWindowWidthEv called 1077 returned 100% blocks executed 100%
     1077: 8826:float ImGui::GetWindowWidth()
        -: 8827:{
     1077: 8828:    ImGuiWindow* window = GImGui->CurrentWindow;
     1077: 8829:    return window->Size.x;
     1077: 8829-block 2
        -: 8830:}
        -: 8831:
function _ZN5ImGui15GetWindowHeightEv called 1077 returned 100% blocks executed 100%
     1077: 8832:float ImGui::GetWindowHeight()
        -: 8833:{
     1077: 8834:    ImGuiWindow* window = GImGui->CurrentWindow;
     1077: 8835:    return window->Size.y;
     1077: 8835-block 2
        -: 8836:}
        -: 8837:
function _ZN5ImGui12GetWindowPosEv called 2154 returned 100% blocks executed 100%
     2154: 8838:ImVec2 ImGui::GetWindowPos()
        -: 8839:{
     2154: 8840:    ImGuiContext& g = *GImGui;
     2154: 8841:    ImGuiWindow* window = g.CurrentWindow;
     2154: 8842:    return window->Pos;
     2154: 8842-block 2
        -: 8843:}
        -: 8844:
function _ZN5ImGui12SetWindowPosEP11ImGuiWindowRK6ImVec2i called 8616 returned 100% blocks executed 90%
     8616: 8845:void ImGui::SetWindowPos(ImGuiWindow* window, const ImVec2& pos, ImGuiCond cond)
        -: 8846:{
        -: 8847:    // Test condition (NB: bit 0 is always true) and clear flags for next time
     8616: 8848:    if (cond && (window->SetWindowPosAllowFlags & cond) == 0)
     8616: 8848-block 2
branch  0 taken 8616 (fallthrough)
branch  1 taken 0
     8616: 8848-block 3
branch  2 taken 0 (fallthrough)
branch  3 taken 8616
    8601*: 8849:        return;
    %%%%%: 8849-block 4
     8601: 8849-block 21
        -: 8850:
    8616*: 8851:    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
     8616: 8851-block 5
branch  0 taken 8616 (fallthrough)
branch  1 taken 0
     8616: 8851-block 6
call    2 returned 8616
branch  3 taken 0 (fallthrough)
branch  4 taken 8616
    %%%%%: 8851-block 8
call    5 never executed
     8616: 8852:    window->SetWindowPosAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);
     8616: 8853:    window->SetWindowPosVal = ImVec2(FLT_MAX, FLT_MAX);
     8616: 8853-block 9
call    0 returned 8616
        -: 8854:
        -: 8855:    // Set
     8616: 8856:    const ImVec2 old_pos = window->Pos;
     8616: 8857:    window->Pos = ImTrunc(pos);
call    0 returned 8616
     8616: 8858:    ImVec2 offset = window->Pos - old_pos;
call    0 returned 8616
     8616: 8859:    if (offset.x == 0.0f && offset.y == 0.0f)
branch  0 taken 8606 (fallthrough)
branch  1 taken 10
     8606: 8859-block 13
branch  2 taken 8601 (fallthrough)
branch  3 taken 5
     8601: 8860:        return;
     8601: 8860-block 14
       15: 8861:    MarkIniSettingsDirty(window);
       15: 8861-block 15
call    0 returned 15
        -: 8862:    // FIXME: share code with TranslateWindow(), need to confirm whether the 3 rect modified by TranslateWindow() are desirable here.
       15: 8863:    window->DC.CursorPos += offset;         // As we happen to move the window while it is being appended to (which is a bad idea - will smear) let's at least offset the cursor
call    0 returned 15
       15: 8864:    window->DC.CursorMaxPos += offset;      // And more importantly we need to offset CursorMaxPos/CursorStartPos this so ContentSize calculation doesn't get affected.
call    0 returned 15
       15: 8865:    window->DC.IdealMaxPos += offset;
call    0 returned 15
       15: 8866:    window->DC.CursorStartPos += offset;
call    0 returned 15
        -: 8867:}
        -: 8868:
function _ZN5ImGui12SetWindowPosERK6ImVec2i called 0 returned 0% blocks executed 0%
    #####: 8869:void ImGui::SetWindowPos(const ImVec2& pos, ImGuiCond cond)
        -: 8870:{
    #####: 8871:    ImGuiWindow* window = GetCurrentWindowRead();
    %%%%%: 8871-block 2
call    0 never executed
    #####: 8872:    SetWindowPos(window, pos, cond);
call    0 never executed
    #####: 8873:}
        -: 8874:
function _ZN5ImGui12SetWindowPosEPKcRK6ImVec2i called 0 returned 0% blocks executed 0%
    #####: 8875:void ImGui::SetWindowPos(const char* name, const ImVec2& pos, ImGuiCond cond)
        -: 8876:{
    #####: 8877:    if (ImGuiWindow* window = FindWindowByName(name))
    %%%%%: 8877-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 8878:        SetWindowPos(window, pos, cond);
    %%%%%: 8878-block 4
call    0 never executed
    #####: 8879:}
        -: 8880:
function _ZN5ImGui13GetWindowSizeEv called 1077 returned 100% blocks executed 100%
     1077: 8881:ImVec2 ImGui::GetWindowSize()
        -: 8882:{
     1077: 8883:    ImGuiWindow* window = GetCurrentWindowRead();
     1077: 8883-block 2
call    0 returned 1077
     1077: 8884:    return window->Size;
        -: 8885:}
        -: 8886:
function _ZN5ImGui13SetWindowSizeEP11ImGuiWindowRK6ImVec2i called 17232 returned 100% blocks executed 97%
    17232: 8887:void ImGui::SetWindowSize(ImGuiWindow* window, const ImVec2& size, ImGuiCond cond)
        -: 8888:{
        -: 8889:    // Test condition (NB: bit 0 is always true) and clear flags for next time
    17232: 8890:    if (cond && (window->SetWindowSizeAllowFlags & cond) == 0)
    17232: 8890-block 2
branch  0 taken 17232 (fallthrough)
branch  1 taken 0
    17232: 8890-block 3
branch  2 taken 2154 (fallthrough)
branch  3 taken 15078
     2154: 8891:        return;
     2154: 8891-block 4
        -: 8892:
   15078*: 8893:    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
    15078: 8893-block 5
branch  0 taken 15078 (fallthrough)
branch  1 taken 0
    15078: 8893-block 6
call    2 returned 15078
branch  3 taken 0 (fallthrough)
branch  4 taken 15078
    %%%%%: 8893-block 8
call    5 never executed
    15078: 8894:    window->SetWindowSizeAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);
        -: 8895:
        -: 8896:    // Enable auto-fit (not done in BeginChild() path unless appearing or combined with ImGuiChildFlags_AlwaysAutoResize)
    15078: 8897:    if ((window->Flags & ImGuiWindowFlags_ChildWindow) == 0 || window->Appearing || (window->ChildFlags & ImGuiChildFlags_AlwaysAutoResize) != 0)
    15078: 8897-block 9
branch  0 taken 12924 (fallthrough)
branch  1 taken 2154
    12924: 8897-block 10
branch  2 taken 12912 (fallthrough)
branch  3 taken 12
    12912: 8897-block 11
branch  4 taken 0 (fallthrough)
branch  5 taken 12912
     2166: 8898:        window->AutoFitFramesX = (size.x <= 0.0f) ? 2 : 0;
     2166: 8898-block 12
branch  0 taken 5 (fallthrough)
branch  1 taken 2161
        5: 8898-block 13
     2161: 8898-block 14
     2166: 8898-block 15
    15078: 8899:    if ((window->Flags & ImGuiWindowFlags_ChildWindow) == 0 || window->Appearing || (window->ChildFlags & ImGuiChildFlags_AlwaysAutoResize) != 0)
    15078: 8899-block 16
branch  0 taken 12924 (fallthrough)
branch  1 taken 2154
    12924: 8899-block 17
branch  2 taken 12912 (fallthrough)
branch  3 taken 12
    12912: 8899-block 18
branch  4 taken 0 (fallthrough)
branch  5 taken 12912
     2166: 8900:        window->AutoFitFramesY = (size.y <= 0.0f) ? 2 : 0;
     2166: 8900-block 19
branch  0 taken 2 (fallthrough)
branch  1 taken 2164
        2: 8900-block 20
     2164: 8900-block 21
     2166: 8900-block 22
        -: 8901:
        -: 8902:    // Set
    15078: 8903:    ImVec2 old_size = window->SizeFull;
    15078: 8904:    if (size.x <= 0.0f)
    15078: 8904-block 23
branch  0 taken 5 (fallthrough)
branch  1 taken 15073
        5: 8905:        window->AutoFitOnlyGrows = false;
        5: 8905-block 24
        -: 8906:    else
    15073: 8907:        window->SizeFull.x = IM_TRUNC(size.x);
    15073: 8907-block 25
    15078: 8908:    if (size.y <= 0.0f)
    15078: 8908-block 26
branch  0 taken 2 (fallthrough)
branch  1 taken 15076
        2: 8909:        window->AutoFitOnlyGrows = false;
        2: 8909-block 27
        -: 8910:    else
    15076: 8911:        window->SizeFull.y = IM_TRUNC(size.y);
    15076: 8911-block 28
    15078: 8912:    if (old_size.x != window->SizeFull.x || old_size.y != window->SizeFull.y)
    15078: 8912-block 29
branch  0 taken 15058 (fallthrough)
branch  1 taken 20
    15058: 8912-block 30
branch  2 taken 7 (fallthrough)
branch  3 taken 15051
       27: 8913:        MarkIniSettingsDirty(window);
       27: 8913-block 31
call    0 returned 27
        -: 8914:}
        -: 8915:
function _ZN5ImGui13SetWindowSizeERK6ImVec2i called 0 returned 0% blocks executed 0%
    #####: 8916:void ImGui::SetWindowSize(const ImVec2& size, ImGuiCond cond)
        -: 8917:{
    #####: 8918:    SetWindowSize(GImGui->CurrentWindow, size, cond);
    %%%%%: 8918-block 2
call    0 never executed
    #####: 8919:}
        -: 8920:
function _ZN5ImGui13SetWindowSizeEPKcRK6ImVec2i called 0 returned 0% blocks executed 0%
    #####: 8921:void ImGui::SetWindowSize(const char* name, const ImVec2& size, ImGuiCond cond)
        -: 8922:{
    #####: 8923:    if (ImGuiWindow* window = FindWindowByName(name))
    %%%%%: 8923-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 8924:        SetWindowSize(window, size, cond);
    %%%%%: 8924-block 4
call    0 never executed
    #####: 8925:}
        -: 8926:
function _ZN5ImGui18SetWindowCollapsedEP11ImGuiWindowbi called 0 returned 0% blocks executed 0%
    #####: 8927:void ImGui::SetWindowCollapsed(ImGuiWindow* window, bool collapsed, ImGuiCond cond)
        -: 8928:{
        -: 8929:    // Test condition (NB: bit 0 is always true) and clear flags for next time
    #####: 8930:    if (cond && (window->SetWindowCollapsedAllowFlags & cond) == 0)
    %%%%%: 8930-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8930-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 8931:        return;
    %%%%%: 8931-block 4
    #####: 8932:    window->SetWindowCollapsedAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);
        -: 8933:
        -: 8934:    // Set
    #####: 8935:    window->Collapsed = collapsed;
    %%%%%: 8935-block 5
        -: 8936:}
        -: 8937:
function _ZN5ImGui20SetWindowHitTestHoleEP11ImGuiWindowRK6ImVec2S4_ called 0 returned 0% blocks executed 0%
    #####: 8938:void ImGui::SetWindowHitTestHole(ImGuiWindow* window, const ImVec2& pos, const ImVec2& size)
        -: 8939:{
    #####: 8940:    IM_ASSERT(window->HitTestHoleSize.x == 0);     // We don't support multiple holes/hit test filters
    %%%%%: 8940-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8940-block 3
call    2 never executed
    #####: 8941:    window->HitTestHoleSize = ImVec2ih(size);
    %%%%%: 8941-block 4
call    0 never executed
    #####: 8942:    window->HitTestHoleOffset = ImVec2ih(pos - window->Pos);
call    0 never executed
call    1 never executed
    #####: 8943:}
        -: 8944:
function _ZN5ImGui42SetWindowHiddenAndSkipItemsForCurrentFrameEP11ImGuiWindow called 0 returned 0% blocks executed 0%
    #####: 8945:void ImGui::SetWindowHiddenAndSkipItemsForCurrentFrame(ImGuiWindow* window)
        -: 8946:{
    #####: 8947:    window->Hidden = window->SkipItems = true;
    #####: 8948:    window->HiddenFramesCanSkipItems = 1;
    #####: 8949:}
        -: 8950:
function _ZN5ImGui18SetWindowCollapsedEbi called 0 returned 0% blocks executed 0%
    #####: 8951:void ImGui::SetWindowCollapsed(bool collapsed, ImGuiCond cond)
        -: 8952:{
    #####: 8953:    SetWindowCollapsed(GImGui->CurrentWindow, collapsed, cond);
    %%%%%: 8953-block 2
call    0 never executed
    #####: 8954:}
        -: 8955:
function _ZN5ImGui17IsWindowCollapsedEv called 0 returned 0% blocks executed 0%
    #####: 8956:bool ImGui::IsWindowCollapsed()
        -: 8957:{
    #####: 8958:    ImGuiWindow* window = GetCurrentWindowRead();
    %%%%%: 8958-block 2
call    0 never executed
    #####: 8959:    return window->Collapsed;
        -: 8960:}
        -: 8961:
function _ZN5ImGui17IsWindowAppearingEv called 0 returned 0% blocks executed 0%
    #####: 8962:bool ImGui::IsWindowAppearing()
        -: 8963:{
    #####: 8964:    ImGuiWindow* window = GetCurrentWindowRead();
    %%%%%: 8964-block 2
call    0 never executed
    #####: 8965:    return window->Appearing;
        -: 8966:}
        -: 8967:
function _ZN5ImGui18SetWindowCollapsedEPKcbi called 0 returned 0% blocks executed 0%
    #####: 8968:void ImGui::SetWindowCollapsed(const char* name, bool collapsed, ImGuiCond cond)
        -: 8969:{
    #####: 8970:    if (ImGuiWindow* window = FindWindowByName(name))
    %%%%%: 8970-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 8971:        SetWindowCollapsed(window, collapsed, cond);
    %%%%%: 8971-block 4
call    0 never executed
    #####: 8972:}
        -: 8973:
function _ZN5ImGui14SetWindowFocusEv called 0 returned 0% blocks executed 0%
    #####: 8974:void ImGui::SetWindowFocus()
        -: 8975:{
    #####: 8976:    FocusWindow(GImGui->CurrentWindow);
    %%%%%: 8976-block 2
call    0 never executed
    #####: 8977:}
        -: 8978:
function _ZN5ImGui14SetWindowFocusEPKc called 0 returned 0% blocks executed 0%
    #####: 8979:void ImGui::SetWindowFocus(const char* name)
        -: 8980:{
    #####: 8981:    if (name)
    %%%%%: 8981-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 8982:    {
    #####: 8983:        if (ImGuiWindow* window = FindWindowByName(name))
    %%%%%: 8983-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 8984:            FocusWindow(window);
    %%%%%: 8984-block 5
call    0 never executed
        -: 8985:    }
        -: 8986:    else
        -: 8987:    {
    #####: 8988:        FocusWindow(NULL);
    %%%%%: 8988-block 6
call    0 never executed
        -: 8989:    }
    #####: 8990:}
        -: 8991:
function _ZN5ImGui16SetNextWindowPosERK6ImVec2iS2_ called 9693 returned 100% blocks executed 50%
     9693: 8992:void ImGui::SetNextWindowPos(const ImVec2& pos, ImGuiCond cond, const ImVec2& pivot)
        -: 8993:{
     9693: 8994:    ImGuiContext& g = *GImGui;
    9693*: 8995:    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
     9693: 8995-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 9693
    %%%%%: 8995-block 3
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 8995-block 5
call    5 never executed
     9693: 8996:    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasPos;
     9693: 8997:    g.NextWindowData.PosVal = pos;
     9693: 8998:    g.NextWindowData.PosPivotVal = pivot;
    9693*: 8999:    g.NextWindowData.PosCond = cond ? cond : ImGuiCond_Always;
     9693: 8999-block 6
branch  0 taken 0 (fallthrough)
branch  1 taken 9693
    %%%%%: 8999-block 7
     9693: 8999-block 8
     9693: 9000:    g.NextWindowData.PosUndock = true;
     9693: 9001:}
        -: 9002:
function _ZN5ImGui17SetNextWindowSizeERK6ImVec2i called 19386 returned 100% blocks executed 88%
    19386: 9003:void ImGui::SetNextWindowSize(const ImVec2& size, ImGuiCond cond)
        -: 9004:{
    19386: 9005:    ImGuiContext& g = *GImGui;
   19386*: 9006:    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
    19386: 9006-block 2
branch  0 taken 3231 (fallthrough)
branch  1 taken 16155
     3231: 9006-block 3
call    2 returned 3231
branch  3 taken 0 (fallthrough)
branch  4 taken 3231
    %%%%%: 9006-block 5
call    5 never executed
    19386: 9007:    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasSize;
    19386: 9008:    g.NextWindowData.SizeVal = size;
    19386: 9009:    g.NextWindowData.SizeCond = cond ? cond : ImGuiCond_Always;
    19386: 9009-block 6
branch  0 taken 3231 (fallthrough)
branch  1 taken 16155
     3231: 9009-block 7
    16155: 9009-block 8
    19386: 9010:}
        -: 9011:
        -: 9012:// For each axis:
        -: 9013:// - Use 0.0f as min or FLT_MAX as max if you don't want limits, e.g. size_min = (500.0f, 0.0f), size_max = (FLT_MAX, FLT_MAX) sets a minimum width.
        -: 9014:// - Use -1 for both min and max of same axis to preserve current size which itself is a constraint.
        -: 9015:// - See "Demo->Examples->Constrained-resizing window" for examples.
function _ZN5ImGui28SetNextWindowSizeConstraintsERK6ImVec2S2_PFvP21ImGuiSizeCallbackDataEPv called 2154 returned 100% blocks executed 100%
     2154: 9016:void ImGui::SetNextWindowSizeConstraints(const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeCallback custom_callback, void* custom_callback_user_data)
        -: 9017:{
     2154: 9018:    ImGuiContext& g = *GImGui;
     2154: 9019:    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasSizeConstraint;
     2154: 9020:    g.NextWindowData.SizeConstraintRect = ImRect(size_min, size_max);
     2154: 9020-block 2
call    0 returned 2154
     2154: 9021:    g.NextWindowData.SizeCallback = custom_callback;
     2154: 9022:    g.NextWindowData.SizeCallbackUserData = custom_callback_user_data;
     2154: 9023:}
        -: 9024:
        -: 9025:// Content size = inner scrollable rectangle, padded with WindowPadding.
        -: 9026:// SetNextWindowContentSize(ImVec2(100,100) + ImGuiWindowFlags_AlwaysAutoResize will always allow submitting a 100x100 item.
function _ZN5ImGui24SetNextWindowContentSizeERK6ImVec2 called 0 returned 0% blocks executed 0%
    #####: 9027:void ImGui::SetNextWindowContentSize(const ImVec2& size)
        -: 9028:{
    #####: 9029:    ImGuiContext& g = *GImGui;
    #####: 9030:    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasContentSize;
    #####: 9031:    g.NextWindowData.ContentSizeVal = ImTrunc(size);
    %%%%%: 9031-block 2
call    0 never executed
    #####: 9032:}
        -: 9033:
function _ZN5ImGui19SetNextWindowScrollERK6ImVec2 called 0 returned 0% blocks executed 0%
    #####: 9034:void ImGui::SetNextWindowScroll(const ImVec2& scroll)
        -: 9035:{
    #####: 9036:    ImGuiContext& g = *GImGui;
    #####: 9037:    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasScroll;
    #####: 9038:    g.NextWindowData.ScrollVal = scroll;
    #####: 9039:}
        -: 9040:
function _ZN5ImGui22SetNextWindowCollapsedEbi called 0 returned 0% blocks executed 0%
    #####: 9041:void ImGui::SetNextWindowCollapsed(bool collapsed, ImGuiCond cond)
        -: 9042:{
    #####: 9043:    ImGuiContext& g = *GImGui;
    #####: 9044:    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
    %%%%%: 9044-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9044-block 3
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 9044-block 5
call    5 never executed
    #####: 9045:    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasCollapsed;
    #####: 9046:    g.NextWindowData.CollapsedVal = collapsed;
    #####: 9047:    g.NextWindowData.CollapsedCond = cond ? cond : ImGuiCond_Always;
    %%%%%: 9047-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9047-block 7
    %%%%%: 9047-block 8
    #####: 9048:}
        -: 9049:
function _ZN5ImGui18SetNextWindowFocusEv called 0 returned 0% blocks executed 0%
    #####: 9050:void ImGui::SetNextWindowFocus()
        -: 9051:{
    #####: 9052:    ImGuiContext& g = *GImGui;
    #####: 9053:    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasFocus;
    #####: 9054:}
        -: 9055:
function _ZN5ImGui20SetNextWindowBgAlphaEf called 0 returned 0% blocks executed 0%
    #####: 9056:void ImGui::SetNextWindowBgAlpha(float alpha)
        -: 9057:{
    #####: 9058:    ImGuiContext& g = *GImGui;
    #####: 9059:    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasBgAlpha;
    #####: 9060:    g.NextWindowData.BgAlphaVal = alpha;
    #####: 9061:}
        -: 9062:
function _ZN5ImGui21SetNextWindowViewportEj called 3231 returned 100% blocks executed 100%
     3231: 9063:void ImGui::SetNextWindowViewport(ImGuiID id)
        -: 9064:{
     3231: 9065:    ImGuiContext& g = *GImGui;
     3231: 9066:    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasViewport;
     3231: 9067:    g.NextWindowData.ViewportId = id;
     3231: 9068:}
        -: 9069:
function _ZN5ImGui19SetNextWindowDockIDEji called 0 returned 0% blocks executed 0%
    #####: 9070:void ImGui::SetNextWindowDockID(ImGuiID id, ImGuiCond cond)
        -: 9071:{
    #####: 9072:    ImGuiContext& g = *GImGui;
    #####: 9073:    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasDock;
    #####: 9074:    g.NextWindowData.DockCond = cond ? cond : ImGuiCond_Always;
    %%%%%: 9074-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9074-block 3
    %%%%%: 9074-block 4
    #####: 9075:    g.NextWindowData.DockId = id;
    #####: 9076:}
        -: 9077:
function _ZN5ImGui18SetNextWindowClassEPK16ImGuiWindowClass called 0 returned 0% blocks executed 0%
    #####: 9078:void ImGui::SetNextWindowClass(const ImGuiWindowClass* window_class)
        -: 9079:{
    #####: 9080:    ImGuiContext& g = *GImGui;
    #####: 9081:    IM_ASSERT((window_class->ViewportFlagsOverrideSet & window_class->ViewportFlagsOverrideClear) == 0); // Cannot set both set and clear for the same bit
    %%%%%: 9081-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9081-block 3
call    2 never executed
    #####: 9082:    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasWindowClass;
    #####: 9083:    g.NextWindowData.WindowClass = *window_class;
    #####: 9084:}
        -: 9085:
        -: 9086:// This is experimental and meant to be a toy for exploring a future/wider range of features.
function _ZN5ImGui26SetNextWindowRefreshPolicyEi called 0 returned 0% blocks executed 0%
    #####: 9087:void ImGui::SetNextWindowRefreshPolicy(ImGuiWindowRefreshFlags flags)
        -: 9088:{
    #####: 9089:    ImGuiContext& g = *GImGui;
    #####: 9090:    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasRefreshPolicy;
    #####: 9091:    g.NextWindowData.RefreshFlagsVal = flags;
    #####: 9092:}
        -: 9093:
function _ZN5ImGui17GetWindowDrawListEv called 3231 returned 100% blocks executed 100%
     3231: 9094:ImDrawList* ImGui::GetWindowDrawList()
        -: 9095:{
     3231: 9096:    ImGuiWindow* window = GetCurrentWindow();
     3231: 9096-block 2
call    0 returned 3231
     3231: 9097:    return window->DrawList;
        -: 9098:}
        -: 9099:
function _ZN5ImGui17GetWindowDpiScaleEv called 0 returned 0% blocks executed 0%
    #####: 9100:float ImGui::GetWindowDpiScale()
        -: 9101:{
    #####: 9102:    ImGuiContext& g = *GImGui;
    #####: 9103:    return g.CurrentDpiScale;
    %%%%%: 9103-block 2
        -: 9104:}
        -: 9105:
function _ZN5ImGui17GetWindowViewportEv called 0 returned 0% blocks executed 0%
    #####: 9106:ImGuiViewport* ImGui::GetWindowViewport()
        -: 9107:{
    #####: 9108:    ImGuiContext& g = *GImGui;
    #####: 9109:    IM_ASSERT(g.CurrentViewport != NULL && g.CurrentViewport == g.CurrentWindow->Viewport);
    %%%%%: 9109-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9109-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 9109-block 4
    %%%%%: 9109-block 5
call    4 never executed
    #####: 9110:    return g.CurrentViewport;
    %%%%%: 9110-block 6
        -: 9111:}
        -: 9112:
function _ZN5ImGui7GetFontEv called 46312 returned 100% blocks executed 100%
    46312: 9113:ImFont* ImGui::GetFont()
        -: 9114:{
    46312: 9115:    return GImGui->Font;
    46312: 9115-block 2
        -: 9116:}
        -: 9117:
function _ZN5ImGui11GetFontSizeEv called 46312 returned 100% blocks executed 100%
    46312: 9118:float ImGui::GetFontSize()
        -: 9119:{
    46312: 9120:    return GImGui->FontSize;
    46312: 9120-block 2
        -: 9121:}
        -: 9122:
function _ZN5ImGui22GetFontTexUvWhitePixelEv called 0 returned 0% blocks executed 0%
    #####: 9123:ImVec2 ImGui::GetFontTexUvWhitePixel()
        -: 9124:{
    #####: 9125:    return GImGui->DrawListSharedData.TexUvWhitePixel;
    %%%%%: 9125-block 2
        -: 9126:}
        -: 9127:
function _ZN5ImGui18SetWindowFontScaleEf called 0 returned 0% blocks executed 0%
    #####: 9128:void ImGui::SetWindowFontScale(float scale)
        -: 9129:{
    #####: 9130:    IM_ASSERT(scale > 0.0f);
    %%%%%: 9130-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9130-block 3
call    2 never executed
    #####: 9131:    ImGuiContext& g = *GImGui;
    #####: 9132:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%: 9132-block 4
call    0 never executed
    #####: 9133:    window->FontWindowScale = scale;
    #####: 9134:    g.FontSize = g.DrawListSharedData.FontSize = window->CalcFontSize();
call    0 never executed
    #####: 9135:    g.FontScale = g.DrawListSharedData.FontScale = g.FontSize / g.Font->FontSize;
    #####: 9136:}
        -: 9137:
function _ZN5ImGui14PushFocusScopeEj called 17445 returned 100% blocks executed 100%
    17445: 9138:void ImGui::PushFocusScope(ImGuiID id)
        -: 9139:{
    17445: 9140:    ImGuiContext& g = *GImGui;
        -: 9141:    ImGuiFocusScopeData data;
    17445: 9142:    data.ID = id;
    17445: 9143:    data.WindowID = g.CurrentWindow->ID;
    17445: 9144:    g.FocusScopeStack.push_back(data);
    17445: 9144-block 2
call    0 returned 17445
branch  1 taken 17445 (fallthrough)
branch  2 taken 0 (throw)
    17445: 9145:    g.CurrentFocusScopeId = id;
    17445: 9146:}
    17445: 9146-block 3
        -: 9147:
function _ZN5ImGui13PopFocusScopeEv called 17445 returned 100% blocks executed 67%
    17445: 9148:void ImGui::PopFocusScope()
        -: 9149:{
    17445: 9150:    ImGuiContext& g = *GImGui;
    17445: 9151:    if (g.FocusScopeStack.Size <= g.StackSizesInBeginForCurrentWindow->SizeOfFocusScopeStack)
    17445: 9151-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 17445
        -: 9152:    {
    #####: 9153:        IM_ASSERT_USER_ERROR(0, "Calling PopFocusScope() too many times!");
    %%%%%: 9153-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 9153-block 5
call    3 never executed
    #####: 9154:        return;
    %%%%%: 9154-block 6
        -: 9155:    }
    17445: 9156:    g.FocusScopeStack.pop_back();
    17445: 9156-block 7
call    0 returned 17445
    17445: 9157:    g.CurrentFocusScopeId = g.FocusScopeStack.Size ? g.FocusScopeStack.back().ID : 0;
branch  0 taken 16368 (fallthrough)
branch  1 taken 1077
    16368: 9157-block 9
call    2 returned 16368
     1077: 9157-block 11
    17445: 9157-block 12
        -: 9158:}
        -: 9159:
function _ZN5ImGui16SetNavFocusScopeEj called 491 returned 100% blocks executed 79%
      491: 9160:void ImGui::SetNavFocusScope(ImGuiID focus_scope_id)
        -: 9161:{
      491: 9162:    ImGuiContext& g = *GImGui;
      491: 9163:    g.NavFocusScopeId = focus_scope_id;
      491: 9164:    g.NavFocusRoute.resize(0); // Invalidate
      491: 9164-block 2
call    0 returned 491
      491: 9165:    if (focus_scope_id == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 491
    #####: 9166:        return;
    %%%%%: 9166-block 4
     491*: 9167:    IM_ASSERT(g.NavWindow != NULL);
      491: 9167-block 5
branch  0 taken 0 (fallthrough)
branch  1 taken 491
    %%%%%: 9167-block 6
call    2 never executed
        -: 9168:
        -: 9169:    // Store current path (in reverse order)
      491: 9170:    if (focus_scope_id == g.CurrentFocusScopeId)
      491: 9170-block 7
branch  0 taken 487 (fallthrough)
branch  1 taken 4
        -: 9171:    {
        -: 9172:        // Top of focus stack contains local focus scopes inside current window
     1309: 9173:        for (int n = g.FocusScopeStack.Size - 1; n >= 0 && g.FocusScopeStack.Data[n].WindowID == g.CurrentWindow->ID; n--)
      487: 9173-block 8
     1309: 9173-block 11
branch  0 taken 1307 (fallthrough)
branch  1 taken 2
     1307: 9173-block 12
branch  2 taken 822
branch  3 taken 485
      822: 9174:            g.NavFocusRoute.push_back(g.FocusScopeStack.Data[n]);
      822: 9174-block 9
call    0 returned 822
        -: 9175:    }
        4: 9176:    else if (focus_scope_id == g.NavWindow->NavRootFocusScopeId)
        4: 9176-block 13
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4: 9177:        g.NavFocusRoute.push_back({ focus_scope_id, g.NavWindow->ID });
        4: 9177-block 14
call    0 returned 4
branch  1 taken 4 (fallthrough)
branch  2 taken 0 (throw)
        4: 9177-block 15
    $$$$$: 9177-block 24
call    3 never executed
        -: 9178:    else
    #####: 9179:        return;
    %%%%%: 9179-block 16
        -: 9180:
        -: 9181:    // Then follow on manually set ParentWindowForFocusRoute field (#6798)
      493: 9182:    for (ImGuiWindow* window = g.NavWindow->ParentWindowForFocusRoute; window != NULL; window = window->ParentWindowForFocusRoute)
      491: 9182-block 17
      493: 9182-block 20
branch  0 taken 2
branch  1 taken 491 (fallthrough)
        2: 9183:        g.NavFocusRoute.push_back({ window->NavRootFocusScopeId, window->ID });
        2: 9183-block 18
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        2: 9183-block 19
     491*: 9184:    IM_ASSERT(g.NavFocusRoute.Size < 100); // Maximum depth is technically 251 as per CalcRoutingScore(): 254 - 3
      491: 9184-block 21
branch  0 taken 0 (fallthrough)
branch  1 taken 491
    %%%%%: 9184-block 22
call    2 never executed
        -: 9185:}
        -: 9186:
        -: 9187:// Focus = move navigation cursor, set scrolling, set focus window.
function _ZN5ImGui9FocusItemEv called 0 returned 0% blocks executed 0%
    #####: 9188:void ImGui::FocusItem()
        -: 9189:{
    #####: 9190:    ImGuiContext& g = *GImGui;
    #####: 9191:    ImGuiWindow* window = g.CurrentWindow;
    #####: 9192:    IMGUI_DEBUG_LOG_FOCUS("FocusItem(0x%08x) in window \"%s\"\n", g.LastItemData.ID, window->Name);
    %%%%%: 9192-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9192-block 3
call    2 never executed
    #####: 9193:    if (g.DragDropActive || g.MovingWindow != NULL) // FIXME: Opt-in flags for this?
    %%%%%: 9193-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9193-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 9194:    {
    #####: 9195:        IMGUI_DEBUG_LOG_FOCUS("FocusItem() ignored while DragDropActive!\n");
    %%%%%: 9195-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9195-block 7
call    2 never executed
    #####: 9196:        return;
    %%%%%: 9196-block 8
        -: 9197:    }
        -: 9198:
    #####: 9199:    ImGuiNavMoveFlags move_flags = ImGuiNavMoveFlags_IsTabbing | ImGuiNavMoveFlags_FocusApi | ImGuiNavMoveFlags_NoSetNavCursorVisible | ImGuiNavMoveFlags_NoSelect;
    #####: 9200:    ImGuiScrollFlags scroll_flags = window->Appearing ? ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_AlwaysCenterY : ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_KeepVisibleEdgeY;
    %%%%%: 9200-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9200-block 10
    %%%%%: 9200-block 11
    #####: 9201:    SetNavWindow(window);
    %%%%%: 9201-block 12
call    0 never executed
    #####: 9202:    NavMoveRequestSubmit(ImGuiDir_None, ImGuiDir_Up, move_flags, scroll_flags);
call    0 never executed
    #####: 9203:    NavMoveRequestResolveWithLastItem(&g.NavMoveResultLocal);
call    0 never executed
        -: 9204:}
        -: 9205:
function _ZN5ImGui16ActivateItemByIDEj called 0 returned 0% blocks executed 0%
    #####: 9206:void ImGui::ActivateItemByID(ImGuiID id)
        -: 9207:{
    #####: 9208:    ImGuiContext& g = *GImGui;
    #####: 9209:    g.NavNextActivateId = id;
    #####: 9210:    g.NavNextActivateFlags = ImGuiActivateFlags_None;
    #####: 9211:}
        -: 9212:
        -: 9213:// Note: this will likely be called ActivateItem() once we rework our Focus/Activation system!
        -: 9214:// But ActivateItem() should function without altering scroll/focus?
function _ZN5ImGui20SetKeyboardFocusHereEi called 0 returned 0% blocks executed 0%
    #####: 9215:void ImGui::SetKeyboardFocusHere(int offset)
        -: 9216:{
    #####: 9217:    ImGuiContext& g = *GImGui;
    #####: 9218:    ImGuiWindow* window = g.CurrentWindow;
    #####: 9219:    IM_ASSERT(offset >= -1);    // -1 is allowed but not below
    %%%%%: 9219-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9219-block 3
call    2 never executed
    #####: 9220:    IMGUI_DEBUG_LOG_FOCUS("SetKeyboardFocusHere(%d) in window \"%s\"\n", offset, window->Name);
    %%%%%: 9220-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9220-block 5
call    2 never executed
        -: 9221:
        -: 9222:    // It makes sense in the vast majority of cases to never interrupt a drag and drop.
        -: 9223:    // When we refactor this function into ActivateItem() we may want to make this an option.
        -: 9224:    // MovingWindow is protected from most user inputs using SetActiveIdUsingNavAndKeys(), but
        -: 9225:    // is also automatically dropped in the event g.ActiveId is stolen.
    #####: 9226:    if (g.DragDropActive || g.MovingWindow != NULL)
    %%%%%: 9226-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9226-block 7
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 9227:    {
    #####: 9228:        IMGUI_DEBUG_LOG_FOCUS("SetKeyboardFocusHere() ignored while DragDropActive!\n");
    %%%%%: 9228-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9228-block 9
call    2 never executed
    #####: 9229:        return;
    %%%%%: 9229-block 10
        -: 9230:    }
        -: 9231:
    #####: 9232:    SetNavWindow(window);
    %%%%%: 9232-block 11
call    0 never executed
        -: 9233:
    #####: 9234:    ImGuiNavMoveFlags move_flags = ImGuiNavMoveFlags_IsTabbing | ImGuiNavMoveFlags_Activate | ImGuiNavMoveFlags_FocusApi | ImGuiNavMoveFlags_NoSetNavCursorVisible;
    #####: 9235:    ImGuiScrollFlags scroll_flags = window->Appearing ? ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_AlwaysCenterY : ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_KeepVisibleEdgeY;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9235-block 13
    %%%%%: 9235-block 14
    #####: 9236:    NavMoveRequestSubmit(ImGuiDir_None, offset < 0 ? ImGuiDir_Up : ImGuiDir_Down, move_flags, scroll_flags); // FIXME-NAV: Once we refactor tabbing, add LegacyApi flag to not activate non-inputable.
    %%%%%: 9236-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9236-block 16
    %%%%%: 9236-block 17
    %%%%%: 9236-block 18
call    2 never executed
    #####: 9237:    if (offset == -1)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 9238:    {
    #####: 9239:        NavMoveRequestResolveWithLastItem(&g.NavMoveResultLocal);
    %%%%%: 9239-block 20
call    0 never executed
        -: 9240:    }
        -: 9241:    else
        -: 9242:    {
    #####: 9243:        g.NavTabbingDir = 1;
    #####: 9244:        g.NavTabbingCounter = offset + 1;
    %%%%%: 9244-block 21
        -: 9245:    }
        -: 9246:}
        -: 9247:
function _ZN5ImGui19SetItemDefaultFocusEv called 1077 returned 100% blocks executed 38%
     1077: 9248:void ImGui::SetItemDefaultFocus()
        -: 9249:{
     1077: 9250:    ImGuiContext& g = *GImGui;
     1077: 9251:    ImGuiWindow* window = g.CurrentWindow;
     1077: 9252:    if (!window->Appearing)
     1077: 9252-block 2
branch  0 taken 1076 (fallthrough)
branch  1 taken 1
     1076: 9253:        return;
     1076: 9253-block 3
       1*: 9254:    if (g.NavWindow != window->RootWindowForNav || (!g.NavInitRequest && g.NavInitResult.ID == 0) || g.NavLayer != window->DC.NavLayerCurrent)
        1: 9254-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 9254-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 9254-block 6
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 9254-block 7
branch  6 never executed (fallthrough)
branch  7 never executed
        1: 9255:        return;
        1: 9255-block 8
        -: 9256:
    #####: 9257:    g.NavInitRequest = false;
    #####: 9258:    NavApplyItemToResult(&g.NavInitResult);
    %%%%%: 9258-block 9
call    0 never executed
    #####: 9259:    NavUpdateAnyRequestFlag();
call    0 never executed
        -: 9260:
        -: 9261:    // Scroll could be done in NavInitRequestApplyResult() via an opt-in flag (we however don't want regular init requests to scroll)
    #####: 9262:    if (!window->ClipRect.Contains(g.LastItemData.Rect))
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 9263:        ScrollToRectEx(window, g.LastItemData.Rect, ImGuiScrollFlags_None);
    %%%%%: 9263-block 13
call    0 never executed
        -: 9264:}
        -: 9265:
function _ZN5ImGui15SetStateStorageEP12ImGuiStorage called 0 returned 0% blocks executed 0%
    #####: 9266:void ImGui::SetStateStorage(ImGuiStorage* tree)
        -: 9267:{
    #####: 9268:    ImGuiWindow* window = GImGui->CurrentWindow;
    #####: 9269:    window->DC.StateStorage = tree ? tree : &window->StateStorage;
    %%%%%: 9269-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9269-block 3
    %%%%%: 9269-block 4
    #####: 9270:}
        -: 9271:
function _ZN5ImGui15GetStateStorageEv called 0 returned 0% blocks executed 0%
    #####: 9272:ImGuiStorage* ImGui::GetStateStorage()
        -: 9273:{
    #####: 9274:    ImGuiWindow* window = GImGui->CurrentWindow;
    #####: 9275:    return window->DC.StateStorage;
    %%%%%: 9275-block 2
        -: 9276:}
        -: 9277:
function _ZN5ImGui13IsRectVisibleERK6ImVec2 called 0 returned 0% blocks executed 0%
    #####: 9278:bool ImGui::IsRectVisible(const ImVec2& size)
        -: 9279:{
    #####: 9280:    ImGuiWindow* window = GImGui->CurrentWindow;
    #####: 9281:    return window->ClipRect.Overlaps(ImRect(window->DC.CursorPos, window->DC.CursorPos + size));
    %%%%%: 9281-block 2
call    0 never executed
call    1 never executed
call    2 never executed
        -: 9282:}
        -: 9283:
function _ZN5ImGui13IsRectVisibleERK6ImVec2S2_ called 0 returned 0% blocks executed 0%
    #####: 9284:bool ImGui::IsRectVisible(const ImVec2& rect_min, const ImVec2& rect_max)
        -: 9285:{
    #####: 9286:    ImGuiWindow* window = GImGui->CurrentWindow;
    #####: 9287:    return window->ClipRect.Overlaps(ImRect(rect_min, rect_max));
    %%%%%: 9287-block 2
call    0 never executed
call    1 never executed
        -: 9288:}
        -: 9289:
        -: 9290://-----------------------------------------------------------------------------
        -: 9291:// [SECTION] ID STACK
        -: 9292://-----------------------------------------------------------------------------
        -: 9293:
        -: 9294:// This is one of the very rare legacy case where we use ImGuiWindow methods,
        -: 9295:// it should ideally be flattened at some point but it's been used a lots by widgets.
        -: 9296:IM_MSVC_RUNTIME_CHECKS_OFF
function _ZN11ImGuiWindow5GetIDEPKcS1_ called 187346 returned 100% blocks executed 78%
   187346: 9297:ImGuiID ImGuiWindow::GetID(const char* str, const char* str_end)
        -: 9298:{
   187346: 9299:    ImGuiID seed = IDStack.back();
   187346: 9299-block 2
call    0 returned 187346
  187346*: 9300:    ImGuiID id = ImHashStr(str, str_end ? (str_end - str) : 0, seed);
branch  0 taken 0 (fallthrough)
branch  1 taken 187346
    %%%%%: 9300-block 4
   187346: 9300-block 5
   187346: 9300-block 6
call    2 returned 187346
        -: 9301:#ifndef IMGUI_DISABLE_DEBUG_TOOLS
   187346: 9302:    ImGuiContext& g = *Ctx;
   187346: 9303:    if (g.DebugHookIdInfo == id)
branch  0 taken 0 (fallthrough)
branch  1 taken 187346
    #####: 9304:        ImGui::DebugHookIdInfo(id, ImGuiDataType_String, str, str_end);
    %%%%%: 9304-block 8
call    0 never executed
        -: 9305:#endif
   187346: 9306:    return id;
   187346: 9306-block 9
        -: 9307:}
        -: 9308:
function _ZN11ImGuiWindow5GetIDEPKv called 1077 returned 100% blocks executed 83%
     1077: 9309:ImGuiID ImGuiWindow::GetID(const void* ptr)
        -: 9310:{
     1077: 9311:    ImGuiID seed = IDStack.back();
     1077: 9311-block 2
call    0 returned 1077
     1077: 9312:    ImGuiID id = ImHashData(&ptr, sizeof(void*), seed);
call    0 returned 1077
        -: 9313:#ifndef IMGUI_DISABLE_DEBUG_TOOLS
     1077: 9314:    ImGuiContext& g = *Ctx;
     1077: 9315:    if (g.DebugHookIdInfo == id)
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####: 9316:        ImGui::DebugHookIdInfo(id, ImGuiDataType_Pointer, ptr, NULL);
    %%%%%: 9316-block 5
call    0 never executed
        -: 9317:#endif
     1077: 9318:    return id;
     1077: 9318-block 6
        -: 9319:}
        -: 9320:
function _ZN11ImGuiWindow5GetIDEi called 74340 returned 100% blocks executed 83%
    74340: 9321:ImGuiID ImGuiWindow::GetID(int n)
        -: 9322:{
    74340: 9323:    ImGuiID seed = IDStack.back();
    74340: 9323-block 2
call    0 returned 74340
    74340: 9324:    ImGuiID id = ImHashData(&n, sizeof(n), seed);
call    0 returned 74340
        -: 9325:#ifndef IMGUI_DISABLE_DEBUG_TOOLS
    74340: 9326:    ImGuiContext& g = *Ctx;
    74340: 9327:    if (g.DebugHookIdInfo == id)
branch  0 taken 0 (fallthrough)
branch  1 taken 74340
    #####: 9328:        ImGui::DebugHookIdInfo(id, ImGuiDataType_S32, (void*)(intptr_t)n, NULL);
    %%%%%: 9328-block 5
call    0 never executed
        -: 9329:#endif
    74340: 9330:    return id;
    74340: 9330-block 6
        -: 9331:}
        -: 9332:
        -: 9333:// This is only used in rare/specific situations to manufacture an ID out of nowhere.
        -: 9334:// FIXME: Consider instead storing last non-zero ID + count of successive zero-ID, and combine those?
function _ZN11ImGuiWindow12GetIDFromPosERK6ImVec2 called 0 returned 0% blocks executed 0%
    #####: 9335:ImGuiID ImGuiWindow::GetIDFromPos(const ImVec2& p_abs)
        -: 9336:{
    #####: 9337:    ImGuiID seed = IDStack.back();
    %%%%%: 9337-block 2
call    0 never executed
    #####: 9338:    ImVec2 p_rel = ImGui::WindowPosAbsToRel(this, p_abs);
call    0 never executed
    #####: 9339:    ImGuiID id = ImHashData(&p_rel, sizeof(p_rel), seed);
call    0 never executed
    #####: 9340:    return id;
        -: 9341:}
        -: 9342:
        -: 9343:// "
function _ZN11ImGuiWindow18GetIDFromRectangleERK6ImRect called 0 returned 0% blocks executed 0%
    #####: 9344:ImGuiID ImGuiWindow::GetIDFromRectangle(const ImRect& r_abs)
        -: 9345:{
    #####: 9346:    ImGuiID seed = IDStack.back();
    %%%%%: 9346-block 2
call    0 never executed
    #####: 9347:    ImRect r_rel = ImGui::WindowRectAbsToRel(this, r_abs);
call    0 never executed
    #####: 9348:    ImGuiID id = ImHashData(&r_rel, sizeof(r_rel), seed);
call    0 never executed
    #####: 9349:    return id;
        -: 9350:}
        -: 9351:
function _ZN5ImGui6PushIDEPKc called 6462 returned 100% blocks executed 100%
     6462: 9352:void ImGui::PushID(const char* str_id)
        -: 9353:{
     6462: 9354:    ImGuiContext& g = *GImGui;
     6462: 9355:    ImGuiWindow* window = g.CurrentWindow;
     6462: 9356:    ImGuiID id = window->GetID(str_id);
     6462: 9356-block 2
call    0 returned 6462
branch  1 taken 6462 (fallthrough)
branch  2 taken 0 (throw)
     6462: 9357:    window->IDStack.push_back(id);
     6462: 9357-block 3
call    0 returned 6462
branch  1 taken 6462 (fallthrough)
branch  2 taken 0 (throw)
     6462: 9358:}
     6462: 9358-block 4
        -: 9359:
function _ZN5ImGui6PushIDEPKcS1_ called 0 returned 0% blocks executed 0%
    #####: 9360:void ImGui::PushID(const char* str_id_begin, const char* str_id_end)
        -: 9361:{
    #####: 9362:    ImGuiContext& g = *GImGui;
    #####: 9363:    ImGuiWindow* window = g.CurrentWindow;
    #####: 9364:    ImGuiID id = window->GetID(str_id_begin, str_id_end);
    %%%%%: 9364-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 9365:    window->IDStack.push_back(id);
    %%%%%: 9365-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 9366:}
    %%%%%: 9366-block 4
        -: 9367:
function _ZN5ImGui6PushIDEPKv called 1077 returned 100% blocks executed 100%
     1077: 9368:void ImGui::PushID(const void* ptr_id)
        -: 9369:{
     1077: 9370:    ImGuiContext& g = *GImGui;
     1077: 9371:    ImGuiWindow* window = g.CurrentWindow;
     1077: 9372:    ImGuiID id = window->GetID(ptr_id);
     1077: 9372-block 2
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077: 9373:    window->IDStack.push_back(id);
     1077: 9373-block 3
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077: 9374:}
     1077: 9374-block 4
        -: 9375:
function _ZN5ImGui6PushIDEi called 74340 returned 100% blocks executed 100%
    74340: 9376:void ImGui::PushID(int int_id)
        -: 9377:{
    74340: 9378:    ImGuiContext& g = *GImGui;
    74340: 9379:    ImGuiWindow* window = g.CurrentWindow;
    74340: 9380:    ImGuiID id = window->GetID(int_id);
    74340: 9380-block 2
call    0 returned 74340
branch  1 taken 74340 (fallthrough)
branch  2 taken 0 (throw)
    74340: 9381:    window->IDStack.push_back(id);
    74340: 9381-block 3
call    0 returned 74340
branch  1 taken 74340 (fallthrough)
branch  2 taken 0 (throw)
    74340: 9382:}
    74340: 9382-block 4
        -: 9383:
        -: 9384:// Push a given id value ignoring the ID stack as a seed.
function _ZN5ImGui14PushOverrideIDEj called 6457 returned 100% blocks executed 75%
     6457: 9385:void ImGui::PushOverrideID(ImGuiID id)
        -: 9386:{
     6457: 9387:    ImGuiContext& g = *GImGui;
     6457: 9388:    ImGuiWindow* window = g.CurrentWindow;
        -: 9389:#ifndef IMGUI_DISABLE_DEBUG_TOOLS
     6457: 9390:    if (g.DebugHookIdInfo == id)
     6457: 9390-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 6457
    #####: 9391:        DebugHookIdInfo(id, ImGuiDataType_ID, NULL, NULL);
    %%%%%: 9391-block 3
call    0 never executed
        -: 9392:#endif
     6457: 9393:    window->IDStack.push_back(id);
     6457: 9393-block 4
call    0 returned 6457
     6457: 9394:}
        -: 9395:
        -: 9396:// Helper to avoid a common series of PushOverrideID -> GetID() -> PopID() call
        -: 9397:// (note that when using this pattern, ID Stack Tool will tend to not display the intermediate stack level.
        -: 9398://  for that to work we would need to do PushOverrideID() -> ItemAdd() -> PopID() which would alter widget code a little more)
function _ZN5ImGui13GetIDWithSeedEPKcS1_j called 4304 returned 100% blocks executed 75%
     4304: 9399:ImGuiID ImGui::GetIDWithSeed(const char* str, const char* str_end, ImGuiID seed)
        -: 9400:{
    4304*: 9401:    ImGuiID id = ImHashStr(str, str_end ? (str_end - str) : 0, seed);
     4304: 9401-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 4304
    %%%%%: 9401-block 3
     4304: 9401-block 4
     4304: 9401-block 5
call    2 returned 4304
        -: 9402:#ifndef IMGUI_DISABLE_DEBUG_TOOLS
     4304: 9403:    ImGuiContext& g = *GImGui;
     4304: 9404:    if (g.DebugHookIdInfo == id)
branch  0 taken 0 (fallthrough)
branch  1 taken 4304
    #####: 9405:        DebugHookIdInfo(id, ImGuiDataType_String, str, str_end);
    %%%%%: 9405-block 7
call    0 never executed
        -: 9406:#endif
     4304: 9407:    return id;
     4304: 9407-block 8
        -: 9408:}
        -: 9409:
function _ZN5ImGui13GetIDWithSeedEij called 0 returned 0% blocks executed 0%
    #####: 9410:ImGuiID ImGui::GetIDWithSeed(int n, ImGuiID seed)
        -: 9411:{
    #####: 9412:    ImGuiID id = ImHashData(&n, sizeof(n), seed);
    %%%%%: 9412-block 2
call    0 never executed
        -: 9413:#ifndef IMGUI_DISABLE_DEBUG_TOOLS
    #####: 9414:    ImGuiContext& g = *GImGui;
    #####: 9415:    if (g.DebugHookIdInfo == id)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9416:        DebugHookIdInfo(id, ImGuiDataType_S32, (void*)(intptr_t)n, NULL);
    %%%%%: 9416-block 4
call    0 never executed
        -: 9417:#endif
    #####: 9418:    return id;
    %%%%%: 9418-block 5
        -: 9419:}
        -: 9420:
function _ZN5ImGui5PopIDEv called 88336 returned 100% blocks executed 43%
    88336: 9421:void ImGui::PopID()
        -: 9422:{
    88336: 9423:    ImGuiWindow* window = GImGui->CurrentWindow;
    88336: 9424:    if (window->IDStack.Size <= 1)
    88336: 9424-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 88336
        -: 9425:    {
    #####: 9426:        IM_ASSERT_USER_ERROR(0, "Calling PopID() too many times!");
    %%%%%: 9426-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 9426-block 5
call    3 never executed
    #####: 9427:        return;
    %%%%%: 9427-block 6
        -: 9428:    }
    88336: 9429:    window->IDStack.pop_back();
    88336: 9429-block 7
call    0 returned 88336
        -: 9430:}
        -: 9431:
function _ZN5ImGui5GetIDEPKc called 16142 returned 100% blocks executed 100%
    16142: 9432:ImGuiID ImGui::GetID(const char* str_id)
        -: 9433:{
    16142: 9434:    ImGuiWindow* window = GImGui->CurrentWindow;
    16142: 9435:    return window->GetID(str_id);
    16142: 9435-block 2
call    0 returned 16142
        -: 9436:}
        -: 9437:
function _ZN5ImGui5GetIDEPKcS1_ called 0 returned 0% blocks executed 0%
    #####: 9438:ImGuiID ImGui::GetID(const char* str_id_begin, const char* str_id_end)
        -: 9439:{
    #####: 9440:    ImGuiWindow* window = GImGui->CurrentWindow;
    #####: 9441:    return window->GetID(str_id_begin, str_id_end);
    %%%%%: 9441-block 2
call    0 never executed
        -: 9442:}
        -: 9443:
function _ZN5ImGui5GetIDEPKv called 0 returned 0% blocks executed 0%
    #####: 9444:ImGuiID ImGui::GetID(const void* ptr_id)
        -: 9445:{
    #####: 9446:    ImGuiWindow* window = GImGui->CurrentWindow;
    #####: 9447:    return window->GetID(ptr_id);
    %%%%%: 9447-block 2
call    0 never executed
        -: 9448:}
        -: 9449:
function _ZN5ImGui5GetIDEi called 0 returned 0% blocks executed 0%
    #####: 9450:ImGuiID ImGui::GetID(int int_id)
        -: 9451:{
    #####: 9452:    ImGuiWindow* window = GImGui->CurrentWindow;
    #####: 9453:    return window->GetID(int_id);
    %%%%%: 9453-block 2
call    0 never executed
        -: 9454:}
        -: 9455:IM_MSVC_RUNTIME_CHECKS_RESTORE
        -: 9456:
        -: 9457://-----------------------------------------------------------------------------
        -: 9458:// [SECTION] INPUTS
        -: 9459://-----------------------------------------------------------------------------
        -: 9460:// - GetModForLRModKey() [Internal]
        -: 9461:// - FixupKeyChord() [Internal]
        -: 9462:// - GetKeyData() [Internal]
        -: 9463:// - GetKeyIndex() [Internal]
        -: 9464:// - GetKeyName()
        -: 9465:// - GetKeyChordName() [Internal]
        -: 9466:// - CalcTypematicRepeatAmount() [Internal]
        -: 9467:// - GetTypematicRepeatRate() [Internal]
        -: 9468:// - GetKeyPressedAmount() [Internal]
        -: 9469:// - GetKeyMagnitude2d() [Internal]
        -: 9470://-----------------------------------------------------------------------------
        -: 9471:// - UpdateKeyRoutingTable() [Internal]
        -: 9472:// - GetRoutingIdFromOwnerId() [Internal]
        -: 9473:// - GetShortcutRoutingData() [Internal]
        -: 9474:// - CalcRoutingScore() [Internal]
        -: 9475:// - SetShortcutRouting() [Internal]
        -: 9476:// - TestShortcutRouting() [Internal]
        -: 9477://-----------------------------------------------------------------------------
        -: 9478:// - IsKeyDown()
        -: 9479:// - IsKeyPressed()
        -: 9480:// - IsKeyReleased()
        -: 9481://-----------------------------------------------------------------------------
        -: 9482:// - IsMouseDown()
        -: 9483:// - IsMouseClicked()
        -: 9484:// - IsMouseReleased()
        -: 9485:// - IsMouseDoubleClicked()
        -: 9486:// - GetMouseClickedCount()
        -: 9487:// - IsMouseHoveringRect() [Internal]
        -: 9488:// - IsMouseDragPastThreshold() [Internal]
        -: 9489:// - IsMouseDragging()
        -: 9490:// - GetMousePos()
        -: 9491:// - SetMousePos() [Internal]
        -: 9492:// - GetMousePosOnOpeningCurrentPopup()
        -: 9493:// - IsMousePosValid()
        -: 9494:// - IsAnyMouseDown()
        -: 9495:// - GetMouseDragDelta()
        -: 9496:// - ResetMouseDragDelta()
        -: 9497:// - GetMouseCursor()
        -: 9498:// - SetMouseCursor()
        -: 9499://-----------------------------------------------------------------------------
        -: 9500:// - UpdateAliasKey()
        -: 9501:// - GetMergedModsFromKeys()
        -: 9502:// - UpdateKeyboardInputs()
        -: 9503:// - UpdateMouseInputs()
        -: 9504://-----------------------------------------------------------------------------
        -: 9505:// - LockWheelingWindow [Internal]
        -: 9506:// - FindBestWheelingWindow [Internal]
        -: 9507:// - UpdateMouseWheel() [Internal]
        -: 9508://-----------------------------------------------------------------------------
        -: 9509:// - SetNextFrameWantCaptureKeyboard()
        -: 9510:// - SetNextFrameWantCaptureMouse()
        -: 9511://-----------------------------------------------------------------------------
        -: 9512:// - GetInputSourceName() [Internal]
        -: 9513:// - DebugPrintInputEvent() [Internal]
        -: 9514:// - UpdateInputEvents() [Internal]
        -: 9515://-----------------------------------------------------------------------------
        -: 9516:// - GetKeyOwner() [Internal]
        -: 9517:// - TestKeyOwner() [Internal]
        -: 9518:// - SetKeyOwner() [Internal]
        -: 9519:// - SetItemKeyOwner() [Internal]
        -: 9520:// - Shortcut() [Internal]
        -: 9521://-----------------------------------------------------------------------------
        -: 9522:
function _ZL17GetModForLRModKey8ImGuiKey called 0 returned 0% blocks executed 0%
    #####: 9523:static ImGuiKeyChord GetModForLRModKey(ImGuiKey key)
        -: 9524:{
    #####: 9525:    if (key == ImGuiKey_LeftCtrl || key == ImGuiKey_RightCtrl)
    %%%%%: 9525-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9525-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 9526:        return ImGuiMod_Ctrl;
    %%%%%: 9526-block 4
    #####: 9527:    if (key == ImGuiKey_LeftShift || key == ImGuiKey_RightShift)
    %%%%%: 9527-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9527-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 9528:        return ImGuiMod_Shift;
    %%%%%: 9528-block 7
    #####: 9529:    if (key == ImGuiKey_LeftAlt || key == ImGuiKey_RightAlt)
    %%%%%: 9529-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9529-block 9
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 9530:        return ImGuiMod_Alt;
    %%%%%: 9530-block 10
    #####: 9531:    if (key == ImGuiKey_LeftSuper || key == ImGuiKey_RightSuper)
    %%%%%: 9531-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9531-block 12
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 9532:        return ImGuiMod_Super;
    %%%%%: 9532-block 13
    #####: 9533:    return ImGuiMod_None;
    %%%%%: 9533-block 14
        -: 9534:}
        -: 9535:
function _ZN5ImGui13FixupKeyChordEi called 4308 returned 100% blocks executed 67%
     4308: 9536:ImGuiKeyChord ImGui::FixupKeyChord(ImGuiKeyChord key_chord)
        -: 9537:{
        -: 9538:    // Add ImGuiMod_XXXX when a corresponding ImGuiKey_LeftXXX/ImGuiKey_RightXXX is specified.
     4308: 9539:    ImGuiKey key = (ImGuiKey)(key_chord & ~ImGuiMod_Mask_);
     4308: 9540:    if (IsLRModKey(key))
     4308: 9540-block 2
call    0 returned 4308
branch  1 taken 0 (fallthrough)
branch  2 taken 4308
    #####: 9541:        key_chord |= GetModForLRModKey(key);
    %%%%%: 9541-block 4
call    0 never executed
     4308: 9542:    return key_chord;
     4308: 9542-block 6
        -: 9543:}
        -: 9544:
function _ZN5ImGui10GetKeyDataEP12ImGuiContext8ImGuiKey called 62868 returned 100% blocks executed 93%
    62868: 9545:ImGuiKeyData* ImGui::GetKeyData(ImGuiContext* ctx, ImGuiKey key)
        -: 9546:{
    62868: 9547:    ImGuiContext& g = *ctx;
        -: 9548:
        -: 9549:    // Special storage location for mods
    62868: 9550:    if (key & ImGuiMod_Mask_)
    62868: 9550-block 2
branch  0 taken 8677 (fallthrough)
branch  1 taken 54191
     8677: 9551:        key = ConvertSingleModFlagToKey(key);
     8677: 9551-block 3
call    0 returned 8677
        -: 9552:
        -: 9553:#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
   62868*: 9554:    IM_ASSERT(key >= ImGuiKey_LegacyNativeKey_BEGIN && key < ImGuiKey_NamedKey_END);
    62868: 9554-block 4
branch  0 taken 62868 (fallthrough)
branch  1 taken 0
    62868: 9554-block 5
branch  2 taken 62868 (fallthrough)
branch  3 taken 0
    62868: 9554-block 6
    %%%%%: 9554-block 7
call    4 never executed
    62868: 9555:    if (IsLegacyKey(key) && g.IO.KeyMap[key] != -1)
    62868: 9555-block 8
call    0 returned 62868
branch  1 taken 20 (fallthrough)
branch  2 taken 62848
       20: 9555-block 10
branch  3 taken 20 (fallthrough)
branch  4 taken 0
       20: 9555-block 11
    62848: 9555-block 12
    62868: 9555-block 13
branch  5 taken 20 (fallthrough)
branch  6 taken 62848
       20: 9556:        key = (ImGuiKey)g.IO.KeyMap[key];  // Remap native->imgui or imgui->native
       20: 9556-block 14
        -: 9557:#else
        -: 9558:    IM_ASSERT(IsNamedKey(key) && "Support for user key indices was dropped in favor of ImGuiKey. Please update backend & user code.");
        -: 9559:#endif
    62868: 9560:    return &g.IO.KeysData[key - ImGuiKey_KeysData_OFFSET];
    62868: 9560-block 15
        -: 9561:}
        -: 9562:
        -: 9563:#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
        -: 9564:// Formally moved to obsolete section in 1.90.5 in spite of documented as obsolete since 1.87
function _ZN5ImGui11GetKeyIndexE8ImGuiKey called 11642 returned 100% blocks executed 83%
    11642: 9565:ImGuiKey ImGui::GetKeyIndex(ImGuiKey key)
        -: 9566:{
    11642: 9567:    ImGuiContext& g = *GImGui;
   11642*: 9568:    IM_ASSERT(IsNamedKey(key));
    11642: 9568-block 2
call    0 returned 11642
branch  1 taken 0 (fallthrough)
branch  2 taken 11642
    %%%%%: 9568-block 4
call    3 never executed
    11642: 9569:    const ImGuiKeyData* key_data = GetKeyData(key);
    11642: 9569-block 5
call    0 returned 11642
    11642: 9570:    return (ImGuiKey)(key_data - g.IO.KeysData);
        -: 9571:}
        -: 9572:#endif
        -: 9573:
        -: 9574:// Those names a provided for debugging purpose and are not meant to be saved persistently not compared.
        -: 9575:static const char* const GKeyNames[] =
        -: 9576:{
        -: 9577:    "Tab", "LeftArrow", "RightArrow", "UpArrow", "DownArrow", "PageUp", "PageDown",
        -: 9578:    "Home", "End", "Insert", "Delete", "Backspace", "Space", "Enter", "Escape",
        -: 9579:    "LeftCtrl", "LeftShift", "LeftAlt", "LeftSuper", "RightCtrl", "RightShift", "RightAlt", "RightSuper", "Menu",
        -: 9580:    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H",
        -: 9581:    "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z",
        -: 9582:    "F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "F10", "F11", "F12",
        -: 9583:    "F13", "F14", "F15", "F16", "F17", "F18", "F19", "F20", "F21", "F22", "F23", "F24",
        -: 9584:    "Apostrophe", "Comma", "Minus", "Period", "Slash", "Semicolon", "Equal", "LeftBracket",
        -: 9585:    "Backslash", "RightBracket", "GraveAccent", "CapsLock", "ScrollLock", "NumLock", "PrintScreen",
        -: 9586:    "Pause", "Keypad0", "Keypad1", "Keypad2", "Keypad3", "Keypad4", "Keypad5", "Keypad6",
        -: 9587:    "Keypad7", "Keypad8", "Keypad9", "KeypadDecimal", "KeypadDivide", "KeypadMultiply",
        -: 9588:    "KeypadSubtract", "KeypadAdd", "KeypadEnter", "KeypadEqual",
        -: 9589:    "AppBack", "AppForward",
        -: 9590:    "GamepadStart", "GamepadBack",
        -: 9591:    "GamepadFaceLeft", "GamepadFaceRight", "GamepadFaceUp", "GamepadFaceDown",
        -: 9592:    "GamepadDpadLeft", "GamepadDpadRight", "GamepadDpadUp", "GamepadDpadDown",
        -: 9593:    "GamepadL1", "GamepadR1", "GamepadL2", "GamepadR2", "GamepadL3", "GamepadR3",
        -: 9594:    "GamepadLStickLeft", "GamepadLStickRight", "GamepadLStickUp", "GamepadLStickDown",
        -: 9595:    "GamepadRStickLeft", "GamepadRStickRight", "GamepadRStickUp", "GamepadRStickDown",
        -: 9596:    "MouseLeft", "MouseRight", "MouseMiddle", "MouseX1", "MouseX2", "MouseWheelX", "MouseWheelY",
        -: 9597:    "ModCtrl", "ModShift", "ModAlt", "ModSuper", // ReservedForModXXX are showing the ModXXX names.
        -: 9598:};
        -: 9599:IM_STATIC_ASSERT(ImGuiKey_NamedKey_COUNT == IM_ARRAYSIZE(GKeyNames));
        -: 9600:
function _ZN5ImGui10GetKeyNameE8ImGuiKey called 0 returned 0% blocks executed 0%
    #####: 9601:const char* ImGui::GetKeyName(ImGuiKey key)
        -: 9602:{
    #####: 9603:    if (key == ImGuiKey_None)
    %%%%%: 9603-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9604:        return "None";
    %%%%%: 9604-block 3
        -: 9605:#ifdef IMGUI_DISABLE_OBSOLETE_KEYIO
        -: 9606:    IM_ASSERT(IsNamedKeyOrMod(key) && "Support for user key indices was dropped in favor of ImGuiKey. Please update backend and user code.");
        -: 9607:#else
    #####: 9608:    ImGuiContext& g = *GImGui;
    #####: 9609:    if (IsLegacyKey(key))
    %%%%%: 9609-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -: 9610:    {
    #####: 9611:        if (g.IO.KeyMap[key] == -1)
    %%%%%: 9611-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9612:            return "N/A";
    %%%%%: 9612-block 7
    #####: 9613:        IM_ASSERT(IsNamedKey((ImGuiKey)g.IO.KeyMap[key]));
    %%%%%: 9613-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 9613-block 10
call    3 never executed
    #####: 9614:        key = (ImGuiKey)g.IO.KeyMap[key];
    %%%%%: 9614-block 11
        -: 9615:    }
        -: 9616:#endif
    #####: 9617:    if (key & ImGuiMod_Mask_)
    %%%%%: 9617-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9618:        key = ConvertSingleModFlagToKey(key);
    %%%%%: 9618-block 13
call    0 never executed
    #####: 9619:    if (!IsNamedKey(key))
    %%%%%: 9619-block 14
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 9620:        return "Unknown";
    %%%%%: 9620-block 16
        -: 9621:
    #####: 9622:    return GKeyNames[key - ImGuiKey_NamedKey_BEGIN];
    %%%%%: 9622-block 17
        -: 9623:}
        -: 9624:
        -: 9625:// Return untranslated names: on macOS, Cmd key will show as Ctrl, Ctrl key will show as super.
        -: 9626:// Lifetime of return value: valid until next call to same function.
function _ZN5ImGui15GetKeyChordNameEi called 0 returned 0% blocks executed 0%
    #####: 9627:const char* ImGui::GetKeyChordName(ImGuiKeyChord key_chord)
        -: 9628:{
    #####: 9629:    ImGuiContext& g = *GImGui;
        -: 9630:
    #####: 9631:    const ImGuiKey key = (ImGuiKey)(key_chord & ~ImGuiMod_Mask_);
    #####: 9632:    if (IsLRModKey(key))
    %%%%%: 9632-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 9633:        key_chord &= ~GetModForLRModKey(key); // Return "Ctrl+LeftShift" instead of "Ctrl+Shift+LeftShift"
    %%%%%: 9633-block 4
call    0 never executed
    #####: 9634:    ImFormatString(g.TempKeychordName, IM_ARRAYSIZE(g.TempKeychordName), "%s%s%s%s%s",
    %%%%%: 9634-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9634-block 10
    %%%%%: 9634-block 12
    %%%%%: 9634-block 13
    %%%%%: 9634-block 15
    %%%%%: 9634-block 16
    %%%%%: 9634-block 18
    %%%%%: 9634-block 19
    %%%%%: 9634-block 21
    %%%%%: 9634-block 22
    %%%%%: 9634-block 23
call    2 never executed
    #####: 9635:        (key_chord & ImGuiMod_Ctrl) ? "Ctrl+" : "",
    %%%%%: 9635-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9636:        (key_chord & ImGuiMod_Shift) ? "Shift+" : "",
    %%%%%: 9636-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9637:        (key_chord & ImGuiMod_Alt) ? "Alt+" : "",
    %%%%%: 9637-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9638:        (key_chord & ImGuiMod_Super) ? "Super+" : "",
    %%%%%: 9638-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9639:        (key != ImGuiKey_None || key_chord == ImGuiKey_None) ? GetKeyName(key) : "");
    %%%%%: 9639-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9639-block 8
call    2 never executed
        -: 9640:    size_t len;
    #####: 9641:    if (key == ImGuiKey_None && key_chord != 0)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9641-block 25
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 9642:        if ((len = strlen(g.TempKeychordName)) != 0) // Remove trailing '+'
    %%%%%: 9642-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9643:            g.TempKeychordName[len - 1] = 0;
    %%%%%: 9643-block 27
    #####: 9644:    return g.TempKeychordName;
    %%%%%: 9644-block 28
        -: 9645:}
        -: 9646:
        -: 9647:// t0 = previous time (e.g.: g.Time - g.IO.DeltaTime)
        -: 9648:// t1 = current time (e.g.: g.Time)
        -: 9649:// An event is triggered at:
        -: 9650://  t = 0.0f     t = repeat_delay,    t = repeat_delay + repeat_rate*N
function _ZN5ImGui25CalcTypematicRepeatAmountEffff called 0 returned 0% blocks executed 0%
    #####: 9651:int ImGui::CalcTypematicRepeatAmount(float t0, float t1, float repeat_delay, float repeat_rate)
        -: 9652:{
    #####: 9653:    if (t1 == 0.0f)
    %%%%%: 9653-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9654:        return 1;
    %%%%%: 9654-block 3
    #####: 9655:    if (t0 >= t1)
    %%%%%: 9655-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9656:        return 0;
    %%%%%: 9656-block 5
    #####: 9657:    if (repeat_rate <= 0.0f)
    %%%%%: 9657-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9658:        return (t0 < repeat_delay) && (t1 >= repeat_delay);
    %%%%%: 9658-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9658-block 8
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 9658-block 9
    %%%%%: 9658-block 10
    %%%%%: 9658-block 11
    #####: 9659:    const int count_t0 = (t0 < repeat_delay) ? -1 : (int)((t0 - repeat_delay) / repeat_rate);
    %%%%%: 9659-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9659-block 13
    %%%%%: 9659-block 14
    #####: 9660:    const int count_t1 = (t1 < repeat_delay) ? -1 : (int)((t1 - repeat_delay) / repeat_rate);
    %%%%%: 9660-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9660-block 16
    %%%%%: 9660-block 17
    #####: 9661:    const int count = count_t1 - count_t0;
    #####: 9662:    return count;
    %%%%%: 9662-block 18
        -: 9663:}
        -: 9664:
function _ZN5ImGui22GetTypematicRepeatRateEiPfS0_ called 0 returned 0% blocks executed 0%
    #####: 9665:void ImGui::GetTypematicRepeatRate(ImGuiInputFlags flags, float* repeat_delay, float* repeat_rate)
        -: 9666:{
    #####: 9667:    ImGuiContext& g = *GImGui;
    #####: 9668:    switch (flags & ImGuiInputFlags_RepeatRateMask_)
    %%%%%: 9668-block 2
branch  0 never executed
branch  1 never executed
branch  2 never executed
        -: 9669:    {
    #####: 9670:    case ImGuiInputFlags_RepeatRateNavMove:             *repeat_delay = g.IO.KeyRepeatDelay * 0.72f; *repeat_rate = g.IO.KeyRepeatRate * 0.80f; return;
    %%%%%: 9670-block 3
    #####: 9671:    case ImGuiInputFlags_RepeatRateNavTweak:            *repeat_delay = g.IO.KeyRepeatDelay * 0.72f; *repeat_rate = g.IO.KeyRepeatRate * 0.30f; return;
    %%%%%: 9671-block 4
    #####: 9672:    case ImGuiInputFlags_RepeatRateDefault: default:    *repeat_delay = g.IO.KeyRepeatDelay * 1.00f; *repeat_rate = g.IO.KeyRepeatRate * 1.00f; return;
    %%%%%: 9672-block 5
        -: 9673:    }
        -: 9674:}
        -: 9675:
        -: 9676:// Return value representing the number of presses in the last time period, for the given repeat rate
        -: 9677:// (most often returns 0 or 1. The result is generally only >1 when RepeatRate is smaller than DeltaTime, aka large DeltaTime or fast RepeatRate)
function _ZN5ImGui19GetKeyPressedAmountE8ImGuiKeyff called 0 returned 0% blocks executed 0%
    #####: 9678:int ImGui::GetKeyPressedAmount(ImGuiKey key, float repeat_delay, float repeat_rate)
        -: 9679:{
    #####: 9680:    ImGuiContext& g = *GImGui;
    #####: 9681:    const ImGuiKeyData* key_data = GetKeyData(key);
    %%%%%: 9681-block 2
call    0 never executed
    #####: 9682:    if (!key_data->Down) // In theory this should already be encoded as (DownDuration < 0.0f), but testing this facilitates eating mechanism (until we finish work on key ownership)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9683:        return 0;
    %%%%%: 9683-block 4
    #####: 9684:    const float t = key_data->DownDuration;
    #####: 9685:    return CalcTypematicRepeatAmount(t - g.IO.DeltaTime, t, repeat_delay, repeat_rate);
    %%%%%: 9685-block 5
call    0 never executed
        -: 9686:}
        -: 9687:
        -: 9688:// Return 2D vector representing the combination of four cardinal direction, with analog value support (for e.g. ImGuiKey_GamepadLStick* values).
function _ZN5ImGui17GetKeyMagnitude2dE8ImGuiKeyS0_S0_S0_ called 0 returned 0% blocks executed 0%
    #####: 9689:ImVec2 ImGui::GetKeyMagnitude2d(ImGuiKey key_left, ImGuiKey key_right, ImGuiKey key_up, ImGuiKey key_down)
        -: 9690:{
    #####: 9691:    return ImVec2(
    %%%%%: 9691-block 8
    #####: 9692:        GetKeyData(key_right)->AnalogValue - GetKeyData(key_left)->AnalogValue,
    %%%%%: 9692-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 9693:        GetKeyData(key_down)->AnalogValue - GetKeyData(key_up)->AnalogValue);
    %%%%%: 9693-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 9693-block 3
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    %%%%%: 9693-block 4
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed (throw)
    %%%%%: 9693-block 6
call    9 never executed
    %%%%%: 9693-block 9
        -: 9694:}
        -: 9695:
        -: 9696:// Rewrite routing data buffers to strip old entries + sort by key to make queries not touch scattered data.
        -: 9697://   Entries   D,A,B,B,A,C,B     --> A,A,B,B,B,C,D
        -: 9698://   Index     A:1 B:2 C:5 D:0   --> A:0 B:2 C:5 D:6
        -: 9699:// See 'Metrics->Key Owners & Shortcut Routing' to visualize the result of that operation.
function _ZN5ImGuiL21UpdateKeyRoutingTableEP20ImGuiKeyRoutingTable called 1077 returned 100% blocks executed 44%
     1077: 9700:static void ImGui::UpdateKeyRoutingTable(ImGuiKeyRoutingTable* rt)
        -: 9701:{
     1077: 9702:    ImGuiContext& g = *GImGui;
     1077: 9703:    rt->EntriesNext.resize(0);
     1077: 9703-block 2
call    0 returned 1077
   166935: 9704:    for (ImGuiKey key = ImGuiKey_NamedKey_BEGIN; key < ImGuiKey_NamedKey_END; key = (ImGuiKey)(key + 1))
   165858: 9704-block 25
   166935: 9704-block 26
branch  0 taken 165858
branch  1 taken 1077 (fallthrough)
        -: 9705:    {
   165858: 9706:        const int new_routing_start_idx = rt->EntriesNext.Size;
        -: 9707:        ImGuiKeyRoutingData* routing_entry;
  165858*: 9708:        for (int old_routing_idx = rt->Index[key - ImGuiKey_NamedKey_BEGIN]; old_routing_idx != -1; old_routing_idx = routing_entry->NextEntryIndex)
   165858: 9708-block 4
    %%%%%: 9708-block 13
   165858: 9708-block 14
branch  0 taken 0
branch  1 taken 165858 (fallthrough)
        -: 9709:        {
    #####: 9710:            routing_entry = &rt->Entries[old_routing_idx];
    %%%%%: 9710-block 5
call    0 never executed
    #####: 9711:            routing_entry->RoutingCurrScore = routing_entry->RoutingNextScore;
    #####: 9712:            routing_entry->RoutingCurr = routing_entry->RoutingNext; // Update entry
    #####: 9713:            routing_entry->RoutingNext = ImGuiKeyOwner_NoOwner;
    #####: 9714:            routing_entry->RoutingNextScore = 255;
    #####: 9715:            if (routing_entry->RoutingCurr == ImGuiKeyOwner_NoOwner)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9716:                continue;
    %%%%%: 9716-block 7
    #####: 9717:            rt->EntriesNext.push_back(*routing_entry); // Write alive ones into new buffer
    %%%%%: 9717-block 8
call    0 never executed
        -: 9718:
        -: 9719:            // Apply routing to owner if there's no owner already (RoutingCurr == None at this point)
        -: 9720:            // This is the result of previous frame's SetShortcutRouting() call.
    #####: 9721:            if (routing_entry->Mods == g.IO.KeyMods)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 9722:            {
    #####: 9723:                ImGuiKeyOwnerData* owner_data = GetKeyOwnerData(&g, key);
    %%%%%: 9723-block 10
call    0 never executed
    #####: 9724:                if (owner_data->OwnerCurr == ImGuiKeyOwner_NoOwner)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 9725:                {
    #####: 9726:                    owner_data->OwnerCurr = routing_entry->RoutingCurr;
    %%%%%: 9726-block 12
        -: 9727:                    //IMGUI_DEBUG_LOG("SetKeyOwner(%s, owner_id=0x%08X) via Routing\n", GetKeyName(key), routing_entry->RoutingCurr);
        -: 9728:                }
        -: 9729:            }
        -: 9730:        }
        -: 9731:
        -: 9732:        // Rewrite linked-list
  165858*: 9733:        rt->Index[key - ImGuiKey_NamedKey_BEGIN] = (ImGuiKeyRoutingIndex)(new_routing_start_idx < rt->EntriesNext.Size ? new_routing_start_idx : -1);
   165858: 9733-block 15
branch  0 taken 0 (fallthrough)
branch  1 taken 165858
    %%%%%: 9733-block 16
   165858: 9733-block 17
  165858*: 9734:        for (int n = new_routing_start_idx; n < rt->EntriesNext.Size; n++)
   165858: 9734-block 18
   165858: 9734-block 24
branch  0 taken 0
branch  1 taken 165858 (fallthrough)
    #####: 9735:            rt->EntriesNext[n].NextEntryIndex = (ImGuiKeyRoutingIndex)((n + 1 < rt->EntriesNext.Size) ? n + 1 : -1);
    %%%%%: 9735-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9735-block 20
    %%%%%: 9735-block 21
    %%%%%: 9735-block 22
call    2 never executed
        -: 9736:    }
     1077: 9737:    rt->Entries.swap(rt->EntriesNext); // Swap new and old indexes
     1077: 9737-block 27
call    0 returned 1077
     1077: 9738:}
        -: 9739:
        -: 9740:// owner_id may be None/Any, but routing_id needs to be always be set, so we default to GetCurrentFocusScope().
function _ZL23GetRoutingIdFromOwnerIdj called 0 returned 0% blocks executed 0%
    #####: 9741:static inline ImGuiID GetRoutingIdFromOwnerId(ImGuiID owner_id)
        -: 9742:{
    #####: 9743:    ImGuiContext& g = *GImGui;
    #####: 9744:    return (owner_id != ImGuiKeyOwner_NoOwner && owner_id != ImGuiKeyOwner_Any) ? owner_id : g.CurrentFocusScopeId;
    %%%%%: 9744-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9744-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 9744-block 4
    %%%%%: 9744-block 5
    %%%%%: 9744-block 6
        -: 9745:}
        -: 9746:
function _ZN5ImGui22GetShortcutRoutingDataEi called 0 returned 0% blocks executed 0%
    #####: 9747:ImGuiKeyRoutingData* ImGui::GetShortcutRoutingData(ImGuiKeyChord key_chord)
        -: 9748:{
        -: 9749:    // Majority of shortcuts will be Key + any number of Mods
        -: 9750:    // We accept _Single_ mod with ImGuiKey_None.
        -: 9751:    //  - Shortcut(ImGuiKey_S | ImGuiMod_Ctrl);                    // Legal
        -: 9752:    //  - Shortcut(ImGuiKey_S | ImGuiMod_Ctrl | ImGuiMod_Shift);   // Legal
        -: 9753:    //  - Shortcut(ImGuiMod_Ctrl);                                 // Legal
        -: 9754:    //  - Shortcut(ImGuiMod_Ctrl | ImGuiMod_Shift);                // Not legal
    #####: 9755:    ImGuiContext& g = *GImGui;
    #####: 9756:    ImGuiKeyRoutingTable* rt = &g.KeysRoutingTable;
        -: 9757:    ImGuiKeyRoutingData* routing_data;
    #####: 9758:    ImGuiKey key = (ImGuiKey)(key_chord & ~ImGuiMod_Mask_);
    #####: 9759:    ImGuiKey mods = (ImGuiKey)(key_chord & ImGuiMod_Mask_);
    #####: 9760:    if (key == ImGuiKey_None)
    %%%%%: 9760-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9761:        key = ConvertSingleModFlagToKey(mods);
    %%%%%: 9761-block 3
call    0 never executed
    #####: 9762:    IM_ASSERT(IsNamedKey(key));
    %%%%%: 9762-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 9762-block 6
call    3 never executed
        -: 9763:
        -: 9764:    // Get (in the majority of case, the linked list will have one element so this should be 2 reads.
        -: 9765:    // Subsequent elements will be contiguous in memory as list is sorted/rebuilt in NewFrame).
    #####: 9766:    for (ImGuiKeyRoutingIndex idx = rt->Index[key - ImGuiKey_NamedKey_BEGIN]; idx != -1; idx = routing_data->NextEntryIndex)
    %%%%%: 9766-block 7
    %%%%%: 9766-block 11
    %%%%%: 9766-block 12
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 9767:    {
    #####: 9768:        routing_data = &rt->Entries[idx];
    %%%%%: 9768-block 8
call    0 never executed
    #####: 9769:        if (routing_data->Mods == mods)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9770:            return routing_data;
    %%%%%: 9770-block 10
        -: 9771:    }
        -: 9772:
        -: 9773:    // Add to linked-list
    #####: 9774:    ImGuiKeyRoutingIndex routing_data_idx = (ImGuiKeyRoutingIndex)rt->Entries.Size;
    #####: 9775:    rt->Entries.push_back(ImGuiKeyRoutingData());
    %%%%%: 9775-block 13
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####: 9776:    routing_data = &rt->Entries[routing_data_idx];
    %%%%%: 9776-block 15
call    0 never executed
    #####: 9777:    routing_data->Mods = (ImU16)mods;
    #####: 9778:    routing_data->NextEntryIndex = rt->Index[key - ImGuiKey_NamedKey_BEGIN]; // Setup linked list
    #####: 9779:    rt->Index[key - ImGuiKey_NamedKey_BEGIN] = routing_data_idx;
    #####: 9780:    return routing_data;
        -: 9781:}
        -: 9782:
        -: 9783:// Current score encoding (lower is highest priority):
        -: 9784://  -   0: ImGuiInputFlags_RouteGlobal | ImGuiInputFlags_RouteOverActive
        -: 9785://  -   1: ImGuiInputFlags_ActiveItem or ImGuiInputFlags_RouteFocused (if item active)
        -: 9786://  -   2: ImGuiInputFlags_RouteGlobal | ImGuiInputFlags_RouteOverFocused
        -: 9787://  -  3+: ImGuiInputFlags_RouteFocused (if window in focus-stack)
        -: 9788://  - 254: ImGuiInputFlags_RouteGlobal
        -: 9789://  - 255: never route
        -: 9790:// 'flags' should include an explicit routing policy
function _ZL16CalcRoutingScorejji called 0 returned 0% blocks executed 0%
    #####: 9791:static int CalcRoutingScore(ImGuiID focus_scope_id, ImGuiID owner_id, ImGuiInputFlags flags)
        -: 9792:{
    #####: 9793:    ImGuiContext& g = *GImGui;
    #####: 9794:    if (flags & ImGuiInputFlags_RouteFocused)
    %%%%%: 9794-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 9795:    {
        -: 9796:        // ActiveID gets top priority
        -: 9797:        // (we don't check g.ActiveIdUsingAllKeys here. Routing is applied but if input ownership is tested later it may discard it)
    #####: 9798:        if (owner_id != 0 && g.ActiveId == owner_id)
    %%%%%: 9798-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9798-block 4
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 9799:            return 1;
    %%%%%: 9799-block 5
        -: 9800:
        -: 9801:        // Score based on distance to focused window (lower is better)
        -: 9802:        // Assuming both windows are submitting a routing request,
        -: 9803:        // - When Window....... is focused -> Window scores 3 (best), Window/ChildB scores 255 (no match)
        -: 9804:        // - When Window/ChildB is focused -> Window scores 4,        Window/ChildB scores 3 (best)
        -: 9805:        // Assuming only WindowA is submitting a routing request,
        -: 9806:        // - When Window/ChildB is focused -> Window scores 4 (best), Window/ChildB doesn't have a score.
        -: 9807:        // This essentially follow the window->ParentWindowForFocusRoute chain.
    #####: 9808:        if (focus_scope_id == 0)
    %%%%%: 9808-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9809:            return 255;
    %%%%%: 9809-block 7
    #####: 9810:        for (int index_in_focus_path = 0; index_in_focus_path < g.NavFocusRoute.Size; index_in_focus_path++)
    %%%%%: 9810-block 8
    %%%%%: 9810-block 11
    %%%%%: 9810-block 12
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 9811:            if (g.NavFocusRoute.Data[index_in_focus_path].ID == focus_scope_id)
    %%%%%: 9811-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9812:                return 3 + index_in_focus_path;
    %%%%%: 9812-block 10
    #####: 9813:        return 255;
    %%%%%: 9813-block 13
        -: 9814:    }
    #####: 9815:    else if (flags & ImGuiInputFlags_RouteActive)
    %%%%%: 9815-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 9816:    {
    #####: 9817:        if (owner_id != 0 && g.ActiveId == owner_id)
    %%%%%: 9817-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9817-block 16
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 9818:            return 1;
    %%%%%: 9818-block 17
    #####: 9819:        return 255;
    %%%%%: 9819-block 18
        -: 9820:    }
    #####: 9821:    else if (flags & ImGuiInputFlags_RouteGlobal)
    %%%%%: 9821-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 9822:    {
    #####: 9823:        if (flags & ImGuiInputFlags_RouteOverActive)
    %%%%%: 9823-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9824:            return 0;
    %%%%%: 9824-block 21
    #####: 9825:        if (flags & ImGuiInputFlags_RouteOverFocused)
    %%%%%: 9825-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9826:            return 2;
    %%%%%: 9826-block 23
    #####: 9827:        return 254;
    %%%%%: 9827-block 24
        -: 9828:    }
    #####: 9829:    IM_ASSERT(0);
    %%%%%: 9829-block 25
call    0 never executed
        -: 9830:    return 0;
        -: 9831:}
        -: 9832:
        -: 9833:// - We need this to filter some Shortcut() routes when an item e.g. an InputText() is active
        -: 9834://   e.g. ImGuiKey_G won't be considered a shortcut when item is active, but ImGuiMod|ImGuiKey_G can be.
        -: 9835:// - This is also used by UpdateInputEvents() to avoid trickling in the most common case of e.g. pressing ImGuiKey_G also emitting a G character.
function _ZL30IsKeyChordPotentiallyCharInputi called 2 returned 100% blocks executed 67%
        2: 9836:static bool IsKeyChordPotentiallyCharInput(ImGuiKeyChord key_chord)
        -: 9837:{
        -: 9838:    // Mimic 'ignore_char_inputs' logic in InputText()
        2: 9839:    ImGuiContext& g = *GImGui;
        -: 9840:
        -: 9841:    // When the right mods are pressed it cannot be a char input so we won't filter the shortcut out.
        2: 9842:    ImGuiKey mods = (ImGuiKey)(key_chord & ImGuiMod_Mask_);
       2*: 9843:    const bool ignore_char_inputs = ((mods & ImGuiMod_Ctrl) && !(mods & ImGuiMod_Alt)) || (g.IO.ConfigMacOSXBehaviors && (mods & ImGuiMod_Ctrl));
        2: 9843-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%: 9843-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
        2: 9843-block 4
branch  4 taken 0 (fallthrough)
branch  5 taken 2
    %%%%%: 9843-block 5
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 9843-block 6
        2: 9843-block 7
        2: 9844:    if (ignore_char_inputs)
        2: 9844-block 8
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####: 9845:        return false;
    %%%%%: 9845-block 9
        -: 9846:
        -: 9847:    // Return true for A-Z, 0-9 and other keys associated to char inputs. Other keys such as F1-F12 won't be filtered.
        2: 9848:    ImGuiKey key = (ImGuiKey)(key_chord & ~ImGuiMod_Mask_);
        2: 9849:    if (key == ImGuiKey_None)
        2: 9849-block 10
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1: 9850:        return false;
        1: 9850-block 11
        1: 9851:    return g.KeysMayBeCharInput.TestBit(key);
        1: 9851-block 12
call    0 returned 1
        -: 9852:}
        -: 9853:
        -: 9854:// Request a desired route for an input chord (key + mods).
        -: 9855:// Return true if the route is available this frame.
        -: 9856:// - Routes and key ownership are attributed at the beginning of next frame based on best score and mod state.
        -: 9857://   (Conceptually this does a "Submit for next frame" + "Test for current frame".
        -: 9858://   As such, it could be called TrySetXXX or SubmitXXX, or the Submit and Test operations should be separate.)
function _ZN5ImGui18SetShortcutRoutingEiij called 2154 returned 100% blocks executed 23%
     2154: 9859:bool ImGui::SetShortcutRouting(ImGuiKeyChord key_chord, ImGuiInputFlags flags, ImGuiID owner_id)
        -: 9860:{
     2154: 9861:    ImGuiContext& g = *GImGui;
     2154: 9862:    if ((flags & ImGuiInputFlags_RouteTypeMask_) == 0)
     2154: 9862-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 2154
    #####: 9863:        flags |= ImGuiInputFlags_RouteGlobal | ImGuiInputFlags_RouteOverFocused | ImGuiInputFlags_RouteOverActive; // IMPORTANT: This is the default for SetShortcutRouting() but NOT Shortcut()
    %%%%%: 9863-block 3
        -: 9864:    else
    2154*: 9865:        IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiInputFlags_RouteTypeMask_)); // Check that only 1 routing flag is used
     2154: 9865-block 4
call    0 returned 2154
branch  1 taken 0 (fallthrough)
branch  2 taken 2154
    %%%%%: 9865-block 6
call    3 never executed
    2154*: 9866:    IM_ASSERT(owner_id != ImGuiKeyOwner_Any && owner_id != ImGuiKeyOwner_NoOwner);
     2154: 9866-block 7
branch  0 taken 2154 (fallthrough)
branch  1 taken 0
     2154: 9866-block 8
branch  2 taken 2154 (fallthrough)
branch  3 taken 0
     2154: 9866-block 9
    %%%%%: 9866-block 10
call    4 never executed
     2154: 9867:    if (flags & (ImGuiInputFlags_RouteOverFocused | ImGuiInputFlags_RouteOverActive | ImGuiInputFlags_RouteUnlessBgFocused))
     2154: 9867-block 11
branch  0 taken 0 (fallthrough)
branch  1 taken 2154
    #####: 9868:        IM_ASSERT(flags & ImGuiInputFlags_RouteGlobal);
    %%%%%: 9868-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9868-block 13
call    2 never executed
        -: 9869:
        -: 9870:    // Add ImGuiMod_XXXX when a corresponding ImGuiKey_LeftXXX/ImGuiKey_RightXXX is specified.
     2154: 9871:    key_chord = FixupKeyChord(key_chord);
     2154: 9871-block 14
call    0 returned 2154
        -: 9872:
        -: 9873:    // [DEBUG] Debug break requested by user
     2154: 9874:    if (g.DebugBreakInShortcutRouting == key_chord)
branch  0 taken 0 (fallthrough)
branch  1 taken 2154
    #####: 9875:        IM_DEBUG_BREAK();
    %%%%%: 9875-block 16
call    0 never executed
        -: 9876:
     2154: 9877:    if (flags & ImGuiInputFlags_RouteUnlessBgFocused)
     2154: 9877-block 17
branch  0 taken 0 (fallthrough)
branch  1 taken 2154
    #####: 9878:        if (g.NavWindow == NULL)
    %%%%%: 9878-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9879:            return false;
    %%%%%: 9879-block 19
        -: 9880:
        -: 9881:    // Note how ImGuiInputFlags_RouteAlways won't set routing and thus won't set owner. May want to rework this?
     2154: 9882:    if (flags & ImGuiInputFlags_RouteAlways)
     2154: 9882-block 20
branch  0 taken 2154 (fallthrough)
branch  1 taken 0
        -: 9883:    {
    2154*: 9884:        IMGUI_DEBUG_LOG_INPUTROUTING("SetShortcutRouting(%s, flags=%04X, owner_id=0x%08X) -> always, no register\n", GetKeyChordName(key_chord), flags, owner_id);
     2154: 9884-block 21
branch  0 taken 0 (fallthrough)
branch  1 taken 2154
    %%%%%: 9884-block 22
call    2 never executed
call    3 never executed
     2154: 9885:        return true;
     2154: 9885-block 24
        -: 9886:    }
        -: 9887:
        -: 9888:    // Specific culling when there's an active item.
    #####: 9889:    if (g.ActiveId != 0 && g.ActiveId != owner_id)
    %%%%%: 9889-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9889-block 26
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 9890:    {
    #####: 9891:        if (flags & ImGuiInputFlags_RouteActive)
    %%%%%: 9891-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9892:            return false;
    %%%%%: 9892-block 28
        -: 9893:
        -: 9894:        // Cull shortcuts with no modifiers when it could generate a character.
        -: 9895:        // e.g. Shortcut(ImGuiKey_G) also generates 'g' character, should not trigger when InputText() is active.
        -: 9896:        // but  Shortcut(Ctrl+G) should generally trigger when InputText() is active.
        -: 9897:        // TL;DR: lettered shortcut with no mods or with only Alt mod will not trigger while an item reading text input is active.
        -: 9898:        // (We cannot filter based on io.InputQueueCharacters[] contents because of trickling and key<>chars submission order are undefined)
    #####: 9899:        if (g.IO.WantTextInput && IsKeyChordPotentiallyCharInput(key_chord))
    %%%%%: 9899-block 29
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9899-block 30
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 9899-block 32
    %%%%%: 9899-block 33
    %%%%%: 9899-block 34
branch  5 never executed (fallthrough)
branch  6 never executed
        -: 9900:        {
    #####: 9901:            IMGUI_DEBUG_LOG_INPUTROUTING("SetShortcutRouting(%s, flags=%04X, owner_id=0x%08X) -> filtered as potential char input\n", GetKeyChordName(key_chord), flags, owner_id);
    %%%%%: 9901-block 35
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9901-block 36
call    2 never executed
call    3 never executed
    #####: 9902:            return false;
    %%%%%: 9902-block 38
        -: 9903:        }
        -: 9904:
        -: 9905:        // ActiveIdUsingAllKeyboardKeys trumps all for ActiveId
    #####: 9906:        if ((flags & ImGuiInputFlags_RouteOverActive) == 0 && g.ActiveIdUsingAllKeyboardKeys)
    %%%%%: 9906-block 39
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9906-block 40
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 9907:        {
    #####: 9908:            ImGuiKey key = (ImGuiKey)(key_chord & ~ImGuiMod_Mask_);
    #####: 9909:            if (key == ImGuiKey_None)
    %%%%%: 9909-block 41
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9910:                key = ConvertSingleModFlagToKey((ImGuiKey)(key_chord & ImGuiMod_Mask_));
    %%%%%: 9910-block 42
call    0 never executed
    #####: 9911:            if (key >= ImGuiKey_Keyboard_BEGIN && key < ImGuiKey_Keyboard_END)
    %%%%%: 9911-block 43
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9911-block 44
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 9912:                return false;
    %%%%%: 9912-block 45
        -: 9913:        }
        -: 9914:    }
        -: 9915:
        -: 9916:    // Where do we evaluate route for?
    #####: 9917:    ImGuiID focus_scope_id = g.CurrentFocusScopeId;
    #####: 9918:    if (flags & ImGuiInputFlags_RouteFromRootWindow)
    %%%%%: 9918-block 46
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9919:        focus_scope_id = g.CurrentWindow->RootWindow->ID; // See PushFocusScope() call in Begin()
    %%%%%: 9919-block 47
        -: 9920:
    #####: 9921:    const int score = CalcRoutingScore(focus_scope_id, owner_id, flags);
    %%%%%: 9921-block 48
call    0 never executed
    #####: 9922:    IMGUI_DEBUG_LOG_INPUTROUTING("SetShortcutRouting(%s, flags=%04X, owner_id=0x%08X) -> score %d\n", GetKeyChordName(key_chord), flags, owner_id, score);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9922-block 50
call    2 never executed
call    3 never executed
    #####: 9923:    if (score == 255)
    %%%%%: 9923-block 52
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9924:        return false;
    %%%%%: 9924-block 53
        -: 9925:
        -: 9926:    // Submit routing for NEXT frame (assuming score is sufficient)
        -: 9927:    // FIXME: Could expose a way to use a "serve last" policy for same score resolution (using <= instead of <).
    #####: 9928:    ImGuiKeyRoutingData* routing_data = GetShortcutRoutingData(key_chord);
    %%%%%: 9928-block 54
call    0 never executed
        -: 9929:    //const bool set_route = (flags & ImGuiInputFlags_ServeLast) ? (score <= routing_data->RoutingNextScore) : (score < routing_data->RoutingNextScore);
    #####: 9930:    if (score < routing_data->RoutingNextScore)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 9931:    {
    #####: 9932:        routing_data->RoutingNext = owner_id;
    #####: 9933:        routing_data->RoutingNextScore = (ImU8)score;
    %%%%%: 9933-block 56
        -: 9934:    }
        -: 9935:
        -: 9936:    // Return routing state for CURRENT frame
    #####: 9937:    if (routing_data->RoutingCurr == owner_id)
    %%%%%: 9937-block 57
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9938:        IMGUI_DEBUG_LOG_INPUTROUTING("--> granting current route\n");
    %%%%%: 9938-block 58
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9938-block 59
call    2 never executed
    #####: 9939:    return routing_data->RoutingCurr == owner_id;
    %%%%%: 9939-block 60
        -: 9940:}
        -: 9941:
        -: 9942:// Currently unused by core (but used by tests)
        -: 9943:// Note: this cannot be turned into GetShortcutRouting() because we do the owner_id->routing_id translation, name would be more misleading.
function _ZN5ImGui19TestShortcutRoutingEij called 0 returned 0% blocks executed 0%
    #####: 9944:bool ImGui::TestShortcutRouting(ImGuiKeyChord key_chord, ImGuiID owner_id)
        -: 9945:{
    #####: 9946:    const ImGuiID routing_id = GetRoutingIdFromOwnerId(owner_id);
    %%%%%: 9946-block 2
call    0 never executed
    #####: 9947:    key_chord = FixupKeyChord(key_chord);
call    0 never executed
    #####: 9948:    ImGuiKeyRoutingData* routing_data = GetShortcutRoutingData(key_chord); // FIXME: Could avoid creating entry.
call    0 never executed
    #####: 9949:    return routing_data->RoutingCurr == routing_id;
        -: 9950:}
        -: 9951:
        -: 9952:// Note that Dear ImGui doesn't know the meaning/semantic of ImGuiKey from 0..511: they are legacy native keycodes.
        -: 9953:// Consider transitioning from 'IsKeyDown(MY_ENGINE_KEY_A)' (<1.87) to IsKeyDown(ImGuiKey_A) (>= 1.87)
function _ZN5ImGui9IsKeyDownE8ImGuiKey called 22645 returned 100% blocks executed 100%
    22645: 9954:bool ImGui::IsKeyDown(ImGuiKey key)
        -: 9955:{
    22645: 9956:    return IsKeyDown(key, ImGuiKeyOwner_Any);
    22645: 9956-block 2
call    0 returned 22645
        -: 9957:}
        -: 9958:
function _ZN5ImGui9IsKeyDownE8ImGuiKeyj called 24017 returned 100% blocks executed 88%
    24017: 9959:bool ImGui::IsKeyDown(ImGuiKey key, ImGuiID owner_id)
        -: 9960:{
    24017: 9961:    const ImGuiKeyData* key_data = GetKeyData(key);
    24017: 9961-block 2
call    0 returned 24017
    24017: 9962:    if (!key_data->Down)
branch  0 taken 23956 (fallthrough)
branch  1 taken 61
    23956: 9963:        return false;
    23956: 9963-block 4
       61: 9964:    if (!TestKeyOwner(key, owner_id))
       61: 9964-block 5
call    0 returned 61
branch  1 taken 0 (fallthrough)
branch  2 taken 61
    #####: 9965:        return false;
    %%%%%: 9965-block 7
       61: 9966:    return true;
       61: 9966-block 8
        -: 9967:}
        -: 9968:
function _ZN5ImGui12IsKeyPressedE8ImGuiKeyb called 11642 returned 100% blocks executed 83%
    11642: 9969:bool ImGui::IsKeyPressed(ImGuiKey key, bool repeat)
        -: 9970:{
   11642*: 9971:    return IsKeyPressed(key, repeat ? ImGuiInputFlags_Repeat : ImGuiInputFlags_None, ImGuiKeyOwner_Any);
    11642: 9971-block 2
branch  0 taken 11642 (fallthrough)
branch  1 taken 0
    11642: 9971-block 3
    %%%%%: 9971-block 4
    11642: 9971-block 5
call    2 returned 11642
        -: 9972:}
        -: 9973:
        -: 9974:// Important: unlike legacy IsKeyPressed(ImGuiKey, bool repeat=true) which DEFAULT to repeat, this requires EXPLICIT repeat.
function _ZN5ImGui12IsKeyPressedE8ImGuiKeyij called 19615 returned 100% blocks executed 14%
    19615: 9975:bool ImGui::IsKeyPressed(ImGuiKey key, ImGuiInputFlags flags, ImGuiID owner_id)
        -: 9976:{
    19615: 9977:    const ImGuiKeyData* key_data = GetKeyData(key);
    19615: 9977-block 2
call    0 returned 19615
    19615: 9978:    if (!key_data->Down) // In theory this should already be encoded as (DownDuration < 0.0f), but testing this facilitates eating mechanism (until we finish work on key ownership)
branch  0 taken 19615 (fallthrough)
branch  1 taken 0
    19615: 9979:        return false;
    19615: 9979-block 4
    #####: 9980:    const float t = key_data->DownDuration;
    #####: 9981:    if (t < 0.0f)
    %%%%%: 9981-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9982:        return false;
    %%%%%: 9982-block 6
    #####: 9983:    IM_ASSERT((flags & ~ImGuiInputFlags_SupportedByIsKeyPressed) == 0); // Passing flags not supported by this function!
    %%%%%: 9983-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9983-block 8
call    2 never executed
    #####: 9984:    if (flags & (ImGuiInputFlags_RepeatRateMask_ | ImGuiInputFlags_RepeatUntilMask_)) // Setting any _RepeatXXX option enables _Repeat
    %%%%%: 9984-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9985:        flags |= ImGuiInputFlags_Repeat;
    %%%%%: 9985-block 10
        -: 9986:
    #####: 9987:    bool pressed = (t == 0.0f);
    #####: 9988:    if (!pressed && (flags & ImGuiInputFlags_Repeat) != 0)
    %%%%%: 9988-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9988-block 12
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 9989:    {
        -: 9990:        float repeat_delay, repeat_rate;
    #####: 9991:        GetTypematicRepeatRate(flags, &repeat_delay, &repeat_rate);
    %%%%%: 9991-block 13
call    0 never executed
    #####: 9992:        pressed = (t > repeat_delay) && GetKeyPressedAmount(key, repeat_delay, repeat_rate) > 0;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9992-block 15
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 9992-block 16
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 9992-block 17
    %%%%%: 9992-block 18
    #####: 9993:        if (pressed && (flags & ImGuiInputFlags_RepeatUntilMask_))
    %%%%%: 9993-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9993-block 20
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 9994:        {
        -: 9995:            // Slightly bias 'key_pressed_time' as DownDuration is an accumulation of DeltaTime which we compare to an absolute time value.
        -: 9996:            // Ideally we'd replace DownDuration with KeyPressedTime but it would break user's code.
    #####: 9997:            ImGuiContext& g = *GImGui;
    #####: 9998:            double key_pressed_time = g.Time - t + 0.00001f;
    #####: 9999:            if ((flags & ImGuiInputFlags_RepeatUntilKeyModsChange) && (g.LastKeyModsChangeTime > key_pressed_time))
    %%%%%: 9999-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9999-block 22
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:10000:                pressed = false;
    %%%%%:10000-block 23
    #####:10001:            if ((flags & ImGuiInputFlags_RepeatUntilKeyModsChangeFromNone) && (g.LastKeyModsChangeFromNoneTime > key_pressed_time))
    %%%%%:10001-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10001-block 25
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:10002:                pressed = false;
    %%%%%:10002-block 26
    #####:10003:            if ((flags & ImGuiInputFlags_RepeatUntilOtherKeyPress) && (g.LastKeyboardKeyPressTime > key_pressed_time))
    %%%%%:10003-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10003-block 28
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:10004:                pressed = false;
    %%%%%:10004-block 29
        -:10005:        }
        -:10006:    }
    #####:10007:    if (!pressed)
    %%%%%:10007-block 31
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:10008:        return false;
    %%%%%:10008-block 32
    #####:10009:    if (!TestKeyOwner(key, owner_id))
    %%%%%:10009-block 33
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:10010:        return false;
    %%%%%:10010-block 35
    #####:10011:    return true;
    %%%%%:10011-block 36
        -:10012:}
        -:10013:
function _ZN5ImGui13IsKeyReleasedE8ImGuiKey called 0 returned 0% blocks executed 0%
    #####:10014:bool ImGui::IsKeyReleased(ImGuiKey key)
        -:10015:{
    #####:10016:    return IsKeyReleased(key, ImGuiKeyOwner_Any);
    %%%%%:10016-block 2
call    0 never executed
        -:10017:}
        -:10018:
function _ZN5ImGui13IsKeyReleasedE8ImGuiKeyj called 0 returned 0% blocks executed 0%
    #####:10019:bool ImGui::IsKeyReleased(ImGuiKey key, ImGuiID owner_id)
        -:10020:{
    #####:10021:    const ImGuiKeyData* key_data = GetKeyData(key);
    %%%%%:10021-block 2
call    0 never executed
    #####:10022:    if (key_data->DownDurationPrev < 0.0f || key_data->Down)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10022-block 4
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:10023:        return false;
    %%%%%:10023-block 5
    #####:10024:    if (!TestKeyOwner(key, owner_id))
    %%%%%:10024-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:10025:        return false;
    %%%%%:10025-block 8
    #####:10026:    return true;
    %%%%%:10026-block 9
        -:10027:}
        -:10028:
function _ZN5ImGui11IsMouseDownEi called 2154 returned 100% blocks executed 92%
     2154:10029:bool ImGui::IsMouseDown(ImGuiMouseButton button)
        -:10030:{
     2154:10031:    ImGuiContext& g = *GImGui;
    2154*:10032:    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
     2154:10032-block 2
branch  0 taken 2154 (fallthrough)
branch  1 taken 0
     2154:10032-block 3
branch  2 taken 2154 (fallthrough)
branch  3 taken 0
     2154:10032-block 4
    %%%%%:10032-block 5
call    4 never executed
     2154:10033:    return g.IO.MouseDown[button] && TestKeyOwner(MouseButtonToKey(button), ImGuiKeyOwner_Any); // should be same as IsKeyDown(MouseButtonToKey(button), ImGuiKeyOwner_Any), but this allows legacy code hijacking the io.Mousedown[] array.
     2154:10033-block 6
branch  0 taken 154 (fallthrough)
branch  1 taken 2000
      154:10033-block 7
call    2 returned 154
call    3 returned 154
branch  4 taken 154 (fallthrough)
branch  5 taken 0
      154:10033-block 10
     2000:10033-block 11
     2154:10033-block 12
        -:10034:}
        -:10035:
function _ZN5ImGui11IsMouseDownEij called 42 returned 100% blocks executed 92%
       42:10036:bool ImGui::IsMouseDown(ImGuiMouseButton button, ImGuiID owner_id)
        -:10037:{
       42:10038:    ImGuiContext& g = *GImGui;
      42*:10039:    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
       42:10039-block 2
branch  0 taken 42 (fallthrough)
branch  1 taken 0
       42:10039-block 3
branch  2 taken 42 (fallthrough)
branch  3 taken 0
       42:10039-block 4
    %%%%%:10039-block 5
call    4 never executed
       42:10040:    return g.IO.MouseDown[button] && TestKeyOwner(MouseButtonToKey(button), owner_id); // Should be same as IsKeyDown(MouseButtonToKey(button), owner_id), but this allows legacy code hijacking the io.Mousedown[] array.
       42:10040-block 6
branch  0 taken 39 (fallthrough)
branch  1 taken 3
       39:10040-block 7
call    2 returned 39
call    3 returned 39
branch  4 taken 39 (fallthrough)
branch  5 taken 0
       39:10040-block 10
        3:10040-block 11
       42:10040-block 12
        -:10041:}
        -:10042:
function _ZN5ImGui14IsMouseClickedEib called 1308 returned 100% blocks executed 83%
     1308:10043:bool ImGui::IsMouseClicked(ImGuiMouseButton button, bool repeat)
        -:10044:{
    1308*:10045:    return IsMouseClicked(button, repeat ? ImGuiInputFlags_Repeat : ImGuiInputFlags_None, ImGuiKeyOwner_Any);
     1308:10045-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1308
    %%%%%:10045-block 3
     1308:10045-block 4
     1308:10045-block 5
call    2 returned 1308
        -:10046:}
        -:10047:
function _ZN5ImGui14IsMouseClickedEiij called 1520 returned 100% blocks executed 72%
     1520:10048:bool ImGui::IsMouseClicked(ImGuiMouseButton button, ImGuiInputFlags flags, ImGuiID owner_id)
        -:10049:{
     1520:10050:    ImGuiContext& g = *GImGui;
    1520*:10051:    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
     1520:10051-block 2
branch  0 taken 1520 (fallthrough)
branch  1 taken 0
     1520:10051-block 3
branch  2 taken 1520 (fallthrough)
branch  3 taken 0
     1520:10051-block 4
    %%%%%:10051-block 5
call    4 never executed
     1520:10052:    if (!g.IO.MouseDown[button]) // In theory this should already be encoded as (DownDuration < 0.0f), but testing this facilitates eating mechanism (until we finish work on key ownership)
     1520:10052-block 6
branch  0 taken 1381 (fallthrough)
branch  1 taken 139
     1381:10053:        return false;
     1381:10053-block 7
      139:10054:    const float t = g.IO.MouseDownDuration[button];
      139:10055:    if (t < 0.0f)
      139:10055-block 8
branch  0 taken 0 (fallthrough)
branch  1 taken 139
    #####:10056:        return false;
    %%%%%:10056-block 9
     139*:10057:    IM_ASSERT((flags & ~ImGuiInputFlags_SupportedByIsMouseClicked) == 0); // Passing flags not supported by this function! // FIXME: Could support RepeatRate and RepeatUntil flags here.
      139:10057-block 10
branch  0 taken 0 (fallthrough)
branch  1 taken 139
    %%%%%:10057-block 11
call    2 never executed
        -:10058:
      139:10059:    const bool repeat = (flags & ImGuiInputFlags_Repeat) != 0;
     139*:10060:    const bool pressed = (t == 0.0f) || (repeat && t > g.IO.KeyRepeatDelay && CalcTypematicRepeatAmount(t - g.IO.DeltaTime, t, g.IO.KeyRepeatDelay, g.IO.KeyRepeatRate) > 0);
      139:10060-block 12
branch  0 taken 134 (fallthrough)
branch  1 taken 5
      134:10060-block 13
branch  2 taken 0 (fallthrough)
branch  3 taken 134
    %%%%%:10060-block 14
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:10060-block 15
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed
        5:10060-block 17
      134:10060-block 18
      139:10061:    if (!pressed)
      139:10061-block 19
branch  0 taken 134 (fallthrough)
branch  1 taken 5
      134:10062:        return false;
      134:10062-block 20
        -:10063:
        5:10064:    if (!TestKeyOwner(MouseButtonToKey(button), owner_id))
        5:10064-block 21
call    0 returned 5
call    1 returned 5
branch  2 taken 0 (fallthrough)
branch  3 taken 5
    #####:10065:        return false;
    %%%%%:10065-block 24
        -:10066:
        5:10067:    return true;
        5:10067-block 25
        -:10068:}
        -:10069:
function _ZN5ImGui15IsMouseReleasedEi called 32959 returned 100% blocks executed 92%
    32959:10070:bool ImGui::IsMouseReleased(ImGuiMouseButton button)
        -:10071:{
    32959:10072:    ImGuiContext& g = *GImGui;
   32959*:10073:    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    32959:10073-block 2
branch  0 taken 32959 (fallthrough)
branch  1 taken 0
    32959:10073-block 3
branch  2 taken 32959 (fallthrough)
branch  3 taken 0
    32959:10073-block 4
    %%%%%:10073-block 5
call    4 never executed
    32959:10074:    return g.IO.MouseReleased[button] && TestKeyOwner(MouseButtonToKey(button), ImGuiKeyOwner_Any); // Should be same as IsKeyReleased(MouseButtonToKey(button), ImGuiKeyOwner_Any)
    32959:10074-block 6
branch  0 taken 2 (fallthrough)
branch  1 taken 32957
        2:10074-block 7
call    2 returned 2
call    3 returned 2
branch  4 taken 2 (fallthrough)
branch  5 taken 0
        2:10074-block 10
    32957:10074-block 11
    32959:10074-block 12
        -:10075:}
        -:10076:
function _ZN5ImGui15IsMouseReleasedEij called 212 returned 100% blocks executed 92%
      212:10077:bool ImGui::IsMouseReleased(ImGuiMouseButton button, ImGuiID owner_id)
        -:10078:{
      212:10079:    ImGuiContext& g = *GImGui;
     212*:10080:    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
      212:10080-block 2
branch  0 taken 212 (fallthrough)
branch  1 taken 0
      212:10080-block 3
branch  2 taken 212 (fallthrough)
branch  3 taken 0
      212:10080-block 4
    %%%%%:10080-block 5
call    4 never executed
      212:10081:    return g.IO.MouseReleased[button] && TestKeyOwner(MouseButtonToKey(button), owner_id); // Should be same as IsKeyReleased(MouseButtonToKey(button), owner_id)
      212:10081-block 6
branch  0 taken 3 (fallthrough)
branch  1 taken 209
        3:10081-block 7
call    2 returned 3
call    3 returned 3
branch  4 taken 3 (fallthrough)
branch  5 taken 0
        3:10081-block 10
      209:10081-block 11
      212:10081-block 12
        -:10082:}
        -:10083:
function _ZN5ImGui20IsMouseDoubleClickedEi called 654 returned 100% blocks executed 58%
      654:10084:bool ImGui::IsMouseDoubleClicked(ImGuiMouseButton button)
        -:10085:{
      654:10086:    ImGuiContext& g = *GImGui;
     654*:10087:    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
      654:10087-block 2
branch  0 taken 654 (fallthrough)
branch  1 taken 0
      654:10087-block 3
branch  2 taken 654 (fallthrough)
branch  3 taken 0
      654:10087-block 4
    %%%%%:10087-block 5
call    4 never executed
     654*:10088:    return g.IO.MouseClickedCount[button] == 2 && TestKeyOwner(MouseButtonToKey(button), ImGuiKeyOwner_Any);
      654:10088-block 6
branch  0 taken 0 (fallthrough)
branch  1 taken 654
    %%%%%:10088-block 7
call    2 never executed
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:10088-block 10
      654:10088-block 11
      654:10088-block 12
        -:10089:}
        -:10090:
function _ZN5ImGui20IsMouseDoubleClickedEij called 0 returned 0% blocks executed 0%
    #####:10091:bool ImGui::IsMouseDoubleClicked(ImGuiMouseButton button, ImGuiID owner_id)
        -:10092:{
    #####:10093:    ImGuiContext& g = *GImGui;
    #####:10094:    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    %%%%%:10094-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10094-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:10094-block 4
    %%%%%:10094-block 5
call    4 never executed
    #####:10095:    return g.IO.MouseClickedCount[button] == 2 && TestKeyOwner(MouseButtonToKey(button), owner_id);
    %%%%%:10095-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10095-block 7
call    2 never executed
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:10095-block 10
    %%%%%:10095-block 11
    %%%%%:10095-block 12
        -:10096:}
        -:10097:
function _ZN5ImGui20GetMouseClickedCountEi called 0 returned 0% blocks executed 0%
    #####:10098:int ImGui::GetMouseClickedCount(ImGuiMouseButton button)
        -:10099:{
    #####:10100:    ImGuiContext& g = *GImGui;
    #####:10101:    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    %%%%%:10101-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10101-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:10101-block 4
    %%%%%:10101-block 5
call    4 never executed
    #####:10102:    return g.IO.MouseClickedCount[button];
    %%%%%:10102-block 6
        -:10103:}
        -:10104:
        -:10105:// Test if mouse cursor is hovering given rectangle
        -:10106:// NB- Rectangle is clipped by our current clip setting
        -:10107:// NB- Expand the rectangle to be generous on imprecise inputs systems (g.Style.TouchExtraPadding)
function _ZN5ImGui19IsMouseHoveringRectERK6ImVec2S2_b called 245123 returned 100% blocks executed 92%
   245123:10108:bool ImGui::IsMouseHoveringRect(const ImVec2& r_min, const ImVec2& r_max, bool clip)
        -:10109:{
   245123:10110:    ImGuiContext& g = *GImGui;
        -:10111:
        -:10112:    // Clip
   245123:10113:    ImRect rect_clipped(r_min, r_max);
   245123:10113-block 2
call    0 returned 245123
   245123:10114:    if (clip)
branch  0 taken 234140 (fallthrough)
branch  1 taken 10983
   234140:10115:        rect_clipped.ClipWith(g.CurrentWindow->ClipRect);
   234140:10115-block 4
call    0 returned 234140
        -:10116:
        -:10117:    // Hit testing, expanded for touch input
   245123:10118:    if (!rect_clipped.ContainsWithPad(g.IO.MousePos, g.Style.TouchExtraPadding))
   245123:10118-block 5
call    0 returned 245123
branch  1 taken 242300 (fallthrough)
branch  2 taken 2823
   242300:10119:        return false;
   242300:10119-block 7
     2823:10120:    if (!g.MouseViewport->GetMainRect().Overlaps(rect_clipped))
     2823:10120-block 8
call    0 returned 2823
call    1 returned 2823
branch  2 taken 0 (fallthrough)
branch  3 taken 2823
    #####:10121:        return false;
    %%%%%:10121-block 11
     2823:10122:    return true;
     2823:10122-block 12
        -:10123:}
        -:10124:
        -:10125:// Return if a mouse click/drag went past the given threshold. Valid to call during the MouseReleased frame.
        -:10126:// [Internal] This doesn't test if the button is pressed
function _ZN5ImGui24IsMouseDragPastThresholdEif called 98 returned 100% blocks executed 88%
       98:10127:bool ImGui::IsMouseDragPastThreshold(ImGuiMouseButton button, float lock_threshold)
        -:10128:{
       98:10129:    ImGuiContext& g = *GImGui;
      98*:10130:    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
       98:10130-block 2
branch  0 taken 98 (fallthrough)
branch  1 taken 0
       98:10130-block 3
branch  2 taken 98 (fallthrough)
branch  3 taken 0
       98:10130-block 4
    %%%%%:10130-block 5
call    4 never executed
       98:10131:    if (lock_threshold < 0.0f)
       98:10131-block 6
branch  0 taken 98 (fallthrough)
branch  1 taken 0
       98:10132:        lock_threshold = g.IO.MouseDragThreshold;
       98:10132-block 7
       98:10133:    return g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold;
       98:10133-block 8
        -:10134:}
        -:10135:
function _ZN5ImGui15IsMouseDraggingEif called 98 returned 100% blocks executed 75%
       98:10136:bool ImGui::IsMouseDragging(ImGuiMouseButton button, float lock_threshold)
        -:10137:{
       98:10138:    ImGuiContext& g = *GImGui;
      98*:10139:    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
       98:10139-block 2
branch  0 taken 98 (fallthrough)
branch  1 taken 0
       98:10139-block 3
branch  2 taken 98 (fallthrough)
branch  3 taken 0
       98:10139-block 4
    %%%%%:10139-block 5
call    4 never executed
       98:10140:    if (!g.IO.MouseDown[button])
       98:10140-block 6
branch  0 taken 0 (fallthrough)
branch  1 taken 98
    #####:10141:        return false;
    %%%%%:10141-block 7
       98:10142:    return IsMouseDragPastThreshold(button, lock_threshold);
       98:10142-block 8
call    0 returned 98
        -:10143:}
        -:10144:
function _ZN5ImGui11GetMousePosEv called 1163 returned 100% blocks executed 100%
     1163:10145:ImVec2 ImGui::GetMousePos()
        -:10146:{
     1163:10147:    ImGuiContext& g = *GImGui;
     1163:10148:    return g.IO.MousePos;
     1163:10148-block 2
        -:10149:}
        -:10150:
        -:10151:// This is called TeleportMousePos() and not SetMousePos() to emphasis that setting MousePosPrev will effectively clear mouse delta as well.
        -:10152:// It is expected you only call this if (io.BackendFlags & ImGuiBackendFlags_HasSetMousePos) is set and supported by backend.
function _ZN5ImGui16TeleportMousePosERK6ImVec2 called 0 returned 0% blocks executed 0%
    #####:10153:void ImGui::TeleportMousePos(const ImVec2& pos)
        -:10154:{
    #####:10155:    ImGuiContext& g = *GImGui;
    #####:10156:    g.IO.MousePos = g.IO.MousePosPrev = pos;
    #####:10157:    g.IO.MouseDelta = ImVec2(0.0f, 0.0f);
    %%%%%:10157-block 2
call    0 never executed
    #####:10158:    g.IO.WantSetMousePos = true;
        -:10159:    //IMGUI_DEBUG_LOG_IO("TeleportMousePos: (%.1f,%.1f)\n", io.MousePos.x, io.MousePos.y);
    #####:10160:}
        -:10161:
        -:10162:// NB: prefer to call right after BeginPopup(). At the time Selectable/MenuItem is activated, the popup is already closed!
function _ZN5ImGui32GetMousePosOnOpeningCurrentPopupEv called 0 returned 0% blocks executed 0%
    #####:10163:ImVec2 ImGui::GetMousePosOnOpeningCurrentPopup()
        -:10164:{
    #####:10165:    ImGuiContext& g = *GImGui;
    #####:10166:    if (g.BeginPopupStack.Size > 0)
    %%%%%:10166-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:10167:        return g.OpenPopupStack[g.BeginPopupStack.Size - 1].OpenMousePos;
    %%%%%:10167-block 3
call    0 never executed
    #####:10168:    return g.IO.MousePos;
    %%%%%:10168-block 5
        -:10169:}
        -:10170:
        -:10171:// We typically use ImVec2(-FLT_MAX,-FLT_MAX) to denote an invalid mouse position.
function _ZN5ImGui15IsMousePosValidEPK6ImVec2 called 3591 returned 100% blocks executed 83%
     3591:10172:bool ImGui::IsMousePosValid(const ImVec2* mouse_pos)
        -:10173:{
        -:10174:    // The assert is only to silence a false-positive in XCode Static Analysis.
        -:10175:    // Because GImGui is not dereferenced in every code path, the static analyzer assume that it may be NULL (which it doesn't for other functions).
    3591*:10176:    IM_ASSERT(GImGui != NULL);
     3591:10176-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 3591
    %%%%%:10176-block 3
call    2 never executed
     3591:10177:    const float MOUSE_INVALID = -256000.0f;
    3591*:10178:    ImVec2 p = mouse_pos ? *mouse_pos : GImGui->IO.MousePos;
     3591:10178-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 3591
    %%%%%:10178-block 5
     3591:10178-block 6
     3591:10179:    return p.x >= MOUSE_INVALID && p.y >= MOUSE_INVALID;
     3591:10179-block 7
branch  0 taken 3588 (fallthrough)
branch  1 taken 3
     3588:10179-block 8
branch  2 taken 3588 (fallthrough)
branch  3 taken 0
     3588:10179-block 9
        3:10179-block 10
     3591:10179-block 11
        -:10180:}
        -:10181:
        -:10182:// [WILL OBSOLETE] This was designed for backends, but prefer having backend maintain a mask of held mouse buttons, because upcoming input queue system will make this invalid.
function _ZN5ImGui14IsAnyMouseDownEv called 0 returned 0% blocks executed 0%
    #####:10183:bool ImGui::IsAnyMouseDown()
        -:10184:{
    #####:10185:    ImGuiContext& g = *GImGui;
    #####:10186:    for (int n = 0; n < IM_ARRAYSIZE(g.IO.MouseDown); n++)
    %%%%%:10186-block 2
    %%%%%:10186-block 5
    %%%%%:10186-block 6
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:10187:        if (g.IO.MouseDown[n])
    %%%%%:10187-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:10188:            return true;
    %%%%%:10188-block 4
    #####:10189:    return false;
    %%%%%:10189-block 7
        -:10190:}
        -:10191:
        -:10192:// Return the delta from the initial clicking position while the mouse button is clicked or was just released.
        -:10193:// This is locked and return 0.0f until the mouse moves past a distance threshold at least once.
        -:10194:// NB: This is only valid if IsMousePosValid(). backends in theory should always keep mouse position valid when dragging even outside the client window.
function _ZN5ImGui17GetMouseDragDeltaEif called 0 returned 0% blocks executed 0%
    #####:10195:ImVec2 ImGui::GetMouseDragDelta(ImGuiMouseButton button, float lock_threshold)
        -:10196:{
    #####:10197:    ImGuiContext& g = *GImGui;
    #####:10198:    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    %%%%%:10198-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10198-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:10198-block 4
    %%%%%:10198-block 5
call    4 never executed
    #####:10199:    if (lock_threshold < 0.0f)
    %%%%%:10199-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:10200:        lock_threshold = g.IO.MouseDragThreshold;
    %%%%%:10200-block 7
    #####:10201:    if (g.IO.MouseDown[button] || g.IO.MouseReleased[button])
    %%%%%:10201-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10201-block 9
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:10202:        if (g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold)
    %%%%%:10202-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:10203:            if (IsMousePosValid(&g.IO.MousePos) && IsMousePosValid(&g.IO.MouseClickedPos[button]))
    %%%%%:10203-block 11
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:10203-block 13
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:10203-block 15
    %%%%%:10203-block 16
    %%%%%:10203-block 17
branch  6 never executed (fallthrough)
branch  7 never executed
    #####:10204:                return g.IO.MousePos - g.IO.MouseClickedPos[button];
    %%%%%:10204-block 18
call    0 never executed
    #####:10205:    return ImVec2(0.0f, 0.0f);
    %%%%%:10205-block 19
call    0 never executed
    %%%%%:10205-block 21
        -:10206:}
        -:10207:
function _ZN5ImGui19ResetMouseDragDeltaEi called 0 returned 0% blocks executed 0%
    #####:10208:void ImGui::ResetMouseDragDelta(ImGuiMouseButton button)
        -:10209:{
    #####:10210:    ImGuiContext& g = *GImGui;
    #####:10211:    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    %%%%%:10211-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10211-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:10211-block 4
    %%%%%:10211-block 5
call    4 never executed
        -:10212:    // NB: We don't need to reset g.IO.MouseDragMaxDistanceSqr
    #####:10213:    g.IO.MouseClickedPos[button] = g.IO.MousePos;
    #####:10214:}
        -:10215:
        -:10216:// Get desired mouse cursor shape.
        -:10217:// Important: this is meant to be used by a platform backend, it is reset in ImGui::NewFrame(),
        -:10218:// updated during the frame, and locked in EndFrame()/Render().
        -:10219:// If you use software rendering by setting io.MouseDrawCursor then Dear ImGui will render those for you
function _ZN5ImGui14GetMouseCursorEv called 1077 returned 100% blocks executed 100%
     1077:10220:ImGuiMouseCursor ImGui::GetMouseCursor()
        -:10221:{
     1077:10222:    ImGuiContext& g = *GImGui;
     1077:10223:    return g.MouseCursor;
     1077:10223-block 2
        -:10224:}
        -:10225:
        -:10226:// We intentionally accept values of ImGuiMouseCursor that are outside our bounds, in case users needs to hack-in a custom cursor value.
        -:10227:// Custom cursors may be handled by custom backends. If you are using a standard backend and want to hack in a custom cursor, you may
        -:10228:// handle it before the backend _NewFrame() call and temporarily set ImGuiConfigFlags_NoMouseCursorChange during the backend _NewFrame() call.
function _ZN5ImGui14SetMouseCursorEi called 344 returned 100% blocks executed 100%
      344:10229:void ImGui::SetMouseCursor(ImGuiMouseCursor cursor_type)
        -:10230:{
      344:10231:    ImGuiContext& g = *GImGui;
      344:10232:    g.MouseCursor = cursor_type;
      344:10233:}
        -:10234:
function _ZL14UpdateAliasKey8ImGuiKeybf called 7539 returned 100% blocks executed 80%
     7539:10235:static void UpdateAliasKey(ImGuiKey key, bool v, float analog_value)
        -:10236:{
    7539*:10237:    IM_ASSERT(ImGui::IsAliasKey(key));
     7539:10237-block 2
call    0 returned 7539
branch  1 taken 0 (fallthrough)
branch  2 taken 7539
    %%%%%:10237-block 4
call    3 never executed
     7539:10238:    ImGuiKeyData* key_data = ImGui::GetKeyData(key);
     7539:10238-block 5
call    0 returned 7539
     7539:10239:    key_data->Down = v;
     7539:10240:    key_data->AnalogValue = analog_value;
     7539:10241:}
        -:10242:
        -:10243:// [Internal] Do not use directly
function _ZL21GetMergedModsFromKeysv called 2156 returned 100% blocks executed 79%
     2156:10244:static ImGuiKeyChord GetMergedModsFromKeys()
        -:10245:{
     2156:10246:    ImGuiKeyChord mods = 0;
    2156*:10247:    if (ImGui::IsKeyDown(ImGuiMod_Ctrl))     { mods |= ImGuiMod_Ctrl; }
     2156:10247-block 2
call    0 returned 2156
branch  1 taken 0 (fallthrough)
branch  2 taken 2156
    %%%%%:10247-block 4
    2156*:10248:    if (ImGui::IsKeyDown(ImGuiMod_Shift))    { mods |= ImGuiMod_Shift; }
     2156:10248-block 5
call    0 returned 2156
branch  1 taken 0 (fallthrough)
branch  2 taken 2156
    %%%%%:10248-block 7
    2156*:10249:    if (ImGui::IsKeyDown(ImGuiMod_Alt))      { mods |= ImGuiMod_Alt; }
     2156:10249-block 8
call    0 returned 2156
branch  1 taken 0 (fallthrough)
branch  2 taken 2156
    %%%%%:10249-block 10
     2156:10250:    if (ImGui::IsKeyDown(ImGuiMod_Super))    { mods |= ImGuiMod_Super; }
     2156:10250-block 11
call    0 returned 2156
branch  1 taken 41 (fallthrough)
branch  2 taken 2115
       41:10250-block 13
     2156:10251:    return mods;
     2156:10251-block 14
        -:10252:}
        -:10253:
function _ZN5ImGuiL20UpdateKeyboardInputsEv called 1077 returned 100% blocks executed 63%
     1077:10254:static void ImGui::UpdateKeyboardInputs()
        -:10255:{
     1077:10256:    ImGuiContext& g = *GImGui;
     1077:10257:    ImGuiIO& io = g.IO;
        -:10258:
     1077:10259:    if (io.ConfigFlags & ImGuiConfigFlags_NoKeyboard)
     1077:10259-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####:10260:        io.ClearInputKeys();
    %%%%%:10260-block 3
call    0 never executed
        -:10261:
        -:10262:    // Import legacy keys or verify they are not used
        -:10263:#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
     1077:10264:    if (io.BackendUsingLegacyKeyArrays == 0)
     1077:10264-block 4
branch  0 taken 742 (fallthrough)
branch  1 taken 335
        -:10265:    {
        -:10266:        // Backend used new io.AddKeyEvent() API: Good! Verify that old arrays are never written to externally.
   380646:10267:        for (int n = 0; n < ImGuiKey_LegacyNativeKey_END; n++)
      742:10267-block 5
   379904:10267-block 11
   380646:10267-block 12
branch  0 taken 379904
branch  1 taken 742
  379904*:10268:            IM_ASSERT((io.KeysDown[n] == false || IsKeyDown((ImGuiKey)n)) && "Backend needs to either only use io.AddKeyEvent(), either only fill legacy io.KeysDown[] + io.KeyMap[]. Not both!");
   379904:10268-block 6
branch  0 taken 20 (fallthrough)
branch  1 taken 379884
       20:10268-block 7
call    2 returned 20
branch  3 taken 20 (fallthrough)
branch  4 taken 0
   379904:10268-block 9
    %%%%%:10268-block 10
call    5 never executed
        -:10269:    }
        -:10270:    else
        -:10271:    {
      335:10272:        if (g.FrameCount == 0)
      335:10272-block 13
branch  0 taken 0 (fallthrough)
branch  1 taken 335
    #####:10273:            for (int n = ImGuiKey_LegacyNativeKey_BEGIN; n < ImGuiKey_LegacyNativeKey_END; n++)
    %%%%%:10273-block 14
    %%%%%:10273-block 17
    %%%%%:10273-block 18
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:10274:                IM_ASSERT(g.IO.KeyMap[n] == -1 && "Backend is not allowed to write to io.KeyMap[0..511]!");
    %%%%%:10274-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10274-block 16
call    2 never executed
        -:10275:
        -:10276:        // Build reverse KeyMap (Named -> Legacy)
    51925:10277:        for (int n = ImGuiKey_NamedKey_BEGIN; n < ImGuiKey_NamedKey_END; n++)
      335:10277-block 19
    51590:10277-block 25
    51925:10277-block 26
branch  0 taken 51590
branch  1 taken 335 (fallthrough)
    51590:10278:            if (io.KeyMap[n] != -1)
    51590:10278-block 20
branch  0 taken 0 (fallthrough)
branch  1 taken 51590
        -:10279:            {
    #####:10280:                IM_ASSERT(IsLegacyKey((ImGuiKey)io.KeyMap[n]));
    %%%%%:10280-block 21
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:10280-block 23
call    3 never executed
    #####:10281:                io.KeyMap[io.KeyMap[n]] = n;
    %%%%%:10281-block 24
        -:10282:            }
        -:10283:
        -:10284:        // Import legacy keys into new ones
   171855:10285:        for (int n = ImGuiKey_LegacyNativeKey_BEGIN; n < ImGuiKey_LegacyNativeKey_END; n++)
      335:10285-block 27
   171520:10285-block 40
   171855:10285-block 41
branch  0 taken 171520
branch  1 taken 335 (fallthrough)
   171520:10286:            if (io.KeysDown[n] || io.BackendUsingLegacyKeyArrays == 1)
   171520:10286-block 28
branch  0 taken 171520 (fallthrough)
branch  1 taken 0
   171520:10286-block 29
branch  2 taken 0 (fallthrough)
branch  3 taken 171520
        -:10287:            {
    #####:10288:                const ImGuiKey key = (ImGuiKey)(io.KeyMap[n] != -1 ? io.KeyMap[n] : n);
    %%%%%:10288-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10288-block 31
    %%%%%:10288-block 32
    #####:10289:                IM_ASSERT(io.KeyMap[n] == -1 || IsNamedKey(key));
    %%%%%:10289-block 33
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10289-block 34
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:10289-block 36
call    5 never executed
    #####:10290:                io.KeysData[key].Down = io.KeysDown[n];
    #####:10291:                if (key != n)
    %%%%%:10291-block 37
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:10292:                    io.KeysDown[key] = io.KeysDown[n]; // Allow legacy code using io.KeysDown[GetKeyIndex()] with old backends
    %%%%%:10292-block 38
    #####:10293:                io.BackendUsingLegacyKeyArrays = 1;
    %%%%%:10293-block 39
        -:10294:            }
      335:10295:        if (io.BackendUsingLegacyKeyArrays == 1)
      335:10295-block 42
branch  0 taken 0 (fallthrough)
branch  1 taken 335
        -:10296:        {
    #####:10297:            GetKeyData(ImGuiMod_Ctrl)->Down = io.KeyCtrl;
    %%%%%:10297-block 43
call    0 never executed
    #####:10298:            GetKeyData(ImGuiMod_Shift)->Down = io.KeyShift;
call    0 never executed
    #####:10299:            GetKeyData(ImGuiMod_Alt)->Down = io.KeyAlt;
call    0 never executed
    #####:10300:            GetKeyData(ImGuiMod_Super)->Down = io.KeySuper;
call    0 never executed
        -:10301:        }
        -:10302:    }
        -:10303:#endif
        -:10304:
        -:10305:    // Import legacy ImGuiNavInput_ io inputs and convert to gamepad keys
        -:10306:#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
    1077*:10307:    const bool nav_gamepad_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (io.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
     1077:10307-block 48
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:10307-block 49
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:10307-block 50
     1077:10307-block 51
     1077:10308:    if (io.BackendUsingLegacyNavInputArray && nav_gamepad_active)
     1077:10308-block 52
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:10308-block 53
branch  2 taken 0 (fallthrough)
branch  3 taken 1077
        -:10309:    {
        -:10310:        #define MAP_LEGACY_NAV_INPUT_TO_KEY1(_KEY, _NAV1)           do { io.KeysData[_KEY].Down = (io.NavInputs[_NAV1] > 0.0f); io.KeysData[_KEY].AnalogValue = io.NavInputs[_NAV1]; } while (0)
        -:10311:        #define MAP_LEGACY_NAV_INPUT_TO_KEY2(_KEY, _NAV1, _NAV2)    do { io.KeysData[_KEY].Down = (io.NavInputs[_NAV1] > 0.0f) || (io.NavInputs[_NAV2] > 0.0f); io.KeysData[_KEY].AnalogValue = ImMax(io.NavInputs[_NAV1], io.NavInputs[_NAV2]); } while (0)
    #####:10312:        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadFaceDown, ImGuiNavInput_Activate);
    #####:10313:        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadFaceRight, ImGuiNavInput_Cancel);
    #####:10314:        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadFaceLeft, ImGuiNavInput_Menu);
    #####:10315:        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadFaceUp, ImGuiNavInput_Input);
    #####:10316:        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadDpadLeft, ImGuiNavInput_DpadLeft);
    #####:10317:        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadDpadRight, ImGuiNavInput_DpadRight);
    #####:10318:        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadDpadUp, ImGuiNavInput_DpadUp);
    #####:10319:        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadDpadDown, ImGuiNavInput_DpadDown);
    #####:10320:        MAP_LEGACY_NAV_INPUT_TO_KEY2(ImGuiKey_GamepadL1, ImGuiNavInput_FocusPrev, ImGuiNavInput_TweakSlow);
    %%%%%:10320-block 54
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10320-block 55
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:10320-block 56
    %%%%%:10320-block 57
    %%%%%:10320-block 58
call    4 never executed
    #####:10321:        MAP_LEGACY_NAV_INPUT_TO_KEY2(ImGuiKey_GamepadR1, ImGuiNavInput_FocusNext, ImGuiNavInput_TweakFast);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10321-block 60
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:10321-block 61
    %%%%%:10321-block 62
    %%%%%:10321-block 63
call    4 never executed
    #####:10322:        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadLStickLeft, ImGuiNavInput_LStickLeft);
    #####:10323:        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadLStickRight, ImGuiNavInput_LStickRight);
    #####:10324:        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadLStickUp, ImGuiNavInput_LStickUp);
    #####:10325:        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadLStickDown, ImGuiNavInput_LStickDown);
        -:10326:        #undef NAV_MAP_KEY
        -:10327:    }
        -:10328:#endif
        -:10329:
        -:10330:    // Update aliases
     6462:10331:    for (int n = 0; n < ImGuiMouseButton_COUNT; n++)
     1077:10331-block 65
     6462:10331-block 72
branch  0 taken 5385
branch  1 taken 1077 (fallthrough)
     5385:10332:        UpdateAliasKey(MouseButtonToKey(n), io.MouseDown[n], io.MouseDown[n] ? 1.0f : 0.0f);
     5385:10332-block 66
branch  0 taken 154 (fallthrough)
branch  1 taken 5231
      154:10332-block 67
     5231:10332-block 68
     5385:10332-block 69
call    2 returned 5385
call    3 returned 5385
     1077:10333:    UpdateAliasKey(ImGuiKey_MouseWheelX, io.MouseWheelH != 0.0f, io.MouseWheelH);
     1077:10333-block 73
call    0 returned 1077
     1077:10334:    UpdateAliasKey(ImGuiKey_MouseWheelY, io.MouseWheel != 0.0f, io.MouseWheel);
call    0 returned 1077
        -:10335:
        -:10336:    // Synchronize io.KeyMods and io.KeyCtrl/io.KeyShift/etc. values.
        -:10337:    // - New backends (1.87+): send io.AddKeyEvent(ImGuiMod_XXX) ->                                      -> (here) deriving io.KeyMods + io.KeyXXX from key array.
        -:10338:    // - Legacy backends:      set io.KeyXXX bools               -> (above) set key array from io.KeyXXX -> (here) deriving io.KeyMods + io.KeyXXX from key array.
        -:10339:    // So with legacy backends the 4 values will do a unnecessary back-and-forth but it makes the code simpler and future facing.
     1077:10340:    const ImGuiKeyChord prev_key_mods = io.KeyMods;
     1077:10341:    io.KeyMods = GetMergedModsFromKeys();
call    0 returned 1077
     1077:10342:    io.KeyCtrl = (io.KeyMods & ImGuiMod_Ctrl) != 0;
     1077:10343:    io.KeyShift = (io.KeyMods & ImGuiMod_Shift) != 0;
     1077:10344:    io.KeyAlt = (io.KeyMods & ImGuiMod_Alt) != 0;
     1077:10345:    io.KeySuper = (io.KeyMods & ImGuiMod_Super) != 0;
     1077:10346:    if (prev_key_mods != io.KeyMods)
branch  0 taken 1 (fallthrough)
branch  1 taken 1076
        1:10347:        g.LastKeyModsChangeTime = g.Time;
        1:10347-block 77
     1077:10348:    if (prev_key_mods != io.KeyMods && prev_key_mods == 0)
     1077:10348-block 78
branch  0 taken 1 (fallthrough)
branch  1 taken 1076
        1:10348-block 79
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1:10349:        g.LastKeyModsChangeFromNoneTime = g.Time;
        1:10349-block 80
        -:10350:
        -:10351:    // Clear gamepad data if disabled
     1077:10352:    if ((io.BackendFlags & ImGuiBackendFlags_HasGamepad) == 0)
     1077:10352-block 81
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
    26925:10353:        for (int i = ImGuiKey_Gamepad_BEGIN; i < ImGuiKey_Gamepad_END; i++)
     1077:10353-block 82
    26925:10353-block 84
branch  0 taken 25848
branch  1 taken 1077 (fallthrough)
        -:10354:        {
    25848:10355:            io.KeysData[i - ImGuiKey_KeysData_OFFSET].Down = false;
    25848:10356:            io.KeysData[i - ImGuiKey_KeysData_OFFSET].AnalogValue = 0.0f;
    25848:10356-block 83
        -:10357:        }
        -:10358:
        -:10359:    // Update keys
   718359:10360:    for (int i = 0; i < ImGuiKey_KeysData_SIZE; i++)
     1077:10360-block 85
   717282:10360-block 101
   718359:10360-block 102
branch  0 taken 717282
branch  1 taken 1077 (fallthrough)
        -:10361:    {
   717282:10362:        ImGuiKeyData* key_data = &io.KeysData[i];
   717282:10363:        key_data->DownDurationPrev = key_data->DownDuration;
   717282:10364:        key_data->DownDuration = key_data->Down ? (key_data->DownDuration < 0.0f ? 0.0f : key_data->DownDuration + io.DeltaTime) : -1.0f;
   717282:10364-block 86
branch  0 taken 194 (fallthrough)
branch  1 taken 717088
      194:10364-block 87
branch  2 taken 8 (fallthrough)
branch  3 taken 186
        8:10364-block 88
      186:10364-block 89
      194:10364-block 90
   717088:10364-block 91
   717282:10365:        if (key_data->DownDuration == 0.0f)
   717282:10365-block 92
branch  0 taken 8 (fallthrough)
branch  1 taken 717274
        -:10366:        {
        8:10367:            ImGuiKey key = (ImGuiKey)(ImGuiKey_KeysData_OFFSET + i);
        8:10368:            if (IsKeyboardKey(key))
        8:10368-block 93
call    0 returned 8
branch  1 taken 1 (fallthrough)
branch  2 taken 7
        1:10369:                g.LastKeyboardKeyPressTime = g.Time;
        1:10369-block 95
        7:10370:            else if (key == ImGuiKey_ReservedForModCtrl || key == ImGuiKey_ReservedForModShift || key == ImGuiKey_ReservedForModAlt || key == ImGuiKey_ReservedForModSuper)
        7:10370-block 96
branch  0 taken 7 (fallthrough)
branch  1 taken 0
        7:10370-block 97
branch  2 taken 7 (fallthrough)
branch  3 taken 0
        7:10370-block 98
branch  4 taken 7 (fallthrough)
branch  5 taken 0
        7:10370-block 99
branch  6 taken 1 (fallthrough)
branch  7 taken 6
        1:10371:                g.LastKeyboardKeyPressTime = g.Time;
        1:10371-block 100
        -:10372:        }
        -:10373:    }
        -:10374:
        -:10375:    // Update keys/input owner (named keys only): one entry per key
   166935:10376:    for (ImGuiKey key = ImGuiKey_NamedKey_BEGIN; key < ImGuiKey_NamedKey_END; key = (ImGuiKey)(key + 1))
     1077:10376-block 103
   166935:10376-block 111
branch  0 taken 165858
branch  1 taken 1077 (fallthrough)
        -:10377:    {
   165858:10378:        ImGuiKeyData* key_data = &io.KeysData[key - ImGuiKey_KeysData_OFFSET];
   165858:10379:        ImGuiKeyOwnerData* owner_data = &g.KeysOwnerData[key - ImGuiKey_NamedKey_BEGIN];
   165858:10380:        owner_data->OwnerCurr = owner_data->OwnerNext;
   165858:10381:        if (!key_data->Down) // Important: ownership is released on the frame after a release. Ensure a 'MouseDown -> CloseWindow -> MouseUp' chain doesn't lead to someone else seeing the MouseUp.
   165858:10381-block 104
branch  0 taken 165664 (fallthrough)
branch  1 taken 194
   165664:10382:            owner_data->OwnerNext = ImGuiKeyOwner_NoOwner;
   165664:10382-block 105
  165858*:10383:        owner_data->LockThisFrame = owner_data->LockUntilRelease = owner_data->LockUntilRelease && key_data->Down;  // Clear LockUntilRelease when key is not Down anymore
   165858:10383-block 106
branch  0 taken 0 (fallthrough)
branch  1 taken 165858
    %%%%%:10383-block 107
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:10383-block 108
   165858:10383-block 109
   165858:10383-block 110
        -:10384:    }
        -:10385:
        -:10386:    // Update key routing (for e.g. shortcuts)
     1077:10387:    UpdateKeyRoutingTable(&g.KeysRoutingTable);
     1077:10387-block 112
call    0 returned 1077
     1077:10388:}
        -:10389:
function _ZN5ImGuiL17UpdateMouseInputsEv called 1077 returned 100% blocks executed 82%
     1077:10390:static void ImGui::UpdateMouseInputs()
        -:10391:{
     1077:10392:    ImGuiContext& g = *GImGui;
     1077:10393:    ImGuiIO& io = g.IO;
        -:10394:
        -:10395:    // Mouse Wheel swapping flag
        -:10396:    // As a standard behavior holding SHIFT while using Vertical Mouse Wheel triggers Horizontal scroll instead
        -:10397:    // - We avoid doing it on OSX as it the OS input layer handles this already.
        -:10398:    // - FIXME: However this means when running on OSX over Emscripten, Shift+WheelY will incur two swapping (1 in OS, 1 here), canceling the feature.
        -:10399:    // - FIXME: When we can distinguish e.g. touchpad scroll events from mouse ones, we'll set this accordingly based on input source.
    1077*:10400:    io.MouseWheelRequestAxisSwap = io.KeyShift && !io.ConfigMacOSXBehaviors;
     1077:10400-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:10400-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:10400-block 4
     1077:10400-block 5
        -:10401:
        -:10402:    // Round mouse position to avoid spreading non-rounded position (e.g. UpdateManualResize doesn't support them well)
     1077:10403:    if (IsMousePosValid(&io.MousePos))
     1077:10403-block 6
call    0 returned 1077
branch  1 taken 1076 (fallthrough)
branch  2 taken 1
     1076:10404:        io.MousePos = g.MouseLastValidPos = ImFloor(io.MousePos);
     1076:10404-block 8
call    0 returned 1076
        -:10405:
        -:10406:    // If mouse just appeared or disappeared (usually denoted by -FLT_MAX components) we cancel out movement in MouseDelta
     1077:10407:    if (IsMousePosValid(&io.MousePos) && IsMousePosValid(&io.MousePosPrev))
     1077:10407-block 10
call    0 returned 1077
branch  1 taken 1076 (fallthrough)
branch  2 taken 1
     1076:10407-block 12
call    3 returned 1076
branch  4 taken 1075 (fallthrough)
branch  5 taken 1
     1075:10407-block 14
        2:10407-block 15
     1077:10407-block 16
branch  6 taken 1075 (fallthrough)
branch  7 taken 2
     1075:10408:        io.MouseDelta = io.MousePos - io.MousePosPrev;
     1075:10408-block 17
call    0 returned 1075
        -:10409:    else
        2:10410:        io.MouseDelta = ImVec2(0.0f, 0.0f);
        2:10410-block 18
call    0 returned 2
        -:10411:
        -:10412:    // Update stationary timer.
        -:10413:    // FIXME: May need to rework again to have some tolerance for occasional small movement, while being functional on high-framerates.
    1077*:10414:    const float mouse_stationary_threshold = (io.MouseSource == ImGuiMouseSource_Mouse) ? 2.0f : 3.0f; // Slightly higher threshold for ImGuiMouseSource_TouchScreen/ImGuiMouseSource_Pen, may need rework.
     1077:10414-block 20
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:10414-block 21
    %%%%%:10414-block 22
     1077:10415:    const bool mouse_stationary = (ImLengthSqr(io.MouseDelta) <= mouse_stationary_threshold * mouse_stationary_threshold);
     1077:10415-block 23
call    0 returned 1077
     1077:10416:    g.MouseStationaryTimer = mouse_stationary ? (g.MouseStationaryTimer + io.DeltaTime) : 0.0f;
branch  0 taken 757 (fallthrough)
branch  1 taken 320
      757:10416-block 25
      320:10416-block 26
        -:10417:    //IMGUI_DEBUG_LOG("%.4f\n", g.MouseStationaryTimer);
        -:10418:
        -:10419:    // If mouse moved we re-enable mouse hovering in case it was disabled by keyboard/gamepad. In theory should use a >0.0f threshold but would need to reset in everywhere we set this to true.
     1077:10420:    if (io.MouseDelta.x != 0.0f || io.MouseDelta.y != 0.0f)
     1077:10420-block 27
branch  0 taken 712 (fallthrough)
branch  1 taken 365
      712:10420-block 28
branch  2 taken 67 (fallthrough)
branch  3 taken 645
      432:10421:        g.NavHighlightItemUnderNav = false;
      432:10421-block 29
        -:10422:
     6462:10423:    for (int i = 0; i < IM_ARRAYSIZE(io.MouseDown); i++)
     1077:10423-block 30
     5385:10423-block 78
     6462:10423-block 79
branch  0 taken 5385
branch  1 taken 1077 (fallthrough)
        -:10424:    {
     5385:10425:        io.MouseClicked[i] = io.MouseDown[i] && io.MouseDownDuration[i] < 0.0f;
     5385:10425-block 31
branch  0 taken 154 (fallthrough)
branch  1 taken 5231
      154:10425-block 32
branch  2 taken 6 (fallthrough)
branch  3 taken 148
        6:10425-block 33
     5379:10425-block 34
     5385:10426:        io.MouseClickedCount[i] = 0; // Will be filled below
     5385:10427:        io.MouseReleased[i] = !io.MouseDown[i] && io.MouseDownDuration[i] >= 0.0f;
     5385:10427-block 35
branch  0 taken 5231 (fallthrough)
branch  1 taken 154
     5231:10427-block 36
branch  2 taken 6 (fallthrough)
branch  3 taken 5225
        6:10427-block 37
     5379:10427-block 38
     5385:10428:        io.MouseDownDurationPrev[i] = io.MouseDownDuration[i];
     5385:10429:        io.MouseDownDuration[i] = io.MouseDown[i] ? (io.MouseDownDuration[i] < 0.0f ? 0.0f : io.MouseDownDuration[i] + io.DeltaTime) : -1.0f;
     5385:10429-block 39
branch  0 taken 154 (fallthrough)
branch  1 taken 5231
      154:10429-block 40
branch  2 taken 6 (fallthrough)
branch  3 taken 148
        6:10429-block 41
      148:10429-block 42
      154:10429-block 43
     5231:10429-block 44
     5385:10430:        if (io.MouseClicked[i])
     5385:10430-block 45
branch  0 taken 6 (fallthrough)
branch  1 taken 5379
        -:10431:        {
        6:10432:            bool is_repeated_click = false;
        6:10433:            if ((float)(g.Time - io.MouseClickedTime[i]) < io.MouseDoubleClickTime)
        6:10433-block 46
branch  0 taken 0 (fallthrough)
branch  1 taken 6
        -:10434:            {
    #####:10435:                ImVec2 delta_from_click_pos = IsMousePosValid(&io.MousePos) ? (io.MousePos - io.MouseClickedPos[i]) : ImVec2(0.0f, 0.0f);
    %%%%%:10435-block 47
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:10435-block 49
call    3 never executed
    %%%%%:10435-block 50
call    4 never executed
    #####:10436:                if (ImLengthSqr(delta_from_click_pos) < io.MouseDoubleClickMaxDist * io.MouseDoubleClickMaxDist)
    %%%%%:10436-block 51
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:10437:                    is_repeated_click = true;
    %%%%%:10437-block 53
        -:10438:            }
        6:10439:            if (is_repeated_click)
        6:10439-block 55
branch  0 taken 0 (fallthrough)
branch  1 taken 6
    #####:10440:                io.MouseClickedLastCount[i]++;
    %%%%%:10440-block 56
        -:10441:            else
        6:10442:                io.MouseClickedLastCount[i] = 1;
        6:10442-block 57
        6:10443:            io.MouseClickedTime[i] = g.Time;
        6:10444:            io.MouseClickedPos[i] = io.MousePos;
        6:10445:            io.MouseClickedCount[i] = io.MouseClickedLastCount[i];
        6:10446:            io.MouseDragMaxDistanceAbs[i] = ImVec2(0.0f, 0.0f);
        6:10446-block 58
call    0 returned 6
        6:10447:            io.MouseDragMaxDistanceSqr[i] = 0.0f;
        -:10448:        }
     5379:10449:        else if (io.MouseDown[i])
     5379:10449-block 60
branch  0 taken 148 (fallthrough)
branch  1 taken 5231
        -:10450:        {
        -:10451:            // Maintain the maximum distance we reaching from the initial click position, which is used with dragging threshold
     148*:10452:            ImVec2 delta_from_click_pos = IsMousePosValid(&io.MousePos) ? (io.MousePos - io.MouseClickedPos[i]) : ImVec2(0.0f, 0.0f);
      148:10452-block 61
call    0 returned 148
branch  1 taken 148 (fallthrough)
branch  2 taken 0
      148:10452-block 63
call    3 returned 148
    %%%%%:10452-block 64
call    4 never executed
      148:10453:            io.MouseDragMaxDistanceSqr[i] = ImMax(io.MouseDragMaxDistanceSqr[i], ImLengthSqr(delta_from_click_pos));
      148:10453-block 65
call    0 returned 148
call    1 returned 148
      148:10454:            io.MouseDragMaxDistanceAbs[i].x = ImMax(io.MouseDragMaxDistanceAbs[i].x, delta_from_click_pos.x < 0.0f ? -delta_from_click_pos.x : delta_from_click_pos.x);
branch  0 taken 82 (fallthrough)
branch  1 taken 66
       82:10454-block 68
       66:10454-block 69
      148:10454-block 70
call    2 returned 148
     148*:10455:            io.MouseDragMaxDistanceAbs[i].y = ImMax(io.MouseDragMaxDistanceAbs[i].y, delta_from_click_pos.y < 0.0f ? -delta_from_click_pos.y : delta_from_click_pos.y);
branch  0 taken 0 (fallthrough)
branch  1 taken 148
    %%%%%:10455-block 72
      148:10455-block 73
      148:10455-block 74
call    2 returned 148
        -:10456:        }
        -:10457:
        -:10458:        // We provide io.MouseDoubleClicked[] as a legacy service
     5385:10459:        io.MouseDoubleClicked[i] = (io.MouseClickedCount[i] == 2);
        -:10460:
        -:10461:        // Clicking any mouse button reactivate mouse hovering which may have been deactivated by keyboard/gamepad navigation
     5385:10462:        if (io.MouseClicked[i])
     5385:10462-block 76
branch  0 taken 6 (fallthrough)
branch  1 taken 5379
        6:10463:            g.NavHighlightItemUnderNav = false;
        6:10463-block 77
        -:10464:    }
     1077:10465:}
        -:10466:
function _ZL18LockWheelingWindowP11ImGuiWindowf called 0 returned 0% blocks executed 0%
    #####:10467:static void LockWheelingWindow(ImGuiWindow* window, float wheel_amount)
        -:10468:{
    #####:10469:    ImGuiContext& g = *GImGui;
    #####:10470:    if (window)
    %%%%%:10470-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:10471:        g.WheelingWindowReleaseTimer = ImMin(g.WheelingWindowReleaseTimer + ImAbs(wheel_amount) * WINDOWS_MOUSE_WHEEL_SCROLL_LOCK_TIMER, WINDOWS_MOUSE_WHEEL_SCROLL_LOCK_TIMER);
    %%%%%:10471-block 3
call    0 never executed
call    1 never executed
        -:10472:    else
    #####:10473:        g.WheelingWindowReleaseTimer = 0.0f;
    %%%%%:10473-block 6
    #####:10474:    if (g.WheelingWindow == window)
    %%%%%:10474-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:10475:        return;
    %%%%%:10475-block 8
    #####:10476:    IMGUI_DEBUG_LOG_IO("[io] LockWheelingWindow() \"%s\"\n", window ? window->Name : "NULL");
    %%%%%:10476-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10476-block 10
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:10476-block 11
    %%%%%:10476-block 12
    %%%%%:10476-block 13
call    4 never executed
    #####:10477:    g.WheelingWindow = window;
    #####:10478:    g.WheelingWindowRefMousePos = g.IO.MousePos;
    #####:10479:    if (window == NULL)
    %%%%%:10479-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
        -:10480:    {
    #####:10481:        g.WheelingWindowStartFrame = -1;
    #####:10482:        g.WheelingAxisAvg = ImVec2(0.0f, 0.0f);
    %%%%%:10482-block 15
call    0 never executed
        -:10483:    }
        -:10484:}
        -:10485:
function _ZL22FindBestWheelingWindowRK6ImVec2 called 0 returned 0% blocks executed 0%
    #####:10486:static ImGuiWindow* FindBestWheelingWindow(const ImVec2& wheel)
        -:10487:{
        -:10488:    // For each axis, find window in the hierarchy that may want to use scrolling
    #####:10489:    ImGuiContext& g = *GImGui;
    #####:10490:    ImGuiWindow* windows[2] = { NULL, NULL };
    #####:10491:    for (int axis = 0; axis < 2; axis++)
    %%%%%:10491-block 2
    %%%%%:10491-block 17
    %%%%%:10491-block 18
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:10492:        if (wheel[axis] != 0.0f)
    %%%%%:10492-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:10493:            for (ImGuiWindow* window = windows[axis] = g.HoveredWindow; window->Flags & ImGuiWindowFlags_ChildWindow; window = windows[axis] = window->ParentWindow)
    %%%%%:10493-block 5
    %%%%%:10493-block 14
    %%%%%:10493-block 15
branch  0 never executed
branch  1 never executed (fallthrough)
        -:10494:            {
        -:10495:                // Bubble up into parent window if:
        -:10496:                // - a child window doesn't allow any scrolling.
        -:10497:                // - a child window has the ImGuiWindowFlags_NoScrollWithMouse flag.
        -:10498:                //// - a child window doesn't need scrolling because it is already at the edge for the direction we are going in (FIXME-WIP)
    #####:10499:                const bool has_scrolling = (window->ScrollMax[axis] != 0.0f);
    %%%%%:10499-block 6
call    0 never executed
    #####:10500:                const bool inputs_disabled = (window->Flags & ImGuiWindowFlags_NoScrollWithMouse) && !(window->Flags & ImGuiWindowFlags_NoMouseInputs);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10500-block 8
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:10500-block 9
    %%%%%:10500-block 10
        -:10501:                //const bool scrolling_past_limits = (wheel_v < 0.0f) ? (window->Scroll[axis] <= 0.0f) : (window->Scroll[axis] >= window->ScrollMax[axis]);
    #####:10502:                if (has_scrolling && !inputs_disabled) // && !scrolling_past_limits)
    %%%%%:10502-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10502-block 12
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:10503:                    break; // select this window
    %%%%%:10503-block 13
        -:10504:            }
    #####:10505:    if (windows[0] == NULL && windows[1] == NULL)
    %%%%%:10505-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10505-block 20
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:10506:        return NULL;
    %%%%%:10506-block 21
        -:10507:
        -:10508:    // If there's only one window or only one axis then there's no ambiguity
    #####:10509:    if (windows[0] == windows[1] || windows[0] == NULL || windows[1] == NULL)
    %%%%%:10509-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10509-block 23
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:10509-block 24
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:10510:        return windows[1] ? windows[1] : windows[0];
    %%%%%:10510-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10510-block 26
    %%%%%:10510-block 27
    %%%%%:10510-block 28
        -:10511:
        -:10512:    // If candidate are different windows we need to decide which one to prioritize
        -:10513:    // - First frame: only find a winner if one axis is zero.
        -:10514:    // - Subsequent frames: only find a winner when one is more than the other.
    #####:10515:    if (g.WheelingWindowStartFrame == -1)
    %%%%%:10515-block 29
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:10516:        g.WheelingWindowStartFrame = g.FrameCount;
    %%%%%:10516-block 30
    #####:10517:    if ((g.WheelingWindowStartFrame == g.FrameCount && wheel.x != 0.0f && wheel.y != 0.0f) || (g.WheelingAxisAvg.x == g.WheelingAxisAvg.y))
    %%%%%:10517-block 31
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10517-block 32
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:10517-block 33
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:10517-block 34
branch  6 never executed (fallthrough)
branch  7 never executed
        -:10518:    {
    #####:10519:        g.WheelingWindowWheelRemainder = wheel;
    #####:10520:        return NULL;
    %%%%%:10520-block 35
        -:10521:    }
    #####:10522:    return (g.WheelingAxisAvg.x > g.WheelingAxisAvg.y) ? windows[0] : windows[1];
    %%%%%:10522-block 36
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10522-block 37
    %%%%%:10522-block 38
    %%%%%:10522-block 39
        -:10523:}
        -:10524:
        -:10525:// Called by NewFrame()
function _ZN5ImGuiL16UpdateMouseWheelEv called 1077 returned 100% blocks executed 26%
     1077:10526:void ImGui::UpdateMouseWheel()
        -:10527:{
        -:10528:    // Reset the locked window if we move the mouse or after the timer elapses.
        -:10529:    // FIXME: Ideally we could refactor to have one timer for "changing window w/ same axis" and a shorter timer for "changing window or axis w/ other axis" (#3795)
     1077:10530:    ImGuiContext& g = *GImGui;
     1077:10531:    if (g.WheelingWindow != NULL)
     1077:10531-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
        -:10532:    {
    #####:10533:        g.WheelingWindowReleaseTimer -= g.IO.DeltaTime;
    #####:10534:        if (IsMousePosValid() && ImLengthSqr(g.IO.MousePos - g.WheelingWindowRefMousePos) > g.IO.MouseDragThreshold * g.IO.MouseDragThreshold)
    %%%%%:10534-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:10534-block 5
call    3 never executed
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:10534-block 8
    %%%%%:10534-block 9
    %%%%%:10534-block 10
branch  7 never executed (fallthrough)
branch  8 never executed
    #####:10535:            g.WheelingWindowReleaseTimer = 0.0f;
    %%%%%:10535-block 11
    #####:10536:        if (g.WheelingWindowReleaseTimer <= 0.0f)
    %%%%%:10536-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:10537:            LockWheelingWindow(NULL, 0.0f);
    %%%%%:10537-block 13
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:10538:    }
        -:10539:
     1077:10540:    ImVec2 wheel;
    1077*:10541:    wheel.x = TestKeyOwner(ImGuiKey_MouseWheelX, ImGuiKeyOwner_NoOwner) ? g.IO.MouseWheelH : 0.0f;
     1077:10541-block 14
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0
     1077:10541-block 16
    %%%%%:10541-block 17
    1077*:10542:    wheel.y = TestKeyOwner(ImGuiKey_MouseWheelY, ImGuiKeyOwner_NoOwner) ? g.IO.MouseWheel : 0.0f;
     1077:10542-block 18
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0
     1077:10542-block 20
    %%%%%:10542-block 21
        -:10543:
        -:10544:    //IMGUI_DEBUG_LOG("MouseWheel X:%.3f Y:%.3f\n", wheel_x, wheel_y);
    1077*:10545:    ImGuiWindow* mouse_window = g.WheelingWindow ? g.WheelingWindow : g.HoveredWindow;
     1077:10545-block 22
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:10545-block 23
     1077:10545-block 24
     1077:10546:    if (!mouse_window || mouse_window->Collapsed)
     1077:10546-block 25
branch  0 taken 1076 (fallthrough)
branch  1 taken 1
     1076:10546-block 26
branch  2 taken 0 (fallthrough)
branch  3 taken 1076
     1077:10547:        return;
        1:10547-block 27
     1077:10547-block 98
        -:10548:
        -:10549:    // Zoom / Scale window
        -:10550:    // FIXME-OBSOLETE: This is an old feature, it still works but pretty much nobody is using it and may be best redesigned.
    1076*:10551:    if (wheel.y != 0.0f && g.IO.KeyCtrl && g.IO.FontAllowUserScaling)
     1076:10551-block 28
branch  0 taken 0 (fallthrough)
branch  1 taken 1076
    %%%%%:10551-block 29
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:10551-block 30
branch  4 never executed (fallthrough)
branch  5 never executed
        -:10552:    {
    #####:10553:        LockWheelingWindow(mouse_window, wheel.y);
    %%%%%:10553-block 31
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:10554:        ImGuiWindow* window = mouse_window;
    #####:10555:        const float new_font_scale = ImClamp(window->FontWindowScale + g.IO.MouseWheel * 0.10f, 0.50f, 2.50f);
    %%%%%:10555-block 32
call    0 never executed
    #####:10556:        const float scale = new_font_scale / window->FontWindowScale;
    #####:10557:        window->FontWindowScale = new_font_scale;
    #####:10558:        if (window == window->RootWindow)
branch  0 never executed (fallthrough)
branch  1 never executed
        -:10559:        {
    #####:10560:            const ImVec2 offset = window->Size * (1.0f - scale) * (g.IO.MousePos - window->Pos) / window->Size;
    %%%%%:10560-block 34
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:10561:            SetWindowPos(window, window->Pos + offset, 0);
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$:10561-block 100
    #####:10562:            window->Size = ImTrunc(window->Size * scale);
    %%%%%:10562-block 40
call    0 never executed
call    1 never executed
    #####:10563:            window->SizeFull = ImTrunc(window->SizeFull * scale);
call    0 never executed
call    1 never executed
        -:10564:        }
    #####:10565:        return;
    %%%%%:10565-block 45
        -:10566:    }
     1076:10567:    if (g.IO.KeyCtrl)
     1076:10567-block 46
branch  0 taken 0 (fallthrough)
branch  1 taken 1076
    #####:10568:        return;
    %%%%%:10568-block 47
        -:10569:
        -:10570:    // Mouse wheel scrolling
        -:10571:    // Read about io.MouseWheelRequestAxisSwap and its issue on Mac+Emscripten in UpdateMouseInputs()
     1076:10572:    if (g.IO.MouseWheelRequestAxisSwap)
     1076:10572-block 48
branch  0 taken 0 (fallthrough)
branch  1 taken 1076
    #####:10573:        wheel = ImVec2(wheel.y, 0.0f);
    %%%%%:10573-block 49
call    0 never executed
        -:10574:
        -:10575:    // Maintain a rough average of moving magnitude on both axises
        -:10576:    // FIXME: should by based on wall clock time rather than frame-counter
     1076:10577:    g.WheelingAxisAvg.x = ImExponentialMovingAverage(g.WheelingAxisAvg.x, ImAbs(wheel.x), 30);
     1076:10577-block 51
call    0 returned 1076
call    1 returned 1076
     1076:10578:    g.WheelingAxisAvg.y = ImExponentialMovingAverage(g.WheelingAxisAvg.y, ImAbs(wheel.y), 30);
call    0 returned 1076
call    1 returned 1076
        -:10579:
        -:10580:    // In the rare situation where FindBestWheelingWindow() had to defer first frame of wheeling due to ambiguous main axis, reinject it now.
     1076:10581:    wheel += g.WheelingWindowWheelRemainder;
call    0 returned 1076
     1076:10582:    g.WheelingWindowWheelRemainder = ImVec2(0.0f, 0.0f);
call    0 returned 1076
     1076:10583:    if (wheel.x == 0.0f && wheel.y == 0.0f)
branch  0 taken 1076 (fallthrough)
branch  1 taken 0
     1076:10583-block 58
branch  2 taken 1076 (fallthrough)
branch  3 taken 0
     1076:10584:        return;
     1076:10584-block 59
        -:10585:
        -:10586:    // Mouse wheel scrolling: find target and apply
        -:10587:    // - don't renew lock if axis doesn't apply on the window.
        -:10588:    // - select a main axis when both axises are being moved.
    #####:10589:    if (ImGuiWindow* window = (g.WheelingWindow ? g.WheelingWindow : FindBestWheelingWindow(wheel)))
    %%%%%:10589-block 60
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10589-block 61
    %%%%%:10589-block 62
call    2 never executed
    %%%%%:10589-block 63
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:10590:        if (!(window->Flags & ImGuiWindowFlags_NoScrollWithMouse) && !(window->Flags & ImGuiWindowFlags_NoMouseInputs))
    %%%%%:10590-block 64
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10590-block 65
branch  2 never executed (fallthrough)
branch  3 never executed
        -:10591:        {
    #####:10592:            bool do_scroll[2] = { wheel.x != 0.0f && window->ScrollMax.x != 0.0f, wheel.y != 0.0f && window->ScrollMax.y != 0.0f };
    %%%%%:10592-block 66
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10592-block 67
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:10592-block 68
    %%%%%:10592-block 69
    %%%%%:10592-block 70
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:10592-block 71
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%:10592-block 72
    %%%%%:10592-block 73
    #####:10593:            if (do_scroll[ImGuiAxis_X] && do_scroll[ImGuiAxis_Y])
    %%%%%:10593-block 74
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10593-block 75
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:10594:                do_scroll[(g.WheelingAxisAvg.x > g.WheelingAxisAvg.y) ? ImGuiAxis_Y : ImGuiAxis_X] = false;
    %%%%%:10594-block 76
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10594-block 77
    %%%%%:10594-block 78
    %%%%%:10594-block 79
    #####:10595:            if (do_scroll[ImGuiAxis_X])
    %%%%%:10595-block 80
branch  0 never executed (fallthrough)
branch  1 never executed
        -:10596:            {
    #####:10597:                LockWheelingWindow(window, wheel.x);
    %%%%%:10597-block 81
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:10598:                float max_step = window->InnerRect.GetWidth() * 0.67f;
    %%%%%:10598-block 82
call    0 never executed
    #####:10599:                float scroll_step = ImTrunc(ImMin(2 * window->CalcFontSize(), max_step));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:10600:                SetScrollX(window, window->Scroll.x - wheel.x * scroll_step);
call    0 never executed
    #####:10601:                g.WheelingWindowScrolledFrame = g.FrameCount;
        -:10602:            }
    #####:10603:            if (do_scroll[ImGuiAxis_Y])
    %%%%%:10603-block 88
branch  0 never executed (fallthrough)
branch  1 never executed
        -:10604:            {
    #####:10605:                LockWheelingWindow(window, wheel.y);
    %%%%%:10605-block 89
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:10606:                float max_step = window->InnerRect.GetHeight() * 0.67f;
    %%%%%:10606-block 90
call    0 never executed
    #####:10607:                float scroll_step = ImTrunc(ImMin(5 * window->CalcFontSize(), max_step));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:10608:                SetScrollY(window, window->Scroll.y - wheel.y * scroll_step);
call    0 never executed
    #####:10609:                g.WheelingWindowScrolledFrame = g.FrameCount;
        -:10610:            }
        -:10611:        }
        -:10612:}
        -:10613:
function _ZN5ImGui31SetNextFrameWantCaptureKeyboardEb called 0 returned 0% blocks executed 0%
    #####:10614:void ImGui::SetNextFrameWantCaptureKeyboard(bool want_capture_keyboard)
        -:10615:{
    #####:10616:    ImGuiContext& g = *GImGui;
    #####:10617:    g.WantCaptureKeyboardNextFrame = want_capture_keyboard ? 1 : 0;
    %%%%%:10617-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10617-block 3
    %%%%%:10617-block 4
    #####:10618:}
        -:10619:
function _ZN5ImGui28SetNextFrameWantCaptureMouseEb called 0 returned 0% blocks executed 0%
    #####:10620:void ImGui::SetNextFrameWantCaptureMouse(bool want_capture_mouse)
        -:10621:{
    #####:10622:    ImGuiContext& g = *GImGui;
    #####:10623:    g.WantCaptureMouseNextFrame = want_capture_mouse ? 1 : 0;
    %%%%%:10623-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10623-block 3
    %%%%%:10623-block 4
    #####:10624:}
        -:10625:
        -:10626:#ifndef IMGUI_DISABLE_DEBUG_TOOLS
function _ZL18GetInputSourceName16ImGuiInputSource called 0 returned 0% blocks executed 0%
    #####:10627:static const char* GetInputSourceName(ImGuiInputSource source)
        -:10628:{
    #####:10629:    const char* input_source_names[] = { "None", "Mouse", "Keyboard", "Gamepad" };
    #####:10630:    IM_ASSERT(IM_ARRAYSIZE(input_source_names) == ImGuiInputSource_COUNT && source >= 0 && source < ImGuiInputSource_COUNT);
    %%%%%:10630-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10630-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:10630-block 4
    %%%%%:10630-block 5
call    4 never executed
    #####:10631:    return input_source_names[source];
    %%%%%:10631-block 6
        -:10632:}
function _ZL18GetMouseSourceName16ImGuiMouseSource called 0 returned 0% blocks executed 0%
    #####:10633:static const char* GetMouseSourceName(ImGuiMouseSource source)
        -:10634:{
    #####:10635:    const char* mouse_source_names[] = { "Mouse", "TouchScreen", "Pen" };
    #####:10636:    IM_ASSERT(IM_ARRAYSIZE(mouse_source_names) == ImGuiMouseSource_COUNT && source >= 0 && source < ImGuiMouseSource_COUNT);
    %%%%%:10636-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10636-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:10636-block 4
    %%%%%:10636-block 5
call    4 never executed
    #####:10637:    return mouse_source_names[source];
    %%%%%:10637-block 6
        -:10638:}
function _ZL20DebugPrintInputEventPKcPK15ImGuiInputEvent called 0 returned 0% blocks executed 0%
    #####:10639:static void DebugPrintInputEvent(const char* prefix, const ImGuiInputEvent* e)
        -:10640:{
    #####:10641:    ImGuiContext& g = *GImGui;
    #####:10642:    if (e->Type == ImGuiInputEventType_MousePos)    { if (e->MousePos.PosX == -FLT_MAX && e->MousePos.PosY == -FLT_MAX) IMGUI_DEBUG_LOG_IO("[io] %s: MousePos (-FLT_MAX, -FLT_MAX)\n", prefix); else IMGUI_DEBUG_LOG_IO("[io] %s: MousePos (%.1f, %.1f) (%s)\n", prefix, e->MousePos.PosX, e->MousePos.PosY, GetMouseSourceName(e->MousePos.MouseSource)); return; }
    %%%%%:10642-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10642-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:10642-block 4
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:10642-block 5
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%:10642-block 6
call    8 never executed
    %%%%%:10642-block 7
    %%%%%:10642-block 8
branch  9 never executed (fallthrough)
branch 10 never executed
    %%%%%:10642-block 9
call   11 never executed
call   12 never executed
    %%%%%:10642-block 11
    #####:10643:    if (e->Type == ImGuiInputEventType_MouseButton) { IMGUI_DEBUG_LOG_IO("[io] %s: MouseButton %d %s (%s)\n", prefix, e->MouseButton.Button, e->MouseButton.Down ? "Down" : "Up", GetMouseSourceName(e->MouseButton.MouseSource)); return; }
    %%%%%:10643-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10643-block 13
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:10643-block 14
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:10643-block 16
    %%%%%:10643-block 17
    %%%%%:10643-block 18
call    7 never executed
    %%%%%:10643-block 19
    #####:10644:    if (e->Type == ImGuiInputEventType_MouseWheel)  { IMGUI_DEBUG_LOG_IO("[io] %s: MouseWheel (%.3f, %.3f) (%s)\n", prefix, e->MouseWheel.WheelX, e->MouseWheel.WheelY, GetMouseSourceName(e->MouseWheel.MouseSource)); return; }
    %%%%%:10644-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10644-block 21
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:10644-block 22
call    4 never executed
call    5 never executed
    %%%%%:10644-block 24
    #####:10645:    if (e->Type == ImGuiInputEventType_MouseViewport){IMGUI_DEBUG_LOG_IO("[io] %s: MouseViewport (0x%08X)\n", prefix, e->MouseViewport.HoveredViewportID); return; }
    %%%%%:10645-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10645-block 26
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:10645-block 27
call    4 never executed
    %%%%%:10645-block 28
    #####:10646:    if (e->Type == ImGuiInputEventType_Key)         { IMGUI_DEBUG_LOG_IO("[io] %s: Key \"%s\" %s\n", prefix, ImGui::GetKeyName(e->Key.Key), e->Key.Down ? "Down" : "Up"); return; }
    %%%%%:10646-block 29
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10646-block 30
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:10646-block 31
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:10646-block 32
    %%%%%:10646-block 33
    %%%%%:10646-block 34
call    6 never executed
call    7 never executed
    %%%%%:10646-block 36
    #####:10647:    if (e->Type == ImGuiInputEventType_Text)        { IMGUI_DEBUG_LOG_IO("[io] %s: Text: %c (U+%08X)\n", prefix, e->Text.Char, e->Text.Char); return; }
    %%%%%:10647-block 37
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10647-block 38
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:10647-block 39
call    4 never executed
    %%%%%:10647-block 40
    #####:10648:    if (e->Type == ImGuiInputEventType_Focus)       { IMGUI_DEBUG_LOG_IO("[io] %s: AppFocused %d\n", prefix, e->AppFocused.Focused); return; }
    %%%%%:10648-block 41
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10648-block 42
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:10648-block 43
call    4 never executed
    %%%%%:10648-block 44
        -:10649:}
        -:10650:#endif
        -:10651:
        -:10652:// Process input queue
        -:10653:// We always call this with the value of 'bool g.IO.ConfigInputTrickleEventQueue'.
        -:10654:// - trickle_fast_inputs = false : process all events, turn into flattened input state (e.g. successive down/up/down/up will be lost)
        -:10655:// - trickle_fast_inputs = true  : process as many events as possible (successive down/up/down/up will be trickled over several frames so nothing is lost) (new feature in 1.87)
function _ZN5ImGui17UpdateInputEventsEb called 1077 returned 100% blocks executed 55%
     1077:10656:void ImGui::UpdateInputEvents(bool trickle_fast_inputs)
        -:10657:{
     1077:10658:    ImGuiContext& g = *GImGui;
     1077:10659:    ImGuiIO& io = g.IO;
        -:10660:
        -:10661:    // Only trickle chars<>key when working with InputText()
        -:10662:    // FIXME: InputText() could parse event trail?
        -:10663:    // FIXME: Could specialize chars<>keys trickling rules for control keys (those not typically associated to characters)
    1077*:10664:    const bool trickle_interleaved_nonchar_keys_and_text = (trickle_fast_inputs && g.WantTextInputNextFrame == 1);
     1077:10664-block 2
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:10664-block 3
branch  2 taken 0 (fallthrough)
branch  3 taken 1077
    %%%%%:10664-block 4
     1077:10664-block 5
        -:10665:
     1077:10666:    bool mouse_moved = false, mouse_wheeled = false, key_changed = false, key_changed_nonchar = false, text_inputted = false;
     1077:10667:    int  mouse_button_changed = 0x00;
     1077:10668:    ImBitArray<ImGuiKey_KeysData_SIZE> key_changed_mask;
     1077:10668-block 6
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -:10669:
     1077:10670:    int event_n = 0;
     1571:10671:    for (; event_n < g.InputEventsQueue.Size; event_n++)
     1077:10671-block 7
      494:10671-block 86
     1571:10671-block 87
branch  0 taken 494
branch  1 taken 1077 (fallthrough)
        -:10672:    {
      494:10673:        ImGuiInputEvent* e = &g.InputEventsQueue[event_n];
      494:10673-block 8
call    0 returned 494
      494:10674:        if (e->Type == ImGuiInputEventType_MousePos)
branch  0 taken 479 (fallthrough)
branch  1 taken 15
        -:10675:        {
     479*:10676:            if (g.IO.WantSetMousePos)
      479:10676-block 10
branch  0 taken 0 (fallthrough)
branch  1 taken 479
    #####:10677:                continue;
    %%%%%:10677-block 11
        -:10678:            // Trickling Rule: Stop processing queued events if we already handled a mouse button change
      479:10679:            ImVec2 event_pos(e->MousePos.PosX, e->MousePos.PosY);
      479:10679-block 12
call    0 returned 479
      479:10680:            if (trickle_fast_inputs && (mouse_button_changed != 0 || mouse_wheeled || key_changed || text_inputted))
branch  0 taken 479 (fallthrough)
branch  1 taken 0
      479:10680-block 14
branch  2 taken 479 (fallthrough)
branch  3 taken 0
      479:10680-block 15
branch  4 taken 479 (fallthrough)
branch  5 taken 0
      479:10680-block 16
branch  6 taken 479 (fallthrough)
branch  7 taken 0
      479:10680-block 17
branch  8 taken 479 (fallthrough)
branch  9 taken 0
        -:10681:                break;
      479:10682:            io.MousePos = event_pos;
      479:10683:            io.MouseSource = e->MousePos.MouseSource;
      479:10684:            mouse_moved = true;
      479:10684-block 18
        -:10685:        }
       15:10686:        else if (e->Type == ImGuiInputEventType_MouseButton)
       15:10686-block 20
branch  0 taken 12 (fallthrough)
branch  1 taken 3
        -:10687:        {
        -:10688:            // Trickling Rule: Stop processing queued events if we got multiple action on the same button
       12:10689:            const ImGuiMouseButton button = e->MouseButton.Button;
      12*:10690:            IM_ASSERT(button >= 0 && button < ImGuiMouseButton_COUNT);
       12:10690-block 21
branch  0 taken 12 (fallthrough)
branch  1 taken 0
       12:10690-block 22
branch  2 taken 12 (fallthrough)
branch  3 taken 0
       12:10690-block 23
    %%%%%:10690-block 24
call    4 never executed
       12:10691:            if (trickle_fast_inputs && ((mouse_button_changed & (1 << button)) || mouse_wheeled))
       12:10691-block 25
branch  0 taken 12 (fallthrough)
branch  1 taken 0
       12:10691-block 26
branch  2 taken 12 (fallthrough)
branch  3 taken 0
       12:10691-block 27
branch  4 taken 12 (fallthrough)
branch  5 taken 0
        -:10692:                break;
      12*:10693:            if (trickle_fast_inputs && e->MouseButton.MouseSource == ImGuiMouseSource_TouchScreen && mouse_moved) // #2702: TouchScreen have no initial hover.
       12:10693-block 28
branch  0 taken 12 (fallthrough)
branch  1 taken 0
       12:10693-block 29
branch  2 taken 0 (fallthrough)
branch  3 taken 12
    %%%%%:10693-block 30
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:10694:                break;
    %%%%%:10694-block 31
       12:10695:            io.MouseDown[button] = e->MouseButton.Down;
       12:10696:            io.MouseSource = e->MouseButton.MouseSource;
       12:10697:            mouse_button_changed |= (1 << button);
       12:10697-block 32
        -:10698:        }
        3:10699:        else if (e->Type == ImGuiInputEventType_MouseWheel)
        3:10699-block 33
branch  0 taken 0 (fallthrough)
branch  1 taken 3
        -:10700:        {
        -:10701:            // Trickling Rule: Stop processing queued events if we got multiple action on the event
    #####:10702:            if (trickle_fast_inputs && (mouse_moved || mouse_button_changed != 0))
    %%%%%:10702-block 34
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10702-block 35
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:10702-block 36
branch  4 never executed (fallthrough)
branch  5 never executed
        -:10703:                break;
    #####:10704:            io.MouseWheelH += e->MouseWheel.WheelX;
    #####:10705:            io.MouseWheel += e->MouseWheel.WheelY;
    #####:10706:            io.MouseSource = e->MouseWheel.MouseSource;
    #####:10707:            mouse_wheeled = true;
    %%%%%:10707-block 37
        -:10708:        }
        3:10709:        else if (e->Type == ImGuiInputEventType_MouseViewport)
        3:10709-block 38
branch  0 taken 1 (fallthrough)
branch  1 taken 2
        -:10710:        {
        1:10711:            io.MouseHoveredViewport = e->MouseViewport.HoveredViewportID;
        1:10711-block 39
        -:10712:        }
        2:10713:        else if (e->Type == ImGuiInputEventType_Key)
        2:10713-block 40
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        -:10714:        {
        -:10715:            // Trickling Rule: Stop processing queued events if we got multiple action on the same button
       2*:10716:            if (io.ConfigFlags & ImGuiConfigFlags_NoKeyboard)
        2:10716-block 41
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:10717:                continue;
    %%%%%:10717-block 42
        2:10718:            ImGuiKey key = e->Key.Key;
       2*:10719:            IM_ASSERT(key != ImGuiKey_None);
        2:10719-block 43
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:10719-block 44
call    2 never executed
        2:10720:            ImGuiKeyData* key_data = GetKeyData(key);
        2:10720-block 45
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        2:10721:            const int key_data_index = (int)(key_data - g.IO.KeysData);
       2*:10722:            if (trickle_fast_inputs && key_data->Down != e->Key.Down && (key_changed_mask.TestBit(key_data_index) || mouse_button_changed != 0))
        2:10722-block 46
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2:10722-block 47
branch  2 taken 2 (fallthrough)
branch  3 taken 0
        2:10722-block 48
call    4 returned 2
branch  5 taken 2 (fallthrough)
branch  6 taken 0
        2:10722-block 50
branch  7 taken 0 (fallthrough)
branch  8 taken 2
    %%%%%:10722-block 51
        2:10722-block 52
        2:10722-block 53
branch  9 taken 0 (fallthrough)
branch 10 taken 2
    #####:10723:                break;
    %%%%%:10723-block 54
        -:10724:
        2:10725:            const bool key_is_potentially_for_char_input = IsKeyChordPotentiallyCharInput(GetMergedModsFromKeys() | key);
        2:10725-block 55
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        2:10725-block 56
call    3 returned 2
branch  4 taken 2 (fallthrough)
branch  5 taken 0 (throw)
       2*:10726:            if (trickle_interleaved_nonchar_keys_and_text && (text_inputted && !key_is_potentially_for_char_input))
        2:10726-block 57
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:10726-block 58
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:10726-block 59
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:10727:                break;
    %%%%%:10727-block 60
        -:10728:
        2:10729:            key_data->Down = e->Key.Down;
        2:10730:            key_data->AnalogValue = e->Key.AnalogValue;
        2:10731:            key_changed = true;
        2:10732:            key_changed_mask.SetBit(key_data_index);
        2:10732-block 61
call    0 returned 2
       2*:10733:            if (trickle_interleaved_nonchar_keys_and_text && !key_is_potentially_for_char_input)
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:10733-block 63
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:10734:                key_changed_nonchar = true;
    %%%%%:10734-block 64
        -:10735:
        -:10736:            // Allow legacy code using io.KeysDown[GetKeyIndex()] with new backends
        -:10737:#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
        2:10738:            io.KeysDown[key_data_index] = key_data->Down;
        2:10739:            if (io.KeyMap[key_data_index] != -1)
        2:10739-block 65
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1:10740:                io.KeysDown[io.KeyMap[key_data_index]] = key_data->Down;
        1:10740-block 66
        -:10741:#endif
        -:10742:        }
    #####:10743:        else if (e->Type == ImGuiInputEventType_Text)
    %%%%%:10743-block 67
branch  0 never executed (fallthrough)
branch  1 never executed
        -:10744:        {
    #####:10745:            if (io.ConfigFlags & ImGuiConfigFlags_NoKeyboard)
    %%%%%:10745-block 68
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:10746:                continue;
    %%%%%:10746-block 69
        -:10747:            // Trickling Rule: Stop processing queued events if keys/mouse have been interacted with
    #####:10748:            if (trickle_fast_inputs && (mouse_button_changed != 0 || mouse_moved || mouse_wheeled))
    %%%%%:10748-block 70
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10748-block 71
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:10748-block 72
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:10748-block 73
branch  6 never executed (fallthrough)
branch  7 never executed
        -:10749:                break;
    #####:10750:            if (trickle_interleaved_nonchar_keys_and_text && key_changed_nonchar)
    %%%%%:10750-block 74
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10750-block 75
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:10751:                break;
    %%%%%:10751-block 76
    #####:10752:            unsigned int c = e->Text.Char;
    #####:10753:            io.InputQueueCharacters.push_back(c <= IM_UNICODE_CODEPOINT_MAX ? (ImWchar)c : IM_UNICODE_CODEPOINT_INVALID);
    %%%%%:10753-block 77
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10753-block 78
    %%%%%:10753-block 79
    %%%%%:10753-block 80
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    $$$$$:10753-block 110
    #####:10754:            if (trickle_interleaved_nonchar_keys_and_text)
    %%%%%:10754-block 81
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:10755:                text_inputted = true;
    %%%%%:10755-block 82
        -:10756:        }
    #####:10757:        else if (e->Type == ImGuiInputEventType_Focus)
    %%%%%:10757-block 83
branch  0 never executed (fallthrough)
branch  1 never executed
        -:10758:        {
        -:10759:            // We intentionally overwrite this and process in NewFrame(), in order to give a chance
        -:10760:            // to multi-viewports backends to queue AddFocusEvent(false) + AddFocusEvent(true) in same frame.
    #####:10761:            const bool focus_lost = !e->AppFocused.Focused;
    #####:10762:            io.AppFocusLost = focus_lost;
    %%%%%:10762-block 84
        -:10763:        }
        -:10764:        else
        -:10765:        {
    #####:10766:            IM_ASSERT(0 && "Unknown event!");
    %%%%%:10766-block 85
call    0 never executed
        -:10767:        }
        -:10768:    }
        -:10769:
        -:10770:    // Record trail (for domain-specific applications wanting to access a precise trail)
        -:10771:    //if (event_n != 0) IMGUI_DEBUG_LOG_IO("Processed: %d / Remaining: %d\n", event_n, g.InputEventsQueue.Size - event_n);
     1571:10772:    for (int n = 0; n < event_n; n++)
     1077:10772-block 88
      494:10772-block 91
     1571:10772-block 92
branch  0 taken 494
branch  1 taken 1077 (fallthrough)
      494:10773:        g.InputEventsTrail.push_back(g.InputEventsQueue[n]);
      494:10773-block 89
call    0 returned 494
call    1 returned 494
branch  2 taken 494 (fallthrough)
branch  3 taken 0 (throw)
        -:10774:
        -:10775:    // [DEBUG]
        -:10776:#ifndef IMGUI_DISABLE_DEBUG_TOOLS
     1077:10777:    if (event_n != 0 && (g.DebugLogFlags & ImGuiDebugLogFlags_EventIO))
     1077:10777-block 93
branch  0 taken 444 (fallthrough)
branch  1 taken 633
      444:10777-block 94
branch  2 taken 0 (fallthrough)
branch  3 taken 444
    #####:10778:        for (int n = 0; n < g.InputEventsQueue.Size; n++)
    %%%%%:10778-block 95
    %%%%%:10778-block 101
    %%%%%:10778-block 102
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:10779:            DebugPrintInputEvent(n < event_n ? "Processed" : "Remaining", &g.InputEventsQueue[n]);
    %%%%%:10779-block 96
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:10779-block 98
    %%%%%:10779-block 99
    %%%%%:10779-block 100
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
        -:10780:#endif
        -:10781:
        -:10782:    // Remaining events will be processed on the next frame
     1077:10783:    if (event_n == g.InputEventsQueue.Size)
     1077:10783-block 103
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:10784:        g.InputEventsQueue.resize(0);
     1077:10784-block 104
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -:10785:    else
    #####:10786:        g.InputEventsQueue.erase(g.InputEventsQueue.Data, g.InputEventsQueue.Data + event_n);
    %%%%%:10786-block 105
call    0 never executed
        -:10787:
        -:10788:    // Clear buttons state when focus is lost
        -:10789:    // - this is useful so e.g. releasing Alt after focus loss on Alt-Tab doesn't trigger the Alt menu toggle.
        -:10790:    // - we clear in EndFrame() and not now in order allow application/user code polling this flag
        -:10791:    //   (e.g. custom backend may want to clear additional data, custom widgets may want to react with a "canceling" event).
     1077:10792:    if (g.IO.AppFocusLost)
     1077:10792-block 106
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
        -:10793:    {
    #####:10794:        g.IO.ClearInputKeys();
    %%%%%:10794-block 107
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:10795:        g.IO.ClearInputMouse();
    %%%%%:10795-block 108
call    0 never executed
        -:10796:    }
     1077:10797:}
     1077:10797-block 109
        -:10798:
function _ZN5ImGui11GetKeyOwnerE8ImGuiKey called 0 returned 0% blocks executed 0%
    #####:10799:ImGuiID ImGui::GetKeyOwner(ImGuiKey key)
        -:10800:{
    #####:10801:    if (!IsNamedKeyOrMod(key))
    %%%%%:10801-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:10802:        return ImGuiKeyOwner_NoOwner;
    %%%%%:10802-block 4
        -:10803:
    #####:10804:    ImGuiContext& g = *GImGui;
    #####:10805:    ImGuiKeyOwnerData* owner_data = GetKeyOwnerData(&g, key);
    %%%%%:10805-block 5
call    0 never executed
    #####:10806:    ImGuiID owner_id = owner_data->OwnerCurr;
        -:10807:
    #####:10808:    if (g.ActiveIdUsingAllKeyboardKeys && owner_id != g.ActiveId && owner_id != ImGuiKeyOwner_Any)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10808-block 7
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:10808-block 8
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:10809:        if (key >= ImGuiKey_Keyboard_BEGIN && key < ImGuiKey_Keyboard_END)
    %%%%%:10809-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10809-block 10
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:10810:            return ImGuiKeyOwner_NoOwner;
    %%%%%:10810-block 11
        -:10811:
    #####:10812:    return owner_id;
    %%%%%:10812-block 12
        -:10813:}
        -:10814:
        -:10815:// TestKeyOwner(..., ID)   : (owner == None || owner == ID)
        -:10816:// TestKeyOwner(..., None) : (owner == None)
        -:10817:// TestKeyOwner(..., Any)  : no owner test
        -:10818:// All paths are also testing for key not being locked, for the rare cases that key have been locked with using ImGuiInputFlags_LockXXX flags.
function _ZN5ImGui12TestKeyOwnerE8ImGuiKeyj called 2421 returned 100% blocks executed 84%
     2421:10819:bool ImGui::TestKeyOwner(ImGuiKey key, ImGuiID owner_id)
        -:10820:{
     2421:10821:    if (!IsNamedKeyOrMod(key))
     2421:10821-block 2
call    0 returned 2421
branch  1 taken 20 (fallthrough)
branch  2 taken 2401
       20:10822:        return true;
       20:10822-block 4
        -:10823:
     2401:10824:    ImGuiContext& g = *GImGui;
     2401:10825:    if (g.ActiveIdUsingAllKeyboardKeys && owner_id != g.ActiveId && owner_id != ImGuiKeyOwner_Any)
     2401:10825-block 5
branch  0 taken 336 (fallthrough)
branch  1 taken 2065
      336:10825-block 6
branch  2 taken 336 (fallthrough)
branch  3 taken 0
      336:10825-block 7
branch  4 taken 224 (fallthrough)
branch  5 taken 112
      224:10826:        if (key >= ImGuiKey_Keyboard_BEGIN && key < ImGuiKey_Keyboard_END)
      224:10826-block 8
branch  0 taken 224 (fallthrough)
branch  1 taken 0
      224:10826-block 9
branch  2 taken 0 (fallthrough)
branch  3 taken 224
    #####:10827:            return false;
    %%%%%:10827-block 10
        -:10828:
     2401:10829:    ImGuiKeyOwnerData* owner_data = GetKeyOwnerData(&g, key);
     2401:10829-block 11
call    0 returned 2401
     2401:10830:    if (owner_id == ImGuiKeyOwner_Any)
branch  0 taken 199 (fallthrough)
branch  1 taken 2202
      199:10831:        return (owner_data->LockThisFrame == false);
      199:10831-block 13
        -:10832:
        -:10833:    // Note: SetKeyOwner() sets OwnerCurr. It is not strictly required for most mouse routing overlap (because of ActiveId/HoveredId
        -:10834:    // are acting as filter before this has a chance to filter), but sane as soon as user tries to look into things.
        -:10835:    // Setting OwnerCurr in SetKeyOwner() is more consistent than testing OwnerNext here: would be inconsistent with getter and other functions.
     2202:10836:    if (owner_data->OwnerCurr != owner_id)
     2202:10836-block 14
branch  0 taken 3 (fallthrough)
branch  1 taken 2199
        -:10837:    {
        3:10838:        if (owner_data->LockThisFrame)
        3:10838-block 15
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:10839:            return false;
    %%%%%:10839-block 16
        3:10840:        if (owner_data->OwnerCurr != ImGuiKeyOwner_NoOwner)
        3:10840-block 17
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:10841:            return false;
    %%%%%:10841-block 18
        -:10842:    }
        -:10843:
     2202:10844:    return true;
     2202:10844-block 19
        -:10845:}
        -:10846:
        -:10847:// _LockXXX flags are useful to lock keys away from code which is not input-owner aware.
        -:10848:// When using _LockXXX flags, you can use ImGuiKeyOwner_Any to lock keys from everyone.
        -:10849:// - SetKeyOwner(..., None)              : clears owner
        -:10850:// - SetKeyOwner(..., Any, !Lock)        : illegal (assert)
        -:10851:// - SetKeyOwner(..., Any or None, Lock) : set lock
function _ZN5ImGui11SetKeyOwnerE8ImGuiKeyji called 3 returned 100% blocks executed 71%
        3:10852:void ImGui::SetKeyOwner(ImGuiKey key, ImGuiID owner_id, ImGuiInputFlags flags)
        -:10853:{
        3:10854:    ImGuiContext& g = *GImGui;
       3*:10855:    IM_ASSERT(IsNamedKeyOrMod(key) && (owner_id != ImGuiKeyOwner_Any || (flags & (ImGuiInputFlags_LockThisFrame | ImGuiInputFlags_LockUntilRelease)))); // Can only use _Any with _LockXXX flags (to eat a key away without an ID to retrieve it)
        3:10855-block 2
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0
        3:10855-block 4
branch  3 taken 0 (fallthrough)
branch  4 taken 3
    %%%%%:10855-block 5
branch  5 never executed (fallthrough)
branch  6 never executed
        3:10855-block 6
    %%%%%:10855-block 7
call    7 never executed
       3*:10856:    IM_ASSERT((flags & ~ImGuiInputFlags_SupportedBySetKeyOwner) == 0); // Passing flags not supported by this function!
        3:10856-block 8
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%:10856-block 9
call    2 never executed
        -:10857:    //IMGUI_DEBUG_LOG("SetKeyOwner(%s, owner_id=0x%08X, flags=%08X)\n", GetKeyName(key), owner_id, flags);
        -:10858:
        3:10859:    ImGuiKeyOwnerData* owner_data = GetKeyOwnerData(&g, key);
        3:10859-block 10
call    0 returned 3
        3:10860:    owner_data->OwnerCurr = owner_data->OwnerNext = owner_id;
        -:10861:
        -:10862:    // We cannot lock by default as it would likely break lots of legacy code.
        -:10863:    // In the case of using LockUntilRelease while key is not down we still lock during the frame (no key_data->Down test)
        3:10864:    owner_data->LockUntilRelease = (flags & ImGuiInputFlags_LockUntilRelease) != 0;
       3*:10865:    owner_data->LockThisFrame = (flags & ImGuiInputFlags_LockThisFrame) != 0 || (owner_data->LockUntilRelease);
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3:10865-block 12
branch  2 taken 0 (fallthrough)
branch  3 taken 3
    %%%%%:10865-block 13
        3:10865-block 14
        3:10866:}
        -:10867:
        -:10868:// Rarely used helper
function _ZN5ImGui23SetKeyOwnersForKeyChordEiji called 0 returned 0% blocks executed 0%
    #####:10869:void ImGui::SetKeyOwnersForKeyChord(ImGuiKeyChord key_chord, ImGuiID owner_id, ImGuiInputFlags flags)
        -:10870:{
    #####:10871:    if (key_chord & ImGuiMod_Ctrl)      { SetKeyOwner(ImGuiMod_Ctrl, owner_id, flags); }
    %%%%%:10871-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10871-block 3
call    2 never executed
    #####:10872:    if (key_chord & ImGuiMod_Shift)     { SetKeyOwner(ImGuiMod_Shift, owner_id, flags); }
    %%%%%:10872-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10872-block 5
call    2 never executed
    #####:10873:    if (key_chord & ImGuiMod_Alt)       { SetKeyOwner(ImGuiMod_Alt, owner_id, flags); }
    %%%%%:10873-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10873-block 7
call    2 never executed
    #####:10874:    if (key_chord & ImGuiMod_Super)     { SetKeyOwner(ImGuiMod_Super, owner_id, flags); }
    %%%%%:10874-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10874-block 9
call    2 never executed
    #####:10875:    if (key_chord & ~ImGuiMod_Mask_)    { SetKeyOwner((ImGuiKey)(key_chord & ~ImGuiMod_Mask_), owner_id, flags); }
    %%%%%:10875-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10875-block 11
call    2 never executed
    #####:10876:}
        -:10877:
        -:10878:// This is more or less equivalent to:
        -:10879://   if (IsItemHovered() || IsItemActive())
        -:10880://       SetKeyOwner(key, GetItemID());
        -:10881:// Extensive uses of that (e.g. many calls for a single item) may want to manually perform the tests once and then call SetKeyOwner() multiple times.
        -:10882:// More advanced usage scenarios may want to call SetKeyOwner() manually based on different condition.
        -:10883:// Worth noting is that only one item can be hovered and only one item can be active, therefore this usage pattern doesn't need to bother with routing and priority.
function _ZN5ImGui15SetItemKeyOwnerE8ImGuiKeyi called 0 returned 0% blocks executed 0%
    #####:10884:void ImGui::SetItemKeyOwner(ImGuiKey key, ImGuiInputFlags flags)
        -:10885:{
    #####:10886:    ImGuiContext& g = *GImGui;
    #####:10887:    ImGuiID id = g.LastItemData.ID;
    #####:10888:    if (id == 0 || (g.HoveredId != id && g.ActiveId != id))
    %%%%%:10888-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10888-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:10888-block 4
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:10889:        return;
    %%%%%:10889-block 5
    #####:10890:    if ((flags & ImGuiInputFlags_CondMask_) == 0)
    %%%%%:10890-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:10891:        flags |= ImGuiInputFlags_CondDefault_;
    %%%%%:10891-block 7
    #####:10892:    if ((g.HoveredId == id && (flags & ImGuiInputFlags_CondHovered)) || (g.ActiveId == id && (flags & ImGuiInputFlags_CondActive)))
    %%%%%:10892-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10892-block 9
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:10892-block 10
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:10892-block 11
branch  6 never executed (fallthrough)
branch  7 never executed
        -:10893:    {
    #####:10894:        IM_ASSERT((flags & ~ImGuiInputFlags_SupportedBySetItemKeyOwner) == 0); // Passing flags not supported by this function!
    %%%%%:10894-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10894-block 13
call    2 never executed
    #####:10895:        SetKeyOwner(key, id, flags & ~ImGuiInputFlags_CondMask_);
    %%%%%:10895-block 14
call    0 never executed
        -:10896:    }
        -:10897:}
        -:10898:
function _ZN5ImGui15SetItemKeyOwnerE8ImGuiKey called 0 returned 0% blocks executed 0%
    #####:10899:void ImGui::SetItemKeyOwner(ImGuiKey key)
        -:10900:{
    #####:10901:    SetItemKeyOwner(key, ImGuiInputFlags_None);
    %%%%%:10901-block 2
call    0 never executed
    #####:10902:}
        -:10903:
        -:10904:// This is the only public API until we expose owner_id versions of the API as replacements.
function _ZN5ImGui17IsKeyChordPressedEi called 0 returned 0% blocks executed 0%
    #####:10905:bool ImGui::IsKeyChordPressed(ImGuiKeyChord key_chord)
        -:10906:{
    #####:10907:    return IsKeyChordPressed(key_chord, ImGuiInputFlags_None, ImGuiKeyOwner_Any);
    %%%%%:10907-block 2
call    0 never executed
        -:10908:}
        -:10909:
        -:10910:// This is equivalent to comparing KeyMods + doing a IsKeyPressed()
function _ZN5ImGui17IsKeyChordPressedEiij called 2154 returned 100% blocks executed 40%
     2154:10911:bool ImGui::IsKeyChordPressed(ImGuiKeyChord key_chord, ImGuiInputFlags flags, ImGuiID owner_id)
        -:10912:{
     2154:10913:    ImGuiContext& g = *GImGui;
     2154:10914:    key_chord = FixupKeyChord(key_chord);
     2154:10914-block 2
call    0 returned 2154
     2154:10915:    ImGuiKey mods = (ImGuiKey)(key_chord & ImGuiMod_Mask_);
     2154:10916:    if (g.IO.KeyMods != mods)
branch  0 taken 2154 (fallthrough)
branch  1 taken 0
     2154:10917:        return false;
     2154:10917-block 4
        -:10918:
        -:10919:    // Special storage location for mods
    #####:10920:    ImGuiKey key = (ImGuiKey)(key_chord & ~ImGuiMod_Mask_);
    #####:10921:    if (key == ImGuiKey_None)
    %%%%%:10921-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:10922:        key = ConvertSingleModFlagToKey(mods);
    %%%%%:10922-block 6
call    0 never executed
    #####:10923:    if (!IsKeyPressed(key, (flags & ImGuiInputFlags_RepeatMask_), owner_id))
    %%%%%:10923-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:10924:        return false;
    %%%%%:10924-block 9
    #####:10925:    return true;
    %%%%%:10925-block 10
        -:10926:}
        -:10927:
function _ZN5ImGui19SetNextItemShortcutEii called 0 returned 0% blocks executed 0%
    #####:10928:void ImGui::SetNextItemShortcut(ImGuiKeyChord key_chord, ImGuiInputFlags flags)
        -:10929:{
    #####:10930:    ImGuiContext& g = *GImGui;
    #####:10931:    g.NextItemData.HasFlags |= ImGuiNextItemDataFlags_HasShortcut;
    #####:10932:    g.NextItemData.Shortcut = key_chord;
    #####:10933:    g.NextItemData.ShortcutFlags = flags;
    #####:10934:}
        -:10935:
        -:10936:// Called from within ItemAdd: at this point we can read from NextItemData and write to LastItemData
function _ZN5ImGuiL18ItemHandleShortcutEj called 0 returned 0% blocks executed 0%
    #####:10937:void ImGui::ItemHandleShortcut(ImGuiID id)
        -:10938:{
    #####:10939:    ImGuiContext& g = *GImGui;
    #####:10940:    ImGuiInputFlags flags = g.NextItemData.ShortcutFlags;
    #####:10941:    IM_ASSERT((flags & ~ImGuiInputFlags_SupportedBySetNextItemShortcut) == 0); // Passing flags not supported by SetNextItemShortcut()!
    %%%%%:10941-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10941-block 3
call    2 never executed
        -:10942:
    #####:10943:    if (g.LastItemData.ItemFlags & ImGuiItemFlags_Disabled)
    %%%%%:10943-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:10944:        return;
    %%%%%:10944-block 5
    #####:10945:    if (flags & ImGuiInputFlags_Tooltip)
    %%%%%:10945-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
        -:10946:    {
    #####:10947:        g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HasShortcut;
    #####:10948:        g.LastItemData.Shortcut = g.NextItemData.Shortcut;
    %%%%%:10948-block 7
        -:10949:    }
    #####:10950:    if (!Shortcut(g.NextItemData.Shortcut, flags & ImGuiInputFlags_SupportedByShortcut, id) || g.NavActivateId != 0)
    %%%%%:10950-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:10950-block 10
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:10950-block 11
    %%%%%:10950-block 12
    %%%%%:10950-block 13
branch  5 never executed (fallthrough)
branch  6 never executed
    #####:10951:        return;
    %%%%%:10951-block 14
        -:10952:
        -:10953:    // FIXME: Generalize Activation queue?
    #####:10954:    g.NavActivateId = id; // Will effectively disable clipping.
    #####:10955:    g.NavActivateFlags = ImGuiActivateFlags_PreferInput | ImGuiActivateFlags_FromShortcut;
        -:10956:    //if (g.ActiveId == 0 || g.ActiveId == id)
    #####:10957:    g.NavActivateDownId = g.NavActivatePressedId = id;
    #####:10958:    NavHighlightActivated(id);
    %%%%%:10958-block 15
call    0 never executed
        -:10959:}
        -:10960:
function _ZN5ImGui8ShortcutEii called 0 returned 0% blocks executed 0%
    #####:10961:bool ImGui::Shortcut(ImGuiKeyChord key_chord, ImGuiInputFlags flags)
        -:10962:{
    #####:10963:    return Shortcut(key_chord, flags, ImGuiKeyOwner_Any);
    %%%%%:10963-block 2
call    0 never executed
        -:10964:}
        -:10965:
function _ZN5ImGui8ShortcutEiij called 2154 returned 100% blocks executed 62%
     2154:10966:bool ImGui::Shortcut(ImGuiKeyChord key_chord, ImGuiInputFlags flags, ImGuiID owner_id)
        -:10967:{
     2154:10968:    ImGuiContext& g = *GImGui;
        -:10969:    //IMGUI_DEBUG_LOG("Shortcut(%s, flags=%X, owner_id=0x%08X)\n", GetKeyChordName(key_chord, g.TempBuffer.Data, g.TempBuffer.Size), flags, owner_id);
        -:10970:
        -:10971:    // When using (owner_id == 0/Any): SetShortcutRouting() will use CurrentFocusScopeId and filter with this, so IsKeyPressed() is fine with he 0/Any.
     2154:10972:    if ((flags & ImGuiInputFlags_RouteTypeMask_) == 0)
     2154:10972-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 2154
    #####:10973:        flags |= ImGuiInputFlags_RouteFocused;
    %%%%%:10973-block 3
        -:10974:
        -:10975:    // Using 'owner_id == ImGuiKeyOwner_Any/0': auto-assign an owner based on current focus scope (each window has its focus scope by default)
        -:10976:    // Effectively makes Shortcut() always input-owner aware.
     2154:10977:    if (owner_id == ImGuiKeyOwner_Any || owner_id == ImGuiKeyOwner_NoOwner)
     2154:10977-block 4
branch  0 taken 2154 (fallthrough)
branch  1 taken 0
     2154:10977-block 5
branch  2 taken 0 (fallthrough)
branch  3 taken 2154
    #####:10978:        owner_id = GetRoutingIdFromOwnerId(owner_id);
    %%%%%:10978-block 6
call    0 never executed
        -:10979:
     2154:10980:    if (g.CurrentItemFlags & ImGuiItemFlags_Disabled)
     2154:10980-block 7
branch  0 taken 0 (fallthrough)
branch  1 taken 2154
    #####:10981:        return false;
    %%%%%:10981-block 8
        -:10982:
        -:10983:    // Submit route
     2154:10984:    if (!SetShortcutRouting(key_chord, flags, owner_id))
     2154:10984-block 9
call    0 returned 2154
branch  1 taken 0 (fallthrough)
branch  2 taken 2154
    #####:10985:        return false;
    %%%%%:10985-block 11
        -:10986:
        -:10987:    // Default repeat behavior for Shortcut()
        -:10988:    // So e.g. pressing Ctrl+W and releasing Ctrl while holding W will not trigger the W shortcut.
     2154:10989:    if ((flags & ImGuiInputFlags_Repeat) != 0 && (flags & ImGuiInputFlags_RepeatUntilMask_) == 0)
     2154:10989-block 12
branch  0 taken 2154 (fallthrough)
branch  1 taken 0
     2154:10989-block 13
branch  2 taken 2154 (fallthrough)
branch  3 taken 0
     2154:10990:        flags |= ImGuiInputFlags_RepeatUntilKeyModsChange;
     2154:10990-block 14
        -:10991:
     2154:10992:    if (!IsKeyChordPressed(key_chord, flags, owner_id))
     2154:10992-block 15
call    0 returned 2154
branch  1 taken 2154 (fallthrough)
branch  2 taken 0
     2154:10993:        return false;
     2154:10993-block 17
        -:10994:
        -:10995:    // Claim mods during the press
    #####:10996:    SetKeyOwnersForKeyChord(key_chord & ImGuiMod_Mask_, owner_id);
    %%%%%:10996-block 18
call    0 never executed
        -:10997:
    #####:10998:    IM_ASSERT((flags & ~ImGuiInputFlags_SupportedByShortcut) == 0); // Passing flags not supported by this function!
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10998-block 20
call    2 never executed
    #####:10999:    return true;
    %%%%%:10999-block 21
        -:11000:}
        -:11001:
        -:11002:
        -:11003://-----------------------------------------------------------------------------
        -:11004:// [SECTION] ERROR CHECKING, STATE RECOVERY
        -:11005://-----------------------------------------------------------------------------
        -:11006:// - DebugCheckVersionAndDataLayout() (called via IMGUI_CHECKVERSION() macros)
        -:11007:// - ErrorCheckUsingSetCursorPosToExtendParentBoundaries()
        -:11008:// - ErrorCheckNewFrameSanityChecks()
        -:11009:// - ErrorCheckEndFrameSanityChecks()
        -:11010:// - ErrorRecoveryStoreState()
        -:11011:// - ErrorRecoveryTryToRecoverState()
        -:11012:// - ErrorRecoveryTryToRecoverWindowState()
        -:11013:// - ErrorLog()
        -:11014://-----------------------------------------------------------------------------
        -:11015:
        -:11016:// Verify ABI compatibility between caller code and compiled version of Dear ImGui. This helps detects some build issues.
        -:11017:// Called by IMGUI_CHECKVERSION().
        -:11018:// Verify that the type sizes are matching between the calling file's compilation unit and imgui.cpp's compilation unit
        -:11019:// If this triggers you have mismatched headers and compiled code versions.
        -:11020:// - It could be because of a build issue (using new headers with old compiled code)
        -:11021:// - It could be because of mismatched configuration #define, compilation settings, packing pragma etc.
        -:11022://   THE CONFIGURATION SETTINGS MENTIONED IN imconfig.h MUST BE SET FOR ALL COMPILATION UNITS INVOLVED WITH DEAR IMGUI.
        -:11023://   Which is why it is required you put them in your imconfig file (and NOT only before including imgui.h).
        -:11024://   Otherwise it is possible that different compilation units would see different structure layout.
        -:11025://   If you don't want to modify imconfig.h you can use the IMGUI_USER_CONFIG define to change filename.
function _ZN5ImGui30DebugCheckVersionAndDataLayoutEPKcmmmmmm called 3 returned 100% blocks executed 39%
        3:11026:bool ImGui::DebugCheckVersionAndDataLayout(const char* version, size_t sz_io, size_t sz_style, size_t sz_vec2, size_t sz_vec4, size_t sz_vert, size_t sz_idx)
        -:11027:{
        3:11028:    bool error = false;
       3*:11029:    if (strcmp(version, IMGUI_VERSION) != 0) { error = true; IM_ASSERT(strcmp(version, IMGUI_VERSION) == 0 && "Mismatched version string!"); }
        3:11029-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%:11029-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:11029-block 4
call    4 never executed
       3*:11030:    if (sz_io    != sizeof(ImGuiIO))    { error = true; IM_ASSERT(sz_io == sizeof(ImGuiIO) && "Mismatched struct layout!"); }
        3:11030-block 5
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%:11030-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:11030-block 7
call    4 never executed
       3*:11031:    if (sz_style != sizeof(ImGuiStyle)) { error = true; IM_ASSERT(sz_style == sizeof(ImGuiStyle) && "Mismatched struct layout!"); }
        3:11031-block 8
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%:11031-block 9
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:11031-block 10
call    4 never executed
       3*:11032:    if (sz_vec2  != sizeof(ImVec2))     { error = true; IM_ASSERT(sz_vec2 == sizeof(ImVec2) && "Mismatched struct layout!"); }
        3:11032-block 11
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%:11032-block 12
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:11032-block 13
call    4 never executed
       3*:11033:    if (sz_vec4  != sizeof(ImVec4))     { error = true; IM_ASSERT(sz_vec4 == sizeof(ImVec4) && "Mismatched struct layout!"); }
        3:11033-block 14
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%:11033-block 15
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:11033-block 16
call    4 never executed
       3*:11034:    if (sz_vert  != sizeof(ImDrawVert)) { error = true; IM_ASSERT(sz_vert == sizeof(ImDrawVert) && "Mismatched struct layout!"); }
        3:11034-block 17
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%:11034-block 18
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:11034-block 19
call    4 never executed
       3*:11035:    if (sz_idx   != sizeof(ImDrawIdx))  { error = true; IM_ASSERT(sz_idx == sizeof(ImDrawIdx) && "Mismatched struct layout!"); }
        3:11035-block 20
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%:11035-block 21
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:11035-block 22
call    4 never executed
        3:11036:    return !error;
        3:11036-block 23
        -:11037:}
        -:11038:
        -:11039:// Until 1.89 (IMGUI_VERSION_NUM < 18814) it was legal to use SetCursorPos() to extend the boundary of a parent (e.g. window or table cell)
        -:11040:// This is causing issues and ambiguity and we need to retire that.
        -:11041:// See https://github.com/ocornut/imgui/issues/5548 for more details.
        -:11042:// [Scenario 1]
        -:11043://  Previously this would make the window content size ~200x200:
        -:11044://    Begin(...) + SetCursorScreenPos(GetCursorScreenPos() + ImVec2(200,200)) + End();  // NOT OK
        -:11045://  Instead, please submit an item:
        -:11046://    Begin(...) + SetCursorScreenPos(GetCursorScreenPos() + ImVec2(200,200)) + Dummy(ImVec2(0,0)) + End(); // OK
        -:11047://  Alternative:
        -:11048://    Begin(...) + Dummy(ImVec2(200,200)) + End(); // OK
        -:11049:// [Scenario 2]
        -:11050://  For reference this is one of the issue what we aim to fix with this change:
        -:11051://    BeginGroup() + SomeItem("foobar") + SetCursorScreenPos(GetCursorScreenPos()) + EndGroup()
        -:11052://  The previous logic made SetCursorScreenPos(GetCursorScreenPos()) have a side-effect! It would erroneously incorporate ItemSpacing.y after the item into content size, making the group taller!
        -:11053://  While this code is a little twisted, no-one would expect SetXXX(GetXXX()) to have a side-effect. Using vertical alignment patterns could trigger this issue.
function _ZN5ImGui51ErrorCheckUsingSetCursorPosToExtendParentBoundariesEv called 0 returned 0% blocks executed 0%
    #####:11054:void ImGui::ErrorCheckUsingSetCursorPosToExtendParentBoundaries()
        -:11055:{
    #####:11056:    ImGuiContext& g = *GImGui;
    #####:11057:    ImGuiWindow* window = g.CurrentWindow;
    #####:11058:    IM_ASSERT(window->DC.IsSetPos);
    %%%%%:11058-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:11058-block 3
call    2 never executed
    #####:11059:    window->DC.IsSetPos = false;
        -:11060:#ifdef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
        -:11061:    if (window->DC.CursorPos.x <= window->DC.CursorMaxPos.x && window->DC.CursorPos.y <= window->DC.CursorMaxPos.y)
        -:11062:        return;
        -:11063:    if (window->SkipItems)
        -:11064:        return;
        -:11065:    IM_ASSERT(0 && "Code uses SetCursorPos()/SetCursorScreenPos() to extend window/parent boundaries. Please submit an item e.g. Dummy() to validate extent.");
        -:11066:#else
    #####:11067:    window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, window->DC.CursorPos);
    %%%%%:11067-block 4
call    0 never executed
        -:11068:#endif
    #####:11069:}
        -:11070:
function _ZN5ImGuiL30ErrorCheckNewFrameSanityChecksEv called 1077 returned 100% blocks executed 36%
     1077:11071:static void ImGui::ErrorCheckNewFrameSanityChecks()
        -:11072:{
     1077:11073:    ImGuiContext& g = *GImGui;
     1077:11073-block 2
        -:11074:
        -:11075:    // Check user IM_ASSERT macro
        -:11076:    // (IF YOU GET A WARNING OR COMPILE ERROR HERE: it means your assert macro is incorrectly defined!
        -:11077:    //  If your macro uses multiple statements, it NEEDS to be surrounded by a 'do { ... } while (0)' block.
        -:11078:    //  This is a common C/C++ idiom to allow multiple statements macros to be used in control flow blocks.)
        -:11079:    // #define IM_ASSERT(EXPR)   if (SomeCode(EXPR)) SomeMoreCode();                    // Wrong!
        -:11080:    // #define IM_ASSERT(EXPR)   do { if (SomeCode(EXPR)) SomeMoreCode(); } while (0)   // Correct!
        -:11081:    if (true) IM_ASSERT(1); else IM_ASSERT(0);
        -:11082:
        -:11083:    // Emscripten backends are often imprecise in their submission of DeltaTime. (#6114, #3644)
        -:11084:    // Ideally the Emscripten app/backend should aim to fix or smooth this value and avoid feeding zero, but we tolerate it.
        -:11085:#ifdef __EMSCRIPTEN__
        -:11086:    if (g.IO.DeltaTime <= 0.0f && g.FrameCount > 0)
        -:11087:        g.IO.DeltaTime = 0.00001f;
        -:11088:#endif
        -:11089:
        -:11090:    // Check user data
        -:11091:    // (We pass an error message in the assert expression to make it visible to programmers who are not using a debugger, as most assert handlers display their argument)
    1077*:11092:    IM_ASSERT(g.Initialized);
     1077:11092-block 3
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:11092-block 4
call    2 never executed
    1077*:11093:    IM_ASSERT((g.IO.DeltaTime > 0.0f || g.FrameCount == 0)              && "Need a positive DeltaTime!");
     1077:11093-block 5
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:11093-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:11093-block 7
call    4 never executed
    1077*:11094:    IM_ASSERT((g.FrameCount == 0 || g.FrameCountEnded == g.FrameCount)  && "Forgot to call Render() or EndFrame() at the end of the previous frame?");
     1077:11094-block 8
branch  0 taken 1076 (fallthrough)
branch  1 taken 1
     1076:11094-block 9
branch  2 taken 0 (fallthrough)
branch  3 taken 1076
    %%%%%:11094-block 10
call    4 never executed
    1077*:11095:    IM_ASSERT(g.IO.DisplaySize.x >= 0.0f && g.IO.DisplaySize.y >= 0.0f  && "Invalid DisplaySize value!");
     1077:11095-block 11
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:11095-block 12
branch  2 taken 1077 (fallthrough)
branch  3 taken 0
     1077:11095-block 13
    %%%%%:11095-block 14
call    4 never executed
    1077*:11096:    IM_ASSERT(g.IO.Fonts->IsBuilt()                                     && "Font Atlas not built! Make sure you called ImGui_ImplXXXX_NewFrame() function for renderer backend, which should call io.Fonts->GetTexDataAsRGBA32() / GetTexDataAsAlpha8()");
     1077:11096-block 15
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0
     1077:11096-block 17
    %%%%%:11096-block 18
call    3 never executed
    1077*:11097:    IM_ASSERT(g.Style.CurveTessellationTol > 0.0f                       && "Invalid style setting!");
     1077:11097-block 19
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:11097-block 20
call    2 never executed
    1077*:11098:    IM_ASSERT(g.Style.CircleTessellationMaxError > 0.0f                 && "Invalid style setting!");
     1077:11098-block 21
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:11098-block 22
call    2 never executed
    1077*:11099:    IM_ASSERT(g.Style.Alpha >= 0.0f && g.Style.Alpha <= 1.0f            && "Invalid style setting!"); // Allows us to avoid a few clamps in color computations
     1077:11099-block 23
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:11099-block 24
branch  2 taken 1077 (fallthrough)
branch  3 taken 0
     1077:11099-block 25
    %%%%%:11099-block 26
call    4 never executed
    1077*:11100:    IM_ASSERT(g.Style.WindowMinSize.x >= 1.0f && g.Style.WindowMinSize.y >= 1.0f && "Invalid style setting.");
     1077:11100-block 27
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:11100-block 28
branch  2 taken 1077 (fallthrough)
branch  3 taken 0
     1077:11100-block 29
    %%%%%:11100-block 30
call    4 never executed
    1077*:11101:    IM_ASSERT(g.Style.WindowMenuButtonPosition == ImGuiDir_None || g.Style.WindowMenuButtonPosition == ImGuiDir_Left || g.Style.WindowMenuButtonPosition == ImGuiDir_Right);
     1077:11101-block 31
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:11101-block 32
branch  2 taken 1077 (fallthrough)
branch  3 taken 0
     1077:11101-block 33
branch  4 taken 0 (fallthrough)
branch  5 taken 1077
    %%%%%:11101-block 34
call    6 never executed
    1077*:11102:    IM_ASSERT(g.Style.ColorButtonPosition == ImGuiDir_Left || g.Style.ColorButtonPosition == ImGuiDir_Right);
     1077:11102-block 35
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:11102-block 36
branch  2 taken 0 (fallthrough)
branch  3 taken 1077
    %%%%%:11102-block 37
call    4 never executed
        -:11103:#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
   166935:11104:    for (int n = ImGuiKey_NamedKey_BEGIN; n < ImGuiKey_COUNT; n++)
     1077:11104-block 38
   165858:11104-block 43
   166935:11104-block 44
branch  0 taken 165858
branch  1 taken 1077 (fallthrough)
  165858*:11105:        IM_ASSERT(g.IO.KeyMap[n] >= -1 && g.IO.KeyMap[n] < ImGuiKey_LegacyNativeKey_END && "io.KeyMap[] contains an out of bound value (need to be 0..511, or -1 for unmapped key)");
   165858:11105-block 39
branch  0 taken 165858 (fallthrough)
branch  1 taken 0
   165858:11105-block 40
branch  2 taken 165858 (fallthrough)
branch  3 taken 0
   165858:11105-block 41
    %%%%%:11105-block 42
call    4 never executed
        -:11106:
        -:11107:    // Check: required key mapping (we intentionally do NOT check all keys to not pressure user into setting up everything, but Space is required and was only added in 1.60 WIP)
     1077:11108:    if ((g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) && g.IO.BackendUsingLegacyKeyArrays == 1)
     1077:11108-block 45
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:11108-block 46
branch  2 taken 0 (fallthrough)
branch  3 taken 1077
    #####:11109:        IM_ASSERT(g.IO.KeyMap[ImGuiKey_Space] != -1 && "ImGuiKey_Space is not mapped, required for keyboard navigation.");
    %%%%%:11109-block 47
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:11109-block 48
call    2 never executed
        -:11110:#endif
        -:11111:
        -:11112:    // Error handling: we do not accept 100% silent recovery! Please contact me if you feel this is getting in your way.
     1077:11113:    if (g.IO.ConfigErrorRecovery)
     1077:11113-block 49
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
    1077*:11114:        IM_ASSERT(g.IO.ConfigErrorRecoveryEnableAssert || g.IO.ConfigErrorRecoveryEnableDebugLog || g.IO.ConfigErrorRecoveryEnableTooltip || g.ErrorCallback != NULL);
     1077:11114-block 50
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:11114-block 51
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:11114-block 52
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:11114-block 53
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%:11114-block 54
call    8 never executed
        -:11115:
        -:11116:#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
        -:11117:    // Remap legacy names
     1077:11118:    if (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos)
     1077:11118-block 55
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
        -:11119:    {
    #####:11120:        g.IO.ConfigNavMoveSetMousePos = true;
    #####:11121:        g.IO.ConfigFlags &= ~ImGuiConfigFlags_NavEnableSetMousePos;
    %%%%%:11121-block 56
        -:11122:    }
     1077:11123:    if (g.IO.ConfigFlags & ImGuiConfigFlags_NavNoCaptureKeyboard)
     1077:11123-block 57
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
        -:11124:    {
    #####:11125:        g.IO.ConfigNavCaptureKeyboard = false;
    #####:11126:        g.IO.ConfigFlags &= ~ImGuiConfigFlags_NavNoCaptureKeyboard;
    %%%%%:11126-block 58
        -:11127:    }
        -:11128:
        -:11129:    // Remap legacy clipboard handlers (OBSOLETED in 1.91.1, August 2024)
    1077*:11130:    if (g.IO.GetClipboardTextFn != NULL && (g.PlatformIO.Platform_GetClipboardTextFn == NULL || g.PlatformIO.Platform_GetClipboardTextFn == Platform_GetClipboardTextFn_DefaultImpl))
     1077:11130-block 59
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:11130-block 60
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:11130-block 61
branch  4 never executed (fallthrough)
branch  5 never executed
function _ZZN5ImGuiL30ErrorCheckNewFrameSanityChecksEvENKUlP12ImGuiContextE_clES1_ called 0 returned 0% blocks executed 0%
    #####:11131:        g.PlatformIO.Platform_GetClipboardTextFn = [](ImGuiContext* ctx) { return ctx->IO.GetClipboardTextFn(ctx->IO.ClipboardUserData); };
    %%%%%:11131-block 62
call    0 never executed
    %%%%%:11131-block 2
call    1 never executed
    1077*:11132:    if (g.IO.SetClipboardTextFn != NULL && (g.PlatformIO.Platform_SetClipboardTextFn == NULL || g.PlatformIO.Platform_SetClipboardTextFn == Platform_SetClipboardTextFn_DefaultImpl))
     1077:11132-block 64
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:11132-block 65
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:11132-block 66
branch  4 never executed (fallthrough)
branch  5 never executed
function _ZZN5ImGuiL30ErrorCheckNewFrameSanityChecksEvENKUlP12ImGuiContextPKcE_clES1_S3_ called 0 returned 0% blocks executed 0%
    #####:11133:        g.PlatformIO.Platform_SetClipboardTextFn = [](ImGuiContext* ctx, const char* text) { return ctx->IO.SetClipboardTextFn(ctx->IO.ClipboardUserData, text); };
    %%%%%:11133-block 67
call    0 never executed
    %%%%%:11133-block 2
call    1 never executed
        -:11134:#endif
        -:11135:
        -:11136:    // Perform simple check: error if Docking or Viewport are enabled _exactly_ on frame 1 (instead of frame 0 or later), which is a common error leading to loss of .ini data.
     1077:11137:    if (g.FrameCount == 1 && (g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable) && (g.ConfigFlagsLastFrame & ImGuiConfigFlags_DockingEnable) == 0)
     1077:11137-block 69
branch  0 taken 1 (fallthrough)
branch  1 taken 1076
        1:11137-block 70
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1:11137-block 71
branch  4 taken 0 (fallthrough)
branch  5 taken 1
    #####:11138:        IM_ASSERT(0 && "Please set DockingEnable before the first call to NewFrame()! Otherwise you will lose your .ini settings!");
    %%%%%:11138-block 72
call    0 never executed
    1077*:11139:    if (g.FrameCount == 1 && (g.IO.ConfigFlags & ImGuiConfigFlags_ViewportsEnable) && (g.ConfigFlagsLastFrame & ImGuiConfigFlags_ViewportsEnable) == 0)
     1077:11139-block 73
branch  0 taken 1 (fallthrough)
branch  1 taken 1076
        1:11139-block 74
branch  2 taken 0 (fallthrough)
branch  3 taken 1
    %%%%%:11139-block 75
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:11140:        IM_ASSERT(0 && "Please set ViewportsEnable before the first call to NewFrame()! Otherwise you will lose your .ini settings!");
    %%%%%:11140-block 76
call    0 never executed
        -:11141:
        -:11142:    // Perform simple checks: multi-viewport and platform windows support
     1077:11143:    if (g.IO.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
     1077:11143-block 77
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
        -:11144:    {
    #####:11145:        if ((g.IO.BackendFlags & ImGuiBackendFlags_PlatformHasViewports) && (g.IO.BackendFlags & ImGuiBackendFlags_RendererHasViewports))
    %%%%%:11145-block 78
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:11145-block 79
branch  2 never executed (fallthrough)
branch  3 never executed
        -:11146:        {
    #####:11147:            IM_ASSERT((g.FrameCount == 0 || g.FrameCount == g.FrameCountPlatformEnded) && "Forgot to call UpdatePlatformWindows() in main loop after EndFrame()? Check examples/ applications for reference.");
    %%%%%:11147-block 80
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:11147-block 81
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:11147-block 82
call    4 never executed
    #####:11148:            IM_ASSERT(g.PlatformIO.Platform_CreateWindow  != NULL && "Platform init didn't install handlers?");
    %%%%%:11148-block 83
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:11148-block 84
call    2 never executed
    #####:11149:            IM_ASSERT(g.PlatformIO.Platform_DestroyWindow != NULL && "Platform init didn't install handlers?");
    %%%%%:11149-block 85
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:11149-block 86
call    2 never executed
    #####:11150:            IM_ASSERT(g.PlatformIO.Platform_GetWindowPos  != NULL && "Platform init didn't install handlers?");
    %%%%%:11150-block 87
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:11150-block 88
call    2 never executed
    #####:11151:            IM_ASSERT(g.PlatformIO.Platform_SetWindowPos  != NULL && "Platform init didn't install handlers?");
    %%%%%:11151-block 89
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:11151-block 90
call    2 never executed
    #####:11152:            IM_ASSERT(g.PlatformIO.Platform_GetWindowSize != NULL && "Platform init didn't install handlers?");
    %%%%%:11152-block 91
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:11152-block 92
call    2 never executed
    #####:11153:            IM_ASSERT(g.PlatformIO.Platform_SetWindowSize != NULL && "Platform init didn't install handlers?");
    %%%%%:11153-block 93
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:11153-block 94
call    2 never executed
    #####:11154:            IM_ASSERT(g.PlatformIO.Monitors.Size > 0 && "Platform init didn't setup Monitors list?");
    %%%%%:11154-block 95
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:11154-block 96
call    2 never executed
    #####:11155:            IM_ASSERT((g.Viewports[0]->PlatformUserData != NULL || g.Viewports[0]->PlatformHandle != NULL) && "Platform init didn't setup main viewport.");
    %%%%%:11155-block 97
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:11155-block 99
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:11155-block 101
    %%%%%:11155-block 102
call    6 never executed
    #####:11156:            if (g.IO.ConfigDockingTransparentPayload && (g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable))
    %%%%%:11156-block 103
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:11156-block 104
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:11157:                IM_ASSERT(g.PlatformIO.Platform_SetWindowAlpha != NULL && "Platform_SetWindowAlpha handler is required to use io.ConfigDockingTransparent!");
    %%%%%:11157-block 105
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:11157-block 106
call    2 never executed
        -:11158:        }
        -:11159:        else
        -:11160:        {
        -:11161:            // Disable feature, our backends do not support it
    #####:11162:            g.IO.ConfigFlags &= ~ImGuiConfigFlags_ViewportsEnable;
    %%%%%:11162-block 108
        -:11163:        }
        -:11164:
        -:11165:        // Perform simple checks on platform monitor data + compute a total bounding box for quick early outs
    #####:11166:        for (ImGuiPlatformMonitor& mon : g.PlatformIO.Monitors)
    %%%%%:11166-block 109
call    0 never executed
call    1 never executed
    %%%%%:11166-block 125
    %%%%%:11166-block 126
branch  2 never executed
branch  3 never executed (fallthrough)
        -:11167:        {
        -:11168:            IM_UNUSED(mon);
    #####:11169:            IM_ASSERT(mon.MainSize.x > 0.0f && mon.MainSize.y > 0.0f && "Monitor main bounds not setup properly.");
    %%%%%:11169-block 111
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:11169-block 112
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:11169-block 113
    %%%%%:11169-block 114
call    4 never executed
    #####:11170:            IM_ASSERT(ImRect(mon.MainPos, mon.MainPos + mon.MainSize).Contains(ImRect(mon.WorkPos, mon.WorkPos + mon.WorkSize)) && "Monitor work bounds not setup properly. If you don't have work area information, just copy MainPos/MainSize into them.");
    %%%%%:11170-block 115
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:11170-block 121
    %%%%%:11170-block 122
call    7 never executed
    #####:11171:            IM_ASSERT(mon.DpiScale != 0.0f);
    %%%%%:11171-block 123
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:11171-block 124
call    2 never executed
        -:11172:        }
        -:11173:    }
     1077:11174:}
        -:11175:
function _ZN5ImGuiL30ErrorCheckEndFrameSanityChecksEv called 1077 returned 100% blocks executed 70%
     1077:11176:static void ImGui::ErrorCheckEndFrameSanityChecks()
        -:11177:{
        -:11178:    // Verify that io.KeyXXX fields haven't been tampered with. Key mods should not be modified between NewFrame() and EndFrame()
        -:11179:    // One possible reason leading to this assert is that your backends update inputs _AFTER_ NewFrame().
        -:11180:    // It is known that when some modal native windows called mid-frame takes focus away, some backends such as GLFW will
        -:11181:    // send key release events mid-frame. This would normally trigger this assertion and lead to sheared inputs.
        -:11182:    // We silently accommodate for this case by ignoring the case where all io.KeyXXX modifiers were released (aka key_mod_flags == 0),
        -:11183:    // while still correctly asserting on mid-frame key press events.
     1077:11184:    ImGuiContext& g = *GImGui;
     1077:11185:    const ImGuiKeyChord key_mods = GetMergedModsFromKeys();
     1077:11185-block 2
call    0 returned 1077
        -:11186:    IM_UNUSED(g);
        -:11187:    IM_UNUSED(key_mods);
    1077*:11188:    IM_ASSERT((key_mods == 0 || g.IO.KeyMods == key_mods) && "Mismatching io.KeyCtrl/io.KeyShift/io.KeyAlt/io.KeySuper vs io.KeyMods");
branch  0 taken 20 (fallthrough)
branch  1 taken 1057
       20:11188-block 4
branch  2 taken 0 (fallthrough)
branch  3 taken 20
    %%%%%:11188-block 5
call    4 never executed
        -:11189:    IM_UNUSED(key_mods);
        -:11190:
    1077*:11191:    IM_ASSERT(g.CurrentWindowStack.Size == 1);
     1077:11191-block 6
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:11191-block 7
call    2 never executed
    1077*:11192:    IM_ASSERT(g.CurrentWindowStack[0].Window->IsFallbackWindow);
     1077:11192-block 8
call    0 returned 1077
branch  1 taken 0 (fallthrough)
branch  2 taken 1077
    %%%%%:11192-block 10
call    3 never executed
     1077:11193:}
        -:11194:
        -:11195:// Save current stack sizes. Called e.g. by NewFrame() and by Begin() but may be called for manual recovery.
function _ZN5ImGui23ErrorRecoveryStoreStateEP23ImGuiErrorRecoveryState called 18522 returned 100% blocks executed 100%
    18522:11196:void ImGui::ErrorRecoveryStoreState(ImGuiErrorRecoveryState* state_out)
        -:11197:{
    18522:11198:    ImGuiContext& g = *GImGui;
    18522:11199:    state_out->SizeOfWindowStack = (short)g.CurrentWindowStack.Size;
    18522:11200:    state_out->SizeOfIDStack = (short)g.CurrentWindow->IDStack.Size;
    18522:11201:    state_out->SizeOfTreeStack = (short)g.CurrentWindow->DC.TreeDepth; // NOT g.TreeNodeStack.Size which is a partial stack!
    18522:11202:    state_out->SizeOfColorStack = (short)g.ColorStack.Size;
    18522:11203:    state_out->SizeOfStyleVarStack = (short)g.StyleVarStack.Size;
    18522:11204:    state_out->SizeOfFontStack = (short)g.FontStack.Size;
    18522:11205:    state_out->SizeOfFocusScopeStack = (short)g.FocusScopeStack.Size;
    18522:11206:    state_out->SizeOfGroupStack = (short)g.GroupStack.Size;
    18522:11207:    state_out->SizeOfItemFlagsStack = (short)g.ItemFlagsStack.Size;
    18522:11208:    state_out->SizeOfBeginPopupStack = (short)g.BeginPopupStack.Size;
    18522:11209:    state_out->SizeOfDisabledStack = (short)g.DisabledStackSize;
    18522:11210:}
        -:11211:
        -:11212:// Chosen name "Try to recover" over e.g. "Restore" to suggest this is not a 100% guaranteed recovery.
        -:11213:// Called by e.g. EndFrame() but may be called for manual recovery.
        -:11214:// Attempt to recover full window stack.
function _ZN5ImGui30ErrorRecoveryTryToRecoverStateEPK23ImGuiErrorRecoveryState called 1077 returned 100% blocks executed 36%
     1077:11215:void ImGui::ErrorRecoveryTryToRecoverState(const ImGuiErrorRecoveryState* state_in)
        -:11216:{
        -:11217:    // PVS-Studio V1044 is "Loop break conditions do not depend on the number of iterations"
     1077:11218:    ImGuiContext& g = *GImGui;
     1077:11219:    while (g.CurrentWindowStack.Size > state_in->SizeOfWindowStack) //-V1044
     1077:11219-block 2
     1077:11219-block 12
branch  0 taken 0
branch  1 taken 1077 (fallthrough)
        -:11220:    {
        -:11221:        // Recap:
        -:11222:        // - Begin()/BeginChild() return false to indicate the window is collapsed or fully clipped.
        -:11223:        // - Always call a matching End() for each Begin() call, regardless of its return value!
        -:11224:        // - Begin/End and BeginChild/EndChild logic is KNOWN TO BE INCONSISTENT WITH ALL OTHER BEGIN/END FUNCTIONS.
        -:11225:        // - We will fix that in a future major update.
    #####:11226:        ImGuiWindow* window = g.CurrentWindow;
    #####:11227:        if (window->Flags & ImGuiWindowFlags_ChildWindow)
    %%%%%:11227-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
        -:11228:        {
    #####:11229:            IM_ASSERT_USER_ERROR(0, "Missing EndChild()");
    %%%%%:11229-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:11229-block 6
call    3 never executed
    #####:11230:            EndChild();
    %%%%%:11230-block 7
call    0 never executed
        -:11231:        }
        -:11232:        else
        -:11233:        {
    #####:11234:            IM_ASSERT_USER_ERROR(0, "Missing End()");
    %%%%%:11234-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:11234-block 10
call    3 never executed
    #####:11235:            End();
    %%%%%:11235-block 11
call    0 never executed
        -:11236:        }
        -:11237:    }
     1077:11238:    if (g.CurrentWindowStack.Size == state_in->SizeOfWindowStack)
     1077:11238-block 13
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:11239:        ErrorRecoveryTryToRecoverWindowState(state_in);
     1077:11239-block 14
call    0 returned 1077
     1077:11240:}
        -:11241:
        -:11242:// Called by e.g. End() but may be called for manual recovery.
        -:11243:// Read '// Error Handling [BETA]' block in imgui_internal.h for details.
        -:11244:// Attempt to recover from incorrect usage of BeginXXX/EndXXX/PushXXX/PopXXX calls.
function _ZN5ImGui36ErrorRecoveryTryToRecoverWindowStateEPK23ImGuiErrorRecoveryState called 18522 returned 100% blocks executed 32%
    18522:11245:void    ImGui::ErrorRecoveryTryToRecoverWindowState(const ImGuiErrorRecoveryState* state_in)
        -:11246:{
    18522:11247:    ImGuiContext& g = *GImGui;
        -:11248:
   18522*:11249:    while (g.CurrentTable != NULL && g.CurrentTable->InnerWindow == g.CurrentWindow) //-V1044
    18522:11249-block 2
    18522:11249-block 7
branch  0 taken 0 (fallthrough)
branch  1 taken 18522
    %%%%%:11249-block 8
branch  2 never executed
branch  3 never executed (fallthrough)
        -:11250:    {
    #####:11251:        IM_ASSERT_USER_ERROR(0, "Missing EndTable()");
    %%%%%:11251-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:11251-block 5
call    3 never executed
    #####:11252:        EndTable();
    %%%%%:11252-block 6
call    0 never executed
        -:11253:    }
        -:11254:
    18522:11255:    ImGuiWindow* window = g.CurrentWindow;
        -:11256:
        -:11257:    // FIXME: Can't recover from inside BeginTabItem/EndTabItem yet.
   18522*:11258:    while (g.CurrentTabBar != NULL && g.CurrentTabBar->Window == window) //-V1044
    18522:11258-block 9
    18522:11258-block 14
branch  0 taken 0 (fallthrough)
branch  1 taken 18522
    %%%%%:11258-block 15
branch  2 never executed
branch  3 never executed (fallthrough)
        -:11259:    {
    #####:11260:        IM_ASSERT_USER_ERROR(0, "Missing EndTabBar()");
    %%%%%:11260-block 10
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:11260-block 12
call    3 never executed
    #####:11261:        EndTabBar();
    %%%%%:11261-block 13
call    0 never executed
        -:11262:    }
   18522*:11263:    while (g.CurrentMultiSelect != NULL && g.CurrentMultiSelect->Storage->Window == window) //-V1044
    18522:11263-block 16
    18522:11263-block 21
branch  0 taken 0 (fallthrough)
branch  1 taken 18522
    %%%%%:11263-block 22
branch  2 never executed
branch  3 never executed (fallthrough)
        -:11264:    {
    #####:11265:        IM_ASSERT_USER_ERROR(0, "Missing EndMultiSelect()");
    %%%%%:11265-block 17
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:11265-block 19
call    3 never executed
    #####:11266:        EndMultiSelect();
    %%%%%:11266-block 20
call    0 never executed
        -:11267:    }
    18522:11268:    while (window->DC.TreeDepth > state_in->SizeOfTreeStack) //-V1044
    18522:11268-block 23
    18522:11268-block 28
branch  0 taken 0
branch  1 taken 18522 (fallthrough)
        -:11269:    {
    #####:11270:        IM_ASSERT_USER_ERROR(0, "Missing TreePop()");
    %%%%%:11270-block 24
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:11270-block 26
call    3 never executed
    #####:11271:        TreePop();
    %%%%%:11271-block 27
call    0 never executed
        -:11272:    }
    18522:11273:    while (g.GroupStack.Size > state_in->SizeOfGroupStack) //-V1044
    18522:11273-block 29
    18522:11273-block 34
branch  0 taken 0
branch  1 taken 18522 (fallthrough)
        -:11274:    {
    #####:11275:        IM_ASSERT_USER_ERROR(0, "Missing EndGroup()");
    %%%%%:11275-block 30
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:11275-block 32
call    3 never executed
    #####:11276:        EndGroup();
    %%%%%:11276-block 33
call    0 never executed
        -:11277:    }
   18522*:11278:    IM_ASSERT(g.GroupStack.Size == state_in->SizeOfGroupStack);
    18522:11278-block 35
branch  0 taken 0 (fallthrough)
branch  1 taken 18522
    %%%%%:11278-block 36
call    2 never executed
    18522:11279:    while (window->IDStack.Size > state_in->SizeOfIDStack) //-V1044
    18522:11279-block 37
    18522:11279-block 42
branch  0 taken 0
branch  1 taken 18522 (fallthrough)
        -:11280:    {
    #####:11281:        IM_ASSERT_USER_ERROR(0, "Missing PopID()");
    %%%%%:11281-block 38
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:11281-block 40
call    3 never executed
    #####:11282:        PopID();
    %%%%%:11282-block 41
call    0 never executed
        -:11283:    }
    18522:11284:    while (g.DisabledStackSize > state_in->SizeOfDisabledStack) //-V1044
    18522:11284-block 43
    18522:11284-block 52
branch  0 taken 0
branch  1 taken 18522 (fallthrough)
        -:11285:    {
    #####:11286:        IM_ASSERT_USER_ERROR(0, "Missing EndDisabled()");
    %%%%%:11286-block 44
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:11286-block 46
call    3 never executed
    #####:11287:        if (g.CurrentItemFlags & ImGuiItemFlags_Disabled)
    %%%%%:11287-block 47
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:11288:            EndDisabled();
    %%%%%:11288-block 48
call    0 never executed
        -:11289:        else
        -:11290:        {
    #####:11291:            EndDisabledOverrideReenable();
    %%%%%:11291-block 49
call    0 never executed
    #####:11292:            g.CurrentWindowStack.back().DisabledOverrideReenable = false;
call    0 never executed
        -:11293:        }
        -:11294:    }
   18522*:11295:    IM_ASSERT(g.DisabledStackSize == state_in->SizeOfDisabledStack);
    18522:11295-block 53
branch  0 taken 0 (fallthrough)
branch  1 taken 18522
    %%%%%:11295-block 54
call    2 never executed
    18522:11296:    while (g.ColorStack.Size > state_in->SizeOfColorStack) //-V1044
    18522:11296-block 55
    18522:11296-block 60
branch  0 taken 0
branch  1 taken 18522 (fallthrough)
        -:11297:    {
    #####:11298:        IM_ASSERT_USER_ERROR(0, "Missing PopStyleColor()");
    %%%%%:11298-block 56
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:11298-block 58
call    3 never executed
    #####:11299:        PopStyleColor();
    %%%%%:11299-block 59
call    0 never executed
        -:11300:    }
    18522:11301:    while (g.ItemFlagsStack.Size > state_in->SizeOfItemFlagsStack) //-V1044
    18522:11301-block 61
    18522:11301-block 66
branch  0 taken 0
branch  1 taken 18522 (fallthrough)
        -:11302:    {
    #####:11303:        IM_ASSERT_USER_ERROR(0, "Missing PopItemFlag()");
    %%%%%:11303-block 62
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:11303-block 64
call    3 never executed
    #####:11304:        PopItemFlag();
    %%%%%:11304-block 65
call    0 never executed
        -:11305:    }
    18522:11306:    while (g.StyleVarStack.Size > state_in->SizeOfStyleVarStack) //-V1044
    18522:11306-block 67
    18522:11306-block 72
branch  0 taken 0
branch  1 taken 18522 (fallthrough)
        -:11307:    {
    #####:11308:        IM_ASSERT_USER_ERROR(0, "Missing PopStyleVar()");
    %%%%%:11308-block 68
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:11308-block 70
call    3 never executed
    #####:11309:        PopStyleVar();
    %%%%%:11309-block 71
call    0 never executed
        -:11310:    }
    18522:11311:    while (g.FontStack.Size > state_in->SizeOfFontStack) //-V1044
    18522:11311-block 73
    18522:11311-block 78
branch  0 taken 0
branch  1 taken 18522 (fallthrough)
        -:11312:    {
    #####:11313:        IM_ASSERT_USER_ERROR(0, "Missing PopFont()");
    %%%%%:11313-block 74
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:11313-block 76
call    3 never executed
    #####:11314:        PopFont();
    %%%%%:11314-block 77
call    0 never executed
        -:11315:    }
    18522:11316:    while (g.FocusScopeStack.Size > state_in->SizeOfFocusScopeStack) //-V1044
    18522:11316-block 79
    18522:11316-block 84
branch  0 taken 0
branch  1 taken 18522 (fallthrough)
        -:11317:    {
    #####:11318:        IM_ASSERT_USER_ERROR(0, "Missing PopFocusScope()");
    %%%%%:11318-block 80
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:11318-block 82
call    3 never executed
    #####:11319:        PopFocusScope();
    %%%%%:11319-block 83
call    0 never executed
        -:11320:    }
        -:11321:    //IM_ASSERT(g.FocusScopeStack.Size == state_in->SizeOfFocusScopeStack);
    18522:11322:}
        -:11323:
function _ZN5ImGui8ErrorLogEPKc called 0 returned 0% blocks executed 0%
    #####:11324:bool    ImGui::ErrorLog(const char* msg)
        -:11325:{
    #####:11326:    ImGuiContext& g = *GImGui;
        -:11327:
        -:11328:    // Output to debug log
        -:11329:#ifndef IMGUI_DISABLE_DEBUG_TOOLS
    #####:11330:    ImGuiWindow* window = g.CurrentWindow;
        -:11331:
    #####:11332:    if (g.IO.ConfigErrorRecoveryEnableDebugLog)
    %%%%%:11332-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -:11333:    {
    #####:11334:        if (g.ErrorFirst)
    %%%%%:11334-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:11335:            IMGUI_DEBUG_LOG_ERROR("[imgui-error] (current settings: Assert=%d, Log=%d, Tooltip=%d)\n",
    %%%%%:11335-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:11335-block 5
call    2 never executed
    %%%%%:11335-block 6
        -:11336:                g.IO.ConfigErrorRecoveryEnableAssert, g.IO.ConfigErrorRecoveryEnableDebugLog, g.IO.ConfigErrorRecoveryEnableTooltip);
    #####:11337:        IMGUI_DEBUG_LOG_ERROR("[imgui-error] In window '%s': %s\n", window ? window->Name : "NULL", msg);
    %%%%%:11337-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:11337-block 8
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:11337-block 9
    %%%%%:11337-block 10
    %%%%%:11337-block 11
call    4 never executed
    %%%%%:11337-block 12
        -:11338:    }
    #####:11339:    g.ErrorFirst = false;
        -:11340:
        -:11341:    // Output to tooltip
    #####:11342:    if (g.IO.ConfigErrorRecoveryEnableTooltip)
    %%%%%:11342-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
        -:11343:    {
    #####:11344:        if (BeginErrorTooltip())
    %%%%%:11344-block 14
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -:11345:        {
    #####:11346:            if (g.ErrorCountCurrentFrame < 20)
    %%%%%:11346-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
        -:11347:            {
    #####:11348:                Text("In window '%s': %s", window ? window->Name : "NULL", msg);
    %%%%%:11348-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:11348-block 18
    %%%%%:11348-block 19
    %%%%%:11348-block 20
call    2 never executed
    #####:11349:                if (window && (!window->IsFallbackWindow || window->WasActive))
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:11349-block 22
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:11349-block 23
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:11350:                    GetForegroundDrawList(window)->AddRect(window->Pos, window->Pos + window->Size, IM_COL32(255, 0, 0, 255));
    %%%%%:11350-block 24
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%:11350-block 27
        -:11351:            }
    #####:11352:            if (g.ErrorCountCurrentFrame == 20)
    %%%%%:11352-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:11353:                Text("(and more errors)");
    %%%%%:11353-block 29
call    0 never executed
        -:11354:            // EndFrame() will amend debug buttons to this window, after all errors have been submitted.
    #####:11355:            EndErrorTooltip();
    %%%%%:11355-block 30
call    0 never executed
        -:11356:        }
    #####:11357:        g.ErrorCountCurrentFrame++;
    %%%%%:11357-block 31
        -:11358:    }
        -:11359:#endif
        -:11360:
        -:11361:    // Output to callback
    #####:11362:    if (g.ErrorCallback != NULL)
    %%%%%:11362-block 32
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:11363:        g.ErrorCallback(&g, g.ErrorCallbackUserData, msg);
    %%%%%:11363-block 33
call    0 never executed
        -:11364:
        -:11365:    // Return whether we should assert
    #####:11366:    return g.IO.ConfigErrorRecoveryEnableAssert;
    %%%%%:11366-block 34
    %%%%%:11366-block 35
        -:11367:}
        -:11368:
function _ZN5ImGui38ErrorCheckEndFrameFinalizeErrorTooltipEv called 1077 returned 100% blocks executed 17%
     1077:11369:void ImGui::ErrorCheckEndFrameFinalizeErrorTooltip()
        -:11370:{
        -:11371:#ifndef IMGUI_DISABLE_DEBUG_TOOLS
     1077:11372:    ImGuiContext& g = *GImGui;
    1077*:11373:    if (g.DebugDrawIdConflicts != 0 && g.IO.KeyCtrl == false)
     1077:11373-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:11373-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:11374:        g.DebugDrawIdConflictsCount = g.HoveredIdPreviousFrameItemCount;
    %%%%%:11374-block 4
    1077*:11375:    if (g.DebugDrawIdConflicts != 0 && g.DebugItemPickerActive == false && BeginErrorTooltip())
     1077:11375-block 5
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:11375-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:11375-block 7
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:11375-block 9
     1077:11375-block 10
     1077:11375-block 11
branch  7 taken 0 (fallthrough)
branch  8 taken 1077
        -:11376:    {
    #####:11377:        Text("Programmer error: %d visible items with conflicting ID!", g.DebugDrawIdConflictsCount);
    %%%%%:11377-block 12
call    0 never executed
    #####:11378:        BulletText("Code should use PushID()/PopID() in loops, or append \"##xx\" to same-label identifiers!");
call    0 never executed
    #####:11379:        BulletText("Empty label e.g. Button(\"\") == same ID as parent widget/node. Use Button(\"##xx\") instead!");
call    0 never executed
        -:11380:        //BulletText("Code intending to use duplicate ID may use e.g. PushItemFlag(ImGuiItemFlags_AllowDuplicateId, true); ... PopItemFlag()"); // Not making this too visible for fear of it being abused.
    #####:11381:        BulletText("Set io.ConfigDebugDetectIdConflicts=false to disable this warning in non-programmers builds.");
call    0 never executed
    #####:11382:        Separator();
call    0 never executed
    #####:11383:        Text("(Hold CTRL to: use");
call    0 never executed
    #####:11384:        SameLine();
call    0 never executed
    #####:11385:        if (SmallButton("Item Picker"))
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:11386:            DebugStartItemPicker();
    %%%%%:11386-block 21
call    0 never executed
    #####:11387:        SameLine();
    %%%%%:11387-block 22
call    0 never executed
    #####:11388:        Text("to break in item call-stack, or");
call    0 never executed
    #####:11389:        SameLine();
call    0 never executed
    #####:11390:        if (SmallButton("Open FAQ->About ID Stack System") && g.PlatformIO.Platform_OpenInShellFn != NULL)
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:11390-block 27
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:11390-block 28
    %%%%%:11390-block 29
    %%%%%:11390-block 30
branch  5 never executed (fallthrough)
branch  6 never executed
    #####:11391:            g.PlatformIO.Platform_OpenInShellFn(&g, "https://github.com/ocornut/imgui/blob/master/docs/FAQ.md#qa-usage");
    %%%%%:11391-block 31
call    0 never executed
    #####:11392:        EndErrorTooltip();
    %%%%%:11392-block 32
call    0 never executed
        -:11393:    }
        -:11394:
    1077*:11395:    if (g.ErrorCountCurrentFrame > 0 && BeginErrorTooltip()) // Amend at end of frame
     1077:11395-block 33
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:11395-block 34
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:11395-block 36
     1077:11395-block 37
     1077:11395-block 38
branch  5 taken 0 (fallthrough)
branch  6 taken 1077
        -:11396:    {
    #####:11397:        Separator();
    %%%%%:11397-block 39
call    0 never executed
    #####:11398:        Text("(Hold CTRL to:");
call    0 never executed
    #####:11399:        SameLine();
call    0 never executed
    #####:11400:        if (SmallButton("Enable Asserts"))
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:11401:            g.IO.ConfigErrorRecoveryEnableAssert = true;
    %%%%%:11401-block 44
        -:11402:        //SameLine();
        -:11403:        //if (SmallButton("Hide Error Tooltips"))
        -:11404:        //    g.IO.ConfigErrorRecoveryEnableTooltip = false; // Too dangerous
    #####:11405:        SameLine(0, 0);
    %%%%%:11405-block 45
call    0 never executed
    #####:11406:        Text(")");
call    0 never executed
    #####:11407:        EndErrorTooltip();
call    0 never executed
        -:11408:    }
        -:11409:#endif
     1077:11410:}
        -:11411:
        -:11412:// Pseudo-tooltip. Follow mouse until CTRL is held. When CTRL is held we lock position, allowing to click it.
function _ZN5ImGui17BeginErrorTooltipEv called 0 returned 0% blocks executed 0%
    #####:11413:bool ImGui::BeginErrorTooltip()
        -:11414:{
    #####:11415:    ImGuiContext& g = *GImGui;
    #####:11416:    ImGuiWindow* window = FindWindowByName("##Tooltip_Error");
    %%%%%:11416-block 2
call    0 never executed
    #####:11417:    const bool use_locked_pos = (g.IO.KeyCtrl && window && window->WasActive);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:11417-block 4
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:11417-block 5
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:11417-block 6
    %%%%%:11417-block 7
    #####:11418:    PushStyleColor(ImGuiCol_PopupBg, ImLerp(g.Style.Colors[ImGuiCol_PopupBg], ImVec4(1.0f, 0.0f, 0.0f, 1.0f), 0.15f));
    %%%%%:11418-block 8
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    $$$$$:11418-block 27
    #####:11419:    if (use_locked_pos)
    %%%%%:11419-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:11420:        SetNextWindowPos(g.ErrorTooltipLockedPos);
    %%%%%:11420-block 12
call    0 never executed
call    1 never executed
    #####:11421:    bool is_visible = Begin("##Tooltip_Error", NULL, ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_AlwaysAutoResize);
    %%%%%:11421-block 15
call    0 never executed
    #####:11422:    PopStyleColor();
call    0 never executed
    #####:11423:    if (is_visible && g.CurrentWindow->BeginCount == 1)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:11423-block 18
branch  2 never executed (fallthrough)
branch  3 never executed
        -:11424:    {
    #####:11425:        SeparatorText("MESSAGE FROM DEAR IMGUI");
    %%%%%:11425-block 19
call    0 never executed
    #####:11426:        BringWindowToDisplayFront(g.CurrentWindow);
call    0 never executed
    #####:11427:        BringWindowToFocusFront(g.CurrentWindow);
call    0 never executed
    #####:11428:        g.ErrorTooltipLockedPos = GetWindowPos();
call    0 never executed
        -:11429:    }
    #####:11430:    else if (!is_visible)
    %%%%%:11430-block 23
branch  0 never executed (fallthrough)
branch  1 never executed
        -:11431:    {
    #####:11432:        End();
    %%%%%:11432-block 24
call    0 never executed
        -:11433:    }
    #####:11434:    return is_visible;
    %%%%%:11434-block 25
    %%%%%:11434-block 26
        -:11435:}
        -:11436:
function _ZN5ImGui15EndErrorTooltipEv called 0 returned 0% blocks executed 0%
    #####:11437:void ImGui::EndErrorTooltip()
        -:11438:{
    #####:11439:    End();
    %%%%%:11439-block 2
call    0 never executed
    #####:11440:}
        -:11441:
        -:11442://-----------------------------------------------------------------------------
        -:11443:// [SECTION] ITEM SUBMISSION
        -:11444://-----------------------------------------------------------------------------
        -:11445:// - KeepAliveID()
        -:11446:// - ItemAdd()
        -:11447://-----------------------------------------------------------------------------
        -:11448:
        -:11449:// Code not using ItemAdd() may need to call this manually otherwise ActiveId will be cleared. In IMGUI_VERSION_NUM < 18717 this was called by GetID().
function _ZN5ImGui11KeepAliveIDEj called 142197 returned 100% blocks executed 100%
   142197:11450:void ImGui::KeepAliveID(ImGuiID id)
        -:11451:{
   142197:11452:    ImGuiContext& g = *GImGui;
   142197:11453:    if (g.ActiveId == id)
   142197:11453-block 2
branch  0 taken 154 (fallthrough)
branch  1 taken 142043
      154:11454:        g.ActiveIdIsAlive = id;
      154:11454-block 3
   142197:11455:    if (g.ActiveIdPreviousFrame == id)
   142197:11455-block 4
branch  0 taken 154 (fallthrough)
branch  1 taken 142043
      154:11456:        g.ActiveIdPreviousFrameIsAlive = true;
      154:11456-block 5
   142197:11457:}
        -:11458:
        -:11459:// Declare item bounding box for clipping and interaction.
        -:11460:// Note that the size can be different than the one provided to ItemSize(). Typically, widgets that spread over available surface
        -:11461:// declare their minimum size requirement to ItemSize() and provide a larger region to ItemAdd() which is used drawing/interaction.
        -:11462:// THIS IS IN THE PERFORMANCE CRITICAL PATH (UNTIL THE CLIPPING TEST AND EARLY-RETURN)
        -:11463:IM_MSVC_RUNTIME_CHECKS_OFF
function _ZN5ImGui7ItemAddERK6ImRectjPS1_i called 567709 returned 100% blocks executed 89%
   567709:11464:bool ImGui::ItemAdd(const ImRect& bb, ImGuiID id, const ImRect* nav_bb_arg, ImGuiItemFlags extra_flags)
        -:11465:{
   567709:11466:    ImGuiContext& g = *GImGui;
   567709:11467:    ImGuiWindow* window = g.CurrentWindow;
        -:11468:
        -:11469:    // Set item data
        -:11470:    // (DisplayRect is left untouched, made valid when ImGuiItemStatusFlags_HasDisplayRect is set)
   567709:11471:    g.LastItemData.ID = id;
   567709:11472:    g.LastItemData.Rect = bb;
   567709:11473:    g.LastItemData.NavRect = nav_bb_arg ? *nav_bb_arg : bb;
   567709:11473-block 2
branch  0 taken 29079 (fallthrough)
branch  1 taken 538630
    29079:11473-block 3
   538630:11473-block 4
   567709:11474:    g.LastItemData.ItemFlags = g.CurrentItemFlags | g.NextItemData.ItemFlags | extra_flags;
   567709:11475:    g.LastItemData.StatusFlags = ImGuiItemStatusFlags_None;
        -:11476:    // Note: we don't copy 'g.NextItemData.SelectionUserData' to an hypothetical g.LastItemData.SelectionUserData: since the former is not cleared.
        -:11477:
   567709:11478:    if (id != 0)
   567709:11478-block 5
branch  0 taken 131322 (fallthrough)
branch  1 taken 436387
        -:11479:    {
   131322:11480:        KeepAliveID(id);
   131322:11480-block 6
call    0 returned 131322
        -:11481:
        -:11482:        // Directional navigation processing
        -:11483:        // Runs prior to clipping early-out
        -:11484:        //  (a) So that NavInitRequest can be honored, for newly opened windows to select a default widget
        -:11485:        //  (b) So that we can scroll up/down past clipped items. This adds a small O(N) cost to regular navigation requests
        -:11486:        //      unfortunately, but it is still limited to one window. It may not scale very well for windows with ten of
        -:11487:        //      thousands of item, but at least NavMoveRequest is only set on user interaction, aka maximum once a frame.
        -:11488:        //      We could early out with "if (is_clipped && !g.NavInitRequest) return false;" but when we wouldn't be able
        -:11489:        //      to reach unclipped widgets. This would work if user had explicit scrolling control (e.g. mapped on a stick).
        -:11490:        // We intentionally don't check if g.NavWindow != NULL because g.NavAnyRequest should only be set when it is non null.
        -:11491:        // If we crash on a NULL g.NavWindow we need to fix the bug elsewhere.
   131322:11492:        if (!(g.LastItemData.ItemFlags & ImGuiItemFlags_NoNav))
branch  0 taken 97907 (fallthrough)
branch  1 taken 33415
        -:11493:        {
        -:11494:            // FIMXE-NAV: investigate changing the window tests into a simple 'if (g.NavFocusScopeId == g.CurrentFocusScopeId)' test.
    97907:11495:            window->DC.NavLayersActiveMaskNext |= (1 << window->DC.NavLayerCurrent);
    97907:11496:            if (g.NavId == id || g.NavAnyRequest)
    97907:11496-block 8
branch  0 taken 97439 (fallthrough)
branch  1 taken 468
    97439:11496-block 9
branch  2 taken 11 (fallthrough)
branch  3 taken 97428
      479:11497:                if (g.NavWindow->RootWindowForNav == window->RootWindowForNav)
      479:11497-block 10
branch  0 taken 476 (fallthrough)
branch  1 taken 3
     476*:11498:                    if (window == g.NavWindow || ((window->ChildFlags | g.NavWindow->ChildFlags) & ImGuiChildFlags_NavFlattened))
      476:11498-block 11
branch  0 taken 0 (fallthrough)
branch  1 taken 476
    %%%%%:11498-block 12
branch  2 never executed (fallthrough)
branch  3 never executed
      476:11499:                        NavProcessItem();
      476:11499-block 13
call    0 returned 476
        -:11500:        }
        -:11501:
   131322:11502:        if (g.NextItemData.HasFlags & ImGuiNextItemDataFlags_HasShortcut)
   131322:11502-block 14
branch  0 taken 0 (fallthrough)
branch  1 taken 131322
    #####:11503:            ItemHandleShortcut(id);
    %%%%%:11503-block 15
call    0 never executed
        -:11504:    }
        -:11505:
        -:11506:    // Lightweight clear of SetNextItemXXX data.
   567709:11507:    g.NextItemData.HasFlags = ImGuiNextItemDataFlags_None;
   567709:11508:    g.NextItemData.ItemFlags = ImGuiItemFlags_None;
        -:11509:
        -:11510:#ifdef IMGUI_ENABLE_TEST_ENGINE
        -:11511:    if (id != 0)
        -:11512:        IMGUI_TEST_ENGINE_ITEM_ADD(id, g.LastItemData.NavRect, &g.LastItemData);
        -:11513:#endif
        -:11514:
        -:11515:    // Clipping test
        -:11516:    // (this is an inline copy of IsClippedEx() so we can reuse the is_rect_visible value, otherwise we'd do 'if (IsClippedEx(bb, id)) return false')
        -:11517:    // g.NavActivateId is not necessarily == g.NavId, in the case of remote activation (e.g. shortcuts)
   567709:11518:    const bool is_rect_visible = bb.Overlaps(window->ClipRect);
   567709:11518-block 16
call    0 returned 567709
   567709:11519:    if (!is_rect_visible)
branch  0 taken 345450 (fallthrough)
branch  1 taken 222259
   345450:11520:        if (id == 0 || (id != g.ActiveId && id != g.ActiveIdPreviousFrame && id != g.NavId && id != g.NavActivateId))
   345450:11520-block 18
branch  0 taken 20496 (fallthrough)
branch  1 taken 324954
    20496:11520-block 19
branch  2 taken 20496 (fallthrough)
branch  3 taken 0
    20496:11520-block 20
branch  4 taken 20496 (fallthrough)
branch  5 taken 0
    20496:11520-block 21
branch  6 taken 20496 (fallthrough)
branch  7 taken 0
    20496:11520-block 22
branch  8 taken 20496 (fallthrough)
branch  9 taken 0
   345450:11521:            if (!g.ItemUnclipByLog)
   345450:11521-block 23
branch  0 taken 345450 (fallthrough)
branch  1 taken 0
   345450:11522:                return false;
   345450:11522-block 24
        -:11523:
        -:11524:    // [DEBUG]
        -:11525:#ifndef IMGUI_DISABLE_DEBUG_TOOLS
   222259:11526:    if (id != 0)
   222259:11526-block 25
branch  0 taken 110826 (fallthrough)
branch  1 taken 111433
        -:11527:    {
   110826:11528:        if (id == g.DebugLocateId)
   110826:11528-block 26
branch  0 taken 0 (fallthrough)
branch  1 taken 110826
    #####:11529:            DebugLocateItemResolveWithLastItem();
    %%%%%:11529-block 27
call    0 never executed
        -:11530:
        -:11531:        // [DEBUG] People keep stumbling on this problem and using "" as identifier in the root of a window instead of "##something".
        -:11532:        // Empty identifier are valid and useful in a small amount of cases, but 99.9% of the time you want to use "##something".
        -:11533:        // READ THE FAQ: https://dearimgui.com/faq
  110826*:11534:        IM_ASSERT(id != window->ID && "Cannot have an empty ID at the root of a window. If you need an empty label, use ## and read the FAQ about how the ID Stack works!");
   110826:11534-block 28
branch  0 taken 0 (fallthrough)
branch  1 taken 110826
    %%%%%:11534-block 29
call    2 never executed
        -:11535:    }
        -:11536:    //if (g.IO.KeyAlt) window->DrawList->AddRect(bb.Min, bb.Max, IM_COL32(255,255,0,120)); // [DEBUG]
        -:11537:    //if ((g.LastItemData.ItemFlags & ImGuiItemFlags_NoNav) == 0)
        -:11538:    //    window->DrawList->AddRect(g.LastItemData.NavRect.Min, g.LastItemData.NavRect.Max, IM_COL32(255,255,0,255)); // [DEBUG]
        -:11539:#endif
        -:11540:
        -:11541:    // We need to calculate this now to take account of the current clipping rectangle (as items like Selectable may change them)
   222259:11542:    if (is_rect_visible)
   222259:11542-block 30
branch  0 taken 222259 (fallthrough)
branch  1 taken 0
   222259:11543:        g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_Visible;
   222259:11543-block 31
   222259:11544:    if (IsMouseHoveringRect(bb.Min, bb.Max))
   222259:11544-block 32
call    0 returned 222259
branch  1 taken 2605 (fallthrough)
branch  2 taken 219654
     2605:11545:        g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredRect;
     2605:11545-block 34
   222259:11546:    return true;
   222259:11546-block 35
        -:11547:}
        -:11548:IM_MSVC_RUNTIME_CHECKS_RESTORE
        -:11549:
        -:11550://-----------------------------------------------------------------------------
        -:11551:// [SECTION] LAYOUT
        -:11552://-----------------------------------------------------------------------------
        -:11553:// - ItemSize()
        -:11554:// - SameLine()
        -:11555:// - GetCursorScreenPos()
        -:11556:// - SetCursorScreenPos()
        -:11557:// - GetCursorPos(), GetCursorPosX(), GetCursorPosY()
        -:11558:// - SetCursorPos(), SetCursorPosX(), SetCursorPosY()
        -:11559:// - GetCursorStartPos()
        -:11560:// - Indent()
        -:11561:// - Unindent()
        -:11562:// - SetNextItemWidth()
        -:11563:// - PushItemWidth()
        -:11564:// - PushMultiItemsWidths()
        -:11565:// - PopItemWidth()
        -:11566:// - CalcItemWidth()
        -:11567:// - CalcItemSize()
        -:11568:// - GetTextLineHeight()
        -:11569:// - GetTextLineHeightWithSpacing()
        -:11570:// - GetFrameHeight()
        -:11571:// - GetFrameHeightWithSpacing()
        -:11572:// - GetContentRegionMax()
        -:11573:// - GetContentRegionAvail(),
        -:11574:// - BeginGroup()
        -:11575:// - EndGroup()
        -:11576:// Also see in imgui_widgets: tab bars, and in imgui_tables: tables, columns.
        -:11577://-----------------------------------------------------------------------------
        -:11578:
        -:11579:// Advance cursor given item size for layout.
        -:11580:// Register minimum needed size so it can extend the bounding box used for auto-fit calculation.
        -:11581:// See comments in ItemAdd() about how/why the size provided to ItemSize() vs ItemAdd() may often different.
        -:11582:// THIS IS IN THE PERFORMANCE CRITICAL PATH.
        -:11583:IM_MSVC_RUNTIME_CHECKS_OFF
function _ZN5ImGui8ItemSizeERK6ImVec2f called 546185 returned 100% blocks executed 93%
   546185:11584:void ImGui::ItemSize(const ImVec2& size, float text_baseline_y)
        -:11585:{
   546185:11586:    ImGuiContext& g = *GImGui;
   546185:11587:    ImGuiWindow* window = g.CurrentWindow;
   546185:11588:    if (window->SkipItems)
   546185:11588-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 546185
    #####:11589:        return;
    %%%%%:11589-block 3
        -:11590:
        -:11591:    // We increase the height in this function to accommodate for baseline offset.
        -:11592:    // In theory we should be offsetting the starting position (window->DC.CursorPos), that will be the topic of a larger refactor,
        -:11593:    // but since ItemSize() is not yet an API that moves the cursor (to handle e.g. wrapping) enlarging the height has the same effect.
   546185:11594:    const float offset_to_match_baseline_y = (text_baseline_y >= 0) ? ImMax(0.0f, window->DC.CurrLineTextBaseOffset - text_baseline_y) : 0.0f;
   546185:11594-block 4
branch  0 taken 503978 (fallthrough)
branch  1 taken 42207
   503978:11594-block 5
call    2 returned 503978
    42207:11594-block 6
        -:11595:
   546185:11596:    const float line_y1 = window->DC.IsSameLine ? window->DC.CursorPosPrevLine.y : window->DC.CursorPos.y;
   546185:11596-block 7
branch  0 taken 427446 (fallthrough)
branch  1 taken 118739
   427446:11596-block 8
   118739:11596-block 9
   546185:11597:    const float line_height = ImMax(window->DC.CurrLineSize.y, /*ImMax(*/window->DC.CursorPos.y - line_y1/*, 0.0f)*/ + size.y + offset_to_match_baseline_y);
   546185:11597-block 10
call    0 returned 546185
        -:11598:
        -:11599:    // Always align ourselves on pixel boundaries
        -:11600:    //if (g.IO.KeyAlt) window->DrawList->AddRect(window->DC.CursorPos, window->DC.CursorPos + ImVec2(size.x, line_height), IM_COL32(255,0,0,200)); // [DEBUG]
   546185:11601:    window->DC.CursorPosPrevLine.x = window->DC.CursorPos.x + size.x;
   546185:11602:    window->DC.CursorPosPrevLine.y = line_y1;
   546185:11603:    window->DC.CursorPos.x = IM_TRUNC(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);    // Next line
   546185:11604:    window->DC.CursorPos.y = IM_TRUNC(line_y1 + line_height + g.Style.ItemSpacing.y);                       // Next line
   546185:11605:    window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPosPrevLine.x);
call    0 returned 546185
   546185:11606:    window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, window->DC.CursorPos.y - g.Style.ItemSpacing.y);
call    0 returned 546185
        -:11607:    //if (g.IO.KeyAlt) window->DrawList->AddCircle(window->DC.CursorMaxPos, 3.0f, IM_COL32(255,0,0,255), 4); // [DEBUG]
        -:11608:
   546185:11609:    window->DC.PrevLineSize.y = line_height;
   546185:11610:    window->DC.CurrLineSize.y = 0.0f;
   546185:11611:    window->DC.PrevLineTextBaseOffset = ImMax(window->DC.CurrLineTextBaseOffset, text_baseline_y);
call    0 returned 546185
   546185:11612:    window->DC.CurrLineTextBaseOffset = 0.0f;
   546185:11613:    window->DC.IsSameLine = window->DC.IsSetPos = false;
        -:11614:
        -:11615:    // Horizontal layout mode
   546185:11616:    if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)
branch  0 taken 3231 (fallthrough)
branch  1 taken 542954
     3231:11617:        SameLine();
     3231:11617-block 15
call    0 returned 3231
        -:11618:}
        -:11619:IM_MSVC_RUNTIME_CHECKS_RESTORE
        -:11620:
        -:11621:// Gets back to previous line and continue with horizontal layout
        -:11622://      offset_from_start_x == 0 : follow right after previous item
        -:11623://      offset_from_start_x != 0 : align to specified x position (relative to window/group left)
        -:11624://      spacing_w < 0            : use default spacing if offset_from_start_x == 0, no spacing if offset_from_start_x != 0
        -:11625://      spacing_w >= 0           : enforce spacing amount
function _ZN5ImGui8SameLineEff called 430927 returned 100% blocks executed 91%
   430927:11626:void ImGui::SameLine(float offset_from_start_x, float spacing_w)
        -:11627:{
   430927:11628:    ImGuiContext& g = *GImGui;
   430927:11629:    ImGuiWindow* window = g.CurrentWindow;
   430927:11630:    if (window->SkipItems)
   430927:11630-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 430927
    #####:11631:        return;
    %%%%%:11631-block 3
        -:11632:
   430927:11633:    if (offset_from_start_x != 0.0f)
   430927:11633-block 4
branch  0 taken 404733 (fallthrough)
branch  1 taken 26194
        -:11634:    {
   404733:11635:        if (spacing_w < 0.0f)
   404733:11635-block 5
branch  0 taken 404733 (fallthrough)
branch  1 taken 0
   404733:11636:            spacing_w = 0.0f;
   404733:11636-block 6
   404733:11637:        window->DC.CursorPos.x = window->Pos.x - window->Scroll.x + offset_from_start_x + spacing_w + window->DC.GroupOffset.x + window->DC.ColumnsOffset.x;
   404733:11638:        window->DC.CursorPos.y = window->DC.CursorPosPrevLine.y;
   404733:11638-block 7
        -:11639:    }
        -:11640:    else
        -:11641:    {
    26194:11642:        if (spacing_w < 0.0f)
    26194:11642-block 8
branch  0 taken 26194 (fallthrough)
branch  1 taken 0
    26194:11643:            spacing_w = g.Style.ItemSpacing.x;
    26194:11643-block 9
    26194:11644:        window->DC.CursorPos.x = window->DC.CursorPosPrevLine.x + spacing_w;
    26194:11645:        window->DC.CursorPos.y = window->DC.CursorPosPrevLine.y;
    26194:11645-block 10
        -:11646:    }
   430927:11647:    window->DC.CurrLineSize = window->DC.PrevLineSize;
   430927:11648:    window->DC.CurrLineTextBaseOffset = window->DC.PrevLineTextBaseOffset;
   430927:11649:    window->DC.IsSameLine = true;
   430927:11649-block 11
        -:11650:}
        -:11651:
function _ZN5ImGui18GetCursorScreenPosEv called 18429 returned 100% blocks executed 100%
    18429:11652:ImVec2 ImGui::GetCursorScreenPos()
        -:11653:{
    18429:11654:    ImGuiWindow* window = GetCurrentWindowRead();
    18429:11654-block 2
call    0 returned 18429
    18429:11655:    return window->DC.CursorPos;
        -:11656:}
        -:11657:
function _ZN5ImGui18SetCursorScreenPosERK6ImVec2 called 0 returned 0% blocks executed 0%
    #####:11658:void ImGui::SetCursorScreenPos(const ImVec2& pos)
        -:11659:{
    #####:11660:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%:11660-block 2
call    0 never executed
    #####:11661:    window->DC.CursorPos = pos;
        -:11662:    //window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, window->DC.CursorPos);
    #####:11663:    window->DC.IsSetPos = true;
    #####:11664:}
        -:11665:
        -:11666:// User generally sees positions in window coordinates. Internally we store CursorPos in absolute screen coordinates because it is more convenient.
        -:11667:// Conversion happens as we pass the value to user, but it makes our naming convention confusing because GetCursorPos() == (DC.CursorPos - window.Pos). May want to rename 'DC.CursorPos'.
function _ZN5ImGui12GetCursorPosEv called 0 returned 0% blocks executed 0%
    #####:11668:ImVec2 ImGui::GetCursorPos()
        -:11669:{
    #####:11670:    ImGuiWindow* window = GetCurrentWindowRead();
    %%%%%:11670-block 2
call    0 never executed
    #####:11671:    return window->DC.CursorPos - window->Pos + window->Scroll;
call    0 never executed
call    1 never executed
        -:11672:}
        -:11673:
function _ZN5ImGui13GetCursorPosXEv called 0 returned 0% blocks executed 0%
    #####:11674:float ImGui::GetCursorPosX()
        -:11675:{
    #####:11676:    ImGuiWindow* window = GetCurrentWindowRead();
    %%%%%:11676-block 2
call    0 never executed
    #####:11677:    return window->DC.CursorPos.x - window->Pos.x + window->Scroll.x;
        -:11678:}
        -:11679:
function _ZN5ImGui13GetCursorPosYEv called 12924 returned 100% blocks executed 100%
    12924:11680:float ImGui::GetCursorPosY()
        -:11681:{
    12924:11682:    ImGuiWindow* window = GetCurrentWindowRead();
    12924:11682-block 2
call    0 returned 12924
    12924:11683:    return window->DC.CursorPos.y - window->Pos.y + window->Scroll.y;
        -:11684:}
        -:11685:
function _ZN5ImGui12SetCursorPosERK6ImVec2 called 1077 returned 100% blocks executed 100%
     1077:11686:void ImGui::SetCursorPos(const ImVec2& local_pos)
        -:11687:{
     1077:11688:    ImGuiWindow* window = GetCurrentWindow();
     1077:11688-block 2
call    0 returned 1077
     1077:11689:    window->DC.CursorPos = window->Pos - window->Scroll + local_pos;
call    0 returned 1077
call    1 returned 1077
        -:11690:    //window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, window->DC.CursorPos);
     1077:11691:    window->DC.IsSetPos = true;
     1077:11692:}
        -:11693:
function _ZN5ImGui13SetCursorPosXEf called 3231 returned 100% blocks executed 100%
     3231:11694:void ImGui::SetCursorPosX(float x)
        -:11695:{
     3231:11696:    ImGuiWindow* window = GetCurrentWindow();
     3231:11696-block 2
call    0 returned 3231
     3231:11697:    window->DC.CursorPos.x = window->Pos.x - window->Scroll.x + x;
        -:11698:    //window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPos.x);
     3231:11699:    window->DC.IsSetPos = true;
     3231:11700:}
        -:11701:
function _ZN5ImGui13SetCursorPosYEf called 12924 returned 100% blocks executed 100%
    12924:11702:void ImGui::SetCursorPosY(float y)
        -:11703:{
    12924:11704:    ImGuiWindow* window = GetCurrentWindow();
    12924:11704-block 2
call    0 returned 12924
    12924:11705:    window->DC.CursorPos.y = window->Pos.y - window->Scroll.y + y;
        -:11706:    //window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, window->DC.CursorPos.y);
    12924:11707:    window->DC.IsSetPos = true;
    12924:11708:}
        -:11709:
function _ZN5ImGui17GetCursorStartPosEv called 0 returned 0% blocks executed 0%
    #####:11710:ImVec2 ImGui::GetCursorStartPos()
        -:11711:{
    #####:11712:    ImGuiWindow* window = GetCurrentWindowRead();
    %%%%%:11712-block 2
call    0 never executed
    #####:11713:    return window->DC.CursorStartPos - window->Pos;
call    0 never executed
        -:11714:}
        -:11715:
function _ZN5ImGui6IndentEf called 0 returned 0% blocks executed 0%
    #####:11716:void ImGui::Indent(float indent_w)
        -:11717:{
    #####:11718:    ImGuiContext& g = *GImGui;
    #####:11719:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%:11719-block 2
call    0 never executed
    #####:11720:    window->DC.Indent.x += (indent_w != 0.0f) ? indent_w : g.Style.IndentSpacing;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:11720-block 4
    %%%%%:11720-block 5
    #####:11721:    window->DC.CursorPos.x = window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x;
    #####:11722:}
        -:11723:
function _ZN5ImGui8UnindentEf called 0 returned 0% blocks executed 0%
    #####:11724:void ImGui::Unindent(float indent_w)
        -:11725:{
    #####:11726:    ImGuiContext& g = *GImGui;
    #####:11727:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%:11727-block 2
call    0 never executed
    #####:11728:    window->DC.Indent.x -= (indent_w != 0.0f) ? indent_w : g.Style.IndentSpacing;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:11728-block 4
    %%%%%:11728-block 5
    #####:11729:    window->DC.CursorPos.x = window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x;
    #####:11730:}
        -:11731:
        -:11732:// Affect large frame+labels widgets only.
function _ZN5ImGui16SetNextItemWidthEf called 24771 returned 100% blocks executed 100%
    24771:11733:void ImGui::SetNextItemWidth(float item_width)
        -:11734:{
    24771:11735:    ImGuiContext& g = *GImGui;
    24771:11736:    g.NextItemData.HasFlags |= ImGuiNextItemDataFlags_HasWidth;
    24771:11737:    g.NextItemData.Width = item_width;
    24771:11738:}
        -:11739:
        -:11740:// FIXME: Remove the == 0.0f behavior?
function _ZN5ImGui13PushItemWidthEf called 1077 returned 100% blocks executed 80%
     1077:11741:void ImGui::PushItemWidth(float item_width)
        -:11742:{
     1077:11743:    ImGuiContext& g = *GImGui;
     1077:11744:    ImGuiWindow* window = g.CurrentWindow;
     1077:11745:    window->DC.ItemWidthStack.push_back(window->DC.ItemWidth); // Backup current width
     1077:11745-block 2
call    0 returned 1077
    1077*:11746:    window->DC.ItemWidth = (item_width == 0.0f ? window->ItemWidthDefault : item_width);
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:11746-block 4
     1077:11746-block 5
     1077:11747:    g.NextItemData.HasFlags &= ~ImGuiNextItemDataFlags_HasWidth;
     1077:11748:}
        -:11749:
function _ZN5ImGui20PushMultiItemsWidthsEif called 0 returned 0% blocks executed 0%
    #####:11750:void ImGui::PushMultiItemsWidths(int components, float w_full)
        -:11751:{
    #####:11752:    ImGuiContext& g = *GImGui;
    #####:11753:    ImGuiWindow* window = g.CurrentWindow;
    #####:11754:    IM_ASSERT(components > 0);
    %%%%%:11754-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:11754-block 3
call    2 never executed
    #####:11755:    const ImGuiStyle& style = g.Style;
    #####:11756:    window->DC.ItemWidthStack.push_back(window->DC.ItemWidth); // Backup current width
    %%%%%:11756-block 4
call    0 never executed
    #####:11757:    float w_items = w_full - style.ItemInnerSpacing.x * (components - 1);
    #####:11758:    float prev_split = w_items;
    #####:11759:    for (int i = components - 1; i > 0; i--)
    %%%%%:11759-block 9
branch  0 never executed
branch  1 never executed (fallthrough)
        -:11760:    {
    #####:11761:        float next_split = IM_TRUNC(w_items * i / components);
    #####:11762:        window->DC.ItemWidthStack.push_back(ImMax(prev_split - next_split, 1.0f));
    %%%%%:11762-block 6
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####:11763:        prev_split = next_split;
    %%%%%:11763-block 8
        -:11764:    }
    #####:11765:    window->DC.ItemWidth = ImMax(prev_split, 1.0f);
    %%%%%:11765-block 10
call    0 never executed
    #####:11766:    g.NextItemData.HasFlags &= ~ImGuiNextItemDataFlags_HasWidth;
    #####:11767:}
        -:11768:
function _ZN5ImGui12PopItemWidthEv called 1077 returned 100% blocks executed 50%
     1077:11769:void ImGui::PopItemWidth()
        -:11770:{
     1077:11771:    ImGuiContext& g = *GImGui;
     1077:11772:    ImGuiWindow* window = g.CurrentWindow;
     1077:11773:    if (window->DC.ItemWidthStack.Size <= 0)
     1077:11773-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
        -:11774:    {
    #####:11775:        IM_ASSERT_USER_ERROR(0, "Calling PopItemWidth() too many times!");
    %%%%%:11775-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:11775-block 5
call    3 never executed
    #####:11776:        return;
    %%%%%:11776-block 6
        -:11777:    }
     1077:11778:    window->DC.ItemWidth = window->DC.ItemWidthStack.back();
     1077:11778-block 7
call    0 returned 1077
     1077:11779:    window->DC.ItemWidthStack.pop_back();
call    0 returned 1077
        -:11780:}
        -:11781:
        -:11782:// Calculate default item width given value passed to PushItemWidth() or SetNextItemWidth().
        -:11783:// The SetNextItemWidth() data is generally cleared/consumed by ItemAdd() or NextItemData.ClearFlags()
function _ZN5ImGui13CalcItemWidthEv called 29079 returned 100% blocks executed 100%
    29079:11784:float ImGui::CalcItemWidth()
        -:11785:{
    29079:11786:    ImGuiContext& g = *GImGui;
    29079:11787:    ImGuiWindow* window = g.CurrentWindow;
        -:11788:    float w;
    29079:11789:    if (g.NextItemData.HasFlags & ImGuiNextItemDataFlags_HasWidth)
    29079:11789-block 2
branch  0 taken 24771 (fallthrough)
branch  1 taken 4308
    24771:11790:        w = g.NextItemData.Width;
    24771:11790-block 3
        -:11791:    else
     4308:11792:        w = window->DC.ItemWidth;
     4308:11792-block 4
    29079:11793:    if (w < 0.0f)
    29079:11793-block 5
branch  0 taken 25848 (fallthrough)
branch  1 taken 3231
        -:11794:    {
    25848:11795:        float region_avail_x = GetContentRegionAvail().x;
    25848:11795-block 6
call    0 returned 25848
    25848:11796:        w = ImMax(1.0f, region_avail_x + w);
call    0 returned 25848
        -:11797:    }
    29079:11798:    w = IM_TRUNC(w);
    29079:11799:    return w;
    29079:11799-block 8
        -:11800:}
        -:11801:
        -:11802:// [Internal] Calculate full item size given user provided 'size' parameter and default width/height. Default width is often == CalcItemWidth().
        -:11803:// Those two functions CalcItemWidth vs CalcItemSize are awkwardly named because they are not fully symmetrical.
        -:11804:// Note that only CalcItemWidth() is publicly exposed.
        -:11805:// The 4.0f here may be changed to match CalcItemWidth() and/or BeginChild() (right now we have a mismatch which is harmless but undesirable)
function _ZN5ImGui12CalcItemSizeE6ImVec2ff called 66731 returned 100% blocks executed 87%
    66731:11806:ImVec2 ImGui::CalcItemSize(ImVec2 size, float default_w, float default_h)
        -:11807:{
    66731:11808:    ImVec2 avail;
    66731:11809:    if (size.x < 0.0f || size.y < 0.0f)
    66731:11809-block 2
branch  0 taken 66731 (fallthrough)
branch  1 taken 0
    66731:11809-block 3
branch  2 taken 4308 (fallthrough)
branch  3 taken 62423
     4308:11810:        avail = GetContentRegionAvail();
     4308:11810-block 4
call    0 returned 4308
        -:11811:
    66731:11812:    if (size.x == 0.0f)
    66731:11812-block 5
branch  0 taken 35541 (fallthrough)
branch  1 taken 31190
    35541:11813:        size.x = default_w;
    35541:11813-block 6
    31190:11814:    else if (size.x < 0.0f)
    31190:11814-block 7
branch  0 taken 0 (fallthrough)
branch  1 taken 31190
    #####:11815:        size.x = ImMax(4.0f, avail.x + size.x); // <-- size.x is negative here so we are subtracting
    %%%%%:11815-block 8
call    0 never executed
        -:11816:
    66731:11817:    if (size.y == 0.0f)
    66731:11817-block 10
branch  0 taken 30156 (fallthrough)
branch  1 taken 36575
    30156:11818:        size.y = default_h;
    30156:11818-block 11
    36575:11819:    else if (size.y < 0.0f)
    36575:11819-block 12
branch  0 taken 4308 (fallthrough)
branch  1 taken 32267
     4308:11820:        size.y = ImMax(4.0f, avail.y + size.y); // <-- size.y is negative here so we are subtracting
     4308:11820-block 13
call    0 returned 4308
        -:11821:
    66731:11822:    return size;
    66731:11822-block 15
        -:11823:}
        -:11824:
function _ZN5ImGui17GetTextLineHeightEv called 17232 returned 100% blocks executed 100%
    17232:11825:float ImGui::GetTextLineHeight()
        -:11826:{
    17232:11827:    ImGuiContext& g = *GImGui;
    17232:11828:    return g.FontSize;
    17232:11828-block 2
        -:11829:}
        -:11830:
function _ZN5ImGui28GetTextLineHeightWithSpacingEv called 1077 returned 100% blocks executed 100%
     1077:11831:float ImGui::GetTextLineHeightWithSpacing()
        -:11832:{
     1077:11833:    ImGuiContext& g = *GImGui;
     1077:11834:    return g.FontSize + g.Style.ItemSpacing.y;
     1077:11834-block 2
        -:11835:}
        -:11836:
function _ZN5ImGui14GetFrameHeightEv called 15078 returned 100% blocks executed 100%
    15078:11837:float ImGui::GetFrameHeight()
        -:11838:{
    15078:11839:    ImGuiContext& g = *GImGui;
    15078:11840:    return g.FontSize + g.Style.FramePadding.y * 2.0f;
    15078:11840-block 2
        -:11841:}
        -:11842:
function _ZN5ImGui25GetFrameHeightWithSpacingEv called 4308 returned 100% blocks executed 100%
     4308:11843:float ImGui::GetFrameHeightWithSpacing()
        -:11844:{
     4308:11845:    ImGuiContext& g = *GImGui;
     4308:11846:    return g.FontSize + g.Style.FramePadding.y * 2.0f + g.Style.ItemSpacing.y;
     4308:11846-block 2
        -:11847:}
        -:11848:
function _ZN5ImGui21GetContentRegionAvailEv called 38772 returned 100% blocks executed 100%
    38772:11849:ImVec2 ImGui::GetContentRegionAvail()
        -:11850:{
    38772:11851:    ImGuiContext& g = *GImGui;
    38772:11852:    ImGuiWindow* window = g.CurrentWindow;
    38772:11853:    ImVec2 mx = (window->DC.CurrentColumns || g.CurrentTable) ? window->WorkRect.Max : window->ContentRegionRect.Max;
    38772:11853-block 2
branch  0 taken 38772 (fallthrough)
branch  1 taken 0
    38772:11853-block 3
branch  2 taken 24771 (fallthrough)
branch  3 taken 14001
    24771:11853-block 4
    14001:11853-block 5
    38772:11854:    return mx - window->DC.CursorPos;
    38772:11854-block 6
call    0 returned 38772
        -:11855:}
        -:11856:
        -:11857:#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
        -:11858:
        -:11859:// You should never need those functions. Always use GetCursorScreenPos() and GetContentRegionAvail()!
        -:11860:// They are bizarre local-coordinates which don't play well with scrolling.
function _ZN5ImGui19GetContentRegionMaxEv called 0 returned 0% blocks executed 0%
    #####:11861:ImVec2 ImGui::GetContentRegionMax()
        -:11862:{
    #####:11863:    return GetContentRegionAvail() + GetCursorScreenPos() - GetWindowPos();
    %%%%%:11863-block 2
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:11864:}
        -:11865:
function _ZN5ImGui25GetWindowContentRegionMinEv called 0 returned 0% blocks executed 0%
    #####:11866:ImVec2 ImGui::GetWindowContentRegionMin()
        -:11867:{
    #####:11868:    ImGuiWindow* window = GImGui->CurrentWindow;
    #####:11869:    return window->ContentRegionRect.Min - window->Pos;
    %%%%%:11869-block 2
call    0 never executed
        -:11870:}
        -:11871:
function _ZN5ImGui25GetWindowContentRegionMaxEv called 0 returned 0% blocks executed 0%
    #####:11872:ImVec2 ImGui::GetWindowContentRegionMax()
        -:11873:{
    #####:11874:    ImGuiWindow* window = GImGui->CurrentWindow;
    #####:11875:    return window->ContentRegionRect.Max - window->Pos;
    %%%%%:11875-block 2
call    0 never executed
        -:11876:}
        -:11877:#endif
        -:11878:
        -:11879:// Lock horizontal starting position + capture group bounding box into one "item" (so you can use IsItemHovered() or layout primitives such as SameLine() on whole group, etc.)
        -:11880:// Groups are currently a mishmash of functionalities which should perhaps be clarified and separated.
        -:11881:// FIXME-OPT: Could we safely early out on ->SkipItems?
function _ZN5ImGui10BeginGroupEv called 1077 returned 100% blocks executed 83%
     1077:11882:void ImGui::BeginGroup()
        -:11883:{
     1077:11884:    ImGuiContext& g = *GImGui;
     1077:11885:    ImGuiWindow* window = g.CurrentWindow;
        -:11886:
     1077:11887:    g.GroupStack.resize(g.GroupStack.Size + 1);
     1077:11887-block 2
call    0 returned 1077
     1077:11888:    ImGuiGroupData& group_data = g.GroupStack.back();
call    0 returned 1077
     1077:11889:    group_data.WindowID = window->ID;
     1077:11890:    group_data.BackupCursorPos = window->DC.CursorPos;
     1077:11891:    group_data.BackupCursorPosPrevLine = window->DC.CursorPosPrevLine;
     1077:11892:    group_data.BackupCursorMaxPos = window->DC.CursorMaxPos;
     1077:11893:    group_data.BackupIndent = window->DC.Indent;
     1077:11894:    group_data.BackupGroupOffset = window->DC.GroupOffset;
     1077:11895:    group_data.BackupCurrLineSize = window->DC.CurrLineSize;
     1077:11896:    group_data.BackupCurrLineTextBaseOffset = window->DC.CurrLineTextBaseOffset;
     1077:11897:    group_data.BackupActiveIdIsAlive = g.ActiveIdIsAlive;
     1077:11898:    group_data.BackupHoveredIdIsAlive = g.HoveredId != 0;
     1077:11899:    group_data.BackupIsSameLine = window->DC.IsSameLine;
     1077:11900:    group_data.BackupActiveIdPreviousFrameIsAlive = g.ActiveIdPreviousFrameIsAlive;
     1077:11901:    group_data.EmitItem = true;
        -:11902:
     1077:11903:    window->DC.GroupOffset.x = window->DC.CursorPos.x - window->Pos.x - window->DC.ColumnsOffset.x;
     1077:11904:    window->DC.Indent = window->DC.GroupOffset;
     1077:11905:    window->DC.CursorMaxPos = window->DC.CursorPos;
     1077:11906:    window->DC.CurrLineSize = ImVec2(0.0f, 0.0f);
call    0 returned 1077
     1077:11907:    if (g.LogEnabled)
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####:11908:        g.LogLinePosY = -FLT_MAX; // To enforce a carriage return
    %%%%%:11908-block 6
     1077:11909:}
        -:11910:
function _ZN5ImGui8EndGroupEv called 1077 returned 100% blocks executed 27%
     1077:11911:void ImGui::EndGroup()
        -:11912:{
     1077:11913:    ImGuiContext& g = *GImGui;
     1077:11914:    ImGuiWindow* window = g.CurrentWindow;
    1077*:11915:    IM_ASSERT(g.GroupStack.Size > 0); // Mismatched BeginGroup()/EndGroup() calls
     1077:11915-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:11915-block 3
call    2 never executed
        -:11916:
     1077:11917:    ImGuiGroupData& group_data = g.GroupStack.back();
     1077:11917-block 4
call    0 returned 1077
    1077*:11918:    IM_ASSERT(group_data.WindowID == window->ID); // EndGroup() in wrong window?
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:11918-block 6
call    2 never executed
        -:11919:
     1077:11920:    if (window->DC.IsSetPos)
     1077:11920-block 7
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####:11921:        ErrorCheckUsingSetCursorPosToExtendParentBoundaries();
    %%%%%:11921-block 8
call    0 never executed
        -:11922:
        -:11923:    // Include LastItemData.Rect.Max as a workaround for e.g. EndTable() undershooting with CursorMaxPos report. (#7543)
     1077:11924:    ImRect group_bb(group_data.BackupCursorPos, ImMax(ImMax(window->DC.CursorMaxPos, g.LastItemData.Rect.Max), group_data.BackupCursorPos));
     1077:11924-block 9
call    0 returned 1077
call    1 returned 1077
call    2 returned 1077
     1077:11925:    window->DC.CursorPos = group_data.BackupCursorPos;
     1077:11926:    window->DC.CursorPosPrevLine = group_data.BackupCursorPosPrevLine;
     1077:11927:    window->DC.CursorMaxPos = ImMax(group_data.BackupCursorMaxPos, group_bb.Max);
call    0 returned 1077
     1077:11928:    window->DC.Indent = group_data.BackupIndent;
     1077:11929:    window->DC.GroupOffset = group_data.BackupGroupOffset;
     1077:11930:    window->DC.CurrLineSize = group_data.BackupCurrLineSize;
     1077:11931:    window->DC.CurrLineTextBaseOffset = group_data.BackupCurrLineTextBaseOffset;
     1077:11932:    window->DC.IsSameLine = group_data.BackupIsSameLine;
     1077:11933:    if (g.LogEnabled)
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####:11934:        g.LogLinePosY = -FLT_MAX; // To enforce a carriage return
    %%%%%:11934-block 14
        -:11935:
     1077:11936:    if (!group_data.EmitItem)
     1077:11936-block 15
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
        -:11937:    {
     1077:11938:        g.GroupStack.pop_back();
     1077:11938-block 16
call    0 returned 1077
     1077:11939:        return;
        -:11940:    }
        -:11941:
    #####:11942:    window->DC.CurrLineTextBaseOffset = ImMax(window->DC.PrevLineTextBaseOffset, group_data.BackupCurrLineTextBaseOffset); // FIXME: Incorrect, we should grab the base offset from the *first line* of the group but it is hard to obtain now.
    %%%%%:11942-block 18
call    0 never executed
    #####:11943:    ItemSize(group_bb.GetSize());
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$:11943-block 52
    #####:11944:    ItemAdd(group_bb, 0, NULL, ImGuiItemFlags_NoTabStop);
    %%%%%:11944-block 21
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:11945:
        -:11946:    // If the current ActiveId was declared within the boundary of our group, we copy it to LastItemId so IsItemActive(), IsItemDeactivated() etc. will be functional on the entire group.
        -:11947:    // It would be neater if we replaced window.DC.LastItemId by e.g. 'bool LastItemIsActive', but would put a little more burden on individual widgets.
        -:11948:    // Also if you grep for LastItemId you'll notice it is only used in that context.
        -:11949:    // (The two tests not the same because ActiveIdIsAlive is an ID itself, in order to be able to handle ActiveId being overwritten during the frame.)
    #####:11950:    const bool group_contains_curr_active_id = (group_data.BackupActiveIdIsAlive != g.ActiveId) && (g.ActiveIdIsAlive == g.ActiveId) && g.ActiveId;
    %%%%%:11950-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:11950-block 23
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:11950-block 24
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:11950-block 25
    %%%%%:11950-block 26
    #####:11951:    const bool group_contains_prev_active_id = (group_data.BackupActiveIdPreviousFrameIsAlive == false) && (g.ActiveIdPreviousFrameIsAlive == true);
    %%%%%:11951-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:11951-block 28
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:11951-block 29
    %%%%%:11951-block 30
    #####:11952:    if (group_contains_curr_active_id)
    %%%%%:11952-block 31
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:11953:        g.LastItemData.ID = g.ActiveId;
    %%%%%:11953-block 32
    #####:11954:    else if (group_contains_prev_active_id)
    %%%%%:11954-block 33
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:11955:        g.LastItemData.ID = g.ActiveIdPreviousFrame;
    %%%%%:11955-block 34
    #####:11956:    g.LastItemData.Rect = group_bb;
        -:11957:
        -:11958:    // Forward Hovered flag
    #####:11959:    const bool group_contains_curr_hovered_id = (group_data.BackupHoveredIdIsAlive == false) && g.HoveredId != 0;
    %%%%%:11959-block 35
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:11959-block 36
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:11959-block 37
    %%%%%:11959-block 38
    #####:11960:    if (group_contains_curr_hovered_id)
    %%%%%:11960-block 39
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:11961:        g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredWindow;
    %%%%%:11961-block 40
        -:11962:
        -:11963:    // Forward Edited flag
    #####:11964:    if (group_contains_curr_active_id && g.ActiveIdHasBeenEditedThisFrame)
    %%%%%:11964-block 41
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:11964-block 42
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:11965:        g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_Edited;
    %%%%%:11965-block 43
        -:11966:
        -:11967:    // Forward Deactivated flag
    #####:11968:    g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HasDeactivated;
    #####:11969:    if (group_contains_prev_active_id && g.ActiveId != g.ActiveIdPreviousFrame)
    %%%%%:11969-block 44
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:11969-block 45
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:11970:        g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_Deactivated;
    %%%%%:11970-block 46
        -:11971:
    #####:11972:    g.GroupStack.pop_back();
    %%%%%:11972-block 47
call    0 never executed
    #####:11973:    if (g.DebugShowGroupRects)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:11974:        window->DrawList->AddRect(group_bb.Min, group_bb.Max, IM_COL32(255,0,255,255));   // [Debug]
    %%%%%:11974-block 49
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:11975:}
        -:11976:
        -:11977:
        -:11978://-----------------------------------------------------------------------------
        -:11979:// [SECTION] SCROLLING
        -:11980://-----------------------------------------------------------------------------
        -:11981:
        -:11982:// Helper to snap on edges when aiming at an item very close to the edge,
        -:11983:// So the difference between WindowPadding and ItemSpacing will be in the visible area after scrolling.
        -:11984:// When we refactor the scrolling API this may be configurable with a flag?
        -:11985:// Note that the effect for this won't be visible on X axis with default Style settings as WindowPadding.x == ItemSpacing.x by default.
function _ZL18CalcScrollEdgeSnapfffff called 0 returned 0% blocks executed 0%
    #####:11986:static float CalcScrollEdgeSnap(float target, float snap_min, float snap_max, float snap_threshold, float center_ratio)
        -:11987:{
    #####:11988:    if (target <= snap_min + snap_threshold)
    %%%%%:11988-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:11989:        return ImLerp(snap_min, target, center_ratio);
    %%%%%:11989-block 3
call    0 never executed
    #####:11990:    if (target >= snap_max - snap_threshold)
    %%%%%:11990-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:11991:        return ImLerp(target, snap_max, center_ratio);
    %%%%%:11991-block 5
call    0 never executed
    #####:11992:    return target;
    %%%%%:11992-block 6
        -:11993:}
        -:11994:
function _ZL38CalcNextScrollFromScrollTargetAndClampP11ImGuiWindow called 16368 returned 100% blocks executed 82%
    16368:11995:static ImVec2 CalcNextScrollFromScrollTargetAndClamp(ImGuiWindow* window)
        -:11996:{
    16368:11997:    ImVec2 scroll = window->Scroll;
    16368:11998:    ImVec2 decoration_size(window->DecoOuterSizeX1 + window->DecoInnerSizeX1 + window->DecoOuterSizeX2, window->DecoOuterSizeY1 + window->DecoInnerSizeY1 + window->DecoOuterSizeY2);
    16368:11998-block 2
call    0 returned 16368
    49104:11999:    for (int axis = 0; axis < 2; axis++)
    32736:11999-block 30
    49104:11999-block 31
branch  0 taken 32736
branch  1 taken 16368 (fallthrough)
        -:12000:    {
    32736:12001:        if (window->ScrollTarget[axis] < FLT_MAX)
    32736:12001-block 4
call    0 returned 32736
branch  1 taken 1077 (fallthrough)
branch  2 taken 31659
        -:12002:        {
     1077:12003:            float center_ratio = window->ScrollTargetCenterRatio[axis];
     1077:12003-block 6
call    0 returned 1077
     1077:12004:            float scroll_target = window->ScrollTarget[axis];
call    0 returned 1077
     1077:12005:            if (window->ScrollTargetEdgeSnapDist[axis] > 0.0f)
call    0 returned 1077
branch  1 taken 0 (fallthrough)
branch  2 taken 1077
        -:12006:            {
    #####:12007:                float snap_min = 0.0f;
    #####:12008:                float snap_max = window->ScrollMax[axis] + window->SizeFull[axis] - decoration_size[axis];
    %%%%%:12008-block 10
call    0 never executed
call    1 never executed
call    2 never executed
    #####:12009:                scroll_target = CalcScrollEdgeSnap(scroll_target, snap_min, snap_max, window->ScrollTargetEdgeSnapDist[axis], center_ratio);
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:12009-block 15
        -:12010:            }
     1077:12011:            scroll[axis] = scroll_target - center_ratio * (window->SizeFull[axis] - decoration_size[axis]);
     1077:12011-block 16
call    0 returned 1077
call    1 returned 1077
call    2 returned 1077
        -:12012:        }
    32736:12013:        scroll[axis] = IM_ROUND(ImMax(scroll[axis], 0.0f));
    32736:12013-block 20
call    0 returned 32736
call    1 returned 32736
call    2 returned 32736
    32736:12014:        if (!window->Collapsed && !window->SkipItems)
branch  0 taken 32736 (fallthrough)
branch  1 taken 0
    32736:12014-block 24
branch  2 taken 32736 (fallthrough)
branch  3 taken 0
    32736:12015:            scroll[axis] = ImMin(scroll[axis], window->ScrollMax[axis]);
    32736:12015-block 25
call    0 returned 32736
call    1 returned 32736
call    2 returned 32736
call    3 returned 32736
        -:12016:    }
    16368:12017:    return scroll;
    16368:12017-block 32
    16368:12017-block 33
        -:12018:}
        -:12019:
function _ZN5ImGui12ScrollToItemEi called 0 returned 0% blocks executed 0%
    #####:12020:void ImGui::ScrollToItem(ImGuiScrollFlags flags)
        -:12021:{
    #####:12022:    ImGuiContext& g = *GImGui;
    #####:12023:    ImGuiWindow* window = g.CurrentWindow;
    #####:12024:    ScrollToRectEx(window, g.LastItemData.NavRect, flags);
    %%%%%:12024-block 2
call    0 never executed
    #####:12025:}
        -:12026:
function _ZN5ImGui12ScrollToRectEP11ImGuiWindowRK6ImRecti called 0 returned 0% blocks executed 0%
    #####:12027:void ImGui::ScrollToRect(ImGuiWindow* window, const ImRect& item_rect, ImGuiScrollFlags flags)
        -:12028:{
    #####:12029:    ScrollToRectEx(window, item_rect, flags);
    %%%%%:12029-block 2
call    0 never executed
    #####:12030:}
        -:12031:
        -:12032:// Scroll to keep newly navigated item fully into view
function _ZN5ImGui14ScrollToRectExEP11ImGuiWindowRK6ImRecti called 0 returned 0% blocks executed 0%
    #####:12033:ImVec2 ImGui::ScrollToRectEx(ImGuiWindow* window, const ImRect& item_rect, ImGuiScrollFlags flags)
        -:12034:{
    #####:12035:    ImGuiContext& g = *GImGui;
    #####:12036:    ImRect scroll_rect(window->InnerRect.Min - ImVec2(1, 1), window->InnerRect.Max + ImVec2(1, 1));
    %%%%%:12036-block 2
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:12037:    scroll_rect.Min.x = ImMin(scroll_rect.Min.x + window->DecoInnerSizeX1, scroll_rect.Max.x);
call    0 never executed
    #####:12038:    scroll_rect.Min.y = ImMin(scroll_rect.Min.y + window->DecoInnerSizeY1, scroll_rect.Max.y);
call    0 never executed
        -:12039:    //GetForegroundDrawList(window)->AddRect(item_rect.Min, item_rect.Max, IM_COL32(255,0,0,255), 0.0f, 0, 5.0f); // [DEBUG]
        -:12040:    //GetForegroundDrawList(window)->AddRect(scroll_rect.Min, scroll_rect.Max, IM_COL32_WHITE); // [DEBUG]
        -:12041:
        -:12042:    // Check that only one behavior is selected per axis
    #####:12043:    IM_ASSERT((flags & ImGuiScrollFlags_MaskX_) == 0 || ImIsPowerOfTwo(flags & ImGuiScrollFlags_MaskX_));
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12043-block 10
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:12043-block 12
call    5 never executed
    #####:12044:    IM_ASSERT((flags & ImGuiScrollFlags_MaskY_) == 0 || ImIsPowerOfTwo(flags & ImGuiScrollFlags_MaskY_));
    %%%%%:12044-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12044-block 14
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:12044-block 16
call    5 never executed
        -:12045:
        -:12046:    // Defaults
    #####:12047:    ImGuiScrollFlags in_flags = flags;
    #####:12048:    if ((flags & ImGuiScrollFlags_MaskX_) == 0 && window->ScrollbarX)
    %%%%%:12048-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12048-block 18
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:12049:        flags |= ImGuiScrollFlags_KeepVisibleEdgeX;
    %%%%%:12049-block 19
    #####:12050:    if ((flags & ImGuiScrollFlags_MaskY_) == 0)
    %%%%%:12050-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:12051:        flags |= window->Appearing ? ImGuiScrollFlags_AlwaysCenterY : ImGuiScrollFlags_KeepVisibleEdgeY;
    %%%%%:12051-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12051-block 22
    %%%%%:12051-block 23
    %%%%%:12051-block 24
        -:12052:
    #####:12053:    const bool fully_visible_x = item_rect.Min.x >= scroll_rect.Min.x && item_rect.Max.x <= scroll_rect.Max.x;
    %%%%%:12053-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12053-block 26
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:12053-block 27
    %%%%%:12053-block 28
    #####:12054:    const bool fully_visible_y = item_rect.Min.y >= scroll_rect.Min.y && item_rect.Max.y <= scroll_rect.Max.y;
    %%%%%:12054-block 29
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12054-block 30
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:12054-block 31
    %%%%%:12054-block 32
    #####:12055:    const bool can_be_fully_visible_x = (item_rect.GetWidth() + g.Style.ItemSpacing.x * 2.0f) <= scroll_rect.GetWidth() || (window->AutoFitFramesX > 0) || (window->Flags & ImGuiWindowFlags_AlwaysAutoResize) != 0;
    %%%%%:12055-block 33
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:12055-block 36
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:12055-block 37
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%:12055-block 38
    %%%%%:12055-block 39
    #####:12056:    const bool can_be_fully_visible_y = (item_rect.GetHeight() + g.Style.ItemSpacing.y * 2.0f) <= scroll_rect.GetHeight() || (window->AutoFitFramesY > 0) || (window->Flags & ImGuiWindowFlags_AlwaysAutoResize) != 0;
    %%%%%:12056-block 40
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:12056-block 43
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:12056-block 44
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%:12056-block 45
    %%%%%:12056-block 46
        -:12057:
    #####:12058:    if ((flags & ImGuiScrollFlags_KeepVisibleEdgeX) && !fully_visible_x)
    %%%%%:12058-block 47
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12058-block 48
branch  2 never executed (fallthrough)
branch  3 never executed
        -:12059:    {
    #####:12060:        if (item_rect.Min.x < scroll_rect.Min.x || !can_be_fully_visible_x)
    %%%%%:12060-block 49
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12060-block 50
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:12061:            SetScrollFromPosX(window, item_rect.Min.x - g.Style.ItemSpacing.x - window->Pos.x, 0.0f);
    %%%%%:12061-block 51
call    0 never executed
    #####:12062:        else if (item_rect.Max.x >= scroll_rect.Max.x)
    %%%%%:12062-block 52
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:12063:            SetScrollFromPosX(window, item_rect.Max.x + g.Style.ItemSpacing.x - window->Pos.x, 1.0f);
    %%%%%:12063-block 53
call    0 never executed
        -:12064:    }
    #####:12065:    else if (((flags & ImGuiScrollFlags_KeepVisibleCenterX) && !fully_visible_x) || (flags & ImGuiScrollFlags_AlwaysCenterX))
    %%%%%:12065-block 55
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12065-block 56
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:12065-block 57
branch  4 never executed (fallthrough)
branch  5 never executed
        -:12066:    {
    #####:12067:        if (can_be_fully_visible_x)
    %%%%%:12067-block 58
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:12068:            SetScrollFromPosX(window, ImTrunc((item_rect.Min.x + item_rect.Max.x) * 0.5f) - window->Pos.x, 0.5f);
    %%%%%:12068-block 59
call    0 never executed
call    1 never executed
        -:12069:        else
    #####:12070:            SetScrollFromPosX(window, item_rect.Min.x - window->Pos.x, 0.0f);
    %%%%%:12070-block 61
call    0 never executed
        -:12071:    }
        -:12072:
    #####:12073:    if ((flags & ImGuiScrollFlags_KeepVisibleEdgeY) && !fully_visible_y)
    %%%%%:12073-block 62
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12073-block 63
branch  2 never executed (fallthrough)
branch  3 never executed
        -:12074:    {
    #####:12075:        if (item_rect.Min.y < scroll_rect.Min.y || !can_be_fully_visible_y)
    %%%%%:12075-block 64
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12075-block 65
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:12076:            SetScrollFromPosY(window, item_rect.Min.y - g.Style.ItemSpacing.y - window->Pos.y, 0.0f);
    %%%%%:12076-block 66
call    0 never executed
    #####:12077:        else if (item_rect.Max.y >= scroll_rect.Max.y)
    %%%%%:12077-block 67
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:12078:            SetScrollFromPosY(window, item_rect.Max.y + g.Style.ItemSpacing.y - window->Pos.y, 1.0f);
    %%%%%:12078-block 68
call    0 never executed
        -:12079:    }
    #####:12080:    else if (((flags & ImGuiScrollFlags_KeepVisibleCenterY) && !fully_visible_y) || (flags & ImGuiScrollFlags_AlwaysCenterY))
    %%%%%:12080-block 70
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12080-block 71
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:12080-block 72
branch  4 never executed (fallthrough)
branch  5 never executed
        -:12081:    {
    #####:12082:        if (can_be_fully_visible_y)
    %%%%%:12082-block 73
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:12083:            SetScrollFromPosY(window, ImTrunc((item_rect.Min.y + item_rect.Max.y) * 0.5f) - window->Pos.y, 0.5f);
    %%%%%:12083-block 74
call    0 never executed
call    1 never executed
        -:12084:        else
    #####:12085:            SetScrollFromPosY(window, item_rect.Min.y - window->Pos.y, 0.0f);
    %%%%%:12085-block 76
call    0 never executed
        -:12086:    }
        -:12087:
    #####:12088:    ImVec2 next_scroll = CalcNextScrollFromScrollTargetAndClamp(window);
    %%%%%:12088-block 77
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:12089:    ImVec2 delta_scroll = next_scroll - window->Scroll;
    %%%%%:12089-block 78
call    0 never executed
        -:12090:
        -:12091:    // Also scroll parent window to keep us into view if necessary
    #####:12092:    if (!(flags & ImGuiScrollFlags_NoScrollParent) && (window->Flags & ImGuiWindowFlags_ChildWindow))
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12092-block 80
branch  2 never executed (fallthrough)
branch  3 never executed
        -:12093:    {
        -:12094:        // FIXME-SCROLL: May be an option?
    #####:12095:        if ((in_flags & (ImGuiScrollFlags_AlwaysCenterX | ImGuiScrollFlags_KeepVisibleCenterX)) != 0)
    %%%%%:12095-block 81
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:12096:            in_flags = (in_flags & ~ImGuiScrollFlags_MaskX_) | ImGuiScrollFlags_KeepVisibleEdgeX;
    %%%%%:12096-block 82
    #####:12097:        if ((in_flags & (ImGuiScrollFlags_AlwaysCenterY | ImGuiScrollFlags_KeepVisibleCenterY)) != 0)
    %%%%%:12097-block 83
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:12098:            in_flags = (in_flags & ~ImGuiScrollFlags_MaskY_) | ImGuiScrollFlags_KeepVisibleEdgeY;
    %%%%%:12098-block 84
    #####:12099:        delta_scroll += ScrollToRectEx(window->ParentWindow, ImRect(item_rect.Min - delta_scroll, item_rect.Max - delta_scroll), in_flags);
    %%%%%:12099-block 85
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    %%%%%:12099-block 89
call    6 never executed
    $$$$$:12099-block 93
    $$$$$:12099-block 94
    $$$$$:12099-block 95
    $$$$$:12099-block 96
        -:12100:    }
        -:12101:
    #####:12102:    return delta_scroll;
    %%%%%:12102-block 91
    %%%%%:12102-block 92
        -:12103:}
        -:12104:
function _ZN5ImGui10GetScrollXEv called 1077 returned 100% blocks executed 100%
     1077:12105:float ImGui::GetScrollX()
        -:12106:{
     1077:12107:    ImGuiWindow* window = GImGui->CurrentWindow;
     1077:12108:    return window->Scroll.x;
     1077:12108-block 2
        -:12109:}
        -:12110:
function _ZN5ImGui10GetScrollYEv called 4308 returned 100% blocks executed 100%
     4308:12111:float ImGui::GetScrollY()
        -:12112:{
     4308:12113:    ImGuiWindow* window = GImGui->CurrentWindow;
     4308:12114:    return window->Scroll.y;
     4308:12114-block 2
        -:12115:}
        -:12116:
function _ZN5ImGui13GetScrollMaxXEv called 0 returned 0% blocks executed 0%
    #####:12117:float ImGui::GetScrollMaxX()
        -:12118:{
    #####:12119:    ImGuiWindow* window = GImGui->CurrentWindow;
    #####:12120:    return window->ScrollMax.x;
    %%%%%:12120-block 2
        -:12121:}
        -:12122:
function _ZN5ImGui13GetScrollMaxYEv called 3231 returned 100% blocks executed 100%
     3231:12123:float ImGui::GetScrollMaxY()
        -:12124:{
     3231:12125:    ImGuiWindow* window = GImGui->CurrentWindow;
     3231:12126:    return window->ScrollMax.y;
     3231:12126-block 2
        -:12127:}
        -:12128:
function _ZN5ImGui10SetScrollXEP11ImGuiWindowf called 0 returned 0% blocks executed 0%
    #####:12129:void ImGui::SetScrollX(ImGuiWindow* window, float scroll_x)
        -:12130:{
    #####:12131:    window->ScrollTarget.x = scroll_x;
    #####:12132:    window->ScrollTargetCenterRatio.x = 0.0f;
    #####:12133:    window->ScrollTargetEdgeSnapDist.x = 0.0f;
    #####:12134:}
        -:12135:
function _ZN5ImGui10SetScrollYEP11ImGuiWindowf called 1 returned 100% blocks executed 100%
        1:12136:void ImGui::SetScrollY(ImGuiWindow* window, float scroll_y)
        -:12137:{
        1:12138:    window->ScrollTarget.y = scroll_y;
        1:12139:    window->ScrollTargetCenterRatio.y = 0.0f;
        1:12140:    window->ScrollTargetEdgeSnapDist.y = 0.0f;
        1:12141:}
        -:12142:
function _ZN5ImGui10SetScrollXEf called 0 returned 0% blocks executed 0%
    #####:12143:void ImGui::SetScrollX(float scroll_x)
        -:12144:{
    #####:12145:    ImGuiContext& g = *GImGui;
    #####:12146:    SetScrollX(g.CurrentWindow, scroll_x);
    %%%%%:12146-block 2
call    0 never executed
    #####:12147:}
        -:12148:
function _ZN5ImGui10SetScrollYEf called 1 returned 100% blocks executed 100%
        1:12149:void ImGui::SetScrollY(float scroll_y)
        -:12150:{
        1:12151:    ImGuiContext& g = *GImGui;
        1:12152:    SetScrollY(g.CurrentWindow, scroll_y);
        1:12152-block 2
call    0 returned 1
        1:12153:}
        -:12154:
        -:12155:// Note that a local position will vary depending on initial scroll value,
        -:12156:// This is a little bit confusing so bear with us:
        -:12157://  - local_pos = (absolution_pos - window->Pos)
        -:12158://  - So local_x/local_y are 0.0f for a position at the upper-left corner of a window,
        -:12159://    and generally local_x/local_y are >(padding+decoration) && <(size-padding-decoration) when in the visible area.
        -:12160://  - They mostly exist because of legacy API.
        -:12161:// Following the rules above, when trying to work with scrolling code, consider that:
        -:12162://  - SetScrollFromPosY(0.0f) == SetScrollY(0.0f + scroll.y) == has no effect!
        -:12163://  - SetScrollFromPosY(-scroll.y) == SetScrollY(-scroll.y + scroll.y) == SetScrollY(0.0f) == reset scroll. Of course writing SetScrollY(0.0f) directly then makes more sense
        -:12164:// We store a target position so centering and clamping can occur on the next frame when we are guaranteed to have a known window size
function _ZN5ImGui17SetScrollFromPosXEP11ImGuiWindowff called 0 returned 0% blocks executed 0%
    #####:12165:void ImGui::SetScrollFromPosX(ImGuiWindow* window, float local_x, float center_x_ratio)
        -:12166:{
    #####:12167:    IM_ASSERT(center_x_ratio >= 0.0f && center_x_ratio <= 1.0f);
    %%%%%:12167-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12167-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:12167-block 4
    %%%%%:12167-block 5
call    4 never executed
    #####:12168:    window->ScrollTarget.x = IM_TRUNC(local_x - window->DecoOuterSizeX1 - window->DecoInnerSizeX1 + window->Scroll.x); // Convert local position to scroll offset
    #####:12169:    window->ScrollTargetCenterRatio.x = center_x_ratio;
    #####:12170:    window->ScrollTargetEdgeSnapDist.x = 0.0f;
    #####:12171:}
        -:12172:
function _ZN5ImGui17SetScrollFromPosYEP11ImGuiWindowff called 3231 returned 100% blocks executed 80%
     3231:12173:void ImGui::SetScrollFromPosY(ImGuiWindow* window, float local_y, float center_y_ratio)
        -:12174:{
    3231*:12175:    IM_ASSERT(center_y_ratio >= 0.0f && center_y_ratio <= 1.0f);
     3231:12175-block 2
branch  0 taken 3231 (fallthrough)
branch  1 taken 0
     3231:12175-block 3
branch  2 taken 3231 (fallthrough)
branch  3 taken 0
     3231:12175-block 4
    %%%%%:12175-block 5
call    4 never executed
     3231:12176:    window->ScrollTarget.y = IM_TRUNC(local_y - window->DecoOuterSizeY1 - window->DecoInnerSizeY1 + window->Scroll.y); // Convert local position to scroll offset
     3231:12177:    window->ScrollTargetCenterRatio.y = center_y_ratio;
     3231:12178:    window->ScrollTargetEdgeSnapDist.y = 0.0f;
     3231:12179:}
        -:12180:
function _ZN5ImGui17SetScrollFromPosXEff called 0 returned 0% blocks executed 0%
    #####:12181:void ImGui::SetScrollFromPosX(float local_x, float center_x_ratio)
        -:12182:{
    #####:12183:    ImGuiContext& g = *GImGui;
    #####:12184:    SetScrollFromPosX(g.CurrentWindow, local_x, center_x_ratio);
    %%%%%:12184-block 2
call    0 never executed
    #####:12185:}
        -:12186:
function _ZN5ImGui17SetScrollFromPosYEff called 0 returned 0% blocks executed 0%
    #####:12187:void ImGui::SetScrollFromPosY(float local_y, float center_y_ratio)
        -:12188:{
    #####:12189:    ImGuiContext& g = *GImGui;
    #####:12190:    SetScrollFromPosY(g.CurrentWindow, local_y, center_y_ratio);
    %%%%%:12190-block 2
call    0 never executed
    #####:12191:}
        -:12192:
        -:12193:// center_x_ratio: 0.0f left of last item, 0.5f horizontal center of last item, 1.0f right of last item.
function _ZN5ImGui14SetScrollHereXEf called 0 returned 0% blocks executed 0%
    #####:12194:void ImGui::SetScrollHereX(float center_x_ratio)
        -:12195:{
    #####:12196:    ImGuiContext& g = *GImGui;
    #####:12197:    ImGuiWindow* window = g.CurrentWindow;
    #####:12198:    float spacing_x = ImMax(window->WindowPadding.x, g.Style.ItemSpacing.x);
    %%%%%:12198-block 2
call    0 never executed
    #####:12199:    float target_pos_x = ImLerp(g.LastItemData.Rect.Min.x - spacing_x, g.LastItemData.Rect.Max.x + spacing_x, center_x_ratio);
call    0 never executed
    #####:12200:    SetScrollFromPosX(window, target_pos_x - window->Pos.x, center_x_ratio); // Convert from absolute to local pos
call    0 never executed
        -:12201:
        -:12202:    // Tweak: snap on edges when aiming at an item very close to the edge
    #####:12203:    window->ScrollTargetEdgeSnapDist.x = ImMax(0.0f, window->WindowPadding.x - spacing_x);
call    0 never executed
    #####:12204:}
        -:12205:
        -:12206:// center_y_ratio: 0.0f top of last item, 0.5f vertical center of last item, 1.0f bottom of last item.
function _ZN5ImGui14SetScrollHereYEf called 3231 returned 100% blocks executed 100%
     3231:12207:void ImGui::SetScrollHereY(float center_y_ratio)
        -:12208:{
     3231:12209:    ImGuiContext& g = *GImGui;
     3231:12210:    ImGuiWindow* window = g.CurrentWindow;
     3231:12211:    float spacing_y = ImMax(window->WindowPadding.y, g.Style.ItemSpacing.y);
     3231:12211-block 2
call    0 returned 3231
     3231:12212:    float target_pos_y = ImLerp(window->DC.CursorPosPrevLine.y - spacing_y, window->DC.CursorPosPrevLine.y + window->DC.PrevLineSize.y + spacing_y, center_y_ratio);
call    0 returned 3231
     3231:12213:    SetScrollFromPosY(window, target_pos_y - window->Pos.y, center_y_ratio); // Convert from absolute to local pos
call    0 returned 3231
        -:12214:
        -:12215:    // Tweak: snap on edges when aiming at an item very close to the edge
     3231:12216:    window->ScrollTargetEdgeSnapDist.y = ImMax(0.0f, window->WindowPadding.y - spacing_y);
call    0 returned 3231
     3231:12217:}
        -:12218:
        -:12219://-----------------------------------------------------------------------------
        -:12220:// [SECTION] TOOLTIPS
        -:12221://-----------------------------------------------------------------------------
        -:12222:
function _ZN5ImGui12BeginTooltipEv called 213 returned 100% blocks executed 100%
      213:12223:bool ImGui::BeginTooltip()
        -:12224:{
      213:12225:    return BeginTooltipEx(ImGuiTooltipFlags_None, ImGuiWindowFlags_None);
      213:12225-block 2
call    0 returned 213
        -:12226:}
        -:12227:
function _ZN5ImGui16BeginItemTooltipEv called 0 returned 0% blocks executed 0%
    #####:12228:bool ImGui::BeginItemTooltip()
        -:12229:{
    #####:12230:    if (!IsItemHovered(ImGuiHoveredFlags_ForTooltip))
    %%%%%:12230-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:12231:        return false;
    %%%%%:12231-block 4
    #####:12232:    return BeginTooltipEx(ImGuiTooltipFlags_None, ImGuiWindowFlags_None);
    %%%%%:12232-block 5
call    0 never executed
        -:12233:}
        -:12234:
function _ZN5ImGui14BeginTooltipExEii called 213 returned 100% blocks executed 39%
      213:12235:bool ImGui::BeginTooltipEx(ImGuiTooltipFlags tooltip_flags, ImGuiWindowFlags extra_window_flags)
        -:12236:{
      213:12237:    ImGuiContext& g = *GImGui;
        -:12238:
     213*:12239:    const bool is_dragdrop_tooltip = g.DragDropWithinSource || g.DragDropWithinTarget;
      213:12239-block 2
branch  0 taken 213 (fallthrough)
branch  1 taken 0
      213:12239-block 3
branch  2 taken 0 (fallthrough)
branch  3 taken 213
    %%%%%:12239-block 4
      213:12239-block 5
      213:12240:    if (is_dragdrop_tooltip)
      213:12240-block 6
branch  0 taken 0 (fallthrough)
branch  1 taken 213
        -:12241:    {
        -:12242:        // Drag and Drop tooltips are positioning differently than other tooltips:
        -:12243:        // - offset visibility to increase visibility around mouse.
        -:12244:        // - never clamp within outer viewport boundary.
        -:12245:        // We call SetNextWindowPos() to enforce position and disable clamping.
        -:12246:        // See FindBestWindowPosForPopup() for positionning logic of other tooltips (not drag and drop ones).
        -:12247:        //ImVec2 tooltip_pos = g.IO.MousePos - g.ActiveIdClickOffset - g.Style.WindowPadding;
    #####:12248:        const bool is_touchscreen = (g.IO.MouseSource == ImGuiMouseSource_TouchScreen);
    #####:12249:        if ((g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasPos) == 0)
    %%%%%:12249-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
        -:12250:        {
    #####:12251:            ImVec2 tooltip_pos = is_touchscreen ? (g.IO.MousePos + TOOLTIP_DEFAULT_OFFSET_TOUCH * g.Style.MouseCursorScale) : (g.IO.MousePos + TOOLTIP_DEFAULT_OFFSET_MOUSE * g.Style.MouseCursorScale);
    %%%%%:12251-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12251-block 9
call    2 never executed
call    3 never executed
    %%%%%:12251-block 11
call    4 never executed
call    5 never executed
    #####:12252:            ImVec2 tooltip_pivot = is_touchscreen ? TOOLTIP_DEFAULT_PIVOT_TOUCH : ImVec2(0.0f, 0.0f);
    %%%%%:12252-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12252-block 14
    %%%%%:12252-block 15
call    2 never executed
    #####:12253:            SetNextWindowPos(tooltip_pos, ImGuiCond_None, tooltip_pivot);
    %%%%%:12253-block 16
call    0 never executed
        -:12254:        }
        -:12255:
    #####:12256:        SetNextWindowBgAlpha(g.Style.Colors[ImGuiCol_PopupBg].w * 0.60f);
    %%%%%:12256-block 18
call    0 never executed
        -:12257:        //PushStyleVar(ImGuiStyleVar_Alpha, g.Style.Alpha * 0.60f); // This would be nice but e.g ColorButton with checkboard has issue with transparent colors :(
    #####:12258:        tooltip_flags |= ImGuiTooltipFlags_OverridePrevious;
        -:12259:    }
        -:12260:
     213*:12261:    const char* window_name_template = is_dragdrop_tooltip ? "##Tooltip_DragDrop_%02d" : "##Tooltip_%02d";
      213:12261-block 20
branch  0 taken 0 (fallthrough)
branch  1 taken 213
    %%%%%:12261-block 21
      213:12261-block 22
        -:12262:    char window_name[32];
      213:12263:    ImFormatString(window_name, IM_ARRAYSIZE(window_name), window_name_template, g.TooltipOverrideCount);
      213:12263-block 23
call    0 returned 213
     213*:12264:    if ((tooltip_flags & ImGuiTooltipFlags_OverridePrevious) && g.TooltipPreviousWindow != NULL && g.TooltipPreviousWindow->Active)
branch  0 taken 0 (fallthrough)
branch  1 taken 213
    %%%%%:12264-block 25
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:12264-block 26
branch  4 never executed (fallthrough)
branch  5 never executed
        -:12265:    {
        -:12266:        // Hide previous tooltip from being displayed. We can't easily "reset" the content of a window so we create a new one.
        -:12267:        //IMGUI_DEBUG_LOG("[tooltip] '%s' already active, using +1 for this frame\n", window_name);
    #####:12268:        SetWindowHiddenAndSkipItemsForCurrentFrame(g.TooltipPreviousWindow);
    %%%%%:12268-block 27
call    0 never executed
    #####:12269:        ImFormatString(window_name, IM_ARRAYSIZE(window_name), window_name_template, ++g.TooltipOverrideCount);
call    0 never executed
        -:12270:    }
        -:12271:
      213:12272:    ImGuiWindowFlags flags = ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoDocking;
      213:12273:    Begin(window_name, NULL, flags | extra_window_flags);
      213:12273-block 29
call    0 returned 213
branch  1 taken 213 (fallthrough)
branch  2 taken 0 (throw)
        -:12274:    // 2023-03-09: Added bool return value to the API, but currently always returning true.
        -:12275:    // If this ever returns false we need to update BeginDragDropSource() accordingly.
        -:12276:    //if (!ret)
        -:12277:    //    End();
        -:12278:    //return ret;
      213:12279:    return true;
      213:12279-block 30
      213:12279-block 31
        -:12280:}
        -:12281:
function _ZN5ImGui10EndTooltipEv called 213 returned 100% blocks executed 80%
      213:12282:void ImGui::EndTooltip()
        -:12283:{
     213*:12284:    IM_ASSERT(GetCurrentWindowRead()->Flags & ImGuiWindowFlags_Tooltip);   // Mismatched BeginTooltip()/EndTooltip() calls
      213:12284-block 2
call    0 returned 213
branch  1 taken 0 (fallthrough)
branch  2 taken 213
    %%%%%:12284-block 4
call    3 never executed
      213:12285:    End();
      213:12285-block 5
call    0 returned 213
      213:12286:}
        -:12287:
function _ZN5ImGui10SetTooltipEPKcz called 0 returned 0% blocks executed 0%
    #####:12288:void ImGui::SetTooltip(const char* fmt, ...)
        -:12289:{
        -:12290:    va_list args;
    #####:12291:    va_start(args, fmt);
    #####:12292:    SetTooltipV(fmt, args);
    %%%%%:12292-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:12293:    va_end(args);
    #####:12294:}
    %%%%%:12294-block 3
        -:12295:
function _ZN5ImGui11SetTooltipVEPKcP13__va_list_tag called 0 returned 0% blocks executed 0%
    #####:12296:void ImGui::SetTooltipV(const char* fmt, va_list args)
        -:12297:{
    #####:12298:    if (!BeginTooltipEx(ImGuiTooltipFlags_OverridePrevious, ImGuiWindowFlags_None))
    %%%%%:12298-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:12299:        return;
    %%%%%:12299-block 4
    #####:12300:    TextV(fmt, args);
    %%%%%:12300-block 5
call    0 never executed
    #####:12301:    EndTooltip();
call    0 never executed
        -:12302:}
        -:12303:
        -:12304:// Shortcut to use 'style.HoverFlagsForTooltipMouse' or 'style.HoverFlagsForTooltipNav'.
        -:12305:// Defaults to == ImGuiHoveredFlags_Stationary | ImGuiHoveredFlags_DelayShort when using the mouse.
function _ZN5ImGui14SetItemTooltipEPKcz called 0 returned 0% blocks executed 0%
    #####:12306:void ImGui::SetItemTooltip(const char* fmt, ...)
        -:12307:{
        -:12308:    va_list args;
    #####:12309:    va_start(args, fmt);
    #####:12310:    if (IsItemHovered(ImGuiHoveredFlags_ForTooltip))
    %%%%%:12310-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:12310-block 3
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:12311:        SetTooltipV(fmt, args);
    %%%%%:12311-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:12312:    va_end(args);
    #####:12313:}
    %%%%%:12313-block 5
        -:12314:
function _ZN5ImGui15SetItemTooltipVEPKcP13__va_list_tag called 0 returned 0% blocks executed 0%
    #####:12315:void ImGui::SetItemTooltipV(const char* fmt, va_list args)
        -:12316:{
    #####:12317:    if (IsItemHovered(ImGuiHoveredFlags_ForTooltip))
    %%%%%:12317-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:12318:        SetTooltipV(fmt, args);
    %%%%%:12318-block 4
call    0 never executed
    #####:12319:}
        -:12320:
        -:12321:
        -:12322://-----------------------------------------------------------------------------
        -:12323:// [SECTION] POPUPS
        -:12324://-----------------------------------------------------------------------------
        -:12325:
        -:12326:// Supported flags: ImGuiPopupFlags_AnyPopupId, ImGuiPopupFlags_AnyPopupLevel
function _ZN5ImGui11IsPopupOpenEji called 35536 returned 100% blocks executed 29%
    35536:12327:bool ImGui::IsPopupOpen(ImGuiID id, ImGuiPopupFlags popup_flags)
        -:12328:{
    35536:12329:    ImGuiContext& g = *GImGui;
    35536:12330:    if (popup_flags & ImGuiPopupFlags_AnyPopupId)
    35536:12330-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 35536
        -:12331:    {
        -:12332:        // Return true if any popup is open at the current BeginPopup() level of the popup stack
        -:12333:        // This may be used to e.g. test for another popups already opened to handle popups priorities at the same level.
    #####:12334:        IM_ASSERT(id == 0);
    %%%%%:12334-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12334-block 4
call    2 never executed
    #####:12335:        if (popup_flags & ImGuiPopupFlags_AnyPopupLevel)
    %%%%%:12335-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:12336:            return g.OpenPopupStack.Size > 0;
    %%%%%:12336-block 6
        -:12337:        else
    #####:12338:            return g.OpenPopupStack.Size > g.BeginPopupStack.Size;
    %%%%%:12338-block 7
        -:12339:    }
        -:12340:    else
        -:12341:    {
    35536:12342:        if (popup_flags & ImGuiPopupFlags_AnyPopupLevel)
    35536:12342-block 8
branch  0 taken 0 (fallthrough)
branch  1 taken 35536
        -:12343:        {
        -:12344:            // Return true if the popup is open anywhere in the popup stack
    #####:12345:            for (ImGuiPopupData& popup_data : g.OpenPopupStack)
    %%%%%:12345-block 9
call    0 never executed
call    1 never executed
    %%%%%:12345-block 13
    %%%%%:12345-block 14
branch  2 never executed
branch  3 never executed (fallthrough)
    #####:12346:                if (popup_data.PopupId == id)
    %%%%%:12346-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:12347:                    return true;
    %%%%%:12347-block 12
    #####:12348:            return false;
    %%%%%:12348-block 15
        -:12349:        }
        -:12350:        else
        -:12351:        {
        -:12352:            // Return true if the popup is open at the current BeginPopup() level of the popup stack (this is the most-common query)
   35536*:12353:            return g.OpenPopupStack.Size > g.BeginPopupStack.Size && g.OpenPopupStack[g.BeginPopupStack.Size].PopupId == id;
    35536:12353-block 16
branch  0 taken 0 (fallthrough)
branch  1 taken 35536
    %%%%%:12353-block 17
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:12353-block 19
    35536:12353-block 20
    35536:12353-block 21
        -:12354:        }
        -:12355:    }
        -:12356:}
        -:12357:
function _ZN5ImGui11IsPopupOpenEPKci called 5380 returned 100% blocks executed 70%
     5380:12358:bool ImGui::IsPopupOpen(const char* str_id, ImGuiPopupFlags popup_flags)
        -:12359:{
     5380:12360:    ImGuiContext& g = *GImGui;
    5380*:12361:    ImGuiID id = (popup_flags & ImGuiPopupFlags_AnyPopupId) ? 0 : g.CurrentWindow->GetID(str_id);
     5380:12361-block 2
branch  0 taken 5380 (fallthrough)
branch  1 taken 0
     5380:12361-block 3
call    2 returned 5380
    %%%%%:12361-block 5
    5380*:12362:    if ((popup_flags & ImGuiPopupFlags_AnyPopupLevel) && id != 0)
     5380:12362-block 6
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    %%%%%:12362-block 7
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:12363:        IM_ASSERT(0 && "Cannot use IsPopupOpen() with a string id and ImGuiPopupFlags_AnyPopupLevel."); // But non-string version is legal and used internally
    %%%%%:12363-block 8
call    0 never executed
     5380:12364:    return IsPopupOpen(id, popup_flags);
     5380:12364-block 9
call    0 returned 5380
        -:12365:}
        -:12366:
        -:12367:// Also see FindBlockingModal(NULL)
function _ZN5ImGui20GetTopMostPopupModalEv called 3231 returned 100% blocks executed 50%
     3231:12368:ImGuiWindow* ImGui::GetTopMostPopupModal()
        -:12369:{
     3231:12370:    ImGuiContext& g = *GImGui;
    3231*:12371:    for (int n = g.OpenPopupStack.Size - 1; n >= 0; n--)
     3231:12371-block 2
    %%%%%:12371-block 6
     3231:12371-block 7
branch  0 taken 0
branch  1 taken 3231 (fallthrough)
    #####:12372:        if (ImGuiWindow* popup = g.OpenPopupStack.Data[n].Window)
    %%%%%:12372-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:12373:            if (popup->Flags & ImGuiWindowFlags_Modal)
    %%%%%:12373-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:12374:                return popup;
    %%%%%:12374-block 5
     3231:12375:    return NULL;
     3231:12375-block 8
        -:12376:}
        -:12377:
        -:12378:// See Demo->Stacked Modal to confirm what this is for.
function _ZN5ImGui30GetTopMostAndVisiblePopupModalEv called 1077 returned 100% blocks executed 31%
     1077:12379:ImGuiWindow* ImGui::GetTopMostAndVisiblePopupModal()
        -:12380:{
     1077:12381:    ImGuiContext& g = *GImGui;
    1077*:12382:    for (int n = g.OpenPopupStack.Size - 1; n >= 0; n--)
     1077:12382-block 2
    %%%%%:12382-block 11
     1077:12382-block 12
branch  0 taken 0
branch  1 taken 1077 (fallthrough)
    #####:12383:        if (ImGuiWindow* popup = g.OpenPopupStack.Data[n].Window)
    %%%%%:12383-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:12384:            if ((popup->Flags & ImGuiWindowFlags_Modal) && IsWindowActiveAndVisible(popup))
    %%%%%:12384-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12384-block 5
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:12384-block 7
    %%%%%:12384-block 8
    %%%%%:12384-block 9
branch  5 never executed (fallthrough)
branch  6 never executed
    #####:12385:                return popup;
    %%%%%:12385-block 10
     1077:12386:    return NULL;
     1077:12386-block 13
        -:12387:}
        -:12388:
function _ZN5ImGui9OpenPopupEPKci called 0 returned 0% blocks executed 0%
    #####:12389:void ImGui::OpenPopup(const char* str_id, ImGuiPopupFlags popup_flags)
        -:12390:{
    #####:12391:    ImGuiContext& g = *GImGui;
    #####:12392:    ImGuiID id = g.CurrentWindow->GetID(str_id);
    %%%%%:12392-block 2
call    0 never executed
    #####:12393:    IMGUI_DEBUG_LOG_POPUP("[popup] OpenPopup(\"%s\" -> 0x%08X)\n", str_id, id);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12393-block 4
call    2 never executed
    #####:12394:    OpenPopupEx(id, popup_flags);
    %%%%%:12394-block 5
call    0 never executed
    #####:12395:}
        -:12396:
function _ZN5ImGui9OpenPopupEji called 0 returned 0% blocks executed 0%
    #####:12397:void ImGui::OpenPopup(ImGuiID id, ImGuiPopupFlags popup_flags)
        -:12398:{
    #####:12399:    OpenPopupEx(id, popup_flags);
    %%%%%:12399-block 2
call    0 never executed
    #####:12400:}
        -:12401:
        -:12402:// Mark popup as open (toggle toward open state).
        -:12403:// Popups are closed when user click outside, or activate a pressable item, or CloseCurrentPopup() is called within a BeginPopup()/EndPopup() block.
        -:12404:// Popup identifiers are relative to the current ID-stack (so OpenPopup and BeginPopup needs to be at the same level).
        -:12405:// One open popup per level of the popup hierarchy (NB: when assigning we reset the Window member of ImGuiPopupRef to NULL)
function _ZN5ImGui11OpenPopupExEji called 0 returned 0% blocks executed 0%
    #####:12406:void ImGui::OpenPopupEx(ImGuiID id, ImGuiPopupFlags popup_flags)
        -:12407:{
    #####:12408:    ImGuiContext& g = *GImGui;
    #####:12409:    ImGuiWindow* parent_window = g.CurrentWindow;
    #####:12410:    const int current_stack_size = g.BeginPopupStack.Size;
        -:12411:
    #####:12412:    if (popup_flags & ImGuiPopupFlags_NoOpenOverExistingPopup)
    %%%%%:12412-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:12413:        if (IsPopupOpen((ImGuiID)0, ImGuiPopupFlags_AnyPopupId))
    %%%%%:12413-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:12413-block 4
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:12414:            return;
    %%%%%:12414-block 5
        -:12415:
    #####:12416:    ImGuiPopupData popup_ref; // Tagged as new ref as Window will be set back to NULL if we write this into OpenPopupStack.
    %%%%%:12416-block 6
call    0 never executed
    #####:12417:    popup_ref.PopupId = id;
    #####:12418:    popup_ref.Window = NULL;
    #####:12419:    popup_ref.RestoreNavWindow = g.NavWindow;           // When popup closes focus may be restored to NavWindow (depend on window type).
    #####:12420:    popup_ref.OpenFrameCount = g.FrameCount;
    #####:12421:    popup_ref.OpenParentId = parent_window->IDStack.back();
call    0 never executed
    #####:12422:    popup_ref.OpenPopupPos = NavCalcPreferredRefPos();
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:12423:    popup_ref.OpenMousePos = IsMousePosValid(&g.IO.MousePos) ? g.IO.MousePos : popup_ref.OpenPopupPos;
    %%%%%:12423-block 9
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:12423-block 11
    %%%%%:12423-block 12
        -:12424:
    #####:12425:    IMGUI_DEBUG_LOG_POPUP("[popup] OpenPopupEx(0x%08X)\n", id);
    %%%%%:12425-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12425-block 14
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####:12426:    if (g.OpenPopupStack.Size < current_stack_size + 1)
    %%%%%:12426-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
        -:12427:    {
    #####:12428:        g.OpenPopupStack.push_back(popup_ref);
    %%%%%:12428-block 16
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:12429:    }
        -:12430:    else
        -:12431:    {
        -:12432:        // Gently handle the user mistakenly calling OpenPopup() every frames: it is likely a programming mistake!
        -:12433:        // However, if we were to run the regular code path, the ui would become completely unusable because the popup will always be
        -:12434:        // in hidden-while-calculating-size state _while_ claiming focus. Which is extremely confusing situation for the programmer.
        -:12435:        // Instead, for successive frames calls to OpenPopup(), we silently avoid reopening even if ImGuiPopupFlags_NoReopen is not specified.
    #####:12436:        bool keep_existing = false;
    #####:12437:        if (g.OpenPopupStack[current_stack_size].PopupId == id)
    %%%%%:12437-block 17
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:12438:            if ((g.OpenPopupStack[current_stack_size].OpenFrameCount == g.FrameCount - 1) || (popup_flags & ImGuiPopupFlags_NoReopen))
    %%%%%:12438-block 19
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:12438-block 21
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:12438-block 22
    %%%%%:12438-block 23
    %%%%%:12438-block 24
branch  5 never executed (fallthrough)
branch  6 never executed
    #####:12439:                keep_existing = true;
    %%%%%:12439-block 25
    #####:12440:        if (keep_existing)
    %%%%%:12440-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
        -:12441:        {
        -:12442:            // No reopen
    #####:12443:            g.OpenPopupStack[current_stack_size].OpenFrameCount = popup_ref.OpenFrameCount;
    %%%%%:12443-block 27
call    0 never executed
        -:12444:        }
        -:12445:        else
        -:12446:        {
        -:12447:            // Reopen: close child popups if any, then flag popup for open/reopen (set position, focus, init navigation)
    #####:12448:            ClosePopupToLevel(current_stack_size, true);
    %%%%%:12448-block 29
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:12449:            g.OpenPopupStack.push_back(popup_ref);
    %%%%%:12449-block 30
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:12450:        }
        -:12451:
        -:12452:        // When reopening a popup we first refocus its parent, otherwise if its parent is itself a popup it would get closed by ClosePopupsOverWindow().
        -:12453:        // This is equivalent to what ClosePopupToLevel() does.
        -:12454:        //if (g.OpenPopupStack[current_stack_size].PopupId == id)
        -:12455:        //    FocusWindow(parent_window);
        -:12456:    }
        -:12457:}
        -:12458:
        -:12459:// When popups are stacked, clicking on a lower level popups puts focus back to it and close popups above it.
        -:12460:// This function closes any popups that are over 'ref_window'.
function _ZN5ImGui21ClosePopupsOverWindowEP11ImGuiWindowb called 11 returned 100% blocks executed 10%
       11:12461:void ImGui::ClosePopupsOverWindow(ImGuiWindow* ref_window, bool restore_focus_to_window_under_popup)
        -:12462:{
       11:12463:    ImGuiContext& g = *GImGui;
       11:12464:    if (g.OpenPopupStack.Size == 0)
       11:12464-block 2
branch  0 taken 11 (fallthrough)
branch  1 taken 0
       11:12465:        return;
       11:12465-block 3
        -:12466:
        -:12467:    // Don't close our own child popup windows.
        -:12468:    //IMGUI_DEBUG_LOG_POPUP("[popup] ClosePopupsOverWindow(\"%s\") restore_under=%d\n", ref_window ? ref_window->Name : "<NULL>", restore_focus_to_window_under_popup);
    #####:12469:    int popup_count_to_keep = 0;
    #####:12470:    if (ref_window)
    %%%%%:12470-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
        -:12471:    {
        -:12472:        // Find the highest popup which is a descendant of the reference window (generally reference window = NavWindow)
    #####:12473:        for (; popup_count_to_keep < g.OpenPopupStack.Size; popup_count_to_keep++)
    %%%%%:12473-block 5
    %%%%%:12473-block 21
    %%%%%:12473-block 22
branch  0 never executed
branch  1 never executed (fallthrough)
        -:12474:        {
    #####:12475:            ImGuiPopupData& popup = g.OpenPopupStack[popup_count_to_keep];
    %%%%%:12475-block 6
call    0 never executed
    #####:12476:            if (!popup.Window)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:12477:                continue;
    %%%%%:12477-block 8
    #####:12478:            IM_ASSERT((popup.Window->Flags & ImGuiWindowFlags_Popup) != 0);
    %%%%%:12478-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12478-block 10
call    2 never executed
        -:12479:
        -:12480:            // Trim the stack unless the popup is a direct parent of the reference window (the reference window is often the NavWindow)
        -:12481:            // - Clicking/Focusing Window2 won't close Popup1:
        -:12482:            //     Window -> Popup1 -> Window2(Ref)
        -:12483:            // - Clicking/focusing Popup1 will close Popup2 and Popup3:
        -:12484:            //     Window -> Popup1(Ref) -> Popup2 -> Popup3
        -:12485:            // - Each popups may contain child windows, which is why we compare ->RootWindowDockTree!
        -:12486:            //     Window -> Popup1 -> Popup1_Child -> Popup2 -> Popup2_Child
        -:12487:            // We step through every popup from bottom to top to validate their position relative to reference window.
    #####:12488:            bool ref_window_is_descendent_of_popup = false;
    #####:12489:            for (int n = popup_count_to_keep; n < g.OpenPopupStack.Size; n++)
    %%%%%:12489-block 11
    %%%%%:12489-block 17
    %%%%%:12489-block 18
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:12490:                if (ImGuiWindow* popup_window = g.OpenPopupStack[n].Window)
    %%%%%:12490-block 12
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -:12491:                    //if (popup_window->RootWindowDockTree == ref_window->RootWindowDockTree) // FIXME-MERGE
    #####:12492:                    if (IsWindowWithinBeginStackOf(ref_window, popup_window))
    %%%%%:12492-block 14
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -:12493:                    {
    #####:12494:                        ref_window_is_descendent_of_popup = true;
    #####:12495:                        break;
    %%%%%:12495-block 16
        -:12496:                    }
    #####:12497:            if (!ref_window_is_descendent_of_popup)
    %%%%%:12497-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:12498:                break;
    %%%%%:12498-block 20
        -:12499:        }
        -:12500:    }
    #####:12501:    if (popup_count_to_keep < g.OpenPopupStack.Size) // This test is not required but it allows to set a convenient breakpoint on the statement below
    %%%%%:12501-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
        -:12502:    {
    #####:12503:        IMGUI_DEBUG_LOG_POPUP("[popup] ClosePopupsOverWindow(\"%s\")\n", ref_window ? ref_window->Name : "<NULL>");
    %%%%%:12503-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12503-block 26
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:12503-block 27
    %%%%%:12503-block 28
    %%%%%:12503-block 29
call    4 never executed
    #####:12504:        ClosePopupToLevel(popup_count_to_keep, restore_focus_to_window_under_popup);
    %%%%%:12504-block 30
call    0 never executed
        -:12505:    }
        -:12506:}
        -:12507:
function _ZN5ImGui23ClosePopupsExceptModalsEv called 0 returned 0% blocks executed 0%
    #####:12508:void ImGui::ClosePopupsExceptModals()
        -:12509:{
    #####:12510:    ImGuiContext& g = *GImGui;
        -:12511:
        -:12512:    int popup_count_to_keep;
    #####:12513:    for (popup_count_to_keep = g.OpenPopupStack.Size; popup_count_to_keep > 0; popup_count_to_keep--)
    %%%%%:12513-block 2
    %%%%%:12513-block 6
    %%%%%:12513-block 7
branch  0 never executed
branch  1 never executed (fallthrough)
        -:12514:    {
    #####:12515:        ImGuiWindow* window = g.OpenPopupStack[popup_count_to_keep - 1].Window;
    %%%%%:12515-block 3
call    0 never executed
    #####:12516:        if (!window || (window->Flags & ImGuiWindowFlags_Modal))
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12516-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
        -:12517:            break;
        -:12518:    }
    #####:12519:    if (popup_count_to_keep < g.OpenPopupStack.Size) // This test is not required but it allows to set a convenient breakpoint on the statement below
    %%%%%:12519-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:12520:        ClosePopupToLevel(popup_count_to_keep, true);
    %%%%%:12520-block 9
call    0 never executed
    #####:12521:}
        -:12522:
function _ZN5ImGui17ClosePopupToLevelEib called 0 returned 0% blocks executed 0%
    #####:12523:void ImGui::ClosePopupToLevel(int remaining, bool restore_focus_to_window_under_popup)
        -:12524:{
    #####:12525:    ImGuiContext& g = *GImGui;
    #####:12526:    IMGUI_DEBUG_LOG_POPUP("[popup] ClosePopupToLevel(%d), restore_under=%d\n", remaining, restore_focus_to_window_under_popup);
    %%%%%:12526-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12526-block 3
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####:12527:    IM_ASSERT(remaining >= 0 && remaining < g.OpenPopupStack.Size);
    %%%%%:12527-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12527-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:12527-block 6
    %%%%%:12527-block 7
call    4 never executed
    #####:12528:    if (g.DebugLogFlags & ImGuiDebugLogFlags_EventPopup)
    %%%%%:12528-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:12529:        for (int n = remaining; n < g.OpenPopupStack.Size; n++)
    %%%%%:12529-block 9
    %%%%%:12529-block 18
    %%%%%:12529-block 19
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:12530:            IMGUI_DEBUG_LOG_POPUP("[popup] - Closing PopupID 0x%08X Window \"%s\"\n", g.OpenPopupStack[n].PopupId, g.OpenPopupStack[n].Window ? g.OpenPopupStack[n].Window->Name : NULL);
    %%%%%:12530-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12530-block 11
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:12530-block 13
call    5 never executed
    %%%%%:12530-block 15
    %%%%%:12530-block 16
call    6 never executed
call    7 never executed
branch  8 never executed (fallthrough)
branch  9 never executed (throw)
        -:12531:
        -:12532:    // Trim open popup stack
    #####:12533:    ImGuiPopupData prev_popup = g.OpenPopupStack[remaining];
    %%%%%:12533-block 20
call    0 never executed
    #####:12534:    g.OpenPopupStack.resize(remaining);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:12535:
        -:12536:    // Restore focus (unless popup window was not yet submitted, and didn't have a chance to take focus anyhow. See #7325 for an edge case)
    #####:12537:    if (restore_focus_to_window_under_popup && prev_popup.Window)
    %%%%%:12537-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12537-block 23
branch  2 never executed (fallthrough)
branch  3 never executed
        -:12538:    {
    #####:12539:        ImGuiWindow* popup_window = prev_popup.Window;
    #####:12540:        ImGuiWindow* focus_window = (popup_window->Flags & ImGuiWindowFlags_ChildMenu) ? popup_window->ParentWindow : prev_popup.RestoreNavWindow;
    %%%%%:12540-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12540-block 25
    %%%%%:12540-block 26
    #####:12541:        if (focus_window && !focus_window->WasActive)
    %%%%%:12541-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12541-block 28
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:12542:            FocusTopMostWindowUnderOne(popup_window, NULL, NULL, ImGuiFocusRequestFlags_RestoreFocusedChild); // Fallback
    %%%%%:12542-block 29
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:12543:        else
    #####:12544:            FocusWindow(focus_window, (g.NavLayer == ImGuiNavLayer_Main) ? ImGuiFocusRequestFlags_RestoreFocusedChild : ImGuiFocusRequestFlags_None);
    %%%%%:12544-block 31
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12544-block 32
    %%%%%:12544-block 33
    %%%%%:12544-block 34
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
        -:12545:    }
    #####:12546:}
    %%%%%:12546-block 36
        -:12547:
        -:12548:// Close the popup we have begin-ed into.
function _ZN5ImGui17CloseCurrentPopupEv called 0 returned 0% blocks executed 0%
    #####:12549:void ImGui::CloseCurrentPopup()
        -:12550:{
    #####:12551:    ImGuiContext& g = *GImGui;
    #####:12552:    int popup_idx = g.BeginPopupStack.Size - 1;
    #####:12553:    if (popup_idx < 0 || popup_idx >= g.OpenPopupStack.Size || g.BeginPopupStack[popup_idx].PopupId != g.OpenPopupStack[popup_idx].PopupId)
    %%%%%:12553-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12553-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:12553-block 4
call    4 never executed
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%:12553-block 7
    %%%%%:12553-block 8
    %%%%%:12553-block 9
branch  8 never executed (fallthrough)
branch  9 never executed
    #####:12554:        return;
    %%%%%:12554-block 10
        -:12555:
        -:12556:    // Closing a menu closes its top-most parent popup (unless a modal)
    #####:12557:    while (popup_idx > 0)
    %%%%%:12557-block 11
    %%%%%:12557-block 22
branch  0 never executed
branch  1 never executed (fallthrough)
        -:12558:    {
    #####:12559:        ImGuiWindow* popup_window = g.OpenPopupStack[popup_idx].Window;
    %%%%%:12559-block 12
call    0 never executed
    #####:12560:        ImGuiWindow* parent_popup_window = g.OpenPopupStack[popup_idx - 1].Window;
call    0 never executed
    #####:12561:        bool close_parent = false;
    #####:12562:        if (popup_window && (popup_window->Flags & ImGuiWindowFlags_ChildMenu))
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12562-block 15
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:12563:            if (parent_popup_window && !(parent_popup_window->Flags & ImGuiWindowFlags_MenuBar))
    %%%%%:12563-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12563-block 17
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:12564:                close_parent = true;
    %%%%%:12564-block 18
    #####:12565:        if (!close_parent)
    %%%%%:12565-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:12566:            break;
    %%%%%:12566-block 20
    #####:12567:        popup_idx--;
    %%%%%:12567-block 21
        -:12568:    }
    #####:12569:    IMGUI_DEBUG_LOG_POPUP("[popup] CloseCurrentPopup %d -> %d\n", g.BeginPopupStack.Size - 1, popup_idx);
    %%%%%:12569-block 23
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12569-block 24
call    2 never executed
    #####:12570:    ClosePopupToLevel(popup_idx, true);
    %%%%%:12570-block 25
call    0 never executed
        -:12571:
        -:12572:    // A common pattern is to close a popup when selecting a menu item/selectable that will open another window.
        -:12573:    // To improve this usage pattern, we avoid nav highlight for a single frame in the parent window.
        -:12574:    // Similarly, we could avoid mouse hover highlight in this window but it is less visually problematic.
    #####:12575:    if (ImGuiWindow* window = g.NavWindow)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:12576:        window->DC.NavHideHighlightOneFrame = true;
    %%%%%:12576-block 27
        -:12577:}
        -:12578:
        -:12579:// Attention! BeginPopup() adds default flags when calling BeginPopupEx()!
function _ZN5ImGui12BeginPopupExEji called 26925 returned 100% blocks executed 50%
    26925:12580:bool ImGui::BeginPopupEx(ImGuiID id, ImGuiWindowFlags extra_window_flags)
        -:12581:{
    26925:12582:    ImGuiContext& g = *GImGui;
    26925:12583:    if (!IsPopupOpen(id, ImGuiPopupFlags_None))
    26925:12583-block 2
call    0 returned 26925
branch  1 taken 26925 (fallthrough)
branch  2 taken 0 (throw)
    26925:12583-block 3
branch  3 taken 26925 (fallthrough)
branch  4 taken 0
        -:12584:    {
    26925:12585:        g.NextWindowData.ClearFlags(); // We behave like Begin() and need to consume those values
    26925:12585-block 4
call    0 returned 26925
    26925:12586:        return false;
        -:12587:    }
        -:12588:
        -:12589:    char name[20];
    #####:12590:    if (extra_window_flags & ImGuiWindowFlags_ChildMenu)
    %%%%%:12590-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:12591:        ImFormatString(name, IM_ARRAYSIZE(name), "##Menu_%02d", g.BeginMenuDepth); // Recycle windows based on depth
    %%%%%:12591-block 7
call    0 never executed
        -:12592:    else
    #####:12593:        ImFormatString(name, IM_ARRAYSIZE(name), "##Popup_%08x", id); // Not recycling, so we can close/open during the same frame
    %%%%%:12593-block 8
call    0 never executed
        -:12594:
    #####:12595:    bool is_open = Begin(name, NULL, extra_window_flags | ImGuiWindowFlags_Popup | ImGuiWindowFlags_NoDocking);
    %%%%%:12595-block 9
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:12596:    if (!is_open) // NB: Begin can return false when the popup is completely clipped (e.g. zero size display)
    %%%%%:12596-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:12597:        EndPopup();
    %%%%%:12597-block 11
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:12598:
        -:12599:    //g.CurrentWindow->FocusRouteParentWindow = g.CurrentWindow->ParentWindowInBeginStack;
        -:12600:
    #####:12601:    return is_open;
    %%%%%:12601-block 12
        -:12602:}
        -:12603:
function _ZN5ImGui10BeginPopupEPKci called 2154 returned 100% blocks executed 57%
     2154:12604:bool ImGui::BeginPopup(const char* str_id, ImGuiWindowFlags flags)
        -:12605:{
     2154:12606:    ImGuiContext& g = *GImGui;
     2154:12607:    if (g.OpenPopupStack.Size <= g.BeginPopupStack.Size) // Early out for performance
     2154:12607-block 2
branch  0 taken 2154 (fallthrough)
branch  1 taken 0
        -:12608:    {
     2154:12609:        g.NextWindowData.ClearFlags(); // We behave like Begin() and need to consume those values
     2154:12609-block 3
call    0 returned 2154
     2154:12610:        return false;
        -:12611:    }
    #####:12612:    flags |= ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings;
    #####:12613:    ImGuiID id = g.CurrentWindow->GetID(str_id);
    %%%%%:12613-block 5
call    0 never executed
    #####:12614:    return BeginPopupEx(id, flags);
call    0 never executed
        -:12615:}
        -:12616:
        -:12617:// If 'p_open' is specified for a modal popup window, the popup will have a regular close button which will close the popup.
        -:12618:// Note that popup visibility status is owned by Dear ImGui (and manipulated with e.g. OpenPopup).
        -:12619:// - *p_open set back to false in BeginPopupModal() when popup is not open.
        -:12620:// - if you set *p_open to false before calling BeginPopupModal(), it will close the popup.
function _ZN5ImGui15BeginPopupModalEPKcPbi called 0 returned 0% blocks executed 0%
    #####:12621:bool ImGui::BeginPopupModal(const char* name, bool* p_open, ImGuiWindowFlags flags)
        -:12622:{
    #####:12623:    ImGuiContext& g = *GImGui;
    #####:12624:    ImGuiWindow* window = g.CurrentWindow;
    #####:12625:    const ImGuiID id = window->GetID(name);
    %%%%%:12625-block 2
call    0 never executed
    #####:12626:    if (!IsPopupOpen(id, ImGuiPopupFlags_None))
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -:12627:    {
    #####:12628:        g.NextWindowData.ClearFlags(); // We behave like Begin() and need to consume those values
    %%%%%:12628-block 5
call    0 never executed
    #####:12629:        if (p_open && *p_open)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12629-block 7
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:12630:            *p_open = false;
    %%%%%:12630-block 8
    #####:12631:        return false;
    %%%%%:12631-block 9
        -:12632:    }
        -:12633:
        -:12634:    // Center modal windows by default for increased visibility
        -:12635:    // (this won't really last as settings will kick in, and is mostly for backward compatibility. user may do the same themselves)
        -:12636:    // FIXME: Should test for (PosCond & window->SetWindowPosAllowFlags) with the upcoming window.
    #####:12637:    if ((g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasPos) == 0)
    %%%%%:12637-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
        -:12638:    {
    #####:12639:        const ImGuiViewport* viewport = window->WasActive ? window->Viewport : GetMainViewport(); // FIXME-VIEWPORT: What may be our reference viewport?
    %%%%%:12639-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12639-block 12
    %%%%%:12639-block 13
call    2 never executed
    #####:12640:        SetNextWindowPos(viewport->GetCenter(), ImGuiCond_FirstUseEver, ImVec2(0.5f, 0.5f));
    %%%%%:12640-block 15
call    0 never executed
call    1 never executed
call    2 never executed
        -:12641:    }
        -:12642:
    #####:12643:    flags |= ImGuiWindowFlags_Popup | ImGuiWindowFlags_Modal | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoDocking;
    #####:12644:    const bool is_open = Begin(name, p_open, flags);
    %%%%%:12644-block 19
call    0 never executed
    #####:12645:    if (!is_open || (p_open && !*p_open)) // NB: is_open can be 'false' when the popup is completely clipped (e.g. zero size display)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12645-block 21
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:12645-block 22
branch  4 never executed (fallthrough)
branch  5 never executed
        -:12646:    {
    #####:12647:        EndPopup();
    %%%%%:12647-block 23
call    0 never executed
    #####:12648:        if (is_open)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:12649:            ClosePopupToLevel(g.BeginPopupStack.Size, true);
    %%%%%:12649-block 25
call    0 never executed
    #####:12650:        return false;
    %%%%%:12650-block 26
        -:12651:    }
    #####:12652:    return is_open;
    %%%%%:12652-block 27
        -:12653:}
        -:12654:
function _ZN5ImGui8EndPopupEv called 0 returned 0% blocks executed 0%
    #####:12655:void ImGui::EndPopup()
        -:12656:{
    #####:12657:    ImGuiContext& g = *GImGui;
    #####:12658:    ImGuiWindow* window = g.CurrentWindow;
    #####:12659:    IM_ASSERT(window->Flags & ImGuiWindowFlags_Popup);  // Mismatched BeginPopup()/EndPopup() calls
    %%%%%:12659-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12659-block 3
call    2 never executed
    #####:12660:    IM_ASSERT(g.BeginPopupStack.Size > 0);
    %%%%%:12660-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12660-block 5
call    2 never executed
        -:12661:
        -:12662:    // Make all menus and popups wrap around for now, may need to expose that policy (e.g. focus scope could include wrap/loop policy flags used by new move requests)
    #####:12663:    if (g.NavWindow == window)
    %%%%%:12663-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:12664:        NavMoveRequestTryWrapping(window, ImGuiNavMoveFlags_LoopY);
    %%%%%:12664-block 7
call    0 never executed
        -:12665:
        -:12666:    // Child-popups don't need to be laid out
    #####:12667:    IM_ASSERT(g.WithinEndChild == false);
    %%%%%:12667-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12667-block 9
call    2 never executed
    #####:12668:    if (window->Flags & ImGuiWindowFlags_ChildWindow)
    %%%%%:12668-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:12669:        g.WithinEndChild = true;
    %%%%%:12669-block 11
    #####:12670:    End();
    %%%%%:12670-block 12
call    0 never executed
    #####:12671:    g.WithinEndChild = false;
    #####:12672:}
        -:12673:
        -:12674:// Helper to open a popup if mouse button is released over the item
        -:12675:// - This is essentially the same as BeginPopupContextItem() but without the trailing BeginPopup()
function _ZN5ImGui20OpenPopupOnItemClickEPKci called 0 returned 0% blocks executed 0%
    #####:12676:void ImGui::OpenPopupOnItemClick(const char* str_id, ImGuiPopupFlags popup_flags)
        -:12677:{
    #####:12678:    ImGuiContext& g = *GImGui;
    #####:12679:    ImGuiWindow* window = g.CurrentWindow;
    #####:12680:    int mouse_button = (popup_flags & ImGuiPopupFlags_MouseButtonMask_);
    #####:12681:    if (IsMouseReleased(mouse_button) && IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))
    %%%%%:12681-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:12681-block 4
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:12681-block 6
    %%%%%:12681-block 7
    %%%%%:12681-block 8
branch  6 never executed (fallthrough)
branch  7 never executed
        -:12682:    {
    #####:12683:        ImGuiID id = str_id ? window->GetID(str_id) : g.LastItemData.ID;    // If user hasn't passed an ID, we can use the LastItemID. Using LastItemID as a Popup ID won't conflict!
    %%%%%:12683-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12683-block 10
call    2 never executed
    %%%%%:12683-block 12
    #####:12684:        IM_ASSERT(id != 0);                                             // You cannot pass a NULL str_id if the last item has no identifier (e.g. a Text() item)
    %%%%%:12684-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12684-block 14
call    2 never executed
    #####:12685:        OpenPopupEx(id, popup_flags);
    %%%%%:12685-block 15
call    0 never executed
        -:12686:    }
    #####:12687:}
        -:12688:
        -:12689:// This is a helper to handle the simplest case of associating one named popup to one given widget.
        -:12690:// - To create a popup associated to the last item, you generally want to pass a NULL value to str_id.
        -:12691:// - To create a popup with a specific identifier, pass it in str_id.
        -:12692://    - This is useful when using using BeginPopupContextItem() on an item which doesn't have an identifier, e.g. a Text() call.
        -:12693://    - This is useful when multiple code locations may want to manipulate/open the same popup, given an explicit id.
        -:12694:// - You may want to handle the whole on user side if you have specific needs (e.g. tweaking IsItemHovered() parameters).
        -:12695://   This is essentially the same as:
        -:12696://       id = str_id ? GetID(str_id) : GetItemID();
        -:12697://       OpenPopupOnItemClick(str_id, ImGuiPopupFlags_MouseButtonRight);
        -:12698://       return BeginPopup(id);
        -:12699://   Which is essentially the same as:
        -:12700://       id = str_id ? GetID(str_id) : GetItemID();
        -:12701://       if (IsItemHovered() && IsMouseReleased(ImGuiMouseButton_Right))
        -:12702://           OpenPopup(id);
        -:12703://       return BeginPopup(id);
        -:12704://   The main difference being that this is tweaked to avoid computing the ID twice.
function _ZN5ImGui21BeginPopupContextItemEPKci called 26925 returned 100% blocks executed 63%
    26925:12705:bool ImGui::BeginPopupContextItem(const char* str_id, ImGuiPopupFlags popup_flags)
        -:12706:{
    26925:12707:    ImGuiContext& g = *GImGui;
    26925:12708:    ImGuiWindow* window = g.CurrentWindow;
    26925:12709:    if (window->SkipItems)
    26925:12709-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 26925
    #####:12710:        return false;
    %%%%%:12710-block 3
   26925*:12711:    ImGuiID id = str_id ? window->GetID(str_id) : g.LastItemData.ID;    // If user hasn't passed an ID, we can use the LastItemID. Using LastItemID as a Popup ID won't conflict!
    26925:12711-block 4
branch  0 taken 26925 (fallthrough)
branch  1 taken 0
    26925:12711-block 5
call    2 returned 26925
    %%%%%:12711-block 7
   26925*:12712:    IM_ASSERT(id != 0);                                             // You cannot pass a NULL str_id if the last item has no identifier (e.g. a Text() item)
    26925:12712-block 8
branch  0 taken 0 (fallthrough)
branch  1 taken 26925
    %%%%%:12712-block 9
call    2 never executed
    26925:12713:    int mouse_button = (popup_flags & ImGuiPopupFlags_MouseButtonMask_);
   26925*:12714:    if (IsMouseReleased(mouse_button) && IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))
    26925:12714-block 10
call    0 returned 26925
branch  1 taken 0 (fallthrough)
branch  2 taken 26925
    %%%%%:12714-block 12
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:12714-block 14
    26925:12714-block 15
    26925:12714-block 16
branch  6 taken 0 (fallthrough)
branch  7 taken 26925
    #####:12715:        OpenPopupEx(id, popup_flags);
    %%%%%:12715-block 17
call    0 never executed
    26925:12716:    return BeginPopupEx(id, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings);
    26925:12716-block 18
call    0 returned 26925
        -:12717:}
        -:12718:
function _ZN5ImGui23BeginPopupContextWindowEPKci called 0 returned 0% blocks executed 0%
    #####:12719:bool ImGui::BeginPopupContextWindow(const char* str_id, ImGuiPopupFlags popup_flags)
        -:12720:{
    #####:12721:    ImGuiContext& g = *GImGui;
    #####:12722:    ImGuiWindow* window = g.CurrentWindow;
    #####:12723:    if (!str_id)
    %%%%%:12723-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:12724:        str_id = "window_context";
    %%%%%:12724-block 3
    #####:12725:    ImGuiID id = window->GetID(str_id);
    %%%%%:12725-block 4
call    0 never executed
    #####:12726:    int mouse_button = (popup_flags & ImGuiPopupFlags_MouseButtonMask_);
    #####:12727:    if (IsMouseReleased(mouse_button) && IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:12727-block 7
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:12727-block 9
    %%%%%:12727-block 10
    %%%%%:12727-block 11
branch  6 never executed (fallthrough)
branch  7 never executed
    #####:12728:        if (!(popup_flags & ImGuiPopupFlags_NoOpenOverItems) || !IsAnyItemHovered())
    %%%%%:12728-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12728-block 13
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:12728-block 15
    %%%%%:12728-block 16
    %%%%%:12728-block 17
branch  5 never executed (fallthrough)
branch  6 never executed
    #####:12729:            OpenPopupEx(id, popup_flags);
    %%%%%:12729-block 18
call    0 never executed
    #####:12730:    return BeginPopupEx(id, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings);
    %%%%%:12730-block 19
call    0 never executed
        -:12731:}
        -:12732:
function _ZN5ImGui21BeginPopupContextVoidEPKci called 0 returned 0% blocks executed 0%
    #####:12733:bool ImGui::BeginPopupContextVoid(const char* str_id, ImGuiPopupFlags popup_flags)
        -:12734:{
    #####:12735:    ImGuiContext& g = *GImGui;
    #####:12736:    ImGuiWindow* window = g.CurrentWindow;
    #####:12737:    if (!str_id)
    %%%%%:12737-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:12738:        str_id = "void_context";
    %%%%%:12738-block 3
    #####:12739:    ImGuiID id = window->GetID(str_id);
    %%%%%:12739-block 4
call    0 never executed
    #####:12740:    int mouse_button = (popup_flags & ImGuiPopupFlags_MouseButtonMask_);
    #####:12741:    if (IsMouseReleased(mouse_button) && !IsWindowHovered(ImGuiHoveredFlags_AnyWindow))
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:12741-block 7
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:12741-block 9
    %%%%%:12741-block 10
    %%%%%:12741-block 11
branch  6 never executed (fallthrough)
branch  7 never executed
    #####:12742:        if (GetTopMostPopupModal() == NULL)
    %%%%%:12742-block 12
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:12743:            OpenPopupEx(id, popup_flags);
    %%%%%:12743-block 14
call    0 never executed
    #####:12744:    return BeginPopupEx(id, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings);
    %%%%%:12744-block 15
call    0 never executed
        -:12745:}
        -:12746:
        -:12747:// r_avoid = the rectangle to avoid (e.g. for tooltip it is a rectangle around the mouse cursor which we want to avoid. for popups it's a small point around the cursor.)
        -:12748:// r_outer = the visible area rectangle, minus safe area padding. If our popup size won't fit because of safe area padding we ignore it.
        -:12749:// (r_outer is usually equivalent to the viewport rectangle minus padding, but when multi-viewports are enabled and monitor
        -:12750://  information are available, it may represent the entire platform monitor from the frame of reference of the current viewport.
        -:12751://  this allows us to have tooltips/popups displayed out of the parent viewport.)
function _ZN5ImGui27FindBestWindowPosForPopupExERK6ImVec2S2_P8ImGuiDirRK6ImRectS7_24ImGuiPopupPositionPolicy called 213 returned 100% blocks executed 39%
      213:12752:ImVec2 ImGui::FindBestWindowPosForPopupEx(const ImVec2& ref_pos, const ImVec2& size, ImGuiDir* last_dir, const ImRect& r_outer, const ImRect& r_avoid, ImGuiPopupPositionPolicy policy)
        -:12753:{
      213:12754:    ImVec2 base_pos_clamped = ImClamp(ref_pos, r_outer.Min, r_outer.Max - size);
      213:12754-block 2
call    0 returned 213
call    1 returned 213
        -:12755:    //GetForegroundDrawList()->AddRect(r_avoid.Min, r_avoid.Max, IM_COL32(255,0,0,255));
        -:12756:    //GetForegroundDrawList()->AddRect(r_outer.Min, r_outer.Max, IM_COL32(0,255,0,255));
        -:12757:
        -:12758:    // Combo Box policy (we want a connecting edge)
      213:12759:    if (policy == ImGuiPopupPositionPolicy_ComboBox)
branch  0 taken 0 (fallthrough)
branch  1 taken 213
        -:12760:    {
    #####:12761:        const ImGuiDir dir_prefered_order[ImGuiDir_COUNT] = { ImGuiDir_Down, ImGuiDir_Right, ImGuiDir_Left, ImGuiDir_Up };
    #####:12762:        for (int n = (*last_dir != ImGuiDir_None) ? -1 : 0; n < ImGuiDir_COUNT; n++)
    %%%%%:12762-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12762-block 6
    %%%%%:12762-block 7
    %%%%%:12762-block 8
    %%%%%:12762-block 34
branch  2 never executed
branch  3 never executed (fallthrough)
        -:12763:        {
    #####:12764:            const ImGuiDir dir = (n == -1) ? *last_dir : dir_prefered_order[n];
    %%%%%:12764-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12764-block 10
    %%%%%:12764-block 11
    #####:12765:            if (n != -1 && dir == *last_dir) // Already tried this direction?
    %%%%%:12765-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12765-block 13
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:12766:                continue;
    %%%%%:12766-block 14
    %%%%%:12766-block 33
    #####:12767:            ImVec2 pos;
    #####:12768:            if (dir == ImGuiDir_Down)  pos = ImVec2(r_avoid.Min.x, r_avoid.Max.y);          // Below, Toward Right (default)
    %%%%%:12768-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12768-block 16
call    2 never executed
    #####:12769:            if (dir == ImGuiDir_Right) pos = ImVec2(r_avoid.Min.x, r_avoid.Min.y - size.y); // Above, Toward Right
    %%%%%:12769-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12769-block 19
call    2 never executed
    #####:12770:            if (dir == ImGuiDir_Left)  pos = ImVec2(r_avoid.Max.x - size.x, r_avoid.Max.y); // Below, Toward Left
    %%%%%:12770-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12770-block 22
call    2 never executed
    #####:12771:            if (dir == ImGuiDir_Up)    pos = ImVec2(r_avoid.Max.x - size.x, r_avoid.Min.y - size.y); // Above, Toward Left
    %%%%%:12771-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:12771-block 25
call    2 never executed
    #####:12772:            if (!r_outer.Contains(ImRect(pos, pos + size)))
    %%%%%:12772-block 27
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:12773:                continue;
    %%%%%:12773-block 31
    #####:12774:            *last_dir = dir;
    #####:12775:            return pos;
    %%%%%:12775-block 32
        -:12776:        }
        -:12777:    }
        -:12778:
        -:12779:    // Tooltip and Default popup policy
        -:12780:    // (Always first try the direction we used on the last frame, if any)
     213*:12781:    if (policy == ImGuiPopupPositionPolicy_Tooltip || policy == ImGuiPopupPositionPolicy_Default)
      213:12781-block 36
branch  0 taken 0 (fallthrough)
branch  1 taken 213
    %%%%%:12781-block 37
branch  2 never executed (fallthrough)
branch  3 never executed
        -:12782:    {
      213:12783:        const ImGuiDir dir_prefered_order[ImGuiDir_COUNT] = { ImGuiDir_Right, ImGuiDir_Down, ImGuiDir_Up, ImGuiDir_Left };
     213*:12784:        for (int n = (*last_dir != ImGuiDir_None) ? -1 : 0; n < ImGuiDir_COUNT; n++)
      213:12784-block 38
branch  0 taken 204 (fallthrough)
branch  1 taken 9
      204:12784-block 39
        9:12784-block 40
      213:12784-block 41
      213:12784-block 84
branch  2 taken 213
branch  3 taken 0 (fallthrough)
        -:12785:        {
      213:12786:            const ImGuiDir dir = (n == -1) ? *last_dir : dir_prefered_order[n];
      213:12786-block 42
branch  0 taken 204 (fallthrough)
branch  1 taken 9
      204:12786-block 43
        9:12786-block 44
     213*:12787:            if (n != -1 && dir == *last_dir) // Already tried this direction?
      213:12787-block 45
branch  0 taken 9 (fallthrough)
branch  1 taken 204
        9:12787-block 46
branch  2 taken 0 (fallthrough)
branch  3 taken 9
    #####:12788:                continue;
    %%%%%:12788-block 47
    %%%%%:12788-block 83
        -:12789:
     213*:12790:            const float avail_w = (dir == ImGuiDir_Left ? r_avoid.Min.x : r_outer.Max.x) - (dir == ImGuiDir_Right ? r_avoid.Max.x : r_outer.Min.x);
      213:12790-block 48
branch  0 taken 0 (fallthrough)
branch  1 taken 213
    %%%%%:12790-block 49
      213:12790-block 50
      213:12790-block 51
branch  2 taken 213 (fallthrough)
branch  3 taken 0
      213:12790-block 52
    %%%%%:12790-block 53
     213*:12791:            const float avail_h = (dir == ImGuiDir_Up ? r_avoid.Min.y : r_outer.Max.y) - (dir == ImGuiDir_Down ? r_avoid.Max.y : r_outer.Min.y);
      213:12791-block 54
branch  0 taken 0 (fallthrough)
branch  1 taken 213
    %%%%%:12791-block 55
      213:12791-block 56
      213:12791-block 57
branch  2 taken 0 (fallthrough)
branch  3 taken 213
    %%%%%:12791-block 58
      213:12791-block 59
        -:12792:
        -:12793:            // If there's not enough room on one axis, there's no point in positioning on a side on this axis (e.g. when not enough width, use a top/bottom position to maximize available width)
     213*:12794:            if (avail_w < size.x && (dir == ImGuiDir_Left || dir == ImGuiDir_Right))
      213:12794-block 60
branch  0 taken 0 (fallthrough)
branch  1 taken 213
    %%%%%:12794-block 61
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:12794-block 62
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:12795:                continue;
    %%%%%:12795-block 63
     213*:12796:            if (avail_h < size.y && (dir == ImGuiDir_Up || dir == ImGuiDir_Down))
      213:12796-block 64
branch  0 taken 0 (fallthrough)
branch  1 taken 213
    %%%%%:12796-block 65
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:12796-block 66
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:12797:                continue;
    %%%%%:12797-block 67
        -:12798:
      213:12799:            ImVec2 pos;
     213*:12800:            pos.x = (dir == ImGuiDir_Left) ? r_avoid.Min.x - size.x : (dir == ImGuiDir_Right) ? r_avoid.Max.x : base_pos_clamped.x;
      213:12800-block 68
branch  0 taken 0 (fallthrough)
branch  1 taken 213
    %%%%%:12800-block 69
      213:12800-block 70
branch  2 taken 213 (fallthrough)
branch  3 taken 0
      213:12800-block 71
    %%%%%:12800-block 72
      213:12800-block 73
     213*:12801:            pos.y = (dir == ImGuiDir_Up) ? r_avoid.Min.y - size.y : (dir == ImGuiDir_Down) ? r_avoid.Max.y : base_pos_clamped.y;
      213:12801-block 74
branch  0 taken 0 (fallthrough)
branch  1 taken 213
    %%%%%:12801-block 75
      213:12801-block 76
branch  2 taken 0 (fallthrough)
branch  3 taken 213
    %%%%%:12801-block 77
      213:12801-block 78
      213:12801-block 79
        -:12802:
        -:12803:            // Clamp top-left corner of popup
      213:12804:            pos.x = ImMax(pos.x, r_outer.Min.x);
      213:12804-block 80
call    0 returned 213
      213:12805:            pos.y = ImMax(pos.y, r_outer.Min.y);
call    0 returned 213
        -:12806:
      213:12807:            *last_dir = dir;
      213:12808:            return pos;
        -:12809:        }
        -:12810:    }
        -:12811:
        -:12812:    // Fallback when not enough room:
    #####:12813:    *last_dir = ImGuiDir_None;
        -:12814:
        -:12815:    // For tooltip we prefer avoiding the cursor at all cost even if it means that part of the tooltip won't be visible.
    #####:12816:    if (policy == ImGuiPopupPositionPolicy_Tooltip)
    %%%%%:12816-block 86
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:12817:        return ref_pos + ImVec2(2, 2);
    %%%%%:12817-block 87
call    0 never executed
call    1 never executed
        -:12818:
        -:12819:    // Otherwise try to keep within display
    #####:12820:    ImVec2 pos = ref_pos;
    #####:12821:    pos.x = ImMax(ImMin(pos.x + size.x, r_outer.Max.x) - size.x, r_outer.Min.x);
    %%%%%:12821-block 90
call    0 never executed
call    1 never executed
    #####:12822:    pos.y = ImMax(ImMin(pos.y + size.y, r_outer.Max.y) - size.y, r_outer.Min.y);
call    0 never executed
call    1 never executed
    #####:12823:    return pos;
        -:12824:}
        -:12825:
        -:12826:// Note that this is used for popups, which can overlap the non work-area of individual viewports.
function _ZN5ImGui25GetPopupAllowedExtentRectEP11ImGuiWindow called 213 returned 100% blocks executed 75%
      213:12827:ImRect ImGui::GetPopupAllowedExtentRect(ImGuiWindow* window)
        -:12828:{
      213:12829:    ImGuiContext& g = *GImGui;
      213:12830:    ImRect r_screen;
      213:12831:    if (window->ViewportAllowPlatformMonitorExtend >= 0)
      213:12831-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 213
        -:12832:    {
        -:12833:        // Extent with be in the frame of reference of the given viewport (so Min is likely to be negative here)
    #####:12834:        const ImGuiPlatformMonitor& monitor = g.PlatformIO.Monitors[window->ViewportAllowPlatformMonitorExtend];
    %%%%%:12834-block 3
call    0 never executed
    #####:12835:        r_screen.Min = monitor.WorkPos;
    #####:12836:        r_screen.Max = monitor.WorkPos + monitor.WorkSize;
call    0 never executed
        -:12837:    }
        -:12838:    else
        -:12839:    {
        -:12840:        // Use the full viewport area (not work area) for popups
      213:12841:        r_screen = window->Viewport->GetMainRect();
      213:12841-block 5
call    0 returned 213
        -:12842:    }
      213:12843:    ImVec2 padding = g.Style.DisplaySafeAreaPadding;
     213*:12844:    r_screen.Expand(ImVec2((r_screen.GetWidth() > padding.x * 2) ? -padding.x : 0.0f, (r_screen.GetHeight() > padding.y * 2) ? -padding.y : 0.0f));
      213:12844-block 6
call    0 returned 213
branch  1 taken 213 (fallthrough)
branch  2 taken 0
      213:12844-block 8
    %%%%%:12844-block 9
      213:12844-block 10
call    3 returned 213
branch  4 taken 213 (fallthrough)
branch  5 taken 0
      213:12844-block 12
    %%%%%:12844-block 13
      213:12844-block 14
call    6 returned 213
call    7 returned 213
      213:12845:    return r_screen;
        -:12846:}
        -:12847:
function _ZN5ImGui25FindBestWindowPosForPopupEP11ImGuiWindow called 213 returned 100% blocks executed 37%
      213:12848:ImVec2 ImGui::FindBestWindowPosForPopup(ImGuiWindow* window)
        -:12849:{
      213:12850:    ImGuiContext& g = *GImGui;
        -:12851:
      213:12852:    ImRect r_outer = GetPopupAllowedExtentRect(window);
      213:12852-block 2
call    0 returned 213
branch  1 taken 213 (fallthrough)
branch  2 taken 0 (throw)
      213:12853:    if (window->Flags & ImGuiWindowFlags_ChildMenu)
      213:12853-block 3
branch  0 taken 0 (fallthrough)
branch  1 taken 213
        -:12854:    {
        -:12855:        // Child menus typically request _any_ position within the parent menu item, and then we move the new menu outside the parent bounds.
        -:12856:        // This is how we end up with child menus appearing (most-commonly) on the right of the parent menu.
    #####:12857:        ImGuiWindow* parent_window = window->ParentWindow;
    #####:12858:        float horizontal_overlap = g.Style.ItemInnerSpacing.x; // We want some overlap to convey the relative depth of each menu (currently the amount of overlap is hard-coded to style.ItemSpacing.x).
    #####:12859:        ImRect r_avoid;
    #####:12860:        if (parent_window->DC.MenuBarAppending)
    %%%%%:12860-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:12861:            r_avoid = ImRect(-FLT_MAX, parent_window->ClipRect.Min.y, FLT_MAX, parent_window->ClipRect.Max.y); // Avoid parent menu-bar. If we wanted multi-line menu-bar, we may instead want to have the calling window setup e.g. a NextWindowData.PosConstraintAvoidRect field
    %%%%%:12861-block 5
call    0 never executed
        -:12862:        else
    #####:12863:            r_avoid = ImRect(parent_window->Pos.x + horizontal_overlap, -FLT_MAX, parent_window->Pos.x + parent_window->Size.x - horizontal_overlap - parent_window->ScrollbarSizes.x, FLT_MAX);
    %%%%%:12863-block 7
call    0 never executed
    #####:12864:        return FindBestWindowPosForPopupEx(window->Pos, window->Size, &window->AutoPosLastDirection, r_outer, r_avoid, ImGuiPopupPositionPolicy_Default);
    %%%%%:12864-block 9
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:12864-block 10
        -:12865:    }
      213:12866:    if (window->Flags & ImGuiWindowFlags_Popup)
      213:12866-block 12
branch  0 taken 0 (fallthrough)
branch  1 taken 213
        -:12867:    {
    #####:12868:        return FindBestWindowPosForPopupEx(window->Pos, window->Size, &window->AutoPosLastDirection, r_outer, ImRect(window->Pos, window->Pos), ImGuiPopupPositionPolicy_Default); // Ideally we'd disable r_avoid here
    %%%%%:12868-block 13
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:12868-block 15
    %%%%%:12868-block 16
    $$$$$:12868-block 53
        -:12869:    }
      213:12870:    if (window->Flags & ImGuiWindowFlags_Tooltip)
      213:12870-block 17
branch  0 taken 213 (fallthrough)
branch  1 taken 0
        -:12871:    {
        -:12872:        // Position tooltip (always follows mouse + clamp within outer boundaries)
        -:12873:        // FIXME:
        -:12874:        // - Too many paths. One problem is that FindBestWindowPosForPopupEx() doesn't allow passing a suggested position (so touch screen path doesn't use it by default).
        -:12875:        // - Drag and drop tooltips are not using this path either: BeginTooltipEx() manually sets their position.
        -:12876:        // - Require some tidying up. In theory we could handle both cases in same location, but requires a bit of shuffling
        -:12877:        //   as drag and drop tooltips are calling SetNextWindowPos() leading to 'window_pos_set_by_api' being set in Begin().
     213*:12878:        IM_ASSERT(g.CurrentWindow == window);
      213:12878-block 18
branch  0 taken 0 (fallthrough)
branch  1 taken 213
    %%%%%:12878-block 19
call    2 never executed
      213:12879:        const float scale = g.Style.MouseCursorScale;
      213:12880:        const ImVec2 ref_pos = NavCalcPreferredRefPos();
      213:12880-block 20
call    0 returned 213
branch  1 taken 213 (fallthrough)
branch  2 taken 0 (throw)
        -:12881:
     213*:12882:        if (g.IO.MouseSource == ImGuiMouseSource_TouchScreen && NavCalcPreferredRefPosSource() == ImGuiInputSource_Mouse)
      213:12882-block 21
branch  0 taken 0 (fallthrough)
branch  1 taken 213
    %%%%%:12882-block 22
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:12882-block 24
      213:12882-block 25
      213:12882-block 26
branch  5 taken 0 (fallthrough)
branch  6 taken 213
        -:12883:        {
    #####:12884:            ImVec2 tooltip_pos = ref_pos + TOOLTIP_DEFAULT_OFFSET_TOUCH * scale - (TOOLTIP_DEFAULT_PIVOT_TOUCH * window->Size);
    %%%%%:12884-block 27
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:12885:            if (r_outer.Contains(ImRect(tooltip_pos, tooltip_pos + window->Size)))
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:12886:                return tooltip_pos;
    %%%%%:12886-block 35
        -:12887:        }
        -:12888:
      213:12889:        ImVec2 tooltip_pos = ref_pos + TOOLTIP_DEFAULT_OFFSET_MOUSE * scale;
      213:12889-block 37
call    0 returned 213
call    1 returned 213
      213:12890:        ImRect r_avoid;
     213*:12891:        if (g.NavCursorVisible && g.NavHighlightItemUnderNav && !g.IO.ConfigNavMoveSetMousePos)
branch  0 taken 0 (fallthrough)
branch  1 taken 213
    %%%%%:12891-block 40
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:12891-block 41
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:12892:            r_avoid = ImRect(ref_pos.x - 16, ref_pos.y - 8, ref_pos.x + 16, ref_pos.y + 8);
    %%%%%:12892-block 42
call    0 never executed
        -:12893:        else
      213:12894:            r_avoid = ImRect(ref_pos.x - 16, ref_pos.y - 8, ref_pos.x + 24 * scale, ref_pos.y + 24 * scale); // FIXME: Hard-coded based on mouse cursor shape expectation. Exact dimension not very important.
      213:12894-block 44
call    0 returned 213
        -:12895:        //GetForegroundDrawList()->AddRect(r_avoid.Min, r_avoid.Max, IM_COL32(255, 0, 255, 255));
        -:12896:
      213:12897:        return FindBestWindowPosForPopupEx(tooltip_pos, window->Size, &window->AutoPosLastDirection, r_outer, r_avoid, ImGuiPopupPositionPolicy_Tooltip);
      213:12897-block 46
call    0 returned 213
branch  1 taken 213 (fallthrough)
branch  2 taken 0 (throw)
      213:12897-block 47
        -:12898:    }
    #####:12899:    IM_ASSERT(0);
    %%%%%:12899-block 49
call    0 never executed
        -:12900:    return window->Pos;
        -:12901:}
        -:12902:
        -:12903://-----------------------------------------------------------------------------
        -:12904:// [SECTION] KEYBOARD/GAMEPAD NAVIGATION
        -:12905://-----------------------------------------------------------------------------
        -:12906:
        -:12907:// FIXME-NAV: The existence of SetNavID vs SetFocusID vs FocusWindow() needs to be clarified/reworked.
        -:12908:// In our terminology those should be interchangeable, yet right now this is super confusing.
        -:12909:// Those two functions are merely a legacy artifact, so at minimum naming should be clarified.
        -:12910:
function _ZN5ImGui19SetNavCursorVisibleEb called 0 returned 0% blocks executed 0%
    #####:12911:void ImGui::SetNavCursorVisible(bool visible)
        -:12912:{
    #####:12913:    ImGuiContext& g = *GImGui;
    #####:12914:    if (g.IO.ConfigNavCursorVisibleAlways)
    %%%%%:12914-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:12915:        visible = true;
    %%%%%:12915-block 3
    #####:12916:    g.NavCursorVisible = visible;
    #####:12917:}
        -:12918:
        -:12919:// (was called NavRestoreHighlightAfterMove() before 1.91.4)
function _ZN5ImGui28SetNavCursorVisibleAfterMoveEv called 0 returned 0% blocks executed 0%
    #####:12920:void ImGui::SetNavCursorVisibleAfterMove()
        -:12921:{
    #####:12922:    ImGuiContext& g = *GImGui;
    #####:12923:    if (g.IO.ConfigNavCursorVisibleAuto)
    %%%%%:12923-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:12924:        g.NavCursorVisible = true;
    %%%%%:12924-block 3
    #####:12925:    g.NavHighlightItemUnderNav = g.NavMousePosDirty = true;
    #####:12926:}
        -:12927:
function _ZN5ImGui12SetNavWindowEP11ImGuiWindow called 11 returned 100% blocks executed 56%
       11:12928:void ImGui::SetNavWindow(ImGuiWindow* window)
        -:12929:{
       11:12930:    ImGuiContext& g = *GImGui;
       11:12931:    if (g.NavWindow != window)
       11:12931-block 2
branch  0 taken 11 (fallthrough)
branch  1 taken 0
        -:12932:    {
      11*:12933:        IMGUI_DEBUG_LOG_FOCUS("[focus] SetNavWindow(\"%s\")\n", window ? window->Name : "<NULL>");
       11:12933-block 3
branch  0 taken 0 (fallthrough)
branch  1 taken 11
    %%%%%:12933-block 4
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:12933-block 5
    %%%%%:12933-block 6
    %%%%%:12933-block 7
call    4 never executed
       11:12934:        g.NavWindow = window;
       11:12935:        g.NavLastValidSelectionUserData = ImGuiSelectionUserData_Invalid;
       11:12935-block 8
        -:12936:    }
       11:12937:    g.NavInitRequest = g.NavMoveSubmitted = g.NavMoveScoringItems = false;
       11:12938:    NavUpdateAnyRequestFlag();
       11:12938-block 9
call    0 returned 11
       11:12939:}
        -:12940:
function _ZN5ImGui21NavHighlightActivatedEj called 0 returned 0% blocks executed 0%
    #####:12941:void ImGui::NavHighlightActivated(ImGuiID id)
        -:12942:{
    #####:12943:    ImGuiContext& g = *GImGui;
    #####:12944:    g.NavHighlightActivatedId = id;
    #####:12945:    g.NavHighlightActivatedTimer = NAV_ACTIVATE_HIGHLIGHT_TIMER;
    #####:12946:}
        -:12947:
function _ZN5ImGui27NavClearPreferredPosForAxisE9ImGuiAxis called 24 returned 100% blocks executed 100%
       24:12948:void ImGui::NavClearPreferredPosForAxis(ImGuiAxis axis)
        -:12949:{
       24:12950:    ImGuiContext& g = *GImGui;
       24:12951:    g.NavWindow->RootWindowForNav->NavPreferredScoringPosRel[g.NavLayer][axis] = FLT_MAX;
       24:12951-block 2
call    0 returned 24
       24:12952:}
        -:12953:
function _ZN5ImGui8SetNavIDEj13ImGuiNavLayerjRK6ImRect called 9 returned 100% blocks executed 67%
        9:12954:void ImGui::SetNavID(ImGuiID id, ImGuiNavLayer nav_layer, ImGuiID focus_scope_id, const ImRect& rect_rel)
        -:12955:{
        9:12956:    ImGuiContext& g = *GImGui;
       9*:12957:    IM_ASSERT(g.NavWindow != NULL);
        9:12957-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 9
    %%%%%:12957-block 3
call    2 never executed
       9*:12958:    IM_ASSERT(nav_layer == ImGuiNavLayer_Main || nav_layer == ImGuiNavLayer_Menu);
        9:12958-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 9
    %%%%%:12958-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:12958-block 6
call    4 never executed
        9:12959:    g.NavId = id;
        9:12960:    g.NavLayer = nav_layer;
        9:12961:    SetNavFocusScope(focus_scope_id);
        9:12961-block 7
call    0 returned 9
        9:12962:    g.NavWindow->NavLastIds[nav_layer] = id;
        9:12963:    g.NavWindow->NavRectRel[nav_layer] = rect_rel;
        -:12964:
        -:12965:    // Clear preferred scoring position (NavMoveRequestApplyResult() will tend to restore it)
        9:12966:    NavClearPreferredPosForAxis(ImGuiAxis_X);
call    0 returned 9
        9:12967:    NavClearPreferredPosForAxis(ImGuiAxis_Y);
call    0 returned 9
        9:12968:}
        -:12969:
function _ZN5ImGui10SetFocusIDEjP11ImGuiWindow called 3 returned 100% blocks executed 80%
        3:12970:void ImGui::SetFocusID(ImGuiID id, ImGuiWindow* window)
        -:12971:{
        3:12972:    ImGuiContext& g = *GImGui;
       3*:12973:    IM_ASSERT(id != 0);
        3:12973-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%:12973-block 3
call    2 never executed
        -:12974:
        3:12975:    if (g.NavWindow != window)
        3:12975-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:12976:       SetNavWindow(window);
    %%%%%:12976-block 5
call    0 never executed
        -:12977:
        -:12978:    // Assume that SetFocusID() is called in the context where its window->DC.NavLayerCurrent and g.CurrentFocusScopeId are valid.
        -:12979:    // Note that window may be != g.CurrentWindow (e.g. SetFocusID call in InputTextEx for multi-line text)
        3:12980:    const ImGuiNavLayer nav_layer = window->DC.NavLayerCurrent;
        3:12981:    g.NavId = id;
        3:12982:    g.NavLayer = nav_layer;
        3:12983:    SetNavFocusScope(g.CurrentFocusScopeId);
        3:12983-block 6
call    0 returned 3
        3:12984:    window->NavLastIds[nav_layer] = id;
        3:12985:    if (g.LastItemData.ID == id)
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3:12986:        window->NavRectRel[nav_layer] = WindowRectAbsToRel(window, g.LastItemData.NavRect);
        3:12986-block 8
call    0 returned 3
        -:12987:
        3:12988:    if (g.ActiveIdSource == ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource_Gamepad)
        3:12988-block 9
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3:12988-block 10
branch  2 taken 0 (fallthrough)
branch  3 taken 3
    #####:12989:        g.NavHighlightItemUnderNav = true;
    %%%%%:12989-block 11
        3:12990:    else if (g.IO.ConfigNavCursorVisibleAuto)
        3:12990-block 12
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3:12991:        g.NavCursorVisible = false;
        3:12991-block 13
        -:12992:
        -:12993:    // Clear preferred scoring position (NavMoveRequestApplyResult() will tend to restore it)
        3:12994:    NavClearPreferredPosForAxis(ImGuiAxis_X);
        3:12994-block 14
call    0 returned 3
        3:12995:    NavClearPreferredPosForAxis(ImGuiAxis_Y);
call    0 returned 3
        3:12996:}
        -:12997:
function _ZL25ImGetDirQuadrantFromDeltaff called 0 returned 0% blocks executed 0%
    #####:12998:static ImGuiDir ImGetDirQuadrantFromDelta(float dx, float dy)
        -:12999:{
    #####:13000:    if (ImFabs(dx) > ImFabs(dy))
    %%%%%:13000-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:13001:        return (dx > 0.0f) ? ImGuiDir_Right : ImGuiDir_Left;
    %%%%%:13001-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13001-block 4
    %%%%%:13001-block 5
    %%%%%:13001-block 6
    #####:13002:    return (dy > 0.0f) ? ImGuiDir_Down : ImGuiDir_Up;
    %%%%%:13002-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13002-block 8
    %%%%%:13002-block 9
    %%%%%:13002-block 10
        -:13003:}
        -:13004:
function _ZL24NavScoreItemDistIntervalffff called 0 returned 0% blocks executed 0%
    #####:13005:static float inline NavScoreItemDistInterval(float cand_min, float cand_max, float curr_min, float curr_max)
        -:13006:{
    #####:13007:    if (cand_max < curr_min)
    %%%%%:13007-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:13008:        return cand_max - curr_min;
    %%%%%:13008-block 3
    #####:13009:    if (curr_max < cand_min)
    %%%%%:13009-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:13010:        return cand_min - curr_max;
    %%%%%:13010-block 5
    #####:13011:    return 0.0f;
    %%%%%:13011-block 6
        -:13012:}
        -:13013:
        -:13014:// Scoring function for keyboard/gamepad directional navigation. Based on https://gist.github.com/rygorous/6981057
function _ZN5ImGuiL12NavScoreItemEP16ImGuiNavItemData called 0 returned 0% blocks executed 0%
    #####:13015:static bool ImGui::NavScoreItem(ImGuiNavItemData* result)
        -:13016:{
    #####:13017:    ImGuiContext& g = *GImGui;
    #####:13018:    ImGuiWindow* window = g.CurrentWindow;
    #####:13019:    if (g.NavLayer != window->DC.NavLayerCurrent)
    %%%%%:13019-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:13020:        return false;
    %%%%%:13020-block 3
        -:13021:
        -:13022:    // FIXME: Those are not good variables names
    #####:13023:    ImRect cand = g.LastItemData.NavRect;   // Current item nav rectangle
    #####:13024:    const ImRect curr = g.NavScoringRect;   // Current modified source rect (NB: we've applied Max.x = Min.x in NavUpdate() to inhibit the effect of having varied item width)
    #####:13025:    g.NavScoringDebugCount++;
        -:13026:
        -:13027:    // When entering through a NavFlattened border, we consider child window items as fully clipped for scoring
    #####:13028:    if (window->ParentWindow == g.NavWindow)
    %%%%%:13028-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
        -:13029:    {
    #####:13030:        IM_ASSERT((window->ChildFlags | g.NavWindow->ChildFlags) & ImGuiChildFlags_NavFlattened);
    %%%%%:13030-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13030-block 6
call    2 never executed
    #####:13031:        if (!window->ClipRect.Overlaps(cand))
    %%%%%:13031-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:13032:            return false;
    %%%%%:13032-block 9
    #####:13033:        cand.ClipWithFull(window->ClipRect); // This allows the scored item to not overlap other candidates in the parent window
    %%%%%:13033-block 10
call    0 never executed
        -:13034:    }
        -:13035:
        -:13036:    // Compute distance between boxes
        -:13037:    // FIXME-NAV: Introducing biases for vertical navigation, needs to be removed.
    #####:13038:    float dbx = NavScoreItemDistInterval(cand.Min.x, cand.Max.x, curr.Min.x, curr.Max.x);
    %%%%%:13038-block 11
call    0 never executed
    #####:13039:    float dby = NavScoreItemDistInterval(ImLerp(cand.Min.y, cand.Max.y, 0.2f), ImLerp(cand.Min.y, cand.Max.y, 0.8f), ImLerp(curr.Min.y, curr.Max.y, 0.2f), ImLerp(curr.Min.y, curr.Max.y, 0.8f)); // Scale down on Y to keep using box-distance for vertically touching items
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:13040:    if (dby != 0.0f && dbx != 0.0f)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13040-block 18
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:13041:        dbx = (dbx / 1000.0f) + ((dbx > 0.0f) ? +1.0f : -1.0f);
    %%%%%:13041-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13041-block 20
    %%%%%:13041-block 21
    %%%%%:13041-block 22
    #####:13042:    float dist_box = ImFabs(dbx) + ImFabs(dby);
        -:13043:
        -:13044:    // Compute distance between centers (this is off by a factor of 2, but we only compare center distances with each other so it doesn't matter)
    #####:13045:    float dcx = (cand.Min.x + cand.Max.x) - (curr.Min.x + curr.Max.x);
    #####:13046:    float dcy = (cand.Min.y + cand.Max.y) - (curr.Min.y + curr.Max.y);
    #####:13047:    float dist_center = ImFabs(dcx) + ImFabs(dcy); // L1 metric (need this for our connectedness guarantee)
        -:13048:
        -:13049:    // Determine which quadrant of 'curr' our candidate item 'cand' lies in based on distance
        -:13050:    ImGuiDir quadrant;
    #####:13051:    float dax = 0.0f, day = 0.0f, dist_axial = 0.0f;
    #####:13052:    if (dbx != 0.0f || dby != 0.0f)
    %%%%%:13052-block 23
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13052-block 24
branch  2 never executed (fallthrough)
branch  3 never executed
        -:13053:    {
        -:13054:        // For non-overlapping boxes, use distance between boxes
        -:13055:        // FIXME-NAV: Quadrant may be incorrect because of (1) dbx bias and (2) curr.Max.y bias applied by NavBiasScoringRect() where typically curr.Max.y==curr.Min.y
        -:13056:        // One typical case where this happens, with style.WindowMenuButtonPosition == ImGuiDir_Right, pressing Left to navigate from Close to Collapse tends to fail.
        -:13057:        // Also see #6344. Calling ImGetDirQuadrantFromDelta() with unbiased values may be good but side-effects are plenty.
    #####:13058:        dax = dbx;
    #####:13059:        day = dby;
    #####:13060:        dist_axial = dist_box;
    #####:13061:        quadrant = ImGetDirQuadrantFromDelta(dbx, dby);
    %%%%%:13061-block 25
call    0 never executed
        -:13062:    }
    #####:13063:    else if (dcx != 0.0f || dcy != 0.0f)
    %%%%%:13063-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13063-block 27
branch  2 never executed (fallthrough)
branch  3 never executed
        -:13064:    {
        -:13065:        // For overlapping boxes with different centers, use distance between centers
    #####:13066:        dax = dcx;
    #####:13067:        day = dcy;
    #####:13068:        dist_axial = dist_center;
    #####:13069:        quadrant = ImGetDirQuadrantFromDelta(dcx, dcy);
    %%%%%:13069-block 28
call    0 never executed
        -:13070:    }
        -:13071:    else
        -:13072:    {
        -:13073:        // Degenerate case: two overlapping buttons with same center, break ties arbitrarily (note that LastItemId here is really the _previous_ item order, but it doesn't matter)
    #####:13074:        quadrant = (g.LastItemData.ID < g.NavId) ? ImGuiDir_Left : ImGuiDir_Right;
    %%%%%:13074-block 29
        -:13075:    }
        -:13076:
    #####:13077:    const ImGuiDir move_dir = g.NavMoveDir;
        -:13078:#if IMGUI_DEBUG_NAV_SCORING
        -:13079:    char buf[200];
        -:13080:    if (g.IO.KeyCtrl) // Hold CTRL to preview score in matching quadrant. CTRL+Arrow to rotate.
        -:13081:    {
        -:13082:        if (quadrant == move_dir)
        -:13083:        {
        -:13084:            ImFormatString(buf, IM_ARRAYSIZE(buf), "%.0f/%.0f", dist_box, dist_center);
        -:13085:            ImDrawList* draw_list = GetForegroundDrawList(window);
        -:13086:            draw_list->AddRectFilled(cand.Min, cand.Max, IM_COL32(255, 0, 0, 80));
        -:13087:            draw_list->AddRectFilled(cand.Min, cand.Min + CalcTextSize(buf), IM_COL32(255, 0, 0, 200));
        -:13088:            draw_list->AddText(cand.Min, IM_COL32(255, 255, 255, 255), buf);
        -:13089:        }
        -:13090:    }
        -:13091:    const bool debug_hovering = IsMouseHoveringRect(cand.Min, cand.Max);
        -:13092:    const bool debug_tty = (g.IO.KeyCtrl && IsKeyPressed(ImGuiKey_Space));
        -:13093:    if (debug_hovering || debug_tty)
        -:13094:    {
        -:13095:        ImFormatString(buf, IM_ARRAYSIZE(buf),
        -:13096:            "d-box    (%7.3f,%7.3f) -> %7.3f\nd-center (%7.3f,%7.3f) -> %7.3f\nd-axial  (%7.3f,%7.3f) -> %7.3f\nnav %c, quadrant %c",
        -:13097:            dbx, dby, dist_box, dcx, dcy, dist_center, dax, day, dist_axial, "-WENS"[move_dir+1], "-WENS"[quadrant+1]);
        -:13098:        if (debug_hovering)
        -:13099:        {
        -:13100:            ImDrawList* draw_list = GetForegroundDrawList(window);
        -:13101:            draw_list->AddRect(curr.Min, curr.Max, IM_COL32(255, 200, 0, 100));
        -:13102:            draw_list->AddRect(cand.Min, cand.Max, IM_COL32(255, 255, 0, 200));
        -:13103:            draw_list->AddRectFilled(cand.Max - ImVec2(4, 4), cand.Max + CalcTextSize(buf) + ImVec2(4, 4), IM_COL32(40, 0, 0, 200));
        -:13104:            draw_list->AddText(cand.Max, ~0U, buf);
        -:13105:        }
        -:13106:        if (debug_tty) { IMGUI_DEBUG_LOG_NAV("id 0x%08X\n%s\n", g.LastItemData.ID, buf); }
        -:13107:    }
        -:13108:#endif
        -:13109:
        -:13110:    // Is it in the quadrant we're interested in moving to?
    #####:13111:    bool new_best = false;
    #####:13112:    if (quadrant == move_dir)
    %%%%%:13112-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
        -:13113:    {
        -:13114:        // Does it beat the current best candidate?
    #####:13115:        if (dist_box < result->DistBox)
    %%%%%:13115-block 31
branch  0 never executed (fallthrough)
branch  1 never executed
        -:13116:        {
    #####:13117:            result->DistBox = dist_box;
    #####:13118:            result->DistCenter = dist_center;
    #####:13119:            return true;
    %%%%%:13119-block 32
        -:13120:        }
    #####:13121:        if (dist_box == result->DistBox)
    %%%%%:13121-block 33
branch  0 never executed (fallthrough)
branch  1 never executed
        -:13122:        {
        -:13123:            // Try using distance between center points to break ties
    #####:13124:            if (dist_center < result->DistCenter)
    %%%%%:13124-block 34
branch  0 never executed (fallthrough)
branch  1 never executed
        -:13125:            {
    #####:13126:                result->DistCenter = dist_center;
    #####:13127:                new_best = true;
    %%%%%:13127-block 35
        -:13128:            }
    #####:13129:            else if (dist_center == result->DistCenter)
    %%%%%:13129-block 36
branch  0 never executed (fallthrough)
branch  1 never executed
        -:13130:            {
        -:13131:                // Still tied! we need to be extra-careful to make sure everything gets linked properly. We consistently break ties by symbolically moving "later" items
        -:13132:                // (with higher index) to the right/downwards by an infinitesimal amount since we the current "best" button already (so it must have a lower index),
        -:13133:                // this is fairly easy. This rule ensures that all buttons with dx==dy==0 will end up being linked in order of appearance along the x axis.
    #####:13134:                if (((move_dir == ImGuiDir_Up || move_dir == ImGuiDir_Down) ? dby : dbx) < 0.0f) // moving bj to the right/down decreases distance
    %%%%%:13134-block 37
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13134-block 38
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:13134-block 39
    %%%%%:13134-block 40
    %%%%%:13134-block 41
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:13135:                    new_best = true;
    %%%%%:13135-block 42
        -:13136:            }
        -:13137:        }
        -:13138:    }
        -:13139:
        -:13140:    // Axial check: if 'curr' has no link at all in some direction and 'cand' lies roughly in that direction, add a tentative link. This will only be kept if no "real" matches
        -:13141:    // are found, so it only augments the graph produced by the above method using extra links. (important, since it doesn't guarantee strong connectedness)
        -:13142:    // This is just to avoid buttons having no links in a particular direction when there's a suitable neighbor. you get good graphs without this too.
        -:13143:    // 2017/09/29: FIXME: This now currently only enabled inside menu bars, ideally we'd disable it everywhere. Menus in particular need to catch failure. For general navigation it feels awkward.
        -:13144:    // Disabling it may lead to disconnected graphs when nodes are very spaced out on different axis. Perhaps consider offering this as an option?
    #####:13145:    if (result->DistBox == FLT_MAX && dist_axial < result->DistAxial)  // Check axial match
    %%%%%:13145-block 43
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13145-block 44
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:13146:        if (g.NavLayer == ImGuiNavLayer_Menu && !(g.NavWindow->Flags & ImGuiWindowFlags_ChildMenu))
    %%%%%:13146-block 45
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13146-block 46
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:13147:            if ((move_dir == ImGuiDir_Left && dax < 0.0f) || (move_dir == ImGuiDir_Right && dax > 0.0f) || (move_dir == ImGuiDir_Up && day < 0.0f) || (move_dir == ImGuiDir_Down && day > 0.0f))
    %%%%%:13147-block 47
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13147-block 48
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:13147-block 49
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:13147-block 50
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%:13147-block 51
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%:13147-block 52
branch 10 never executed (fallthrough)
branch 11 never executed
    %%%%%:13147-block 53
branch 12 never executed (fallthrough)
branch 13 never executed
    %%%%%:13147-block 54
branch 14 never executed (fallthrough)
branch 15 never executed
        -:13148:            {
    #####:13149:                result->DistAxial = dist_axial;
    #####:13150:                new_best = true;
    %%%%%:13150-block 55
        -:13151:            }
        -:13152:
    #####:13153:    return new_best;
    %%%%%:13153-block 56
        -:13154:}
        -:13155:
function _ZN5ImGuiL20NavApplyItemToResultEP16ImGuiNavItemData called 4 returned 100% blocks executed 50%
        4:13156:static void ImGui::NavApplyItemToResult(ImGuiNavItemData* result)
        -:13157:{
        4:13158:    ImGuiContext& g = *GImGui;
        4:13159:    ImGuiWindow* window = g.CurrentWindow;
        4:13160:    result->Window = window;
        4:13161:    result->ID = g.LastItemData.ID;
        4:13162:    result->FocusScopeId = g.CurrentFocusScopeId;
        4:13163:    result->ItemFlags = g.LastItemData.ItemFlags;
        4:13164:    result->RectRel = WindowRectAbsToRel(window, g.LastItemData.NavRect);
        4:13164-block 2
call    0 returned 4
        4:13165:    if (result->ItemFlags & ImGuiItemFlags_HasSelectionUserData)
branch  0 taken 0 (fallthrough)
branch  1 taken 4
        -:13166:    {
    #####:13167:        IM_ASSERT(g.NextItemData.SelectionUserData != ImGuiSelectionUserData_Invalid);
    %%%%%:13167-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13167-block 5
call    2 never executed
    #####:13168:        result->SelectionUserData = g.NextItemData.SelectionUserData; // INTENTIONAL: At this point this field is not cleared in NextItemData. Avoid unnecessary copy to LastItemData.
    %%%%%:13168-block 6
        -:13169:    }
        4:13170:}
        -:13171:
        -:13172:// True when current work location may be scrolled horizontally when moving left / right.
        -:13173:// This is generally always true UNLESS within a column. We don't have a vertical equivalent.
function _ZN5ImGui39NavUpdateCurrentWindowIsScrollPushableXEv called 34890 returned 100% blocks executed 80%
    34890:13174:void ImGui::NavUpdateCurrentWindowIsScrollPushableX()
        -:13175:{
    34890:13176:    ImGuiContext& g = *GImGui;
    34890:13177:    ImGuiWindow* window = g.CurrentWindow;
   34890*:13178:    window->DC.NavIsScrollPushableX = (g.CurrentTable == NULL && window->DC.CurrentColumns == NULL);
    34890:13178-block 2
branch  0 taken 34890 (fallthrough)
branch  1 taken 0
    34890:13178-block 3
branch  2 taken 34890 (fallthrough)
branch  3 taken 0
    34890:13178-block 4
    %%%%%:13178-block 5
    34890:13179:}
        -:13180:
        -:13181:// We get there when either NavId == id, or when g.NavAnyRequest is set (which is updated by NavUpdateAnyRequestFlag above)
        -:13182:// This is called after LastItemData is set, but NextItemData is also still valid.
function _ZN5ImGuiL14NavProcessItemEv called 476 returned 100% blocks executed 39%
      476:13183:static void ImGui::NavProcessItem()
        -:13184:{
      476:13185:    ImGuiContext& g = *GImGui;
      476:13186:    ImGuiWindow* window = g.CurrentWindow;
      476:13187:    const ImGuiID id = g.LastItemData.ID;
      476:13188:    const ImGuiItemFlags item_flags = g.LastItemData.ItemFlags;
        -:13189:
        -:13190:    // When inside a container that isn't scrollable with Left<>Right, clip NavRect accordingly (#2221)
      476:13191:    if (window->DC.NavIsScrollPushableX == false)
      476:13191-block 2
branch  0 taken 1 (fallthrough)
branch  1 taken 475
        -:13192:    {
        1:13193:        g.LastItemData.NavRect.Min.x = ImClamp(g.LastItemData.NavRect.Min.x, window->ClipRect.Min.x, window->ClipRect.Max.x);
        1:13193-block 3
call    0 returned 1
        1:13194:        g.LastItemData.NavRect.Max.x = ImClamp(g.LastItemData.NavRect.Max.x, window->ClipRect.Min.x, window->ClipRect.Max.x);
call    0 returned 1
        -:13195:    }
      476:13196:    const ImRect nav_bb = g.LastItemData.NavRect;
        -:13197:
        -:13198:    // Process Init Request
      476:13199:    if (g.NavInitRequest && g.NavLayer == window->DC.NavLayerCurrent && (item_flags & ImGuiItemFlags_Disabled) == 0)
      476:13199-block 6
branch  0 taken 8 (fallthrough)
branch  1 taken 468
        8:13199-block 7
branch  2 taken 4 (fallthrough)
branch  3 taken 4
        4:13199-block 8
branch  4 taken 4 (fallthrough)
branch  5 taken 0
        -:13200:    {
        -:13201:        // Even if 'ImGuiItemFlags_NoNavDefaultFocus' is on (typically collapse/close button) we record the first ResultId so they can be used as a fallback
        4:13202:        const bool candidate_for_nav_default_focus = (item_flags & ImGuiItemFlags_NoNavDefaultFocus) == 0;
       4*:13203:        if (candidate_for_nav_default_focus || g.NavInitResult.ID == 0)
        4:13203-block 9
branch  0 taken 0 (fallthrough)
branch  1 taken 4
    %%%%%:13203-block 10
branch  2 never executed (fallthrough)
branch  3 never executed
        -:13204:        {
        4:13205:            NavApplyItemToResult(&g.NavInitResult);
        4:13205-block 11
call    0 returned 4
        -:13206:        }
        4:13207:        if (candidate_for_nav_default_focus)
        4:13207-block 12
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        -:13208:        {
        4:13209:            g.NavInitRequest = false; // Found a match, clear request
        4:13210:            NavUpdateAnyRequestFlag();
        4:13210-block 13
call    0 returned 4
        -:13211:        }
        -:13212:    }
        -:13213:
        -:13214:    // Process Move Request (scoring for navigation)
        -:13215:    // FIXME-NAV: Consider policy for double scoring (scoring from NavScoringRect + scoring from a rect wrapped according to current wrapping policy)
     476*:13216:    if (g.NavMoveScoringItems && (item_flags & ImGuiItemFlags_Disabled) == 0)
      476:13216-block 14
branch  0 taken 0 (fallthrough)
branch  1 taken 476
    %%%%%:13216-block 15
branch  2 never executed (fallthrough)
branch  3 never executed
        -:13217:    {
    #####:13218:        if ((g.NavMoveFlags & ImGuiNavMoveFlags_FocusApi) || (window->Flags & ImGuiWindowFlags_NoNavInputs) == 0)
    %%%%%:13218-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13218-block 17
branch  2 never executed (fallthrough)
branch  3 never executed
        -:13219:        {
    #####:13220:            const bool is_tabbing = (g.NavMoveFlags & ImGuiNavMoveFlags_IsTabbing) != 0;
    #####:13221:            if (is_tabbing)
    %%%%%:13221-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
        -:13222:            {
    #####:13223:                NavProcessItemForTabbingRequest(id, item_flags, g.NavMoveFlags);
    %%%%%:13223-block 19
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:13224:            }
    #####:13225:            else if (g.NavId != id || (g.NavMoveFlags & ImGuiNavMoveFlags_AllowCurrentNavId))
    %%%%%:13225-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13225-block 21
branch  2 never executed (fallthrough)
branch  3 never executed
        -:13226:            {
    #####:13227:                ImGuiNavItemData* result = (window == g.NavWindow) ? &g.NavMoveResultLocal : &g.NavMoveResultOther;
    %%%%%:13227-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13227-block 23
    %%%%%:13227-block 24
    #####:13228:                if (NavScoreItem(result))
    %%%%%:13228-block 25
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:13228-block 26
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:13229:                    NavApplyItemToResult(result);
    %%%%%:13229-block 27
call    0 never executed
        -:13230:
        -:13231:                // Features like PageUp/PageDown need to maintain a separate score for the visible set of items.
    #####:13232:                const float VISIBLE_RATIO = 0.70f;
    #####:13233:                if ((g.NavMoveFlags & ImGuiNavMoveFlags_AlsoScoreVisibleSet) && window->ClipRect.Overlaps(nav_bb))
    %%%%%:13233-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13233-block 29
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:13233-block 31
    %%%%%:13233-block 32
    %%%%%:13233-block 33
branch  5 never executed (fallthrough)
branch  6 never executed
    #####:13234:                    if (ImClamp(nav_bb.Max.y, window->ClipRect.Min.y, window->ClipRect.Max.y) - ImClamp(nav_bb.Min.y, window->ClipRect.Min.y, window->ClipRect.Max.y) >= (nav_bb.Max.y - nav_bb.Min.y) * VISIBLE_RATIO)
    %%%%%:13234-block 34
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:13235:                        if (NavScoreItem(&g.NavMoveResultLocalVisible))
    %%%%%:13235-block 37
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:13235-block 38
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:13236:                            NavApplyItemToResult(&g.NavMoveResultLocalVisible);
    %%%%%:13236-block 39
call    0 never executed
        -:13237:            }
        -:13238:        }
        -:13239:    }
        -:13240:
        -:13241:    // Update information for currently focused/navigated item
      476:13242:    if (g.NavId == id)
      476:13242-block 40
branch  0 taken 468 (fallthrough)
branch  1 taken 8
        -:13243:    {
      468:13244:        if (g.NavWindow != window)
      468:13244-block 41
branch  0 taken 0 (fallthrough)
branch  1 taken 468
    #####:13245:            SetNavWindow(window); // Always refresh g.NavWindow, because some operations such as FocusItem() may not have a window.
    %%%%%:13245-block 42
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
      468:13246:        g.NavLayer = window->DC.NavLayerCurrent;
      468:13247:        SetNavFocusScope(g.CurrentFocusScopeId); // Will set g.NavFocusScopeId AND store g.NavFocusScopePath
      468:13247-block 43
call    0 returned 468
branch  1 taken 468 (fallthrough)
branch  2 taken 0 (throw)
      468:13248:        g.NavFocusScopeId = g.CurrentFocusScopeId;
      468:13249:        g.NavIdIsAlive = true;
      468:13250:        if (g.LastItemData.ItemFlags & ImGuiItemFlags_HasSelectionUserData)
      468:13250-block 44
branch  0 taken 0 (fallthrough)
branch  1 taken 468
        -:13251:        {
    #####:13252:            IM_ASSERT(g.NextItemData.SelectionUserData != ImGuiSelectionUserData_Invalid);
    %%%%%:13252-block 45
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13252-block 46
call    2 never executed
    #####:13253:            g.NavLastValidSelectionUserData = g.NextItemData.SelectionUserData; // INTENTIONAL: At this point this field is not cleared in NextItemData. Avoid unnecessary copy to LastItemData.
    %%%%%:13253-block 47
        -:13254:        }
      468:13255:        window->NavRectRel[window->DC.NavLayerCurrent] = WindowRectAbsToRel(window, nav_bb); // Store item bounding box (relative to window position)
      468:13255-block 48
call    0 returned 468
        -:13256:    }
      476:13257:}
      476:13257-block 49
        -:13258:
        -:13259:// Handle "scoring" of an item for a tabbing/focusing request initiated by NavUpdateCreateTabbingRequest().
        -:13260:// Note that SetKeyboardFocusHere() API calls are considered tabbing requests!
        -:13261:// - Case 1: no nav/active id:    set result to first eligible item, stop storing.
        -:13262:// - Case 2: tab forward:         on ref id set counter, on counter elapse store result
        -:13263:// - Case 3: tab forward wrap:    set result to first eligible item (preemptively), on ref id set counter, on next frame if counter hasn't elapsed store result. // FIXME-TABBING: Could be done as a next-frame forwarded request
        -:13264:// - Case 4: tab backward:        store all results, on ref id pick prev, stop storing
        -:13265:// - Case 5: tab backward wrap:   store all results, on ref id if no result keep storing until last // FIXME-TABBING: Could be done as next-frame forwarded requested
function _ZN5ImGuiL31NavProcessItemForTabbingRequestEjii called 0 returned 0% blocks executed 0%
    #####:13266:void ImGui::NavProcessItemForTabbingRequest(ImGuiID id, ImGuiItemFlags item_flags, ImGuiNavMoveFlags move_flags)
        -:13267:{
    #####:13268:    ImGuiContext& g = *GImGui;
        -:13269:
    #####:13270:    if ((move_flags & ImGuiNavMoveFlags_FocusApi) == 0)
    %%%%%:13270-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -:13271:    {
    #####:13272:        if (g.NavLayer != g.CurrentWindow->DC.NavLayerCurrent)
    %%%%%:13272-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:13273:            return;
    %%%%%:13273-block 4
    #####:13274:        if (g.NavFocusScopeId != g.CurrentFocusScopeId)
    %%%%%:13274-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:13275:            return;
    %%%%%:13275-block 6
        -:13276:    }
        -:13277:
        -:13278:    // - Can always land on an item when using API call.
        -:13279:    // - Tabbing with _NavEnableKeyboard (space/enter/arrows): goes through every item.
        -:13280:    // - Tabbing without _NavEnableKeyboard: goes through inputable items only.
        -:13281:    bool can_stop;
    #####:13282:    if (move_flags & ImGuiNavMoveFlags_FocusApi)
    %%%%%:13282-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:13283:        can_stop = true;
    %%%%%:13283-block 8
        -:13284:    else
    #####:13285:        can_stop = (item_flags & ImGuiItemFlags_NoTabStop) == 0 && ((g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) || (item_flags & ImGuiItemFlags_Inputable));
    %%%%%:13285-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13285-block 10
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:13285-block 11
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:13285-block 12
    %%%%%:13285-block 13
    %%%%%:13285-block 14
        -:13286:
        -:13287:    // Always store in NavMoveResultLocal (unlike directional request which uses NavMoveResultOther on sibling/flattened windows)
    #####:13288:    ImGuiNavItemData* result = &g.NavMoveResultLocal;
    #####:13289:    if (g.NavTabbingDir == +1)
    %%%%%:13289-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
        -:13290:    {
        -:13291:        // Tab Forward or SetKeyboardFocusHere() with >= 0
    #####:13292:        if (can_stop && g.NavTabbingResultFirst.ID == 0)
    %%%%%:13292-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13292-block 17
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:13293:            NavApplyItemToResult(&g.NavTabbingResultFirst);
    %%%%%:13293-block 18
call    0 never executed
    #####:13294:        if (can_stop && g.NavTabbingCounter > 0 && --g.NavTabbingCounter == 0)
    %%%%%:13294-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13294-block 20
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:13294-block 21
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:13294-block 22
    %%%%%:13294-block 23
    %%%%%:13294-block 24
branch  6 never executed (fallthrough)
branch  7 never executed
    #####:13295:            NavMoveRequestResolveWithLastItem(result);
    %%%%%:13295-block 25
call    0 never executed
    #####:13296:        else if (g.NavId == id)
    %%%%%:13296-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:13297:            g.NavTabbingCounter = 1;
    %%%%%:13297-block 27
        -:13298:    }
    #####:13299:    else if (g.NavTabbingDir == -1)
    %%%%%:13299-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
        -:13300:    {
        -:13301:        // Tab Backward
    #####:13302:        if (g.NavId == id)
    %%%%%:13302-block 29
branch  0 never executed (fallthrough)
branch  1 never executed
        -:13303:        {
    #####:13304:            if (result->ID)
    %%%%%:13304-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
        -:13305:            {
    #####:13306:                g.NavMoveScoringItems = false;
    #####:13307:                NavUpdateAnyRequestFlag();
    %%%%%:13307-block 31
call    0 never executed
        -:13308:            }
        -:13309:        }
    #####:13310:        else if (can_stop)
    %%%%%:13310-block 32
branch  0 never executed (fallthrough)
branch  1 never executed
        -:13311:        {
        -:13312:            // Keep applying until reaching NavId
    #####:13313:            NavApplyItemToResult(result);
    %%%%%:13313-block 33
call    0 never executed
        -:13314:        }
        -:13315:    }
    #####:13316:    else if (g.NavTabbingDir == 0)
    %%%%%:13316-block 34
branch  0 never executed (fallthrough)
branch  1 never executed
        -:13317:    {
    #####:13318:        if (can_stop && g.NavId == id)
    %%%%%:13318-block 35
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13318-block 36
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:13319:            NavMoveRequestResolveWithLastItem(result);
    %%%%%:13319-block 37
call    0 never executed
    #####:13320:        if (can_stop && g.NavTabbingResultFirst.ID == 0) // Tab init
    %%%%%:13320-block 38
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13320-block 39
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:13321:            NavApplyItemToResult(&g.NavTabbingResultFirst);
    %%%%%:13321-block 40
call    0 never executed
        -:13322:    }
        -:13323:}
        -:13324:
function _ZN5ImGui28NavMoveRequestButNoResultYetEv called 2154 returned 100% blocks executed 57%
     2154:13325:bool ImGui::NavMoveRequestButNoResultYet()
        -:13326:{
     2154:13327:    ImGuiContext& g = *GImGui;
    2154*:13328:    return g.NavMoveScoringItems && g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0;
     2154:13328-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 2154
    %%%%%:13328-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:13328-block 4
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:13328-block 5
     2154:13328-block 6
     2154:13328-block 7
        -:13329:}
        -:13330:
        -:13331:// FIXME: ScoringRect is not set
function _ZN5ImGui20NavMoveRequestSubmitE8ImGuiDirS0_ii called 0 returned 0% blocks executed 0%
    #####:13332:void ImGui::NavMoveRequestSubmit(ImGuiDir move_dir, ImGuiDir clip_dir, ImGuiNavMoveFlags move_flags, ImGuiScrollFlags scroll_flags)
        -:13333:{
    #####:13334:    ImGuiContext& g = *GImGui;
    #####:13335:    IM_ASSERT(g.NavWindow != NULL);
    %%%%%:13335-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13335-block 3
call    2 never executed
        -:13336:    //IMGUI_DEBUG_LOG_NAV("[nav] NavMoveRequestSubmit: dir %c, window \"%s\"\n", "-WENS"[move_dir + 1], g.NavWindow->Name);
        -:13337:
    #####:13338:    if (move_flags & ImGuiNavMoveFlags_IsTabbing)
    %%%%%:13338-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:13339:        move_flags |= ImGuiNavMoveFlags_AllowCurrentNavId;
    %%%%%:13339-block 5
        -:13340:
    #####:13341:    g.NavMoveSubmitted = g.NavMoveScoringItems = true;
    #####:13342:    g.NavMoveDir = move_dir;
    #####:13343:    g.NavMoveDirForDebug = move_dir;
    #####:13344:    g.NavMoveClipDir = clip_dir;
    #####:13345:    g.NavMoveFlags = move_flags;
    #####:13346:    g.NavMoveScrollFlags = scroll_flags;
    #####:13347:    g.NavMoveForwardToNextFrame = false;
    #####:13348:    g.NavMoveKeyMods = (move_flags & ImGuiNavMoveFlags_FocusApi) ? 0 : g.IO.KeyMods;
    %%%%%:13348-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13348-block 7
    %%%%%:13348-block 8
    #####:13349:    g.NavMoveResultLocal.Clear();
    %%%%%:13349-block 9
call    0 never executed
    #####:13350:    g.NavMoveResultLocalVisible.Clear();
call    0 never executed
    #####:13351:    g.NavMoveResultOther.Clear();
call    0 never executed
    #####:13352:    g.NavTabbingCounter = 0;
    #####:13353:    g.NavTabbingResultFirst.Clear();
call    0 never executed
    #####:13354:    NavUpdateAnyRequestFlag();
call    0 never executed
    #####:13355:}
        -:13356:
function _ZN5ImGui33NavMoveRequestResolveWithLastItemEP16ImGuiNavItemData called 0 returned 0% blocks executed 0%
    #####:13357:void ImGui::NavMoveRequestResolveWithLastItem(ImGuiNavItemData* result)
        -:13358:{
    #####:13359:    ImGuiContext& g = *GImGui;
    #####:13360:    g.NavMoveScoringItems = false; // Ensure request doesn't need more processing
    #####:13361:    NavApplyItemToResult(result);
    %%%%%:13361-block 2
call    0 never executed
    #####:13362:    NavUpdateAnyRequestFlag();
call    0 never executed
    #####:13363:}
        -:13364:
        -:13365:// Called by TreePop() to implement ImGuiTreeNodeFlags_NavLeftJumpsBackHere
function _ZN5ImGui37NavMoveRequestResolveWithPastTreeNodeEP16ImGuiNavItemDataP22ImGuiTreeNodeStackData called 0 returned 0% blocks executed 0%
    #####:13366:void ImGui::NavMoveRequestResolveWithPastTreeNode(ImGuiNavItemData* result, ImGuiTreeNodeStackData* tree_node_data)
        -:13367:{
    #####:13368:    ImGuiContext& g = *GImGui;
    #####:13369:    g.NavMoveScoringItems = false;
    #####:13370:    g.LastItemData.ID = tree_node_data->ID;
    #####:13371:    g.LastItemData.ItemFlags = tree_node_data->ItemFlags & ~ImGuiItemFlags_HasSelectionUserData; // Losing SelectionUserData, recovered next-frame (cheaper).
    #####:13372:    g.LastItemData.NavRect = tree_node_data->NavRect;
    #####:13373:    NavApplyItemToResult(result); // Result this instead of implementing a NavApplyPastTreeNodeToResult()
    %%%%%:13373-block 2
call    0 never executed
    #####:13374:    NavClearPreferredPosForAxis(ImGuiAxis_Y);
call    0 never executed
    #####:13375:    NavUpdateAnyRequestFlag();
call    0 never executed
    #####:13376:}
        -:13377:
function _ZN5ImGui20NavMoveRequestCancelEv called 3 returned 100% blocks executed 100%
        3:13378:void ImGui::NavMoveRequestCancel()
        -:13379:{
        3:13380:    ImGuiContext& g = *GImGui;
        3:13381:    g.NavMoveSubmitted = g.NavMoveScoringItems = false;
        3:13382:    NavUpdateAnyRequestFlag();
        3:13382-block 2
call    0 returned 3
        3:13383:}
        -:13384:
        -:13385:// Forward will reuse the move request again on the next frame (generally with modifications done to it)
function _ZN5ImGui21NavMoveRequestForwardE8ImGuiDirS0_ii called 0 returned 0% blocks executed 0%
    #####:13386:void ImGui::NavMoveRequestForward(ImGuiDir move_dir, ImGuiDir clip_dir, ImGuiNavMoveFlags move_flags, ImGuiScrollFlags scroll_flags)
        -:13387:{
    #####:13388:    ImGuiContext& g = *GImGui;
    #####:13389:    IM_ASSERT(g.NavMoveForwardToNextFrame == false);
    %%%%%:13389-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13389-block 3
call    2 never executed
    #####:13390:    NavMoveRequestCancel();
    %%%%%:13390-block 4
call    0 never executed
    #####:13391:    g.NavMoveForwardToNextFrame = true;
    #####:13392:    g.NavMoveDir = move_dir;
    #####:13393:    g.NavMoveClipDir = clip_dir;
    #####:13394:    g.NavMoveFlags = move_flags | ImGuiNavMoveFlags_Forwarded;
    #####:13395:    g.NavMoveScrollFlags = scroll_flags;
    #####:13396:}
        -:13397:
        -:13398:// Navigation wrap-around logic is delayed to the end of the frame because this operation is only valid after entire
        -:13399:// popup is assembled and in case of appended popups it is not clear which EndPopup() call is final.
function _ZN5ImGui25NavMoveRequestTryWrappingEP11ImGuiWindowi called 0 returned 0% blocks executed 0%
    #####:13400:void ImGui::NavMoveRequestTryWrapping(ImGuiWindow* window, ImGuiNavMoveFlags wrap_flags)
        -:13401:{
    #####:13402:    ImGuiContext& g = *GImGui;
    #####:13403:    IM_ASSERT((wrap_flags & ImGuiNavMoveFlags_WrapMask_ ) != 0 && (wrap_flags & ~ImGuiNavMoveFlags_WrapMask_) == 0); // Call with _WrapX, _WrapY, _LoopX, _LoopY
    %%%%%:13403-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13403-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:13403-block 4
    %%%%%:13403-block 5
call    4 never executed
        -:13404:
        -:13405:    // In theory we should test for NavMoveRequestButNoResultYet() but there's no point doing it:
        -:13406:    // as NavEndFrame() will do the same test. It will end up calling NavUpdateCreateWrappingRequest().
    #####:13407:    if (g.NavWindow == window && g.NavMoveScoringItems && g.NavLayer == ImGuiNavLayer_Main)
    %%%%%:13407-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13407-block 7
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:13407-block 8
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:13408:        g.NavMoveFlags = (g.NavMoveFlags & ~ImGuiNavMoveFlags_WrapMask_) | wrap_flags;
    %%%%%:13408-block 9
    #####:13409:}
        -:13410:
        -:13411:// FIXME: This could be replaced by updating a frame number in each window when (window == NavWindow) and (NavLayer == 0).
        -:13412:// This way we could find the last focused window among our children. It would be much less confusing this way?
function _ZN5ImGuiL35NavSaveLastChildNavWindowIntoParentEP11ImGuiWindow called 1076 returned 100% blocks executed 100%
     1076:13413:static void ImGui::NavSaveLastChildNavWindowIntoParent(ImGuiWindow* nav_window)
        -:13414:{
     1076:13415:    ImGuiWindow* parent = nav_window;
     1466:13416:    while (parent && parent->RootWindow != parent && (parent->Flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_ChildMenu)) == 0)
     1076:13416-block 2
     1466:13416-block 4
branch  0 taken 1466 (fallthrough)
branch  1 taken 0
     1466:13416-block 5
branch  2 taken 390 (fallthrough)
branch  3 taken 1076
      390:13416-block 6
branch  4 taken 390
branch  5 taken 0 (fallthrough)
      390:13417:        parent = parent->ParentWindow;
      390:13417-block 3
     1076:13418:    if (parent && parent != nav_window)
     1076:13418-block 7
branch  0 taken 1076 (fallthrough)
branch  1 taken 0
     1076:13418-block 8
branch  2 taken 390 (fallthrough)
branch  3 taken 686
      390:13419:        parent->NavLastChildNavWindow = nav_window;
      390:13419-block 9
     1076:13420:}
        -:13421:
        -:13422:// Restore the last focused child.
        -:13423:// Call when we are expected to land on the Main Layer (0) after FocusWindow()
function _ZN5ImGuiL28NavRestoreLastChildNavWindowEP11ImGuiWindow called 0 returned 0% blocks executed 0%
    #####:13424:static ImGuiWindow* ImGui::NavRestoreLastChildNavWindow(ImGuiWindow* window)
        -:13425:{
    #####:13426:    if (window->NavLastChildNavWindow && window->NavLastChildNavWindow->WasActive)
    %%%%%:13426-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13426-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:13427:        return window->NavLastChildNavWindow;
    %%%%%:13427-block 4
    #####:13428:    if (window->DockNodeAsHost && window->DockNodeAsHost->TabBar)
    %%%%%:13428-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13428-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:13429:        if (ImGuiTabItem* tab = TabBarFindMostRecentlySelectedTabForActiveWindow(window->DockNodeAsHost->TabBar))
    %%%%%:13429-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:13430:            return tab->Window;
    %%%%%:13430-block 9
    #####:13431:    return window;
    %%%%%:13431-block 10
        -:13432:}
        -:13433:
function _ZN5ImGuiL15NavRestoreLayerE13ImGuiNavLayer called 0 returned 0% blocks executed 0%
    #####:13434:void ImGui::NavRestoreLayer(ImGuiNavLayer layer)
        -:13435:{
    #####:13436:    ImGuiContext& g = *GImGui;
    #####:13437:    if (layer == ImGuiNavLayer_Main)
    %%%%%:13437-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -:13438:    {
    #####:13439:        ImGuiWindow* prev_nav_window = g.NavWindow;
    #####:13440:        g.NavWindow = NavRestoreLastChildNavWindow(g.NavWindow);    // FIXME-NAV: Should clear ongoing nav requests?
    %%%%%:13440-block 3
call    0 never executed
    #####:13441:        g.NavLastValidSelectionUserData = ImGuiSelectionUserData_Invalid;
    #####:13442:        if (prev_nav_window)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:13443:            IMGUI_DEBUG_LOG_FOCUS("[focus] NavRestoreLayer: from \"%s\" to SetNavWindow(\"%s\")\n", prev_nav_window->Name, g.NavWindow->Name);
    %%%%%:13443-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13443-block 6
call    2 never executed
        -:13444:    }
    #####:13445:    ImGuiWindow* window = g.NavWindow;
    #####:13446:    if (window->NavLastIds[layer] != 0)
    %%%%%:13446-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
        -:13447:    {
    #####:13448:        SetNavID(window->NavLastIds[layer], layer, 0, window->NavRectRel[layer]);
    %%%%%:13448-block 8
call    0 never executed
        -:13449:    }
        -:13450:    else
        -:13451:    {
    #####:13452:        g.NavLayer = layer;
    #####:13453:        NavInitWindow(window, true);
    %%%%%:13453-block 9
call    0 never executed
        -:13454:    }
    #####:13455:}
        -:13456:
function _ZN5ImGuiL23NavUpdateAnyRequestFlagEv called 1103 returned 100% blocks executed 88%
     1103:13457:static inline void ImGui::NavUpdateAnyRequestFlag()
        -:13458:{
     1103:13459:    ImGuiContext& g = *GImGui;
     1103:13460:    g.NavAnyRequest = g.NavMoveScoringItems || g.NavInitRequest || (IMGUI_DEBUG_NAV_SCORING && g.NavWindow != NULL);
     1103:13460-block 2
branch  0 taken 1103 (fallthrough)
branch  1 taken 0
     1103:13460-block 3
branch  2 taken 8 (fallthrough)
branch  3 taken 1095
        8:13460-block 4
     1095:13460-block 5
     1103:13461:    if (g.NavAnyRequest)
     1103:13461-block 6
branch  0 taken 8 (fallthrough)
branch  1 taken 1095
       8*:13462:        IM_ASSERT(g.NavWindow != NULL);
        8:13462-block 7
branch  0 taken 0 (fallthrough)
branch  1 taken 8
    %%%%%:13462-block 8
call    2 never executed
     1103:13463:}
        -:13464:
        -:13465:// This needs to be called before we submit any widget (aka in or before Begin)
function _ZN5ImGui13NavInitWindowEP11ImGuiWindowb called 8 returned 100% blocks executed 58%
        8:13466:void ImGui::NavInitWindow(ImGuiWindow* window, bool force_reinit)
        -:13467:{
        -:13468:    // FIXME: ChildWindow test here is wrong for docking
        8:13469:    ImGuiContext& g = *GImGui;
       8*:13470:    IM_ASSERT(window == g.NavWindow);
        8:13470-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 8
    %%%%%:13470-block 3
call    2 never executed
        -:13471:
        8:13472:    if (window->Flags & ImGuiWindowFlags_NoNavInputs)
        8:13472-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 8
        -:13473:    {
    #####:13474:        g.NavId = 0;
    #####:13475:        SetNavFocusScope(window->NavRootFocusScopeId);
    %%%%%:13475-block 5
call    0 never executed
    #####:13476:        return;
        -:13477:    }
        -:13478:
        8:13479:    bool init_for_nav = false;
       8*:13480:    if (window == window->RootWindow || (window->Flags & ImGuiWindowFlags_Popup) || (window->NavLastIds[0] == 0) || force_reinit)
        8:13480-block 7
branch  0 taken 0 (fallthrough)
branch  1 taken 8
    %%%%%:13480-block 8
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:13480-block 9
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:13480-block 10
branch  6 never executed (fallthrough)
branch  7 never executed
        8:13481:        init_for_nav = true;
        8:13481-block 11
       8*:13482:    IMGUI_DEBUG_LOG_NAV("[nav] NavInitRequest: from NavInitWindow(), init_for_nav=%d, window=\"%s\", layer=%d\n", init_for_nav, window->Name, g.NavLayer);
        8:13482-block 12
branch  0 taken 0 (fallthrough)
branch  1 taken 8
    %%%%%:13482-block 13
call    2 never executed
        8:13483:    if (init_for_nav)
        8:13483-block 14
branch  0 taken 8 (fallthrough)
branch  1 taken 0
        -:13484:    {
        8:13485:        SetNavID(0, g.NavLayer, window->NavRootFocusScopeId, ImRect());
        8:13485-block 15
call    0 returned 8
call    1 returned 8
branch  2 taken 8 (fallthrough)
branch  3 taken 0 (throw)
        8:13486:        g.NavInitRequest = true;
        8:13487:        g.NavInitRequestFromMove = false;
        8:13488:        g.NavInitResult.ID = 0;
        8:13489:        NavUpdateAnyRequestFlag();
        8:13489-block 17
call    0 returned 8
        -:13490:    }
        -:13491:    else
        -:13492:    {
    #####:13493:        g.NavId = window->NavLastIds[0];
    #####:13494:        SetNavFocusScope(window->NavRootFocusScopeId);
    %%%%%:13494-block 18
call    0 never executed
        -:13495:    }
        -:13496:}
        -:13497:
function _ZN5ImGuiL28NavCalcPreferredRefPosSourceEv called 213 returned 100% blocks executed 58%
      213:13498:static ImGuiInputSource ImGui::NavCalcPreferredRefPosSource()
        -:13499:{
      213:13500:    ImGuiContext& g = *GImGui;
      213:13501:    ImGuiWindow* window = g.NavWindow;
     213*:13502:    const bool activated_shortcut = g.ActiveId != 0 && g.ActiveIdFromShortcut && g.ActiveId == g.LastItemData.ID;
      213:13502-block 2
branch  0 taken 39 (fallthrough)
branch  1 taken 174
       39:13502-block 3
branch  2 taken 0 (fallthrough)
branch  3 taken 39
    %%%%%:13502-block 4
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:13502-block 5
      213:13502-block 6
        -:13503:
        -:13504:    // Testing for !activated_shortcut here could in theory be removed if we decided that activating a remote shortcut altered one of the g.NavDisableXXX flag.
     213*:13505:    if ((!g.NavCursorVisible || !g.NavHighlightItemUnderNav || !window) && !activated_shortcut)
      213:13505-block 7
branch  0 taken 0 (fallthrough)
branch  1 taken 213
    %%%%%:13505-block 8
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:13505-block 9
branch  4 never executed (fallthrough)
branch  5 never executed
      213:13505-block 10
branch  6 taken 213 (fallthrough)
branch  7 taken 0
      213:13506:        return ImGuiInputSource_Mouse;
      213:13506-block 11
        -:13507:    else
    #####:13508:        return ImGuiInputSource_Keyboard; // or Nav in general
    %%%%%:13508-block 12
        -:13509:}
        -:13510:
function _ZN5ImGuiL22NavCalcPreferredRefPosEv called 213 returned 100% blocks executed 36%
      213:13511:static ImVec2 ImGui::NavCalcPreferredRefPos()
        -:13512:{
      213:13513:    ImGuiContext& g = *GImGui;
      213:13514:    ImGuiWindow* window = g.NavWindow;
      213:13515:    ImGuiInputSource source = NavCalcPreferredRefPosSource();
      213:13515-block 2
call    0 returned 213
        -:13516:
     213*:13517:    const bool activated_shortcut = g.ActiveId != 0 && g.ActiveIdFromShortcut && g.ActiveId == g.LastItemData.ID;
branch  0 taken 39 (fallthrough)
branch  1 taken 174
       39:13517-block 4
branch  2 taken 0 (fallthrough)
branch  3 taken 39
    %%%%%:13517-block 5
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:13517-block 6
      213:13517-block 7
        -:13518:
        -:13519:    // Testing for !activated_shortcut here could in theory be removed if we decided that activating a remote shortcut altered one of the g.NavDisableXXX flag.
      213:13520:    if (source == ImGuiInputSource_Mouse)
      213:13520-block 8
branch  0 taken 213 (fallthrough)
branch  1 taken 0
        -:13521:    {
        -:13522:        // Mouse (we need a fallback in case the mouse becomes invalid after being used)
        -:13523:        // The +1.0f offset when stored by OpenPopupEx() allows reopening this or another popup (same or another mouse button) while not moving the mouse, it is pretty standard.
        -:13524:        // In theory we could move that +1.0f offset in OpenPopupEx()
     213*:13525:        ImVec2 p = IsMousePosValid(&g.IO.MousePos) ? g.IO.MousePos : g.MouseLastValidPos;
      213:13525-block 9
call    0 returned 213
branch  1 taken 213 (fallthrough)
branch  2 taken 0
      213:13525-block 11
    %%%%%:13525-block 12
      213:13526:        return ImVec2(p.x + 1.0f, p.y);
      213:13526-block 13
call    0 returned 213
      213:13526-block 15
        -:13527:    }
        -:13528:    else
        -:13529:    {
        -:13530:        // When navigation is active and mouse is disabled, pick a position around the bottom left of the currently navigated item
    #####:13531:        ImRect ref_rect;
    #####:13532:        if (activated_shortcut)
    %%%%%:13532-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:13533:            ref_rect = g.LastItemData.NavRect;
    %%%%%:13533-block 17
        -:13534:        else
    #####:13535:            ref_rect = WindowRectRelToAbs(window, window->NavRectRel[g.NavLayer]);
    %%%%%:13535-block 18
call    0 never executed
        -:13536:
        -:13537:        // Take account of upcoming scrolling (maybe set mouse pos should be done in EndFrame?)
    #####:13538:        if (window->LastFrameActive != g.FrameCount && (window->ScrollTarget.x != FLT_MAX || window->ScrollTarget.y != FLT_MAX))
    %%%%%:13538-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13538-block 20
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:13538-block 21
branch  4 never executed (fallthrough)
branch  5 never executed
        -:13539:        {
    #####:13540:            ImVec2 next_scroll = CalcNextScrollFromScrollTargetAndClamp(window);
    %%%%%:13540-block 22
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:13541:            ref_rect.Translate(window->Scroll - next_scroll);
    %%%%%:13541-block 23
call    0 never executed
call    1 never executed
        -:13542:        }
    #####:13543:        ImVec2 pos = ImVec2(ref_rect.Min.x + ImMin(g.Style.FramePadding.x * 4, ref_rect.GetWidth()), ref_rect.Max.y - ImMin(g.Style.FramePadding.y, ref_rect.GetHeight()));
    %%%%%:13543-block 26
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:13544:        ImGuiViewport* viewport = window->Viewport;
    #####:13545:        return ImTrunc(ImClamp(pos, viewport->Pos, viewport->Pos + viewport->Size)); // ImTrunc() is important because non-integer mouse position application in backend might be lossy and result in undesirable non-zero delta.
call    0 never executed
call    1 never executed
call    2 never executed
        -:13546:    }
        -:13547:}
        -:13548:
function _ZN5ImGui24GetNavTweakPressedAmountE9ImGuiAxis called 0 returned 0% blocks executed 0%
    #####:13549:float ImGui::GetNavTweakPressedAmount(ImGuiAxis axis)
        -:13550:{
    #####:13551:    ImGuiContext& g = *GImGui;
        -:13552:    float repeat_delay, repeat_rate;
    #####:13553:    GetTypematicRepeatRate(ImGuiInputFlags_RepeatRateNavTweak, &repeat_delay, &repeat_rate);
    %%%%%:13553-block 2
call    0 never executed
        -:13554:
        -:13555:    ImGuiKey key_less, key_more;
    #####:13556:    if (g.NavInputSource == ImGuiInputSource_Gamepad)
branch  0 never executed (fallthrough)
branch  1 never executed
        -:13557:    {
    #####:13558:        key_less = (axis == ImGuiAxis_X) ? ImGuiKey_GamepadDpadLeft : ImGuiKey_GamepadDpadUp;
    %%%%%:13558-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13558-block 5
    %%%%%:13558-block 6
    #####:13559:        key_more = (axis == ImGuiAxis_X) ? ImGuiKey_GamepadDpadRight : ImGuiKey_GamepadDpadDown;
    %%%%%:13559-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13559-block 8
    %%%%%:13559-block 9
    %%%%%:13559-block 10
        -:13560:    }
        -:13561:    else
        -:13562:    {
    #####:13563:        key_less = (axis == ImGuiAxis_X) ? ImGuiKey_LeftArrow : ImGuiKey_UpArrow;
    %%%%%:13563-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13563-block 12
    %%%%%:13563-block 13
    #####:13564:        key_more = (axis == ImGuiAxis_X) ? ImGuiKey_RightArrow : ImGuiKey_DownArrow;
    %%%%%:13564-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13564-block 15
    %%%%%:13564-block 16
    %%%%%:13564-block 17
        -:13565:    }
    #####:13566:    float amount = (float)GetKeyPressedAmount(key_more, repeat_delay, repeat_rate) - (float)GetKeyPressedAmount(key_less, repeat_delay, repeat_rate);
    %%%%%:13566-block 18
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:13566-block 19
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    #####:13567:    if (amount != 0.0f && IsKeyDown(key_less) && IsKeyDown(key_more)) // Cancel when opposite directions are held, regardless of repeat phase
    %%%%%:13567-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13567-block 21
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%:13567-block 22
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:13567-block 23
call    7 never executed
branch  8 never executed (fallthrough)
branch  9 never executed (throw)
    %%%%%:13567-block 24
branch 10 never executed (fallthrough)
branch 11 never executed
    %%%%%:13567-block 25
    %%%%%:13567-block 26
    %%%%%:13567-block 27
branch 12 never executed (fallthrough)
branch 13 never executed
    #####:13568:        amount = 0.0f;
    %%%%%:13568-block 28
    #####:13569:    return amount;
    %%%%%:13569-block 29
    %%%%%:13569-block 30
        -:13570:}
        -:13571:
function _ZN5ImGuiL9NavUpdateEv called 1077 returned 100% blocks executed 31%
     1077:13572:static void ImGui::NavUpdate()
        -:13573:{
     1077:13574:    ImGuiContext& g = *GImGui;
     1077:13575:    ImGuiIO& io = g.IO;
        -:13576:
     1077:13577:    io.WantSetMousePos = false;
        -:13578:    //if (g.NavScoringDebugCount > 0) IMGUI_DEBUG_LOG_NAV("[nav] NavScoringDebugCount %d for '%s' layer %d (Init:%d, Move:%d)\n", g.NavScoringDebugCount, g.NavWindow ? g.NavWindow->Name : "NULL", g.NavLayer, g.NavInitRequest || g.NavInitResultId != 0, g.NavMoveRequest);
        -:13579:
        -:13580:    // Set input source based on which keys are last pressed (as some features differs when used with Gamepad vs Keyboard)
        -:13581:    // FIXME-NAV: Now that keys are separated maybe we can get rid of NavInputSource?
    1077*:13582:    const bool nav_gamepad_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (io.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
     1077:13582-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:13582-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:13582-block 4
     1077:13582-block 5
     1077:13583:    const ImGuiKey nav_gamepad_keys_to_change_source[] = { ImGuiKey_GamepadFaceRight, ImGuiKey_GamepadFaceLeft, ImGuiKey_GamepadFaceUp, ImGuiKey_GamepadFaceDown, ImGuiKey_GamepadDpadRight, ImGuiKey_GamepadDpadLeft, ImGuiKey_GamepadDpadUp, ImGuiKey_GamepadDpadDown };
     1077:13584:    if (nav_gamepad_active)
     1077:13584-block 6
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####:13585:        for (ImGuiKey key : nav_gamepad_keys_to_change_source)
    %%%%%:13585-block 7
    %%%%%:13585-block 11
    %%%%%:13585-block 12
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:13586:            if (IsKeyDown(key))
    %%%%%:13586-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:13586-block 9
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:13587:                g.NavInputSource = ImGuiInputSource_Gamepad;
    %%%%%:13587-block 10
     1077:13588:    const bool nav_keyboard_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
     1077:13589:    const ImGuiKey nav_keyboard_keys_to_change_source[] = { ImGuiKey_Space, ImGuiKey_Enter, ImGuiKey_Escape, ImGuiKey_RightArrow, ImGuiKey_LeftArrow, ImGuiKey_UpArrow, ImGuiKey_DownArrow };
     1077:13590:    if (nav_keyboard_active)
     1077:13590-block 13
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     8616:13591:        for (ImGuiKey key : nav_keyboard_keys_to_change_source)
     1077:13591-block 14
     7539:13591-block 18
     8616:13591-block 19
branch  0 taken 7539
branch  1 taken 1077 (fallthrough)
     7539:13592:            if (IsKeyDown(key))
     7539:13592-block 15
call    0 returned 7539
branch  1 taken 7539 (fallthrough)
branch  2 taken 0 (throw)
     7539:13592-block 16
branch  3 taken 0 (fallthrough)
branch  4 taken 7539
    #####:13593:                g.NavInputSource = ImGuiInputSource_Keyboard;
    %%%%%:13593-block 17
        -:13594:
        -:13595:    // Process navigation init request (select first/default focus)
     1077:13596:    g.NavJustMovedToId = 0;
     1077:13597:    g.NavJustMovedToFocusScopeId = g.NavJustMovedFromFocusScopeId = 0;
     1077:13598:    if (g.NavInitResult.ID != 0)
     1077:13598-block 20
branch  0 taken 1 (fallthrough)
branch  1 taken 1076
        1:13599:        NavInitRequestApplyResult();
        1:13599-block 21
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
     1077:13600:    g.NavInitRequest = false;
     1077:13601:    g.NavInitRequestFromMove = false;
     1077:13602:    g.NavInitResult.ID = 0;
        -:13603:
        -:13604:    // Process navigation move request
     1077:13605:    if (g.NavMoveSubmitted)
     1077:13605-block 22
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####:13606:        NavMoveRequestApplyResult();
    %%%%%:13606-block 23
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
     1077:13607:    g.NavTabbingCounter = 0;
     1077:13608:    g.NavMoveSubmitted = g.NavMoveScoringItems = false;
     1077:13609:    if (g.NavCursorHideFrames > 0)
     1077:13609-block 24
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####:13610:        if (--g.NavCursorHideFrames == 0)
    %%%%%:13610-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:13611:            g.NavCursorVisible = true;
    %%%%%:13611-block 26
        -:13612:
        -:13613:    // Schedule mouse position update (will be done at the bottom of this function, after 1) processing all move requests and 2) updating scrolling)
     1077:13614:    bool set_mouse_pos = false;
    1077*:13615:    if (g.NavMousePosDirty && g.NavIdIsAlive)
     1077:13615-block 27
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:13615-block 28
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:13616:        if (g.NavCursorVisible && g.NavHighlightItemUnderNav && g.NavWindow)
    %%%%%:13616-block 29
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13616-block 30
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:13616-block 31
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:13617:            set_mouse_pos = true;
    %%%%%:13617-block 32
     1077:13618:    g.NavMousePosDirty = false;
    1077*:13619:    IM_ASSERT(g.NavLayer == ImGuiNavLayer_Main || g.NavLayer == ImGuiNavLayer_Menu);
     1077:13619-block 33
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:13619-block 34
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:13619-block 35
call    4 never executed
        -:13620:
        -:13621:    // Store our return window (for returning from Menu Layer to Main Layer) and clear it as soon as we step back in our own Layer 0
     1077:13622:    if (g.NavWindow)
     1077:13622-block 36
branch  0 taken 1076 (fallthrough)
branch  1 taken 1
     1076:13623:        NavSaveLastChildNavWindowIntoParent(g.NavWindow);
     1076:13623-block 37
call    0 returned 1076
     1077:13624:    if (g.NavWindow && g.NavWindow->NavLastChildNavWindow != NULL && g.NavLayer == ImGuiNavLayer_Main)
     1077:13624-block 38
branch  0 taken 1076 (fallthrough)
branch  1 taken 1
     1076:13624-block 39
branch  2 taken 1 (fallthrough)
branch  3 taken 1075
        1:13624-block 40
branch  4 taken 1 (fallthrough)
branch  5 taken 0
        1:13625:        g.NavWindow->NavLastChildNavWindow = NULL;
        1:13625-block 41
        -:13626:
        -:13627:    // Update CTRL+TAB and Windowing features (hold Square to move/resize/etc.)
     1077:13628:    NavUpdateWindowing();
     1077:13628-block 42
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -:13629:
        -:13630:    // Set output flags for user application
    1077*:13631:    io.NavActive = (nav_keyboard_active || nav_gamepad_active) && g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs);
     1077:13631-block 43
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:13631-block 44
branch  2 never executed (fallthrough)
branch  3 never executed
     1077:13631-block 45
branch  4 taken 1076 (fallthrough)
branch  5 taken 1
     1076:13631-block 46
branch  6 taken 686 (fallthrough)
branch  7 taken 390
      686:13631-block 47
      391:13631-block 48
    1077*:13632:    io.NavVisible = (io.NavActive && g.NavId != 0 && g.NavCursorVisible) || (g.NavWindowingTarget != NULL);
     1077:13632-block 49
branch  0 taken 686 (fallthrough)
branch  1 taken 391
      686:13632-block 50
branch  2 taken 649 (fallthrough)
branch  3 taken 37
      649:13632-block 51
branch  4 taken 649 (fallthrough)
branch  5 taken 0
     1077:13632-block 52
branch  6 taken 0 (fallthrough)
branch  7 taken 1077
    %%%%%:13632-block 53
     1077:13632-block 54
        -:13633:
        -:13634:    // Process NavCancel input (to close a popup, get back to parent, clear focus)
     1077:13635:    NavUpdateCancelRequest();
     1077:13635-block 55
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -:13636:
        -:13637:    // Process manual activation request
     1077:13638:    g.NavActivateId = g.NavActivateDownId = g.NavActivatePressedId = 0;
     1077:13639:    g.NavActivateFlags = ImGuiActivateFlags_None;
    1077*:13640:    if (g.NavId != 0 && g.NavCursorVisible && !g.NavWindowingTarget && g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))
     1077:13640-block 56
branch  0 taken 649 (fallthrough)
branch  1 taken 428
      649:13640-block 57
branch  2 taken 0 (fallthrough)
branch  3 taken 649
    %%%%%:13640-block 58
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:13640-block 59
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%:13640-block 60
branch  8 never executed (fallthrough)
branch  9 never executed
        -:13641:    {
    #####:13642:        const bool activate_down = (nav_keyboard_active && IsKeyDown(ImGuiKey_Space, ImGuiKeyOwner_NoOwner)) || (nav_gamepad_active && IsKeyDown(ImGuiKey_NavGamepadActivate, ImGuiKeyOwner_NoOwner));
    %%%%%:13642-block 61
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13642-block 62
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%:13642-block 63
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:13642-block 64
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%:13642-block 65
branch  9 never executed (fallthrough)
branch 10 never executed
    %%%%%:13642-block 66
    %%%%%:13642-block 67
    %%%%%:13642-block 68
call   11 never executed
branch 12 never executed (fallthrough)
branch 13 never executed (throw)
    %%%%%:13642-block 69
branch 14 never executed (fallthrough)
branch 15 never executed
    %%%%%:13642-block 70
    %%%%%:13642-block 71
    #####:13643:        const bool activate_pressed = activate_down && ((nav_keyboard_active && IsKeyPressed(ImGuiKey_Space, 0, ImGuiKeyOwner_NoOwner)) || (nav_gamepad_active && IsKeyPressed(ImGuiKey_NavGamepadActivate, 0, ImGuiKeyOwner_NoOwner)));
    %%%%%:13643-block 72
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13643-block 73
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:13643-block 74
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    %%%%%:13643-block 75
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%:13643-block 76
branch  9 never executed (fallthrough)
branch 10 never executed
    %%%%%:13643-block 77
branch 11 never executed (fallthrough)
branch 12 never executed
    %%%%%:13643-block 78
    %%%%%:13643-block 79
    %%%%%:13643-block 80
call   13 never executed
branch 14 never executed (fallthrough)
branch 15 never executed (throw)
    %%%%%:13643-block 81
branch 16 never executed (fallthrough)
branch 17 never executed
    %%%%%:13643-block 82
    %%%%%:13643-block 83
    #####:13644:        const bool input_down = (nav_keyboard_active && (IsKeyDown(ImGuiKey_Enter, ImGuiKeyOwner_NoOwner) || IsKeyDown(ImGuiKey_KeypadEnter, ImGuiKeyOwner_NoOwner))) || (nav_gamepad_active && IsKeyDown(ImGuiKey_NavGamepadInput, ImGuiKeyOwner_NoOwner));
    %%%%%:13644-block 84
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13644-block 85
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%:13644-block 86
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:13644-block 87
call    7 never executed
branch  8 never executed (fallthrough)
branch  9 never executed (throw)
    %%%%%:13644-block 88
branch 10 never executed (fallthrough)
branch 11 never executed
    %%%%%:13644-block 89
branch 12 never executed (fallthrough)
branch 13 never executed
    %%%%%:13644-block 90
call   14 never executed
branch 15 never executed (fallthrough)
branch 16 never executed (throw)
    %%%%%:13644-block 91
branch 17 never executed (fallthrough)
branch 18 never executed
    %%%%%:13644-block 92
    %%%%%:13644-block 93
    #####:13645:        const bool input_pressed = input_down && ((nav_keyboard_active && (IsKeyPressed(ImGuiKey_Enter, 0, ImGuiKeyOwner_NoOwner) || IsKeyPressed(ImGuiKey_KeypadEnter, 0, ImGuiKeyOwner_NoOwner))) || (nav_gamepad_active && IsKeyPressed(ImGuiKey_NavGamepadInput, 0, ImGuiKeyOwner_NoOwner)));
    %%%%%:13645-block 94
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13645-block 95
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:13645-block 96
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    %%%%%:13645-block 97
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%:13645-block 98
call    9 never executed
branch 10 never executed (fallthrough)
branch 11 never executed (throw)
    %%%%%:13645-block 99
branch 12 never executed (fallthrough)
branch 13 never executed
    %%%%%:13645-block 100
branch 14 never executed (fallthrough)
branch 15 never executed
    %%%%%:13645-block 101
call   16 never executed
branch 17 never executed (fallthrough)
branch 18 never executed (throw)
    %%%%%:13645-block 102
branch 19 never executed (fallthrough)
branch 20 never executed
    %%%%%:13645-block 103
    %%%%%:13645-block 104
    #####:13646:        if (g.ActiveId == 0 && activate_pressed)
    %%%%%:13646-block 105
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13646-block 106
branch  2 never executed (fallthrough)
branch  3 never executed
        -:13647:        {
    #####:13648:            g.NavActivateId = g.NavId;
    #####:13649:            g.NavActivateFlags = ImGuiActivateFlags_PreferTweak;
    %%%%%:13649-block 107
        -:13650:        }
    #####:13651:        if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && input_pressed)
    %%%%%:13651-block 108
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13651-block 109
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:13651-block 110
branch  4 never executed (fallthrough)
branch  5 never executed
        -:13652:        {
    #####:13653:            g.NavActivateId = g.NavId;
    #####:13654:            g.NavActivateFlags = ImGuiActivateFlags_PreferInput;
    %%%%%:13654-block 111
        -:13655:        }
    #####:13656:        if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && (activate_down || input_down))
    %%%%%:13656-block 112
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13656-block 113
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:13656-block 114
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:13656-block 115
branch  6 never executed (fallthrough)
branch  7 never executed
    #####:13657:            g.NavActivateDownId = g.NavId;
    %%%%%:13657-block 116
    #####:13658:        if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && (activate_pressed || input_pressed))
    %%%%%:13658-block 117
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13658-block 118
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:13658-block 119
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:13658-block 120
branch  6 never executed (fallthrough)
branch  7 never executed
        -:13659:        {
    #####:13660:            g.NavActivatePressedId = g.NavId;
    #####:13661:            NavHighlightActivated(g.NavId);
    %%%%%:13661-block 121
call    0 never executed
        -:13662:        }
        -:13663:    }
     1077:13664:    if (g.NavWindow && (g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))
     1077:13664-block 122
branch  0 taken 1076 (fallthrough)
branch  1 taken 1
     1076:13664-block 123
branch  2 taken 390 (fallthrough)
branch  3 taken 686
      390:13665:        g.NavCursorVisible = false;
      390:13665-block 124
     687*:13666:    else if (g.IO.ConfigNavCursorVisibleAlways && g.NavCursorHideFrames == 0)
      687:13666-block 125
branch  0 taken 0 (fallthrough)
branch  1 taken 687
    %%%%%:13666-block 126
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:13667:        g.NavCursorVisible = true;
    %%%%%:13667-block 127
     1077:13668:    if (g.NavActivateId != 0)
     1077:13668-block 128
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####:13669:        IM_ASSERT(g.NavActivateDownId == g.NavActivateId);
    %%%%%:13669-block 129
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13669-block 130
call    2 never executed
        -:13670:
        -:13671:    // Highlight
     1077:13672:    if (g.NavHighlightActivatedTimer > 0.0f)
     1077:13672-block 131
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####:13673:        g.NavHighlightActivatedTimer = ImMax(0.0f, g.NavHighlightActivatedTimer - io.DeltaTime);
    %%%%%:13673-block 132
call    0 never executed
     1077:13674:    if (g.NavHighlightActivatedTimer == 0.0f)
     1077:13674-block 134
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:13675:        g.NavHighlightActivatedId = 0;
     1077:13675-block 135
        -:13676:
        -:13677:    // Process programmatic activation request
        -:13678:    // FIXME-NAV: Those should eventually be queued (unlike focus they don't cancel each others)
     1077:13679:    if (g.NavNextActivateId != 0)
     1077:13679-block 136
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
        -:13680:    {
    #####:13681:        g.NavActivateId = g.NavActivateDownId = g.NavActivatePressedId = g.NavNextActivateId;
    #####:13682:        g.NavActivateFlags = g.NavNextActivateFlags;
    %%%%%:13682-block 137
        -:13683:    }
     1077:13684:    g.NavNextActivateId = 0;
        -:13685:
        -:13686:    // Process move requests
     1077:13687:    NavUpdateCreateMoveRequest();
     1077:13687-block 138
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:13688:    if (g.NavMoveDir == ImGuiDir_None)
     1077:13688-block 139
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:13689:        NavUpdateCreateTabbingRequest();
     1077:13689-block 140
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:13690:    NavUpdateAnyRequestFlag();
     1077:13690-block 141
call    0 returned 1077
     1077:13691:    g.NavIdIsAlive = false;
        -:13692:
        -:13693:    // Scrolling
     1077:13694:    if (g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs) && !g.NavWindowingTarget)
branch  0 taken 1076 (fallthrough)
branch  1 taken 1
     1076:13694-block 143
branch  2 taken 686 (fallthrough)
branch  3 taken 390
      686:13694-block 144
branch  4 taken 686 (fallthrough)
branch  5 taken 0
        -:13695:    {
        -:13696:        // *Fallback* manual-scroll with Nav directional keys when window has no navigable item
      686:13697:        ImGuiWindow* window = g.NavWindow;
      686:13698:        const float scroll_speed = IM_ROUND(window->CalcFontSize() * 100 * io.DeltaTime); // We need round the scrolling speed because sub-pixel scroll isn't reliably supported.
      686:13698-block 145
call    0 returned 686
      686:13699:        const ImGuiDir move_dir = g.NavMoveDir;
     686*:13700:        if (window->DC.NavLayersActiveMask == 0x00 && window->DC.NavWindowHasScrollY && move_dir != ImGuiDir_None)
branch  0 taken 1 (fallthrough)
branch  1 taken 685
        1:13700-block 147
branch  2 taken 0 (fallthrough)
branch  3 taken 1
    %%%%%:13700-block 148
branch  4 never executed (fallthrough)
branch  5 never executed
        -:13701:        {
    #####:13702:            if (move_dir == ImGuiDir_Left || move_dir == ImGuiDir_Right)
    %%%%%:13702-block 149
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13702-block 150
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:13703:                SetScrollX(window, ImTrunc(window->Scroll.x + ((move_dir == ImGuiDir_Left) ? -1.0f : +1.0f) * scroll_speed));
    %%%%%:13703-block 151
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13703-block 152
    %%%%%:13703-block 153
    %%%%%:13703-block 154
call    2 never executed
call    3 never executed
    #####:13704:            if (move_dir == ImGuiDir_Up || move_dir == ImGuiDir_Down)
    %%%%%:13704-block 156
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13704-block 157
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:13705:                SetScrollY(window, ImTrunc(window->Scroll.y + ((move_dir == ImGuiDir_Up) ? -1.0f : +1.0f) * scroll_speed));
    %%%%%:13705-block 158
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13705-block 159
    %%%%%:13705-block 160
    %%%%%:13705-block 161
call    2 never executed
call    3 never executed
        -:13706:        }
        -:13707:
        -:13708:        // *Normal* Manual scroll with LStick
        -:13709:        // Next movement request will clamp the NavId reference rectangle to the visible area, so navigation will resume within those bounds.
      686:13710:        if (nav_gamepad_active)
      686:13710-block 163
branch  0 taken 0 (fallthrough)
branch  1 taken 686
        -:13711:        {
    #####:13712:            const ImVec2 scroll_dir = GetKeyMagnitude2d(ImGuiKey_GamepadLStickLeft, ImGuiKey_GamepadLStickRight, ImGuiKey_GamepadLStickUp, ImGuiKey_GamepadLStickDown);
    %%%%%:13712-block 164
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:13713:            const float tweak_factor = IsKeyDown(ImGuiKey_NavGamepadTweakSlow) ? 1.0f / 10.0f : IsKeyDown(ImGuiKey_NavGamepadTweakFast) ? 10.0f : 1.0f;
    %%%%%:13713-block 165
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:13713-block 166
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:13713-block 167
    %%%%%:13713-block 168
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
    %%%%%:13713-block 169
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%:13713-block 170
    %%%%%:13713-block 171
    %%%%%:13713-block 172
    #####:13714:            if (scroll_dir.x != 0.0f && window->ScrollbarX)
    %%%%%:13714-block 173
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13714-block 174
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:13715:                SetScrollX(window, ImTrunc(window->Scroll.x + scroll_dir.x * scroll_speed * tweak_factor));
    %%%%%:13715-block 175
call    0 never executed
call    1 never executed
    #####:13716:            if (scroll_dir.y != 0.0f)
    %%%%%:13716-block 177
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:13717:                SetScrollY(window, ImTrunc(window->Scroll.y + scroll_dir.y * scroll_speed * tweak_factor));
    %%%%%:13717-block 178
call    0 never executed
call    1 never executed
        -:13718:        }
        -:13719:    }
        -:13720:
        -:13721:    // Always prioritize mouse highlight if navigation is disabled
    1077*:13722:    if (!nav_keyboard_active && !nav_gamepad_active)
     1077:13722-block 181
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:13722-block 182
branch  2 never executed (fallthrough)
branch  3 never executed
        -:13723:    {
    #####:13724:        g.NavCursorVisible = false;
    #####:13725:        g.NavHighlightItemUnderNav = set_mouse_pos = false;
    %%%%%:13725-block 183
        -:13726:    }
        -:13727:
        -:13728:    // Update mouse position if requested
        -:13729:    // (This will take into account the possibility that a Scroll was queued in the window to offset our absolute mouse position before scroll has been applied)
    1077*:13730:    if (set_mouse_pos && io.ConfigNavMoveSetMousePos && (io.BackendFlags & ImGuiBackendFlags_HasSetMousePos))
     1077:13730-block 184
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:13730-block 185
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:13730-block 186
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:13731:        TeleportMousePos(NavCalcPreferredRefPos());
    %%%%%:13731-block 187
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:13731-block 188
call    3 never executed
    $$$$$:13731-block 192
        -:13732:
        -:13733:    // [DEBUG]
     1077:13734:    g.NavScoringDebugCount = 0;
        -:13735:#if IMGUI_DEBUG_NAV_RECTS
        -:13736:    if (ImGuiWindow* debug_window = g.NavWindow)
        -:13737:    {
        -:13738:        ImDrawList* draw_list = GetForegroundDrawList(debug_window);
        -:13739:        int layer = g.NavLayer; /* for (int layer = 0; layer < 2; layer++)*/ { ImRect r = WindowRectRelToAbs(debug_window, debug_window->NavRectRel[layer]); draw_list->AddRect(r.Min, r.Max, IM_COL32(255, 200, 0, 255)); }
        -:13740:        //if (1) { ImU32 col = (!debug_window->Hidden) ? IM_COL32(255,0,255,255) : IM_COL32(255,0,0,255); ImVec2 p = NavCalcPreferredRefPos(); char buf[32]; ImFormatString(buf, 32, "%d", g.NavLayer); draw_list->AddCircleFilled(p, 3.0f, col); draw_list->AddText(NULL, 13.0f, p + ImVec2(8,-4), col, buf); }
        -:13741:    }
        -:13742:#endif
     1077:13743:}
     1077:13743-block 190
        -:13744:
function _ZN5ImGui25NavInitRequestApplyResultEv called 1 returned 100% blocks executed 67%
        1:13745:void ImGui::NavInitRequestApplyResult()
        -:13746:{
        -:13747:    // In very rare cases g.NavWindow may be null (e.g. clearing focus after requesting an init request, which does happen when releasing Alt while clicking on void)
        1:13748:    ImGuiContext& g = *GImGui;
        1:13749:    if (!g.NavWindow)
        1:13749-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:13750:        return;
    %%%%%:13750-block 3
        -:13751:
        1:13752:    ImGuiNavItemData* result = &g.NavInitResult;
        1:13753:    if (g.NavId != result->ID)
        1:13753-block 4
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -:13754:    {
        1:13755:        g.NavJustMovedFromFocusScopeId = g.NavFocusScopeId;
        1:13756:        g.NavJustMovedToId = result->ID;
        1:13757:        g.NavJustMovedToFocusScopeId = result->FocusScopeId;
        1:13758:        g.NavJustMovedToKeyMods = 0;
        1:13759:        g.NavJustMovedToIsTabbing = false;
        1:13760:        g.NavJustMovedToHasSelectionData = (result->ItemFlags & ImGuiItemFlags_HasSelectionUserData) != 0;
        1:13760-block 5
        -:13761:    }
        -:13762:
        -:13763:    // Apply result from previous navigation init request (will typically select the first item, unless SetItemDefaultFocus() has been called)
        -:13764:    // FIXME-NAV: On _NavFlattened windows, g.NavWindow will only be updated during subsequent frame. Not a problem currently.
       1*:13765:    IMGUI_DEBUG_LOG_NAV("[nav] NavInitRequest: ApplyResult: NavID 0x%08X in Layer %d Window \"%s\"\n", result->ID, g.NavLayer, g.NavWindow->Name);
        1:13765-block 6
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%:13765-block 7
call    2 never executed
        1:13766:    SetNavID(result->ID, g.NavLayer, result->FocusScopeId, result->RectRel);
        1:13766-block 8
call    0 returned 1
        1:13767:    g.NavIdIsAlive = true; // Mark as alive from previous frame as we got a result
        1:13768:    if (result->SelectionUserData != ImGuiSelectionUserData_Invalid)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:13769:        g.NavLastValidSelectionUserData = result->SelectionUserData;
    %%%%%:13769-block 10
        1:13770:    if (g.NavInitRequestFromMove)
        1:13770-block 11
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:13771:        SetNavCursorVisibleAfterMove();
    %%%%%:13771-block 12
call    0 never executed
        -:13772:}
        -:13773:
        -:13774:// Bias scoring rect ahead of scoring + update preferred pos (if missing) using source position
function _ZL18NavBiasScoringRectR6ImRectR6ImVec28ImGuiDiri called 0 returned 0% blocks executed 0%
    #####:13775:static void NavBiasScoringRect(ImRect& r, ImVec2& preferred_pos_rel, ImGuiDir move_dir, ImGuiNavMoveFlags move_flags)
        -:13776:{
        -:13777:    // Bias initial rect
    #####:13778:    ImGuiContext& g = *GImGui;
    #####:13779:    const ImVec2 rel_to_abs_offset = g.NavWindow->DC.CursorStartPos;
        -:13780:
        -:13781:    // Initialize bias on departure if we don't have any. So mouse-click + arrow will record bias.
        -:13782:    // - We default to L/U bias, so moving down from a large source item into several columns will land on left-most column.
        -:13783:    // - But each successful move sets new bias on one axis, only cleared when using mouse.
    #####:13784:    if ((move_flags & ImGuiNavMoveFlags_Forwarded) == 0)
    %%%%%:13784-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -:13785:    {
    #####:13786:        if (preferred_pos_rel.x == FLT_MAX)
    %%%%%:13786-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:13787:            preferred_pos_rel.x = ImMin(r.Min.x + 1.0f, r.Max.x) - rel_to_abs_offset.x;
    %%%%%:13787-block 4
call    0 never executed
    #####:13788:        if (preferred_pos_rel.y == FLT_MAX)
    %%%%%:13788-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:13789:            preferred_pos_rel.y = r.GetCenter().y - rel_to_abs_offset.y;
    %%%%%:13789-block 7
call    0 never executed
        -:13790:    }
        -:13791:
        -:13792:    // Apply general bias on the other axis
    #####:13793:    if ((move_dir == ImGuiDir_Up || move_dir == ImGuiDir_Down) && preferred_pos_rel.x != FLT_MAX)
    %%%%%:13793-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13793-block 10
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:13793-block 11
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:13794:        r.Min.x = r.Max.x = preferred_pos_rel.x + rel_to_abs_offset.x;
    %%%%%:13794-block 12
    #####:13795:    else if ((move_dir == ImGuiDir_Left || move_dir == ImGuiDir_Right) && preferred_pos_rel.y != FLT_MAX)
    %%%%%:13795-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13795-block 14
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:13795-block 15
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:13796:        r.Min.y = r.Max.y = preferred_pos_rel.y + rel_to_abs_offset.y;
    %%%%%:13796-block 16
    #####:13797:}
        -:13798:
function _ZN5ImGuiL26NavUpdateCreateMoveRequestEv called 1077 returned 100% blocks executed 42%
     1077:13799:void ImGui::NavUpdateCreateMoveRequest()
        -:13800:{
     1077:13801:    ImGuiContext& g = *GImGui;
     1077:13802:    ImGuiIO& io = g.IO;
     1077:13803:    ImGuiWindow* window = g.NavWindow;
    1077*:13804:    const bool nav_gamepad_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (io.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
     1077:13804-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:13804-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:13804-block 4
     1077:13804-block 5
     1077:13805:    const bool nav_keyboard_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
        -:13806:
    1077*:13807:    if (g.NavMoveForwardToNextFrame && window != NULL)
     1077:13807-block 6
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:13807-block 7
branch  2 never executed (fallthrough)
branch  3 never executed
        -:13808:    {
        -:13809:        // Forwarding previous request (which has been modified, e.g. wrap around menus rewrite the requests with a starting rectangle at the other side of the window)
        -:13810:        // (preserve most state, which were already set by the NavMoveRequestForward() function)
    #####:13811:        IM_ASSERT(g.NavMoveDir != ImGuiDir_None && g.NavMoveClipDir != ImGuiDir_None);
    %%%%%:13811-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13811-block 9
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:13811-block 10
    %%%%%:13811-block 11
call    4 never executed
    #####:13812:        IM_ASSERT(g.NavMoveFlags & ImGuiNavMoveFlags_Forwarded);
    %%%%%:13812-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13812-block 13
call    2 never executed
    #####:13813:        IMGUI_DEBUG_LOG_NAV("[nav] NavMoveRequestForward %d\n", g.NavMoveDir);
    %%%%%:13813-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13813-block 15
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
        -:13814:    }
        -:13815:    else
        -:13816:    {
        -:13817:        // Initiate directional inputs request
     1077:13818:        g.NavMoveDir = ImGuiDir_None;
     1077:13819:        g.NavMoveFlags = ImGuiNavMoveFlags_None;
     1077:13820:        g.NavMoveScrollFlags = ImGuiScrollFlags_None;
     1077:13821:        if (window && !g.NavWindowingTarget && !(window->Flags & ImGuiWindowFlags_NoNavInputs))
     1077:13821-block 17
branch  0 taken 1076 (fallthrough)
branch  1 taken 1
     1076:13821-block 18
branch  2 taken 1076 (fallthrough)
branch  3 taken 0
     1076:13821-block 19
branch  4 taken 686 (fallthrough)
branch  5 taken 390
        -:13822:        {
      686:13823:            const ImGuiInputFlags repeat_mode = ImGuiInputFlags_Repeat | (ImGuiInputFlags)ImGuiInputFlags_RepeatRateNavMove;
     686*:13824:            if (!IsActiveIdUsingNavDir(ImGuiDir_Left)  && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadLeft,  repeat_mode, ImGuiKeyOwner_NoOwner)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_LeftArrow,  repeat_mode, ImGuiKeyOwner_NoOwner)))) { g.NavMoveDir = ImGuiDir_Left; }
      686:13824-block 20
call    0 returned 686
branch  1 taken 671 (fallthrough)
branch  2 taken 15
      671:13824-block 22
branch  3 taken 0 (fallthrough)
branch  4 taken 671
    %%%%%:13824-block 23
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
    %%%%%:13824-block 24
branch  8 never executed (fallthrough)
branch  9 never executed
      671:13824-block 25
branch 10 taken 671 (fallthrough)
branch 11 taken 0
      671:13824-block 26
call   12 returned 671
branch 13 taken 671 (fallthrough)
branch 14 taken 0 (throw)
      671:13824-block 27
branch 15 taken 0 (fallthrough)
branch 16 taken 671
    %%%%%:13824-block 28
      686:13824-block 29
      686:13824-block 30
branch 17 taken 0 (fallthrough)
branch 18 taken 686
    %%%%%:13824-block 31
     686*:13825:            if (!IsActiveIdUsingNavDir(ImGuiDir_Right) && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadRight, repeat_mode, ImGuiKeyOwner_NoOwner)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_RightArrow, repeat_mode, ImGuiKeyOwner_NoOwner)))) { g.NavMoveDir = ImGuiDir_Right; }
      686:13825-block 32
call    0 returned 686
branch  1 taken 671 (fallthrough)
branch  2 taken 15
      671:13825-block 34
branch  3 taken 0 (fallthrough)
branch  4 taken 671
    %%%%%:13825-block 35
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
    %%%%%:13825-block 36
branch  8 never executed (fallthrough)
branch  9 never executed
      671:13825-block 37
branch 10 taken 671 (fallthrough)
branch 11 taken 0
      671:13825-block 38
call   12 returned 671
branch 13 taken 671 (fallthrough)
branch 14 taken 0 (throw)
      671:13825-block 39
branch 15 taken 0 (fallthrough)
branch 16 taken 671
    %%%%%:13825-block 40
      686:13825-block 41
      686:13825-block 42
branch 17 taken 0 (fallthrough)
branch 18 taken 686
    %%%%%:13825-block 43
     686*:13826:            if (!IsActiveIdUsingNavDir(ImGuiDir_Up)    && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadUp,    repeat_mode, ImGuiKeyOwner_NoOwner)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_UpArrow,    repeat_mode, ImGuiKeyOwner_NoOwner)))) { g.NavMoveDir = ImGuiDir_Up; }
      686:13826-block 44
call    0 returned 686
branch  1 taken 671 (fallthrough)
branch  2 taken 15
      671:13826-block 46
branch  3 taken 0 (fallthrough)
branch  4 taken 671
    %%%%%:13826-block 47
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
    %%%%%:13826-block 48
branch  8 never executed (fallthrough)
branch  9 never executed
      671:13826-block 49
branch 10 taken 671 (fallthrough)
branch 11 taken 0
      671:13826-block 50
call   12 returned 671
branch 13 taken 671 (fallthrough)
branch 14 taken 0 (throw)
      671:13826-block 51
branch 15 taken 0 (fallthrough)
branch 16 taken 671
    %%%%%:13826-block 52
      686:13826-block 53
      686:13826-block 54
branch 17 taken 0 (fallthrough)
branch 18 taken 686
    %%%%%:13826-block 55
     686*:13827:            if (!IsActiveIdUsingNavDir(ImGuiDir_Down)  && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadDown,  repeat_mode, ImGuiKeyOwner_NoOwner)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_DownArrow,  repeat_mode, ImGuiKeyOwner_NoOwner)))) { g.NavMoveDir = ImGuiDir_Down; }
      686:13827-block 56
call    0 returned 686
branch  1 taken 671 (fallthrough)
branch  2 taken 15
      671:13827-block 58
branch  3 taken 0 (fallthrough)
branch  4 taken 671
    %%%%%:13827-block 59
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
    %%%%%:13827-block 60
branch  8 never executed (fallthrough)
branch  9 never executed
      671:13827-block 61
branch 10 taken 671 (fallthrough)
branch 11 taken 0
      671:13827-block 62
call   12 returned 671
branch 13 taken 671 (fallthrough)
branch 14 taken 0 (throw)
      671:13827-block 63
branch 15 taken 0 (fallthrough)
branch 16 taken 671
    %%%%%:13827-block 64
      686:13827-block 65
      686:13827-block 66
branch 17 taken 0 (fallthrough)
branch 18 taken 686
    %%%%%:13827-block 67
        -:13828:        }
     1077:13829:        g.NavMoveClipDir = g.NavMoveDir;
     1077:13830:        g.NavScoringNoClipRect = ImRect(+FLT_MAX, +FLT_MAX, -FLT_MAX, -FLT_MAX);
     1077:13830-block 68
call    0 returned 1077
        -:13831:    }
        -:13832:
        -:13833:    // Update PageUp/PageDown/Home/End scroll
        -:13834:    // FIXME-NAV: Consider enabling those keys even without the master ImGuiConfigFlags_NavEnableKeyboard flag?
     1077:13835:    float scoring_rect_offset_y = 0.0f;
     1077:13836:    if (window && g.NavMoveDir == ImGuiDir_None && nav_keyboard_active)
     1077:13836-block 70
branch  0 taken 1076 (fallthrough)
branch  1 taken 1
     1076:13836-block 71
branch  2 taken 1076 (fallthrough)
branch  3 taken 0
     1076:13836-block 72
branch  4 taken 1076 (fallthrough)
branch  5 taken 0
     1076:13837:        scoring_rect_offset_y = NavUpdatePageUpPageDown();
     1076:13837-block 73
call    0 returned 1076
branch  1 taken 1076 (fallthrough)
branch  2 taken 0 (throw)
     1076:13837-block 74
     1077:13838:    if (scoring_rect_offset_y != 0.0f)
     1077:13838-block 75
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
        -:13839:    {
    #####:13840:        g.NavScoringNoClipRect = window->InnerRect;
    #####:13841:        g.NavScoringNoClipRect.TranslateY(scoring_rect_offset_y);
    %%%%%:13841-block 76
call    0 never executed
        -:13842:    }
        -:13843:
        -:13844:    // [DEBUG] Always send a request when holding CTRL. Hold CTRL + Arrow change the direction.
        -:13845:#if IMGUI_DEBUG_NAV_SCORING
        -:13846:    //if (io.KeyCtrl && IsKeyPressed(ImGuiKey_C))
        -:13847:    //    g.NavMoveDirForDebug = (ImGuiDir)((g.NavMoveDirForDebug + 1) & 3);
        -:13848:    if (io.KeyCtrl)
        -:13849:    {
        -:13850:        if (g.NavMoveDir == ImGuiDir_None)
        -:13851:            g.NavMoveDir = g.NavMoveDirForDebug;
        -:13852:        g.NavMoveClipDir = g.NavMoveDir;
        -:13853:        g.NavMoveFlags |= ImGuiNavMoveFlags_DebugNoResult;
        -:13854:    }
        -:13855:#endif
        -:13856:
        -:13857:    // Submit
     1077:13858:    g.NavMoveForwardToNextFrame = false;
     1077:13859:    if (g.NavMoveDir != ImGuiDir_None)
     1077:13859-block 77
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####:13860:        NavMoveRequestSubmit(g.NavMoveDir, g.NavMoveClipDir, g.NavMoveFlags, g.NavMoveScrollFlags);
    %%%%%:13860-block 78
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:13861:
        -:13862:    // Moving with no reference triggers an init request (will be used as a fallback if the direction fails to find a match)
    1077*:13863:    if (g.NavMoveSubmitted && g.NavId == 0)
     1077:13863-block 79
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:13863-block 80
branch  2 never executed (fallthrough)
branch  3 never executed
        -:13864:    {
    #####:13865:        IMGUI_DEBUG_LOG_NAV("[nav] NavInitRequest: from move, window \"%s\", layer=%d\n", window ? window->Name : "<NULL>", g.NavLayer);
    %%%%%:13865-block 81
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13865-block 82
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:13865-block 83
    %%%%%:13865-block 84
    %%%%%:13865-block 85
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    #####:13866:        g.NavInitRequest = g.NavInitRequestFromMove = true;
    #####:13867:        g.NavInitResult.ID = 0;
    #####:13868:        if (g.IO.ConfigNavCursorVisibleAuto)
    %%%%%:13868-block 86
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:13869:            g.NavCursorVisible = true;
    %%%%%:13869-block 87
        -:13870:    }
        -:13871:
        -:13872:    // When using gamepad, we project the reference nav bounding box into window visible area.
        -:13873:    // This is to allow resuming navigation inside the visible area after doing a large amount of scrolling,
        -:13874:    // since with gamepad all movements are relative (can't focus a visible object like we can with the mouse).
    1077*:13875:    if (g.NavMoveSubmitted && g.NavInputSource == ImGuiInputSource_Gamepad && g.NavLayer == ImGuiNavLayer_Main && window != NULL)// && (g.NavMoveFlags & ImGuiNavMoveFlags_Forwarded))
     1077:13875-block 88
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:13875-block 89
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:13875-block 90
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:13875-block 91
branch  6 never executed (fallthrough)
branch  7 never executed
        -:13876:    {
    #####:13877:        bool clamp_x = (g.NavMoveFlags & (ImGuiNavMoveFlags_LoopX | ImGuiNavMoveFlags_WrapX)) == 0;
    #####:13878:        bool clamp_y = (g.NavMoveFlags & (ImGuiNavMoveFlags_LoopY | ImGuiNavMoveFlags_WrapY)) == 0;
    #####:13879:        ImRect inner_rect_rel = WindowRectAbsToRel(window, ImRect(window->InnerRect.Min - ImVec2(1, 1), window->InnerRect.Max + ImVec2(1, 1)));
    %%%%%:13879-block 92
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -:13880:
        -:13881:        // Take account of changing scroll to handle triggering a new move request on a scrolling frame. (#6171)
        -:13882:        // Otherwise 'inner_rect_rel' would be off on the move result frame.
    #####:13883:        inner_rect_rel.Translate(CalcNextScrollFromScrollTargetAndClamp(window) - window->Scroll);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:13883-block 99
call    3 never executed
call    4 never executed
    $$$$$:13883-block 146
    $$$$$:13883-block 147
        -:13884:
    #####:13885:        if ((clamp_x || clamp_y) && !inner_rect_rel.Contains(window->NavRectRel[g.NavLayer]))
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13885-block 102
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:13885-block 103
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:13885-block 105
    %%%%%:13885-block 106
    %%%%%:13885-block 107
branch  7 never executed (fallthrough)
branch  8 never executed
        -:13886:        {
    #####:13887:            IMGUI_DEBUG_LOG_NAV("[nav] NavMoveRequest: clamp NavRectRel for gamepad move\n");
    %%%%%:13887-block 108
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13887-block 109
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####:13888:            float pad_x = ImMin(inner_rect_rel.GetWidth(), window->CalcFontSize() * 0.5f);
    %%%%%:13888-block 110
call    0 never executed
call    1 never executed
call    2 never executed
    #####:13889:            float pad_y = ImMin(inner_rect_rel.GetHeight(), window->CalcFontSize() * 0.5f); // Terrible approximation for the intent of starting navigation from first fully visible item
call    0 never executed
call    1 never executed
call    2 never executed
    #####:13890:            inner_rect_rel.Min.x = clamp_x ? (inner_rect_rel.Min.x + pad_x) : -FLT_MAX;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13890-block 117
    %%%%%:13890-block 118
    #####:13891:            inner_rect_rel.Max.x = clamp_x ? (inner_rect_rel.Max.x - pad_x) : +FLT_MAX;
    %%%%%:13891-block 119
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13891-block 120
    %%%%%:13891-block 121
    #####:13892:            inner_rect_rel.Min.y = clamp_y ? (inner_rect_rel.Min.y + pad_y) : -FLT_MAX;
    %%%%%:13892-block 122
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13892-block 123
    %%%%%:13892-block 124
    #####:13893:            inner_rect_rel.Max.y = clamp_y ? (inner_rect_rel.Max.y - pad_y) : +FLT_MAX;
    %%%%%:13893-block 125
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13893-block 126
    %%%%%:13893-block 127
    #####:13894:            window->NavRectRel[g.NavLayer].ClipWithFull(inner_rect_rel);
    %%%%%:13894-block 128
call    0 never executed
    #####:13895:            g.NavId = 0;
        -:13896:        }
        -:13897:    }
        -:13898:
        -:13899:    // For scoring we use a single segment on the left side our current item bounding box (not touching the edge to avoid box overlap with zero-spaced items)
     1077:13900:    ImRect scoring_rect;
     1077:13901:    if (window != NULL)
     1077:13901-block 131
branch  0 taken 1076 (fallthrough)
branch  1 taken 1
        -:13902:    {
    1076*:13903:        ImRect nav_rect_rel = !window->NavRectRel[g.NavLayer].IsInverted() ? window->NavRectRel[g.NavLayer] : ImRect(0, 0, 0, 0);
     1076:13903-block 132
call    0 returned 1076
branch  1 taken 1076 (fallthrough)
branch  2 taken 0
     1076:13903-block 134
    %%%%%:13903-block 135
call    3 never executed
     1076:13904:        scoring_rect = WindowRectRelToAbs(window, nav_rect_rel);
     1076:13904-block 136
call    0 returned 1076
     1076:13905:        scoring_rect.TranslateY(scoring_rect_offset_y);
call    0 returned 1076
     1076:13906:        if (g.NavMoveSubmitted)
branch  0 taken 0 (fallthrough)
branch  1 taken 1076
    #####:13907:            NavBiasScoringRect(scoring_rect, window->RootWindowForNav->NavPreferredScoringPosRel[g.NavLayer], g.NavMoveDir, g.NavMoveFlags);
    %%%%%:13907-block 139
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    1076*:13908:        IM_ASSERT(!scoring_rect.IsInverted()); // Ensure we have a non-inverted bounding box here will allow us to remove extraneous ImFabs() calls in NavScoreItem().
     1076:13908-block 140
call    0 returned 1076
branch  1 taken 0 (fallthrough)
branch  2 taken 1076
    %%%%%:13908-block 142
call    3 never executed
        -:13909:        //GetForegroundDrawList()->AddRect(scoring_rect.Min, scoring_rect.Max, IM_COL32(255,200,0,255)); // [DEBUG]
        -:13910:        //if (!g.NavScoringNoClipRect.IsInverted()) { GetForegroundDrawList()->AddRect(g.NavScoringNoClipRect.Min, g.NavScoringNoClipRect.Max, IM_COL32(255, 200, 0, 255)); } // [DEBUG]
        -:13911:    }
     1077:13912:    g.NavScoringRect = scoring_rect;
     1077:13913:    g.NavScoringNoClipRect.Add(scoring_rect);
     1077:13913-block 144
call    0 returned 1077
     1077:13914:}
        -:13915:
function _ZN5ImGuiL29NavUpdateCreateTabbingRequestEv called 1077 returned 100% blocks executed 31%
     1077:13916:void ImGui::NavUpdateCreateTabbingRequest()
        -:13917:{
     1077:13918:    ImGuiContext& g = *GImGui;
     1077:13919:    ImGuiWindow* window = g.NavWindow;
    1077*:13920:    IM_ASSERT(g.NavMoveDir == ImGuiDir_None);
     1077:13920-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:13920-block 3
call    2 never executed
     1077:13921:    if (window == NULL || g.NavWindowingTarget != NULL || (window->Flags & ImGuiWindowFlags_NoNavInputs))
     1077:13921-block 4
branch  0 taken 1076 (fallthrough)
branch  1 taken 1
     1076:13921-block 5
branch  2 taken 1076 (fallthrough)
branch  3 taken 0
     1076:13921-block 6
branch  4 taken 390 (fallthrough)
branch  5 taken 686
      391:13922:        return;
      391:13922-block 7
        -:13923:
     686*:13924:    const bool tab_pressed = IsKeyPressed(ImGuiKey_Tab, ImGuiInputFlags_Repeat, ImGuiKeyOwner_NoOwner) && !g.IO.KeyCtrl && !g.IO.KeyAlt;
      686:13924-block 8
call    0 returned 686
branch  1 taken 0 (fallthrough)
branch  2 taken 686
    %%%%%:13924-block 10
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:13924-block 11
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:13924-block 12
      686:13924-block 13
      686:13925:    if (!tab_pressed)
      686:13925-block 14
branch  0 taken 686 (fallthrough)
branch  1 taken 0
      686:13926:        return;
      686:13926-block 15
        -:13927:
        -:13928:    // Initiate tabbing request
        -:13929:    // (this is ALWAYS ENABLED, regardless of ImGuiConfigFlags_NavEnableKeyboard flag!)
        -:13930:    // See NavProcessItemForTabbingRequest() for a description of the various forward/backward tabbing cases with and without wrapping.
    #####:13931:    const bool nav_keyboard_active = (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
    #####:13932:    if (nav_keyboard_active)
    %%%%%:13932-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:13933:        g.NavTabbingDir = g.IO.KeyShift ? -1 : (g.NavCursorVisible == false && g.ActiveId == 0) ? 0 : +1;
    %%%%%:13933-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13933-block 18
    %%%%%:13933-block 19
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:13933-block 20
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:13933-block 21
    %%%%%:13933-block 22
    %%%%%:13933-block 23
    %%%%%:13933-block 24
        -:13934:    else
    #####:13935:        g.NavTabbingDir = g.IO.KeyShift ? -1 : (g.ActiveId == 0) ? 0 : +1;
    %%%%%:13935-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13935-block 26
    %%%%%:13935-block 27
    %%%%%:13935-block 28
    #####:13936:    ImGuiNavMoveFlags move_flags = ImGuiNavMoveFlags_IsTabbing | ImGuiNavMoveFlags_Activate;
    #####:13937:    ImGuiScrollFlags scroll_flags = window->Appearing ? ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_AlwaysCenterY : ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_KeepVisibleEdgeY;
    %%%%%:13937-block 29
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13937-block 30
    %%%%%:13937-block 31
    #####:13938:    ImGuiDir clip_dir = (g.NavTabbingDir < 0) ? ImGuiDir_Up : ImGuiDir_Down;
    %%%%%:13938-block 32
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13938-block 33
    %%%%%:13938-block 34
    #####:13939:    NavMoveRequestSubmit(ImGuiDir_None, clip_dir, move_flags, scroll_flags); // FIXME-NAV: Once we refactor tabbing, add LegacyApi flag to not activate non-inputable.
    %%%%%:13939-block 35
call    0 never executed
    #####:13940:    g.NavTabbingCounter = -1;
        -:13941:}
        -:13942:
        -:13943:// Apply result from previous frame navigation directional move request. Always called from NavUpdate()
function _ZN5ImGui25NavMoveRequestApplyResultEv called 0 returned 0% blocks executed 0%
    #####:13944:void ImGui::NavMoveRequestApplyResult()
        -:13945:{
    #####:13946:    ImGuiContext& g = *GImGui;
        -:13947:#if IMGUI_DEBUG_NAV_SCORING
        -:13948:    if (g.NavMoveFlags & ImGuiNavMoveFlags_DebugNoResult) // [DEBUG] Scoring all items in NavWindow at all times
        -:13949:        return;
        -:13950:#endif
        -:13951:
        -:13952:    // Select which result to use
    #####:13953:    ImGuiNavItemData* result = (g.NavMoveResultLocal.ID != 0) ? &g.NavMoveResultLocal : (g.NavMoveResultOther.ID != 0) ? &g.NavMoveResultOther : NULL;
    %%%%%:13953-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13953-block 3
    %%%%%:13953-block 4
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:13953-block 5
    %%%%%:13953-block 6
    %%%%%:13953-block 7
        -:13954:
        -:13955:    // Tabbing forward wrap
    #####:13956:    if ((g.NavMoveFlags & ImGuiNavMoveFlags_IsTabbing) && result == NULL)
    %%%%%:13956-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13956-block 9
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:13957:        if ((g.NavTabbingCounter == 1 || g.NavTabbingDir == 0) && g.NavTabbingResultFirst.ID)
    %%%%%:13957-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13957-block 11
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:13957-block 12
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:13958:            result = &g.NavTabbingResultFirst;
    %%%%%:13958-block 13
        -:13959:
        -:13960:    // In a situation when there are no results but NavId != 0, re-enable the Navigation highlight (because g.NavId is not considered as a possible result)
    #####:13961:    const ImGuiAxis axis = (g.NavMoveDir == ImGuiDir_Up || g.NavMoveDir == ImGuiDir_Down) ? ImGuiAxis_Y : ImGuiAxis_X;
    %%%%%:13961-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13961-block 15
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:13961-block 16
    %%%%%:13961-block 17
    #####:13962:    if (result == NULL)
    %%%%%:13962-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
        -:13963:    {
    #####:13964:        if (g.NavMoveFlags & ImGuiNavMoveFlags_IsTabbing)
    %%%%%:13964-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:13965:            g.NavMoveFlags |= ImGuiNavMoveFlags_NoSetNavCursorVisible;
    %%%%%:13965-block 20
    #####:13966:        if (g.NavId != 0 && (g.NavMoveFlags & ImGuiNavMoveFlags_NoSetNavCursorVisible) == 0)
    %%%%%:13966-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13966-block 22
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:13967:            SetNavCursorVisibleAfterMove();
    %%%%%:13967-block 23
call    0 never executed
    #####:13968:        NavClearPreferredPosForAxis(axis); // On a failed move, clear preferred pos for this axis.
    %%%%%:13968-block 24
call    0 never executed
    #####:13969:        IMGUI_DEBUG_LOG_NAV("[nav] NavMoveSubmitted but not led to a result!\n");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13969-block 26
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####:13970:        return;
    %%%%%:13970-block 27
        -:13971:    }
        -:13972:
        -:13973:    // PageUp/PageDown behavior first jumps to the bottom/top mostly visible item, _otherwise_ use the result from the previous/next page.
    #####:13974:    if (g.NavMoveFlags & ImGuiNavMoveFlags_AlsoScoreVisibleSet)
    %%%%%:13974-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:13975:        if (g.NavMoveResultLocalVisible.ID != 0 && g.NavMoveResultLocalVisible.ID != g.NavId)
    %%%%%:13975-block 29
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13975-block 30
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:13976:            result = &g.NavMoveResultLocalVisible;
    %%%%%:13976-block 31
        -:13977:
        -:13978:    // Maybe entering a flattened child from the outside? In this case solve the tie using the regular scoring rules.
    #####:13979:    if (result != &g.NavMoveResultOther && g.NavMoveResultOther.ID != 0 && g.NavMoveResultOther.Window->ParentWindow == g.NavWindow)
    %%%%%:13979-block 32
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13979-block 33
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:13979-block 34
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:13980:        if ((g.NavMoveResultOther.DistBox < result->DistBox) || (g.NavMoveResultOther.DistBox == result->DistBox && g.NavMoveResultOther.DistCenter < result->DistCenter))
    %%%%%:13980-block 35
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13980-block 36
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:13980-block 37
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:13981:            result = &g.NavMoveResultOther;
    %%%%%:13981-block 38
    #####:13982:    IM_ASSERT(g.NavWindow && result->Window);
    %%%%%:13982-block 39
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13982-block 40
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:13982-block 41
    %%%%%:13982-block 42
call    4 never executed
        -:13983:
        -:13984:    // Scroll to keep newly navigated item fully into view.
    #####:13985:    if (g.NavLayer == ImGuiNavLayer_Main)
    %%%%%:13985-block 43
branch  0 never executed (fallthrough)
branch  1 never executed
        -:13986:    {
    #####:13987:        ImRect rect_abs = WindowRectRelToAbs(result->Window, result->RectRel);
    %%%%%:13987-block 44
call    0 never executed
    #####:13988:        ScrollToRectEx(result->Window, rect_abs, g.NavMoveScrollFlags);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:13989:
    #####:13990:        if (g.NavMoveFlags & ImGuiNavMoveFlags_ScrollToEdgeY)
    %%%%%:13990-block 46
branch  0 never executed (fallthrough)
branch  1 never executed
        -:13991:        {
        -:13992:            // FIXME: Should remove this? Or make more precise: use ScrollToRectEx() with edge?
    #####:13993:            float scroll_target = (g.NavMoveDir == ImGuiDir_Up) ? result->Window->ScrollMax.y : 0.0f;
    %%%%%:13993-block 47
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:13993-block 48
    %%%%%:13993-block 49
    #####:13994:            SetScrollY(result->Window, scroll_target);
    %%%%%:13994-block 50
call    0 never executed
        -:13995:        }
        -:13996:    }
        -:13997:
    #####:13998:    if (g.NavWindow != result->Window)
    %%%%%:13998-block 52
branch  0 never executed (fallthrough)
branch  1 never executed
        -:13999:    {
    #####:14000:        IMGUI_DEBUG_LOG_FOCUS("[focus] NavMoveRequest: SetNavWindow(\"%s\")\n", result->Window->Name);
    %%%%%:14000-block 53
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14000-block 54
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####:14001:        g.NavWindow = result->Window;
    #####:14002:        g.NavLastValidSelectionUserData = ImGuiSelectionUserData_Invalid;
    %%%%%:14002-block 55
        -:14003:    }
        -:14004:
        -:14005:    // Clear active id unless requested not to
        -:14006:    // FIXME: ImGuiNavMoveFlags_NoClearActiveId is currently unused as we don't have a clear strategy to preserve active id after interaction,
        -:14007:    // so this is mostly provided as a gateway for further experiments (see #1418, #2890)
    #####:14008:    if (g.ActiveId != result->ID && (g.NavMoveFlags & ImGuiNavMoveFlags_NoClearActiveId) == 0)
    %%%%%:14008-block 56
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14008-block 57
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:14009:        ClearActiveID();
    %%%%%:14009-block 58
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:14010:
        -:14011:    // Don't set NavJustMovedToId if just landed on the same spot (which may happen with ImGuiNavMoveFlags_AllowCurrentNavId)
        -:14012:    // PageUp/PageDown however sets always set NavJustMovedTo (vs Home/End which doesn't) mimicking Windows behavior.
    #####:14013:    if ((g.NavId != result->ID || (g.NavMoveFlags & ImGuiNavMoveFlags_IsPageMove)) && (g.NavMoveFlags & ImGuiNavMoveFlags_NoSelect) == 0)
    %%%%%:14013-block 59
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14013-block 60
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:14013-block 61
branch  4 never executed (fallthrough)
branch  5 never executed
        -:14014:    {
    #####:14015:        g.NavJustMovedFromFocusScopeId = g.NavFocusScopeId;
    #####:14016:        g.NavJustMovedToId = result->ID;
    #####:14017:        g.NavJustMovedToFocusScopeId = result->FocusScopeId;
    #####:14018:        g.NavJustMovedToKeyMods = g.NavMoveKeyMods;
    #####:14019:        g.NavJustMovedToIsTabbing = (g.NavMoveFlags & ImGuiNavMoveFlags_IsTabbing) != 0;
    #####:14020:        g.NavJustMovedToHasSelectionData = (result->ItemFlags & ImGuiItemFlags_HasSelectionUserData) != 0;
    %%%%%:14020-block 62
        -:14021:        //IMGUI_DEBUG_LOG_NAV("[nav] NavJustMovedFromFocusScopeId = 0x%08X, NavJustMovedToFocusScopeId = 0x%08X\n", g.NavJustMovedFromFocusScopeId, g.NavJustMovedToFocusScopeId);
        -:14022:    }
        -:14023:
        -:14024:    // Apply new NavID/Focus
    #####:14025:    IMGUI_DEBUG_LOG_NAV("[nav] NavMoveRequest: result NavID 0x%08X in Layer %d Window \"%s\"\n", result->ID, g.NavLayer, g.NavWindow->Name);
    %%%%%:14025-block 63
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14025-block 64
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####:14026:    ImVec2 preferred_scoring_pos_rel = g.NavWindow->RootWindowForNav->NavPreferredScoringPosRel[g.NavLayer];
    #####:14027:    SetNavID(result->ID, g.NavLayer, result->FocusScopeId, result->RectRel);
    %%%%%:14027-block 65
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:14028:    if (result->SelectionUserData != ImGuiSelectionUserData_Invalid)
    %%%%%:14028-block 66
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14029:        g.NavLastValidSelectionUserData = result->SelectionUserData;
    %%%%%:14029-block 67
        -:14030:
        -:14031:    // Restore last preferred position for current axis
        -:14032:    // (storing in RootWindowForNav-> as the info is desirable at the beginning of a Move Request. In theory all storage should use RootWindowForNav..)
    #####:14033:    if ((g.NavMoveFlags & ImGuiNavMoveFlags_IsTabbing) == 0)
    %%%%%:14033-block 68
branch  0 never executed (fallthrough)
branch  1 never executed
        -:14034:    {
    #####:14035:        preferred_scoring_pos_rel[axis] = result->RectRel.GetCenter()[axis];
    %%%%%:14035-block 69
call    0 never executed
call    1 never executed
call    2 never executed
    #####:14036:        g.NavWindow->RootWindowForNav->NavPreferredScoringPosRel[g.NavLayer] = preferred_scoring_pos_rel;
        -:14037:    }
        -:14038:
        -:14039:    // Tabbing: Activates Inputable, otherwise only Focus
    #####:14040:    if ((g.NavMoveFlags & ImGuiNavMoveFlags_IsTabbing) && (result->ItemFlags & ImGuiItemFlags_Inputable) == 0)
    %%%%%:14040-block 73
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14040-block 74
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:14041:        g.NavMoveFlags &= ~ImGuiNavMoveFlags_Activate;
    %%%%%:14041-block 75
        -:14042:
        -:14043:    // Activate
    #####:14044:    if (g.NavMoveFlags & ImGuiNavMoveFlags_Activate)
    %%%%%:14044-block 76
branch  0 never executed (fallthrough)
branch  1 never executed
        -:14045:    {
    #####:14046:        g.NavNextActivateId = result->ID;
    #####:14047:        g.NavNextActivateFlags = ImGuiActivateFlags_None;
    #####:14048:        if (g.NavMoveFlags & ImGuiNavMoveFlags_IsTabbing)
    %%%%%:14048-block 77
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14049:            g.NavNextActivateFlags |= ImGuiActivateFlags_PreferInput | ImGuiActivateFlags_TryToPreserveState | ImGuiActivateFlags_FromTabbing;
    %%%%%:14049-block 78
        -:14050:    }
        -:14051:
        -:14052:    // Make nav cursor visible
    #####:14053:    if ((g.NavMoveFlags & ImGuiNavMoveFlags_NoSetNavCursorVisible) == 0)
    %%%%%:14053-block 79
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14054:        SetNavCursorVisibleAfterMove();
    %%%%%:14054-block 80
call    0 never executed
        -:14055:}
        -:14056:
        -:14057:// Process Escape/NavCancel input (to close a popup, get back to parent, clear focus)
        -:14058:// FIXME: In order to support e.g. Escape to clear a selection we'll need:
        -:14059:// - either to store the equivalent of ActiveIdUsingKeyInputMask for a FocusScope and test for it.
        -:14060:// - either to move most/all of those tests to the epilogue/end functions of the scope they are dealing with (e.g. exit child window in EndChild()) or in EndFrame(), to allow an earlier intercept
function _ZN5ImGuiL22NavUpdateCancelRequestEv called 1077 returned 100% blocks executed 19%
     1077:14061:static void ImGui::NavUpdateCancelRequest()
        -:14062:{
     1077:14063:    ImGuiContext& g = *GImGui;
    1077*:14064:    const bool nav_gamepad_active = (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (g.IO.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
     1077:14064-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:14064-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:14064-block 4
     1077:14064-block 5
     1077:14065:    const bool nav_keyboard_active = (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
    1077*:14066:    if (!(nav_keyboard_active && IsKeyPressed(ImGuiKey_Escape, 0, ImGuiKeyOwner_NoOwner)) && !(nav_gamepad_active && IsKeyPressed(ImGuiKey_NavGamepadCancel, 0, ImGuiKeyOwner_NoOwner)))
     1077:14066-block 6
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:14066-block 7
call    2 returned 1077
branch  3 taken 1077 (fallthrough)
branch  4 taken 0
     1077:14066-block 9
branch  5 taken 0 (fallthrough)
branch  6 taken 1077
    %%%%%:14066-block 10
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%:14066-block 11
    %%%%%:14066-block 12
    %%%%%:14066-block 13
call    9 never executed
branch 10 never executed (fallthrough)
branch 11 never executed
     1077:14066-block 15
    %%%%%:14066-block 16
     1077:14066-block 17
branch 12 taken 1077 (fallthrough)
branch 13 taken 0
     1077:14067:        return;
     1077:14067-block 18
        -:14068:
    #####:14069:    IMGUI_DEBUG_LOG_NAV("[nav] NavUpdateCancelRequest()\n");
    %%%%%:14069-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14069-block 20
call    2 never executed
    #####:14070:    if (g.ActiveId != 0)
    %%%%%:14070-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
        -:14071:    {
    #####:14072:        ClearActiveID();
    %%%%%:14072-block 22
call    0 never executed
        -:14073:    }
    #####:14074:    else if (g.NavLayer != ImGuiNavLayer_Main)
    %%%%%:14074-block 23
branch  0 never executed (fallthrough)
branch  1 never executed
        -:14075:    {
        -:14076:        // Leave the "menu" layer
    #####:14077:        NavRestoreLayer(ImGuiNavLayer_Main);
    %%%%%:14077-block 24
call    0 never executed
    #####:14078:        SetNavCursorVisibleAfterMove();
call    0 never executed
        -:14079:    }
    #####:14080:    else if (g.NavWindow && g.NavWindow != g.NavWindow->RootWindow && !(g.NavWindow->RootWindowForNav->Flags & ImGuiWindowFlags_Popup) && g.NavWindow->RootWindowForNav->ParentWindow)
    %%%%%:14080-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14080-block 27
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:14080-block 28
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:14080-block 29
branch  6 never executed (fallthrough)
branch  7 never executed
        -:14081:    {
        -:14082:        // Exit child window
    #####:14083:        ImGuiWindow* child_window = g.NavWindow->RootWindowForNav;
    #####:14084:        ImGuiWindow* parent_window = child_window->ParentWindow;
    #####:14085:        IM_ASSERT(child_window->ChildId != 0);
    %%%%%:14085-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14085-block 31
call    2 never executed
    #####:14086:        FocusWindow(parent_window);
    %%%%%:14086-block 32
call    0 never executed
    #####:14087:        SetNavID(child_window->ChildId, ImGuiNavLayer_Main, 0, WindowRectAbsToRel(parent_window, child_window->Rect()));
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    $$$$$:14087-block 58
    #####:14088:        SetNavCursorVisibleAfterMove();
    %%%%%:14088-block 36
call    0 never executed
    #####:14089:    }
    #####:14090:    else if (g.OpenPopupStack.Size > 0 && g.OpenPopupStack.back().Window != NULL && !(g.OpenPopupStack.back().Window->Flags & ImGuiWindowFlags_Modal))
    %%%%%:14090-block 38
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14090-block 39
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:14090-block 41
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%:14090-block 43
    %%%%%:14090-block 44
    %%%%%:14090-block 45
branch  8 never executed (fallthrough)
branch  9 never executed
        -:14091:    {
        -:14092:        // Close open popup/menu
    #####:14093:        ClosePopupToLevel(g.OpenPopupStack.Size - 1, true);
    %%%%%:14093-block 46
call    0 never executed
        -:14094:    }
        -:14095:    else
        -:14096:    {
        -:14097:        // Clear NavLastId for popups but keep it for regular child window so we can leave one and come back where we were
        -:14098:        // FIXME-NAV: This should happen on window appearing.
    #####:14099:        if (g.IO.ConfigNavEscapeClearFocusItem || g.IO.ConfigNavEscapeClearFocusWindow)
    %%%%%:14099-block 47
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14099-block 48
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:14100:            if (g.NavWindow && ((g.NavWindow->Flags & ImGuiWindowFlags_Popup)))// || !(g.NavWindow->Flags & ImGuiWindowFlags_ChildWindow)))
    %%%%%:14100-block 49
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14100-block 50
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:14101:                g.NavWindow->NavLastIds[0] = 0;
    %%%%%:14101-block 51
        -:14102:
        -:14103:        // Clear nav focus
    #####:14104:        if (g.IO.ConfigNavEscapeClearFocusItem || g.IO.ConfigNavEscapeClearFocusWindow)
    %%%%%:14104-block 52
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14104-block 53
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:14105:            g.NavId = 0;
    %%%%%:14105-block 54
    #####:14106:        if (g.IO.ConfigNavEscapeClearFocusWindow)
    %%%%%:14106-block 55
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14107:            FocusWindow(NULL);
    %%%%%:14107-block 56
call    0 never executed
        -:14108:    }
        -:14109:}
        -:14110:
        -:14111:// Handle PageUp/PageDown/Home/End keys
        -:14112:// Called from NavUpdateCreateMoveRequest() which will use our output to create a move request
        -:14113:// FIXME-NAV: This doesn't work properly with NavFlattened siblings as we use NavWindow rectangle for reference
        -:14114:// FIXME-NAV: how to get Home/End to aim at the beginning/end of a 2D grid?
function _ZN5ImGuiL23NavUpdatePageUpPageDownEv called 1076 returned 100% blocks executed 22%
     1076:14115:static float ImGui::NavUpdatePageUpPageDown()
        -:14116:{
     1076:14117:    ImGuiContext& g = *GImGui;
     1076:14118:    ImGuiWindow* window = g.NavWindow;
     1076:14119:    if ((window->Flags & ImGuiWindowFlags_NoNavInputs) || g.NavWindowingTarget != NULL)
     1076:14119-block 2
branch  0 taken 686 (fallthrough)
branch  1 taken 390
      686:14119-block 3
branch  2 taken 0 (fallthrough)
branch  3 taken 686
      390:14120:        return 0.0f;
      390:14120-block 4
        -:14121:
      686:14122:    const bool page_up_held = IsKeyDown(ImGuiKey_PageUp, ImGuiKeyOwner_NoOwner);
      686:14122-block 5
call    0 returned 686
      686:14123:    const bool page_down_held = IsKeyDown(ImGuiKey_PageDown, ImGuiKeyOwner_NoOwner);
call    0 returned 686
      686:14124:    const bool home_pressed = IsKeyPressed(ImGuiKey_Home, ImGuiInputFlags_Repeat, ImGuiKeyOwner_NoOwner);
call    0 returned 686
      686:14125:    const bool end_pressed = IsKeyPressed(ImGuiKey_End, ImGuiInputFlags_Repeat, ImGuiKeyOwner_NoOwner);
call    0 returned 686
      686:14126:    if (page_up_held == page_down_held && home_pressed == end_pressed) // Proceed if either (not both) are pressed, otherwise early out
branch  0 taken 686 (fallthrough)
branch  1 taken 0
      686:14126-block 10
branch  2 taken 686 (fallthrough)
branch  3 taken 0
      686:14127:        return 0.0f;
      686:14127-block 11
        -:14128:
    #####:14129:    if (g.NavLayer != ImGuiNavLayer_Main)
    %%%%%:14129-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14130:        NavRestoreLayer(ImGuiNavLayer_Main);
    %%%%%:14130-block 13
call    0 never executed
        -:14131:
    #####:14132:    if (window->DC.NavLayersActiveMask == 0x00 && window->DC.NavWindowHasScrollY)
    %%%%%:14132-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14132-block 15
branch  2 never executed (fallthrough)
branch  3 never executed
        -:14133:    {
        -:14134:        // Fallback manual-scroll when window has no navigable item
    #####:14135:        if (IsKeyPressed(ImGuiKey_PageUp, ImGuiInputFlags_Repeat, ImGuiKeyOwner_NoOwner))
    %%%%%:14135-block 16
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:14135-block 28
    #####:14136:            SetScrollY(window, window->Scroll.y - window->InnerRect.GetHeight());
    %%%%%:14136-block 18
call    0 never executed
call    1 never executed
    #####:14137:        else if (IsKeyPressed(ImGuiKey_PageDown, ImGuiInputFlags_Repeat, ImGuiKeyOwner_NoOwner))
    %%%%%:14137-block 20
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:14138:            SetScrollY(window, window->Scroll.y + window->InnerRect.GetHeight());
    %%%%%:14138-block 22
call    0 never executed
call    1 never executed
    #####:14139:        else if (home_pressed)
    %%%%%:14139-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14140:            SetScrollY(window, 0.0f);
    %%%%%:14140-block 25
call    0 never executed
    #####:14141:        else if (end_pressed)
    %%%%%:14141-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14142:            SetScrollY(window, window->ScrollMax.y);
    %%%%%:14142-block 27
call    0 never executed
        -:14143:    }
        -:14144:    else
        -:14145:    {
    #####:14146:        ImRect& nav_rect_rel = window->NavRectRel[g.NavLayer];
    #####:14147:        const float page_offset_y = ImMax(0.0f, window->InnerRect.GetHeight() - window->CalcFontSize() * 1.0f + nav_rect_rel.GetHeight());
    %%%%%:14147-block 29
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:14148:        float nav_scoring_rect_offset_y = 0.0f;
    #####:14149:        if (IsKeyPressed(ImGuiKey_PageUp, true))
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -:14150:        {
    #####:14151:            nav_scoring_rect_offset_y = -page_offset_y;
    #####:14152:            g.NavMoveDir = ImGuiDir_Down; // Because our scoring rect is offset up, we request the down direction (so we can always land on the last item)
    #####:14153:            g.NavMoveClipDir = ImGuiDir_Up;
    #####:14154:            g.NavMoveFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_AlsoScoreVisibleSet | ImGuiNavMoveFlags_IsPageMove;
    %%%%%:14154-block 35
        -:14155:        }
    #####:14156:        else if (IsKeyPressed(ImGuiKey_PageDown, true))
    %%%%%:14156-block 36
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -:14157:        {
    #####:14158:            nav_scoring_rect_offset_y = +page_offset_y;
    #####:14159:            g.NavMoveDir = ImGuiDir_Up; // Because our scoring rect is offset down, we request the up direction (so we can always land on the last item)
    #####:14160:            g.NavMoveClipDir = ImGuiDir_Down;
    #####:14161:            g.NavMoveFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_AlsoScoreVisibleSet | ImGuiNavMoveFlags_IsPageMove;
    %%%%%:14161-block 38
        -:14162:        }
    #####:14163:        else if (home_pressed)
    %%%%%:14163-block 39
branch  0 never executed (fallthrough)
branch  1 never executed
        -:14164:        {
        -:14165:            // FIXME-NAV: handling of Home/End is assuming that the top/bottom most item will be visible with Scroll.y == 0/ScrollMax.y
        -:14166:            // Scrolling will be handled via the ImGuiNavMoveFlags_ScrollToEdgeY flag, we don't scroll immediately to avoid scrolling happening before nav result.
        -:14167:            // Preserve current horizontal position if we have any.
    #####:14168:            nav_rect_rel.Min.y = nav_rect_rel.Max.y = 0.0f;
    #####:14169:            if (nav_rect_rel.IsInverted())
    %%%%%:14169-block 40
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:14170:                nav_rect_rel.Min.x = nav_rect_rel.Max.x = 0.0f;
    %%%%%:14170-block 42
    #####:14171:            g.NavMoveDir = ImGuiDir_Down;
    #####:14172:            g.NavMoveFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_ScrollToEdgeY;
    %%%%%:14172-block 43
        -:14173:            // FIXME-NAV: MoveClipDir left to _None, intentional?
        -:14174:        }
    #####:14175:        else if (end_pressed)
    %%%%%:14175-block 44
branch  0 never executed (fallthrough)
branch  1 never executed
        -:14176:        {
    #####:14177:            nav_rect_rel.Min.y = nav_rect_rel.Max.y = window->ContentSize.y;
    #####:14178:            if (nav_rect_rel.IsInverted())
    %%%%%:14178-block 45
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:14179:                nav_rect_rel.Min.x = nav_rect_rel.Max.x = 0.0f;
    %%%%%:14179-block 47
    #####:14180:            g.NavMoveDir = ImGuiDir_Up;
    #####:14181:            g.NavMoveFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_ScrollToEdgeY;
    %%%%%:14181-block 48
        -:14182:            // FIXME-NAV: MoveClipDir left to _None, intentional?
        -:14183:        }
    #####:14184:        return nav_scoring_rect_offset_y;
    %%%%%:14184-block 49
        -:14185:    }
    #####:14186:    return 0.0f;
    %%%%%:14186-block 50
        -:14187:}
        -:14188:
function _ZN5ImGuiL11NavEndFrameEv called 1077 returned 100% blocks executed 58%
     1077:14189:static void ImGui::NavEndFrame()
        -:14190:{
     1077:14191:    ImGuiContext& g = *GImGui;
        -:14192:
        -:14193:    // Show CTRL+TAB list window
     1077:14194:    if (g.NavWindowingTarget != NULL)
     1077:14194-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####:14195:        NavUpdateWindowingOverlay();
    %%%%%:14195-block 3
call    0 never executed
        -:14196:
        -:14197:    // Perform wrap-around in menus
        -:14198:    // FIXME-NAV: Wrap may need to apply a weight bias on the other axis. e.g. 4x4 grid with 2 last items missing on last item won't handle LoopY/WrapY correctly.
        -:14199:    // FIXME-NAV: Wrap (not Loop) support could be handled by the scoring function and then WrapX would function without an extra frame.
    1077*:14200:    if (g.NavWindow && NavMoveRequestButNoResultYet() && (g.NavMoveFlags & ImGuiNavMoveFlags_WrapMask_) && (g.NavMoveFlags & ImGuiNavMoveFlags_Forwarded) == 0)
     1077:14200-block 4
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:14200-block 5
call    2 returned 1077
branch  3 taken 0 (fallthrough)
branch  4 taken 1077
    %%%%%:14200-block 7
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:14200-block 8
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%:14200-block 9
     1077:14200-block 10
     1077:14200-block 11
branch  9 taken 0 (fallthrough)
branch 10 taken 1077
    #####:14201:        NavUpdateCreateWrappingRequest();
    %%%%%:14201-block 12
call    0 never executed
     1077:14202:}
        -:14203:
function _ZN5ImGuiL30NavUpdateCreateWrappingRequestEv called 0 returned 0% blocks executed 0%
    #####:14204:static void ImGui::NavUpdateCreateWrappingRequest()
        -:14205:{
    #####:14206:    ImGuiContext& g = *GImGui;
    #####:14207:    ImGuiWindow* window = g.NavWindow;
        -:14208:
    #####:14209:    bool do_forward = false;
    #####:14210:    ImRect bb_rel = window->NavRectRel[g.NavLayer];
    #####:14211:    ImGuiDir clip_dir = g.NavMoveDir;
        -:14212:
    #####:14213:    const ImGuiNavMoveFlags move_flags = g.NavMoveFlags;
        -:14214:    //const ImGuiAxis move_axis = (g.NavMoveDir == ImGuiDir_Up || g.NavMoveDir == ImGuiDir_Down) ? ImGuiAxis_Y : ImGuiAxis_X;
    #####:14215:    if (g.NavMoveDir == ImGuiDir_Left && (move_flags & (ImGuiNavMoveFlags_WrapX | ImGuiNavMoveFlags_LoopX)))
    %%%%%:14215-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14215-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
        -:14216:    {
    #####:14217:        bb_rel.Min.x = bb_rel.Max.x = window->ContentSize.x + window->WindowPadding.x;
    #####:14218:        if (move_flags & ImGuiNavMoveFlags_WrapX)
    %%%%%:14218-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
        -:14219:        {
    #####:14220:            bb_rel.TranslateY(-bb_rel.GetHeight()); // Previous row
    %%%%%:14220-block 5
call    0 never executed
call    1 never executed
    #####:14221:            clip_dir = ImGuiDir_Up;
        -:14222:        }
    #####:14223:        do_forward = true;
    %%%%%:14223-block 8
        -:14224:    }
    #####:14225:    if (g.NavMoveDir == ImGuiDir_Right && (move_flags & (ImGuiNavMoveFlags_WrapX | ImGuiNavMoveFlags_LoopX)))
    %%%%%:14225-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14225-block 10
branch  2 never executed (fallthrough)
branch  3 never executed
        -:14226:    {
    #####:14227:        bb_rel.Min.x = bb_rel.Max.x = -window->WindowPadding.x;
    #####:14228:        if (move_flags & ImGuiNavMoveFlags_WrapX)
    %%%%%:14228-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
        -:14229:        {
    #####:14230:            bb_rel.TranslateY(+bb_rel.GetHeight()); // Next row
    %%%%%:14230-block 12
call    0 never executed
call    1 never executed
    #####:14231:            clip_dir = ImGuiDir_Down;
        -:14232:        }
    #####:14233:        do_forward = true;
    %%%%%:14233-block 15
        -:14234:    }
    #####:14235:    if (g.NavMoveDir == ImGuiDir_Up && (move_flags & (ImGuiNavMoveFlags_WrapY | ImGuiNavMoveFlags_LoopY)))
    %%%%%:14235-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14235-block 17
branch  2 never executed (fallthrough)
branch  3 never executed
        -:14236:    {
    #####:14237:        bb_rel.Min.y = bb_rel.Max.y = window->ContentSize.y + window->WindowPadding.y;
    #####:14238:        if (move_flags & ImGuiNavMoveFlags_WrapY)
    %%%%%:14238-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
        -:14239:        {
    #####:14240:            bb_rel.TranslateX(-bb_rel.GetWidth()); // Previous column
    %%%%%:14240-block 19
call    0 never executed
call    1 never executed
    #####:14241:            clip_dir = ImGuiDir_Left;
        -:14242:        }
    #####:14243:        do_forward = true;
    %%%%%:14243-block 22
        -:14244:    }
    #####:14245:    if (g.NavMoveDir == ImGuiDir_Down && (move_flags & (ImGuiNavMoveFlags_WrapY | ImGuiNavMoveFlags_LoopY)))
    %%%%%:14245-block 23
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14245-block 24
branch  2 never executed (fallthrough)
branch  3 never executed
        -:14246:    {
    #####:14247:        bb_rel.Min.y = bb_rel.Max.y = -window->WindowPadding.y;
    #####:14248:        if (move_flags & ImGuiNavMoveFlags_WrapY)
    %%%%%:14248-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
        -:14249:        {
    #####:14250:            bb_rel.TranslateX(+bb_rel.GetWidth()); // Next column
    %%%%%:14250-block 26
call    0 never executed
call    1 never executed
    #####:14251:            clip_dir = ImGuiDir_Right;
        -:14252:        }
    #####:14253:        do_forward = true;
    %%%%%:14253-block 29
        -:14254:    }
    #####:14255:    if (!do_forward)
    %%%%%:14255-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14256:        return;
    %%%%%:14256-block 31
    #####:14257:    window->NavRectRel[g.NavLayer] = bb_rel;
    #####:14258:    NavClearPreferredPosForAxis(ImGuiAxis_X);
    %%%%%:14258-block 32
call    0 never executed
    #####:14259:    NavClearPreferredPosForAxis(ImGuiAxis_Y);
call    0 never executed
    #####:14260:    NavMoveRequestForward(g.NavMoveDir, clip_dir, move_flags, g.NavMoveScrollFlags);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:14261:}
        -:14262:
function _ZN5ImGuiL20FindWindowFocusIndexEP11ImGuiWindow called 0 returned 0% blocks executed 0%
    #####:14263:static int ImGui::FindWindowFocusIndex(ImGuiWindow* window)
        -:14264:{
    #####:14265:    ImGuiContext& g = *GImGui;
        -:14266:    IM_UNUSED(g);
    #####:14267:    int order = window->FocusOrder;
    #####:14268:    IM_ASSERT(window->RootWindow == window); // No child window (not testing _ChildWindow because of docking)
    %%%%%:14268-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14268-block 3
call    2 never executed
    #####:14269:    IM_ASSERT(g.WindowsFocusOrder[order] == window);
    %%%%%:14269-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:14269-block 6
call    3 never executed
    #####:14270:    return order;
    %%%%%:14270-block 7
        -:14271:}
        -:14272:
function _ZL22FindWindowNavFocusableiii called 0 returned 0% blocks executed 0%
    #####:14273:static ImGuiWindow* FindWindowNavFocusable(int i_start, int i_stop, int dir) // FIXME-OPT O(N)
        -:14274:{
    #####:14275:    ImGuiContext& g = *GImGui;
    #####:14276:    for (int i = i_start; i >= 0 && i < g.WindowsFocusOrder.Size && i != i_stop; i += dir)
    %%%%%:14276-block 2
    %%%%%:14276-block 8
    %%%%%:14276-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14276-block 10
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:14276-block 11
branch  4 never executed
branch  5 never executed (fallthrough)
    #####:14277:        if (ImGui::IsWindowNavFocusable(g.WindowsFocusOrder[i]))
    %%%%%:14277-block 3
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:14278:            return g.WindowsFocusOrder[i];
    %%%%%:14278-block 6
call    0 never executed
    #####:14279:    return NULL;
    %%%%%:14279-block 12
        -:14280:}
        -:14281:
function _ZL24NavUpdateWindowingTargeti called 0 returned 0% blocks executed 0%
    #####:14282:static void NavUpdateWindowingTarget(int focus_change_dir)
        -:14283:{
    #####:14284:    ImGuiContext& g = *GImGui;
    #####:14285:    IM_ASSERT(g.NavWindowingTarget);
    %%%%%:14285-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14285-block 3
call    2 never executed
    #####:14286:    if (g.NavWindowingTarget->Flags & ImGuiWindowFlags_Modal)
    %%%%%:14286-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14287:        return;
    %%%%%:14287-block 5
        -:14288:
    #####:14289:    const int i_current = ImGui::FindWindowFocusIndex(g.NavWindowingTarget);
    %%%%%:14289-block 6
call    0 never executed
    #####:14290:    ImGuiWindow* window_target = FindWindowNavFocusable(i_current + focus_change_dir, -INT_MAX, focus_change_dir);
call    0 never executed
    #####:14291:    if (!window_target)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14292:        window_target = FindWindowNavFocusable((focus_change_dir < 0) ? (g.WindowsFocusOrder.Size - 1) : 0, i_current, focus_change_dir);
    %%%%%:14292-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14292-block 10
    %%%%%:14292-block 11
    %%%%%:14292-block 12
call    2 never executed
    #####:14293:    if (window_target) // Don't reset windowing target if there's a single window in the list
    %%%%%:14293-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
        -:14294:    {
    #####:14295:        g.NavWindowingTarget = g.NavWindowingTargetAnim = window_target;
    #####:14296:        g.NavWindowingAccumDeltaPos = g.NavWindowingAccumDeltaSize = ImVec2(0.0f, 0.0f);
    %%%%%:14296-block 15
call    0 never executed
        -:14297:    }
    #####:14298:    g.NavWindowingToggleLayer = false;
    %%%%%:14298-block 17
        -:14299:}
        -:14300:
        -:14301:// Windowing management mode
        -:14302:// Keyboard: CTRL+Tab (change focus/move/resize), Alt (toggle menu layer)
        -:14303:// Gamepad:  Hold Menu/Square (change focus/move/resize), Tap Menu/Square (toggle menu layer)
function _ZN5ImGuiL18NavUpdateWindowingEv called 1077 returned 100% blocks executed 21%
     1077:14304:static void ImGui::NavUpdateWindowing()
        -:14305:{
     1077:14306:    ImGuiContext& g = *GImGui;
     1077:14307:    ImGuiIO& io = g.IO;
        -:14308:
     1077:14309:    ImGuiWindow* apply_focus_window = NULL;
     1077:14310:    bool apply_toggle_layer = false;
        -:14311:
     1077:14312:    ImGuiWindow* modal_window = GetTopMostPopupModal();
     1077:14312-block 2
call    0 returned 1077
     1077:14313:    bool allow_windowing = (modal_window == NULL); // FIXME: This prevent CTRL+TAB from being usable with windows that are inside the Begin-stack of that modal.
     1077:14314:    if (!allow_windowing)
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####:14315:        g.NavWindowingTarget = NULL;
    %%%%%:14315-block 4
        -:14316:
        -:14317:    // Fade out
    1077*:14318:    if (g.NavWindowingTargetAnim && g.NavWindowingTarget == NULL)
     1077:14318-block 5
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:14318-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
        -:14319:    {
    #####:14320:        g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha - io.DeltaTime * 10.0f, 0.0f);
    %%%%%:14320-block 7
call    0 never executed
    #####:14321:        if (g.DimBgRatio <= 0.0f && g.NavWindowingHighlightAlpha <= 0.0f)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14321-block 9
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:14322:            g.NavWindowingTargetAnim = NULL;
    %%%%%:14322-block 10
        -:14323:    }
        -:14324:
        -:14325:    // Start CTRL+Tab or Square+L/R window selection
        -:14326:    // (g.ConfigNavWindowingKeyNext/g.ConfigNavWindowingKeyPrev defaults are ImGuiMod_Ctrl|ImGuiKey_Tab and ImGuiMod_Ctrl|ImGuiMod_Shift|ImGuiKey_Tab)
     1077:14327:    const ImGuiID owner_id = ImHashStr("###NavUpdateWindowing");
     1077:14327-block 11
call    0 returned 1077
    1077*:14328:    const bool nav_gamepad_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (io.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:14328-block 13
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:14328-block 14
     1077:14328-block 15
     1077:14329:    const bool nav_keyboard_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
    1077*:14330:    const bool keyboard_next_window = allow_windowing && g.ConfigNavWindowingKeyNext && Shortcut(g.ConfigNavWindowingKeyNext, ImGuiInputFlags_Repeat | ImGuiInputFlags_RouteAlways, owner_id);
     1077:14330-block 16
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:14330-block 17
branch  2 taken 1077 (fallthrough)
branch  3 taken 0
     1077:14330-block 18
call    4 returned 1077
branch  5 taken 1077 (fallthrough)
branch  6 taken 0 (throw)
     1077:14330-block 19
branch  7 taken 0 (fallthrough)
branch  8 taken 1077
    %%%%%:14330-block 20
     1077:14330-block 21
    1077*:14331:    const bool keyboard_prev_window = allow_windowing && g.ConfigNavWindowingKeyPrev && Shortcut(g.ConfigNavWindowingKeyPrev, ImGuiInputFlags_Repeat | ImGuiInputFlags_RouteAlways, owner_id);
     1077:14331-block 22
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:14331-block 23
branch  2 taken 1077 (fallthrough)
branch  3 taken 0
     1077:14331-block 24
call    4 returned 1077
branch  5 taken 1077 (fallthrough)
branch  6 taken 0 (throw)
     1077:14331-block 25
branch  7 taken 0 (fallthrough)
branch  8 taken 1077
    %%%%%:14331-block 26
     1077:14331-block 27
    1077*:14332:    const bool start_windowing_with_gamepad = allow_windowing && nav_gamepad_active && !g.NavWindowingTarget && IsKeyPressed(ImGuiKey_NavGamepadMenu, ImGuiInputFlags_None);
     1077:14332-block 28
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:14332-block 29
branch  2 taken 0 (fallthrough)
branch  3 taken 1077
    %%%%%:14332-block 30
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:14332-block 31
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed (throw)
    %%%%%:14332-block 32
branch  9 never executed (fallthrough)
branch 10 never executed
    %%%%%:14332-block 33
     1077:14332-block 34
    1077*:14333:    const bool start_windowing_with_keyboard = allow_windowing && !g.NavWindowingTarget && (keyboard_next_window || keyboard_prev_window); // Note: enabled even without NavEnableKeyboard!
     1077:14333-block 35
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:14333-block 36
branch  2 taken 1077 (fallthrough)
branch  3 taken 0
     1077:14333-block 37
branch  4 taken 1077 (fallthrough)
branch  5 taken 0
     1077:14333-block 38
branch  6 taken 0 (fallthrough)
branch  7 taken 1077
    %%%%%:14333-block 39
     1077:14333-block 40
     1077:14334:    bool just_started_windowing_from_null_focus = false;
     1077:14335:    if (start_windowing_with_gamepad || start_windowing_with_keyboard)
     1077:14335-block 41
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:14335-block 42
branch  2 taken 0 (fallthrough)
branch  3 taken 1077
    #####:14336:        if (ImGuiWindow* window = g.NavWindow ? g.NavWindow : FindWindowNavFocusable(g.WindowsFocusOrder.Size - 1, -INT_MAX, -1))
    %%%%%:14336-block 43
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14336-block 44
    %%%%%:14336-block 45
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%:14336-block 46
    %%%%%:14336-block 47
branch  5 never executed (fallthrough)
branch  6 never executed
        -:14337:        {
    #####:14338:            g.NavWindowingTarget = g.NavWindowingTargetAnim = window->RootWindow; // Current location
    #####:14339:            g.NavWindowingTimer = g.NavWindowingHighlightAlpha = 0.0f;
    #####:14340:            g.NavWindowingAccumDeltaPos = g.NavWindowingAccumDeltaSize = ImVec2(0.0f, 0.0f);
    %%%%%:14340-block 48
call    0 never executed
    #####:14341:            g.NavWindowingToggleLayer = start_windowing_with_gamepad ? true : false; // Gamepad starts toggling layer
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14341-block 50
    %%%%%:14341-block 51
    #####:14342:            g.NavInputSource = start_windowing_with_keyboard ? ImGuiInputSource_Keyboard : ImGuiInputSource_Gamepad;
    %%%%%:14342-block 52
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14342-block 53
    %%%%%:14342-block 54
    #####:14343:            if (g.NavWindow == NULL)
    %%%%%:14343-block 55
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14344:                just_started_windowing_from_null_focus = true;
    %%%%%:14344-block 56
        -:14345:
        -:14346:            // Manually register ownership of our mods. Using a global route in the Shortcut() calls instead would probably be correct but may have more side-effects.
    #####:14347:            if (keyboard_next_window || keyboard_prev_window)
    %%%%%:14347-block 57
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14347-block 58
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:14348:                SetKeyOwnersForKeyChord((g.ConfigNavWindowingKeyNext | g.ConfigNavWindowingKeyPrev) & ImGuiMod_Mask_, owner_id);
    %%%%%:14348-block 59
call    0 never executed
        -:14349:        }
        -:14350:
        -:14351:    // Gamepad update
     1077:14352:    g.NavWindowingTimer += io.DeltaTime;
    1077*:14353:    if (g.NavWindowingTarget && g.NavInputSource == ImGuiInputSource_Gamepad)
     1077:14353-block 60
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:14353-block 61
branch  2 never executed (fallthrough)
branch  3 never executed
        -:14354:    {
        -:14355:        // Highlight only appears after a brief time holding the button, so that a fast tap on PadMenu (to toggle NavLayer) doesn't add visual noise
    #####:14356:        g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha, ImSaturate((g.NavWindowingTimer - NAV_WINDOWING_HIGHLIGHT_DELAY) / 0.05f));
    %%%%%:14356-block 62
call    0 never executed
call    1 never executed
        -:14357:
        -:14358:        // Select window to focus
    #####:14359:        const int focus_change_dir = (int)IsKeyPressed(ImGuiKey_GamepadL1) - (int)IsKeyPressed(ImGuiKey_GamepadR1);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:14359-block 65
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    #####:14360:        if (focus_change_dir != 0 && !just_started_windowing_from_null_focus)
    %%%%%:14360-block 66
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14360-block 67
branch  2 never executed (fallthrough)
branch  3 never executed
        -:14361:        {
    #####:14362:            NavUpdateWindowingTarget(focus_change_dir);
    %%%%%:14362-block 68
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:14363:            g.NavWindowingHighlightAlpha = 1.0f;
    %%%%%:14363-block 69
        -:14364:        }
        -:14365:
        -:14366:        // Single press toggles NavLayer, long press with L/R apply actual focus on release (until then the window was merely rendered top-most)
    #####:14367:        if (!IsKeyDown(ImGuiKey_NavGamepadMenu))
    %%%%%:14367-block 70
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:14367-block 71
branch  3 never executed (fallthrough)
branch  4 never executed
        -:14368:        {
    #####:14369:            g.NavWindowingToggleLayer &= (g.NavWindowingHighlightAlpha < 1.0f); // Once button was held long enough we don't consider it a tap-to-toggle-layer press anymore.
    #####:14370:            if (g.NavWindowingToggleLayer && g.NavWindow)
    %%%%%:14370-block 72
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14370-block 73
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:14371:                apply_toggle_layer = true;
    %%%%%:14371-block 74
    #####:14372:            else if (!g.NavWindowingToggleLayer)
    %%%%%:14372-block 75
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14373:                apply_focus_window = g.NavWindowingTarget;
    %%%%%:14373-block 76
    #####:14374:            g.NavWindowingTarget = NULL;
    %%%%%:14374-block 77
        -:14375:        }
        -:14376:    }
        -:14377:
        -:14378:    // Keyboard: Focus
    1077*:14379:    if (g.NavWindowingTarget && g.NavInputSource == ImGuiInputSource_Keyboard)
     1077:14379-block 78
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:14379-block 79
branch  2 never executed (fallthrough)
branch  3 never executed
        -:14380:    {
        -:14381:        // Visuals only appears after a brief time after pressing TAB the first time, so that a fast CTRL+TAB doesn't add visual noise
    #####:14382:        ImGuiKeyChord shared_mods = ((g.ConfigNavWindowingKeyNext ? g.ConfigNavWindowingKeyNext : ImGuiMod_Mask_) & (g.ConfigNavWindowingKeyPrev ? g.ConfigNavWindowingKeyPrev : ImGuiMod_Mask_)) & ImGuiMod_Mask_;
    %%%%%:14382-block 80
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14382-block 81
    %%%%%:14382-block 82
    %%%%%:14382-block 83
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:14382-block 84
    %%%%%:14382-block 85
    #####:14383:        IM_ASSERT(shared_mods != 0); // Next/Prev shortcut currently needs a shared modifier to "hold", otherwise Prev actions would keep cycling between two windows.
    %%%%%:14383-block 86
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14383-block 87
call    2 never executed
    #####:14384:        g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha, ImSaturate((g.NavWindowingTimer - NAV_WINDOWING_HIGHLIGHT_DELAY) / 0.05f)); // 1.0f
    %%%%%:14384-block 88
call    0 never executed
call    1 never executed
    #####:14385:        if ((keyboard_next_window || keyboard_prev_window) && !just_started_windowing_from_null_focus)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14385-block 91
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:14385-block 92
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:14386:            NavUpdateWindowingTarget(keyboard_next_window ? -1 : +1);
    %%%%%:14386-block 93
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14386-block 94
    %%%%%:14386-block 95
    %%%%%:14386-block 96
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####:14387:        else if ((io.KeyMods & shared_mods) != shared_mods)
    %%%%%:14387-block 98
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14388:            apply_focus_window = g.NavWindowingTarget;
    %%%%%:14388-block 99
        -:14389:    }
        -:14390:
        -:14391:    // Keyboard: Press and Release ALT to toggle menu layer
     1077:14392:    const ImGuiKey windowing_toggle_keys[] = { ImGuiKey_LeftAlt, ImGuiKey_RightAlt };
     1077:14393:    bool windowing_toggle_layer_start = false;
     3231:14394:    for (ImGuiKey windowing_toggle_key : windowing_toggle_keys)
     1077:14394-block 101
     2154:14394-block 109
     3231:14394-block 110
branch  0 taken 2154
branch  1 taken 1077 (fallthrough)
    2154*:14395:        if (nav_keyboard_active && IsKeyPressed(windowing_toggle_key, 0, ImGuiKeyOwner_NoOwner))
     2154:14395-block 102
branch  0 taken 2154 (fallthrough)
branch  1 taken 0
     2154:14395-block 103
call    2 returned 2154
branch  3 taken 2154 (fallthrough)
branch  4 taken 0 (throw)
     2154:14395-block 104
branch  5 taken 0 (fallthrough)
branch  6 taken 2154
    %%%%%:14395-block 105
     2154:14395-block 106
     2154:14395-block 107
branch  7 taken 0 (fallthrough)
branch  8 taken 2154
        -:14396:        {
    #####:14397:            windowing_toggle_layer_start = true;
    #####:14398:            g.NavWindowingToggleLayer = true;
    #####:14399:            g.NavWindowingToggleKey = windowing_toggle_key;
    #####:14400:            g.NavInputSource = ImGuiInputSource_Keyboard;
    #####:14401:            break;
    %%%%%:14401-block 108
        -:14402:        }
    1077*:14403:    if (g.NavWindowingToggleLayer && g.NavInputSource == ImGuiInputSource_Keyboard)
     1077:14403-block 111
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:14403-block 112
branch  2 never executed (fallthrough)
branch  3 never executed
        -:14404:    {
        -:14405:        // We cancel toggling nav layer when any text has been typed (generally while holding Alt). (See #370)
        -:14406:        // We cancel toggling nav layer when other modifiers are pressed. (See #4439)
        -:14407:        // - AltGR is Alt+Ctrl on some layout but we can't reliably detect it (not all backends/systems/layout emit it as Alt+Ctrl).
        -:14408:        // We cancel toggling nav layer if an owner has claimed the key.
    #####:14409:        if (io.InputQueueCharacters.Size > 0 || io.KeyCtrl || io.KeyShift || io.KeySuper)
    %%%%%:14409-block 113
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14409-block 114
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:14409-block 115
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:14409-block 116
branch  6 never executed (fallthrough)
branch  7 never executed
    #####:14410:            g.NavWindowingToggleLayer = false;
    %%%%%:14410-block 117
    #####:14411:        else if (windowing_toggle_layer_start == false && g.LastKeyboardKeyPressTime == g.Time)
    %%%%%:14411-block 118
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14411-block 119
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:14412:            g.NavWindowingToggleLayer = false;
    %%%%%:14412-block 120
    #####:14413:        else if (TestKeyOwner(g.NavWindowingToggleKey, ImGuiKeyOwner_NoOwner) == false || TestKeyOwner(ImGuiMod_Alt, ImGuiKeyOwner_NoOwner) == false)
    %%%%%:14413-block 121
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:14413-block 123
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:14413-block 125
    %%%%%:14413-block 126
    %%%%%:14413-block 127
branch  6 never executed (fallthrough)
branch  7 never executed
    #####:14414:            g.NavWindowingToggleLayer = false;
    %%%%%:14414-block 128
        -:14415:
        -:14416:        // Apply layer toggle on Alt release
        -:14417:        // Important: as before version <18314 we lacked an explicit IO event for focus gain/loss, we also compare mouse validity to detect old backends clearing mouse pos on focus loss.
    #####:14418:        if (IsKeyReleased(g.NavWindowingToggleKey) && g.NavWindowingToggleLayer)
    %%%%%:14418-block 129
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:14418-block 130
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:14418-block 131
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:14418-block 132
    %%%%%:14418-block 133
    %%%%%:14418-block 134
branch  7 never executed (fallthrough)
branch  8 never executed
    #####:14419:            if (g.ActiveId == 0 || g.ActiveIdAllowOverlap)
    %%%%%:14419-block 135
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14419-block 136
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:14420:                if (IsMousePosValid(&io.MousePos) == IsMousePosValid(&io.MousePosPrev))
    %%%%%:14420-block 137
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:14421:                    apply_toggle_layer = true;
    %%%%%:14421-block 140
    #####:14422:        if (!IsKeyDown(g.NavWindowingToggleKey))
    %%%%%:14422-block 141
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:14422-block 142
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:14423:            g.NavWindowingToggleLayer = false;
    %%%%%:14423-block 143
        -:14424:    }
        -:14425:
        -:14426:    // Move window
    1077*:14427:    if (g.NavWindowingTarget && !(g.NavWindowingTarget->Flags & ImGuiWindowFlags_NoMove))
     1077:14427-block 144
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:14427-block 145
branch  2 never executed (fallthrough)
branch  3 never executed
        -:14428:    {
    #####:14429:        ImVec2 nav_move_dir;
    #####:14430:        if (g.NavInputSource == ImGuiInputSource_Keyboard && !io.KeyShift)
    %%%%%:14430-block 146
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14430-block 147
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:14431:            nav_move_dir = GetKeyMagnitude2d(ImGuiKey_LeftArrow, ImGuiKey_RightArrow, ImGuiKey_UpArrow, ImGuiKey_DownArrow);
    %%%%%:14431-block 148
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:14432:        if (g.NavInputSource == ImGuiInputSource_Gamepad)
    %%%%%:14432-block 149
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14433:            nav_move_dir = GetKeyMagnitude2d(ImGuiKey_GamepadLStickLeft, ImGuiKey_GamepadLStickRight, ImGuiKey_GamepadLStickUp, ImGuiKey_GamepadLStickDown);
    %%%%%:14433-block 150
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:14434:        if (nav_move_dir.x != 0.0f || nav_move_dir.y != 0.0f)
    %%%%%:14434-block 151
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14434-block 152
branch  2 never executed (fallthrough)
branch  3 never executed
        -:14435:        {
    #####:14436:            const float NAV_MOVE_SPEED = 800.0f;
    #####:14437:            const float move_step = NAV_MOVE_SPEED * io.DeltaTime * ImMin(io.DisplayFramebufferScale.x, io.DisplayFramebufferScale.y);
    %%%%%:14437-block 153
call    0 never executed
    #####:14438:            g.NavWindowingAccumDeltaPos += nav_move_dir * move_step;
call    0 never executed
call    1 never executed
    #####:14439:            g.NavHighlightItemUnderNav = true;
    #####:14440:            ImVec2 accum_floored = ImTrunc(g.NavWindowingAccumDeltaPos);
call    0 never executed
    #####:14441:            if (accum_floored.x != 0.0f || accum_floored.y != 0.0f)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14441-block 158
branch  2 never executed (fallthrough)
branch  3 never executed
        -:14442:            {
    #####:14443:                ImGuiWindow* moving_window = g.NavWindowingTarget->RootWindowDockTree;
    #####:14444:                SetWindowPos(moving_window, moving_window->Pos + accum_floored, ImGuiCond_Always);
    %%%%%:14444-block 159
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$:14444-block 205
    #####:14445:                g.NavWindowingAccumDeltaPos -= accum_floored;
    %%%%%:14445-block 161
call    0 never executed
        -:14446:            }
        -:14447:        }
        -:14448:    }
        -:14449:
        -:14450:    // Apply final focus
    1077*:14451:    if (apply_focus_window && (g.NavWindow == NULL || apply_focus_window != g.NavWindow->RootWindow))
     1077:14451-block 164
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:14451-block 165
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:14451-block 166
branch  4 never executed (fallthrough)
branch  5 never executed
        -:14452:    {
        -:14453:        // FIXME: Many actions here could be part of a higher-level/reused function. Why aren't they in FocusWindow()
        -:14454:        // Investigate for each of them: ClearActiveID(), NavRestoreHighlightAfterMove(), NavRestoreLastChildNavWindow(), ClosePopupsOverWindow(), NavInitWindow()
    #####:14455:        ImGuiViewport* previous_viewport = g.NavWindow ? g.NavWindow->Viewport : NULL;
    %%%%%:14455-block 167
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14455-block 168
    %%%%%:14455-block 169
    #####:14456:        ClearActiveID();
    %%%%%:14456-block 170
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:14457:        SetNavCursorVisibleAfterMove();
    %%%%%:14457-block 171
call    0 never executed
    #####:14458:        ClosePopupsOverWindow(apply_focus_window, false);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:14459:        FocusWindow(apply_focus_window, ImGuiFocusRequestFlags_RestoreFocusedChild);
    %%%%%:14459-block 173
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:14460:        apply_focus_window = g.NavWindow;
    #####:14461:        if (apply_focus_window->NavLastIds[0] == 0)
    %%%%%:14461-block 174
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14462:            NavInitWindow(apply_focus_window, false);
    %%%%%:14462-block 175
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:14463:
        -:14464:        // If the window has ONLY a menu layer (no main layer), select it directly
        -:14465:        // Use NavLayersActiveMaskNext since windows didn't have a chance to be Begin()-ed on this frame,
        -:14466:        // so CTRL+Tab where the keys are only held for 1 frame will be able to use correct layers mask since
        -:14467:        // the target window as already been previewed once.
        -:14468:        // FIXME-NAV: This should be done in NavInit.. or in FocusWindow... However in both of those cases,
        -:14469:        // we won't have a guarantee that windows has been visible before and therefore NavLayersActiveMask*
        -:14470:        // won't be valid.
    #####:14471:        if (apply_focus_window->DC.NavLayersActiveMaskNext == (1 << ImGuiNavLayer_Menu))
    %%%%%:14471-block 176
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14472:            g.NavLayer = ImGuiNavLayer_Menu;
    %%%%%:14472-block 177
        -:14473:
        -:14474:        // Request OS level focus
    #####:14475:        if (apply_focus_window->Viewport != previous_viewport && g.PlatformIO.Platform_SetWindowFocus)
    %%%%%:14475-block 178
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14475-block 179
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:14476:            g.PlatformIO.Platform_SetWindowFocus(apply_focus_window->Viewport);
    %%%%%:14476-block 180
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:14477:    }
     1077:14478:    if (apply_focus_window)
     1077:14478-block 181
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####:14479:        g.NavWindowingTarget = NULL;
    %%%%%:14479-block 182
        -:14480:
        -:14481:    // Apply menu/layer toggle
    1077*:14482:    if (apply_toggle_layer && g.NavWindow)
     1077:14482-block 183
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:14482-block 184
branch  2 never executed (fallthrough)
branch  3 never executed
        -:14483:    {
    #####:14484:        ClearActiveID();
    %%%%%:14484-block 185
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:14485:
        -:14486:        // Move to parent menu if necessary
    #####:14487:        ImGuiWindow* new_nav_window = g.NavWindow;
    #####:14488:        while (new_nav_window->ParentWindow
    %%%%%:14488-block 186
    #####:14489:            && (new_nav_window->DC.NavLayersActiveMask & (1 << ImGuiNavLayer_Menu)) == 0
    %%%%%:14489-block 189
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14490:            && (new_nav_window->Flags & ImGuiWindowFlags_ChildWindow) != 0
    %%%%%:14490-block 190
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14491:            && (new_nav_window->Flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_ChildMenu)) == 0)
    %%%%%:14491-block 188
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14491-block 191
branch  2 never executed
branch  3 never executed (fallthrough)
    #####:14492:            new_nav_window = new_nav_window->ParentWindow;
    %%%%%:14492-block 187
    #####:14493:        if (new_nav_window != g.NavWindow)
    %%%%%:14493-block 192
branch  0 never executed (fallthrough)
branch  1 never executed
        -:14494:        {
    #####:14495:            ImGuiWindow* old_nav_window = g.NavWindow;
    #####:14496:            FocusWindow(new_nav_window);
    %%%%%:14496-block 193
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:14497:            new_nav_window->NavLastChildNavWindow = old_nav_window;
    %%%%%:14497-block 194
        -:14498:        }
        -:14499:
        -:14500:        // Toggle layer
    #####:14501:        const ImGuiNavLayer new_nav_layer = (g.NavWindow->DC.NavLayersActiveMask & (1 << ImGuiNavLayer_Menu)) ? (ImGuiNavLayer)((int)g.NavLayer ^ 1) : ImGuiNavLayer_Main;
    %%%%%:14501-block 195
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14501-block 196
    %%%%%:14501-block 197
    #####:14502:        if (new_nav_layer != g.NavLayer)
    %%%%%:14502-block 198
branch  0 never executed (fallthrough)
branch  1 never executed
        -:14503:        {
        -:14504:            // Reinitialize navigation when entering menu bar with the Alt key (FIXME: could be a properly of the layer?)
    #####:14505:            const bool preserve_layer_1_nav_id = (new_nav_window->DockNodeAsHost != NULL);
    #####:14506:            if (new_nav_layer == ImGuiNavLayer_Menu && !preserve_layer_1_nav_id)
    %%%%%:14506-block 199
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14506-block 200
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:14507:                g.NavWindow->NavLastIds[new_nav_layer] = 0;
    %%%%%:14507-block 201
    #####:14508:            NavRestoreLayer(new_nav_layer);
    %%%%%:14508-block 202
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:14509:            SetNavCursorVisibleAfterMove();
    %%%%%:14509-block 203
call    0 never executed
        -:14510:        }
        -:14511:    }
     1077:14512:}
     1077:14512-block 204
        -:14513:
        -:14514:// Window has already passed the IsWindowNavFocusable()
function _ZL37GetFallbackWindowNameForWindowingListP11ImGuiWindow called 0 returned 0% blocks executed 0%
    #####:14515:static const char* GetFallbackWindowNameForWindowingList(ImGuiWindow* window)
        -:14516:{
    #####:14517:    if (window->Flags & ImGuiWindowFlags_Popup)
    %%%%%:14517-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14518:        return ImGui::LocalizeGetMsg(ImGuiLocKey_WindowingPopup);
    %%%%%:14518-block 3
call    0 never executed
    #####:14519:    if ((window->Flags & ImGuiWindowFlags_MenuBar) && strcmp(window->Name, "##MainMenuBar") == 0)
    %%%%%:14519-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14519-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:14520:        return ImGui::LocalizeGetMsg(ImGuiLocKey_WindowingMainMenuBar);
    %%%%%:14520-block 6
call    0 never executed
    #####:14521:    if (window->DockNodeAsHost)
    %%%%%:14521-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14522:        return "(Dock node)"; // Not normally shown to user.
    %%%%%:14522-block 8
    #####:14523:    return ImGui::LocalizeGetMsg(ImGuiLocKey_WindowingUntitled);
    %%%%%:14523-block 9
call    0 never executed
        -:14524:}
        -:14525:
        -:14526:// Overlay displayed when using CTRL+TAB. Called by EndFrame().
function _ZN5ImGuiL25NavUpdateWindowingOverlayEv called 0 returned 0% blocks executed 0%
    #####:14527:void ImGui::NavUpdateWindowingOverlay()
        -:14528:{
    #####:14529:    ImGuiContext& g = *GImGui;
    #####:14530:    IM_ASSERT(g.NavWindowingTarget != NULL);
    %%%%%:14530-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14530-block 3
call    2 never executed
        -:14531:
    #####:14532:    if (g.NavWindowingTimer < NAV_WINDOWING_LIST_APPEAR_DELAY)
    %%%%%:14532-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14533:        return;
    %%%%%:14533-block 5
        -:14534:
    #####:14535:    if (g.NavWindowingListWindow == NULL)
    %%%%%:14535-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14536:        g.NavWindowingListWindow = FindWindowByName("###NavWindowingList");
    %%%%%:14536-block 7
call    0 never executed
    #####:14537:    const ImGuiViewport* viewport = /*g.NavWindow ? g.NavWindow->Viewport :*/ GetMainViewport();
    %%%%%:14537-block 9
call    0 never executed
    #####:14538:    SetNextWindowSizeConstraints(ImVec2(viewport->Size.x * 0.20f, viewport->Size.y * 0.20f), ImVec2(FLT_MAX, FLT_MAX));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:14539:    SetNextWindowPos(viewport->GetCenter(), ImGuiCond_Always, ImVec2(0.5f, 0.5f));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:14540:    PushStyleVar(ImGuiStyleVar_WindowPadding, g.Style.WindowPadding * 2.0f);
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$:14540-block 39
call    4 never executed
    #####:14541:    Begin("###NavWindowingList", NULL, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings);
    %%%%%:14541-block 18
call    0 never executed
    #####:14542:    if (g.ContextName[0] != 0)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14543:        SeparatorText(g.ContextName);
    %%%%%:14543-block 20
call    0 never executed
    #####:14544:    for (int n = g.WindowsFocusOrder.Size - 1; n >= 0; n--)
    %%%%%:14544-block 21
    %%%%%:14544-block 34
    %%%%%:14544-block 35
branch  0 never executed
branch  1 never executed (fallthrough)
        -:14545:    {
    #####:14546:        ImGuiWindow* window = g.WindowsFocusOrder[n];
    %%%%%:14546-block 22
call    0 never executed
    #####:14547:        IM_ASSERT(window != NULL); // Fix static analyzers
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14547-block 24
call    2 never executed
    #####:14548:        if (!IsWindowNavFocusable(window))
    %%%%%:14548-block 25
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:14549:            continue;
    %%%%%:14549-block 27
    #####:14550:        const char* label = window->Name;
    #####:14551:        if (label == FindRenderedTextEnd(label))
    %%%%%:14551-block 28
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:14552:            label = GetFallbackWindowNameForWindowingList(window);
    %%%%%:14552-block 30
call    0 never executed
    #####:14553:        Selectable(label, g.NavWindowingTarget == window);
    %%%%%:14553-block 31
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:14553-block 33
        -:14554:    }
    #####:14555:    End();
    %%%%%:14555-block 36
call    0 never executed
    #####:14556:    PopStyleVar();
call    0 never executed
        -:14557:}
        -:14558:
        -:14559:
        -:14560://-----------------------------------------------------------------------------
        -:14561:// [SECTION] DRAG AND DROP
        -:14562://-----------------------------------------------------------------------------
        -:14563:
function _ZN5ImGui16IsDragDropActiveEv called 0 returned 0% blocks executed 0%
    #####:14564:bool ImGui::IsDragDropActive()
        -:14565:{
    #####:14566:    ImGuiContext& g = *GImGui;
    #####:14567:    return g.DragDropActive;
    %%%%%:14567-block 2
        -:14568:}
        -:14569:
function _ZN5ImGui13ClearDragDropEv called 0 returned 0% blocks executed 0%
    #####:14570:void ImGui::ClearDragDrop()
        -:14571:{
    #####:14572:    ImGuiContext& g = *GImGui;
    #####:14573:    if (g.DragDropActive)
    %%%%%:14573-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14574:        IMGUI_DEBUG_LOG_ACTIVEID("[dragdrop] ClearDragDrop()\n");
    %%%%%:14574-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14574-block 4
call    2 never executed
    #####:14575:    g.DragDropActive = false;
    #####:14576:    g.DragDropPayload.Clear();
    %%%%%:14576-block 5
call    0 never executed
    #####:14577:    g.DragDropAcceptFlags = ImGuiDragDropFlags_None;
    #####:14578:    g.DragDropAcceptIdCurr = g.DragDropAcceptIdPrev = 0;
    #####:14579:    g.DragDropAcceptIdCurrRectSurface = FLT_MAX;
    #####:14580:    g.DragDropAcceptFrameCount = -1;
        -:14581:
    #####:14582:    g.DragDropPayloadBufHeap.clear();
call    0 never executed
    #####:14583:    memset(&g.DragDropPayloadBufLocal, 0, sizeof(g.DragDropPayloadBufLocal));
    #####:14584:}
        -:14585:
function _ZN5ImGui18BeginTooltipHiddenEv called 0 returned 0% blocks executed 0%
    #####:14586:bool ImGui::BeginTooltipHidden()
        -:14587:{
    #####:14588:    ImGuiContext& g = *GImGui;
    #####:14589:    bool ret = Begin("##Tooltip_Hidden", NULL, ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_AlwaysAutoResize);
    %%%%%:14589-block 2
call    0 never executed
    #####:14590:    SetWindowHiddenAndSkipItemsForCurrentFrame(g.CurrentWindow);
call    0 never executed
    #####:14591:    return ret;
        -:14592:}
        -:14593:
        -:14594:// When this returns true you need to: a) call SetDragDropPayload() exactly once, b) you may render the payload visual/description, c) call EndDragDropSource()
        -:14595:// If the item has an identifier:
        -:14596:// - This assume/require the item to be activated (typically via ButtonBehavior).
        -:14597:// - Therefore if you want to use this with a mouse button other than left mouse button, it is up to the item itself to activate with another button.
        -:14598:// - We then pull and use the mouse button that was used to activate the item and use it to carry on the drag.
        -:14599:// If the item has no identifier:
        -:14600:// - Currently always assume left mouse button.
function _ZN5ImGui19BeginDragDropSourceEi called 0 returned 0% blocks executed 0%
    #####:14601:bool ImGui::BeginDragDropSource(ImGuiDragDropFlags flags)
        -:14602:{
    #####:14603:    ImGuiContext& g = *GImGui;
    #####:14604:    ImGuiWindow* window = g.CurrentWindow;
        -:14605:
        -:14606:    // FIXME-DRAGDROP: While in the common-most "drag from non-zero active id" case we can tell the mouse button,
        -:14607:    // in both SourceExtern and id==0 cases we may requires something else (explicit flags or some heuristic).
    #####:14608:    ImGuiMouseButton mouse_button = ImGuiMouseButton_Left;
        -:14609:
    #####:14610:    bool source_drag_active = false;
    #####:14611:    ImGuiID source_id = 0;
    #####:14612:    ImGuiID source_parent_id = 0;
    #####:14613:    if ((flags & ImGuiDragDropFlags_SourceExtern) == 0)
    %%%%%:14613-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -:14614:    {
    #####:14615:        source_id = g.LastItemData.ID;
    #####:14616:        if (source_id != 0)
    %%%%%:14616-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
        -:14617:        {
        -:14618:            // Common path: items with ID
    #####:14619:            if (g.ActiveId != source_id)
    %%%%%:14619-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14620:                return false;
    %%%%%:14620-block 5
    #####:14621:            if (g.ActiveIdMouseButton != -1)
    %%%%%:14621-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14622:                mouse_button = g.ActiveIdMouseButton;
    %%%%%:14622-block 7
    #####:14623:            if (g.IO.MouseDown[mouse_button] == false || window->SkipItems)
    %%%%%:14623-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14623-block 9
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:14624:                return false;
    %%%%%:14624-block 10
    #####:14625:            g.ActiveIdAllowOverlap = false;
    %%%%%:14625-block 11
        -:14626:        }
        -:14627:        else
        -:14628:        {
        -:14629:            // Uncommon path: items without ID
    #####:14630:            if (g.IO.MouseDown[mouse_button] == false || window->SkipItems)
    %%%%%:14630-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14630-block 13
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:14631:                return false;
    %%%%%:14631-block 14
    #####:14632:            if ((g.LastItemData.StatusFlags & ImGuiItemStatusFlags_HoveredRect) == 0 && (g.ActiveId == 0 || g.ActiveIdWindow != window))
    %%%%%:14632-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14632-block 16
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:14632-block 17
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:14633:                return false;
    %%%%%:14633-block 18
        -:14634:
        -:14635:            // If you want to use BeginDragDropSource() on an item with no unique identifier for interaction, such as Text() or Image(), you need to:
        -:14636:            // A) Read the explanation below, B) Use the ImGuiDragDropFlags_SourceAllowNullID flag.
    #####:14637:            if (!(flags & ImGuiDragDropFlags_SourceAllowNullID))
    %%%%%:14637-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
        -:14638:            {
    #####:14639:                IM_ASSERT(0);
    %%%%%:14639-block 20
call    0 never executed
        -:14640:                return false;
        -:14641:            }
        -:14642:
        -:14643:            // Magic fallback to handle items with no assigned ID, e.g. Text(), Image()
        -:14644:            // We build a throwaway ID based on current ID stack + relative AABB of items in window.
        -:14645:            // THE IDENTIFIER WON'T SURVIVE ANY REPOSITIONING/RESIZINGG OF THE WIDGET, so if your widget moves your dragging operation will be canceled.
        -:14646:            // We don't need to maintain/call ClearActiveID() as releasing the button will early out this function and trigger !ActiveIdIsAlive.
        -:14647:            // Rely on keeping other window->LastItemXXX fields intact.
    #####:14648:            source_id = g.LastItemData.ID = window->GetIDFromRectangle(g.LastItemData.Rect);
    %%%%%:14648-block 21
call    0 never executed
    #####:14649:            KeepAliveID(source_id);
call    0 never executed
    #####:14650:            bool is_hovered = ItemHoverable(g.LastItemData.Rect, source_id, g.LastItemData.ItemFlags);
call    0 never executed
    #####:14651:            if (is_hovered && g.IO.MouseClicked[mouse_button])
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14651-block 25
branch  2 never executed (fallthrough)
branch  3 never executed
        -:14652:            {
    #####:14653:                SetActiveID(source_id, window);
    %%%%%:14653-block 26
call    0 never executed
    #####:14654:                FocusWindow(window);
call    0 never executed
        -:14655:            }
    #####:14656:            if (g.ActiveId == source_id) // Allow the underlying widget to display/return hovered during the mouse release frame, else we would get a flicker.
    %%%%%:14656-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14657:                g.ActiveIdAllowOverlap = is_hovered;
    %%%%%:14657-block 29
        -:14658:        }
    #####:14659:        if (g.ActiveId != source_id)
    %%%%%:14659-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14660:            return false;
    %%%%%:14660-block 31
    #####:14661:        source_parent_id = window->IDStack.back();
    %%%%%:14661-block 32
call    0 never executed
    #####:14662:        source_drag_active = IsMouseDragging(mouse_button);
call    0 never executed
        -:14663:
        -:14664:        // Disable navigation and key inputs while dragging + cancel existing request if any
    #####:14665:        SetActiveIdUsingAllKeyboardKeys();
call    0 never executed
        -:14666:    }
        -:14667:    else
        -:14668:    {
        -:14669:        // When ImGuiDragDropFlags_SourceExtern is set:
    #####:14670:        window = NULL;
    #####:14671:        source_id = ImHashStr("#SourceExtern");
    %%%%%:14671-block 35
call    0 never executed
    #####:14672:        source_drag_active = true;
    #####:14673:        mouse_button = g.IO.MouseDown[0] ? 0 : -1;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14673-block 37
    %%%%%:14673-block 38
    #####:14674:        KeepAliveID(source_id);
    %%%%%:14674-block 39
call    0 never executed
    #####:14675:        SetActiveID(source_id, NULL);
call    0 never executed
        -:14676:    }
        -:14677:
    #####:14678:    IM_ASSERT(g.DragDropWithinTarget == false); // Can't nest BeginDragDropSource() and BeginDragDropTarget()
    %%%%%:14678-block 41
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14678-block 42
call    2 never executed
    #####:14679:    if (!source_drag_active)
    %%%%%:14679-block 43
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14680:        return false;
    %%%%%:14680-block 44
        -:14681:
        -:14682:    // Activate drag and drop
    #####:14683:    if (!g.DragDropActive)
    %%%%%:14683-block 45
branch  0 never executed (fallthrough)
branch  1 never executed
        -:14684:    {
    #####:14685:        IM_ASSERT(source_id != 0);
    %%%%%:14685-block 46
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14685-block 47
call    2 never executed
    #####:14686:        ClearDragDrop();
    %%%%%:14686-block 48
call    0 never executed
    #####:14687:        IMGUI_DEBUG_LOG_ACTIVEID("[dragdrop] BeginDragDropSource() DragDropActive = true, source_id = 0x%08X%s\n",
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14687-block 50
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:14687-block 51
    %%%%%:14687-block 52
    %%%%%:14687-block 53
call    4 never executed
        -:14688:            source_id, (flags & ImGuiDragDropFlags_SourceExtern) ? " (EXTERN)" : "");
    #####:14689:        ImGuiPayload& payload = g.DragDropPayload;
    #####:14690:        payload.SourceId = source_id;
    #####:14691:        payload.SourceParentId = source_parent_id;
    #####:14692:        g.DragDropActive = true;
    #####:14693:        g.DragDropSourceFlags = flags;
    #####:14694:        g.DragDropMouseButton = mouse_button;
    #####:14695:        if (payload.SourceId == g.ActiveId)
    %%%%%:14695-block 54
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14696:            g.ActiveIdNoClearOnFocusLoss = true;
    %%%%%:14696-block 55
        -:14697:    }
    #####:14698:    g.DragDropSourceFrameCount = g.FrameCount;
    #####:14699:    g.DragDropWithinSource = true;
        -:14700:
    #####:14701:    if (!(flags & ImGuiDragDropFlags_SourceNoPreviewTooltip))
    %%%%%:14701-block 56
branch  0 never executed (fallthrough)
branch  1 never executed
        -:14702:    {
        -:14703:        // Target can request the Source to not display its tooltip (we use a dedicated flag to make this request explicit)
        -:14704:        // We unfortunately can't just modify the source flags and skip the call to BeginTooltip, as caller may be emitting contents.
        -:14705:        bool ret;
    #####:14706:        if (g.DragDropAcceptIdPrev && (g.DragDropAcceptFlags & ImGuiDragDropFlags_AcceptNoPreviewTooltip))
    %%%%%:14706-block 57
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14706-block 58
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:14707:            ret = BeginTooltipHidden();
    %%%%%:14707-block 59
call    0 never executed
        -:14708:        else
    #####:14709:            ret = BeginTooltip();
    %%%%%:14709-block 61
call    0 never executed
    #####:14710:        IM_ASSERT(ret); // FIXME-NEWBEGIN: If this ever becomes false, we need to Begin("##Hidden", NULL, ImGuiWindowFlags_NoSavedSettings) + SetWindowHiddendAndSkipItemsForCurrentFrame().
    %%%%%:14710-block 63
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14710-block 64
call    2 never executed
        -:14711:        IM_UNUSED(ret);
        -:14712:    }
        -:14713:
    #####:14714:    if (!(flags & ImGuiDragDropFlags_SourceNoDisableHover) && !(flags & ImGuiDragDropFlags_SourceExtern))
    %%%%%:14714-block 65
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14714-block 66
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:14715:        g.LastItemData.StatusFlags &= ~ImGuiItemStatusFlags_HoveredRect;
    %%%%%:14715-block 67
        -:14716:
    #####:14717:    return true;
    %%%%%:14717-block 68
        -:14718:}
        -:14719:
function _ZN5ImGui17EndDragDropSourceEv called 0 returned 0% blocks executed 0%
    #####:14720:void ImGui::EndDragDropSource()
        -:14721:{
    #####:14722:    ImGuiContext& g = *GImGui;
    #####:14723:    IM_ASSERT(g.DragDropActive);
    %%%%%:14723-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14723-block 3
call    2 never executed
    #####:14724:    IM_ASSERT(g.DragDropWithinSource && "Not after a BeginDragDropSource()?");
    %%%%%:14724-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14724-block 5
call    2 never executed
        -:14725:
    #####:14726:    if (!(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoPreviewTooltip))
    %%%%%:14726-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14727:        EndTooltip();
    %%%%%:14727-block 7
call    0 never executed
        -:14728:
        -:14729:    // Discard the drag if have not called SetDragDropPayload()
    #####:14730:    if (g.DragDropPayload.DataFrameCount == -1)
    %%%%%:14730-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14731:        ClearDragDrop();
    %%%%%:14731-block 9
call    0 never executed
    #####:14732:    g.DragDropWithinSource = false;
    #####:14733:}
        -:14734:
        -:14735:// Use 'cond' to choose to submit payload on drag start or every frame
function _ZN5ImGui18SetDragDropPayloadEPKcPKvmi called 0 returned 0% blocks executed 0%
    #####:14736:bool ImGui::SetDragDropPayload(const char* type, const void* data, size_t data_size, ImGuiCond cond)
        -:14737:{
    #####:14738:    ImGuiContext& g = *GImGui;
    #####:14739:    ImGuiPayload& payload = g.DragDropPayload;
    #####:14740:    if (cond == 0)
    %%%%%:14740-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14741:        cond = ImGuiCond_Always;
    %%%%%:14741-block 3
        -:14742:
    #####:14743:    IM_ASSERT(type != NULL);
    %%%%%:14743-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14743-block 5
call    2 never executed
    #####:14744:    IM_ASSERT(strlen(type) < IM_ARRAYSIZE(payload.DataType) && "Payload type can be at most 32 characters long");
    %%%%%:14744-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14744-block 7
call    2 never executed
    #####:14745:    IM_ASSERT((data != NULL && data_size > 0) || (data == NULL && data_size == 0));
    %%%%%:14745-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14745-block 9
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:14745-block 10
    %%%%%:14745-block 11
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:14745-block 12
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%:14745-block 13
    %%%%%:14745-block 14
call    8 never executed
    #####:14746:    IM_ASSERT(cond == ImGuiCond_Always || cond == ImGuiCond_Once);
    %%%%%:14746-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14746-block 16
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:14746-block 17
call    4 never executed
    #####:14747:    IM_ASSERT(payload.SourceId != 0); // Not called between BeginDragDropSource() and EndDragDropSource()
    %%%%%:14747-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14747-block 19
call    2 never executed
        -:14748:
    #####:14749:    if (cond == ImGuiCond_Always || payload.DataFrameCount == -1)
    %%%%%:14749-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14749-block 21
branch  2 never executed (fallthrough)
branch  3 never executed
        -:14750:    {
        -:14751:        // Copy payload
    #####:14752:        ImStrncpy(payload.DataType, type, IM_ARRAYSIZE(payload.DataType));
    %%%%%:14752-block 22
call    0 never executed
    #####:14753:        g.DragDropPayloadBufHeap.resize(0);
call    0 never executed
    #####:14754:        if (data_size > sizeof(g.DragDropPayloadBufLocal))
branch  0 never executed (fallthrough)
branch  1 never executed
        -:14755:        {
        -:14756:            // Store in heap
    #####:14757:            g.DragDropPayloadBufHeap.resize((int)data_size);
    %%%%%:14757-block 25
call    0 never executed
    #####:14758:            payload.Data = g.DragDropPayloadBufHeap.Data;
    #####:14759:            memcpy(payload.Data, data, data_size);
        -:14760:        }
    #####:14761:        else if (data_size > 0)
    %%%%%:14761-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
        -:14762:        {
        -:14763:            // Store locally
    #####:14764:            memset(&g.DragDropPayloadBufLocal, 0, sizeof(g.DragDropPayloadBufLocal));
    #####:14765:            payload.Data = g.DragDropPayloadBufLocal;
    #####:14766:            memcpy(payload.Data, data, data_size);
    %%%%%:14766-block 28
        -:14767:        }
        -:14768:        else
        -:14769:        {
    #####:14770:            payload.Data = NULL;
    %%%%%:14770-block 29
        -:14771:        }
    #####:14772:        payload.DataSize = (int)data_size;
    %%%%%:14772-block 30
        -:14773:    }
    #####:14774:    payload.DataFrameCount = g.FrameCount;
        -:14775:
        -:14776:    // Return whether the payload has been accepted
    #####:14777:    return (g.DragDropAcceptFrameCount == g.FrameCount) || (g.DragDropAcceptFrameCount == g.FrameCount - 1);
    %%%%%:14777-block 31
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14777-block 32
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:14777-block 33
    %%%%%:14777-block 34
    %%%%%:14777-block 35
        -:14778:}
        -:14779:
function _ZN5ImGui25BeginDragDropTargetCustomERK6ImRectj called 0 returned 0% blocks executed 0%
    #####:14780:bool ImGui::BeginDragDropTargetCustom(const ImRect& bb, ImGuiID id)
        -:14781:{
    #####:14782:    ImGuiContext& g = *GImGui;
    #####:14783:    if (!g.DragDropActive)
    %%%%%:14783-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14784:        return false;
    %%%%%:14784-block 3
        -:14785:
    #####:14786:    ImGuiWindow* window = g.CurrentWindow;
    #####:14787:    ImGuiWindow* hovered_window = g.HoveredWindowUnderMovingWindow;
    #####:14788:    if (hovered_window == NULL || window->RootWindowDockTree != hovered_window->RootWindowDockTree)
    %%%%%:14788-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14788-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:14789:        return false;
    %%%%%:14789-block 6
    #####:14790:    IM_ASSERT(id != 0);
    %%%%%:14790-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14790-block 8
call    2 never executed
    #####:14791:    if (!IsMouseHoveringRect(bb.Min, bb.Max) || (id == g.DragDropPayload.SourceId))
    %%%%%:14791-block 9
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:14791-block 11
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:14791-block 12
    %%%%%:14791-block 13
    %%%%%:14791-block 14
branch  5 never executed (fallthrough)
branch  6 never executed
    #####:14792:        return false;
    %%%%%:14792-block 15
    #####:14793:    if (window->SkipItems)
    %%%%%:14793-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14794:        return false;
    %%%%%:14794-block 17
        -:14795:
    #####:14796:    IM_ASSERT(g.DragDropWithinTarget == false && g.DragDropWithinSource == false); // Can't nest BeginDragDropSource() and BeginDragDropTarget()
    %%%%%:14796-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14796-block 19
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:14796-block 20
    %%%%%:14796-block 21
call    4 never executed
    #####:14797:    g.DragDropTargetRect = bb;
    #####:14798:    g.DragDropTargetClipRect = window->ClipRect; // May want to be overridden by user depending on use case?
    #####:14799:    g.DragDropTargetId = id;
    #####:14800:    g.DragDropWithinTarget = true;
    #####:14801:    return true;
    %%%%%:14801-block 22
        -:14802:}
        -:14803:
        -:14804:// We don't use BeginDragDropTargetCustom() and duplicate its code because:
        -:14805:// 1) we use LastItemData's ImGuiItemStatusFlags_HoveredRect which handles items that push a temporarily clip rectangle in their code. Calling BeginDragDropTargetCustom(LastItemRect) would not handle them.
        -:14806:// 2) and it's faster. as this code may be very frequently called, we want to early out as fast as we can.
        -:14807:// Also note how the HoveredWindow test is positioned differently in both functions (in both functions we optimize for the cheapest early out case)
function _ZN5ImGui19BeginDragDropTargetEv called 0 returned 0% blocks executed 0%
    #####:14808:bool ImGui::BeginDragDropTarget()
        -:14809:{
    #####:14810:    ImGuiContext& g = *GImGui;
    #####:14811:    if (!g.DragDropActive)
    %%%%%:14811-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14812:        return false;
    %%%%%:14812-block 3
        -:14813:
    #####:14814:    ImGuiWindow* window = g.CurrentWindow;
    #####:14815:    if (!(g.LastItemData.StatusFlags & ImGuiItemStatusFlags_HoveredRect))
    %%%%%:14815-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14816:        return false;
    %%%%%:14816-block 5
    #####:14817:    ImGuiWindow* hovered_window = g.HoveredWindowUnderMovingWindow;
    #####:14818:    if (hovered_window == NULL || window->RootWindowDockTree != hovered_window->RootWindowDockTree || window->SkipItems)
    %%%%%:14818-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14818-block 7
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:14818-block 8
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:14819:        return false;
    %%%%%:14819-block 9
        -:14820:
    #####:14821:    const ImRect& display_rect = (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_HasDisplayRect) ? g.LastItemData.DisplayRect : g.LastItemData.Rect;
    %%%%%:14821-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14821-block 11
    %%%%%:14821-block 12
    #####:14822:    ImGuiID id = g.LastItemData.ID;
    #####:14823:    if (id == 0)
    %%%%%:14823-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
        -:14824:    {
    #####:14825:        id = window->GetIDFromRectangle(display_rect);
    %%%%%:14825-block 14
call    0 never executed
    #####:14826:        KeepAliveID(id);
call    0 never executed
        -:14827:    }
    #####:14828:    if (g.DragDropPayload.SourceId == id)
    %%%%%:14828-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14829:        return false;
    %%%%%:14829-block 17
        -:14830:
    #####:14831:    IM_ASSERT(g.DragDropWithinTarget == false && g.DragDropWithinSource == false); // Can't nest BeginDragDropSource() and BeginDragDropTarget()
    %%%%%:14831-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14831-block 19
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:14831-block 20
    %%%%%:14831-block 21
call    4 never executed
    #####:14832:    g.DragDropTargetRect = display_rect;
    #####:14833:    g.DragDropTargetClipRect = (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_HasClipRect) ? g.LastItemData.ClipRect : window->ClipRect;
    %%%%%:14833-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14833-block 23
    %%%%%:14833-block 24
    #####:14834:    g.DragDropTargetId = id;
    #####:14835:    g.DragDropWithinTarget = true;
    #####:14836:    return true;
    %%%%%:14836-block 25
        -:14837:}
        -:14838:
function _ZN5ImGui30IsDragDropPayloadBeingAcceptedEv called 0 returned 0% blocks executed 0%
    #####:14839:bool ImGui::IsDragDropPayloadBeingAccepted()
        -:14840:{
    #####:14841:    ImGuiContext& g = *GImGui;
    #####:14842:    return g.DragDropActive && g.DragDropAcceptIdPrev != 0;
    %%%%%:14842-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14842-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:14842-block 4
    %%%%%:14842-block 5
    %%%%%:14842-block 6
        -:14843:}
        -:14844:
function _ZN5ImGui21AcceptDragDropPayloadEPKci called 0 returned 0% blocks executed 0%
    #####:14845:const ImGuiPayload* ImGui::AcceptDragDropPayload(const char* type, ImGuiDragDropFlags flags)
        -:14846:{
    #####:14847:    ImGuiContext& g = *GImGui;
    #####:14848:    ImGuiPayload& payload = g.DragDropPayload;
    #####:14849:    IM_ASSERT(g.DragDropActive);                        // Not called between BeginDragDropTarget() and EndDragDropTarget() ?
    %%%%%:14849-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14849-block 3
call    2 never executed
    #####:14850:    IM_ASSERT(payload.DataFrameCount != -1);            // Forgot to call EndDragDropTarget() ?
    %%%%%:14850-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14850-block 5
call    2 never executed
    #####:14851:    if (type != NULL && !payload.IsDataType(type))
    %%%%%:14851-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14851-block 7
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:14851-block 9
    %%%%%:14851-block 10
    %%%%%:14851-block 11
branch  5 never executed (fallthrough)
branch  6 never executed
    #####:14852:        return NULL;
    %%%%%:14852-block 12
        -:14853:
        -:14854:    // Accept smallest drag target bounding box, this allows us to nest drag targets conveniently without ordering constraints.
        -:14855:    // NB: We currently accept NULL id as target. However, overlapping targets requires a unique ID to function!
    #####:14856:    const bool was_accepted_previously = (g.DragDropAcceptIdPrev == g.DragDropTargetId);
    #####:14857:    ImRect r = g.DragDropTargetRect;
    #####:14858:    float r_surface = r.GetWidth() * r.GetHeight();
    %%%%%:14858-block 13
call    0 never executed
call    1 never executed
    #####:14859:    if (r_surface > g.DragDropAcceptIdCurrRectSurface)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14860:        return NULL;
    %%%%%:14860-block 16
        -:14861:
    #####:14862:    g.DragDropAcceptFlags = flags;
    #####:14863:    g.DragDropAcceptIdCurr = g.DragDropTargetId;
    #####:14864:    g.DragDropAcceptIdCurrRectSurface = r_surface;
        -:14865:    //IMGUI_DEBUG_LOG("AcceptDragDropPayload(): %08X: accept\n", g.DragDropTargetId);
        -:14866:
        -:14867:    // Render default drop visuals
    #####:14868:    payload.Preview = was_accepted_previously;
    #####:14869:    flags |= (g.DragDropSourceFlags & ImGuiDragDropFlags_AcceptNoDrawDefaultRect); // Source can also inhibit the preview (useful for external sources that live for 1 frame)
    #####:14870:    if (!(flags & ImGuiDragDropFlags_AcceptNoDrawDefaultRect) && payload.Preview)
    %%%%%:14870-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14870-block 18
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:14871:        RenderDragDropTargetRect(r, g.DragDropTargetClipRect);
    %%%%%:14871-block 19
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:14872:
    #####:14873:    g.DragDropAcceptFrameCount = g.FrameCount;
    #####:14874:    if ((g.DragDropSourceFlags & ImGuiDragDropFlags_SourceExtern) && g.DragDropMouseButton == -1)
    %%%%%:14874-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14874-block 21
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:14875:        payload.Delivery = was_accepted_previously && (g.DragDropSourceFrameCount < g.FrameCount);
    %%%%%:14875-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14875-block 23
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:14875-block 24
    %%%%%:14875-block 25
    %%%%%:14875-block 26
        -:14876:    else
    #####:14877:        payload.Delivery = was_accepted_previously && !IsMouseDown(g.DragDropMouseButton); // For extern drag sources affecting OS window focus, it's easier to just test !IsMouseDown() instead of IsMouseReleased()
    %%%%%:14877-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14877-block 28
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%:14877-block 29
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:14877-block 30
    %%%%%:14877-block 31
    %%%%%:14877-block 32
    #####:14878:    if (!payload.Delivery && !(flags & ImGuiDragDropFlags_AcceptBeforeDelivery))
    %%%%%:14878-block 33
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14878-block 34
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:14879:        return NULL;
    %%%%%:14879-block 35
        -:14880:
    #####:14881:    if (payload.Delivery)
    %%%%%:14881-block 36
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14882:        IMGUI_DEBUG_LOG_ACTIVEID("[dragdrop] AcceptDragDropPayload(): 0x%08X: payload delivery\n", g.DragDropTargetId);
    %%%%%:14882-block 37
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14882-block 38
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####:14883:    return &payload;
    %%%%%:14883-block 39
        -:14884:}
        -:14885:
        -:14886:// FIXME-STYLE FIXME-DRAGDROP: Settle on a proper default visuals for drop target.
function _ZN5ImGui24RenderDragDropTargetRectERK6ImRectS2_ called 0 returned 0% blocks executed 0%
    #####:14887:void ImGui::RenderDragDropTargetRect(const ImRect& bb, const ImRect& item_clip_rect)
        -:14888:{
    #####:14889:    ImGuiContext& g = *GImGui;
    #####:14890:    ImGuiWindow* window = g.CurrentWindow;
    #####:14891:    ImRect bb_display = bb;
    #####:14892:    bb_display.ClipWith(item_clip_rect); // Clip THEN expand so we have a way to visualize that target is not entirely visible.
    %%%%%:14892-block 2
call    0 never executed
    #####:14893:    bb_display.Expand(3.5f);
call    0 never executed
    #####:14894:    bool push_clip_rect = !window->ClipRect.Contains(bb_display);
call    0 never executed
    #####:14895:    if (push_clip_rect)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14896:        window->DrawList->PushClipRectFullScreen();
    %%%%%:14896-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:14897:    window->DrawList->AddRect(bb_display.Min, bb_display.Max, GetColorU32(ImGuiCol_DragDropTarget), 0.0f, 0, 2.0f);
    %%%%%:14897-block 7
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####:14898:    if (push_clip_rect)
    %%%%%:14898-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14899:        window->DrawList->PopClipRect();
    %%%%%:14899-block 10
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:14900:}
    %%%%%:14900-block 11
        -:14901:
function _ZN5ImGui18GetDragDropPayloadEv called 0 returned 0% blocks executed 0%
    #####:14902:const ImGuiPayload* ImGui::GetDragDropPayload()
        -:14903:{
    #####:14904:    ImGuiContext& g = *GImGui;
    #####:14905:    return (g.DragDropActive && g.DragDropPayload.DataFrameCount != -1) ? &g.DragDropPayload : NULL;
    %%%%%:14905-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14905-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:14905-block 4
    %%%%%:14905-block 5
    %%%%%:14905-block 6
        -:14906:}
        -:14907:
function _ZN5ImGui17EndDragDropTargetEv called 0 returned 0% blocks executed 0%
    #####:14908:void ImGui::EndDragDropTarget()
        -:14909:{
    #####:14910:    ImGuiContext& g = *GImGui;
    #####:14911:    IM_ASSERT(g.DragDropActive);
    %%%%%:14911-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14911-block 3
call    2 never executed
    #####:14912:    IM_ASSERT(g.DragDropWithinTarget);
    %%%%%:14912-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14912-block 5
call    2 never executed
    #####:14913:    g.DragDropWithinTarget = false;
        -:14914:
        -:14915:    // Clear drag and drop state payload right after delivery
    #####:14916:    if (g.DragDropPayload.Delivery)
    %%%%%:14916-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14917:        ClearDragDrop();
    %%%%%:14917-block 7
call    0 never executed
    #####:14918:}
        -:14919:
        -:14920://-----------------------------------------------------------------------------
        -:14921:// [SECTION] LOGGING/CAPTURING
        -:14922://-----------------------------------------------------------------------------
        -:14923:// All text output from the interface can be captured into tty/file/clipboard.
        -:14924:// By default, tree nodes are automatically opened during logging.
        -:14925://-----------------------------------------------------------------------------
        -:14926:
        -:14927:// Pass text data straight to log (without being displayed)
function _ZL8LogTextVR12ImGuiContextPKcP13__va_list_tag called 0 returned 0% blocks executed 0%
    #####:14928:static inline void LogTextV(ImGuiContext& g, const char* fmt, va_list args)
        -:14929:{
    #####:14930:    if (g.LogFile)
    %%%%%:14930-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -:14931:    {
    #####:14932:        g.LogBuffer.Buf.resize(0);
    %%%%%:14932-block 3
call    0 never executed
    #####:14933:        g.LogBuffer.appendfv(fmt, args);
call    0 never executed
    #####:14934:        ImFileWrite(g.LogBuffer.c_str(), sizeof(char), (ImU64)g.LogBuffer.size(), g.LogFile);
call    0 never executed
call    1 never executed
call    2 never executed
        -:14935:    }
        -:14936:    else
        -:14937:    {
    #####:14938:        g.LogBuffer.appendfv(fmt, args);
    %%%%%:14938-block 8
call    0 never executed
        -:14939:    }
    #####:14940:}
        -:14941:
function _ZN5ImGui7LogTextEPKcz called 0 returned 0% blocks executed 0%
    #####:14942:void ImGui::LogText(const char* fmt, ...)
        -:14943:{
    #####:14944:    ImGuiContext& g = *GImGui;
    #####:14945:    if (!g.LogEnabled)
    %%%%%:14945-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14946:        return;
    %%%%%:14946-block 3
        -:14947:
        -:14948:    va_list args;
    #####:14949:    va_start(args, fmt);
    #####:14950:    LogTextV(g, fmt, args);
    %%%%%:14950-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:14951:    va_end(args);
    %%%%%:14951-block 5
        -:14952:}
        -:14953:
function _ZN5ImGui8LogTextVEPKcP13__va_list_tag called 0 returned 0% blocks executed 0%
    #####:14954:void ImGui::LogTextV(const char* fmt, va_list args)
        -:14955:{
    #####:14956:    ImGuiContext& g = *GImGui;
    #####:14957:    if (!g.LogEnabled)
    %%%%%:14957-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14958:        return;
    %%%%%:14958-block 3
        -:14959:
    #####:14960:    LogTextV(g, fmt, args);
    %%%%%:14960-block 4
call    0 never executed
        -:14961:}
        -:14962:
        -:14963:// Internal version that takes a position to decide on newline placement and pad items according to their depth.
        -:14964:// We split text into individual lines to add current tree level padding
        -:14965:// FIXME: This code is a little complicated perhaps, considering simplifying the whole system.
function _ZN5ImGui15LogRenderedTextEPK6ImVec2PKcS4_ called 0 returned 0% blocks executed 0%
    #####:14966:void ImGui::LogRenderedText(const ImVec2* ref_pos, const char* text, const char* text_end)
        -:14967:{
    #####:14968:    ImGuiContext& g = *GImGui;
    #####:14969:    ImGuiWindow* window = g.CurrentWindow;
        -:14970:
    #####:14971:    const char* prefix = g.LogNextPrefix;
    #####:14972:    const char* suffix = g.LogNextSuffix;
    #####:14973:    g.LogNextPrefix = g.LogNextSuffix = NULL;
        -:14974:
    #####:14975:    if (!text_end)
    %%%%%:14975-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14976:        text_end = FindRenderedTextEnd(text, text_end);
    %%%%%:14976-block 3
call    0 never executed
        -:14977:
    #####:14978:    const bool log_new_line = ref_pos && (ref_pos->y > g.LogLinePosY + g.Style.FramePadding.y + 1);
    %%%%%:14978-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:14978-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:14978-block 6
    %%%%%:14978-block 7
    #####:14979:    if (ref_pos)
    %%%%%:14979-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14980:        g.LogLinePosY = ref_pos->y;
    %%%%%:14980-block 9
    #####:14981:    if (log_new_line)
    %%%%%:14981-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
        -:14982:    {
    #####:14983:        LogText(IM_NEWLINE);
    %%%%%:14983-block 11
call    0 never executed
    #####:14984:        g.LogLineFirstItem = true;
        -:14985:    }
        -:14986:
    #####:14987:    if (prefix)
    %%%%%:14987-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14988:        LogRenderedText(ref_pos, prefix, prefix + strlen(prefix)); // Calculate end ourself to ensure "##" are included here.
    %%%%%:14988-block 14
call    0 never executed
        -:14989:
        -:14990:    // Re-adjust padding if we have popped out of our starting depth
    #####:14991:    if (g.LogDepthRef > window->DC.TreeDepth)
    %%%%%:14991-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:14992:        g.LogDepthRef = window->DC.TreeDepth;
    %%%%%:14992-block 16
    #####:14993:    const int tree_depth = (window->DC.TreeDepth - g.LogDepthRef);
        -:14994:
    #####:14995:    const char* text_remaining = text;
    %%%%%:14995-block 17
        -:14996:    for (;;)
        -:14997:    {
        -:14998:        // Split the string. Each new line (after a '\n') is followed by indentation corresponding to the current depth of our log entry.
        -:14999:        // We don't add a trailing \n yet to allow a subsequent item on the same line to be captured.
    #####:15000:        const char* line_start = text_remaining;
    #####:15001:        const char* line_end = ImStreolRange(line_start, text_end);
    %%%%%:15001-block 18
call    0 never executed
    #####:15002:        const bool is_last_line = (line_end == text_end);
    #####:15003:        if (line_start != line_end || !is_last_line)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:15003-block 20
branch  2 never executed (fallthrough)
branch  3 never executed
        -:15004:        {
    #####:15005:            const int line_length = (int)(line_end - line_start);
    #####:15006:            const int indentation = g.LogLineFirstItem ? tree_depth * 4 : 1;
    %%%%%:15006-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:15006-block 22
    %%%%%:15006-block 23
    #####:15007:            LogText("%*s%.*s", indentation, "", line_length, line_start);
    %%%%%:15007-block 24
call    0 never executed
    #####:15008:            g.LogLineFirstItem = false;
    #####:15009:            if (*line_end == '\n')
branch  0 never executed (fallthrough)
branch  1 never executed
        -:15010:            {
    #####:15011:                LogText(IM_NEWLINE);
    %%%%%:15011-block 26
call    0 never executed
    #####:15012:                g.LogLineFirstItem = true;
        -:15013:            }
        -:15014:        }
    #####:15015:        if (is_last_line)
    %%%%%:15015-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:15016:            break;
    %%%%%:15016-block 29
    #####:15017:        text_remaining = line_end + 1;
    #####:15018:    }
    %%%%%:15018-block 30
        -:15019:
    #####:15020:    if (suffix)
    %%%%%:15020-block 31
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:15021:        LogRenderedText(ref_pos, suffix, suffix + strlen(suffix));
    %%%%%:15021-block 32
call    0 never executed
    #####:15022:}
        -:15023:
        -:15024:// Start logging/capturing text output
function _ZN5ImGui8LogBeginE12ImGuiLogTypei called 0 returned 0% blocks executed 0%
    #####:15025:void ImGui::LogBegin(ImGuiLogType type, int auto_open_depth)
        -:15026:{
    #####:15027:    ImGuiContext& g = *GImGui;
    #####:15028:    ImGuiWindow* window = g.CurrentWindow;
    #####:15029:    IM_ASSERT(g.LogEnabled == false);
    %%%%%:15029-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:15029-block 3
call    2 never executed
    #####:15030:    IM_ASSERT(g.LogFile == NULL);
    %%%%%:15030-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:15030-block 5
call    2 never executed
    #####:15031:    IM_ASSERT(g.LogBuffer.empty());
    %%%%%:15031-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:15031-block 8
call    3 never executed
    #####:15032:    g.LogEnabled = g.ItemUnclipByLog = true;
    #####:15033:    g.LogType = type;
    #####:15034:    g.LogNextPrefix = g.LogNextSuffix = NULL;
    #####:15035:    g.LogDepthRef = window->DC.TreeDepth;
    #####:15036:    g.LogDepthToExpand = ((auto_open_depth >= 0) ? auto_open_depth : g.LogDepthToExpandDefault);
    %%%%%:15036-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:15036-block 10
    %%%%%:15036-block 11
    #####:15037:    g.LogLinePosY = FLT_MAX;
    #####:15038:    g.LogLineFirstItem = true;
    #####:15039:}
        -:15040:
        -:15041:// Important: doesn't copy underlying data, use carefully (prefix/suffix must be in scope at the time of the next LogRenderedText)
function _ZN5ImGui24LogSetNextTextDecorationEPKcS1_ called 0 returned 0% blocks executed 0%
    #####:15042:void ImGui::LogSetNextTextDecoration(const char* prefix, const char* suffix)
        -:15043:{
    #####:15044:    ImGuiContext& g = *GImGui;
    #####:15045:    g.LogNextPrefix = prefix;
    #####:15046:    g.LogNextSuffix = suffix;
    #####:15047:}
        -:15048:
function _ZN5ImGui8LogToTTYEi called 0 returned 0% blocks executed 0%
    #####:15049:void ImGui::LogToTTY(int auto_open_depth)
        -:15050:{
    #####:15051:    ImGuiContext& g = *GImGui;
    #####:15052:    if (g.LogEnabled)
    %%%%%:15052-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:15053:        return;
    %%%%%:15053-block 3
        -:15054:    IM_UNUSED(auto_open_depth);
        -:15055:#ifndef IMGUI_DISABLE_TTY_FUNCTIONS
    #####:15056:    LogBegin(ImGuiLogType_TTY, auto_open_depth);
    %%%%%:15056-block 4
call    0 never executed
    #####:15057:    g.LogFile = stdout;
        -:15058:#endif
        -:15059:}
        -:15060:
        -:15061:// Start logging/capturing text output to given file
function _ZN5ImGui9LogToFileEiPKc called 0 returned 0% blocks executed 0%
    #####:15062:void ImGui::LogToFile(int auto_open_depth, const char* filename)
        -:15063:{
    #####:15064:    ImGuiContext& g = *GImGui;
    #####:15065:    if (g.LogEnabled)
    %%%%%:15065-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:15066:        return;
    %%%%%:15066-block 3
        -:15067:
        -:15068:    // FIXME: We could probably open the file in text mode "at", however note that clipboard/buffer logging will still
        -:15069:    // be subject to outputting OS-incompatible carriage return if within strings the user doesn't use IM_NEWLINE.
        -:15070:    // By opening the file in binary mode "ab" we have consistent output everywhere.
    #####:15071:    if (!filename)
    %%%%%:15071-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:15072:        filename = g.IO.LogFilename;
    %%%%%:15072-block 5
    #####:15073:    if (!filename || !filename[0])
    %%%%%:15073-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:15073-block 7
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:15074:        return;
    %%%%%:15074-block 8
    #####:15075:    ImFileHandle f = ImFileOpen(filename, "ab");
    %%%%%:15075-block 9
call    0 never executed
    #####:15076:    if (!f)
branch  0 never executed (fallthrough)
branch  1 never executed
        -:15077:    {
    #####:15078:        IM_ASSERT(0);
    %%%%%:15078-block 11
call    0 never executed
        -:15079:        return;
        -:15080:    }
        -:15081:
    #####:15082:    LogBegin(ImGuiLogType_File, auto_open_depth);
    %%%%%:15082-block 12
call    0 never executed
    #####:15083:    g.LogFile = f;
        -:15084:}
        -:15085:
        -:15086:// Start logging/capturing text output to clipboard
function _ZN5ImGui14LogToClipboardEi called 0 returned 0% blocks executed 0%
    #####:15087:void ImGui::LogToClipboard(int auto_open_depth)
        -:15088:{
    #####:15089:    ImGuiContext& g = *GImGui;
    #####:15090:    if (g.LogEnabled)
    %%%%%:15090-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:15091:        return;
    %%%%%:15091-block 3
    #####:15092:    LogBegin(ImGuiLogType_Clipboard, auto_open_depth);
    %%%%%:15092-block 4
call    0 never executed
        -:15093:}
        -:15094:
function _ZN5ImGui11LogToBufferEi called 0 returned 0% blocks executed 0%
    #####:15095:void ImGui::LogToBuffer(int auto_open_depth)
        -:15096:{
    #####:15097:    ImGuiContext& g = *GImGui;
    #####:15098:    if (g.LogEnabled)
    %%%%%:15098-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:15099:        return;
    %%%%%:15099-block 3
    #####:15100:    LogBegin(ImGuiLogType_Buffer, auto_open_depth);
    %%%%%:15100-block 4
call    0 never executed
        -:15101:}
        -:15102:
function _ZN5ImGui9LogFinishEv called 3444 returned 100% blocks executed 18%
     3444:15103:void ImGui::LogFinish()
        -:15104:{
     3444:15105:    ImGuiContext& g = *GImGui;
     3444:15106:    if (!g.LogEnabled)
     3444:15106-block 2
branch  0 taken 3444 (fallthrough)
branch  1 taken 0
     3444:15107:        return;
     3444:15107-block 3
        -:15108:
    #####:15109:    LogText(IM_NEWLINE);
    %%%%%:15109-block 4
call    0 never executed
    #####:15110:    switch (g.LogType)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:15111:    {
    #####:15112:    case ImGuiLogType_TTY:
        -:15113:#ifndef IMGUI_DISABLE_TTY_FUNCTIONS
    #####:15114:        fflush(g.LogFile);
    %%%%%:15114-block 6
call    0 never executed
        -:15115:#endif
    #####:15116:        break;
    #####:15117:    case ImGuiLogType_File:
    #####:15118:        ImFileClose(g.LogFile);
    %%%%%:15118-block 7
call    0 never executed
    #####:15119:        break;
    #####:15120:    case ImGuiLogType_Buffer:
    #####:15121:        break;
    %%%%%:15121-block 9
    #####:15122:    case ImGuiLogType_Clipboard:
    #####:15123:        if (!g.LogBuffer.empty())
    %%%%%:15123-block 10
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:15124:            SetClipboardText(g.LogBuffer.begin());
    %%%%%:15124-block 12
call    0 never executed
call    1 never executed
    #####:15125:        break;
    %%%%%:15125-block 14
    #####:15126:    case ImGuiLogType_None:
    #####:15127:        IM_ASSERT(0);
    %%%%%:15127-block 15
call    0 never executed
        -:15128:        break;
        -:15129:    }
        -:15130:
    #####:15131:    g.LogEnabled = g.ItemUnclipByLog = false;
    #####:15132:    g.LogType = ImGuiLogType_None;
    #####:15133:    g.LogFile = NULL;
    #####:15134:    g.LogBuffer.clear();
    %%%%%:15134-block 17
call    0 never executed
        -:15135:}
        -:15136:
        -:15137:// Helper to display logging buttons
        -:15138:// FIXME-OBSOLETE: We should probably obsolete this and let the user have their own helper (this is one of the oldest function alive!)
function _ZN5ImGui10LogButtonsEv called 0 returned 0% blocks executed 0%
    #####:15139:void ImGui::LogButtons()
        -:15140:{
    #####:15141:    ImGuiContext& g = *GImGui;
        -:15142:
    #####:15143:    PushID("LogButtons");
    %%%%%:15143-block 2
call    0 never executed
        -:15144:#ifndef IMGUI_DISABLE_TTY_FUNCTIONS
    #####:15145:    const bool log_to_tty = Button("Log To TTY"); SameLine();
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:15145-block 5
call    4 never executed
    $$$$$:15145-block 24
call    5 never executed
        -:15146:#else
        -:15147:    const bool log_to_tty = false;
        -:15148:#endif
    #####:15149:    const bool log_to_file = Button("Log To File"); SameLine();
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:15149-block 8
call    4 never executed
    $$$$$:15149-block 25
call    5 never executed
    #####:15150:    const bool log_to_clipboard = Button("Log To Clipboard"); SameLine();
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:15150-block 11
call    4 never executed
    #####:15151:    PushItemFlag(ImGuiItemFlags_NoTabStop, true);
call    0 never executed
    #####:15152:    SetNextItemWidth(80.0f);
call    0 never executed
    #####:15153:    SliderInt("Default Depth", &g.LogDepthToExpandDefault, 0, 9, NULL);
call    0 never executed
    #####:15154:    PopItemFlag();
call    0 never executed
    #####:15155:    PopID();
call    0 never executed
        -:15156:
        -:15157:    // Start logging at the end of the function so that the buttons don't appear in the log
    #####:15158:    if (log_to_tty)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:15159:        LogToTTY();
    %%%%%:15159-block 18
call    0 never executed
    #####:15160:    if (log_to_file)
    %%%%%:15160-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:15161:        LogToFile();
    %%%%%:15161-block 20
call    0 never executed
    #####:15162:    if (log_to_clipboard)
    %%%%%:15162-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:15163:        LogToClipboard();
    %%%%%:15163-block 22
call    0 never executed
    #####:15164:}
    %%%%%:15164-block 23
        -:15165:
        -:15166:
        -:15167://-----------------------------------------------------------------------------
        -:15168:// [SECTION] SETTINGS
        -:15169://-----------------------------------------------------------------------------
        -:15170:// - UpdateSettings() [Internal]
        -:15171:// - MarkIniSettingsDirty() [Internal]
        -:15172:// - FindSettingsHandler() [Internal]
        -:15173:// - ClearIniSettings() [Internal]
        -:15174:// - LoadIniSettingsFromDisk()
        -:15175:// - LoadIniSettingsFromMemory()
        -:15176:// - SaveIniSettingsToDisk()
        -:15177:// - SaveIniSettingsToMemory()
        -:15178://-----------------------------------------------------------------------------
        -:15179:// - CreateNewWindowSettings() [Internal]
        -:15180:// - FindWindowSettingsByID() [Internal]
        -:15181:// - FindWindowSettingsByWindow() [Internal]
        -:15182:// - ClearWindowSettings() [Internal]
        -:15183:// - WindowSettingsHandler_***() [Internal]
        -:15184://-----------------------------------------------------------------------------
        -:15185:
        -:15186:// Called by NewFrame()
function _ZN5ImGuiL14UpdateSettingsEv called 1077 returned 100% blocks executed 50%
     1077:15187:void ImGui::UpdateSettings()
        -:15188:{
        -:15189:    // Load settings on first frame (if not explicitly loaded manually before)
     1077:15190:    ImGuiContext& g = *GImGui;
     1077:15191:    if (!g.SettingsLoaded)
     1077:15191-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
        -:15192:    {
    #####:15193:        IM_ASSERT(g.SettingsWindows.empty());
    %%%%%:15193-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:15193-block 5
call    3 never executed
    #####:15194:        if (g.IO.IniFilename)
    %%%%%:15194-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:15195:            LoadIniSettingsFromDisk(g.IO.IniFilename);
    %%%%%:15195-block 7
call    0 never executed
    #####:15196:        g.SettingsLoaded = true;
    %%%%%:15196-block 8
        -:15197:    }
        -:15198:
        -:15199:    // Save settings (with a delay after the last modification, so we don't spam disk too much)
     1077:15200:    if (g.SettingsDirtyTimer > 0.0f)
     1077:15200-block 9
branch  0 taken 600 (fallthrough)
branch  1 taken 477
        -:15201:    {
      600:15202:        g.SettingsDirtyTimer -= g.IO.DeltaTime;
      600:15203:        if (g.SettingsDirtyTimer <= 0.0f)
      600:15203-block 10
branch  0 taken 1 (fallthrough)
branch  1 taken 599
        -:15204:        {
        1:15205:            if (g.IO.IniFilename != NULL)
        1:15205-block 11
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:15206:                SaveIniSettingsToDisk(g.IO.IniFilename);
        1:15206-block 12
call    0 returned 1
        -:15207:            else
    #####:15208:                g.IO.WantSaveIniSettings = true;  // Let user know they can call SaveIniSettingsToMemory(). user will need to clear io.WantSaveIniSettings themselves.
    %%%%%:15208-block 13
        1:15209:            g.SettingsDirtyTimer = 0.0f;
        1:15209-block 14
        -:15210:        }
        -:15211:    }
     1077:15212:}
        -:15213:
function _ZN5ImGui20MarkIniSettingsDirtyEv called 0 returned 0% blocks executed 0%
    #####:15214:void ImGui::MarkIniSettingsDirty()
        -:15215:{
    #####:15216:    ImGuiContext& g = *GImGui;
    #####:15217:    if (g.SettingsDirtyTimer <= 0.0f)
    %%%%%:15217-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:15218:        g.SettingsDirtyTimer = g.IO.IniSavingRate;
    %%%%%:15218-block 3
    #####:15219:}
        -:15220:
function _ZN5ImGui20MarkIniSettingsDirtyEP11ImGuiWindow called 52 returned 100% blocks executed 100%
       52:15221:void ImGui::MarkIniSettingsDirty(ImGuiWindow* window)
        -:15222:{
       52:15223:    ImGuiContext& g = *GImGui;
       52:15224:    if (!(window->Flags & ImGuiWindowFlags_NoSavedSettings))
       52:15224-block 2
branch  0 taken 26 (fallthrough)
branch  1 taken 26
       26:15225:        if (g.SettingsDirtyTimer <= 0.0f)
       26:15225-block 3
branch  0 taken 1 (fallthrough)
branch  1 taken 25
        1:15226:            g.SettingsDirtyTimer = g.IO.IniSavingRate;
        1:15226-block 4
       52:15227:}
        -:15228:
function _ZN5ImGui18AddSettingsHandlerEPK20ImGuiSettingsHandler called 2 returned 100% blocks executed 80%
        2:15229:void ImGui::AddSettingsHandler(const ImGuiSettingsHandler* handler)
        -:15230:{
        2:15231:    ImGuiContext& g = *GImGui;
       2*:15232:    IM_ASSERT(FindSettingsHandler(handler->TypeName) == NULL);
        2:15232-block 2
call    0 returned 2
branch  1 taken 0 (fallthrough)
branch  2 taken 2
    %%%%%:15232-block 4
call    3 never executed
        2:15233:    g.SettingsHandlers.push_back(*handler);
        2:15233-block 5
call    0 returned 2
        2:15234:}
        -:15235:
function _ZN5ImGui21RemoveSettingsHandlerEPKc called 0 returned 0% blocks executed 0%
    #####:15236:void ImGui::RemoveSettingsHandler(const char* type_name)
        -:15237:{
    #####:15238:    ImGuiContext& g = *GImGui;
    #####:15239:    if (ImGuiSettingsHandler* handler = FindSettingsHandler(type_name))
    %%%%%:15239-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:15240:        g.SettingsHandlers.erase(handler);
    %%%%%:15240-block 4
call    0 never executed
    #####:15241:}
        -:15242:
function _ZN5ImGui19FindSettingsHandlerEPKc called 21 returned 100% blocks executed 100%
       21:15243:ImGuiSettingsHandler* ImGui::FindSettingsHandler(const char* type_name)
        -:15244:{
       21:15245:    ImGuiContext& g = *GImGui;
       21:15246:    const ImGuiID type_hash = ImHashStr(type_name);
       21:15246-block 2
call    0 returned 21
       31:15247:    for (ImGuiSettingsHandler& handler : g.SettingsHandlers)
call    0 returned 21
call    1 returned 21
       10:15247-block 7
       31:15247-block 8
branch  2 taken 29
branch  3 taken 2 (fallthrough)
       29:15248:        if (handler.TypeHash == type_hash)
       29:15248-block 5
branch  0 taken 19 (fallthrough)
branch  1 taken 10
       19:15249:            return &handler;
       19:15249-block 6
        2:15250:    return NULL;
        2:15250-block 9
        -:15251:}
        -:15252:
        -:15253:// Clear all settings (windows, tables, docking etc.)
function _ZN5ImGui16ClearIniSettingsEv called 0 returned 0% blocks executed 0%
    #####:15254:void ImGui::ClearIniSettings()
        -:15255:{
    #####:15256:    ImGuiContext& g = *GImGui;
    #####:15257:    g.SettingsIniData.clear();
    %%%%%:15257-block 2
call    0 never executed
    #####:15258:    for (ImGuiSettingsHandler& handler : g.SettingsHandlers)
call    0 never executed
call    1 never executed
    %%%%%:15258-block 7
    %%%%%:15258-block 8
branch  2 never executed
branch  3 never executed (fallthrough)
    #####:15259:        if (handler.ClearAllFn != NULL)
    %%%%%:15259-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:15260:            handler.ClearAllFn(&g, &handler);
    %%%%%:15260-block 6
call    0 never executed
    #####:15261:}
        -:15262:
function _ZN5ImGui23LoadIniSettingsFromDiskEPKc called 1 returned 100% blocks executed 89%
        1:15263:void ImGui::LoadIniSettingsFromDisk(const char* ini_filename)
        -:15264:{
        1:15265:    size_t file_data_size = 0;
        1:15266:    char* file_data = (char*)ImFileLoadToMemory(ini_filename, "rb", &file_data_size);
        1:15266-block 2
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:15267:    if (!file_data)
        1:15267-block 3
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:15268:        return;
    %%%%%:15268-block 4
        1:15269:    if (file_data_size > 0)
        1:15269-block 5
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:15270:        LoadIniSettingsFromMemory(file_data, (size_t)file_data_size);
        1:15270-block 6
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:15271:    IM_FREE(file_data);
        1:15271-block 7
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:15272:}
        -:15273:
        -:15274:// Zero-tolerance, no error reporting, cheap .ini parsing
        -:15275:// Set ini_size==0 to let us use strlen(ini_data). Do not call this function with a 0 if your buffer is actually empty!
function _ZN5ImGui25LoadIniSettingsFromMemoryEPKcm called 1 returned 100% blocks executed 88%
        1:15276:void ImGui::LoadIniSettingsFromMemory(const char* ini_data, size_t ini_size)
        -:15277:{
        1:15278:    ImGuiContext& g = *GImGui;
       1*:15279:    IM_ASSERT(g.Initialized);
        1:15279-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%:15279-block 3
call    2 never executed
        -:15280:    //IM_ASSERT(!g.WithinFrameScope && "Cannot be called between NewFrame() and EndFrame()");
        -:15281:    //IM_ASSERT(g.SettingsLoaded == false && g.FrameCount == 0);
        -:15282:
        -:15283:    // For user convenience, we allow passing a non zero-terminated string (hence the ini_size parameter).
        -:15284:    // For our convenience and to make the code simpler, we'll also write zero-terminators within the buffer. So let's create a writable copy..
        1:15285:    if (ini_size == 0)
        1:15285-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:15286:        ini_size = strlen(ini_data);
    %%%%%:15286-block 5
        1:15287:    g.SettingsIniData.Buf.resize((int)ini_size + 1);
        1:15287-block 6
call    0 returned 1
        1:15288:    char* const buf = g.SettingsIniData.Buf.Data;
        1:15289:    char* const buf_end = buf + ini_size;
        1:15290:    memcpy(buf, ini_data, ini_size);
        1:15291:    buf_end[0] = 0;
        -:15292:
        -:15293:    // Call pre-read handlers
        -:15294:    // Some types will clear their data (e.g. dock information) some types will allow merge/override (window)
        4:15295:    for (ImGuiSettingsHandler& handler : g.SettingsHandlers)
call    0 returned 1
call    1 returned 1
        3:15295-block 11
        4:15295-block 12
branch  2 taken 3
branch  3 taken 1 (fallthrough)
        3:15296:        if (handler.ReadInitFn != NULL)
        3:15296-block 9
branch  0 taken 1 (fallthrough)
branch  1 taken 2
        1:15297:            handler.ReadInitFn(&g, &handler);
        1:15297-block 10
call    0 returned 1
        -:15298:
        1:15299:    void* entry_data = NULL;
        1:15300:    ImGuiSettingsHandler* entry_handler = NULL;
        -:15301:
        1:15302:    char* line_end = NULL;
       94:15303:    for (char* line = buf; line < buf_end; line = line_end + 1)
        1:15303-block 13
       93:15303-block 44
       94:15303-block 45
branch  0 taken 93
branch  1 taken 1 (fallthrough)
        -:15304:    {
        -:15305:        // Skip new lines markers, then find end of the line
      112:15306:        while (*line == '\n' || *line == '\r')
       93:15306-block 14
      112:15306-block 16
branch  0 taken 19
branch  1 taken 93 (fallthrough)
       93:15306-block 17
branch  2 taken 0
branch  3 taken 93 (fallthrough)
       19:15307:            line++;
       19:15307-block 15
       93:15308:        line_end = line;
     2340:15309:        while (line_end < buf_end && *line_end != '\n' && *line_end != '\r')
       93:15309-block 18
     2340:15309-block 20
branch  0 taken 2339 (fallthrough)
branch  1 taken 1
     2339:15309-block 21
branch  2 taken 2247 (fallthrough)
branch  3 taken 92
     2247:15309-block 22
branch  4 taken 2247
branch  5 taken 0 (fallthrough)
     2247:15310:            line_end++;
     2247:15310-block 19
       93:15311:        line_end[0] = 0;
      93*:15312:        if (line[0] == ';')
       93:15312-block 23
branch  0 taken 0 (fallthrough)
branch  1 taken 93
    #####:15313:            continue;
    %%%%%:15313-block 24
       93:15314:        if (line[0] == '[' && line_end > line && line_end[-1] == ']')
       93:15314-block 25
branch  0 taken 19 (fallthrough)
branch  1 taken 74
       19:15314-block 26
branch  2 taken 19 (fallthrough)
branch  3 taken 0
       19:15314-block 27
branch  4 taken 19 (fallthrough)
branch  5 taken 0
        -:15315:        {
        -:15316:            // Parse "[Type][Name]". Note that 'Name' can itself contains [] characters, which is acceptable with the current format and parsing code.
       19:15317:            line_end[-1] = 0;
       19:15318:            const char* name_end = line_end - 1;
       19:15319:            const char* type_start = line + 1;
       19:15320:            char* type_end = (char*)(void*)ImStrchrRange(type_start, name_end, ']');
       19:15320-block 28
call    0 returned 19
      19*:15321:            const char* name_start = type_end ? ImStrchrRange(type_end + 1, name_end, '[') : NULL;
branch  0 taken 19 (fallthrough)
branch  1 taken 0
       19:15321-block 30
call    2 returned 19
    %%%%%:15321-block 31
      19*:15322:            if (!type_end || !name_start)
       19:15322-block 32
branch  0 taken 19 (fallthrough)
branch  1 taken 0
       19:15322-block 33
branch  2 taken 0 (fallthrough)
branch  3 taken 19
    #####:15323:                continue;
    %%%%%:15323-block 34
       19:15324:            *type_end = 0; // Overwrite first ']'
       19:15325:            name_start++;  // Skip second '['
       19:15326:            entry_handler = FindSettingsHandler(type_start);
       19:15326-block 35
call    0 returned 19
      19*:15327:            entry_data = entry_handler ? entry_handler->ReadOpenFn(&g, entry_handler, name_start) : NULL;
branch  0 taken 19 (fallthrough)
branch  1 taken 0
       19:15327-block 37
call    2 returned 19
    %%%%%:15327-block 39
       19:15328:        }
       19:15328-block 40
       74:15329:        else if (entry_handler != NULL && entry_data != NULL)
       74:15329-block 41
branch  0 taken 74 (fallthrough)
branch  1 taken 0
       74:15329-block 42
branch  2 taken 74 (fallthrough)
branch  3 taken 0
        -:15330:        {
        -:15331:            // Let type handler parse the line
       74:15332:            entry_handler->ReadLineFn(&g, entry_handler, entry_data, line);
       74:15332-block 43
call    0 returned 74
        -:15333:        }
        -:15334:    }
        1:15335:    g.SettingsLoaded = true;
        -:15336:
        -:15337:    // [DEBUG] Restore untouched copy so it can be browsed in Metrics (not strictly necessary)
        1:15338:    memcpy(buf, ini_data, ini_size);
        -:15339:
        -:15340:    // Call post-read handlers
        4:15341:    for (ImGuiSettingsHandler& handler : g.SettingsHandlers)
        1:15341-block 46
call    0 returned 1
call    1 returned 1
        3:15341-block 50
        4:15341-block 51
branch  2 taken 3
branch  3 taken 1 (fallthrough)
        3:15342:        if (handler.ApplyAllFn != NULL)
        3:15342-block 48
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3:15343:            handler.ApplyAllFn(&g, &handler);
        3:15343-block 49
call    0 returned 3
        1:15344:}
        -:15345:
function _ZN5ImGui21SaveIniSettingsToDiskEPKc called 2 returned 100% blocks executed 75%
        2:15346:void ImGui::SaveIniSettingsToDisk(const char* ini_filename)
        -:15347:{
        2:15348:    ImGuiContext& g = *GImGui;
        2:15349:    g.SettingsDirtyTimer = 0.0f;
        2:15350:    if (!ini_filename)
        2:15350-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:15351:        return;
    %%%%%:15351-block 3
    %%%%%:15351-block 11
        -:15352:
        2:15353:    size_t ini_data_size = 0;
        2:15354:    const char* ini_data = SaveIniSettingsToMemory(&ini_data_size);
        2:15354-block 4
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        2:15355:    ImFileHandle f = ImFileOpen(ini_filename, "wt");
        2:15355-block 5
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        2:15356:    if (!f)
        2:15356-block 6
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:15357:        return;
    %%%%%:15357-block 7
        2:15358:    ImFileWrite(ini_data, sizeof(char), ini_data_size, f);
        2:15358-block 8
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        2:15359:    ImFileClose(f);
        2:15359-block 9
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        -:15360:}
        -:15361:
        -:15362:// Call registered handlers (e.g. SettingsHandlerWindow_WriteAll() + custom handlers) to write their stuff into a text buffer
function _ZN5ImGui23SaveIniSettingsToMemoryEPm called 2 returned 100% blocks executed 100%
        2:15363:const char* ImGui::SaveIniSettingsToMemory(size_t* out_size)
        -:15364:{
        2:15365:    ImGuiContext& g = *GImGui;
        2:15366:    g.SettingsDirtyTimer = 0.0f;
        2:15367:    g.SettingsIniData.Buf.resize(0);
        2:15367-block 2
call    0 returned 2
        2:15368:    g.SettingsIniData.Buf.push_back(0);
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        8:15369:    for (ImGuiSettingsHandler& handler : g.SettingsHandlers)
        2:15369-block 4
call    0 returned 2
call    1 returned 2
        8:15369-block 8
branch  2 taken 6
branch  3 taken 2 (fallthrough)
        6:15370:        handler.WriteAllFn(&g, &handler, &g.SettingsIniData);
        6:15370-block 6
call    0 returned 6
        2:15371:    if (out_size)
        2:15371-block 9
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2:15372:        *out_size = (size_t)g.SettingsIniData.size();
        2:15372-block 10
call    0 returned 2
        2:15373:    return g.SettingsIniData.c_str();
        2:15373-block 12
call    0 returned 2
        -:15374:}
        -:15375:
function _ZN5ImGui23CreateNewWindowSettingsEPKc called 11 returned 100% blocks executed 90%
       11:15376:ImGuiWindowSettings* ImGui::CreateNewWindowSettings(const char* name)
        -:15377:{
       11:15378:    ImGuiContext& g = *GImGui;
        -:15379:
       11:15380:    if (g.IO.ConfigDebugIniSettings == false)
       11:15380-block 2
branch  0 taken 11 (fallthrough)
branch  1 taken 0
        -:15381:    {
        -:15382:        // Skip to the "###" marker if any. We don't skip past to match the behavior of GetID()
        -:15383:        // Preserve the full string when ConfigDebugVerboseIniSettings is set to make .ini inspection easier.
       11:15384:        if (const char* p = strstr(name, "###"))
       11:15384-block 3
branch  0 taken 0 (fallthrough)
branch  1 taken 11
    #####:15385:            name = p;
    %%%%%:15385-block 4
        -:15386:    }
       11:15387:    const size_t name_len = strlen(name);
        -:15388:
        -:15389:    // Allocate chunk
       11:15390:    const size_t chunk_size = sizeof(ImGuiWindowSettings) + name_len + 1;
       11:15391:    ImGuiWindowSettings* settings = g.SettingsWindows.alloc_chunk(chunk_size);
       11:15391-block 5
call    0 returned 11
       11:15392:    IM_PLACEMENT_NEW(settings) ImGuiWindowSettings();
call    0 returned 11
call    1 returned 11
       11:15393:    settings->ID = ImHashStr(name, name_len);
call    0 returned 11
       11:15394:    memcpy(settings->GetName(), name, name_len + 1);   // Store with zero terminator
call    0 returned 11
        -:15395:
       11:15396:    return settings;
        -:15397:}
        -:15398:
        -:15399:// We don't provide a FindWindowSettingsByName() because Docking system doesn't always hold on names.
        -:15400:// This is called once per window .ini entry + once per newly instantiated window.
function _ZN5ImGui22FindWindowSettingsByIDEj called 19 returned 100% blocks executed 100%
       19:15401:ImGuiWindowSettings* ImGui::FindWindowSettingsByID(ImGuiID id)
        -:15402:{
       19:15403:    ImGuiContext& g = *GImGui;
      109:15404:    for (ImGuiWindowSettings* settings = g.SettingsWindows.begin(); settings != NULL; settings = g.SettingsWindows.next_chunk(settings))
       19:15404-block 2
call    0 returned 19
       90:15404-block 6
call    1 returned 90
      109:15404-block 8
branch  2 taken 98
branch  3 taken 11 (fallthrough)
       98:15405:        if (settings->ID == id && !settings->WantDelete)
       98:15405-block 3
branch  0 taken 8 (fallthrough)
branch  1 taken 90
        8:15405-block 4
branch  2 taken 8 (fallthrough)
branch  3 taken 0
        8:15406:            return settings;
        8:15406-block 5
       11:15407:    return NULL;
       11:15407-block 9
        -:15408:}
        -:15409:
        -:15410:// This is faster if you are holding on a Window already as we don't need to perform a search.
function _ZN5ImGui26FindWindowSettingsByWindowEP11ImGuiWindow called 21 returned 100% blocks executed 100%
       21:15411:ImGuiWindowSettings* ImGui::FindWindowSettingsByWindow(ImGuiWindow* window)
        -:15412:{
       21:15413:    ImGuiContext& g = *GImGui;
       21:15414:    if (window->SettingsOffset != -1)
       21:15414-block 2
branch  0 taken 14 (fallthrough)
branch  1 taken 7
       14:15415:        return g.SettingsWindows.ptr_from_offset(window->SettingsOffset);
       14:15415-block 3
call    0 returned 14
        7:15416:    return FindWindowSettingsByID(window->ID);
        7:15416-block 4
call    0 returned 7
        -:15417:}
        -:15418:
        -:15419:// This will revert window to its initial state, including enabling the ImGuiCond_FirstUseEver/ImGuiCond_Once conditions once more.
function _ZN5ImGui19ClearWindowSettingsEPKc called 0 returned 0% blocks executed 0%
    #####:15420:void ImGui::ClearWindowSettings(const char* name)
        -:15421:{
        -:15422:    //IMGUI_DEBUG_LOG("ClearWindowSettings('%s')\n", name);
    #####:15423:    ImGuiContext& g = *GImGui;
    #####:15424:    ImGuiWindow* window = FindWindowByName(name);
    %%%%%:15424-block 2
call    0 never executed
    #####:15425:    if (window != NULL)
branch  0 never executed (fallthrough)
branch  1 never executed
        -:15426:    {
    #####:15427:        window->Flags |= ImGuiWindowFlags_NoSavedSettings;
    #####:15428:        InitOrLoadWindowSettings(window, NULL);
    %%%%%:15428-block 4
call    0 never executed
    #####:15429:        if (window->DockId != 0)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:15430:            DockContextProcessUndockWindow(&g, window, true);
    %%%%%:15430-block 6
call    0 never executed
        -:15431:    }
    #####:15432:    if (ImGuiWindowSettings* settings = window ? FindWindowSettingsByWindow(window) : FindWindowSettingsByID(ImHashStr(name)))
    %%%%%:15432-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:15432-block 8
call    2 never executed
    %%%%%:15432-block 10
call    3 never executed
call    4 never executed
    %%%%%:15432-block 13
branch  5 never executed (fallthrough)
branch  6 never executed
    #####:15433:        settings->WantDelete = true;
    %%%%%:15433-block 14
    #####:15434:}
        -:15435:
function _ZL30WindowSettingsHandler_ClearAllP12ImGuiContextP20ImGuiSettingsHandler called 0 returned 0% blocks executed 0%
    #####:15436:static void WindowSettingsHandler_ClearAll(ImGuiContext* ctx, ImGuiSettingsHandler*)
        -:15437:{
    #####:15438:    ImGuiContext& g = *ctx;
    #####:15439:    for (ImGuiWindow* window : g.Windows)
    %%%%%:15439-block 2
call    0 never executed
call    1 never executed
    %%%%%:15439-block 5
branch  2 never executed
branch  3 never executed (fallthrough)
    #####:15440:        window->SettingsOffset = -1;
    %%%%%:15440-block 4
    #####:15441:    g.SettingsWindows.clear();
    %%%%%:15441-block 6
call    0 never executed
    #####:15442:}
        -:15443:
function _ZL30WindowSettingsHandler_ReadOpenP12ImGuiContextP20ImGuiSettingsHandlerPKc called 11 returned 100% blocks executed 78%
       11:15444:static void* WindowSettingsHandler_ReadOpen(ImGuiContext*, ImGuiSettingsHandler*, const char* name)
        -:15445:{
       11:15446:    ImGuiID id = ImHashStr(name);
       11:15446-block 2
call    0 returned 11
       11:15447:    ImGuiWindowSettings* settings = ImGui::FindWindowSettingsByID(id);
call    0 returned 11
       11:15448:    if (settings)
branch  0 taken 0 (fallthrough)
branch  1 taken 11
    #####:15449:        *settings = ImGuiWindowSettings(); // Clear existing if recycling previous entry
    %%%%%:15449-block 5
call    0 never executed
        -:15450:    else
       11:15451:        settings = ImGui::CreateNewWindowSettings(name);
       11:15451-block 7
call    0 returned 11
       11:15452:    settings->ID = id;
       11:15453:    settings->WantApply = true;
       11:15454:    return (void*)settings;
       11:15454-block 9
        -:15455:}
        -:15456:
function _ZL30WindowSettingsHandler_ReadLineP12ImGuiContextP20ImGuiSettingsHandlerPvPKc called 38 returned 100% blocks executed 64%
       38:15457:static void WindowSettingsHandler_ReadLine(ImGuiContext*, ImGuiSettingsHandler*, void* entry, const char* line)
        -:15458:{
       38:15459:    ImGuiWindowSettings* settings = (ImGuiWindowSettings*)entry;
        -:15460:    int x, y;
        -:15461:    int i;
        -:15462:    ImU32 u1;
       38:15463:    if (sscanf(line, "Pos=%i,%i", &x, &y) == 2)             { settings->Pos = ImVec2ih((short)x, (short)y); }
       38:15463-block 2
branch  0 taken 11 (fallthrough)
branch  1 taken 27
       11:15463-block 3
call    2 returned 11
       27:15464:    else if (sscanf(line, "Size=%i,%i", &x, &y) == 2)       { settings->Size = ImVec2ih((short)x, (short)y); }
       27:15464-block 5
branch  0 taken 11 (fallthrough)
branch  1 taken 16
       11:15464-block 6
call    2 returned 11
      16*:15465:    else if (sscanf(line, "ViewportId=0x%08X", &u1) == 1)   { settings->ViewportId = u1; }
       16:15465-block 8
branch  0 taken 0 (fallthrough)
branch  1 taken 16
    %%%%%:15465-block 9
      16*:15466:    else if (sscanf(line, "ViewportPos=%i,%i", &x, &y) == 2){ settings->ViewportPos = ImVec2ih((short)x, (short)y); }
       16:15466-block 10
branch  0 taken 0 (fallthrough)
branch  1 taken 16
    %%%%%:15466-block 11
call    2 never executed
       16:15467:    else if (sscanf(line, "Collapsed=%d", &i) == 1)         { settings->Collapsed = (i != 0); }
       16:15467-block 13
branch  0 taken 11 (fallthrough)
branch  1 taken 5
       11:15467-block 14
       5*:15468:    else if (sscanf(line, "IsChild=%d", &i) == 1)           { settings->IsChild = (i != 0); }
        5:15468-block 15
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    %%%%%:15468-block 16
        5:15469:    else if (sscanf(line, "DockId=0x%X,%d", &u1, &i) == 2)  { settings->DockId = u1; settings->DockOrder = (short)i; }
        5:15469-block 17
branch  0 taken 5 (fallthrough)
branch  1 taken 0
        5:15469-block 18
    #####:15470:    else if (sscanf(line, "DockId=0x%X", &u1) == 1)         { settings->DockId = u1; settings->DockOrder = -1; }
    %%%%%:15470-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:15470-block 20
    #####:15471:    else if (sscanf(line, "ClassId=0x%X", &u1) == 1)        { settings->ClassId = u1; }
    %%%%%:15471-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:15471-block 22
       38:15472:}
        -:15473:
        -:15474:// Apply to existing windows (if any)
function _ZL30WindowSettingsHandler_ApplyAllP12ImGuiContextP20ImGuiSettingsHandler called 1 returned 100% blocks executed 90%
        1:15475:static void WindowSettingsHandler_ApplyAll(ImGuiContext* ctx, ImGuiSettingsHandler*)
        -:15476:{
        1:15477:    ImGuiContext& g = *ctx;
       12:15478:    for (ImGuiWindowSettings* settings = g.SettingsWindows.begin(); settings != NULL; settings = g.SettingsWindows.next_chunk(settings))
        1:15478-block 2
call    0 returned 1
       11:15478-block 8
call    1 returned 11
       12:15478-block 10
branch  2 taken 11
branch  3 taken 1 (fallthrough)
       11:15479:        if (settings->WantApply)
       11:15479-block 3
branch  0 taken 11 (fallthrough)
branch  1 taken 0
        -:15480:        {
       11:15481:            if (ImGuiWindow* window = ImGui::FindWindowByID(settings->ID))
       11:15481-block 4
call    0 returned 11
branch  1 taken 0 (fallthrough)
branch  2 taken 11
    #####:15482:                ApplyWindowSettings(window, settings);
    %%%%%:15482-block 6
call    0 never executed
       11:15483:            settings->WantApply = false;
       11:15483-block 7
        -:15484:        }
        1:15485:}
        -:15486:
function _ZL30WindowSettingsHandler_WriteAllP12ImGuiContextP20ImGuiSettingsHandlerP15ImGuiTextBuffer called 2 returned 100% blocks executed 75%
        2:15487:static void WindowSettingsHandler_WriteAll(ImGuiContext* ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* buf)
        -:15488:{
        -:15489:    // Gather data from windows that were active during this session
        -:15490:    // (if a window wasn't opened in this session we preserve its settings)
        2:15491:    ImGuiContext& g = *ctx;
       34:15492:    for (ImGuiWindow* window : g.Windows)
        2:15492-block 2
call    0 returned 2
call    1 returned 2
       32:15492-block 21
       34:15492-block 22
branch  2 taken 32
branch  3 taken 2 (fallthrough)
        -:15493:    {
       32:15494:        if (window->Flags & ImGuiWindowFlags_NoSavedSettings)
       32:15494-block 4
branch  0 taken 18 (fallthrough)
branch  1 taken 14
       18:15495:            continue;
       18:15495-block 5
        -:15496:
       14:15497:        ImGuiWindowSettings* settings = ImGui::FindWindowSettingsByWindow(window);
       14:15497-block 6
call    0 returned 14
       14:15498:        if (!settings)
branch  0 taken 0 (fallthrough)
branch  1 taken 14
        -:15499:        {
    #####:15500:            settings = ImGui::CreateNewWindowSettings(window->Name);
    %%%%%:15500-block 8
call    0 never executed
    #####:15501:            window->SettingsOffset = g.SettingsWindows.offset_from_ptr(settings);
call    0 never executed
        -:15502:        }
      14*:15503:        IM_ASSERT(settings->ID == window->ID);
       14:15503-block 11
branch  0 taken 0 (fallthrough)
branch  1 taken 14
    %%%%%:15503-block 12
call    2 never executed
       14:15504:        settings->Pos = ImVec2ih(window->Pos - window->ViewportPos);
       14:15504-block 13
call    0 returned 14
call    1 returned 14
       14:15505:        settings->Size = ImVec2ih(window->SizeFull);
call    0 returned 14
       14:15506:        settings->ViewportId = window->ViewportId;
       14:15507:        settings->ViewportPos = ImVec2ih(window->ViewportPos);
call    0 returned 14
      14*:15508:        IM_ASSERT(window->DockNode == NULL || window->DockNode->ID == window->DockId);
branch  0 taken 10 (fallthrough)
branch  1 taken 4
       10:15508-block 18
branch  2 taken 0 (fallthrough)
branch  3 taken 10
    %%%%%:15508-block 19
call    4 never executed
       14:15509:        settings->DockId = window->DockId;
       14:15510:        settings->ClassId = window->WindowClass.ClassId;
       14:15511:        settings->DockOrder = window->DockOrder;
       14:15512:        settings->Collapsed = window->Collapsed;
       14:15513:        settings->IsChild = (window->RootWindow != window); // Cannot rely on ImGuiWindowFlags_ChildWindow here as docked windows have this set.
       14:15514:        settings->WantDelete = false;
       14:15514-block 20
        -:15515:    }
        -:15516:
        -:15517:    // Write to text buffer
        2:15518:    buf->reserve(buf->size() + g.SettingsWindows.size() * 6); // ballpark reserve
        2:15518-block 23
call    0 returned 2
call    1 returned 2
call    2 returned 2
       24:15519:    for (ImGuiWindowSettings* settings = g.SettingsWindows.begin(); settings != NULL; settings = g.SettingsWindows.next_chunk(settings))
call    0 returned 2
       22:15519-block 53
call    1 returned 22
       24:15519-block 55
branch  2 taken 22
branch  3 taken 2 (fallthrough)
        -:15520:    {
      22*:15521:        if (settings->WantDelete)
       22:15521-block 27
branch  0 taken 0 (fallthrough)
branch  1 taken 22
    #####:15522:            continue;
    %%%%%:15522-block 28
       22:15523:        const char* settings_name = settings->GetName();
       22:15523-block 29
call    0 returned 22
       22:15524:        buf->appendf("[%s][%s]\n", handler->TypeName, settings_name);
call    0 returned 22
       22:15525:        if (settings->IsChild)
branch  0 taken 0 (fallthrough)
branch  1 taken 22
        -:15526:        {
    #####:15527:            buf->appendf("IsChild=1\n");
    %%%%%:15527-block 32
call    0 never executed
    #####:15528:            buf->appendf("Size=%d,%d\n", settings->Size.x, settings->Size.y);
call    0 never executed
        -:15529:        }
        -:15530:        else
        -:15531:        {
       22:15532:            if (settings->ViewportId != 0 && settings->ViewportId != ImGui::IMGUI_VIEWPORT_DEFAULT_ID)
       22:15532-block 34
branch  0 taken 14 (fallthrough)
branch  1 taken 8
       14:15532-block 35
branch  2 taken 0 (fallthrough)
branch  3 taken 14
        -:15533:            {
    #####:15534:                buf->appendf("ViewportPos=%d,%d\n", settings->ViewportPos.x, settings->ViewportPos.y);
    %%%%%:15534-block 36
call    0 never executed
    #####:15535:                buf->appendf("ViewportId=0x%08X\n", settings->ViewportId);
call    0 never executed
        -:15536:            }
      22*:15537:            if (settings->Pos.x != 0 || settings->Pos.y != 0 || settings->ViewportId == ImGui::IMGUI_VIEWPORT_DEFAULT_ID)
       22:15537-block 38
branch  0 taken 6 (fallthrough)
branch  1 taken 16
        6:15537-block 39
branch  2 taken 0 (fallthrough)
branch  3 taken 6
    %%%%%:15537-block 40
branch  4 never executed (fallthrough)
branch  5 never executed
       22:15538:                buf->appendf("Pos=%d,%d\n", settings->Pos.x, settings->Pos.y);
       22:15538-block 41
call    0 returned 22
      22*:15539:            if (settings->Size.x != 0 || settings->Size.y != 0)
       22:15539-block 42
branch  0 taken 0 (fallthrough)
branch  1 taken 22
    %%%%%:15539-block 43
branch  2 never executed (fallthrough)
branch  3 never executed
       22:15540:                buf->appendf("Size=%d,%d\n", settings->Size.x, settings->Size.y);
       22:15540-block 44
call    0 returned 22
       22:15541:            buf->appendf("Collapsed=%d\n", settings->Collapsed);
       22:15541-block 45
call    0 returned 22
       22:15542:            if (settings->DockId != 0)
branch  0 taken 10 (fallthrough)
branch  1 taken 12
        -:15543:            {
        -:15544:                //buf->appendf("TabId=0x%08X\n", ImHashStr("#TAB", 4, settings->ID)); // window->TabId: this is not read back but writing it makes "debugging" the .ini data easier.
       10:15545:                if (settings->DockOrder == -1)
       10:15545-block 47
branch  0 taken 0 (fallthrough)
branch  1 taken 10
    #####:15546:                    buf->appendf("DockId=0x%08X\n", settings->DockId);
    %%%%%:15546-block 48
call    0 never executed
        -:15547:                else
       10:15548:                    buf->appendf("DockId=0x%08X,%d\n", settings->DockId, settings->DockOrder);
       10:15548-block 49
call    0 returned 10
       10:15549:                if (settings->ClassId != 0)
       10:15549-block 50
branch  0 taken 0 (fallthrough)
branch  1 taken 10
    #####:15550:                    buf->appendf("ClassId=0x%08X\n", settings->ClassId);
    %%%%%:15550-block 51
call    0 never executed
        -:15551:            }
        -:15552:        }
       22:15553:        buf->append("\n");
       22:15553-block 52
call    0 returned 22
        -:15554:    }
        2:15555:}
        -:15556:
        -:15557:
        -:15558://-----------------------------------------------------------------------------
        -:15559:// [SECTION] LOCALIZATION
        -:15560://-----------------------------------------------------------------------------
        -:15561:
function _ZN5ImGui23LocalizeRegisterEntriesEPK13ImGuiLocEntryi called 1 returned 100% blocks executed 100%
        1:15562:void ImGui::LocalizeRegisterEntries(const ImGuiLocEntry* entries, int count)
        -:15563:{
        1:15564:    ImGuiContext& g = *GImGui;
       14:15565:    for (int n = 0; n < count; n++)
        1:15565-block 2
       14:15565-block 4
branch  0 taken 13
branch  1 taken 1 (fallthrough)
       13:15566:        g.LocalizationTable[entries[n].Key] = entries[n].Text;
       13:15566-block 3
        1:15567:}
        -:15568:
        -:15569:
        -:15570://-----------------------------------------------------------------------------
        -:15571:// [SECTION] VIEWPORTS, PLATFORM WINDOWS
        -:15572://-----------------------------------------------------------------------------
        -:15573:// - GetMainViewport()
        -:15574:// - FindViewportByID()
        -:15575:// - FindViewportByPlatformHandle()
        -:15576:// - SetCurrentViewport() [Internal]
        -:15577:// - SetWindowViewport() [Internal]
        -:15578:// - GetWindowAlwaysWantOwnViewport() [Internal]
        -:15579:// - UpdateTryMergeWindowIntoHostViewport() [Internal]
        -:15580:// - UpdateTryMergeWindowIntoHostViewports() [Internal]
        -:15581:// - TranslateWindowsInViewport() [Internal]
        -:15582:// - ScaleWindowsInViewport() [Internal]
        -:15583:// - FindHoveredViewportFromPlatformWindowStack() [Internal]
        -:15584:// - UpdateViewportsNewFrame() [Internal]
        -:15585:// - UpdateViewportsEndFrame() [Internal]
        -:15586:// - AddUpdateViewport() [Internal]
        -:15587:// - WindowSelectViewport() [Internal]
        -:15588:// - WindowSyncOwnedViewport() [Internal]
        -:15589:// - UpdatePlatformWindows()
        -:15590:// - RenderPlatformWindowsDefault()
        -:15591:// - FindPlatformMonitorForPos() [Internal]
        -:15592:// - FindPlatformMonitorForRect() [Internal]
        -:15593:// - UpdateViewportPlatformMonitor() [Internal]
        -:15594:// - DestroyPlatformWindow() [Internal]
        -:15595:// - DestroyPlatformWindows()
        -:15596://-----------------------------------------------------------------------------
        -:15597:
function _ZN5ImGui15GetMainViewportEv called 22855 returned 100% blocks executed 100%
    22855:15598:ImGuiViewport* ImGui::GetMainViewport()
        -:15599:{
    22855:15600:    ImGuiContext& g = *GImGui;
    22855:15601:    return g.Viewports[0];
    22855:15601-block 2
call    0 returned 22855
        -:15602:}
        -:15603:
        -:15604:// FIXME: This leaks access to viewports not listed in PlatformIO.Viewports[]. Problematic? (#4236)
function _ZN5ImGui16FindViewportByIDEj called 1077 returned 100% blocks executed 75%
     1077:15605:ImGuiViewport* ImGui::FindViewportByID(ImGuiID id)
        -:15606:{
     1077:15607:    ImGuiContext& g = *GImGui;
    1077*:15608:    for (ImGuiViewportP* viewport : g.Viewports)
     1077:15608-block 2
call    0 returned 1077
call    1 returned 1077
    %%%%%:15608-block 6
     1077:15608-block 7
branch  2 taken 1077
branch  3 taken 0 (fallthrough)
     1077:15609:        if (viewport->ID == id)
     1077:15609-block 4
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:15610:            return viewport;
     1077:15610-block 5
    #####:15611:    return NULL;
    %%%%%:15611-block 8
        -:15612:}
        -:15613:
function _ZN5ImGui28FindViewportByPlatformHandleEPv called 0 returned 0% blocks executed 0%
    #####:15614:ImGuiViewport* ImGui::FindViewportByPlatformHandle(void* platform_handle)
        -:15615:{
    #####:15616:    ImGuiContext& g = *GImGui;
    #####:15617:    for (ImGuiViewportP* viewport : g.Viewports)
    %%%%%:15617-block 2
call    0 never executed
call    1 never executed
    %%%%%:15617-block 6
    %%%%%:15617-block 7
branch  2 never executed
branch  3 never executed (fallthrough)
    #####:15618:        if (viewport->PlatformHandle == platform_handle)
    %%%%%:15618-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:15619:            return viewport;
    %%%%%:15619-block 5
    #####:15620:    return NULL;
    %%%%%:15620-block 8
        -:15621:}
        -:15622:
function _ZN5ImGui18SetCurrentViewportEP11ImGuiWindowP14ImGuiViewportP called 35967 returned 100% blocks executed 91%
    35967:15623:void ImGui::SetCurrentViewport(ImGuiWindow* current_window, ImGuiViewportP* viewport)
        -:15624:{
    35967:15625:    ImGuiContext& g = *GImGui;
        -:15626:    (void)current_window;
        -:15627:
    35967:15628:    if (viewport)
    35967:15628-block 2
branch  0 taken 34890 (fallthrough)
branch  1 taken 1077
    34890:15629:        viewport->LastFrameActive = g.FrameCount;
    34890:15629-block 3
    35967:15630:    if (g.CurrentViewport == viewport)
    35967:15630-block 4
branch  0 taken 33813 (fallthrough)
branch  1 taken 2154
    33813:15631:        return;
    33813:15631-block 5
     2154:15632:    g.CurrentDpiScale = viewport ? viewport->DpiScale : 1.0f;
     2154:15632-block 6
branch  0 taken 1077 (fallthrough)
branch  1 taken 1077
     1077:15632-block 7
     1077:15632-block 8
     2154:15633:    g.CurrentViewport = viewport;
        -:15634:    //IMGUI_DEBUG_LOG_VIEWPORT("[viewport] SetCurrentViewport changed '%s' 0x%08X\n", current_window ? current_window->Name : NULL, viewport ? viewport->ID : 0);
        -:15635:
        -:15636:    // Notify platform layer of viewport changes
        -:15637:    // FIXME-DPI: This is only currently used for experimenting with handling of multiple DPI
     2154:15638:    if (g.CurrentViewport && g.PlatformIO.Platform_OnChangedViewport)
     2154:15638-block 9
branch  0 taken 1077 (fallthrough)
branch  1 taken 1077
     1077:15638-block 10
branch  2 taken 0 (fallthrough)
branch  3 taken 1077
    #####:15639:        g.PlatformIO.Platform_OnChangedViewport(g.CurrentViewport);
    %%%%%:15639-block 11
call    0 never executed
        -:15640:}
        -:15641:
function _ZN5ImGui17SetWindowViewportEP11ImGuiWindowP14ImGuiViewportP called 16368 returned 100% blocks executed 40%
    16368:15642:void ImGui::SetWindowViewport(ImGuiWindow* window, ImGuiViewportP* viewport)
        -:15643:{
        -:15644:    // Abandon viewport
   16368*:15645:    if (window->ViewportOwned && window->Viewport->Window == window)
    16368:15645-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 16368
    %%%%%:15645-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:15646:        window->Viewport->Size = ImVec2(0.0f, 0.0f);
    %%%%%:15646-block 4
call    0 never executed
        -:15647:
    16368:15648:    window->Viewport = viewport;
    16368:15649:    window->ViewportId = viewport->ID;
    16368:15650:    window->ViewportOwned = (viewport->Window == window);
    16368:15651:}
        -:15652:
function _ZN5ImGuiL30GetWindowAlwaysWantOwnViewportEP11ImGuiWindow called 0 returned 0% blocks executed 0%
    #####:15653:static bool ImGui::GetWindowAlwaysWantOwnViewport(ImGuiWindow* window)
        -:15654:{
        -:15655:    // Tooltips and menus are not automatically forced into their own viewport when the NoMerge flag is set, however the multiplication of viewports makes them more likely to protrude and create their own.
    #####:15656:    ImGuiContext& g = *GImGui;
    #####:15657:    if (g.IO.ConfigViewportsNoAutoMerge || (window->WindowClass.ViewportFlagsOverrideSet & ImGuiViewportFlags_NoAutoMerge))
    %%%%%:15657-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:15657-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:15658:        if (g.ConfigFlagsCurrFrame & ImGuiConfigFlags_ViewportsEnable)
    %%%%%:15658-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:15659:            if (!window->DockIsActive)
    %%%%%:15659-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:15660:                if ((window->Flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_ChildMenu | ImGuiWindowFlags_Tooltip)) == 0)
    %%%%%:15660-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:15661:                    if ((window->Flags & ImGuiWindowFlags_Popup) == 0 || (window->Flags & ImGuiWindowFlags_Modal) != 0)
    %%%%%:15661-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:15661-block 8
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:15662:                        return true;
    %%%%%:15662-block 9
    #####:15663:    return false;
    %%%%%:15663-block 10
        -:15664:}
        -:15665:
function _ZN5ImGuiL36UpdateTryMergeWindowIntoHostViewportEP11ImGuiWindowP14ImGuiViewportP called 0 returned 0% blocks executed 0%
    #####:15666:static bool ImGui::UpdateTryMergeWindowIntoHostViewport(ImGuiWindow* window, ImGuiViewportP* viewport)
        -:15667:{
    #####:15668:    ImGuiContext& g = *GImGui;
    #####:15669:    if (window->Viewport == viewport)
    %%%%%:15669-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:15670:        return false;
    %%%%%:15670-block 3
    #####:15671:    if ((viewport->Flags & ImGuiViewportFlags_CanHostOtherWindows) == 0)
    %%%%%:15671-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:15672:        return false;
    %%%%%:15672-block 5
    #####:15673:    if ((viewport->Flags & ImGuiViewportFlags_IsMinimized) != 0)
    %%%%%:15673-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:15674:        return false;
    %%%%%:15674-block 7
    #####:15675:    if (!viewport->GetMainRect().Contains(window->Rect()))
    %%%%%:15675-block 8
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:15676:        return false;
    %%%%%:15676-block 12
    #####:15677:    if (GetWindowAlwaysWantOwnViewport(window))
    %%%%%:15677-block 13
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:15678:        return false;
    %%%%%:15678-block 15
        -:15679:
        -:15680:    // FIXME: Can't use g.WindowsFocusOrder[] for root windows only as we care about Z order. If we maintained a DisplayOrder along with FocusOrder we could..
    #####:15681:    for (ImGuiWindow* window_behind : g.Windows)
    %%%%%:15681-block 16
call    0 never executed
call    1 never executed
    %%%%%:15681-block 28
    %%%%%:15681-block 29
branch  2 never executed
branch  3 never executed (fallthrough)
        -:15682:    {
    #####:15683:        if (window_behind == window)
    %%%%%:15683-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:15684:            break;
    %%%%%:15684-block 19
    #####:15685:        if (window_behind->WasActive && window_behind->ViewportOwned && !(window_behind->Flags & ImGuiWindowFlags_ChildWindow))
    %%%%%:15685-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:15685-block 21
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:15685-block 22
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:15686:            if (window_behind->Viewport->GetMainRect().Overlaps(window->Rect()))
    %%%%%:15686-block 23
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:15687:                return false;
    %%%%%:15687-block 27
        -:15688:    }
        -:15689:
        -:15690:    // Move to the existing viewport, Move child/hosted windows as well (FIXME-OPT: iterate child)
    #####:15691:    ImGuiViewportP* old_viewport = window->Viewport;
    #####:15692:    if (window->ViewportOwned)
    %%%%%:15692-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:15693:        for (int n = 0; n < g.Windows.Size; n++)
    %%%%%:15693-block 31
    %%%%%:15693-block 36
    %%%%%:15693-block 37
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:15694:            if (g.Windows[n]->Viewport == old_viewport)
    %%%%%:15694-block 32
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:15695:                SetWindowViewport(g.Windows[n], viewport);
    %%%%%:15695-block 34
call    0 never executed
call    1 never executed
    #####:15696:    SetWindowViewport(window, viewport);
    %%%%%:15696-block 38
call    0 never executed
    #####:15697:    BringWindowToDisplayFront(window);
call    0 never executed
        -:15698:
    #####:15699:    return true;
        -:15700:}
        -:15701:
        -:15702:// FIXME: handle 0 to N host viewports
function _ZN5ImGuiL37UpdateTryMergeWindowIntoHostViewportsEP11ImGuiWindow called 0 returned 0% blocks executed 0%
    #####:15703:static bool ImGui::UpdateTryMergeWindowIntoHostViewports(ImGuiWindow* window)
        -:15704:{
    #####:15705:    ImGuiContext& g = *GImGui;
    #####:15706:    return UpdateTryMergeWindowIntoHostViewport(window, g.Viewports[0]);
    %%%%%:15706-block 2
call    0 never executed
call    1 never executed
        -:15707:}
        -:15708:
        -:15709:// Translate Dear ImGui windows when a Host Viewport has been moved
        -:15710:// (This additionally keeps windows at the same place when ImGuiConfigFlags_ViewportsEnable is toggled!)
function _ZN5ImGui26TranslateWindowsInViewportEP14ImGuiViewportPRK6ImVec2S4_S4_S4_ called 0 returned 0% blocks executed 0%
    #####:15711:void ImGui::TranslateWindowsInViewport(ImGuiViewportP* viewport, const ImVec2& old_pos, const ImVec2& new_pos, const ImVec2& old_size, const ImVec2& new_size)
        -:15712:{
    #####:15713:    ImGuiContext& g = *GImGui;
    #####:15714:    IM_ASSERT(viewport->Window == NULL && (viewport->Flags & ImGuiViewportFlags_CanHostOtherWindows));
    %%%%%:15714-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:15714-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:15714-block 4
    %%%%%:15714-block 5
call    4 never executed
        -:15715:
        -:15716:    // 1) We test if ImGuiConfigFlags_ViewportsEnable was just toggled, which allows us to conveniently
        -:15717:    // translate imgui windows from OS-window-local to absolute coordinates or vice-versa.
        -:15718:    // 2) If it's not going to fit into the new size, keep it at same absolute position.
        -:15719:    // One problem with this is that most Win32 applications doesn't update their render while dragging,
        -:15720:    // and so the window will appear to teleport when releasing the mouse.
    #####:15721:    const bool translate_all_windows = (g.ConfigFlagsCurrFrame & ImGuiConfigFlags_ViewportsEnable) != (g.ConfigFlagsLastFrame & ImGuiConfigFlags_ViewportsEnable);
    #####:15722:    ImRect test_still_fit_rect(old_pos, old_pos + viewport->Size);
    %%%%%:15722-block 6
call    0 never executed
call    1 never executed
    #####:15723:    ImVec2 delta_pos = new_pos - old_pos;
call    0 never executed
    #####:15724:    for (ImGuiWindow* window : g.Windows) // FIXME-OPT
call    0 never executed
call    1 never executed
    %%%%%:15724-block 22
    %%%%%:15724-block 23
branch  2 never executed
branch  3 never executed (fallthrough)
    #####:15725:        if (translate_all_windows || (window->Viewport == viewport && (old_size == new_size || test_still_fit_rect.Contains(window->Rect()))))
    %%%%%:15725-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:15725-block 12
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:15725-block 13
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:15725-block 15
call    7 never executed
call    8 never executed
branch  9 never executed (fallthrough)
branch 10 never executed
    %%%%%:15725-block 18
    %%%%%:15725-block 19
    %%%%%:15725-block 20
branch 11 never executed (fallthrough)
branch 12 never executed
    #####:15726:            TranslateWindow(window, delta_pos);
    %%%%%:15726-block 21
call    0 never executed
    #####:15727:}
        -:15728:
        -:15729:// Scale all windows (position, size). Use when e.g. changing DPI. (This is a lossy operation!)
function _ZN5ImGui22ScaleWindowsInViewportEP14ImGuiViewportPf called 0 returned 0% blocks executed 0%
    #####:15730:void ImGui::ScaleWindowsInViewport(ImGuiViewportP* viewport, float scale)
        -:15731:{
    #####:15732:    ImGuiContext& g = *GImGui;
    #####:15733:    if (viewport->Window)
    %%%%%:15733-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -:15734:    {
    #####:15735:        ScaleWindow(viewport->Window, scale);
    %%%%%:15735-block 3
call    0 never executed
        -:15736:    }
        -:15737:    else
        -:15738:    {
    #####:15739:        for (ImGuiWindow* window : g.Windows)
    %%%%%:15739-block 4
call    0 never executed
call    1 never executed
    %%%%%:15739-block 8
    %%%%%:15739-block 9
branch  2 never executed
branch  3 never executed (fallthrough)
    #####:15740:            if (window->Viewport == viewport)
    %%%%%:15740-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:15741:                ScaleWindow(window, scale);
    %%%%%:15741-block 7
call    0 never executed
        -:15742:    }
    #####:15743:}
        -:15744:
        -:15745:// If the backend doesn't set MouseLastHoveredViewport or doesn't honor ImGuiViewportFlags_NoInputs, we do a search ourselves.
        -:15746:// A) It won't take account of the possibility that non-imgui windows may be in-between our dragged window and our target window.
        -:15747:// B) It requires Platform_GetWindowFocus to be implemented by backend.
function _ZN5ImGui42FindHoveredViewportFromPlatformWindowStackERK6ImVec2 called 0 returned 0% blocks executed 0%
    #####:15748:ImGuiViewportP* ImGui::FindHoveredViewportFromPlatformWindowStack(const ImVec2& mouse_platform_pos)
        -:15749:{
    #####:15750:    ImGuiContext& g = *GImGui;
    #####:15751:    ImGuiViewportP* best_candidate = NULL;
    #####:15752:    for (ImGuiViewportP* viewport : g.Viewports)
    %%%%%:15752-block 2
call    0 never executed
call    1 never executed
    %%%%%:15752-block 14
    %%%%%:15752-block 15
branch  2 never executed
branch  3 never executed (fallthrough)
    #####:15753:        if (!(viewport->Flags & (ImGuiViewportFlags_NoInputs | ImGuiViewportFlags_IsMinimized)) && viewport->GetMainRect().Contains(mouse_platform_pos))
    %%%%%:15753-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:15753-block 5
call    2 never executed
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:15753-block 8
    %%%%%:15753-block 9
    %%%%%:15753-block 10
branch  6 never executed (fallthrough)
branch  7 never executed
    #####:15754:            if (best_candidate == NULL || best_candidate->LastFocusedStampCount < viewport->LastFocusedStampCount)
    %%%%%:15754-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:15754-block 12
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:15755:                best_candidate = viewport;
    %%%%%:15755-block 13
    #####:15756:    return best_candidate;
    %%%%%:15756-block 16
        -:15757:}
        -:15758:
        -:15759:// Update viewports and monitor infos
        -:15760:// Note that this is running even if 'ImGuiConfigFlags_ViewportsEnable' is not set, in order to clear unused viewports (if any) and update monitor info.
function _ZN5ImGuiL23UpdateViewportsNewFrameEv called 1077 returned 100% blocks executed 26%
     1077:15761:static void ImGui::UpdateViewportsNewFrame()
        -:15762:{
     1077:15763:    ImGuiContext& g = *GImGui;
    1077*:15764:    IM_ASSERT(g.PlatformIO.Viewports.Size <= g.Viewports.Size);
     1077:15764-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:15764-block 3
call    2 never executed
        -:15765:
        -:15766:    // Update Minimized status (we need it first in order to decide if we'll apply Pos/Size of the main viewport)
        -:15767:    // Update Focused status
     1077:15768:    const bool viewports_enabled = (g.ConfigFlagsCurrFrame & ImGuiConfigFlags_ViewportsEnable) != 0;
     1077:15769:    if (viewports_enabled)
     1077:15769-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
        -:15770:    {
    #####:15771:        ImGuiViewportP* focused_viewport = NULL;
    #####:15772:        for (ImGuiViewportP* viewport : g.Viewports)
    %%%%%:15772-block 5
call    0 never executed
call    1 never executed
    %%%%%:15772-block 21
    %%%%%:15772-block 22
branch  2 never executed
branch  3 never executed (fallthrough)
        -:15773:        {
    #####:15774:            const bool platform_funcs_available = viewport->PlatformWindowCreated;
    #####:15775:            if (g.PlatformIO.Platform_GetWindowMinimized && platform_funcs_available)
    %%%%%:15775-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:15775-block 8
branch  2 never executed (fallthrough)
branch  3 never executed
        -:15776:            {
    #####:15777:                bool is_minimized = g.PlatformIO.Platform_GetWindowMinimized(viewport);
    %%%%%:15777-block 9
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:15778:                if (is_minimized)
    %%%%%:15778-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:15779:                    viewport->Flags |= ImGuiViewportFlags_IsMinimized;
    %%%%%:15779-block 11
        -:15780:                else
    #####:15781:                    viewport->Flags &= ~ImGuiViewportFlags_IsMinimized;
    %%%%%:15781-block 12
        -:15782:            }
        -:15783:
        -:15784:            // Update our implicit z-order knowledge of platform windows, which is used when the backend cannot provide io.MouseHoveredViewport.
        -:15785:            // When setting Platform_GetWindowFocus, it is expected that the platform backend can handle calls without crashing if it doesn't have data stored.
    #####:15786:            if (g.PlatformIO.Platform_GetWindowFocus && platform_funcs_available)
    %%%%%:15786-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:15786-block 14
branch  2 never executed (fallthrough)
branch  3 never executed
        -:15787:            {
    #####:15788:                bool is_focused = g.PlatformIO.Platform_GetWindowFocus(viewport);
    %%%%%:15788-block 15
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:15789:                if (is_focused)
    %%%%%:15789-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:15790:                    viewport->Flags |= ImGuiViewportFlags_IsFocused;
    %%%%%:15790-block 17
        -:15791:                else
    #####:15792:                    viewport->Flags &= ~ImGuiViewportFlags_IsFocused;
    %%%%%:15792-block 18
    #####:15793:                if (is_focused)
    %%%%%:15793-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:15794:                    focused_viewport = viewport;
    %%%%%:15794-block 20
        -:15795:            }
        -:15796:        }
        -:15797:
        -:15798:        // Focused viewport has changed?
    #####:15799:        if (focused_viewport && g.PlatformLastFocusedViewportId != focused_viewport->ID)
    %%%%%:15799-block 23
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:15799-block 24
branch  2 never executed (fallthrough)
branch  3 never executed
        -:15800:        {
    #####:15801:            IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Focused viewport changed %08X -> %08X, attempting to apply our focus.\n", g.PlatformLastFocusedViewportId, focused_viewport->ID);
    %%%%%:15801-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:15801-block 26
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####:15802:            const ImGuiViewport* prev_focused_viewport = FindViewportByID(g.PlatformLastFocusedViewportId);
    %%%%%:15802-block 27
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:15803:            const bool prev_focused_has_been_destroyed = (prev_focused_viewport == NULL) || (prev_focused_viewport->PlatformWindowCreated == false);
    %%%%%:15803-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:15803-block 29
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:15803-block 30
    %%%%%:15803-block 31
        -:15804:
        -:15805:            // Store a tag so we can infer z-order easily from all our windows
        -:15806:            // We compare PlatformLastFocusedViewportId so newly created viewports with _NoFocusOnAppearing flag
        -:15807:            // will keep the front most stamp instead of losing it back to their parent viewport.
    #####:15808:            if (focused_viewport->LastFocusedStampCount != g.ViewportFocusedStampCount)
    %%%%%:15808-block 32
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:15809:                focused_viewport->LastFocusedStampCount = ++g.ViewportFocusedStampCount;
    %%%%%:15809-block 33
    #####:15810:            g.PlatformLastFocusedViewportId = focused_viewport->ID;
        -:15811:
        -:15812:            // Focus associated dear imgui window
        -:15813:            // - if focus didn't happen with a click within imgui boundaries, e.g. Clicking platform title bar. (#6299)
        -:15814:            // - if focus didn't happen because we destroyed another window (#6462)
        -:15815:            // FIXME: perhaps 'FocusTopMostWindowUnderOne()' can handle the 'focused_window->Window != NULL' case as well.
    #####:15816:            const bool apply_imgui_focus_on_focused_viewport = !IsAnyMouseDown() && !prev_focused_has_been_destroyed;
    %%%%%:15816-block 34
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:15816-block 36
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:15816-block 37
    %%%%%:15816-block 38
    #####:15817:            if (apply_imgui_focus_on_focused_viewport)
    %%%%%:15817-block 39
branch  0 never executed (fallthrough)
branch  1 never executed
        -:15818:            {
    #####:15819:                focused_viewport->LastFocusedHadNavWindow |= (g.NavWindow != NULL) && (g.NavWindow->Viewport == focused_viewport); // Update so a window changing viewport won't lose focus.
    %%%%%:15819-block 40
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:15819-block 41
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:15819-block 42
    %%%%%:15819-block 43
    #####:15820:                ImGuiFocusRequestFlags focus_request_flags = ImGuiFocusRequestFlags_UnlessBelowModal | ImGuiFocusRequestFlags_RestoreFocusedChild;
    #####:15821:                if (focused_viewport->Window != NULL)
    %%%%%:15821-block 44
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:15822:                    FocusWindow(focused_viewport->Window, focus_request_flags);
    %%%%%:15822-block 45
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:15823:                else if (focused_viewport->LastFocusedHadNavWindow)
    %%%%%:15823-block 46
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:15824:                    FocusTopMostWindowUnderOne(NULL, NULL, focused_viewport, focus_request_flags); // Focus top most in viewport
    %%%%%:15824-block 47
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:15825:                else
    #####:15826:                    FocusWindow(NULL, focus_request_flags); // No window had focus last time viewport was focused
    %%%%%:15826-block 48
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:15827:            }
        -:15828:        }
    #####:15829:        if (focused_viewport)
    %%%%%:15829-block 49
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:15830:            focused_viewport->LastFocusedHadNavWindow = (g.NavWindow != NULL) && (g.NavWindow->Viewport == focused_viewport);
    %%%%%:15830-block 50
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:15830-block 51
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:15830-block 52
    %%%%%:15830-block 53
    %%%%%:15830-block 54
        -:15831:    }
        -:15832:
        -:15833:    // Create/update main viewport with current platform position.
        -:15834:    // FIXME-VIEWPORT: Size is driven by backend/user code for backward-compatibility but we should aim to make this more consistent.
     1077:15835:    ImGuiViewportP* main_viewport = g.Viewports[0];
     1077:15835-block 55
call    0 returned 1077
    1077*:15836:    IM_ASSERT(main_viewport->ID == IMGUI_VIEWPORT_DEFAULT_ID);
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:15836-block 57
call    2 never executed
    1077*:15837:    IM_ASSERT(main_viewport->Window == NULL);
     1077:15837-block 58
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:15837-block 59
call    2 never executed
    1077*:15838:    ImVec2 main_viewport_pos = viewports_enabled ? g.PlatformIO.Platform_GetWindowPos(main_viewport) : ImVec2(0.0f, 0.0f);
     1077:15838-block 60
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:15838-block 61
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
     1077:15838-block 62
call    5 returned 1077
     1077:15839:    ImVec2 main_viewport_size = g.IO.DisplaySize;
    1077*:15840:    if (viewports_enabled && (main_viewport->Flags & ImGuiViewportFlags_IsMinimized))
     1077:15840-block 63
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:15840-block 64
branch  2 never executed (fallthrough)
branch  3 never executed
        -:15841:    {
    #####:15842:        main_viewport_pos = main_viewport->Pos;    // Preserve last pos/size when minimized (FIXME: We don't do the same for Size outside of the viewport path)
    #####:15843:        main_viewport_size = main_viewport->Size;
    %%%%%:15843-block 65
        -:15844:    }
     1077:15845:    AddUpdateViewport(NULL, IMGUI_VIEWPORT_DEFAULT_ID, main_viewport_pos, main_viewport_size, ImGuiViewportFlags_OwnedByApp | ImGuiViewportFlags_CanHostOtherWindows);
     1077:15845-block 66
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -:15846:
     1077:15847:    g.CurrentDpiScale = 0.0f;
     1077:15848:    g.CurrentViewport = NULL;
     1077:15849:    g.MouseViewport = NULL;
     2154:15850:    for (int n = 0; n < g.Viewports.Size; n++)
     1077:15850-block 67
     1077:15850-block 118
     2154:15850-block 119
branch  0 taken 1077
branch  1 taken 1077 (fallthrough)
        -:15851:    {
     1077:15852:        ImGuiViewportP* viewport = g.Viewports[n];
     1077:15852-block 68
call    0 returned 1077
     1077:15853:        viewport->Idx = n;
        -:15854:
        -:15855:        // Erase unused viewports
    1077*:15856:        if (n > 0 && viewport->LastFrameActive < g.FrameCount - 2)
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:15856-block 70
branch  2 never executed (fallthrough)
branch  3 never executed
        -:15857:        {
    #####:15858:            DestroyViewport(viewport);
    %%%%%:15858-block 71
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:15859:            n--;
    #####:15860:            continue;
    %%%%%:15860-block 72
        -:15861:        }
        -:15862:
     1077:15863:        const bool platform_funcs_available = viewport->PlatformWindowCreated;
     1077:15864:        if (viewports_enabled)
     1077:15864-block 73
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
        -:15865:        {
        -:15866:            // Update Position and Size (from Platform Window to ImGui) if requested.
        -:15867:            // We do it early in the frame instead of waiting for UpdatePlatformWindows() to avoid a frame of lag when moving/resizing using OS facilities.
    #####:15868:            if (!(viewport->Flags & ImGuiViewportFlags_IsMinimized) && platform_funcs_available)
    %%%%%:15868-block 74
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:15868-block 75
branch  2 never executed (fallthrough)
branch  3 never executed
        -:15869:            {
        -:15870:                // Viewport->WorkPos and WorkSize will be updated below
    #####:15871:                if (viewport->PlatformRequestMove)
    %%%%%:15871-block 76
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:15872:                    viewport->Pos = viewport->LastPlatformPos = g.PlatformIO.Platform_GetWindowPos(viewport);
    %%%%%:15872-block 77
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:15872-block 78
    #####:15873:                if (viewport->PlatformRequestResize)
    %%%%%:15873-block 79
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:15874:                    viewport->Size = viewport->LastPlatformSize = g.PlatformIO.Platform_GetWindowSize(viewport);
    %%%%%:15874-block 80
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:15874-block 81
        -:15875:            }
        -:15876:        }
        -:15877:
        -:15878:        // Update/copy monitor info
     1077:15879:        UpdateViewportPlatformMonitor(viewport);
     1077:15879-block 82
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -:15880:
        -:15881:        // Lock down space taken by menu bars and status bars + query initial insets from backend
        -:15882:        // Setup initial value for functions like BeginMainMenuBar(), DockSpaceOverViewport() etc.
     1077:15883:        viewport->WorkInsetMin = viewport->BuildWorkInsetMin;
     1077:15884:        viewport->WorkInsetMax = viewport->BuildWorkInsetMax;
     1077:15885:        viewport->BuildWorkInsetMin = viewport->BuildWorkInsetMax = ImVec2(0.0f, 0.0f);
     1077:15885-block 83
call    0 returned 1077
    1077*:15886:        if (g.PlatformIO.Platform_GetWindowWorkAreaInsets != NULL && platform_funcs_available)
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:15886-block 85
branch  2 never executed (fallthrough)
branch  3 never executed
        -:15887:        {
    #####:15888:            ImVec4 insets = g.PlatformIO.Platform_GetWindowWorkAreaInsets(viewport);
    %%%%%:15888-block 86
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:15889:            IM_ASSERT(insets.x >= 0.0f && insets.y >= 0.0f && insets.z >= 0.0f && insets.w >= 0.0f);
    %%%%%:15889-block 87
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:15889-block 88
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:15889-block 89
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:15889-block 90
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%:15889-block 91
    %%%%%:15889-block 92
call    8 never executed
    #####:15890:            viewport->BuildWorkInsetMin = ImVec2(insets.x, insets.y);
    %%%%%:15890-block 93
call    0 never executed
    #####:15891:            viewport->BuildWorkInsetMax = ImVec2(insets.z, insets.w);
call    0 never executed
        -:15892:        }
     1077:15893:        viewport->UpdateWorkRect();
     1077:15893-block 96
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -:15894:
        -:15895:        // Reset alpha every frame. Users of transparency (docking) needs to request a lower alpha back.
     1077:15896:        viewport->Alpha = 1.0f;
        -:15897:
        -:15898:        // Translate Dear ImGui windows when a Host Viewport has been moved
        -:15899:        // (This additionally keeps windows at the same place when ImGuiConfigFlags_ViewportsEnable is toggled!)
     1077:15900:        const ImVec2 viewport_delta_pos = viewport->Pos - viewport->LastPos;
     1077:15900-block 97
call    0 returned 1077
     1077:15901:        if ((viewport->Flags & ImGuiViewportFlags_CanHostOtherWindows) && (viewport_delta_pos.x != 0.0f || viewport_delta_pos.y != 0.0f))
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:15901-block 99
branch  2 taken 1077 (fallthrough)
branch  3 taken 0
     1077:15901-block 100
branch  4 taken 0 (fallthrough)
branch  5 taken 1077
    #####:15902:            TranslateWindowsInViewport(viewport, viewport->LastPos, viewport->Pos, viewport->LastSize, viewport->Size);
    %%%%%:15902-block 101
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:15903:
        -:15904:        // Update DPI scale
        -:15905:        float new_dpi_scale;
    1077*:15906:        if (g.PlatformIO.Platform_GetWindowDpiScale && platform_funcs_available)
     1077:15906-block 102
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:15906-block 103
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:15907:            new_dpi_scale = g.PlatformIO.Platform_GetWindowDpiScale(viewport);
    %%%%%:15907-block 104
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:15907-block 105
     1077:15908:        else if (viewport->PlatformMonitor != -1)
     1077:15908-block 106
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:15909:            new_dpi_scale = g.PlatformIO.Monitors[viewport->PlatformMonitor].DpiScale;
     1077:15909-block 107
call    0 returned 1077
        -:15910:        else
    #####:15911:            new_dpi_scale = (viewport->DpiScale != 0.0f) ? viewport->DpiScale : 1.0f;
    %%%%%:15911-block 109
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:15911-block 110
    %%%%%:15911-block 111
    %%%%%:15911-block 112
     1077:15912:        if (viewport->DpiScale != 0.0f && new_dpi_scale != viewport->DpiScale)
     1077:15912-block 113
branch  0 taken 1076 (fallthrough)
branch  1 taken 1
     1076:15912-block 114
branch  2 taken 0 (fallthrough)
branch  3 taken 1076
        -:15913:        {
    #####:15914:            float scale_factor = new_dpi_scale / viewport->DpiScale;
    #####:15915:            if (g.IO.ConfigFlags & ImGuiConfigFlags_DpiEnableScaleViewports)
    %%%%%:15915-block 115
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:15916:                ScaleWindowsInViewport(viewport, scale_factor);
    %%%%%:15916-block 116
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:15917:            //if (viewport == GetMainViewport())
        -:15918:            //    g.PlatformInterface.SetWindowSize(viewport, viewport->Size * scale_factor);
        -:15919:
        -:15920:            // Scale our window moving pivot so that the window will rescale roughly around the mouse position.
        -:15921:            // FIXME-VIEWPORT: This currently creates a resizing feedback loop when a window is straddling a DPI transition border.
        -:15922:            // (Minor: since our sizes do not perfectly linearly scale, deferring the click offset scale until we know the actual window scale ratio may get us slightly more precise mouse positioning.)
        -:15923:            //if (g.MovingWindow != NULL && g.MovingWindow->Viewport == viewport)
        -:15924:            //    g.ActiveIdClickOffset = ImTrunc(g.ActiveIdClickOffset * scale_factor);
        -:15925:        }
     1077:15926:        viewport->DpiScale = new_dpi_scale;
     1077:15926-block 117
        -:15927:    }
        -:15928:
        -:15929:    // Update fallback monitor
     1077:15930:    g.PlatformMonitorsFullWorkRect = ImRect(+FLT_MAX, +FLT_MAX, -FLT_MAX, -FLT_MAX);
     1077:15930-block 120
call    0 returned 1077
     1077:15931:    if (g.PlatformIO.Monitors.Size == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
        -:15932:    {
    #####:15933:        ImGuiPlatformMonitor* monitor = &g.FallbackMonitor;
    #####:15934:        monitor->MainPos = main_viewport->Pos;
    #####:15935:        monitor->MainSize = main_viewport->Size;
    #####:15936:        monitor->WorkPos = main_viewport->WorkPos;
    #####:15937:        monitor->WorkSize = main_viewport->WorkSize;
    #####:15938:        monitor->DpiScale = main_viewport->DpiScale;
    #####:15939:        g.PlatformMonitorsFullWorkRect.Add(monitor->WorkPos);
    %%%%%:15939-block 122
call    0 never executed
    #####:15940:        g.PlatformMonitorsFullWorkRect.Add(monitor->WorkPos + monitor->WorkSize);
call    0 never executed
call    1 never executed
        -:15941:    }
        -:15942:    else
        -:15943:    {
     1077:15944:        g.FallbackMonitor = g.PlatformIO.Monitors[0];
     1077:15944-block 126
call    0 returned 1077
        -:15945:    }
     2154:15946:    for (ImGuiPlatformMonitor& monitor : g.PlatformIO.Monitors)
     1077:15946-block 128
call    0 returned 1077
call    1 returned 1077
     2154:15946-block 134
branch  2 taken 1077
branch  3 taken 1077 (fallthrough)
        -:15947:    {
     1077:15948:        g.PlatformMonitorsFullWorkRect.Add(monitor.WorkPos);
     1077:15948-block 130
call    0 returned 1077
     1077:15949:        g.PlatformMonitorsFullWorkRect.Add(monitor.WorkPos + monitor.WorkSize);
call    0 returned 1077
call    1 returned 1077
        -:15950:    }
        -:15951:
     1077:15952:    if (!viewports_enabled)
     1077:15952-block 135
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
        -:15953:    {
     1077:15954:        g.MouseViewport = main_viewport;
     1077:15955:        return;
     1077:15955-block 136
        -:15956:    }
        -:15957:
        -:15958:    // Mouse handling: decide on the actual mouse viewport for this frame between the active/focused viewport and the hovered viewport.
        -:15959:    // Note that 'viewport_hovered' should skip over any viewport that has the ImGuiViewportFlags_NoInputs flags set.
    #####:15960:    ImGuiViewportP* viewport_hovered = NULL;
    #####:15961:    if (g.IO.BackendFlags & ImGuiBackendFlags_HasMouseHoveredViewport)
    %%%%%:15961-block 137
branch  0 never executed (fallthrough)
branch  1 never executed
        -:15962:    {
    #####:15963:        viewport_hovered = g.IO.MouseHoveredViewport ? (ImGuiViewportP*)FindViewportByID(g.IO.MouseHoveredViewport) : NULL;
    %%%%%:15963-block 138
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:15963-block 139
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%:15963-block 140
    %%%%%:15963-block 141
    #####:15964:        if (viewport_hovered && (viewport_hovered->Flags & ImGuiViewportFlags_NoInputs))
    %%%%%:15964-block 142
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:15964-block 143
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:15965:            viewport_hovered = FindHoveredViewportFromPlatformWindowStack(g.IO.MousePos); // Backend failed to handle _NoInputs viewport: revert to our fallback.
    %%%%%:15965-block 144
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:15965-block 145
        -:15966:    }
        -:15967:    else
        -:15968:    {
        -:15969:        // If the backend doesn't know how to honor ImGuiViewportFlags_NoInputs, we do a search ourselves. Note that this search:
        -:15970:        // A) won't take account of the possibility that non-imgui windows may be in-between our dragged window and our target window.
        -:15971:        // B) won't take account of how the backend apply parent<>child relationship to secondary viewports, which affects their Z order.
        -:15972:        // C) uses LastFrameAsRefViewport as a flawed replacement for the last time a window was focused (we could/should fix that by introducing Focus functions in PlatformIO)
    #####:15973:        viewport_hovered = FindHoveredViewportFromPlatformWindowStack(g.IO.MousePos);
    %%%%%:15973-block 146
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:15973-block 147
        -:15974:    }
    #####:15975:    if (viewport_hovered != NULL)
    %%%%%:15975-block 148
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:15976:        g.MouseLastHoveredViewport = viewport_hovered;
    %%%%%:15976-block 149
    #####:15977:    else if (g.MouseLastHoveredViewport == NULL)
    %%%%%:15977-block 150
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:15978:        g.MouseLastHoveredViewport = g.Viewports[0];
    %%%%%:15978-block 151
call    0 never executed
        -:15979:
        -:15980:    // Update mouse reference viewport
        -:15981:    // (when moving a window we aim at its viewport, but this will be overwritten below if we go in drag and drop mode)
        -:15982:    // (MovingViewport->Viewport will be NULL in the rare situation where the window disappared while moving, set UpdateMouseMovingWindowNewFrame() for details)
    #####:15983:    if (g.MovingWindow && g.MovingWindow->Viewport)
    %%%%%:15983-block 153
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:15983-block 154
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:15984:        g.MouseViewport = g.MovingWindow->Viewport;
    %%%%%:15984-block 155
        -:15985:    else
    #####:15986:        g.MouseViewport = g.MouseLastHoveredViewport;
    %%%%%:15986-block 156
        -:15987:
        -:15988:    // When dragging something, always refer to the last hovered viewport.
        -:15989:    // - when releasing a moving window we will revert to aiming behind (at viewport_hovered)
        -:15990:    // - when we are between viewports, our dragged preview will tend to show in the last viewport _even_ if we don't have tooltips in their viewports (when lacking monitor info)
        -:15991:    // - consider the case of holding on a menu item to browse child menus: even thou a mouse button is held, there's no active id because menu items only react on mouse release.
        -:15992:    // FIXME-VIEWPORT: This is essentially broken, when ImGuiBackendFlags_HasMouseHoveredViewport is set we want to trust when viewport_hovered==NULL and use that.
    #####:15993:    const bool is_mouse_dragging_with_an_expected_destination = g.DragDropActive;
    #####:15994:    if (is_mouse_dragging_with_an_expected_destination && viewport_hovered == NULL)
    %%%%%:15994-block 157
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:15994-block 158
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:15995:        viewport_hovered = g.MouseLastHoveredViewport;
    %%%%%:15995-block 159
    #####:15996:    if (is_mouse_dragging_with_an_expected_destination || g.ActiveId == 0 || !IsAnyMouseDown())
    %%%%%:15996-block 160
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:15996-block 161
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:15996-block 162
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:15996-block 164
    %%%%%:15996-block 165
    %%%%%:15996-block 166
branch  7 never executed (fallthrough)
branch  8 never executed
    #####:15997:        if (viewport_hovered != NULL && viewport_hovered != g.MouseViewport && !(viewport_hovered->Flags & ImGuiViewportFlags_NoInputs))
    %%%%%:15997-block 167
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:15997-block 168
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:15997-block 169
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:15998:            g.MouseViewport = viewport_hovered;
    %%%%%:15998-block 170
        -:15999:
    #####:16000:    IM_ASSERT(g.MouseViewport != NULL);
    %%%%%:16000-block 171
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16000-block 172
call    2 never executed
        -:16001:}
        -:16002:
        -:16003:// Update user-facing viewport list (g.Viewports -> g.PlatformIO.Viewports after filtering out some)
function _ZN5ImGuiL23UpdateViewportsEndFrameEv called 1077 returned 100% blocks executed 69%
     1077:16004:static void ImGui::UpdateViewportsEndFrame()
        -:16005:{
     1077:16006:    ImGuiContext& g = *GImGui;
     1077:16007:    g.PlatformIO.Viewports.resize(0);
     1077:16007-block 2
call    0 returned 1077
     2154:16008:    for (int i = 0; i < g.Viewports.Size; i++)
     1077:16008-block 22
     2154:16008-block 23
branch  0 taken 1077
branch  1 taken 1077 (fallthrough)
        -:16009:    {
     1077:16010:        ImGuiViewportP* viewport = g.Viewports[i];
     1077:16010-block 4
call    0 returned 1077
     1077:16011:        viewport->LastPos = viewport->Pos;
     1077:16012:        viewport->LastSize = viewport->Size;
     1077:16013:        if (viewport->LastFrameActive < g.FrameCount || viewport->Size.x <= 0.0f || viewport->Size.y <= 0.0f)
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:16013-block 6
branch  2 taken 1077 (fallthrough)
branch  3 taken 0
     1077:16013-block 7
branch  4 taken 0 (fallthrough)
branch  5 taken 1077
    #####:16014:            if (i > 0) // Always include main viewport in the list
    %%%%%:16014-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:16015:                continue;
    %%%%%:16015-block 9
    1077*:16016:        if (viewport->Window && !IsWindowActiveAndVisible(viewport->Window))
     1077:16016-block 10
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:16016-block 11
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:16016-block 13
     1077:16016-block 14
     1077:16016-block 15
branch  5 taken 0 (fallthrough)
branch  6 taken 1077
    #####:16017:            continue;
    %%%%%:16017-block 16
     1077:16018:        if (i > 0)
     1077:16018-block 17
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####:16019:            IM_ASSERT(viewport->Window != NULL);
    %%%%%:16019-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16019-block 19
call    2 never executed
     1077:16020:        g.PlatformIO.Viewports.push_back(viewport);
     1077:16020-block 20
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:16020-block 21
        -:16021:    }
     1077:16022:    g.Viewports[0]->ClearRequestFlags(); // Clear main viewport flags because UpdatePlatformWindows() won't do it and may not even be called
     1077:16022-block 24
call    0 returned 1077
call    1 returned 1077
     1077:16023:}
        -:16024:
        -:16025:// FIXME: We should ideally refactor the system to call this every frame (we currently don't)
function _ZN5ImGuiL17AddUpdateViewportEP11ImGuiWindowjRK6ImVec2S4_i called 1077 returned 100% blocks executed 31%
     1077:16026:ImGuiViewportP* ImGui::AddUpdateViewport(ImGuiWindow* window, ImGuiID id, const ImVec2& pos, const ImVec2& size, ImGuiViewportFlags flags)
        -:16027:{
     1077:16028:    ImGuiContext& g = *GImGui;
    1077*:16029:    IM_ASSERT(id != 0);
     1077:16029-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:16029-block 3
call    2 never executed
        -:16030:
     1077:16031:    flags |= ImGuiViewportFlags_IsPlatformWindow;
     1077:16032:    if (window != NULL)
     1077:16032-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
        -:16033:    {
    #####:16034:        if (g.MovingWindow && g.MovingWindow->RootWindowDockTree == window)
    %%%%%:16034-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16034-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:16035:            flags |= ImGuiViewportFlags_NoInputs | ImGuiViewportFlags_NoFocusOnAppearing;
    %%%%%:16035-block 7
    #####:16036:        if ((window->Flags & ImGuiWindowFlags_NoMouseInputs) && (window->Flags & ImGuiWindowFlags_NoNavInputs))
    %%%%%:16036-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16036-block 9
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:16037:            flags |= ImGuiViewportFlags_NoInputs;
    %%%%%:16037-block 10
    #####:16038:        if (window->Flags & ImGuiWindowFlags_NoFocusOnAppearing)
    %%%%%:16038-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:16039:            flags |= ImGuiViewportFlags_NoFocusOnAppearing;
    %%%%%:16039-block 12
        -:16040:    }
        -:16041:
     1077:16042:    ImGuiViewportP* viewport = (ImGuiViewportP*)FindViewportByID(id);
     1077:16042-block 13
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:16043:    if (viewport)
     1077:16043-block 14
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
        -:16044:    {
        -:16045:        // Always update for main viewport as we are already pulling correct platform pos/size (see #4900)
    1077*:16046:        if (!viewport->PlatformRequestMove || viewport->ID == IMGUI_VIEWPORT_DEFAULT_ID)
     1077:16046-block 15
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:16046-block 16
branch  2 never executed (fallthrough)
branch  3 never executed
     1077:16047:            viewport->Pos = pos;
     1077:16047-block 17
    1077*:16048:        if (!viewport->PlatformRequestResize || viewport->ID == IMGUI_VIEWPORT_DEFAULT_ID)
     1077:16048-block 18
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:16048-block 19
branch  2 never executed (fallthrough)
branch  3 never executed
     1077:16049:            viewport->Size = size;
     1077:16049-block 20
     1077:16050:        viewport->Flags = flags | (viewport->Flags & (ImGuiViewportFlags_IsMinimized | ImGuiViewportFlags_IsFocused)); // Preserve existing flags
     1077:16050-block 21
        -:16051:    }
        -:16052:    else
        -:16053:    {
        -:16054:        // New viewport
    #####:16055:        viewport = IM_NEW(ImGuiViewportP)();
    %%%%%:16055-block 22
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:16055-block 23
call    3 never executed
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    $$$$$:16055-block 47
branch  7 never executed (fallthrough)
branch  8 never executed
    $$$$$:16055-block 48
call    9 never executed
    #####:16056:        viewport->ID = id;
    #####:16057:        viewport->Idx = g.Viewports.Size;
    #####:16058:        viewport->Pos = viewport->LastPos = pos;
    #####:16059:        viewport->Size = viewport->LastSize = size;
    #####:16060:        viewport->Flags = flags;
    #####:16061:        UpdateViewportPlatformMonitor(viewport);
    %%%%%:16061-block 25
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:16062:        g.Viewports.push_back(viewport);
    %%%%%:16062-block 26
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:16063:        g.ViewportCreatedCount++;
    #####:16064:        IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Add Viewport %08X '%s'\n", id, window ? window->Name : "<NULL>");
    %%%%%:16064-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16064-block 28
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:16064-block 29
    %%%%%:16064-block 30
    %%%%%:16064-block 31
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
        -:16065:
        -:16066:        // We normally setup for all viewports in NewFrame() but here need to handle the mid-frame creation of a new viewport.
        -:16067:        // We need to extend the fullscreen clip rect so the OverlayDrawList clip is correct for that the first frame
    #####:16068:        g.DrawListSharedData.ClipRectFullscreen.x = ImMin(g.DrawListSharedData.ClipRectFullscreen.x, viewport->Pos.x);
    %%%%%:16068-block 32
call    0 never executed
    #####:16069:        g.DrawListSharedData.ClipRectFullscreen.y = ImMin(g.DrawListSharedData.ClipRectFullscreen.y, viewport->Pos.y);
call    0 never executed
    #####:16070:        g.DrawListSharedData.ClipRectFullscreen.z = ImMax(g.DrawListSharedData.ClipRectFullscreen.z, viewport->Pos.x + viewport->Size.x);
call    0 never executed
    #####:16071:        g.DrawListSharedData.ClipRectFullscreen.w = ImMax(g.DrawListSharedData.ClipRectFullscreen.w, viewport->Pos.y + viewport->Size.y);
call    0 never executed
        -:16072:
        -:16073:        // Store initial DpiScale before the OS platform window creation, based on expected monitor data.
        -:16074:        // This is so we can select an appropriate font size on the first frame of our window lifetime
    #####:16075:        if (viewport->PlatformMonitor != -1)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:16076:            viewport->DpiScale = g.PlatformIO.Monitors[viewport->PlatformMonitor].DpiScale;
    %%%%%:16076-block 37
call    0 never executed
        -:16077:    }
        -:16078:
     1077:16079:    viewport->Window = window;
     1077:16080:    viewport->LastFrameActive = g.FrameCount;
     1077:16081:    viewport->UpdateWorkRect();
     1077:16081-block 39
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
    1077*:16082:    IM_ASSERT(window == NULL || viewport->ID == window->ID);
     1077:16082-block 40
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:16082-block 41
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:16082-block 42
call    4 never executed
        -:16083:
     1077:16084:    if (window != NULL)
     1077:16084-block 43
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####:16085:        window->ViewportOwned = true;
    %%%%%:16085-block 44
        -:16086:
     1077:16087:    return viewport;
     1077:16087-block 45
     1077:16087-block 46
        -:16088:}
        -:16089:
function _ZN5ImGuiL15DestroyViewportEP14ImGuiViewportP called 0 returned 0% blocks executed 0%
    #####:16090:static void ImGui::DestroyViewport(ImGuiViewportP* viewport)
        -:16091:{
        -:16092:    // Clear references to this viewport in windows (window->ViewportId becomes the master data)
    #####:16093:    ImGuiContext& g = *GImGui;
    #####:16094:    for (ImGuiWindow* window : g.Windows)
    %%%%%:16094-block 2
call    0 never executed
call    1 never executed
    %%%%%:16094-block 7
    %%%%%:16094-block 8
branch  2 never executed
branch  3 never executed (fallthrough)
        -:16095:    {
    #####:16096:        if (window->Viewport != viewport)
    %%%%%:16096-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:16097:            continue;
    %%%%%:16097-block 5
    #####:16098:        window->Viewport = NULL;
    #####:16099:        window->ViewportOwned = false;
    %%%%%:16099-block 6
        -:16100:    }
    #####:16101:    if (viewport == g.MouseLastHoveredViewport)
    %%%%%:16101-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:16102:        g.MouseLastHoveredViewport = NULL;
    %%%%%:16102-block 10
        -:16103:
        -:16104:    // Destroy
    #####:16105:    IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Delete Viewport %08X '%s'\n", viewport->ID, viewport->Window ? viewport->Window->Name : "n/a");
    %%%%%:16105-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16105-block 12
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:16105-block 13
    %%%%%:16105-block 14
    %%%%%:16105-block 15
call    4 never executed
    #####:16106:    DestroyPlatformWindow(viewport); // In most circumstances the platform window will already be destroyed here.
    %%%%%:16106-block 16
call    0 never executed
    #####:16107:    IM_ASSERT(g.PlatformIO.Viewports.contains(viewport) == false);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:16107-block 19
call    3 never executed
    #####:16108:    IM_ASSERT(g.Viewports[viewport->Idx] == viewport);
    %%%%%:16108-block 20
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:16108-block 22
call    3 never executed
    #####:16109:    g.Viewports.erase(g.Viewports.Data + viewport->Idx);
    %%%%%:16109-block 23
call    0 never executed
    #####:16110:    IM_DELETE(viewport);
call    0 never executed
    #####:16111:}
        -:16112:
        -:16113:// FIXME-VIEWPORT: This is all super messy and ought to be clarified or rewritten.
function _ZN5ImGuiL20WindowSelectViewportEP11ImGuiWindow called 16368 returned 100% blocks executed 5%
    16368:16114:static void ImGui::WindowSelectViewport(ImGuiWindow* window)
        -:16115:{
    16368:16116:    ImGuiContext& g = *GImGui;
    16368:16117:    ImGuiWindowFlags flags = window->Flags;
    16368:16118:    window->ViewportAllowPlatformMonitorExtend = -1;
        -:16119:
        -:16120:    // Restore main viewport if multi-viewport is not supported by the backend
    16368:16121:    ImGuiViewportP* main_viewport = (ImGuiViewportP*)(void*)GetMainViewport();
    16368:16121-block 2
call    0 returned 16368
    16368:16122:    if (!(g.ConfigFlagsCurrFrame & ImGuiConfigFlags_ViewportsEnable))
branch  0 taken 16368 (fallthrough)
branch  1 taken 0
        -:16123:    {
    16368:16124:        SetWindowViewport(window, main_viewport);
    16368:16124-block 4
call    0 returned 16368
    16368:16125:        return;
        -:16126:    }
    #####:16127:    window->ViewportOwned = false;
        -:16128:
        -:16129:    // Appearing popups reset their viewport so they can inherit again
    #####:16130:    if ((flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) && window->Appearing)
    %%%%%:16130-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16130-block 7
branch  2 never executed (fallthrough)
branch  3 never executed
        -:16131:    {
    #####:16132:        window->Viewport = NULL;
    #####:16133:        window->ViewportId = 0;
    %%%%%:16133-block 8
        -:16134:    }
        -:16135:
    #####:16136:    if ((g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasViewport) == 0)
    %%%%%:16136-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
        -:16137:    {
        -:16138:        // By default inherit from parent window
    #####:16139:        if (window->Viewport == NULL && window->ParentWindow && (!window->ParentWindow->IsFallbackWindow || window->ParentWindow->WasActive))
    %%%%%:16139-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16139-block 11
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:16139-block 12
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:16139-block 13
branch  6 never executed (fallthrough)
branch  7 never executed
    #####:16140:            window->Viewport = window->ParentWindow->Viewport;
    %%%%%:16140-block 14
        -:16141:
        -:16142:        // Attempt to restore saved viewport id (= window that hasn't been activated yet), try to restore the viewport based on saved 'window->ViewportPos' restored from .ini file
    #####:16143:        if (window->Viewport == NULL && window->ViewportId != 0)
    %%%%%:16143-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16143-block 16
branch  2 never executed (fallthrough)
branch  3 never executed
        -:16144:        {
    #####:16145:            window->Viewport = (ImGuiViewportP*)FindViewportByID(window->ViewportId);
    %%%%%:16145-block 17
call    0 never executed
    #####:16146:            if (window->Viewport == NULL && window->ViewportPos.x != FLT_MAX && window->ViewportPos.y != FLT_MAX)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16146-block 19
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:16146-block 20
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:16147:                window->Viewport = AddUpdateViewport(window, window->ID, window->ViewportPos, window->Size, ImGuiViewportFlags_None);
    %%%%%:16147-block 21
call    0 never executed
        -:16148:        }
        -:16149:    }
        -:16150:
    #####:16151:    bool lock_viewport = false;
    #####:16152:    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasViewport)
    %%%%%:16152-block 23
branch  0 never executed (fallthrough)
branch  1 never executed
        -:16153:    {
        -:16154:        // Code explicitly request a viewport
    #####:16155:        window->Viewport = (ImGuiViewportP*)FindViewportByID(g.NextWindowData.ViewportId);
    %%%%%:16155-block 24
call    0 never executed
    #####:16156:        window->ViewportId = g.NextWindowData.ViewportId; // Store ID even if Viewport isn't resolved yet.
    #####:16157:        if (window->Viewport && (window->Flags & ImGuiWindowFlags_DockNodeHost) != 0 && window->Viewport->Window != NULL)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16157-block 26
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:16157-block 27
branch  4 never executed (fallthrough)
branch  5 never executed
        -:16158:        {
    #####:16159:            window->Viewport->Window = window;
    #####:16160:            window->Viewport->ID = window->ViewportId = window->ID; // Overwrite ID (always owned by node)
    %%%%%:16160-block 28
        -:16161:        }
    #####:16162:        lock_viewport = true;
    %%%%%:16162-block 29
        -:16163:    }
    #####:16164:    else if ((flags & ImGuiWindowFlags_ChildWindow) || (flags & ImGuiWindowFlags_ChildMenu))
    %%%%%:16164-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16164-block 31
branch  2 never executed (fallthrough)
branch  3 never executed
        -:16165:    {
        -:16166:        // Always inherit viewport from parent window
    #####:16167:        if (window->DockNode && window->DockNode->HostWindow)
    %%%%%:16167-block 32
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16167-block 33
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:16168:            IM_ASSERT(window->DockNode->HostWindow->Viewport == window->ParentWindow->Viewport);
    %%%%%:16168-block 34
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16168-block 35
call    2 never executed
    #####:16169:        window->Viewport = window->ParentWindow->Viewport;
    %%%%%:16169-block 36
        -:16170:    }
    #####:16171:    else if (window->DockNode && window->DockNode->HostWindow)
    %%%%%:16171-block 37
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16171-block 38
branch  2 never executed (fallthrough)
branch  3 never executed
        -:16172:    {
        -:16173:        // This covers the "always inherit viewport from parent window" case for when a window reattach to a node that was just created mid-frame
    #####:16174:        window->Viewport = window->DockNode->HostWindow->Viewport;
    %%%%%:16174-block 39
        -:16175:    }
    #####:16176:    else if (flags & ImGuiWindowFlags_Tooltip)
    %%%%%:16176-block 40
branch  0 never executed (fallthrough)
branch  1 never executed
        -:16177:    {
    #####:16178:        window->Viewport = g.MouseViewport;
    %%%%%:16178-block 41
        -:16179:    }
    #####:16180:    else if (GetWindowAlwaysWantOwnViewport(window))
    %%%%%:16180-block 42
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -:16181:    {
    #####:16182:        window->Viewport = AddUpdateViewport(window, window->ID, window->Pos, window->Size, ImGuiViewportFlags_None);
    %%%%%:16182-block 44
call    0 never executed
        -:16183:    }
    #####:16184:    else if (g.MovingWindow && g.MovingWindow->RootWindowDockTree == window && IsMousePosValid())
    %%%%%:16184-block 46
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16184-block 47
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:16184-block 48
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:16184-block 50
    %%%%%:16184-block 51
    %%%%%:16184-block 52
branch  7 never executed (fallthrough)
branch  8 never executed
        -:16185:    {
    #####:16186:        if (window->Viewport != NULL && window->Viewport->Window == window)
    %%%%%:16186-block 53
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16186-block 54
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:16187:            window->Viewport = AddUpdateViewport(window, window->ID, window->Pos, window->Size, ImGuiViewportFlags_None);
    %%%%%:16187-block 55
call    0 never executed
        -:16188:    }
        -:16189:    else
        -:16190:    {
        -:16191:        // Merge into host viewport?
        -:16192:        // We cannot test window->ViewportOwned as it set lower in the function.
        -:16193:        // Testing (g.ActiveId == 0 || g.ActiveIdAllowOverlap) to avoid merging during a short-term widget interaction. Main intent was to avoid during resize (see #4212)
    #####:16194:        bool try_to_merge_into_host_viewport = (window->Viewport && window == window->Viewport->Window && (g.ActiveId == 0 || g.ActiveIdAllowOverlap));
    %%%%%:16194-block 57
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16194-block 58
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:16194-block 59
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:16194-block 60
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%:16194-block 61
    %%%%%:16194-block 62
    #####:16195:        if (try_to_merge_into_host_viewport)
    %%%%%:16195-block 63
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:16196:            UpdateTryMergeWindowIntoHostViewports(window);
    %%%%%:16196-block 64
call    0 never executed
        -:16197:    }
        -:16198:
        -:16199:    // Fallback: merge in default viewport if z-order matches, otherwise create a new viewport
    #####:16200:    if (window->Viewport == NULL)
    %%%%%:16200-block 65
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:16201:        if (!UpdateTryMergeWindowIntoHostViewport(window, main_viewport))
    %%%%%:16201-block 66
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:16202:            window->Viewport = AddUpdateViewport(window, window->ID, window->Pos, window->Size, ImGuiViewportFlags_None);
    %%%%%:16202-block 68
call    0 never executed
        -:16203:
        -:16204:    // Mark window as allowed to protrude outside of its viewport and into the current monitor
    #####:16205:    if (!lock_viewport)
    %%%%%:16205-block 70
branch  0 never executed (fallthrough)
branch  1 never executed
        -:16206:    {
    #####:16207:        if (flags & (ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_Popup))
    %%%%%:16207-block 71
branch  0 never executed (fallthrough)
branch  1 never executed
        -:16208:        {
        -:16209:            // We need to take account of the possibility that mouse may become invalid.
        -:16210:            // Popups/Tooltip always set ViewportAllowPlatformMonitorExtend so GetWindowAllowedExtentRect() will return full monitor bounds.
    #####:16211:            ImVec2 mouse_ref = (flags & ImGuiWindowFlags_Tooltip) ? g.IO.MousePos : g.BeginPopupStack.back().OpenMousePos;
    %%%%%:16211-block 72
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16211-block 73
    %%%%%:16211-block 74
call    2 never executed
    #####:16212:            bool use_mouse_ref = (!g.NavCursorVisible || !g.NavHighlightItemUnderNav || !g.NavWindow);
    %%%%%:16212-block 76
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16212-block 77
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:16212-block 78
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:16212-block 79
    %%%%%:16212-block 80
    #####:16213:            bool mouse_valid = IsMousePosValid(&mouse_ref);
    %%%%%:16213-block 81
call    0 never executed
    #####:16214:            if ((window->Appearing || (flags & (ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_ChildMenu))) && (!use_mouse_ref || mouse_valid))
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16214-block 83
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:16214-block 84
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:16214-block 85
branch  6 never executed (fallthrough)
branch  7 never executed
    #####:16215:                window->ViewportAllowPlatformMonitorExtend = FindPlatformMonitorForPos((use_mouse_ref && mouse_valid) ? mouse_ref : NavCalcPreferredRefPos());
    %%%%%:16215-block 86
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16215-block 87
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:16215-block 88
    %%%%%:16215-block 89
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    %%%%%:16215-block 90
call    7 never executed
branch  8 never executed (fallthrough)
branch  9 never executed (throw)
    %%%%%:16215-block 91
    $$$$$:16215-block 120
        -:16216:            else
    #####:16217:                window->ViewportAllowPlatformMonitorExtend = window->Viewport->PlatformMonitor;
    %%%%%:16217-block 92
        -:16218:        }
    #####:16219:        else if (window->Viewport && window != window->Viewport->Window && window->Viewport->Window && !(flags & ImGuiWindowFlags_ChildWindow) && window->DockNode == NULL)
    %%%%%:16219-block 94
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16219-block 95
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:16219-block 96
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:16219-block 97
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%:16219-block 98
branch  8 never executed (fallthrough)
branch  9 never executed
        -:16220:        {
        -:16221:            // When called from Begin() we don't have access to a proper version of the Hidden flag yet, so we replicate this code.
    #####:16222:            const bool will_be_visible = (window->DockIsActive && !window->DockTabIsVisible) ? false : true;
    %%%%%:16222-block 99
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16222-block 100
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:16222-block 101
    %%%%%:16222-block 102
    #####:16223:            if ((window->Flags & ImGuiWindowFlags_DockNodeHost) && window->Viewport->LastFrameActive < g.FrameCount && will_be_visible)
    %%%%%:16223-block 103
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16223-block 104
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:16223-block 105
branch  4 never executed (fallthrough)
branch  5 never executed
        -:16224:            {
        -:16225:                // Steal/transfer ownership
    #####:16226:                IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Window '%s' steal Viewport %08X from Window '%s'\n", window->Name, window->Viewport->ID, window->Viewport->Window->Name);
    %%%%%:16226-block 106
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16226-block 107
call    2 never executed
    #####:16227:                window->Viewport->Window = window;
    #####:16228:                window->Viewport->ID = window->ID;
    #####:16229:                window->Viewport->LastNameHash = 0;
    %%%%%:16229-block 108
        -:16230:            }
    #####:16231:            else if (!UpdateTryMergeWindowIntoHostViewports(window)) // Merge?
    %%%%%:16231-block 109
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -:16232:            {
        -:16233:                // New viewport
    #####:16234:                window->Viewport = AddUpdateViewport(window, window->ID, window->Pos, window->Size, ImGuiViewportFlags_NoFocusOnAppearing);
    %%%%%:16234-block 111
call    0 never executed
        -:16235:            }
    #####:16236:        }
    %%%%%:16236-block 113
    #####:16237:        else if (window->ViewportAllowPlatformMonitorExtend < 0 && (flags & ImGuiWindowFlags_ChildWindow) == 0)
    %%%%%:16237-block 114
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16237-block 115
branch  2 never executed (fallthrough)
branch  3 never executed
        -:16238:        {
        -:16239:            // Regular (non-child, non-popup) windows by default are also allowed to protrude
        -:16240:            // Child windows are kept contained within their parent.
    #####:16241:            window->ViewportAllowPlatformMonitorExtend = window->Viewport->PlatformMonitor;
    %%%%%:16241-block 116
        -:16242:        }
        -:16243:    }
        -:16244:
        -:16245:    // Update flags
    #####:16246:    window->ViewportOwned = (window == window->Viewport->Window);
    #####:16247:    window->ViewportId = window->Viewport->ID;
    %%%%%:16247-block 118
        -:16248:
        -:16249:    // If the OS window has a title bar, hide our imgui title bar
        -:16250:    //if (window->ViewportOwned && !(window->Viewport->Flags & ImGuiViewportFlags_NoDecoration))
        -:16251:    //    window->Flags |= ImGuiWindowFlags_NoTitleBar;
        -:16252:}
        -:16253:
function _ZN5ImGuiL23WindowSyncOwnedViewportEP11ImGuiWindowS1_ called 0 returned 0% blocks executed 0%
    #####:16254:void ImGui::WindowSyncOwnedViewport(ImGuiWindow* window, ImGuiWindow* parent_window_in_stack)
        -:16255:{
    #####:16256:    ImGuiContext& g = *GImGui;
        -:16257:
    #####:16258:    bool viewport_rect_changed = false;
        -:16259:
        -:16260:    // Synchronize window --> viewport in most situations
        -:16261:    // Synchronize viewport -> window in case the platform window has been moved or resized from the OS/WM
    #####:16262:    if (window->Viewport->PlatformRequestMove)
    %%%%%:16262-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -:16263:    {
    #####:16264:        window->Pos = window->Viewport->Pos;
    #####:16265:        MarkIniSettingsDirty(window);
    %%%%%:16265-block 3
call    0 never executed
        -:16266:    }
    #####:16267:    else if (memcmp(&window->Viewport->Pos, &window->Pos, sizeof(window->Pos)) != 0)
    %%%%%:16267-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
        -:16268:    {
    #####:16269:        viewport_rect_changed = true;
    #####:16270:        window->Viewport->Pos = window->Pos;
    %%%%%:16270-block 5
        -:16271:    }
        -:16272:
    #####:16273:    if (window->Viewport->PlatformRequestResize)
    %%%%%:16273-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
        -:16274:    {
    #####:16275:        window->Size = window->SizeFull = window->Viewport->Size;
    #####:16276:        MarkIniSettingsDirty(window);
    %%%%%:16276-block 7
call    0 never executed
        -:16277:    }
    #####:16278:    else if (memcmp(&window->Viewport->Size, &window->Size, sizeof(window->Size)) != 0)
    %%%%%:16278-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
        -:16279:    {
    #####:16280:        viewport_rect_changed = true;
    #####:16281:        window->Viewport->Size = window->Size;
    %%%%%:16281-block 9
        -:16282:    }
    #####:16283:    window->Viewport->UpdateWorkRect();
    %%%%%:16283-block 10
call    0 never executed
        -:16284:
        -:16285:    // The viewport may have changed monitor since the global update in UpdateViewportsNewFrame()
        -:16286:    // Either a SetNextWindowPos() call in the current frame or a SetWindowPos() call in the previous frame may have this effect.
    #####:16287:    if (viewport_rect_changed)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:16288:        UpdateViewportPlatformMonitor(window->Viewport);
    %%%%%:16288-block 12
call    0 never executed
        -:16289:
        -:16290:    // Update common viewport flags
    #####:16291:    const ImGuiViewportFlags viewport_flags_to_clear = ImGuiViewportFlags_TopMost | ImGuiViewportFlags_NoTaskBarIcon | ImGuiViewportFlags_NoDecoration | ImGuiViewportFlags_NoRendererClear;
    #####:16292:    ImGuiViewportFlags viewport_flags = window->Viewport->Flags & ~viewport_flags_to_clear;
    #####:16293:    ImGuiWindowFlags window_flags = window->Flags;
    #####:16294:    const bool is_modal = (window_flags & ImGuiWindowFlags_Modal) != 0;
    #####:16295:    const bool is_short_lived_floating_window = (window_flags & (ImGuiWindowFlags_ChildMenu | ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_Popup)) != 0;
    #####:16296:    if (window_flags & ImGuiWindowFlags_Tooltip)
    %%%%%:16296-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:16297:        viewport_flags |= ImGuiViewportFlags_TopMost;
    %%%%%:16297-block 14
    #####:16298:    if ((g.IO.ConfigViewportsNoTaskBarIcon || is_short_lived_floating_window) && !is_modal)
    %%%%%:16298-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16298-block 16
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:16298-block 17
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:16299:        viewport_flags |= ImGuiViewportFlags_NoTaskBarIcon;
    %%%%%:16299-block 18
    #####:16300:    if (g.IO.ConfigViewportsNoDecoration || is_short_lived_floating_window)
    %%%%%:16300-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16300-block 20
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:16301:        viewport_flags |= ImGuiViewportFlags_NoDecoration;
    %%%%%:16301-block 21
        -:16302:
        -:16303:    // Not correct to set modal as topmost because:
        -:16304:    // - Because other popups can be stacked above a modal (e.g. combo box in a modal)
        -:16305:    // - ImGuiViewportFlags_TopMost is currently handled different in backends: in Win32 it is "appear top most" whereas in GLFW and SDL it is "stay topmost"
        -:16306:    //if (flags & ImGuiWindowFlags_Modal)
        -:16307:    //    viewport_flags |= ImGuiViewportFlags_TopMost;
        -:16308:
        -:16309:    // For popups and menus that may be protruding out of their parent viewport, we enable _NoFocusOnClick so that clicking on them
        -:16310:    // won't steal the OS focus away from their parent window (which may be reflected in OS the title bar decoration).
        -:16311:    // Setting _NoFocusOnClick would technically prevent us from bringing back to front in case they are being covered by an OS window from a different app,
        -:16312:    // but it shouldn't be much of a problem considering those are already popups that are closed when clicking elsewhere.
    #####:16313:    if (is_short_lived_floating_window && !is_modal)
    %%%%%:16313-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16313-block 23
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:16314:        viewport_flags |= ImGuiViewportFlags_NoFocusOnAppearing | ImGuiViewportFlags_NoFocusOnClick;
    %%%%%:16314-block 24
        -:16315:
        -:16316:    // We can overwrite viewport flags using ImGuiWindowClass (advanced users)
    #####:16317:    if (window->WindowClass.ViewportFlagsOverrideSet)
    %%%%%:16317-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:16318:        viewport_flags |= window->WindowClass.ViewportFlagsOverrideSet;
    %%%%%:16318-block 26
    #####:16319:    if (window->WindowClass.ViewportFlagsOverrideClear)
    %%%%%:16319-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:16320:        viewport_flags &= ~window->WindowClass.ViewportFlagsOverrideClear;
    %%%%%:16320-block 28
        -:16321:
        -:16322:    // We can also tell the backend that clearing the platform window won't be necessary,
        -:16323:    // as our window background is filling the viewport and we have disabled BgAlpha.
        -:16324:    // FIXME: Work on support for per-viewport transparency (#2766)
    #####:16325:    if (!(window_flags & ImGuiWindowFlags_NoBackground))
    %%%%%:16325-block 29
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:16326:        viewport_flags |= ImGuiViewportFlags_NoRendererClear;
    %%%%%:16326-block 30
        -:16327:
    #####:16328:    window->Viewport->Flags = viewport_flags;
        -:16329:
        -:16330:    // Update parent viewport ID
        -:16331:    // (the !IsFallbackWindow test mimic the one done in WindowSelectViewport())
    #####:16332:    if (window->WindowClass.ParentViewportId != (ImGuiID)-1)
    %%%%%:16332-block 31
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:16333:        window->Viewport->ParentViewportId = window->WindowClass.ParentViewportId;
    %%%%%:16333-block 32
    #####:16334:    else if ((window_flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) && parent_window_in_stack && (!parent_window_in_stack->IsFallbackWindow || parent_window_in_stack->WasActive))
    %%%%%:16334-block 33
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16334-block 34
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:16334-block 35
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:16334-block 36
branch  6 never executed (fallthrough)
branch  7 never executed
    #####:16335:        window->Viewport->ParentViewportId = parent_window_in_stack->Viewport->ID;
    %%%%%:16335-block 37
        -:16336:    else
    #####:16337:        window->Viewport->ParentViewportId = g.IO.ConfigViewportsNoDefaultParent ? 0 : IMGUI_VIEWPORT_DEFAULT_ID;
    %%%%%:16337-block 38
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16337-block 39
    %%%%%:16337-block 40
    %%%%%:16337-block 41
    #####:16338:}
        -:16339:
        -:16340:// Called by user at the end of the main loop, after EndFrame()
        -:16341:// This will handle the creation/update of all OS windows via function defined in the ImGuiPlatformIO api.
function _ZN5ImGui21UpdatePlatformWindowsEv called 0 returned 0% blocks executed 0%
    #####:16342:void ImGui::UpdatePlatformWindows()
        -:16343:{
    #####:16344:    ImGuiContext& g = *GImGui;
    #####:16345:    IM_ASSERT(g.FrameCountEnded == g.FrameCount && "Forgot to call Render() or EndFrame() before UpdatePlatformWindows()?");
    %%%%%:16345-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16345-block 3
call    2 never executed
    #####:16346:    IM_ASSERT(g.FrameCountPlatformEnded < g.FrameCount);
    %%%%%:16346-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16346-block 5
call    2 never executed
    #####:16347:    g.FrameCountPlatformEnded = g.FrameCount;
    #####:16348:    if (!(g.ConfigFlagsCurrFrame & ImGuiConfigFlags_ViewportsEnable))
    %%%%%:16348-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:16349:        return;
    %%%%%:16349-block 7
        -:16350:
        -:16351:    // Create/resize/destroy platform windows to match each active viewport.
        -:16352:    // Skip the main viewport (index 0), which is always fully handled by the application!
    #####:16353:    for (int i = 1; i < g.Viewports.Size; i++)
    %%%%%:16353-block 8
    %%%%%:16353-block 64
    %%%%%:16353-block 65
branch  0 never executed
branch  1 never executed (fallthrough)
        -:16354:    {
    #####:16355:        ImGuiViewportP* viewport = g.Viewports[i];
    %%%%%:16355-block 9
call    0 never executed
        -:16356:
        -:16357:        // Destroy platform window if the viewport hasn't been submitted or if it is hosting a hidden window
        -:16358:        // (the implicit/fallback Debug##Default window will be registering its viewport then be disabled, causing a dummy DestroyPlatformWindow to be made each frame)
    #####:16359:        bool destroy_platform_window = false;
    #####:16360:        destroy_platform_window |= (viewport->LastFrameActive < g.FrameCount - 1);
    #####:16361:        destroy_platform_window |= (viewport->Window && !IsWindowActiveAndVisible(viewport->Window));
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16361-block 11
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:16361-block 13
    %%%%%:16361-block 14
    #####:16362:        if (destroy_platform_window)
    %%%%%:16362-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
        -:16363:        {
    #####:16364:            DestroyPlatformWindow(viewport);
    %%%%%:16364-block 16
call    0 never executed
    #####:16365:            continue;
        -:16366:        }
        -:16367:
        -:16368:        // New windows that appears directly in a new viewport won't always have a size on their first frame
    #####:16369:        if (viewport->LastFrameActive < g.FrameCount || viewport->Size.x <= 0 || viewport->Size.y <= 0)
    %%%%%:16369-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16369-block 19
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:16369-block 20
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:16370:            continue;
    %%%%%:16370-block 21
        -:16371:
        -:16372:        // Create window
    #####:16373:        const bool is_new_platform_window = (viewport->PlatformWindowCreated == false);
    #####:16374:        if (is_new_platform_window)
    %%%%%:16374-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
        -:16375:        {
    #####:16376:            IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Create Platform Window %08X '%s'\n", viewport->ID, viewport->Window ? viewport->Window->Name : "n/a");
    %%%%%:16376-block 23
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16376-block 24
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:16376-block 25
    %%%%%:16376-block 26
    %%%%%:16376-block 27
call    4 never executed
    #####:16377:            g.PlatformIO.Platform_CreateWindow(viewport);
    %%%%%:16377-block 28
call    0 never executed
    #####:16378:            if (g.PlatformIO.Renderer_CreateWindow != NULL)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:16379:                g.PlatformIO.Renderer_CreateWindow(viewport);
    %%%%%:16379-block 30
call    0 never executed
    #####:16380:            g.PlatformWindowsCreatedCount++;
    #####:16381:            viewport->LastNameHash = 0;
    #####:16382:            viewport->LastPlatformPos = viewport->LastPlatformSize = ImVec2(FLT_MAX, FLT_MAX); // By clearing those we'll enforce a call to Platform_SetWindowPos/Size below, before Platform_ShowWindow (FIXME: Is that necessary?)
    %%%%%:16382-block 31
call    0 never executed
    #####:16383:            viewport->LastRendererSize = viewport->Size;                                       // We don't need to call Renderer_SetWindowSize() as it is expected Renderer_CreateWindow() already did it.
    #####:16384:            viewport->PlatformWindowCreated = true;
        -:16385:        }
        -:16386:
        -:16387:        // Apply Position and Size (from ImGui to Platform/Renderer backends)
    #####:16388:        if ((viewport->LastPlatformPos.x != viewport->Pos.x || viewport->LastPlatformPos.y != viewport->Pos.y) && !viewport->PlatformRequestMove)
    %%%%%:16388-block 33
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16388-block 34
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:16388-block 35
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:16389:            g.PlatformIO.Platform_SetWindowPos(viewport, viewport->Pos);
    %%%%%:16389-block 36
call    0 never executed
    #####:16390:        if ((viewport->LastPlatformSize.x != viewport->Size.x || viewport->LastPlatformSize.y != viewport->Size.y) && !viewport->PlatformRequestResize)
    %%%%%:16390-block 37
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16390-block 38
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:16390-block 39
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:16391:            g.PlatformIO.Platform_SetWindowSize(viewport, viewport->Size);
    %%%%%:16391-block 40
call    0 never executed
    #####:16392:        if ((viewport->LastRendererSize.x != viewport->Size.x || viewport->LastRendererSize.y != viewport->Size.y) && g.PlatformIO.Renderer_SetWindowSize)
    %%%%%:16392-block 41
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16392-block 42
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:16392-block 43
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:16393:            g.PlatformIO.Renderer_SetWindowSize(viewport, viewport->Size);
    %%%%%:16393-block 44
call    0 never executed
    #####:16394:        viewport->LastPlatformPos = viewport->Pos;
    #####:16395:        viewport->LastPlatformSize = viewport->LastRendererSize = viewport->Size;
        -:16396:
        -:16397:        // Update title bar (if it changed)
    #####:16398:        if (ImGuiWindow* window_for_title = GetWindowForTitleDisplay(viewport->Window))
    %%%%%:16398-block 45
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -:16399:        {
    #####:16400:            const char* title_begin = window_for_title->Name;
    #####:16401:            char* title_end = (char*)(intptr_t)FindRenderedTextEnd(title_begin);
    %%%%%:16401-block 47
call    0 never executed
    #####:16402:            const ImGuiID title_hash = ImHashStr(title_begin, title_end - title_begin);
call    0 never executed
    #####:16403:            if (viewport->LastNameHash != title_hash)
branch  0 never executed (fallthrough)
branch  1 never executed
        -:16404:            {
    #####:16405:                char title_end_backup_c = *title_end;
    #####:16406:                *title_end = 0; // Cut existing buffer short instead of doing an alloc/free, no small gain.
    #####:16407:                g.PlatformIO.Platform_SetWindowTitle(viewport, title_begin);
    %%%%%:16407-block 50
call    0 never executed
    #####:16408:                *title_end = title_end_backup_c;
    #####:16409:                viewport->LastNameHash = title_hash;
        -:16410:            }
        -:16411:        }
        -:16412:
        -:16413:        // Update alpha (if it changed)
    #####:16414:        if (viewport->LastAlpha != viewport->Alpha && g.PlatformIO.Platform_SetWindowAlpha)
    %%%%%:16414-block 52
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16414-block 53
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:16415:            g.PlatformIO.Platform_SetWindowAlpha(viewport, viewport->Alpha);
    %%%%%:16415-block 54
call    0 never executed
    #####:16416:        viewport->LastAlpha = viewport->Alpha;
        -:16417:
        -:16418:        // Optional, general purpose call to allow the backend to perform general book-keeping even if things haven't changed.
    #####:16419:        if (g.PlatformIO.Platform_UpdateWindow)
    %%%%%:16419-block 55
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:16420:            g.PlatformIO.Platform_UpdateWindow(viewport);
    %%%%%:16420-block 56
call    0 never executed
        -:16421:
    #####:16422:        if (is_new_platform_window)
    %%%%%:16422-block 57
branch  0 never executed (fallthrough)
branch  1 never executed
        -:16423:        {
        -:16424:            // On startup ensure new platform window don't steal focus (give it a few frames, as nested contents may lead to viewport being created a few frames late)
    #####:16425:            if (g.FrameCount < 3)
    %%%%%:16425-block 58
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:16426:                viewport->Flags |= ImGuiViewportFlags_NoFocusOnAppearing;
    %%%%%:16426-block 59
        -:16427:
        -:16428:            // Show window
    #####:16429:            g.PlatformIO.Platform_ShowWindow(viewport);
    %%%%%:16429-block 60
call    0 never executed
        -:16430:
        -:16431:            // Even without focus, we assume the window becomes front-most.
        -:16432:            // This is useful for our platform z-order heuristic when io.MouseHoveredViewport is not available.
    #####:16433:            if (viewport->LastFocusedStampCount != g.ViewportFocusedStampCount)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:16434:                viewport->LastFocusedStampCount = ++g.ViewportFocusedStampCount;
    %%%%%:16434-block 62
        -:16435:        }
        -:16436:
        -:16437:        // Clear request flags
    #####:16438:        viewport->ClearRequestFlags();
    %%%%%:16438-block 63
call    0 never executed
        -:16439:    }
        -:16440:}
        -:16441:
        -:16442:// This is a default/basic function for performing the rendering/swap of multiple Platform Windows.
        -:16443:// Custom renderers may prefer to not call this function at all, and instead iterate the publicly exposed platform data and handle rendering/sync themselves.
        -:16444:// The Render/Swap functions stored in ImGuiPlatformIO are merely here to allow for this helper to exist, but you can do it yourself:
        -:16445://
        -:16446://    ImGuiPlatformIO& platform_io = ImGui::GetPlatformIO();
        -:16447://    for (int i = 1; i < platform_io.Viewports.Size; i++)
        -:16448://        if ((platform_io.Viewports[i]->Flags & ImGuiViewportFlags_Minimized) == 0)
        -:16449://            MyRenderFunction(platform_io.Viewports[i], my_args);
        -:16450://    for (int i = 1; i < platform_io.Viewports.Size; i++)
        -:16451://        if ((platform_io.Viewports[i]->Flags & ImGuiViewportFlags_Minimized) == 0)
        -:16452://            MySwapBufferFunction(platform_io.Viewports[i], my_args);
        -:16453://
function _ZN5ImGui28RenderPlatformWindowsDefaultEPvS0_ called 0 returned 0% blocks executed 0%
    #####:16454:void ImGui::RenderPlatformWindowsDefault(void* platform_render_arg, void* renderer_render_arg)
        -:16455:{
        -:16456:    // Skip the main viewport (index 0), which is always fully handled by the application!
    #####:16457:    ImGuiPlatformIO& platform_io = ImGui::GetPlatformIO();
    %%%%%:16457-block 2
call    0 never executed
    #####:16458:    for (int i = 1; i < platform_io.Viewports.Size; i++)
    %%%%%:16458-block 11
    %%%%%:16458-block 12
branch  0 never executed
branch  1 never executed (fallthrough)
        -:16459:    {
    #####:16460:        ImGuiViewport* viewport = platform_io.Viewports[i];
    %%%%%:16460-block 4
call    0 never executed
    #####:16461:        if (viewport->Flags & ImGuiViewportFlags_IsMinimized)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:16462:            continue;
    %%%%%:16462-block 6
    #####:16463:        if (platform_io.Platform_RenderWindow) platform_io.Platform_RenderWindow(viewport, platform_render_arg);
    %%%%%:16463-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16463-block 8
call    2 never executed
    #####:16464:        if (platform_io.Renderer_RenderWindow) platform_io.Renderer_RenderWindow(viewport, renderer_render_arg);
    %%%%%:16464-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16464-block 10
call    2 never executed
        -:16465:    }
    #####:16466:    for (int i = 1; i < platform_io.Viewports.Size; i++)
    %%%%%:16466-block 13
    %%%%%:16466-block 21
    %%%%%:16466-block 22
branch  0 never executed
branch  1 never executed (fallthrough)
        -:16467:    {
    #####:16468:        ImGuiViewport* viewport = platform_io.Viewports[i];
    %%%%%:16468-block 14
call    0 never executed
    #####:16469:        if (viewport->Flags & ImGuiViewportFlags_IsMinimized)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:16470:            continue;
    %%%%%:16470-block 16
    #####:16471:        if (platform_io.Platform_SwapBuffers) platform_io.Platform_SwapBuffers(viewport, platform_render_arg);
    %%%%%:16471-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16471-block 18
call    2 never executed
    #####:16472:        if (platform_io.Renderer_SwapBuffers) platform_io.Renderer_SwapBuffers(viewport, renderer_render_arg);
    %%%%%:16472-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16472-block 20
call    2 never executed
        -:16473:    }
    #####:16474:}
        -:16475:
function _ZN5ImGuiL25FindPlatformMonitorForPosERK6ImVec2 called 0 returned 0% blocks executed 0%
    #####:16476:static int ImGui::FindPlatformMonitorForPos(const ImVec2& pos)
        -:16477:{
    #####:16478:    ImGuiContext& g = *GImGui;
    #####:16479:    for (int monitor_n = 0; monitor_n < g.PlatformIO.Monitors.Size; monitor_n++)
    %%%%%:16479-block 2
    %%%%%:16479-block 9
    %%%%%:16479-block 10
branch  0 never executed
branch  1 never executed (fallthrough)
        -:16480:    {
    #####:16481:        const ImGuiPlatformMonitor& monitor = g.PlatformIO.Monitors[monitor_n];
    %%%%%:16481-block 3
call    0 never executed
    #####:16482:        if (ImRect(monitor.MainPos, monitor.MainPos + monitor.MainSize).Contains(pos))
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:16483:            return monitor_n;
    %%%%%:16483-block 8
        -:16484:    }
    #####:16485:    return -1;
    %%%%%:16485-block 11
        -:16486:}
        -:16487:
        -:16488:// Search for the monitor with the largest intersection area with the given rectangle
        -:16489:// We generally try to avoid searching loops but the monitor count should be very small here
        -:16490:// FIXME-OPT: We could test the last monitor used for that viewport first, and early
function _ZN5ImGuiL26FindPlatformMonitorForRectERK6ImRect called 1077 returned 100% blocks executed 13%
     1077:16491:static int ImGui::FindPlatformMonitorForRect(const ImRect& rect)
        -:16492:{
     1077:16493:    ImGuiContext& g = *GImGui;
        -:16494:
     1077:16495:    const int monitor_count = g.PlatformIO.Monitors.Size;
     1077:16496:    if (monitor_count <= 1)
     1077:16496-block 2
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:16497:        return monitor_count - 1;
     1077:16497-block 3
        -:16498:
        -:16499:    // Use a minimum threshold of 1.0f so a zero-sized rect won't false positive, and will still find the correct monitor given its position.
        -:16500:    // This is necessary for tooltips which always resize down to zero at first.
    #####:16501:    const float surface_threshold = ImMax(rect.GetWidth() * rect.GetHeight() * 0.5f, 1.0f);
    %%%%%:16501-block 4
call    0 never executed
call    1 never executed
call    2 never executed
    #####:16502:    int best_monitor_n = -1;
    #####:16503:    float best_monitor_surface = 0.001f;
        -:16504:
    #####:16505:    for (int monitor_n = 0; monitor_n < g.PlatformIO.Monitors.Size && best_monitor_surface < surface_threshold; monitor_n++)
    %%%%%:16505-block 20
    %%%%%:16505-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16505-block 22
branch  2 never executed
branch  3 never executed (fallthrough)
        -:16506:    {
    #####:16507:        const ImGuiPlatformMonitor& monitor = g.PlatformIO.Monitors[monitor_n];
    %%%%%:16507-block 8
call    0 never executed
    #####:16508:        const ImRect monitor_rect = ImRect(monitor.MainPos, monitor.MainPos + monitor.MainSize);
call    0 never executed
call    1 never executed
    #####:16509:        if (monitor_rect.Contains(rect))
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:16510:            return monitor_n;
    %%%%%:16510-block 13
    #####:16511:        ImRect overlapping_rect = rect;
    #####:16512:        overlapping_rect.ClipWithFull(monitor_rect);
    %%%%%:16512-block 14
call    0 never executed
    #####:16513:        float overlapping_surface = overlapping_rect.GetWidth() * overlapping_rect.GetHeight();
call    0 never executed
call    1 never executed
    #####:16514:        if (overlapping_surface < best_monitor_surface)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:16515:            continue;
    %%%%%:16515-block 18
    #####:16516:        best_monitor_surface = overlapping_surface;
    #####:16517:        best_monitor_n = monitor_n;
    %%%%%:16517-block 19
        -:16518:    }
    #####:16519:    return best_monitor_n;
    %%%%%:16519-block 23
        -:16520:}
        -:16521:
        -:16522:// Update monitor from viewport rectangle (we'll use this info to clamp windows and save windows lost in a removed monitor)
function _ZN5ImGuiL29UpdateViewportPlatformMonitorEP14ImGuiViewportP called 1077 returned 100% blocks executed 100%
     1077:16523:static void ImGui::UpdateViewportPlatformMonitor(ImGuiViewportP* viewport)
        -:16524:{
     1077:16525:    viewport->PlatformMonitor = (short)FindPlatformMonitorForRect(viewport->GetMainRect());
     1077:16525-block 2
call    0 returned 1077
call    1 returned 1077
branch  2 taken 1077 (fallthrough)
branch  3 taken 0 (throw)
     1077:16526:}
     1077:16526-block 4
        -:16527:
        -:16528:// Return value is always != NULL, but don't hold on it across frames.
function _ZN5ImGui26GetViewportPlatformMonitorEP13ImGuiViewport called 0 returned 0% blocks executed 0%
    #####:16529:const ImGuiPlatformMonitor* ImGui::GetViewportPlatformMonitor(ImGuiViewport* viewport_p)
        -:16530:{
    #####:16531:    ImGuiContext& g = *GImGui;
    #####:16532:    ImGuiViewportP* viewport = (ImGuiViewportP*)(void*)viewport_p;
    #####:16533:    int monitor_idx = viewport->PlatformMonitor;
    #####:16534:    if (monitor_idx >= 0 && monitor_idx < g.PlatformIO.Monitors.Size)
    %%%%%:16534-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16534-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:16535:        return &g.PlatformIO.Monitors[monitor_idx];
    %%%%%:16535-block 4
call    0 never executed
    #####:16536:    return &g.FallbackMonitor;
    %%%%%:16536-block 5
        -:16537:}
        -:16538:
function _ZN5ImGui21DestroyPlatformWindowEP14ImGuiViewportP called 3 returned 100% blocks executed 48%
        3:16539:void ImGui::DestroyPlatformWindow(ImGuiViewportP* viewport)
        -:16540:{
        3:16541:    ImGuiContext& g = *GImGui;
        3:16542:    if (viewport->PlatformWindowCreated)
        3:16542-block 2
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        -:16543:    {
       3*:16544:        IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Destroy Platform Window %08X '%s'\n", viewport->ID, viewport->Window ? viewport->Window->Name : "n/a");
        3:16544-block 3
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%:16544-block 4
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:16544-block 5
    %%%%%:16544-block 6
    %%%%%:16544-block 7
call    4 never executed
        3:16545:        if (g.PlatformIO.Renderer_DestroyWindow)
        3:16545-block 8
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:16546:            g.PlatformIO.Renderer_DestroyWindow(viewport);
    %%%%%:16546-block 9
call    0 never executed
        3:16547:        if (g.PlatformIO.Platform_DestroyWindow)
        3:16547-block 10
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3:16548:            g.PlatformIO.Platform_DestroyWindow(viewport);
        3:16548-block 11
call    0 returned 3
       3*:16549:        IM_ASSERT(viewport->RendererUserData == NULL && viewport->PlatformUserData == NULL);
        3:16549-block 12
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3:16549-block 13
branch  2 taken 3 (fallthrough)
branch  3 taken 0
        3:16549-block 14
    %%%%%:16549-block 15
call    4 never executed
        -:16550:
        -:16551:        // Don't clear PlatformWindowCreated for the main viewport, as we initially set that up to true in Initialize()
        -:16552:        // The righter way may be to leave it to the backend to set this flag all-together, and made the flag public.
        3:16553:        if (viewport->ID != IMGUI_VIEWPORT_DEFAULT_ID)
        3:16553-block 16
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:16554:            viewport->PlatformWindowCreated = false;
    %%%%%:16554-block 17
        -:16555:    }
        -:16556:    else
        -:16557:    {
    #####:16558:        IM_ASSERT(viewport->RendererUserData == NULL && viewport->PlatformUserData == NULL && viewport->PlatformHandle == NULL);
    %%%%%:16558-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16558-block 19
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:16558-block 20
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:16558-block 21
    %%%%%:16558-block 22
call    6 never executed
        -:16559:    }
        3:16560:    viewport->RendererUserData = viewport->PlatformUserData = viewport->PlatformHandle = NULL;
        3:16561:    viewport->ClearRequestFlags();
        3:16561-block 23
call    0 returned 3
        3:16562:}
        -:16563:
function _ZN5ImGui22DestroyPlatformWindowsEv called 3 returned 100% blocks executed 100%
        3:16564:void ImGui::DestroyPlatformWindows()
        -:16565:{
        -:16566:    // We call the destroy window on every viewport (including the main viewport, index 0) to give a chance to the backend
        -:16567:    // to clear any data they may have stored in e.g. PlatformUserData, RendererUserData.
        -:16568:    // It is convenient for the platform backend code to store something in the main viewport, in order for e.g. the mouse handling
        -:16569:    // code to operator a consistent manner.
        -:16570:    // It is expected that the backend can handle calls to Renderer_DestroyWindow/Platform_DestroyWindow without
        -:16571:    // crashing if it doesn't have data stored.
        3:16572:    ImGuiContext& g = *GImGui;
        6:16573:    for (ImGuiViewportP* viewport : g.Viewports)
        3:16573-block 2
call    0 returned 3
call    1 returned 3
        6:16573-block 6
branch  2 taken 3
branch  3 taken 3 (fallthrough)
        3:16574:        DestroyPlatformWindow(viewport);
        3:16574-block 4
call    0 returned 3
        3:16575:}
        -:16576:
        -:16577:
        -:16578://-----------------------------------------------------------------------------
        -:16579:// [SECTION] DOCKING
        -:16580://-----------------------------------------------------------------------------
        -:16581:// Docking: Internal Types
        -:16582:// Docking: Forward Declarations
        -:16583:// Docking: ImGuiDockContext
        -:16584:// Docking: ImGuiDockContext Docking/Undocking functions
        -:16585:// Docking: ImGuiDockNode
        -:16586:// Docking: ImGuiDockNode Tree manipulation functions
        -:16587:// Docking: Public Functions (SetWindowDock, DockSpace, DockSpaceOverViewport)
        -:16588:// Docking: Builder Functions
        -:16589:// Docking: Begin/End Support Functions (called from Begin/End)
        -:16590:// Docking: Settings
        -:16591://-----------------------------------------------------------------------------
        -:16592:
        -:16593://-----------------------------------------------------------------------------
        -:16594:// Typical Docking call flow: (root level is generally public API):
        -:16595://-----------------------------------------------------------------------------
        -:16596:// - NewFrame()                               new dear imgui frame
        -:16597://    | DockContextNewFrameUpdateUndocking()  - process queued undocking requests
        -:16598://    | - DockContextProcessUndockWindow()    - process one window undocking request
        -:16599://    | - DockContextProcessUndockNode()      - process one whole node undocking request
        -:16600://    | DockContextNewFrameUpdateUndocking()  - process queue docking requests, create floating dock nodes
        -:16601://    | - update g.HoveredDockNode            - [debug] update node hovered by mouse
        -:16602://    | - DockContextProcessDock()            - process one docking request
        -:16603://    | - DockNodeUpdate()
        -:16604://    |   - DockNodeUpdateForRootNode()
        -:16605://    |     - DockNodeUpdateFlagsAndCollapse()
        -:16606://    |     - DockNodeFindInfo()
        -:16607://    |   - destroy unused node or tab bar
        -:16608://    |   - create dock node host window
        -:16609://    |      - Begin() etc.
        -:16610://    |   - DockNodeStartMouseMovingWindow()
        -:16611://    |   - DockNodeTreeUpdatePosSize()
        -:16612://    |   - DockNodeTreeUpdateSplitter()
        -:16613://    |   - draw node background
        -:16614://    |   - DockNodeUpdateTabBar()            - create/update tab bar for a docking node
        -:16615://    |     - DockNodeAddTabBar()
        -:16616://    |     - DockNodeWindowMenuUpdate()
        -:16617://    |     - DockNodeCalcTabBarLayout()
        -:16618://    |     - BeginTabBarEx()
        -:16619://    |     - TabItemEx() calls
        -:16620://    |     - EndTabBar()
        -:16621://    |   - BeginDockableDragDropTarget()
        -:16622://    |      - DockNodeUpdate()               - recurse into child nodes...
        -:16623://-----------------------------------------------------------------------------
        -:16624:// - DockSpace()                              user submit a dockspace into a window
        -:16625://    | Begin(Child)                          - create a child window
        -:16626://    | DockNodeUpdate()                      - call main dock node update function
        -:16627://    | End(Child)
        -:16628://    | ItemSize()
        -:16629://-----------------------------------------------------------------------------
        -:16630:// - Begin()
        -:16631://    | BeginDocked()
        -:16632://    | BeginDockableDragDropSource()
        -:16633://    | BeginDockableDragDropTarget()
        -:16634://    | - DockNodePreviewDockRender()
        -:16635://-----------------------------------------------------------------------------
        -:16636:// - EndFrame()
        -:16637://    | DockContextEndFrame()
        -:16638://-----------------------------------------------------------------------------
        -:16639:
        -:16640://-----------------------------------------------------------------------------
        -:16641:// Docking: Internal Types
        -:16642://-----------------------------------------------------------------------------
        -:16643:// - ImGuiDockRequestType
        -:16644:// - ImGuiDockRequest
        -:16645:// - ImGuiDockPreviewData
        -:16646:// - ImGuiDockNodeSettings
        -:16647:// - ImGuiDockContext
        -:16648://-----------------------------------------------------------------------------
        -:16649:
        -:16650:enum ImGuiDockRequestType
        -:16651:{
        -:16652:    ImGuiDockRequestType_None = 0,
        -:16653:    ImGuiDockRequestType_Dock,
        -:16654:    ImGuiDockRequestType_Undock,
        -:16655:    ImGuiDockRequestType_Split                  // Split is the same as Dock but without a DockPayload
        -:16656:};
        -:16657:
        -:16658:struct ImGuiDockRequest
        -:16659:{
        -:16660:    ImGuiDockRequestType    Type;
        -:16661:    ImGuiWindow*            DockTargetWindow;   // Destination/Target Window to dock into (may be a loose window or a DockNode, might be NULL in which case DockTargetNode cannot be NULL)
        -:16662:    ImGuiDockNode*          DockTargetNode;     // Destination/Target Node to dock into
        -:16663:    ImGuiWindow*            DockPayload;        // Source/Payload window to dock (may be a loose window or a DockNode), [Optional]
        -:16664:    ImGuiDir                DockSplitDir;
        -:16665:    float                   DockSplitRatio;
        -:16666:    bool                    DockSplitOuter;
        -:16667:    ImGuiWindow*            UndockTargetWindow;
        -:16668:    ImGuiDockNode*          UndockTargetNode;
        -:16669:
function _ZN16ImGuiDockRequestC2Ev called 0 returned 0% blocks executed 0%
    #####:16670:    ImGuiDockRequest()
    #####:16671:    {
    #####:16672:        Type = ImGuiDockRequestType_None;
    #####:16673:        DockTargetWindow = DockPayload = UndockTargetWindow = NULL;
    #####:16674:        DockTargetNode = UndockTargetNode = NULL;
    #####:16675:        DockSplitDir = ImGuiDir_None;
    #####:16676:        DockSplitRatio = 0.5f;
    #####:16677:        DockSplitOuter = false;
    #####:16678:    }
        -:16679:};
        -:16680:
        -:16681:struct ImGuiDockPreviewData
        -:16682:{
        -:16683:    ImGuiDockNode   FutureNode;
        -:16684:    bool            IsDropAllowed;
        -:16685:    bool            IsCenterAvailable;
        -:16686:    bool            IsSidesAvailable;           // Hold your breath, grammar freaks..
        -:16687:    bool            IsSplitDirExplicit;         // Set when hovered the drop rect (vs. implicit SplitDir==None when hovered the window)
        -:16688:    ImGuiDockNode*  SplitNode;
        -:16689:    ImGuiDir        SplitDir;
        -:16690:    float           SplitRatio;
        -:16691:    ImRect          DropRectsDraw[ImGuiDir_COUNT + 1];  // May be slightly different from hit-testing drop rects used in DockNodeCalcDropRects()
        -:16692:
function _ZN20ImGuiDockPreviewDataC2Ev called 0 returned 0% blocks executed 0%
    #####:16693:    ImGuiDockPreviewData() : FutureNode(0) { IsDropAllowed = IsCenterAvailable = IsSidesAvailable = IsSplitDirExplicit = false; SplitNode = NULL; SplitDir = ImGuiDir_None; SplitRatio = 0.f; for (int n = 0; n < IM_ARRAYSIZE(DropRectsDraw); n++) DropRectsDraw[n] = ImRect(+FLT_MAX, +FLT_MAX, -FLT_MAX, -FLT_MAX); }
    %%%%%:16693-block 2
call    0 never executed
    %%%%%:16693-block 4
call    1 never executed
    %%%%%:16693-block 6
branch  2 never executed
branch  3 never executed (fallthrough)
        -:16694:};
        -:16695:
        -:16696:// Persistent Settings data, stored contiguously in SettingsNodes (sizeof() ~32 bytes)
        -:16697:struct ImGuiDockNodeSettings
        -:16698:{
        -:16699:    ImGuiID             ID;
        -:16700:    ImGuiID             ParentNodeId;
        -:16701:    ImGuiID             ParentWindowId;
        -:16702:    ImGuiID             SelectedTabId;
        -:16703:    signed char         SplitAxis;
        -:16704:    char                Depth;
        -:16705:    ImGuiDockNodeFlags  Flags;                  // NB: We save individual flags one by one in ascii format (ImGuiDockNodeFlags_SavedFlagsMask_)
        -:16706:    ImVec2ih            Pos;
        -:16707:    ImVec2ih            Size;
        -:16708:    ImVec2ih            SizeRef;
function _ZN21ImGuiDockNodeSettingsC2Ev called 28 returned 100% blocks executed 100%
       28:16709:    ImGuiDockNodeSettings() { memset(this, 0, sizeof(*this)); SplitAxis = ImGuiAxis_None; }
       28:16709-block 2
call    0 returned 28
call    1 returned 28
call    2 returned 28
        -:16710:};
        -:16711:
        -:16712://-----------------------------------------------------------------------------
        -:16713:// Docking: Forward Declarations
        -:16714://-----------------------------------------------------------------------------
        -:16715:
        -:16716:namespace ImGui
        -:16717:{
        -:16718:    // ImGuiDockContext
        -:16719:    static ImGuiDockNode*   DockContextAddNode(ImGuiContext* ctx, ImGuiID id);
        -:16720:    static void             DockContextRemoveNode(ImGuiContext* ctx, ImGuiDockNode* node, bool merge_sibling_into_parent_node);
        -:16721:    static void             DockContextQueueNotifyRemovedNode(ImGuiContext* ctx, ImGuiDockNode* node);
        -:16722:    static void             DockContextProcessDock(ImGuiContext* ctx, ImGuiDockRequest* req);
        -:16723:    static void             DockContextPruneUnusedSettingsNodes(ImGuiContext* ctx);
        -:16724:    static ImGuiDockNode*   DockContextBindNodeToWindow(ImGuiContext* ctx, ImGuiWindow* window);
        -:16725:    static void             DockContextBuildNodesFromSettings(ImGuiContext* ctx, ImGuiDockNodeSettings* node_settings_array, int node_settings_count);
        -:16726:    static void             DockContextBuildAddWindowsToNodes(ImGuiContext* ctx, ImGuiID root_id);                            // Use root_id==0 to add all
        -:16727:
        -:16728:    // ImGuiDockNode
        -:16729:    static void             DockNodeAddWindow(ImGuiDockNode* node, ImGuiWindow* window, bool add_to_tab_bar);
        -:16730:    static void             DockNodeMoveWindows(ImGuiDockNode* dst_node, ImGuiDockNode* src_node);
        -:16731:    static void             DockNodeMoveChildNodes(ImGuiDockNode* dst_node, ImGuiDockNode* src_node);
        -:16732:    static ImGuiWindow*     DockNodeFindWindowByID(ImGuiDockNode* node, ImGuiID id);
        -:16733:    static void             DockNodeApplyPosSizeToWindows(ImGuiDockNode* node);
        -:16734:    static void             DockNodeRemoveWindow(ImGuiDockNode* node, ImGuiWindow* window, ImGuiID save_dock_id);
        -:16735:    static void             DockNodeHideHostWindow(ImGuiDockNode* node);
        -:16736:    static void             DockNodeUpdate(ImGuiDockNode* node);
        -:16737:    static void             DockNodeUpdateForRootNode(ImGuiDockNode* node);
        -:16738:    static void             DockNodeUpdateFlagsAndCollapse(ImGuiDockNode* node);
        -:16739:    static void             DockNodeUpdateHasCentralNodeChild(ImGuiDockNode* node);
        -:16740:    static void             DockNodeUpdateTabBar(ImGuiDockNode* node, ImGuiWindow* host_window);
        -:16741:    static void             DockNodeAddTabBar(ImGuiDockNode* node);
        -:16742:    static void             DockNodeRemoveTabBar(ImGuiDockNode* node);
        -:16743:    static void             DockNodeWindowMenuUpdate(ImGuiDockNode* node, ImGuiTabBar* tab_bar);
        -:16744:    static void             DockNodeUpdateVisibleFlag(ImGuiDockNode* node);
        -:16745:    static void             DockNodeStartMouseMovingWindow(ImGuiDockNode* node, ImGuiWindow* window);
        -:16746:    static bool             DockNodeIsDropAllowed(ImGuiWindow* host_window, ImGuiWindow* payload_window);
        -:16747:    static void             DockNodePreviewDockSetup(ImGuiWindow* host_window, ImGuiDockNode* host_node, ImGuiWindow* payload_window, ImGuiDockNode* payload_node, ImGuiDockPreviewData* preview_data, bool is_explicit_target, bool is_outer_docking);
        -:16748:    static void             DockNodePreviewDockRender(ImGuiWindow* host_window, ImGuiDockNode* host_node, ImGuiWindow* payload_window, const ImGuiDockPreviewData* preview_data);
        -:16749:    static void             DockNodeCalcTabBarLayout(const ImGuiDockNode* node, ImRect* out_title_rect, ImRect* out_tab_bar_rect, ImVec2* out_window_menu_button_pos, ImVec2* out_close_button_pos);
        -:16750:    static void             DockNodeCalcSplitRects(ImVec2& pos_old, ImVec2& size_old, ImVec2& pos_new, ImVec2& size_new, ImGuiDir dir, ImVec2 size_new_desired);
        -:16751:    static bool             DockNodeCalcDropRectsAndTestMousePos(const ImRect& parent, ImGuiDir dir, ImRect& out_draw, bool outer_docking, ImVec2* test_mouse_pos);
function _ZN5ImGuiL26DockNodeGetHostWindowTitleEP13ImGuiDockNodePci called 9 returned 100% blocks executed 100%
        9:16752:    static const char*      DockNodeGetHostWindowTitle(ImGuiDockNode* node, char* buf, int buf_size) { ImFormatString(buf, buf_size, "##DockNode_%02X", node->ID); return buf; }
        9:16752-block 2
call    0 returned 9
        -:16753:    static int              DockNodeGetTabOrder(ImGuiWindow* window);
        -:16754:
        -:16755:    // ImGuiDockNode tree manipulations
        -:16756:    static void             DockNodeTreeSplit(ImGuiContext* ctx, ImGuiDockNode* parent_node, ImGuiAxis split_axis, int split_first_child, float split_ratio, ImGuiDockNode* new_node);
        -:16757:    static void             DockNodeTreeMerge(ImGuiContext* ctx, ImGuiDockNode* parent_node, ImGuiDockNode* merge_lead_child);
        -:16758:    static void             DockNodeTreeUpdatePosSize(ImGuiDockNode* node, ImVec2 pos, ImVec2 size, ImGuiDockNode* only_write_to_single_node = NULL);
        -:16759:    static void             DockNodeTreeUpdateSplitter(ImGuiDockNode* node);
        -:16760:    static ImGuiDockNode*   DockNodeTreeFindVisibleNodeByPos(ImGuiDockNode* node, ImVec2 pos);
        -:16761:    static ImGuiDockNode*   DockNodeTreeFindFallbackLeafNode(ImGuiDockNode* node);
        -:16762:
        -:16763:    // Settings
        -:16764:    static void             DockSettingsRenameNodeReferences(ImGuiID old_node_id, ImGuiID new_node_id);
        -:16765:    static void             DockSettingsRemoveNodeReferences(ImGuiID* node_ids, int node_ids_count);
        -:16766:    static ImGuiDockNodeSettings*   DockSettingsFindNodeSettings(ImGuiContext* ctx, ImGuiID node_id);
        -:16767:    static void             DockSettingsHandler_ClearAll(ImGuiContext*, ImGuiSettingsHandler*);
        -:16768:    static void             DockSettingsHandler_ApplyAll(ImGuiContext*, ImGuiSettingsHandler*);
        -:16769:    static void*            DockSettingsHandler_ReadOpen(ImGuiContext*, ImGuiSettingsHandler*, const char* name);
        -:16770:    static void             DockSettingsHandler_ReadLine(ImGuiContext*, ImGuiSettingsHandler*, void* entry, const char* line);
        -:16771:    static void             DockSettingsHandler_WriteAll(ImGuiContext* imgui_ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* buf);
        -:16772:}
        -:16773:
        -:16774://-----------------------------------------------------------------------------
        -:16775:// Docking: ImGuiDockContext
        -:16776://-----------------------------------------------------------------------------
        -:16777:// The lifetime model is different from the one of regular windows: we always create a ImGuiDockNode for each ImGuiDockNodeSettings,
        -:16778:// or we always hold the entire docking node tree. Nodes are frequently hidden, e.g. if the window(s) or child nodes they host are not active.
        -:16779:// At boot time only, we run a simple GC to remove nodes that have no references.
        -:16780:// Because dock node settings (which are small, contiguous structures) are always mirrored by their corresponding dock nodes (more complete structures),
        -:16781:// we can also very easily recreate the nodes from scratch given the settings data (this is what DockContextRebuild() does).
        -:16782:// This is convenient as docking reconfiguration can be implemented by mostly poking at the simpler settings data.
        -:16783://-----------------------------------------------------------------------------
        -:16784:// - DockContextInitialize()
        -:16785:// - DockContextShutdown()
        -:16786:// - DockContextClearNodes()
        -:16787:// - DockContextRebuildNodes()
        -:16788:// - DockContextNewFrameUpdateUndocking()
        -:16789:// - DockContextNewFrameUpdateDocking()
        -:16790:// - DockContextEndFrame()
        -:16791:// - DockContextFindNodeByID()
        -:16792:// - DockContextBindNodeToWindow()
        -:16793:// - DockContextGenNodeID()
        -:16794:// - DockContextAddNode()
        -:16795:// - DockContextRemoveNode()
        -:16796:// - ImGuiDockContextPruneNodeData
        -:16797:// - DockContextPruneUnusedSettingsNodes()
        -:16798:// - DockContextBuildNodesFromSettings()
        -:16799:// - DockContextBuildAddWindowsToNodes()
        -:16800://-----------------------------------------------------------------------------
        -:16801:
function _ZN5ImGui21DockContextInitializeEP12ImGuiContext called 1 returned 100% blocks executed 100%
        1:16802:void ImGui::DockContextInitialize(ImGuiContext* ctx)
        -:16803:{
        1:16804:    ImGuiContext& g = *ctx;
        -:16805:
        -:16806:    // Add .ini handle for persistent docking data
        1:16807:    ImGuiSettingsHandler ini_handler;
        1:16807-block 2
call    0 returned 1
        1:16808:    ini_handler.TypeName = "Docking";
        1:16809:    ini_handler.TypeHash = ImHashStr("Docking");
call    0 returned 1
        1:16810:    ini_handler.ClearAllFn = DockSettingsHandler_ClearAll;
        1:16811:    ini_handler.ReadInitFn = DockSettingsHandler_ClearAll; // Also clear on read
        1:16812:    ini_handler.ReadOpenFn = DockSettingsHandler_ReadOpen;
        1:16813:    ini_handler.ReadLineFn = DockSettingsHandler_ReadLine;
        1:16814:    ini_handler.ApplyAllFn = DockSettingsHandler_ApplyAll;
        1:16815:    ini_handler.WriteAllFn = DockSettingsHandler_WriteAll;
        1:16816:    g.SettingsHandlers.push_back(ini_handler);
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:16817:
        1:16818:    g.DockNodeWindowMenuHandler = &DockNodeWindowMenuHandler_Default;
        1:16819:}
        1:16819-block 5
        -:16820:
function _ZN5ImGui19DockContextShutdownEP12ImGuiContext called 1 returned 100% blocks executed 100%
        1:16821:void ImGui::DockContextShutdown(ImGuiContext* ctx)
        -:16822:{
        1:16823:    ImGuiDockContext* dc = &ctx->DockContext;
       10:16824:    for (int n = 0; n < dc->Nodes.Data.Size; n++)
        1:16824-block 2
        9:16824-block 6
       10:16824-block 7
branch  0 taken 9
branch  1 taken 1 (fallthrough)
        9:16825:        if (ImGuiDockNode* node = (ImGuiDockNode*)dc->Nodes.Data[n].val_p)
        9:16825-block 3
call    0 returned 9
branch  1 taken 9 (fallthrough)
branch  2 taken 0
        9:16826:            IM_DELETE(node);
        9:16826-block 5
call    0 returned 9
        1:16827:}
        -:16828:
function _ZN5ImGui21DockContextClearNodesEP12ImGuiContextjb called 1 returned 100% blocks executed 80%
        1:16829:void ImGui::DockContextClearNodes(ImGuiContext* ctx, ImGuiID root_id, bool clear_settings_refs)
        -:16830:{
        -:16831:    IM_UNUSED(ctx);
       1*:16832:    IM_ASSERT(ctx == GImGui);
        1:16832-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%:16832-block 3
call    2 never executed
        1:16833:    DockBuilderRemoveNodeDockedWindows(root_id, clear_settings_refs);
        1:16833-block 4
call    0 returned 1
        1:16834:    DockBuilderRemoveNodeChildNodes(root_id);
call    0 returned 1
        1:16835:}
        -:16836:
        -:16837:// [DEBUG] This function also acts as a defacto test to make sure we can rebuild from scratch without a glitch
        -:16838:// (Different from DockSettingsHandler_ClearAll() + DockSettingsHandler_ApplyAll() because this reuses current settings!)
function _ZN5ImGui23DockContextRebuildNodesEP12ImGuiContext called 0 returned 0% blocks executed 0%
    #####:16839:void ImGui::DockContextRebuildNodes(ImGuiContext* ctx)
        -:16840:{
    #####:16841:    ImGuiContext& g = *ctx;
    #####:16842:    ImGuiDockContext* dc = &ctx->DockContext;
    #####:16843:    IMGUI_DEBUG_LOG_DOCKING("[docking] DockContextRebuildNodes\n");
    %%%%%:16843-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16843-block 3
call    2 never executed
    #####:16844:    SaveIniSettingsToMemory();
    %%%%%:16844-block 4
call    0 never executed
    #####:16845:    ImGuiID root_id = 0; // Rebuild all
    #####:16846:    DockContextClearNodes(ctx, root_id, false);
call    0 never executed
    #####:16847:    DockContextBuildNodesFromSettings(ctx, dc->NodesSettings.Data, dc->NodesSettings.Size);
call    0 never executed
    #####:16848:    DockContextBuildAddWindowsToNodes(ctx, root_id);
call    0 never executed
    #####:16849:}
        -:16850:
        -:16851:// Docking context update function, called by NewFrame()
function _ZN5ImGui34DockContextNewFrameUpdateUndockingEP12ImGuiContext called 1077 returned 100% blocks executed 21%
     1077:16852:void ImGui::DockContextNewFrameUpdateUndocking(ImGuiContext* ctx)
        -:16853:{
     1077:16854:    ImGuiContext& g = *ctx;
     1077:16855:    ImGuiDockContext* dc = &ctx->DockContext;
     1077:16856:    if (!(g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable))
     1077:16856-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
        -:16857:    {
    #####:16858:        if (dc->Nodes.Data.Size > 0 || dc->Requests.Size > 0)
    %%%%%:16858-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16858-block 4
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:16859:            DockContextClearNodes(ctx, 0, true);
    %%%%%:16859-block 5
call    0 never executed
    #####:16860:        return;
    %%%%%:16860-block 6
        -:16861:    }
        -:16862:
        -:16863:    // Setting NoSplit at runtime merges all nodes
     1077:16864:    if (g.IO.ConfigDockingNoSplit)
     1077:16864-block 7
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####:16865:        for (int n = 0; n < dc->Nodes.Data.Size; n++)
    %%%%%:16865-block 8
    %%%%%:16865-block 19
    %%%%%:16865-block 20
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:16866:            if (ImGuiDockNode* node = (ImGuiDockNode*)dc->Nodes.Data[n].val_p)
    %%%%%:16866-block 9
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:16867:                if (node->IsRootNode() && node->IsSplitNode())
    %%%%%:16867-block 11
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:16867-block 13
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:16867-block 15
    %%%%%:16867-block 16
    %%%%%:16867-block 17
branch  6 never executed (fallthrough)
branch  7 never executed
        -:16868:                {
    #####:16869:                    DockBuilderRemoveNodeChildNodes(node->ID);
    %%%%%:16869-block 18
call    0 never executed
        -:16870:                    //dc->WantFullRebuild = true;
        -:16871:                }
        -:16872:
        -:16873:    // Process full rebuild
        -:16874:#if 0
        -:16875:    if (ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_C)))
        -:16876:        dc->WantFullRebuild = true;
        -:16877:#endif
     1077:16878:    if (dc->WantFullRebuild)
     1077:16878-block 21
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
        -:16879:    {
    #####:16880:        DockContextRebuildNodes(ctx);
    %%%%%:16880-block 22
call    0 never executed
    #####:16881:        dc->WantFullRebuild = false;
        -:16882:    }
        -:16883:
        -:16884:    // Process Undocking requests (we need to process them _before_ the UpdateMouseMovingWindowNewFrame call in NewFrame)
    1077*:16885:    for (ImGuiDockRequest& req : dc->Requests)
     1077:16885-block 24
call    0 returned 1077
call    1 returned 1077
    %%%%%:16885-block 32
     1077:16885-block 33
branch  2 taken 0
branch  3 taken 1077 (fallthrough)
        -:16886:    {
    #####:16887:        if (req.Type == ImGuiDockRequestType_Undock && req.UndockTargetWindow)
    %%%%%:16887-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16887-block 27
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:16888:            DockContextProcessUndockWindow(ctx, req.UndockTargetWindow);
    %%%%%:16888-block 28
call    0 never executed
    #####:16889:        else if (req.Type == ImGuiDockRequestType_Undock && req.UndockTargetNode)
    %%%%%:16889-block 29
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16889-block 30
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:16890:            DockContextProcessUndockNode(ctx, req.UndockTargetNode);
    %%%%%:16890-block 31
call    0 never executed
        -:16891:    }
        -:16892:}
        -:16893:
        -:16894:// Docking context update function, called by NewFrame()
function _ZN5ImGui32DockContextNewFrameUpdateDockingEP12ImGuiContext called 1077 returned 100% blocks executed 71%
     1077:16895:void ImGui::DockContextNewFrameUpdateDocking(ImGuiContext* ctx)
        -:16896:{
     1077:16897:    ImGuiContext& g = *ctx;
     1077:16898:    ImGuiDockContext* dc = &ctx->DockContext;
     1077:16899:    if (!(g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable))
     1077:16899-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####:16900:        return;
    %%%%%:16900-block 3
        -:16901:
        -:16902:    // [DEBUG] Store hovered dock node.
        -:16903:    // We could in theory use DockNodeTreeFindVisibleNodeByPos() on the root host dock node, but using ->DockNode is a good shortcut.
        -:16904:    // Note this is mostly a debug thing and isn't actually used for docking target, because docking involve more detailed filtering.
     1077:16905:    g.DebugHoveredDockNode = NULL;
     1077:16906:    if (ImGuiWindow* hovered_window = g.HoveredWindowUnderMovingWindow)
     1077:16906-block 4
branch  0 taken 1076 (fallthrough)
branch  1 taken 1
        -:16907:    {
     1076:16908:        if (hovered_window->DockNodeAsHost)
     1076:16908-block 5
branch  0 taken 0 (fallthrough)
branch  1 taken 1076
    #####:16909:            g.DebugHoveredDockNode = DockNodeTreeFindVisibleNodeByPos(hovered_window->DockNodeAsHost, g.IO.MousePos);
    %%%%%:16909-block 6
call    0 never executed
     1076:16910:        else if (hovered_window->RootWindow->DockNode)
     1076:16910-block 8
branch  0 taken 1075 (fallthrough)
branch  1 taken 1
     1075:16911:            g.DebugHoveredDockNode = hovered_window->RootWindow->DockNode;
     1075:16911-block 9
        -:16912:    }
        -:16913:
        -:16914:    // Process Docking requests
    1077*:16915:    for (ImGuiDockRequest& req : dc->Requests)
     1077:16915-block 10
call    0 returned 1077
call    1 returned 1077
    %%%%%:16915-block 14
     1077:16915-block 15
branch  2 taken 0
branch  3 taken 1077 (fallthrough)
    #####:16916:        if (req.Type == ImGuiDockRequestType_Dock)
    %%%%%:16916-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:16917:            DockContextProcessDock(ctx, &req);
    %%%%%:16917-block 13
call    0 never executed
     1077:16918:    dc->Requests.resize(0);
     1077:16918-block 16
call    0 returned 1077
        -:16919:
        -:16920:    // Create windows for each automatic docking nodes
        -:16921:    // We can have NULL pointers when we delete nodes, but because ID are recycled this should amortize nicely (and our node count will never be very high)
    10770:16922:    for (int n = 0; n < dc->Nodes.Data.Size; n++)
     9693:16922-block 23
    10770:16922-block 24
branch  0 taken 9693
branch  1 taken 1077 (fallthrough)
     9693:16923:        if (ImGuiDockNode* node = (ImGuiDockNode*)dc->Nodes.Data[n].val_p)
     9693:16923-block 18
call    0 returned 9693
branch  1 taken 9693 (fallthrough)
branch  2 taken 0
     9693:16924:            if (node->IsFloatingNode())
     9693:16924-block 20
call    0 returned 9693
branch  1 taken 0 (fallthrough)
branch  2 taken 9693
    #####:16925:                DockNodeUpdate(node);
    %%%%%:16925-block 22
call    0 never executed
        -:16926:}
        -:16927:
function _ZN5ImGui19DockContextEndFrameEP12ImGuiContext called 1077 returned 100% blocks executed 56%
     1077:16928:void ImGui::DockContextEndFrame(ImGuiContext* ctx)
        -:16929:{
        -:16930:    // Draw backgrounds of node missing their window
     1077:16931:    ImGuiContext& g = *ctx;
     1077:16932:    ImGuiDockContext* dc = &g.DockContext;
    10770:16933:    for (int n = 0; n < dc->Nodes.Data.Size; n++)
     1077:16933-block 2
     9693:16933-block 24
    10770:16933-block 25
branch  0 taken 9693
branch  1 taken 1077 (fallthrough)
     9693:16934:        if (ImGuiDockNode* node = (ImGuiDockNode*)dc->Nodes.Data[n].val_p)
     9693:16934-block 3
call    0 returned 9693
branch  1 taken 9693 (fallthrough)
branch  2 taken 0
    9693*:16935:            if (node->LastFrameActive == g.FrameCount && node->IsVisible && node->HostWindow && node->IsLeafNode() && !node->IsBgDrawnThisFrame)
     9693:16935-block 5
branch  0 taken 9693 (fallthrough)
branch  1 taken 0
     9693:16935-block 6
branch  2 taken 9688 (fallthrough)
branch  3 taken 5
     9688:16935-block 7
branch  4 taken 9688 (fallthrough)
branch  5 taken 0
     9688:16935-block 8
call    6 returned 9688
branch  7 taken 5381 (fallthrough)
branch  8 taken 4307
     5381:16935-block 10
branch  9 taken 0 (fallthrough)
branch 10 taken 5381
    %%%%%:16935-block 11
     9693:16935-block 12
     9693:16935-block 13
branch 11 taken 0 (fallthrough)
branch 12 taken 9693
        -:16936:            {
    #####:16937:                ImRect bg_rect(node->Pos + ImVec2(0.0f, GetFrameHeight()), node->Pos + node->Size);
    %%%%%:16937-block 14
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:16938:                ImDrawFlags bg_rounding_flags = CalcRoundingFlagsForRectInRect(bg_rect, node->HostWindow->Rect(), g.Style.DockingSeparatorSize);
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$:16938-block 27
    #####:16939:                node->HostWindow->DrawList->ChannelsSetCurrent(DOCKING_HOST_DRAW_CHANNEL_BG);
    %%%%%:16939-block 21
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:16940:                node->HostWindow->DrawList->AddRectFilled(bg_rect.Min, bg_rect.Max, node->LastBgColor, node->HostWindow->WindowRounding, bg_rounding_flags);
    %%%%%:16940-block 22
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:16941:            }
     1077:16942:}
     1077:16942-block 26
        -:16943:
function _ZN5ImGui23DockContextFindNodeByIDEP12ImGuiContextj called 1099 returned 100% blocks executed 100%
     1099:16944:ImGuiDockNode* ImGui::DockContextFindNodeByID(ImGuiContext* ctx, ImGuiID id)
        -:16945:{
     1099:16946:    return (ImGuiDockNode*)ctx->DockContext.Nodes.GetVoidPtr(id);
     1099:16946-block 2
call    0 returned 1099
        -:16947:}
        -:16948:
function _ZN5ImGui20DockContextGenNodeIDEP12ImGuiContext called 0 returned 0% blocks executed 0%
    #####:16949:ImGuiID ImGui::DockContextGenNodeID(ImGuiContext* ctx)
        -:16950:{
        -:16951:    // Generate an ID for new node (the exact ID value doesn't matter as long as it is not already used)
        -:16952:    // FIXME-OPT FIXME-DOCK: This is suboptimal, even if the node count is small enough not to be a worry.0
        -:16953:    // We should poke in ctx->Nodes to find a suitable ID faster. Even more so trivial that ctx->Nodes lookup is already sorted.
    #####:16954:    ImGuiID id = 0x0001;
    #####:16955:    while (DockContextFindNodeByID(ctx, id) != NULL)
    %%%%%:16955-block 2
    %%%%%:16955-block 4
call    0 never executed
branch  1 never executed
branch  2 never executed (fallthrough)
    #####:16956:        id++;
    %%%%%:16956-block 3
    #####:16957:    return id;
    %%%%%:16957-block 6
        -:16958:}
        -:16959:
function _ZN5ImGuiL18DockContextAddNodeEP12ImGuiContextj called 9 returned 100% blocks executed 69%
        9:16960:static ImGuiDockNode* ImGui::DockContextAddNode(ImGuiContext* ctx, ImGuiID id)
        -:16961:{
        -:16962:    // Generate an ID for the new node (the exact ID value doesn't matter as long as it is not already used) and add the first window.
        9:16963:    ImGuiContext& g = *ctx;
        9:16964:    if (id == 0)
        9:16964-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 9
    #####:16965:        id = DockContextGenNodeID(ctx);
    %%%%%:16965-block 3
call    0 never executed
        -:16966:    else
       9*:16967:        IM_ASSERT(DockContextFindNodeByID(ctx, id) == NULL);
        9:16967-block 4
call    0 returned 9
branch  1 taken 0 (fallthrough)
branch  2 taken 9
    %%%%%:16967-block 6
call    3 never executed
        -:16968:
        -:16969:    // We don't set node->LastFrameAlive on construction. Nodes are always created at all time to reflect .ini settings!
       9*:16970:    IMGUI_DEBUG_LOG_DOCKING("[docking] DockContextAddNode 0x%08X\n", id);
        9:16970-block 7
branch  0 taken 0 (fallthrough)
branch  1 taken 9
    %%%%%:16970-block 8
call    2 never executed
        9:16971:    ImGuiDockNode* node = IM_NEW(ImGuiDockNode)(id);
        9:16971-block 9
call    0 returned 9
call    1 returned 9
call    2 returned 9
branch  3 taken 9 (fallthrough)
branch  4 taken 0 (throw)
    $$$$$:16971-block 15
branch  5 never executed (fallthrough)
branch  6 never executed
    $$$$$:16971-block 16
call    7 never executed
        9:16972:    ctx->DockContext.Nodes.SetVoidPtr(node->ID, node);
        9:16972-block 12
call    0 returned 9
        9:16973:    return node;
        9:16973-block 14
        -:16974:}
        -:16975:
function _ZN5ImGuiL21DockContextRemoveNodeEP12ImGuiContextP13ImGuiDockNodeb called 0 returned 0% blocks executed 0%
    #####:16976:static void ImGui::DockContextRemoveNode(ImGuiContext* ctx, ImGuiDockNode* node, bool merge_sibling_into_parent_node)
        -:16977:{
    #####:16978:    ImGuiContext& g = *ctx;
    #####:16979:    ImGuiDockContext* dc = &ctx->DockContext;
        -:16980:
    #####:16981:    IMGUI_DEBUG_LOG_DOCKING("[docking] DockContextRemoveNode 0x%08X\n", node->ID);
    %%%%%:16981-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16981-block 3
call    2 never executed
    #####:16982:    IM_ASSERT(DockContextFindNodeByID(ctx, node->ID) == node);
    %%%%%:16982-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:16982-block 6
call    3 never executed
    #####:16983:    IM_ASSERT(node->ChildNodes[0] == NULL && node->ChildNodes[1] == NULL);
    %%%%%:16983-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16983-block 8
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:16983-block 9
    %%%%%:16983-block 10
call    4 never executed
    #####:16984:    IM_ASSERT(node->Windows.Size == 0);
    %%%%%:16984-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16984-block 12
call    2 never executed
        -:16985:
    #####:16986:    if (node->HostWindow)
    %%%%%:16986-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:16987:        node->HostWindow->DockNodeAsHost = NULL;
    %%%%%:16987-block 14
        -:16988:
    #####:16989:    ImGuiDockNode* parent_node = node->ParentNode;
    #####:16990:    const bool merge = (merge_sibling_into_parent_node && parent_node != NULL);
    %%%%%:16990-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16990-block 16
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:16990-block 17
    %%%%%:16990-block 18
    #####:16991:    if (merge)
    %%%%%:16991-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
        -:16992:    {
    #####:16993:        IM_ASSERT(parent_node->ChildNodes[0] == node || parent_node->ChildNodes[1] == node);
    %%%%%:16993-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16993-block 21
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:16993-block 22
call    4 never executed
    #####:16994:        ImGuiDockNode* sibling_node = (parent_node->ChildNodes[0] == node ? parent_node->ChildNodes[1] : parent_node->ChildNodes[0]);
    %%%%%:16994-block 23
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16994-block 24
    %%%%%:16994-block 25
    #####:16995:        DockNodeTreeMerge(&g, parent_node, sibling_node);
    %%%%%:16995-block 26
call    0 never executed
        -:16996:    }
        -:16997:    else
        -:16998:    {
    #####:16999:        for (int n = 0; parent_node && n < IM_ARRAYSIZE(parent_node->ChildNodes); n++)
    %%%%%:16999-block 27
    %%%%%:16999-block 30
    %%%%%:16999-block 31
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:16999-block 32
branch  2 never executed
branch  3 never executed (fallthrough)
    #####:17000:            if (parent_node->ChildNodes[n] == node)
    %%%%%:17000-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:17001:                node->ParentNode->ChildNodes[n] = NULL;
    %%%%%:17001-block 29
    #####:17002:        dc->Nodes.SetVoidPtr(node->ID, NULL);
    %%%%%:17002-block 33
call    0 never executed
    #####:17003:        IM_DELETE(node);
call    0 never executed
        -:17004:    }
    #####:17005:}
        -:17006:
function _ZL30DockNodeComparerDepthMostFirstPKvS0_ called 0 returned 0% blocks executed 0%
    #####:17007:static int IMGUI_CDECL DockNodeComparerDepthMostFirst(const void* lhs, const void* rhs)
        -:17008:{
    #####:17009:    const ImGuiDockNode* a = *(const ImGuiDockNode* const*)lhs;
    #####:17010:    const ImGuiDockNode* b = *(const ImGuiDockNode* const*)rhs;
    #####:17011:    return ImGui::DockNodeGetDepth(b) - ImGui::DockNodeGetDepth(a);
    %%%%%:17011-block 2
call    0 never executed
call    1 never executed
        -:17012:}
        -:17013:
        -:17014:// Pre C++0x doesn't allow us to use a function-local type (without linkage) as template parameter, so we moved this here.
        -:17015:struct ImGuiDockContextPruneNodeData
        -:17016:{
        -:17017:    int         CountWindows, CountChildWindows, CountChildNodes;
        -:17018:    ImGuiID     RootId;
function _ZN29ImGuiDockContextPruneNodeDataC2Ev called 9 returned 100% blocks executed 100%
        9:17019:    ImGuiDockContextPruneNodeData() { CountWindows = CountChildWindows = CountChildNodes = 0; RootId = 0; }
        -:17020:};
        -:17021:
        -:17022:// Garbage collect unused nodes (run once at init time)
function _ZN5ImGuiL35DockContextPruneUnusedSettingsNodesEP12ImGuiContext called 1 returned 100% blocks executed 79%
        1:17023:static void ImGui::DockContextPruneUnusedSettingsNodes(ImGuiContext* ctx)
        -:17024:{
        1:17025:    ImGuiContext& g = *ctx;
        1:17026:    ImGuiDockContext* dc = &ctx->DockContext;
       1*:17027:    IM_ASSERT(g.Windows.Size == 0);
        1:17027-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%:17027-block 3
call    2 never executed
        -:17028:
        1:17029:    ImPool<ImGuiDockContextPruneNodeData> pool;
        1:17029-block 4
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:17030:    pool.Reserve(dc->NodesSettings.Size);
        1:17030-block 5
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:17031:
        -:17032:    // Count child nodes and compute RootID
       10:17033:    for (int settings_n = 0; settings_n < dc->NodesSettings.Size; settings_n++)
        1:17033-block 6
        9:17033-block 19
       10:17033-block 20
branch  0 taken 9
branch  1 taken 1 (fallthrough)
        -:17034:    {
        9:17035:        ImGuiDockNodeSettings* settings = &dc->NodesSettings[settings_n];
        9:17035-block 7
call    0 returned 9
        9:17036:        ImGuiDockContextPruneNodeData* parent_data = settings->ParentNodeId ? pool.GetByKey(settings->ParentNodeId) : 0;
branch  0 taken 8 (fallthrough)
branch  1 taken 1
        8:17036-block 9
call    2 returned 8
branch  3 taken 8 (fallthrough)
branch  4 taken 0 (throw)
        8:17036-block 10
        1:17036-block 11
        9:17037:        pool.GetOrAddByKey(settings->ID)->RootId = parent_data ? parent_data->RootId : settings->ID;
        9:17037-block 12
branch  0 taken 8 (fallthrough)
branch  1 taken 1
        8:17037-block 13
        1:17037-block 14
        9:17037-block 15
call    2 returned 9
branch  3 taken 9 (fallthrough)
branch  4 taken 0 (throw)
        9:17038:        if (settings->ParentNodeId)
        9:17038-block 16
branch  0 taken 8 (fallthrough)
branch  1 taken 1
        8:17039:            pool.GetOrAddByKey(settings->ParentNodeId)->CountChildNodes++;
        8:17039-block 17
call    0 returned 8
branch  1 taken 8 (fallthrough)
branch  2 taken 0 (throw)
        8:17039-block 18
        -:17040:    }
        -:17041:
        -:17042:    // Count reference to dock ids from dockspaces
        -:17043:    // We track the 'auto-DockNode <- manual-Window <- manual-DockSpace' in order to avoid 'auto-DockNode' being ditched by DockContextPruneUnusedSettingsNodes()
       10:17044:    for (int settings_n = 0; settings_n < dc->NodesSettings.Size; settings_n++)
        1:17044-block 21
        9:17044-block 30
       10:17044-block 31
branch  0 taken 9
branch  1 taken 1 (fallthrough)
        -:17045:    {
        9:17046:        ImGuiDockNodeSettings* settings = &dc->NodesSettings[settings_n];
        9:17046-block 22
call    0 returned 9
        9:17047:        if (settings->ParentWindowId != 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 8
        1:17048:            if (ImGuiWindowSettings* window_settings = FindWindowSettingsByID(settings->ParentWindowId))
        1:17048-block 24
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:17048-block 25
branch  3 taken 1 (fallthrough)
branch  4 taken 0
        1:17049:                if (window_settings->DockId)
        1:17049-block 26
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:17050:                    if (ImGuiDockContextPruneNodeData* data = pool.GetByKey(window_settings->DockId))
    %%%%%:17050-block 27
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:17050-block 28
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:17051:                        data->CountChildNodes++;
    %%%%%:17051-block 29
        -:17052:    }
        -:17053:
        -:17054:    // Count reference to dock ids from window settings
        -:17055:    // We guard against the possibility of an invalid .ini file (RootID may point to a missing node)
       12:17056:    for (ImGuiWindowSettings* settings = g.SettingsWindows.begin(); settings != NULL; settings = g.SettingsWindows.next_chunk(settings))
        1:17056-block 32
call    0 returned 1
       11:17056-block 42
call    1 returned 11
branch  2 taken 11 (fallthrough)
branch  3 taken 0 (throw)
       11:17056-block 43
       12:17056-block 44
branch  4 taken 11
branch  5 taken 1 (fallthrough)
       11:17057:        if (ImGuiID dock_id = settings->DockId)
       11:17057-block 33
branch  0 taken 5 (fallthrough)
branch  1 taken 6
        5:17058:            if (ImGuiDockContextPruneNodeData* data = pool.GetByKey(dock_id))
        5:17058-block 34
call    0 returned 5
branch  1 taken 5 (fallthrough)
branch  2 taken 0 (throw)
        5:17058-block 35
branch  3 taken 5 (fallthrough)
branch  4 taken 0
        -:17059:            {
        5:17060:                data->CountWindows++;
       5*:17061:                if (ImGuiDockContextPruneNodeData* data_root = (data->RootId == dock_id) ? data : pool.GetByKey(data->RootId))
        5:17061-block 36
branch  0 taken 5 (fallthrough)
branch  1 taken 0
        5:17061-block 37
call    2 returned 5
branch  3 taken 5 (fallthrough)
branch  4 taken 0 (throw)
        5:17061-block 38
    %%%%%:17061-block 39
        5:17061-block 40
branch  5 taken 5 (fallthrough)
branch  6 taken 0
        5:17062:                    data_root->CountChildWindows++;
        5:17062-block 41
        -:17063:            }
        -:17064:
        -:17065:    // Prune
       10:17066:    for (int settings_n = 0; settings_n < dc->NodesSettings.Size; settings_n++)
        1:17066-block 45
        9:17066-block 70
       10:17066-block 71
branch  0 taken 9
branch  1 taken 1 (fallthrough)
        -:17067:    {
        9:17068:        ImGuiDockNodeSettings* settings = &dc->NodesSettings[settings_n];
        9:17068-block 46
call    0 returned 9
        9:17069:        ImGuiDockContextPruneNodeData* data = pool.GetByKey(settings->ID);
call    0 returned 9
branch  1 taken 9 (fallthrough)
branch  2 taken 0 (throw)
       9*:17070:        if (data->CountWindows > 1)
        9:17070-block 48
branch  0 taken 0 (fallthrough)
branch  1 taken 9
    #####:17071:            continue;
    %%%%%:17071-block 49
        9:17072:        ImGuiDockContextPruneNodeData* data_root = (data->RootId == settings->ID) ? data : pool.GetByKey(data->RootId);
        9:17072-block 50
branch  0 taken 8 (fallthrough)
branch  1 taken 1
        8:17072-block 51
call    2 returned 8
branch  3 taken 8 (fallthrough)
branch  4 taken 0 (throw)
        8:17072-block 52
        1:17072-block 53
        -:17073:
        9:17074:        bool remove = false;
       9*:17075:        remove |= (data->CountWindows == 1 && settings->ParentNodeId == 0 && data->CountChildNodes == 0 && !(settings->Flags & ImGuiDockNodeFlags_CentralNode));  // Floating root node with only 1 window
        9:17075-block 54
branch  0 taken 5 (fallthrough)
branch  1 taken 4
        5:17075-block 55
branch  2 taken 0 (fallthrough)
branch  3 taken 5
    %%%%%:17075-block 56
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:17075-block 57
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%:17075-block 58
        9:17075-block 59
       9*:17076:        remove |= (data->CountWindows == 0 && settings->ParentNodeId == 0 && data->CountChildNodes == 0); // Leaf nodes with 0 window
        9:17076-block 60
branch  0 taken 4 (fallthrough)
branch  1 taken 5
        4:17076-block 61
branch  2 taken 1 (fallthrough)
branch  3 taken 3
        1:17076-block 62
branch  4 taken 0 (fallthrough)
branch  5 taken 1
    %%%%%:17076-block 63
        9:17076-block 64
        9:17077:        remove |= (data_root->CountChildWindows == 0);
        9:17078:        if (remove)
        9:17078-block 65
branch  0 taken 0 (fallthrough)
branch  1 taken 9
        -:17079:        {
    #####:17080:            IMGUI_DEBUG_LOG_DOCKING("[docking] DockContextPruneUnusedSettingsNodes: Prune 0x%08X\n", settings->ID);
    %%%%%:17080-block 66
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17080-block 67
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####:17081:            DockSettingsRemoveNodeReferences(&settings->ID, 1);
    %%%%%:17081-block 68
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:17082:            settings->ID = 0;
    %%%%%:17082-block 69
        -:17083:        }
        -:17084:    }
        1:17085:}
        1:17085-block 72
call    0 returned 1
    $$$$$:17085-block 74
call    1 never executed
        -:17086:
function _ZN5ImGuiL33DockContextBuildNodesFromSettingsEP12ImGuiContextP21ImGuiDockNodeSettingsi called 1 returned 100% blocks executed 96%
        1:17087:static void ImGui::DockContextBuildNodesFromSettings(ImGuiContext* ctx, ImGuiDockNodeSettings* node_settings_array, int node_settings_count)
        -:17088:{
        -:17089:    // Build nodes
       10:17090:    for (int node_n = 0; node_n < node_settings_count; node_n++)
        1:17090-block 2
        9:17090-block 23
       10:17090-block 24
branch  0 taken 9
branch  1 taken 1 (fallthrough)
        -:17091:    {
        9:17092:        ImGuiDockNodeSettings* settings = &node_settings_array[node_n];
       9*:17093:        if (settings->ID == 0)
        9:17093-block 3
branch  0 taken 0 (fallthrough)
branch  1 taken 9
    #####:17094:            continue;
    %%%%%:17094-block 4
        9:17095:        ImGuiDockNode* node = DockContextAddNode(ctx, settings->ID);
        9:17095-block 5
call    0 returned 9
branch  1 taken 9 (fallthrough)
branch  2 taken 0 (throw)
        9:17096:        node->ParentNode = settings->ParentNodeId ? DockContextFindNodeByID(ctx, settings->ParentNodeId) : NULL;
        9:17096-block 6
branch  0 taken 8 (fallthrough)
branch  1 taken 1
        8:17096-block 7
call    2 returned 8
        1:17096-block 8
        9:17097:        node->Pos = ImVec2(settings->Pos.x, settings->Pos.y);
        9:17097-block 9
call    0 returned 9
        9:17098:        node->Size = ImVec2(settings->Size.x, settings->Size.y);
call    0 returned 9
        9:17099:        node->SizeRef = ImVec2(settings->SizeRef.x, settings->SizeRef.y);
call    0 returned 9
        9:17100:        node->AuthorityForPos = node->AuthorityForSize = node->AuthorityForViewport = ImGuiDataAuthority_DockNode;
        9:17101:        if (node->ParentNode && node->ParentNode->ChildNodes[0] == NULL)
branch  0 taken 8 (fallthrough)
branch  1 taken 1
        8:17101-block 13
branch  2 taken 4 (fallthrough)
branch  3 taken 4
        4:17102:            node->ParentNode->ChildNodes[0] = node;
        4:17102-block 14
        5:17103:        else if (node->ParentNode && node->ParentNode->ChildNodes[1] == NULL)
        5:17103-block 15
branch  0 taken 4 (fallthrough)
branch  1 taken 1
        4:17103-block 16
branch  2 taken 4 (fallthrough)
branch  3 taken 0
        4:17104:            node->ParentNode->ChildNodes[1] = node;
        4:17104-block 17
        9:17105:        node->SelectedTabId = settings->SelectedTabId;
        9:17106:        node->SplitAxis = (ImGuiAxis)settings->SplitAxis;
        9:17107:        node->SetLocalFlags(settings->Flags & ImGuiDockNodeFlags_SavedFlagsMask_);
        9:17107-block 18
call    0 returned 9
branch  1 taken 9 (fallthrough)
branch  2 taken 0 (throw)
        -:17108:
        -:17109:        // Bind host window immediately if it already exist (in case of a rebuild)
        -:17110:        // This is useful as the RootWindowForTitleBarHighlight links necessary to highlight the currently focused node requires node->HostWindow to be set.
        -:17111:        char host_window_title[20];
        9:17112:        ImGuiDockNode* root_node = DockNodeGetRootNode(node);
        9:17112-block 19
call    0 returned 9
        9:17113:        node->HostWindow = FindWindowByName(DockNodeGetHostWindowTitle(root_node, host_window_title, IM_ARRAYSIZE(host_window_title)));
call    0 returned 9
call    1 returned 9
        -:17114:    }
        1:17115:}
        1:17115-block 25
        -:17116:
function _ZN5ImGuiL33DockContextBuildAddWindowsToNodesEP12ImGuiContextj called 1 returned 100% blocks executed 20%
        1:17117:void ImGui::DockContextBuildAddWindowsToNodes(ImGuiContext* ctx, ImGuiID root_id)
        -:17118:{
        -:17119:    // Rebind all windows to nodes (they can also lazily rebind but we'll have a visible glitch during the first frame)
        1:17120:    ImGuiContext& g = *ctx;
       1*:17121:    for (ImGuiWindow* window : g.Windows)
        1:17121-block 2
call    0 returned 1
call    1 returned 1
    %%%%%:17121-block 19
        1:17121-block 20
branch  2 taken 0
branch  3 taken 1 (fallthrough)
        -:17122:    {
    #####:17123:        if (window->DockId == 0 || window->LastFrameActive < g.FrameCount - 1)
    %%%%%:17123-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17123-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:17124:            continue;
    %%%%%:17124-block 6
    #####:17125:        if (window->DockNode != NULL)
    %%%%%:17125-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:17126:            continue;
    %%%%%:17126-block 8
        -:17127:
    #####:17128:        ImGuiDockNode* node = DockContextFindNodeByID(ctx, window->DockId);
    %%%%%:17128-block 9
call    0 never executed
    #####:17129:        IM_ASSERT(node != NULL);   // This should have been called after DockContextBuildNodesFromSettings()
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17129-block 11
call    2 never executed
    #####:17130:        if (root_id == 0 || DockNodeGetRootNode(node)->ID == root_id)
    %%%%%:17130-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17130-block 13
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:17130-block 15
    %%%%%:17130-block 16
    %%%%%:17130-block 17
branch  5 never executed (fallthrough)
branch  6 never executed
    #####:17131:            DockNodeAddWindow(node, window, true);
    %%%%%:17131-block 18
call    0 never executed
        -:17132:    }
        1:17133:}
        -:17134:
        -:17135://-----------------------------------------------------------------------------
        -:17136:// Docking: ImGuiDockContext Docking/Undocking functions
        -:17137://-----------------------------------------------------------------------------
        -:17138:// - DockContextQueueDock()
        -:17139:// - DockContextQueueUndockWindow()
        -:17140:// - DockContextQueueUndockNode()
        -:17141:// - DockContextQueueNotifyRemovedNode()
        -:17142:// - DockContextProcessDock()
        -:17143:// - DockContextProcessUndockWindow()
        -:17144:// - DockContextProcessUndockNode()
        -:17145:// - DockContextCalcDropPosForDocking()
        -:17146://-----------------------------------------------------------------------------
        -:17147:
function _ZN5ImGui20DockContextQueueDockEP12ImGuiContextP11ImGuiWindowP13ImGuiDockNodeS3_8ImGuiDirfb called 0 returned 0% blocks executed 0%
    #####:17148:void ImGui::DockContextQueueDock(ImGuiContext* ctx, ImGuiWindow* target, ImGuiDockNode* target_node, ImGuiWindow* payload, ImGuiDir split_dir, float split_ratio, bool split_outer)
        -:17149:{
    #####:17150:    IM_ASSERT(target != payload);
    %%%%%:17150-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17150-block 3
call    2 never executed
    #####:17151:    ImGuiDockRequest req;
    %%%%%:17151-block 4
call    0 never executed
    #####:17152:    req.Type = ImGuiDockRequestType_Dock;
    #####:17153:    req.DockTargetWindow = target;
    #####:17154:    req.DockTargetNode = target_node;
    #####:17155:    req.DockPayload = payload;
    #####:17156:    req.DockSplitDir = split_dir;
    #####:17157:    req.DockSplitRatio = split_ratio;
    #####:17158:    req.DockSplitOuter = split_outer;
    #####:17159:    ctx->DockContext.Requests.push_back(req);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:17160:}
    %%%%%:17160-block 6
        -:17161:
function _ZN5ImGui28DockContextQueueUndockWindowEP12ImGuiContextP11ImGuiWindow called 0 returned 0% blocks executed 0%
    #####:17162:void ImGui::DockContextQueueUndockWindow(ImGuiContext* ctx, ImGuiWindow* window)
        -:17163:{
    #####:17164:    ImGuiDockRequest req;
    %%%%%:17164-block 2
call    0 never executed
    #####:17165:    req.Type = ImGuiDockRequestType_Undock;
    #####:17166:    req.UndockTargetWindow = window;
    #####:17167:    ctx->DockContext.Requests.push_back(req);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:17168:}
    %%%%%:17168-block 4
        -:17169:
function _ZN5ImGui26DockContextQueueUndockNodeEP12ImGuiContextP13ImGuiDockNode called 0 returned 0% blocks executed 0%
    #####:17170:void ImGui::DockContextQueueUndockNode(ImGuiContext* ctx, ImGuiDockNode* node)
        -:17171:{
    #####:17172:    ImGuiDockRequest req;
    %%%%%:17172-block 2
call    0 never executed
    #####:17173:    req.Type = ImGuiDockRequestType_Undock;
    #####:17174:    req.UndockTargetNode = node;
    #####:17175:    ctx->DockContext.Requests.push_back(req);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:17176:}
    %%%%%:17176-block 4
        -:17177:
function _ZN5ImGuiL33DockContextQueueNotifyRemovedNodeEP12ImGuiContextP13ImGuiDockNode called 0 returned 0% blocks executed 0%
    #####:17178:void ImGui::DockContextQueueNotifyRemovedNode(ImGuiContext* ctx, ImGuiDockNode* node)
        -:17179:{
    #####:17180:    ImGuiDockContext* dc = &ctx->DockContext;
    #####:17181:    for (ImGuiDockRequest& req : dc->Requests)
    %%%%%:17181-block 2
call    0 never executed
call    1 never executed
    %%%%%:17181-block 6
    %%%%%:17181-block 7
branch  2 never executed
branch  3 never executed (fallthrough)
    #####:17182:        if (req.DockTargetNode == node)
    %%%%%:17182-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:17183:            req.Type = ImGuiDockRequestType_None;
    %%%%%:17183-block 5
    #####:17184:}
        -:17185:
function _ZN5ImGuiL22DockContextProcessDockEP12ImGuiContextP16ImGuiDockRequest called 0 returned 0% blocks executed 0%
    #####:17186:void ImGui::DockContextProcessDock(ImGuiContext* ctx, ImGuiDockRequest* req)
        -:17187:{
    #####:17188:    IM_ASSERT((req->Type == ImGuiDockRequestType_Dock && req->DockPayload != NULL) || (req->Type == ImGuiDockRequestType_Split && req->DockPayload == NULL));
    %%%%%:17188-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17188-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:17188-block 4
    %%%%%:17188-block 5
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:17188-block 6
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%:17188-block 7
    %%%%%:17188-block 8
call    8 never executed
    #####:17189:    IM_ASSERT(req->DockTargetWindow != NULL || req->DockTargetNode != NULL);
    %%%%%:17189-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17189-block 10
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:17189-block 11
call    4 never executed
        -:17190:
    #####:17191:    ImGuiContext& g = *ctx;
        -:17192:    IM_UNUSED(g);
        -:17193:
    #####:17194:    ImGuiWindow* payload_window = req->DockPayload;     // Optional
    #####:17195:    ImGuiWindow* target_window = req->DockTargetWindow;
    #####:17196:    ImGuiDockNode* node = req->DockTargetNode;
    #####:17197:    if (payload_window)
    %%%%%:17197-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:17198:        IMGUI_DEBUG_LOG_DOCKING("[docking] DockContextProcessDock node 0x%08X target '%s' dock window '%s', split_dir %d\n", node ? node->ID : 0, target_window ? target_window->Name : "NULL", payload_window->Name, req->DockSplitDir);
    %%%%%:17198-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17198-block 14
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:17198-block 15
    %%%%%:17198-block 16
    %%%%%:17198-block 17
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:17198-block 18
    %%%%%:17198-block 19
    %%%%%:17198-block 20
call    6 never executed
        -:17199:    else
    #####:17200:        IMGUI_DEBUG_LOG_DOCKING("[docking] DockContextProcessDock node 0x%08X, split_dir %d\n", node ? node->ID : 0, req->DockSplitDir);
    %%%%%:17200-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17200-block 22
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:17200-block 23
    %%%%%:17200-block 24
    %%%%%:17200-block 25
call    4 never executed
        -:17201:
        -:17202:    // Decide which Tab will be selected at the end of the operation
    #####:17203:    ImGuiID next_selected_id = 0;
    #####:17204:    ImGuiDockNode* payload_node = NULL;
    #####:17205:    if (payload_window)
    %%%%%:17205-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
        -:17206:    {
    #####:17207:        payload_node = payload_window->DockNodeAsHost;
    #####:17208:        payload_window->DockNodeAsHost = NULL; // Important to clear this as the node will have its life as a child which might be merged/deleted later.
    #####:17209:        if (payload_node && payload_node->IsLeafNode())
    %%%%%:17209-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17209-block 28
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:17209-block 30
    %%%%%:17209-block 31
    %%%%%:17209-block 32
branch  5 never executed (fallthrough)
branch  6 never executed
    #####:17210:            next_selected_id = payload_node->TabBar->NextSelectedTabId ? payload_node->TabBar->NextSelectedTabId : payload_node->TabBar->SelectedTabId;
    %%%%%:17210-block 33
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17210-block 34
    %%%%%:17210-block 35
    %%%%%:17210-block 36
    #####:17211:        if (payload_node == NULL)
    %%%%%:17211-block 37
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:17212:            next_selected_id = payload_window->TabId;
    %%%%%:17212-block 38
        -:17213:    }
        -:17214:
        -:17215:    // FIXME-DOCK: When we are trying to dock an existing single-window node into a loose window, transfer Node ID as well
        -:17216:    // When processing an interactive split, usually LastFrameAlive will be < g.FrameCount. But DockBuilder operations can make it ==.
    #####:17217:    if (node)
    %%%%%:17217-block 39
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:17218:        IM_ASSERT(node->LastFrameAlive <= g.FrameCount);
    %%%%%:17218-block 40
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17218-block 41
call    2 never executed
    #####:17219:    if (node && target_window && node == target_window->DockNodeAsHost)
    %%%%%:17219-block 42
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17219-block 43
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:17219-block 44
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:17220:        IM_ASSERT(node->Windows.Size > 0 || node->IsSplitNode() || node->IsCentralNode());
    %%%%%:17220-block 45
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17220-block 46
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:17220-block 48
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%:17220-block 50
call    8 never executed
        -:17221:
        -:17222:    // Create new node and add existing window to it
    #####:17223:    if (node == NULL)
    %%%%%:17223-block 51
branch  0 never executed (fallthrough)
branch  1 never executed
        -:17224:    {
    #####:17225:        node = DockContextAddNode(ctx, 0);
    %%%%%:17225-block 52
call    0 never executed
    #####:17226:        node->Pos = target_window->Pos;
    #####:17227:        node->Size = target_window->Size;
    #####:17228:        if (target_window->DockNodeAsHost == NULL)
branch  0 never executed (fallthrough)
branch  1 never executed
        -:17229:        {
    #####:17230:            DockNodeAddWindow(node, target_window, true);
    %%%%%:17230-block 54
call    0 never executed
    #####:17231:            node->TabBar->Tabs[0].Flags &= ~ImGuiTabItemFlags_Unsorted;
call    0 never executed
    #####:17232:            target_window->DockIsActive = true;
        -:17233:        }
        -:17234:    }
        -:17235:
    #####:17236:    ImGuiDir split_dir = req->DockSplitDir;
    #####:17237:    if (split_dir != ImGuiDir_None)
    %%%%%:17237-block 57
branch  0 never executed (fallthrough)
branch  1 never executed
        -:17238:    {
        -:17239:        // Split into two, one side will be our payload node unless we are dropping a loose window
    #####:17240:        const ImGuiAxis split_axis = (split_dir == ImGuiDir_Left || split_dir == ImGuiDir_Right) ? ImGuiAxis_X : ImGuiAxis_Y;
    %%%%%:17240-block 58
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17240-block 59
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:17240-block 60
    %%%%%:17240-block 61
    #####:17241:        const int split_inheritor_child_idx = (split_dir == ImGuiDir_Left || split_dir == ImGuiDir_Up) ? 1 : 0; // Current contents will be moved to the opposite side
    %%%%%:17241-block 62
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17241-block 63
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:17241-block 64
    %%%%%:17241-block 65
    #####:17242:        const float split_ratio = req->DockSplitRatio;
    #####:17243:        DockNodeTreeSplit(ctx, node, split_axis, split_inheritor_child_idx, split_ratio, payload_node);  // payload_node may be NULL here!
    %%%%%:17243-block 66
call    0 never executed
    #####:17244:        ImGuiDockNode* new_node = node->ChildNodes[split_inheritor_child_idx ^ 1];
    #####:17245:        new_node->HostWindow = node->HostWindow;
    #####:17246:        node = new_node;
        -:17247:    }
    #####:17248:    node->SetLocalFlags(node->LocalFlags & ~ImGuiDockNodeFlags_HiddenTabBar);
    %%%%%:17248-block 68
call    0 never executed
        -:17249:
    #####:17250:    if (node != payload_node)
branch  0 never executed (fallthrough)
branch  1 never executed
        -:17251:    {
        -:17252:        // Create tab bar before we call DockNodeMoveWindows (which would attempt to move the old tab-bar, which would lead us to payload tabs wrongly appearing before target tabs!)
    #####:17253:        if (node->Windows.Size > 0 && node->TabBar == NULL)
    %%%%%:17253-block 70
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17253-block 71
branch  2 never executed (fallthrough)
branch  3 never executed
        -:17254:        {
    #####:17255:            DockNodeAddTabBar(node);
    %%%%%:17255-block 72
call    0 never executed
    #####:17256:            for (int n = 0; n < node->Windows.Size; n++)
    %%%%%:17256-block 77
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:17257:                TabBarAddTab(node->TabBar, ImGuiTabItemFlags_None, node->Windows[n]);
    %%%%%:17257-block 74
call    0 never executed
call    1 never executed
        -:17258:        }
        -:17259:
    #####:17260:        if (payload_node != NULL)
    %%%%%:17260-block 78
branch  0 never executed (fallthrough)
branch  1 never executed
        -:17261:        {
        -:17262:            // Transfer full payload node (with 1+ child windows or child nodes)
    #####:17263:            if (payload_node->IsSplitNode())
    %%%%%:17263-block 79
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -:17264:            {
    #####:17265:                if (node->Windows.Size > 0)
    %%%%%:17265-block 81
branch  0 never executed (fallthrough)
branch  1 never executed
        -:17266:                {
        -:17267:                    // We can dock a split payload into a node that already has windows _only_ if our payload is a node tree with a single visible node.
        -:17268:                    // In this situation, we move the windows of the target node into the currently visible node of the payload.
        -:17269:                    // This allows us to preserve some of the underlying dock tree settings nicely.
    #####:17270:                    IM_ASSERT(payload_node->OnlyNodeWithWindows != NULL); // The docking should have been blocked by DockNodePreviewDockSetup() early on and never submitted.
    %%%%%:17270-block 82
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17270-block 83
call    2 never executed
    #####:17271:                    ImGuiDockNode* visible_node = payload_node->OnlyNodeWithWindows;
    #####:17272:                    if (visible_node->TabBar)
    %%%%%:17272-block 84
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:17273:                        IM_ASSERT(visible_node->TabBar->Tabs.Size > 0);
    %%%%%:17273-block 85
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17273-block 86
call    2 never executed
    #####:17274:                    DockNodeMoveWindows(node, visible_node);
    %%%%%:17274-block 87
call    0 never executed
    #####:17275:                    DockNodeMoveWindows(visible_node, node);
call    0 never executed
    #####:17276:                    DockSettingsRenameNodeReferences(node->ID, visible_node->ID);
call    0 never executed
        -:17277:                }
    #####:17278:                if (node->IsCentralNode())
    %%%%%:17278-block 90
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -:17279:                {
        -:17280:                    // Central node property needs to be moved to a leaf node, pick the last focused one.
        -:17281:                    // FIXME-DOCK: If we had to transfer other flags here, what would the policy be?
    #####:17282:                    ImGuiDockNode* last_focused_node = DockContextFindNodeByID(ctx, payload_node->LastFocusedNodeId);
    %%%%%:17282-block 92
call    0 never executed
    #####:17283:                    IM_ASSERT(last_focused_node != NULL);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17283-block 94
call    2 never executed
    #####:17284:                    ImGuiDockNode* last_focused_root_node = DockNodeGetRootNode(last_focused_node);
    %%%%%:17284-block 95
call    0 never executed
    #####:17285:                    IM_ASSERT(last_focused_root_node == DockNodeGetRootNode(payload_node));
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:17285-block 98
call    3 never executed
    #####:17286:                    last_focused_node->SetLocalFlags(last_focused_node->LocalFlags | ImGuiDockNodeFlags_CentralNode);
    %%%%%:17286-block 99
call    0 never executed
    #####:17287:                    node->SetLocalFlags(node->LocalFlags & ~ImGuiDockNodeFlags_CentralNode);
call    0 never executed
    #####:17288:                    last_focused_root_node->CentralNode = last_focused_node;
        -:17289:                }
        -:17290:
    #####:17291:                IM_ASSERT(node->Windows.Size == 0);
    %%%%%:17291-block 102
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17291-block 103
call    2 never executed
    #####:17292:                DockNodeMoveChildNodes(node, payload_node);
    %%%%%:17292-block 104
call    0 never executed
        -:17293:            }
        -:17294:            else
        -:17295:            {
    #####:17296:                const ImGuiID payload_dock_id = payload_node->ID;
    #####:17297:                DockNodeMoveWindows(node, payload_node);
    %%%%%:17297-block 105
call    0 never executed
    #####:17298:                DockSettingsRenameNodeReferences(payload_dock_id, node->ID);
call    0 never executed
        -:17299:            }
    #####:17300:            DockContextRemoveNode(ctx, payload_node, true);
    %%%%%:17300-block 107
call    0 never executed
        -:17301:        }
    #####:17302:        else if (payload_window)
    %%%%%:17302-block 108
branch  0 never executed (fallthrough)
branch  1 never executed
        -:17303:        {
        -:17304:            // Transfer single window
    #####:17305:            const ImGuiID payload_dock_id = payload_window->DockId;
    #####:17306:            node->VisibleWindow = payload_window;
    #####:17307:            DockNodeAddWindow(node, payload_window, true);
    %%%%%:17307-block 109
call    0 never executed
    #####:17308:            if (payload_dock_id != 0)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:17309:                DockSettingsRenameNodeReferences(payload_dock_id, node->ID);
    %%%%%:17309-block 111
call    0 never executed
        -:17310:        }
        -:17311:    }
        -:17312:    else
        -:17313:    {
        -:17314:        // When docking a floating single window node we want to reevaluate auto-hiding of the tab bar
    #####:17315:        node->WantHiddenTabBarUpdate = true;
    %%%%%:17315-block 112
        -:17316:    }
        -:17317:
        -:17318:    // Update selection immediately
    #####:17319:    if (ImGuiTabBar* tab_bar = node->TabBar)
    %%%%%:17319-block 113
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:17320:        tab_bar->NextSelectedTabId = next_selected_id;
    %%%%%:17320-block 114
    #####:17321:    MarkIniSettingsDirty();
    %%%%%:17321-block 115
call    0 never executed
    #####:17322:}
        -:17323:
        -:17324:// Problem:
        -:17325://   Undocking a large (~full screen) window would leave it so large that the bottom right sizing corner would more
        -:17326://   than likely be off the screen and the window would be hard to resize to fit on screen. This can be particularly problematic
        -:17327://   with 'ConfigWindowsMoveFromTitleBarOnly=true' and/or with 'ConfigWindowsResizeFromEdges=false' as well (the later can be
        -:17328://   due to missing ImGuiBackendFlags_HasMouseCursors backend flag).
        -:17329:// Solution:
        -:17330://   When undocking a window we currently force its maximum size to 90% of the host viewport or monitor.
        -:17331:// Reevaluate this when we implement preserving docked/undocked size ("docking_wip/undocked_size" branch).
function _ZL28FixLargeWindowsWhenUndockingRK6ImVec2P13ImGuiViewport called 0 returned 0% blocks executed 0%
    #####:17332:static ImVec2 FixLargeWindowsWhenUndocking(const ImVec2& size, ImGuiViewport* ref_viewport)
        -:17333:{
    #####:17334:    if (ref_viewport == NULL)
    %%%%%:17334-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:17335:        return size;
    %%%%%:17335-block 3
        -:17336:
    #####:17337:    ImGuiContext& g = *GImGui;
    #####:17338:    ImVec2 max_size = ImTrunc(ref_viewport->WorkSize * 0.90f);
    %%%%%:17338-block 4
call    0 never executed
call    1 never executed
    #####:17339:    if (g.ConfigFlagsCurrFrame & ImGuiConfigFlags_ViewportsEnable)
branch  0 never executed (fallthrough)
branch  1 never executed
        -:17340:    {
    #####:17341:        const ImGuiPlatformMonitor* monitor = ImGui::GetViewportPlatformMonitor(ref_viewport);
    %%%%%:17341-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:17342:        max_size = ImTrunc(monitor->WorkSize * 0.90f);
    %%%%%:17342-block 8
call    0 never executed
call    1 never executed
        -:17343:    }
    #####:17344:    return ImMin(size, max_size);
    %%%%%:17344-block 11
call    0 never executed
        -:17345:}
        -:17346:
function _ZN5ImGui30DockContextProcessUndockWindowEP12ImGuiContextP11ImGuiWindowb called 0 returned 0% blocks executed 0%
    #####:17347:void ImGui::DockContextProcessUndockWindow(ImGuiContext* ctx, ImGuiWindow* window, bool clear_persistent_docking_ref)
        -:17348:{
    #####:17349:    ImGuiContext& g = *ctx;
    #####:17350:    IMGUI_DEBUG_LOG_DOCKING("[docking] DockContextProcessUndockWindow window '%s', clear_persistent_docking_ref = %d\n", window->Name, clear_persistent_docking_ref);
    %%%%%:17350-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17350-block 3
call    2 never executed
    #####:17351:    if (window->DockNode)
    %%%%%:17351-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:17352:        DockNodeRemoveWindow(window->DockNode, window, clear_persistent_docking_ref ? 0 : window->DockId);
    %%%%%:17352-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17352-block 6
    %%%%%:17352-block 7
    %%%%%:17352-block 8
call    2 never executed
        -:17353:    else
    #####:17354:        window->DockId = 0;
    %%%%%:17354-block 9
    #####:17355:    window->Collapsed = false;
    #####:17356:    window->DockIsActive = false;
    #####:17357:    window->DockNodeIsVisible = window->DockTabIsVisible = false;
    #####:17358:    window->Size = window->SizeFull = FixLargeWindowsWhenUndocking(window->SizeFull, window->Viewport);
    %%%%%:17358-block 10
call    0 never executed
        -:17359:
    #####:17360:    MarkIniSettingsDirty();
call    0 never executed
    #####:17361:}
        -:17362:
function _ZN5ImGui28DockContextProcessUndockNodeEP12ImGuiContextP13ImGuiDockNode called 0 returned 0% blocks executed 0%
    #####:17363:void ImGui::DockContextProcessUndockNode(ImGuiContext* ctx, ImGuiDockNode* node)
        -:17364:{
    #####:17365:    ImGuiContext& g = *ctx;
    #####:17366:    IMGUI_DEBUG_LOG_DOCKING("[docking] DockContextProcessUndockNode node %08X\n", node->ID);
    %%%%%:17366-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17366-block 3
call    2 never executed
    #####:17367:    IM_ASSERT(node->IsLeafNode());
    %%%%%:17367-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:17367-block 6
call    3 never executed
    #####:17368:    IM_ASSERT(node->Windows.Size >= 1);
    %%%%%:17368-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17368-block 8
call    2 never executed
        -:17369:
    #####:17370:    if (node->IsRootNode() || node->IsCentralNode())
    %%%%%:17370-block 9
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:17370-block 11
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:17370-block 13
    %%%%%:17370-block 14
    %%%%%:17370-block 15
branch  6 never executed (fallthrough)
branch  7 never executed
        -:17371:    {
        -:17372:        // In the case of a root node or central node, the node will have to stay in place. Create a new node to receive the payload.
    #####:17373:        ImGuiDockNode* new_node = DockContextAddNode(ctx, 0);
    %%%%%:17373-block 16
call    0 never executed
    #####:17374:        new_node->Pos = node->Pos;
    #####:17375:        new_node->Size = node->Size;
    #####:17376:        new_node->SizeRef = node->SizeRef;
    #####:17377:        DockNodeMoveWindows(new_node, node);
call    0 never executed
    #####:17378:        DockSettingsRenameNodeReferences(node->ID, new_node->ID);
call    0 never executed
    #####:17379:        node = new_node;
        -:17380:    }
        -:17381:    else
        -:17382:    {
        -:17383:        // Otherwise extract our node and merge our sibling back into the parent node.
    #####:17384:        IM_ASSERT(node->ParentNode->ChildNodes[0] == node || node->ParentNode->ChildNodes[1] == node);
    %%%%%:17384-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17384-block 21
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:17384-block 22
call    4 never executed
    #####:17385:        int index_in_parent = (node->ParentNode->ChildNodes[0] == node) ? 0 : 1;
    #####:17386:        node->ParentNode->ChildNodes[index_in_parent] = NULL;
    #####:17387:        DockNodeTreeMerge(ctx, node->ParentNode, node->ParentNode->ChildNodes[index_in_parent ^ 1]);
    %%%%%:17387-block 23
call    0 never executed
    #####:17388:        node->ParentNode->AuthorityForViewport = ImGuiDataAuthority_Window; // The node that stays in place keeps the viewport, so our newly dragged out node will create a new viewport
    #####:17389:        node->ParentNode = NULL;
        -:17390:    }
    #####:17391:    for (ImGuiWindow* window : node->Windows)
    %%%%%:17391-block 25
call    0 never executed
call    1 never executed
    %%%%%:17391-block 31
branch  2 never executed
branch  3 never executed (fallthrough)
        -:17392:    {
    #####:17393:        window->Flags &= ~ImGuiWindowFlags_ChildWindow;
    #####:17394:        if (window->ParentWindow)
    %%%%%:17394-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:17395:            window->ParentWindow->DC.ChildWindows.find_erase(window);
    %%%%%:17395-block 28
call    0 never executed
    #####:17396:        UpdateWindowParentAndRootLinks(window, window->Flags, NULL);
    %%%%%:17396-block 29
call    0 never executed
        -:17397:    }
    #####:17398:    node->AuthorityForPos = node->AuthorityForSize = ImGuiDataAuthority_DockNode;
    #####:17399:    node->Size = FixLargeWindowsWhenUndocking(node->Size, node->Windows[0]->Viewport);
    %%%%%:17399-block 32
call    0 never executed
call    1 never executed
    #####:17400:    node->WantMouseMove = true;
    #####:17401:    MarkIniSettingsDirty();
call    0 never executed
    #####:17402:}
        -:17403:
        -:17404:// This is mostly used for automation.
function _ZN5ImGui32DockContextCalcDropPosForDockingEP11ImGuiWindowP13ImGuiDockNodeS1_S3_8ImGuiDirbP6ImVec2 called 0 returned 0% blocks executed 0%
    #####:17405:bool ImGui::DockContextCalcDropPosForDocking(ImGuiWindow* target, ImGuiDockNode* target_node, ImGuiWindow* payload_window, ImGuiDockNode* payload_node, ImGuiDir split_dir, bool split_outer, ImVec2* out_pos)
        -:17406:{
    #####:17407:    if (target != NULL && target_node == NULL)
    %%%%%:17407-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17407-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:17408:        target_node = target->DockNode;
    %%%%%:17408-block 4
        -:17409:
        -:17410:    // In DockNodePreviewDockSetup() for a root central node instead of showing both "inner" and "outer" drop rects
        -:17411:    // (which would be functionally identical) we only show the outer one. Reflect this here.
    #####:17412:    if (target_node && target_node->ParentNode == NULL && target_node->IsCentralNode() && split_dir != ImGuiDir_None)
    %%%%%:17412-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17412-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:17412-block 7
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:17412-block 9
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%:17412-block 10
    %%%%%:17412-block 11
    %%%%%:17412-block 12
branch  9 never executed (fallthrough)
branch 10 never executed
    #####:17413:        split_outer = true;
    %%%%%:17413-block 13
    #####:17414:    ImGuiDockPreviewData split_data;
    %%%%%:17414-block 14
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:17415:    DockNodePreviewDockSetup(target, target_node, payload_window, payload_node, &split_data, false, split_outer);
    %%%%%:17415-block 15
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:17416:    if (split_data.DropRectsDraw[split_dir+1].IsInverted())
    %%%%%:17416-block 16
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:17417:        return false;
    %%%%%:17417-block 18
    #####:17418:    *out_pos = split_data.DropRectsDraw[split_dir+1].GetCenter();
    %%%%%:17418-block 19
call    0 never executed
    #####:17419:    return true;
    #####:17420:}
    %%%%%:17420-block 21
call    0 never executed
    $$$$$:17420-block 24
call    1 never executed
        -:17421:
        -:17422://-----------------------------------------------------------------------------
        -:17423:// Docking: ImGuiDockNode
        -:17424://-----------------------------------------------------------------------------
        -:17425:// - DockNodeGetTabOrder()
        -:17426:// - DockNodeAddWindow()
        -:17427:// - DockNodeRemoveWindow()
        -:17428:// - DockNodeMoveChildNodes()
        -:17429:// - DockNodeMoveWindows()
        -:17430:// - DockNodeApplyPosSizeToWindows()
        -:17431:// - DockNodeHideHostWindow()
        -:17432:// - ImGuiDockNodeFindInfoResults
        -:17433:// - DockNodeFindInfo()
        -:17434:// - DockNodeFindWindowByID()
        -:17435:// - DockNodeUpdateFlagsAndCollapse()
        -:17436:// - DockNodeUpdateHasCentralNodeFlag()
        -:17437:// - DockNodeUpdateVisibleFlag()
        -:17438:// - DockNodeStartMouseMovingWindow()
        -:17439:// - DockNodeUpdate()
        -:17440:// - DockNodeUpdateWindowMenu()
        -:17441:// - DockNodeBeginAmendTabBar()
        -:17442:// - DockNodeEndAmendTabBar()
        -:17443:// - DockNodeUpdateTabBar()
        -:17444:// - DockNodeAddTabBar()
        -:17445:// - DockNodeRemoveTabBar()
        -:17446:// - DockNodeIsDropAllowedOne()
        -:17447:// - DockNodeIsDropAllowed()
        -:17448:// - DockNodeCalcTabBarLayout()
        -:17449:// - DockNodeCalcSplitRects()
        -:17450:// - DockNodeCalcDropRectsAndTestMousePos()
        -:17451:// - DockNodePreviewDockSetup()
        -:17452:// - DockNodePreviewDockRender()
        -:17453://-----------------------------------------------------------------------------
        -:17454:
function _ZN13ImGuiDockNodeC2Ej called 9 returned 100% blocks executed 100%
        9:17455:ImGuiDockNode::ImGuiDockNode(ImGuiID id)
        9:17455-block 2
call    0 returned 9
call    1 returned 9
call    2 returned 9
call    3 returned 9
call    4 returned 9
        -:17456:{
        9:17457:    ID = id;
        9:17458:    SharedFlags = LocalFlags = LocalFlagsInWindows = MergedFlags = ImGuiDockNodeFlags_None;
        9:17459:    ParentNode = ChildNodes[0] = ChildNodes[1] = NULL;
        9:17460:    TabBar = NULL;
        9:17461:    SplitAxis = ImGuiAxis_None;
        -:17462:
        9:17463:    State = ImGuiDockNodeState_Unknown;
        9:17464:    LastBgColor = IM_COL32_WHITE;
        9:17465:    HostWindow = VisibleWindow = NULL;
        9:17466:    CentralNode = OnlyNodeWithWindows = NULL;
        9:17467:    CountNodeWithWindows = 0;
        9:17468:    LastFrameAlive = LastFrameActive = LastFrameFocused = -1;
        9:17469:    LastFocusedNodeId = 0;
        9:17470:    SelectedTabId = 0;
        9:17471:    WantCloseTabId = 0;
        9:17472:    RefViewportId = 0;
        9:17473:    AuthorityForPos = AuthorityForSize = ImGuiDataAuthority_DockNode;
        9:17474:    AuthorityForViewport = ImGuiDataAuthority_Auto;
        9:17475:    IsVisible = true;
        9:17476:    IsFocused = HasCloseButton = HasWindowMenuButton = HasCentralNodeChild = false;
        9:17477:    IsBgDrawnThisFrame = false;
        9:17478:    WantCloseAll = WantLockSizeOnce = WantMouseMove = WantHiddenTabBarUpdate = WantHiddenTabBarToggle = false;
        9:17479:}
        -:17480:
function _ZN13ImGuiDockNodeD2Ev called 9 returned 100% blocks executed 100%
        9:17481:ImGuiDockNode::~ImGuiDockNode()
        -:17482:{
        9:17483:    IM_DELETE(TabBar);
        9:17483-block 2
call    0 returned 9
        9:17484:    TabBar = NULL;
        9:17485:    ChildNodes[0] = ChildNodes[1] = NULL;
        9:17486:}
call    0 returned 9
        -:17487:
function _ZN5ImGuiL19DockNodeGetTabOrderEP11ImGuiWindow called 5380 returned 100% blocks executed 78%
     5380:17488:int ImGui::DockNodeGetTabOrder(ImGuiWindow* window)
        -:17489:{
     5380:17490:    ImGuiTabBar* tab_bar = window->DockNode->TabBar;
     5380:17491:    if (tab_bar == NULL)
     5380:17491-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    #####:17492:        return -1;
    %%%%%:17492-block 3
     5380:17493:    ImGuiTabItem* tab = TabBarFindTabByID(tab_bar, window->TabId);
     5380:17493-block 4
call    0 returned 5380
    5380*:17494:    return tab ? TabBarGetTabOrder(tab_bar, tab) : -1;
branch  0 taken 5380 (fallthrough)
branch  1 taken 0
     5380:17494-block 6
call    2 returned 5380
    %%%%%:17494-block 8
     5380:17494-block 9
        -:17495:}
        -:17496:
function _ZL42DockNodeHideWindowDuringHostWindowCreationP11ImGuiWindow called 0 returned 0% blocks executed 0%
    #####:17497:static void DockNodeHideWindowDuringHostWindowCreation(ImGuiWindow* window)
        -:17498:{
    #####:17499:    window->Hidden = true;
    #####:17500:    window->HiddenFramesCanSkipItems = window->Active ? 1 : 2;
    %%%%%:17500-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17500-block 3
    %%%%%:17500-block 4
    #####:17501:}
        -:17502:
function _ZN5ImGuiL17DockNodeAddWindowEP13ImGuiDockNodeP11ImGuiWindowb called 5 returned 100% blocks executed 45%
        5:17503:static void ImGui::DockNodeAddWindow(ImGuiDockNode* node, ImGuiWindow* window, bool add_to_tab_bar)
        -:17504:{
        5:17505:    ImGuiContext& g = *GImGui; (void)g;
        5:17506:    if (window->DockNode)
        5:17506-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 5
        -:17507:    {
        -:17508:        // Can overwrite an existing window->DockNode (e.g. pointing to a disabled DockSpace node)
    #####:17509:        IM_ASSERT(window->DockNode->ID != node->ID);
    %%%%%:17509-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17509-block 4
call    2 never executed
    #####:17510:        DockNodeRemoveWindow(window->DockNode, window, 0);
    %%%%%:17510-block 5
call    0 never executed
        -:17511:    }
       5*:17512:    IM_ASSERT(window->DockNode == NULL || window->DockNodeAsHost == NULL);
        5:17512-block 6
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    %%%%%:17512-block 7
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:17512-block 8
call    4 never executed
       5*:17513:    IMGUI_DEBUG_LOG_DOCKING("[docking] DockNodeAddWindow node 0x%08X window '%s'\n", node->ID, window->Name);
        5:17513-block 9
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    %%%%%:17513-block 10
call    2 never executed
        -:17514:
        -:17515:    // If more than 2 windows appeared on the same frame leading to the creation of a new hosting window,
        -:17516:    // we'll hide windows until the host window is ready. Hide the 1st window after its been output (so it is not visible for one frame).
        -:17517:    // We will call DockNodeHideWindowDuringHostWindowCreation() on ourselves in Begin()
       5*:17518:    if (node->HostWindow == NULL && node->Windows.Size == 1 && node->Windows[0]->WasActive == false)
        5:17518-block 11
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    %%%%%:17518-block 12
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:17518-block 13
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:17518-block 15
        5:17518-block 16
        5:17518-block 17
branch  7 taken 0 (fallthrough)
branch  8 taken 5
    #####:17519:        DockNodeHideWindowDuringHostWindowCreation(node->Windows[0]);
    %%%%%:17519-block 18
call    0 never executed
call    1 never executed
        -:17520:
        5:17521:    node->Windows.push_back(window);
        5:17521-block 20
call    0 returned 5
        5:17522:    node->WantHiddenTabBarUpdate = true;
        5:17523:    window->DockNode = node;
        5:17524:    window->DockId = node->ID;
        5:17525:    window->DockIsActive = (node->Windows.Size > 1);
        5:17526:    window->DockTabWantClose = false;
        -:17527:
        -:17528:    // When reactivating a node with one or two loose window, the window pos/size/viewport are authoritative over the node storage.
        -:17529:    // In particular it is important we init the viewport from the first window so we don't create two viewports and drop one.
       5*:17530:    if (node->HostWindow == NULL && node->IsFloatingNode())
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    %%%%%:17530-block 22
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:17530-block 24
        5:17530-block 25
        5:17530-block 26
branch  5 taken 0 (fallthrough)
branch  6 taken 5
        -:17531:    {
    #####:17532:        if (node->AuthorityForPos == ImGuiDataAuthority_Auto)
    %%%%%:17532-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:17533:            node->AuthorityForPos = ImGuiDataAuthority_Window;
    %%%%%:17533-block 28
    #####:17534:        if (node->AuthorityForSize == ImGuiDataAuthority_Auto)
    %%%%%:17534-block 29
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:17535:            node->AuthorityForSize = ImGuiDataAuthority_Window;
    %%%%%:17535-block 30
    #####:17536:        if (node->AuthorityForViewport == ImGuiDataAuthority_Auto)
    %%%%%:17536-block 31
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:17537:            node->AuthorityForViewport = ImGuiDataAuthority_Window;
    %%%%%:17537-block 32
        -:17538:    }
        -:17539:
        -:17540:    // Add to tab bar if requested
        5:17541:    if (add_to_tab_bar)
        5:17541-block 33
branch  0 taken 5 (fallthrough)
branch  1 taken 0
        -:17542:    {
        5:17543:        if (node->TabBar == NULL)
        5:17543-block 34
branch  0 taken 5 (fallthrough)
branch  1 taken 0
        -:17544:        {
        5:17545:            DockNodeAddTabBar(node);
        5:17545-block 35
call    0 returned 5
        5:17546:            node->TabBar->SelectedTabId = node->TabBar->NextSelectedTabId = node->SelectedTabId;
        -:17547:
        -:17548:            // Add existing windows
       5*:17549:            for (int n = 0; n < node->Windows.Size - 1; n++)
        5:17549-block 40
branch  0 taken 0
branch  1 taken 5 (fallthrough)
    #####:17550:                TabBarAddTab(node->TabBar, ImGuiTabItemFlags_None, node->Windows[n]);
    %%%%%:17550-block 37
call    0 never executed
call    1 never executed
        -:17551:        }
        5:17552:        TabBarAddTab(node->TabBar, ImGuiTabItemFlags_Unsorted, window);
        5:17552-block 41
call    0 returned 5
        -:17553:    }
        -:17554:
        5:17555:    DockNodeUpdateVisibleFlag(node);
        5:17555-block 42
call    0 returned 5
        -:17556:
        -:17557:    // Update this without waiting for the next time we Begin() in the window, so our host window will have the proper title bar color on its first frame.
        5:17558:    if (node->HostWindow)
branch  0 taken 5 (fallthrough)
branch  1 taken 0
        5:17559:        UpdateWindowParentAndRootLinks(window, window->Flags | ImGuiWindowFlags_ChildWindow, node->HostWindow);
        5:17559-block 44
call    0 returned 5
        5:17560:}
        -:17561:
function _ZN5ImGuiL20DockNodeRemoveWindowEP13ImGuiDockNodeP11ImGuiWindowj called 0 returned 0% blocks executed 0%
    #####:17562:static void ImGui::DockNodeRemoveWindow(ImGuiDockNode* node, ImGuiWindow* window, ImGuiID save_dock_id)
        -:17563:{
    #####:17564:    ImGuiContext& g = *GImGui;
    #####:17565:    IM_ASSERT(window->DockNode == node);
    %%%%%:17565-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17565-block 3
call    2 never executed
        -:17566:    //IM_ASSERT(window->RootWindowDockTree == node->HostWindow);
        -:17567:    //IM_ASSERT(window->LastFrameActive < g.FrameCount);    // We may call this from Begin()
    #####:17568:    IM_ASSERT(save_dock_id == 0 || save_dock_id == node->ID);
    %%%%%:17568-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17568-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:17568-block 6
call    4 never executed
    #####:17569:    IMGUI_DEBUG_LOG_DOCKING("[docking] DockNodeRemoveWindow node 0x%08X window '%s'\n", node->ID, window->Name);
    %%%%%:17569-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17569-block 8
call    2 never executed
        -:17570:
    #####:17571:    window->DockNode = NULL;
    #####:17572:    window->DockIsActive = window->DockTabWantClose = false;
    #####:17573:    window->DockId = save_dock_id;
    #####:17574:    window->Flags &= ~ImGuiWindowFlags_ChildWindow;
    #####:17575:    if (window->ParentWindow)
    %%%%%:17575-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:17576:        window->ParentWindow->DC.ChildWindows.find_erase(window);
    %%%%%:17576-block 10
call    0 never executed
    #####:17577:    UpdateWindowParentAndRootLinks(window, window->Flags, NULL); // Update immediately
    %%%%%:17577-block 11
call    0 never executed
        -:17578:
    #####:17579:    if (node->HostWindow && node->HostWindow->ViewportOwned)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17579-block 13
branch  2 never executed (fallthrough)
branch  3 never executed
        -:17580:    {
        -:17581:        // When undocking from a user interaction this will always run in NewFrame() and have not much effect.
        -:17582:        // But mid-frame, if we clear viewport we need to mark window as hidden as well.
    #####:17583:        window->Viewport = NULL;
    #####:17584:        window->ViewportId = 0;
    #####:17585:        window->ViewportOwned = false;
    #####:17586:        window->Hidden = true;
    %%%%%:17586-block 14
        -:17587:    }
        -:17588:
        -:17589:    // Remove window
    #####:17590:    bool erased = false;
    #####:17591:    for (int n = 0; n < node->Windows.Size; n++)
    %%%%%:17591-block 15
    %%%%%:17591-block 20
    %%%%%:17591-block 21
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:17592:        if (node->Windows[n] == window)
    %%%%%:17592-block 16
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -:17593:        {
    #####:17594:            node->Windows.erase(node->Windows.Data + n);
    %%%%%:17594-block 18
call    0 never executed
    #####:17595:            erased = true;
    #####:17596:            break;
        -:17597:        }
    #####:17598:    if (!erased)
    %%%%%:17598-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:17599:        IM_ASSERT(erased);
    %%%%%:17599-block 23
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17599-block 24
call    2 never executed
    #####:17600:    if (node->VisibleWindow == window)
    %%%%%:17600-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:17601:        node->VisibleWindow = NULL;
    %%%%%:17601-block 26
        -:17602:
        -:17603:    // Remove tab and possibly tab bar
    #####:17604:    node->WantHiddenTabBarUpdate = true;
    #####:17605:    if (node->TabBar)
    %%%%%:17605-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
        -:17606:    {
    #####:17607:        TabBarRemoveTab(node->TabBar, window->TabId);
    %%%%%:17607-block 28
call    0 never executed
    #####:17608:        const int tab_count_threshold_for_tab_bar = node->IsCentralNode() ? 1 : 2;
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:17608-block 31
    %%%%%:17608-block 32
    #####:17609:        if (node->Windows.Size < tab_count_threshold_for_tab_bar)
    %%%%%:17609-block 33
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:17610:            DockNodeRemoveTabBar(node);
    %%%%%:17610-block 34
call    0 never executed
        -:17611:    }
        -:17612:
    #####:17613:    if (node->Windows.Size == 0 && !node->IsCentralNode() && !node->IsDockSpace() && window->DockId != node->ID)
    %%%%%:17613-block 35
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17613-block 36
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:17613-block 38
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%:17613-block 40
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%:17613-block 41
    %%%%%:17613-block 42
    %%%%%:17613-block 43
branch 10 never executed (fallthrough)
branch 11 never executed
        -:17614:    {
        -:17615:        // Automatic dock node delete themselves if they are not holding at least one tab
    #####:17616:        DockContextRemoveNode(&g, node, true);
    %%%%%:17616-block 44
call    0 never executed
    #####:17617:        return;
        -:17618:    }
        -:17619:
    #####:17620:    if (node->Windows.Size == 1 && !node->IsCentralNode() && node->HostWindow)
    %%%%%:17620-block 46
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17620-block 47
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:17620-block 49
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:17620-block 50
    %%%%%:17620-block 51
    %%%%%:17620-block 52
branch  7 never executed (fallthrough)
branch  8 never executed
        -:17621:    {
    #####:17622:        ImGuiWindow* remaining_window = node->Windows[0];
    %%%%%:17622-block 53
call    0 never executed
        -:17623:        // Note: we used to transport viewport ownership here.
    #####:17624:        remaining_window->Collapsed = node->HostWindow->Collapsed;
        -:17625:    }
        -:17626:
        -:17627:    // Update visibility immediately is required so the DockNodeUpdateRemoveInactiveChilds() processing can reflect changes up the tree
    #####:17628:    DockNodeUpdateVisibleFlag(node);
    %%%%%:17628-block 55
call    0 never executed
        -:17629:}
        -:17630:
function _ZN5ImGuiL22DockNodeMoveChildNodesEP13ImGuiDockNodeS1_ called 0 returned 0% blocks executed 0%
    #####:17631:static void ImGui::DockNodeMoveChildNodes(ImGuiDockNode* dst_node, ImGuiDockNode* src_node)
        -:17632:{
    #####:17633:    IM_ASSERT(dst_node->Windows.Size == 0);
    %%%%%:17633-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17633-block 3
call    2 never executed
    #####:17634:    dst_node->ChildNodes[0] = src_node->ChildNodes[0];
    #####:17635:    dst_node->ChildNodes[1] = src_node->ChildNodes[1];
    #####:17636:    if (dst_node->ChildNodes[0])
    %%%%%:17636-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:17637:        dst_node->ChildNodes[0]->ParentNode = dst_node;
    %%%%%:17637-block 5
    #####:17638:    if (dst_node->ChildNodes[1])
    %%%%%:17638-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:17639:        dst_node->ChildNodes[1]->ParentNode = dst_node;
    %%%%%:17639-block 7
    #####:17640:    dst_node->SplitAxis = src_node->SplitAxis;
    #####:17641:    dst_node->SizeRef = src_node->SizeRef;
    #####:17642:    src_node->ChildNodes[0] = src_node->ChildNodes[1] = NULL;
    #####:17643:}
        -:17644:
function _ZN5ImGuiL19DockNodeMoveWindowsEP13ImGuiDockNodeS1_ called 0 returned 0% blocks executed 0%
    #####:17645:static void ImGui::DockNodeMoveWindows(ImGuiDockNode* dst_node, ImGuiDockNode* src_node)
        -:17646:{
        -:17647:    // Insert tabs in the same orders as currently ordered (node->Windows isn't ordered)
    #####:17648:    IM_ASSERT(src_node && dst_node && dst_node != src_node);
    %%%%%:17648-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17648-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:17648-block 4
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:17648-block 5
    %%%%%:17648-block 6
call    6 never executed
    #####:17649:    ImGuiTabBar* src_tab_bar = src_node->TabBar;
    #####:17650:    if (src_tab_bar != NULL)
    %%%%%:17650-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:17651:        IM_ASSERT(src_node->Windows.Size <= src_node->TabBar->Tabs.Size);
    %%%%%:17651-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17651-block 9
call    2 never executed
        -:17652:
        -:17653:    // If the dst_node is empty we can just move the entire tab bar (to preserve selection, scrolling, etc.)
    #####:17654:    bool move_tab_bar = (src_tab_bar != NULL) && (dst_node->TabBar == NULL);
    %%%%%:17654-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17654-block 11
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:17654-block 12
    %%%%%:17654-block 13
    #####:17655:    if (move_tab_bar)
    %%%%%:17655-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
        -:17656:    {
    #####:17657:        dst_node->TabBar = src_node->TabBar;
    #####:17658:        src_node->TabBar = NULL;
    %%%%%:17658-block 15
        -:17659:    }
        -:17660:
        -:17661:    // Tab order is not important here, it is preserved by sorting in DockNodeUpdateTabBar().
    #####:17662:    for (ImGuiWindow* window : src_node->Windows)
    %%%%%:17662-block 16
call    0 never executed
call    1 never executed
    %%%%%:17662-block 20
branch  2 never executed
branch  3 never executed (fallthrough)
        -:17663:    {
    #####:17664:        window->DockNode = NULL;
    #####:17665:        window->DockIsActive = false;
    #####:17666:        DockNodeAddWindow(dst_node, window, !move_tab_bar);
    %%%%%:17666-block 18
call    0 never executed
        -:17667:    }
    #####:17668:    src_node->Windows.clear();
    %%%%%:17668-block 21
call    0 never executed
        -:17669:
    #####:17670:    if (!move_tab_bar && src_node->TabBar)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17670-block 23
branch  2 never executed (fallthrough)
branch  3 never executed
        -:17671:    {
    #####:17672:        if (dst_node->TabBar)
    %%%%%:17672-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:17673:            dst_node->TabBar->SelectedTabId = src_node->TabBar->SelectedTabId;
    %%%%%:17673-block 25
    #####:17674:        DockNodeRemoveTabBar(src_node);
    %%%%%:17674-block 26
call    0 never executed
        -:17675:    }
    #####:17676:}
        -:17677:
function _ZN5ImGuiL29DockNodeApplyPosSizeToWindowsEP13ImGuiDockNode called 0 returned 0% blocks executed 0%
    #####:17678:static void ImGui::DockNodeApplyPosSizeToWindows(ImGuiDockNode* node)
        -:17679:{
    #####:17680:    for (ImGuiWindow* window : node->Windows)
    %%%%%:17680-block 2
call    0 never executed
call    1 never executed
    %%%%%:17680-block 7
branch  2 never executed
branch  3 never executed (fallthrough)
        -:17681:    {
    #####:17682:        SetWindowPos(window, node->Pos, ImGuiCond_Always); // We don't assign directly to Pos because it can break the calculation of SizeContents on next frame
    %%%%%:17682-block 4
call    0 never executed
    #####:17683:        SetWindowSize(window, node->Size, ImGuiCond_Always);
call    0 never executed
        -:17684:    }
    #####:17685:}
        -:17686:
function _ZN5ImGuiL22DockNodeHideHostWindowEP13ImGuiDockNode called 0 returned 0% blocks executed 0%
    #####:17687:static void ImGui::DockNodeHideHostWindow(ImGuiDockNode* node)
        -:17688:{
    #####:17689:    if (node->HostWindow)
    %%%%%:17689-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -:17690:    {
    #####:17691:        if (node->HostWindow->DockNodeAsHost == node)
    %%%%%:17691-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:17692:            node->HostWindow->DockNodeAsHost = NULL;
    %%%%%:17692-block 4
    #####:17693:        node->HostWindow = NULL;
    %%%%%:17693-block 5
        -:17694:    }
        -:17695:
    #####:17696:    if (node->Windows.Size == 1)
    %%%%%:17696-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
        -:17697:    {
    #####:17698:        node->VisibleWindow = node->Windows[0];
    %%%%%:17698-block 7
call    0 never executed
    #####:17699:        node->Windows[0]->DockIsActive = false;
call    0 never executed
        -:17700:    }
        -:17701:
    #####:17702:    if (node->TabBar)
    %%%%%:17702-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:17703:        DockNodeRemoveTabBar(node);
    %%%%%:17703-block 11
call    0 never executed
    #####:17704:}
        -:17705:
        -:17706:// Search function called once by root node in DockNodeUpdate()
        -:17707:struct ImGuiDockNodeTreeInfo
        -:17708:{
        -:17709:    ImGuiDockNode*      CentralNode;
        -:17710:    ImGuiDockNode*      FirstNodeWithWindows;
        -:17711:    int                 CountNodesWithWindows;
        -:17712:    //ImGuiWindowClass  WindowClassForMerges;
        -:17713:
function _ZN21ImGuiDockNodeTreeInfoC2Ev called 1077 returned 100% blocks executed 100%
     1077:17714:    ImGuiDockNodeTreeInfo() { memset(this, 0, sizeof(*this)); }
        -:17715:};
        -:17716:
function _ZL16DockNodeFindInfoP13ImGuiDockNodeP21ImGuiDockNodeTreeInfo called 9693 returned 100% blocks executed 90%
     9693:17717:static void DockNodeFindInfo(ImGuiDockNode* node, ImGuiDockNodeTreeInfo* info)
        -:17718:{
     9693:17719:    if (node->Windows.Size > 0)
     9693:17719-block 2
branch  0 taken 5380 (fallthrough)
branch  1 taken 4313
        -:17720:    {
     5380:17721:        if (info->FirstNodeWithWindows == NULL)
     5380:17721-block 3
branch  0 taken 1076 (fallthrough)
branch  1 taken 4304
     1076:17722:            info->FirstNodeWithWindows = node;
     1076:17722-block 4
     5380:17723:        info->CountNodesWithWindows++;
     5380:17723-block 5
        -:17724:    }
     9693:17725:    if (node->IsCentralNode())
     9693:17725-block 6
call    0 returned 9693
branch  1 taken 1077 (fallthrough)
branch  2 taken 8616
        -:17726:    {
    1077*:17727:        IM_ASSERT(info->CentralNode == NULL); // Should be only one
     1077:17727-block 8
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:17727-block 9
call    2 never executed
    1077*:17728:        IM_ASSERT(node->IsLeafNode() && "If you get this assert: please submit .ini file + repro of actions leading to this.");
     1077:17728-block 10
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0
     1077:17728-block 12
    %%%%%:17728-block 13
call    3 never executed
     1077:17729:        info->CentralNode = node;
     1077:17729-block 14
        -:17730:    }
     9693:17731:    if (info->CountNodesWithWindows > 1 && info->CentralNode != NULL)
     9693:17731-block 15
branch  0 taken 5380 (fallthrough)
branch  1 taken 4313
     5380:17731-block 16
branch  2 taken 2152 (fallthrough)
branch  3 taken 3228
     2152:17732:        return;
     2152:17732-block 17
     7541:17733:    if (node->ChildNodes[0])
     7541:17733-block 18
branch  0 taken 4308 (fallthrough)
branch  1 taken 3233
     4308:17734:        DockNodeFindInfo(node->ChildNodes[0], info);
     4308:17734-block 19
call    0 returned 4308
     7541:17735:    if (node->ChildNodes[1])
     7541:17735-block 20
branch  0 taken 4308 (fallthrough)
branch  1 taken 3233
     4308:17736:        DockNodeFindInfo(node->ChildNodes[1], info);
     4308:17736-block 21
call    0 returned 4308
        -:17737:}
        -:17738:
function _ZN5ImGuiL22DockNodeFindWindowByIDEP13ImGuiDockNodej called 0 returned 0% blocks executed 0%
    #####:17739:static ImGuiWindow* ImGui::DockNodeFindWindowByID(ImGuiDockNode* node, ImGuiID id)
        -:17740:{
    #####:17741:    IM_ASSERT(id != 0);
    %%%%%:17741-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17741-block 3
call    2 never executed
    #####:17742:    for (ImGuiWindow* window : node->Windows)
    %%%%%:17742-block 4
call    0 never executed
call    1 never executed
    %%%%%:17742-block 8
    %%%%%:17742-block 9
branch  2 never executed
branch  3 never executed (fallthrough)
    #####:17743:        if (window->ID == id)
    %%%%%:17743-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:17744:            return window;
    %%%%%:17744-block 7
    #####:17745:    return NULL;
    %%%%%:17745-block 10
        -:17746:}
        -:17747:
        -:17748:// - Remove inactive windows/nodes.
        -:17749:// - Update visibility flag.
function _ZN5ImGuiL30DockNodeUpdateFlagsAndCollapseEP13ImGuiDockNode called 9693 returned 100% blocks executed 57%
     9693:17750:static void ImGui::DockNodeUpdateFlagsAndCollapse(ImGuiDockNode* node)
        -:17751:{
     9693:17752:    ImGuiContext& g = *GImGui;
    9693*:17753:    IM_ASSERT(node->ParentNode == NULL || node->ParentNode->ChildNodes[0] == node || node->ParentNode->ChildNodes[1] == node);
     9693:17753-block 2
branch  0 taken 8616 (fallthrough)
branch  1 taken 1077
     8616:17753-block 3
branch  2 taken 4308 (fallthrough)
branch  3 taken 4308
     4308:17753-block 4
branch  4 taken 0 (fallthrough)
branch  5 taken 4308
    %%%%%:17753-block 5
call    6 never executed
        -:17754:
        -:17755:    // Inherit most flags
     9693:17756:    if (node->ParentNode)
     9693:17756-block 6
branch  0 taken 8616 (fallthrough)
branch  1 taken 1077
     8616:17757:        node->SharedFlags = node->ParentNode->SharedFlags & ImGuiDockNodeFlags_SharedFlagsInheritMask_;
     8616:17757-block 7
        -:17758:
        -:17759:    // Recurse into children
        -:17760:    // There is the possibility that one of our child becoming empty will delete itself and moving its sibling contents into 'node'.
        -:17761:    // If 'node->ChildNode[0]' delete itself, then 'node->ChildNode[1]->Windows' will be moved into 'node'
        -:17762:    // If 'node->ChildNode[1]' delete itself, then 'node->ChildNode[0]->Windows' will be moved into 'node' and the "remove inactive windows" loop will have run twice on those windows (harmless)
     9693:17763:    node->HasCentralNodeChild = false;
     9693:17764:    if (node->ChildNodes[0])
     9693:17764-block 8
branch  0 taken 4308 (fallthrough)
branch  1 taken 5385
     4308:17765:        DockNodeUpdateFlagsAndCollapse(node->ChildNodes[0]);
     4308:17765-block 9
call    0 returned 4308
     9693:17766:    if (node->ChildNodes[1])
     9693:17766-block 10
branch  0 taken 4308 (fallthrough)
branch  1 taken 5385
     4308:17767:        DockNodeUpdateFlagsAndCollapse(node->ChildNodes[1]);
     4308:17767-block 11
call    0 returned 4308
        -:17768:
        -:17769:    // Remove inactive windows, collapse nodes
        -:17770:    // Merge node flags overrides stored in windows
     9693:17771:    node->LocalFlagsInWindows = ImGuiDockNodeFlags_None;
    15073:17772:    for (int window_n = 0; window_n < node->Windows.Size; window_n++)
     9693:17772-block 12
     5380:17772-block 40
    15073:17772-block 41
branch  0 taken 5380
branch  1 taken 9693 (fallthrough)
        -:17773:    {
     5380:17774:        ImGuiWindow* window = node->Windows[window_n];
     5380:17774-block 13
call    0 returned 5380
    5380*:17775:        IM_ASSERT(window->DockNode == node);
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    %%%%%:17775-block 15
call    2 never executed
        -:17776:
     5380:17777:        bool node_was_active = (node->LastFrameActive + 1 == g.FrameCount);
     5380:17778:        bool remove = false;
    5380*:17779:        remove |= node_was_active && (window->LastFrameActive + 1 < g.FrameCount);
     5380:17779-block 16
branch  0 taken 5380 (fallthrough)
branch  1 taken 0
     5380:17779-block 17
branch  2 taken 0 (fallthrough)
branch  3 taken 5380
    %%%%%:17779-block 18
     5380:17779-block 19
    5380*:17780:        remove |= node_was_active && (node->WantCloseAll || node->WantCloseTabId == window->TabId) && window->HasCloseButton && !(window->Flags & ImGuiWindowFlags_UnsavedDocument);  // Submit all _expected_ closure from last frame
     5380:17780-block 20
branch  0 taken 5380 (fallthrough)
branch  1 taken 0
     5380:17780-block 21
branch  2 taken 5380 (fallthrough)
branch  3 taken 0
     5380:17780-block 22
branch  4 taken 0 (fallthrough)
branch  5 taken 5380
    %%%%%:17780-block 23
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%:17780-block 24
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%:17780-block 25
     5380:17780-block 26
     5380:17781:        remove |= (window->DockTabWantClose);
    5380*:17782:        if (remove)
     5380:17782-block 27
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
        -:17783:        {
    #####:17784:            window->DockTabWantClose = false;
    #####:17785:            if (node->Windows.Size == 1 && !node->IsCentralNode())
    %%%%%:17785-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17785-block 29
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:17785-block 31
    %%%%%:17785-block 32
    %%%%%:17785-block 33
branch  5 never executed (fallthrough)
branch  6 never executed
        -:17786:            {
    #####:17787:                DockNodeHideHostWindow(node);
    %%%%%:17787-block 34
call    0 never executed
    #####:17788:                node->State = ImGuiDockNodeState_HostWindowHiddenBecauseSingleWindow;
    #####:17789:                DockNodeRemoveWindow(node, window, node->ID); // Will delete the node so it'll be invalid on return
call    0 never executed
    #####:17790:                return;
        -:17791:            }
    #####:17792:            DockNodeRemoveWindow(node, window, node->ID);
    %%%%%:17792-block 37
call    0 never executed
    #####:17793:            window_n--;
    #####:17794:            continue;
        -:17795:        }
        -:17796:
        -:17797:        // FIXME-DOCKING: Missing policies for conflict resolution, hence the "Experimental" tag on this.
        -:17798:        //node->LocalFlagsInWindow &= ~window->WindowClass.DockNodeFlagsOverrideClear;
     5380:17799:        node->LocalFlagsInWindows |= window->WindowClass.DockNodeFlagsOverrideSet;
     5380:17799-block 39
        -:17800:    }
     9693:17801:    node->UpdateMergedFlags();
     9693:17801-block 42
call    0 returned 9693
        -:17802:
        -:17803:    // Auto-hide tab bar option
     9693:17804:    ImGuiDockNodeFlags node_flags = node->MergedFlags;
    9693*:17805:    if (node->WantHiddenTabBarUpdate && node->Windows.Size == 1 && (node_flags & ImGuiDockNodeFlags_AutoHideTabBar) && !node->IsHiddenTabBar())
branch  0 taken 5 (fallthrough)
branch  1 taken 9688
        5:17805-block 44
branch  2 taken 5 (fallthrough)
branch  3 taken 0
        5:17805-block 45
branch  4 taken 0 (fallthrough)
branch  5 taken 5
    %%%%%:17805-block 46
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%:17805-block 48
     9693:17805-block 49
     9693:17805-block 50
branch  9 taken 0 (fallthrough)
branch 10 taken 9693
    #####:17806:        node->WantHiddenTabBarToggle = true;
    %%%%%:17806-block 51
     9693:17807:    node->WantHiddenTabBarUpdate = false;
        -:17808:
        -:17809:    // Cancel toggling if we know our tab bar is enforced to be hidden at all times
    9693*:17810:    if (node->WantHiddenTabBarToggle && node->VisibleWindow && (node->VisibleWindow->WindowClass.DockNodeFlagsOverrideSet & ImGuiDockNodeFlags_HiddenTabBar))
     9693:17810-block 52
branch  0 taken 0 (fallthrough)
branch  1 taken 9693
    %%%%%:17810-block 53
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:17810-block 54
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:17811:        node->WantHiddenTabBarToggle = false;
    %%%%%:17811-block 55
        -:17812:
        -:17813:    // Apply toggles at a single point of the frame (here!)
     9693:17814:    if (node->Windows.Size > 1)
     9693:17814-block 56
branch  0 taken 0 (fallthrough)
branch  1 taken 9693
    #####:17815:        node->SetLocalFlags(node->LocalFlags & ~ImGuiDockNodeFlags_HiddenTabBar);
    %%%%%:17815-block 57
call    0 never executed
     9693:17816:    else if (node->WantHiddenTabBarToggle)
     9693:17816-block 58
branch  0 taken 0 (fallthrough)
branch  1 taken 9693
    #####:17817:        node->SetLocalFlags(node->LocalFlags ^ ImGuiDockNodeFlags_HiddenTabBar);
    %%%%%:17817-block 59
call    0 never executed
     9693:17818:    node->WantHiddenTabBarToggle = false;
        -:17819:
     9693:17820:    DockNodeUpdateVisibleFlag(node);
     9693:17820-block 60
call    0 returned 9693
        -:17821:}
        -:17822:
        -:17823:// This is rarely called as DockNodeUpdateForRootNode() generally does it most frames.
function _ZN5ImGuiL33DockNodeUpdateHasCentralNodeChildEP13ImGuiDockNode called 36 returned 100% blocks executed 100%
       36:17824:static void ImGui::DockNodeUpdateHasCentralNodeChild(ImGuiDockNode* node)
        -:17825:{
       36:17826:    node->HasCentralNodeChild = false;
       36:17827:    if (node->ChildNodes[0])
       36:17827-block 2
branch  0 taken 16 (fallthrough)
branch  1 taken 20
       16:17828:        DockNodeUpdateHasCentralNodeChild(node->ChildNodes[0]);
       16:17828-block 3
call    0 returned 16
       36:17829:    if (node->ChildNodes[1])
       36:17829-block 4
branch  0 taken 16 (fallthrough)
branch  1 taken 20
       16:17830:        DockNodeUpdateHasCentralNodeChild(node->ChildNodes[1]);
       16:17830-block 5
call    0 returned 16
       36:17831:    if (node->IsRootNode())
       36:17831-block 6
call    0 returned 36
branch  1 taken 4 (fallthrough)
branch  2 taken 32
        -:17832:    {
        4:17833:        ImGuiDockNode* mark_node = node->CentralNode;
       20:17834:        while (mark_node)
        4:17834-block 8
       20:17834-block 10
branch  0 taken 16
branch  1 taken 4 (fallthrough)
        -:17835:        {
       16:17836:            mark_node->HasCentralNodeChild = true;
       16:17837:            mark_node = mark_node->ParentNode;
       16:17837-block 9
        -:17838:        }
        -:17839:    }
       36:17840:}
        -:17841:
function _ZN5ImGuiL25DockNodeUpdateVisibleFlagEP13ImGuiDockNode called 9698 returned 100% blocks executed 100%
     9698:17842:static void ImGui::DockNodeUpdateVisibleFlag(ImGuiDockNode* node)
        -:17843:{
        -:17844:    // Update visibility flag
     9698:17845:    bool is_visible = (node->ParentNode == NULL) ? node->IsDockSpace() : node->IsCentralNode();
     9698:17845-block 2
branch  0 taken 1077 (fallthrough)
branch  1 taken 8621
     1077:17845-block 3
call    2 returned 1077
     8621:17845-block 5
call    3 returned 8621
     9698:17846:    is_visible |= (node->Windows.Size > 0);
     9698:17847:    is_visible |= (node->ChildNodes[0] && node->ChildNodes[0]->IsVisible);
     9698:17847-block 7
branch  0 taken 4308 (fallthrough)
branch  1 taken 5390
     4308:17847-block 8
branch  2 taken 4305 (fallthrough)
branch  3 taken 3
     4305:17847-block 9
     5393:17847-block 10
     9698:17848:    is_visible |= (node->ChildNodes[1] && node->ChildNodes[1]->IsVisible);
     9698:17848-block 11
branch  0 taken 4308 (fallthrough)
branch  1 taken 5390
     4308:17848-block 12
branch  2 taken 4306 (fallthrough)
branch  3 taken 2
     4306:17848-block 13
     5392:17848-block 14
     9698:17849:    node->IsVisible = is_visible;
     9698:17850:}
        -:17851:
function _ZN5ImGuiL30DockNodeStartMouseMovingWindowEP13ImGuiDockNodeP11ImGuiWindow called 0 returned 0% blocks executed 0%
    #####:17852:static void ImGui::DockNodeStartMouseMovingWindow(ImGuiDockNode* node, ImGuiWindow* window)
        -:17853:{
    #####:17854:    ImGuiContext& g = *GImGui;
    #####:17855:    IM_ASSERT(node->WantMouseMove == true);
    %%%%%:17855-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17855-block 3
call    2 never executed
    #####:17856:    StartMouseMovingWindow(window);
    %%%%%:17856-block 4
call    0 never executed
    #####:17857:    g.ActiveIdClickOffset = g.IO.MouseClickedPos[0] - node->Pos;
call    0 never executed
    #####:17858:    g.MovingWindow = window; // If we are docked into a non moveable root window, StartMouseMovingWindow() won't set g.MovingWindow. Override that decision.
    #####:17859:    node->WantMouseMove = false;
    #####:17860:}
        -:17861:
        -:17862:// Update CentralNode, OnlyNodeWithWindows, LastFocusedNodeID. Copy window class.
function _ZN5ImGuiL25DockNodeUpdateForRootNodeEP13ImGuiDockNode called 1077 returned 100% blocks executed 75%
     1077:17863:static void ImGui::DockNodeUpdateForRootNode(ImGuiDockNode* node)
        -:17864:{
     1077:17865:    DockNodeUpdateFlagsAndCollapse(node);
     1077:17865-block 2
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -:17866:
        -:17867:    // - Setup central node pointers
        -:17868:    // - Find if there's only a single visible window in the hierarchy (in which case we need to display a regular title bar -> FIXME-DOCK: that last part is not done yet!)
        -:17869:    // Cannot merge this with DockNodeUpdateFlagsAndCollapse() because FirstNodeWithWindows is found after window removal and child collapsing
     1077:17870:    ImGuiDockNodeTreeInfo info;
     1077:17870-block 3
call    0 returned 1077
     1077:17871:    DockNodeFindInfo(node, &info);
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:17872:    node->CentralNode = info.CentralNode;
    1077*:17873:    node->OnlyNodeWithWindows = (info.CountNodesWithWindows == 1) ? info.FirstNodeWithWindows : NULL;
     1077:17873-block 5
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:17873-block 6
     1077:17873-block 7
     1077:17874:    node->CountNodeWithWindows = info.CountNodesWithWindows;
     1077:17875:    if (node->LastFocusedNodeId == 0 && info.FirstNodeWithWindows != NULL)
     1077:17875-block 8
branch  0 taken 2 (fallthrough)
branch  1 taken 1075
        2:17875-block 9
branch  2 taken 1 (fallthrough)
branch  3 taken 1
        1:17876:        node->LastFocusedNodeId = info.FirstNodeWithWindows->ID;
        1:17876-block 10
        -:17877:
        -:17878:    // Copy the window class from of our first window so it can be used for proper dock filtering.
        -:17879:    // When node has mixed windows, prioritize the class with the most constraint (DockingAllowUnclassed = false) as the reference to copy.
        -:17880:    // FIXME-DOCK: We don't recurse properly, this code could be reworked to work from DockNodeUpdateScanRec.
     1077:17881:    if (ImGuiDockNode* first_node_with_windows = info.FirstNodeWithWindows)
     1077:17881-block 11
branch  0 taken 1076 (fallthrough)
branch  1 taken 1
        -:17882:    {
     1076:17883:        node->WindowClass = first_node_with_windows->Windows[0]->WindowClass;
     1076:17883-block 12
call    0 returned 1076
    1076*:17884:        for (int n = 1; n < first_node_with_windows->Windows.Size; n++)
    %%%%%:17884-block 18
     1076:17884-block 19
branch  0 taken 0
branch  1 taken 1076 (fallthrough)
    #####:17885:            if (first_node_with_windows->Windows[n]->WindowClass.DockingAllowUnclassed == false)
    %%%%%:17885-block 14
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -:17886:            {
    #####:17887:                node->WindowClass = first_node_with_windows->Windows[n]->WindowClass;
    %%%%%:17887-block 16
call    0 never executed
    #####:17888:                break;
        -:17889:            }
        -:17890:    }
        -:17891:
     1077:17892:    ImGuiDockNode* mark_node = node->CentralNode;
     5385:17893:    while (mark_node)
     1077:17893-block 21
     5385:17893-block 23
branch  0 taken 4308
branch  1 taken 1077 (fallthrough)
        -:17894:    {
     4308:17895:        mark_node->HasCentralNodeChild = true;
     4308:17896:        mark_node = mark_node->ParentNode;
     4308:17896-block 22
        -:17897:    }
     1077:17898:}
     1077:17898-block 24
        -:17899:
function _ZL23DockNodeSetupHostWindowP13ImGuiDockNodeP11ImGuiWindow called 1077 returned 100% blocks executed 60%
     1077:17900:static void DockNodeSetupHostWindow(ImGuiDockNode* node, ImGuiWindow* host_window)
        -:17901:{
        -:17902:    // Remove ourselves from any previous different host window
        -:17903:    // This can happen if a user mistakenly does (see #4295 for details):
        -:17904:    //  - N+0: DockBuilderAddNode(id, 0)    // missing ImGuiDockNodeFlags_DockSpace
        -:17905:    //  - N+1: NewFrame()                   // will create floating host window for that node
        -:17906:    //  - N+1: DockSpace(id)                // requalify node as dockspace, moving host window
    1077*:17907:    if (node->HostWindow && node->HostWindow != host_window && node->HostWindow->DockNodeAsHost == node)
     1077:17907-block 2
branch  0 taken 1076 (fallthrough)
branch  1 taken 1
     1076:17907-block 3
branch  2 taken 0 (fallthrough)
branch  3 taken 1076
    %%%%%:17907-block 4
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:17908:        node->HostWindow->DockNodeAsHost = NULL;
    %%%%%:17908-block 5
        -:17909:
     1077:17910:    host_window->DockNodeAsHost = node;
     1077:17911:    node->HostWindow = host_window;
     1077:17912:}
        -:17913:
function _ZN5ImGuiL14DockNodeUpdateEP13ImGuiDockNode called 9693 returned 100% blocks executed 43%
     9693:17914:static void ImGui::DockNodeUpdate(ImGuiDockNode* node)
        -:17915:{
     9693:17916:    ImGuiContext& g = *GImGui;
    9693*:17917:    IM_ASSERT(node->LastFrameActive != g.FrameCount);
     9693:17917-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 9693
    %%%%%:17917-block 3
call    2 never executed
     9693:17918:    node->LastFrameAlive = g.FrameCount;
     9693:17919:    node->IsBgDrawnThisFrame = false;
        -:17920:
     9693:17921:    node->CentralNode = node->OnlyNodeWithWindows = NULL;
     9693:17922:    if (node->IsRootNode())
     9693:17922-block 4
call    0 returned 9693
branch  1 taken 1077 (fallthrough)
branch  2 taken 8616
     1077:17923:        DockNodeUpdateForRootNode(node);
     1077:17923-block 6
call    0 returned 1077
        -:17924:
        -:17925:    // Remove tab bar if not needed
    9693*:17926:    if (node->TabBar && node->IsNoTabBar())
     9693:17926-block 7
branch  0 taken 5380 (fallthrough)
branch  1 taken 4313
     5380:17926-block 8
call    2 returned 5380
branch  3 taken 0 (fallthrough)
branch  4 taken 5380
    %%%%%:17926-block 10
     9693:17926-block 11
     9693:17926-block 12
branch  5 taken 0 (fallthrough)
branch  6 taken 9693
    #####:17927:        DockNodeRemoveTabBar(node);
    %%%%%:17927-block 13
call    0 never executed
        -:17928:
        -:17929:    // Early out for hidden root dock nodes (when all DockId references are in inactive windows, or there is only 1 floating window holding on the DockId)
     9693:17930:    bool want_to_hide_host_window = false;
     9693:17931:    if (node->IsFloatingNode())
     9693:17931-block 14
call    0 returned 9693
branch  1 taken 0 (fallthrough)
branch  2 taken 9693
        -:17932:    {
    #####:17933:        if (node->Windows.Size <= 1 && node->IsLeafNode())
    %%%%%:17933-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17933-block 17
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:17933-block 19
    %%%%%:17933-block 20
    %%%%%:17933-block 21
branch  5 never executed (fallthrough)
branch  6 never executed
    #####:17934:            if (!g.IO.ConfigDockingAlwaysTabBar && (node->Windows.Size == 0 || !node->Windows[0]->WindowClass.DockingAlwaysTabBar))
    %%%%%:17934-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17934-block 23
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:17934-block 24
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:17934-block 26
    %%%%%:17934-block 27
    %%%%%:17934-block 28
branch  7 never executed (fallthrough)
branch  8 never executed
    #####:17935:                want_to_hide_host_window = true;
    %%%%%:17935-block 29
    #####:17936:        if (node->CountNodeWithWindows == 0)
    %%%%%:17936-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:17937:            want_to_hide_host_window = true;
    %%%%%:17937-block 31
        -:17938:    }
     9693:17939:    if (want_to_hide_host_window)
     9693:17939-block 32
branch  0 taken 0 (fallthrough)
branch  1 taken 9693
        -:17940:    {
    #####:17941:        if (node->Windows.Size == 1)
    %%%%%:17941-block 33
branch  0 never executed (fallthrough)
branch  1 never executed
        -:17942:        {
        -:17943:            // Floating window pos/size is authoritative
    #####:17944:            ImGuiWindow* single_window = node->Windows[0];
    %%%%%:17944-block 34
call    0 never executed
    #####:17945:            node->Pos = single_window->Pos;
    #####:17946:            node->Size = single_window->SizeFull;
    #####:17947:            node->AuthorityForPos = node->AuthorityForSize = node->AuthorityForViewport = ImGuiDataAuthority_Window;
        -:17948:
        -:17949:            // Transfer focus immediately so when we revert to a regular window it is immediately selected
    #####:17950:            if (node->HostWindow && g.NavWindow == node->HostWindow)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17950-block 36
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:17951:                FocusWindow(single_window);
    %%%%%:17951-block 37
call    0 never executed
    #####:17952:            if (node->HostWindow)
    %%%%%:17952-block 38
branch  0 never executed (fallthrough)
branch  1 never executed
        -:17953:            {
    #####:17954:                IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Node %08X transfer Viewport %08X->%08X to Window '%s'\n", node->ID, node->HostWindow->Viewport->ID, single_window->ID, single_window->Name);
    %%%%%:17954-block 39
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17954-block 40
call    2 never executed
    #####:17955:                single_window->Viewport = node->HostWindow->Viewport;
    #####:17956:                single_window->ViewportId = node->HostWindow->ViewportId;
    #####:17957:                if (node->HostWindow->ViewportOwned)
    %%%%%:17957-block 41
branch  0 never executed (fallthrough)
branch  1 never executed
        -:17958:                {
    #####:17959:                    single_window->Viewport->ID = single_window->ID;
    #####:17960:                    single_window->Viewport->Window = single_window;
    #####:17961:                    single_window->ViewportOwned = true;
    %%%%%:17961-block 42
        -:17962:                }
        -:17963:            }
    #####:17964:            node->RefViewportId = single_window->ViewportId;
    %%%%%:17964-block 43
        -:17965:        }
        -:17966:
    #####:17967:        DockNodeHideHostWindow(node);
    %%%%%:17967-block 44
call    0 never executed
    #####:17968:        node->State = ImGuiDockNodeState_HostWindowHiddenBecauseSingleWindow;
    #####:17969:        node->WantCloseAll = false;
    #####:17970:        node->WantCloseTabId = 0;
    #####:17971:        node->HasCloseButton = node->HasWindowMenuButton = false;
    #####:17972:        node->LastFrameActive = g.FrameCount;
        -:17973:
    #####:17974:        if (node->WantMouseMove && node->Windows.Size == 1)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17974-block 46
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:17975:            DockNodeStartMouseMovingWindow(node, node->Windows[0]);
    %%%%%:17975-block 47
call    0 never executed
call    1 never executed
    #####:17976:        return;
    %%%%%:17976-block 49
        -:17977:    }
        -:17978:
        -:17979:    // In some circumstance we will defer creating the host window (so everything will be kept hidden),
        -:17980:    // while the expected visible window is resizing itself.
        -:17981:    // This is important for first-time (no ini settings restored) single window when io.ConfigDockingAlwaysTabBar is enabled,
        -:17982:    // otherwise the node ends up using the minimum window size. Effectively those windows will take an extra frame to show up:
        -:17983:    //   N+0: Begin(): window created (with no known size), node is created
        -:17984:    //   N+1: DockNodeUpdate(): node skip creating host window / Begin(): window size applied, not visible
        -:17985:    //   N+2: DockNodeUpdate(): node can create host window / Begin(): window becomes visible
        -:17986:    // We could remove this frame if we could reliably calculate the expected window size during node update, before the Begin() code.
        -:17987:    // It would require a generalization of CalcWindowExpectedSize(), probably extracting code away from Begin().
        -:17988:    // In reality it isn't very important as user quickly ends up with size data in .ini file.
    9693*:17989:    if (node->IsVisible && node->HostWindow == NULL && node->IsFloatingNode() && node->IsLeafNode())
     9693:17989-block 50
branch  0 taken 9688 (fallthrough)
branch  1 taken 5
     9688:17989-block 51
branch  2 taken 3 (fallthrough)
branch  3 taken 9685
        3:17989-block 52
call    4 returned 3
branch  5 taken 0 (fallthrough)
branch  6 taken 3
    %%%%%:17989-block 54
call    7 never executed
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%:17989-block 56
     9693:17989-block 57
     9693:17989-block 58
branch 10 taken 0 (fallthrough)
branch 11 taken 9693
        -:17990:    {
    #####:17991:        IM_ASSERT(node->Windows.Size > 0);
    %%%%%:17991-block 59
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17991-block 60
call    2 never executed
    #####:17992:        ImGuiWindow* ref_window = NULL;
    #####:17993:        if (node->SelectedTabId != 0) // Note that we prune single-window-node settings on .ini loading, so this is generally 0 for them!
    %%%%%:17993-block 61
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:17994:            ref_window = DockNodeFindWindowByID(node, node->SelectedTabId);
    %%%%%:17994-block 62
call    0 never executed
    #####:17995:        if (ref_window == NULL)
    %%%%%:17995-block 64
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:17996:            ref_window = node->Windows[0];
    %%%%%:17996-block 65
call    0 never executed
    #####:17997:        if (ref_window->AutoFitFramesX > 0 || ref_window->AutoFitFramesY > 0)
    %%%%%:17997-block 67
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:17997-block 68
branch  2 never executed (fallthrough)
branch  3 never executed
        -:17998:        {
    #####:17999:            node->State = ImGuiDockNodeState_HostWindowHiddenBecauseWindowsAreResizing;
    #####:18000:            return;
    %%%%%:18000-block 69
        -:18001:        }
        -:18002:    }
        -:18003:
     9693:18004:    const ImGuiDockNodeFlags node_flags = node->MergedFlags;
        -:18005:
        -:18006:    // Decide if the node will have a close button and a window menu button
     9693:18007:    node->HasWindowMenuButton = (node->Windows.Size > 0) && (node_flags & ImGuiDockNodeFlags_NoWindowMenuButton) == 0;
     9693:18007-block 70
branch  0 taken 5380 (fallthrough)
branch  1 taken 4313
     5380:18007-block 71
branch  2 taken 5380 (fallthrough)
branch  3 taken 0
     5380:18007-block 72
     4313:18007-block 73
     9693:18008:    node->HasCloseButton = false;
    15073:18009:    for (ImGuiWindow* window : node->Windows)
     9693:18009-block 74
call    0 returned 9693
call    1 returned 9693
    15073:18009-block 77
branch  2 taken 5380
branch  3 taken 9693 (fallthrough)
        -:18010:    {
        -:18011:        // FIXME-DOCK: Setting DockIsActive here means that for single active window in a leaf node, DockIsActive will be cleared until the next Begin() call.
     5380:18012:        node->HasCloseButton |= window->HasCloseButton;
     5380:18013:        window->DockIsActive = (node->Windows.Size > 1);
     5380:18013-block 76
        -:18014:    }
     9693:18015:    if (node_flags & ImGuiDockNodeFlags_NoCloseButton)
     9693:18015-block 78
branch  0 taken 0 (fallthrough)
branch  1 taken 9693
    #####:18016:        node->HasCloseButton = false;
    %%%%%:18016-block 79
        -:18017:
        -:18018:    // Bind or create host window
     9693:18019:    ImGuiWindow* host_window = NULL;
     9693:18020:    bool beginned_into_host_window = false;
     9693:18021:    if (node->IsDockSpace())
     9693:18021-block 80
call    0 returned 9693
branch  1 taken 1077 (fallthrough)
branch  2 taken 8616
        -:18022:    {
        -:18023:        // [Explicit root dockspace node]
    1077*:18024:        IM_ASSERT(node->HostWindow);
     1077:18024-block 82
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:18024-block 83
call    2 never executed
     1077:18025:        host_window = node->HostWindow;
     1077:18025-block 84
        -:18026:    }
        -:18027:    else
        -:18028:    {
        -:18029:        // [Automatic root or child nodes]
    8616*:18030:        if (node->IsRootNode() && node->IsVisible)
     8616:18030-block 85
call    0 returned 8616
branch  1 taken 0 (fallthrough)
branch  2 taken 8616
    %%%%%:18030-block 87
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:18030-block 88
     8616:18030-block 89
     8616:18030-block 90
branch  5 taken 0 (fallthrough)
branch  6 taken 8616
        -:18031:        {
    #####:18032:            ImGuiWindow* ref_window = (node->Windows.Size > 0) ? node->Windows[0] : NULL;
    %%%%%:18032-block 91
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18032-block 92
call    2 never executed
    %%%%%:18032-block 94
        -:18033:
        -:18034:            // Sync Pos
    #####:18035:            if (node->AuthorityForPos == ImGuiDataAuthority_Window && ref_window)
    %%%%%:18035-block 95
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18035-block 96
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:18036:                SetNextWindowPos(ref_window->Pos);
    %%%%%:18036-block 97
call    0 never executed
call    1 never executed
    #####:18037:            else if (node->AuthorityForPos == ImGuiDataAuthority_DockNode)
    %%%%%:18037-block 100
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:18038:                SetNextWindowPos(node->Pos);
    %%%%%:18038-block 101
call    0 never executed
call    1 never executed
        -:18039:
        -:18040:            // Sync Size
    #####:18041:            if (node->AuthorityForSize == ImGuiDataAuthority_Window && ref_window)
    %%%%%:18041-block 104
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18041-block 105
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:18042:                SetNextWindowSize(ref_window->SizeFull);
    %%%%%:18042-block 106
call    0 never executed
    #####:18043:            else if (node->AuthorityForSize == ImGuiDataAuthority_DockNode)
    %%%%%:18043-block 107
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:18044:                SetNextWindowSize(node->Size);
    %%%%%:18044-block 108
call    0 never executed
        -:18045:
        -:18046:            // Sync Collapsed
    #####:18047:            if (node->AuthorityForSize == ImGuiDataAuthority_Window && ref_window)
    %%%%%:18047-block 109
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18047-block 110
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:18048:                SetNextWindowCollapsed(ref_window->Collapsed);
    %%%%%:18048-block 111
call    0 never executed
        -:18049:
        -:18050:            // Sync Viewport
    #####:18051:            if (node->AuthorityForViewport == ImGuiDataAuthority_Window && ref_window)
    %%%%%:18051-block 112
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18051-block 113
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:18052:                SetNextWindowViewport(ref_window->ViewportId);
    %%%%%:18052-block 114
call    0 never executed
    #####:18053:            else if (node->AuthorityForViewport == ImGuiDataAuthority_Window && node->RefViewportId != 0)
    %%%%%:18053-block 115
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18053-block 116
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:18054:                SetNextWindowViewport(node->RefViewportId);
    %%%%%:18054-block 117
call    0 never executed
        -:18055:
    #####:18056:            SetNextWindowClass(&node->WindowClass);
    %%%%%:18056-block 118
call    0 never executed
        -:18057:
        -:18058:            // Begin into the host window
        -:18059:            char window_label[20];
    #####:18060:            DockNodeGetHostWindowTitle(node, window_label, IM_ARRAYSIZE(window_label));
call    0 never executed
    #####:18061:            ImGuiWindowFlags window_flags = ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoScrollWithMouse | ImGuiWindowFlags_DockNodeHost;
    #####:18062:            window_flags |= ImGuiWindowFlags_NoFocusOnAppearing;
    #####:18063:            window_flags |= ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoNavFocus | ImGuiWindowFlags_NoCollapse;
    #####:18064:            window_flags |= ImGuiWindowFlags_NoTitleBar;
        -:18065:
    #####:18066:            SetNextWindowBgAlpha(0.0f); // Don't set ImGuiWindowFlags_NoBackground because it disables borders
call    0 never executed
    #####:18067:            PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0, 0));
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$:18067-block 285
    #####:18068:            Begin(window_label, NULL, window_flags);
    %%%%%:18068-block 123
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:18069:            PopStyleVar();
    %%%%%:18069-block 124
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:18070:            beginned_into_host_window = true;
        -:18071:
    #####:18072:            host_window = g.CurrentWindow;
    #####:18073:            DockNodeSetupHostWindow(node, host_window);
    %%%%%:18073-block 125
call    0 never executed
    #####:18074:            host_window->DC.CursorPos = host_window->Pos;
    #####:18075:            node->Pos = host_window->Pos;
    #####:18076:            node->Size = host_window->Size;
        -:18077:
        -:18078:            // We set ImGuiWindowFlags_NoFocusOnAppearing because we don't want the host window to take full focus (e.g. steal NavWindow)
        -:18079:            // But we still it bring it to the front of display. There's no way to choose this precise behavior via window flags.
        -:18080:            // One simple case to ponder if: window A has a toggle to create windows B/C/D. Dock B/C/D together, clear the toggle and enable it again.
        -:18081:            // When reappearing B/C/D will request focus and be moved to the top of the display pile, but they are not linked to the dock host window
        -:18082:            // during the frame they appear. The dock host window would keep its old display order, and the sorting in EndFrame would move B/C/D back
        -:18083:            // after the dock host window, losing their top-most status.
    #####:18084:            if (node->HostWindow->Appearing)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:18085:                BringWindowToDisplayFront(node->HostWindow);
    %%%%%:18085-block 127
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:18086:
    #####:18087:            node->AuthorityForPos = node->AuthorityForSize = node->AuthorityForViewport = ImGuiDataAuthority_Auto;
    %%%%%:18087-block 128
        -:18088:        }
     8616:18089:        else if (node->ParentNode)
     8616:18089-block 129
branch  0 taken 8616 (fallthrough)
branch  1 taken 0
        -:18090:        {
     8616:18091:            node->HostWindow = host_window = node->ParentNode->HostWindow;
     8616:18092:            node->AuthorityForPos = node->AuthorityForSize = node->AuthorityForViewport = ImGuiDataAuthority_Auto;
     8616:18092-block 130
        -:18093:        }
    8616*:18094:        if (node->WantMouseMove && node->HostWindow)
     8616:18094-block 131
branch  0 taken 0 (fallthrough)
branch  1 taken 8616
    %%%%%:18094-block 132
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:18095:            DockNodeStartMouseMovingWindow(node, node->HostWindow);
    %%%%%:18095-block 133
call    0 never executed
        -:18096:    }
     9693:18097:    node->RefViewportId = 0; // Clear when we have a host window
        -:18098:
        -:18099:    // Update focused node (the one whose title bar is highlight) within a node tree
     9693:18100:    if (node->IsSplitNode())
     9693:18100-block 134
call    0 returned 9693
branch  1 taken 4308 (fallthrough)
branch  2 taken 5385
    4308*:18101:        IM_ASSERT(node->TabBar == NULL);
     4308:18101-block 136
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
    %%%%%:18101-block 137
call    2 never executed
     9693:18102:    if (node->IsRootNode())
     9693:18102-block 138
call    0 returned 9693
branch  1 taken 1077 (fallthrough)
branch  2 taken 8616
    1077*:18103:        if (ImGuiWindow* p_window = g.NavWindow ? g.NavWindow->RootWindow : NULL)
     1077:18103-block 140
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:18103-block 141
    %%%%%:18103-block 142
     1077:18103-block 143
branch  2 taken 1077 (fallthrough)
branch  3 taken 0
     1077:18104:            while (p_window != NULL && p_window->DockNode != NULL)
     1077:18104-block 144
     1077:18104-block 152
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:18104-block 153
branch  2 taken 1076
branch  3 taken 1 (fallthrough)
        -:18105:            {
     1076:18106:                ImGuiDockNode* p_node = DockNodeGetRootNode(p_window->DockNode);
     1076:18106-block 145
call    0 returned 1076
     1076:18107:                if (p_node == node)
branch  0 taken 1076 (fallthrough)
branch  1 taken 0
        -:18108:                {
     1076:18109:                    node->LastFocusedNodeId = p_window->DockNode->ID; // Note: not using root node ID!
     1076:18110:                    break;
     1076:18110-block 147
        -:18111:                }
    #####:18112:                p_window = p_node->HostWindow ? p_node->HostWindow->RootWindow : NULL;
    %%%%%:18112-block 148
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18112-block 149
    %%%%%:18112-block 150
    %%%%%:18112-block 151
        -:18113:            }
        -:18114:
        -:18115:    // Register a hit-test hole in the window unless we are currently dragging a window that is compatible with our dockspace
     9693:18116:    ImGuiDockNode* central_node = node->CentralNode;
    9693*:18117:    const bool central_node_hole = node->IsRootNode() && host_window && (node_flags & ImGuiDockNodeFlags_PassthruCentralNode) != 0 && central_node != NULL && central_node->IsEmpty();
     9693:18117-block 155
call    0 returned 9693
branch  1 taken 1077 (fallthrough)
branch  2 taken 8616
     1077:18117-block 157
branch  3 taken 1077 (fallthrough)
branch  4 taken 0
     1077:18117-block 158
branch  5 taken 0 (fallthrough)
branch  6 taken 1077
    %%%%%:18117-block 159
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%:18117-block 160
call    9 never executed
branch 10 never executed (fallthrough)
branch 11 never executed
    %%%%%:18117-block 162
     9693:18117-block 163
     9693:18118:    bool central_node_hole_register_hit_test_hole = central_node_hole;
     9693:18119:    if (central_node_hole)
     9693:18119-block 164
branch  0 taken 0 (fallthrough)
branch  1 taken 9693
    #####:18120:        if (const ImGuiPayload* payload = ImGui::GetDragDropPayload())
    %%%%%:18120-block 165
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:18121:            if (payload->IsDataType(IMGUI_PAYLOAD_TYPE_WINDOW) && DockNodeIsDropAllowed(host_window, *(ImGuiWindow**)payload->Data))
    %%%%%:18121-block 167
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:18121-block 169
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:18121-block 171
    %%%%%:18121-block 172
    %%%%%:18121-block 173
branch  6 never executed (fallthrough)
branch  7 never executed
    #####:18122:                central_node_hole_register_hit_test_hole = false;
    %%%%%:18122-block 174
     9693:18123:    if (central_node_hole_register_hit_test_hole)
     9693:18123-block 175
branch  0 taken 0 (fallthrough)
branch  1 taken 9693
        -:18124:    {
        -:18125:        // We add a little padding to match the "resize from edges" behavior and allow grabbing the splitter easily.
        -:18126:        // (But we only add it if there's something else on the other side of the hole, otherwise for e.g. fullscreen
        -:18127:        // covering passthru node we'd have a gap on the edge not covered by the hole)
    #####:18128:        IM_ASSERT(node->IsDockSpace()); // We cannot pass this flag without the DockSpace() api. Testing this because we also setup the hole in host_window->ParentNode
    %%%%%:18128-block 176
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:18128-block 178
call    3 never executed
    #####:18129:        ImGuiDockNode* root_node = DockNodeGetRootNode(central_node);
    %%%%%:18129-block 179
call    0 never executed
    #####:18130:        ImRect root_rect(root_node->Pos, root_node->Pos + root_node->Size);
call    0 never executed
call    1 never executed
    #####:18131:        ImRect hole_rect(central_node->Pos, central_node->Pos + central_node->Size);
call    0 never executed
call    1 never executed
    #####:18132:        if (hole_rect.Min.x > root_rect.Min.x) { hole_rect.Min.x += WINDOWS_HOVER_PADDING; }
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18132-block 185
    #####:18133:        if (hole_rect.Max.x < root_rect.Max.x) { hole_rect.Max.x -= WINDOWS_HOVER_PADDING; }
    %%%%%:18133-block 186
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18133-block 187
    #####:18134:        if (hole_rect.Min.y > root_rect.Min.y) { hole_rect.Min.y += WINDOWS_HOVER_PADDING; }
    %%%%%:18134-block 188
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18134-block 189
    #####:18135:        if (hole_rect.Max.y < root_rect.Max.y) { hole_rect.Max.y -= WINDOWS_HOVER_PADDING; }
    %%%%%:18135-block 190
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18135-block 191
        -:18136:        //GetForegroundDrawList()->AddRect(hole_rect.Min, hole_rect.Max, IM_COL32(255, 0, 0, 255));
    #####:18137:        if (central_node_hole && !hole_rect.IsInverted())
    %%%%%:18137-block 192
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18137-block 193
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:18137-block 195
    %%%%%:18137-block 196
    %%%%%:18137-block 197
branch  5 never executed (fallthrough)
branch  6 never executed
        -:18138:        {
    #####:18139:            SetWindowHitTestHole(host_window, hole_rect.Min, hole_rect.Max - hole_rect.Min);
    %%%%%:18139-block 198
call    0 never executed
call    1 never executed
    #####:18140:            if (host_window->ParentWindow)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:18141:                SetWindowHitTestHole(host_window->ParentWindow, hole_rect.Min, hole_rect.Max - hole_rect.Min);
    %%%%%:18141-block 201
call    0 never executed
call    1 never executed
        -:18142:        }
        -:18143:    }
        -:18144:
        -:18145:    // Update position/size, process and draw resizing splitters
     9693:18146:    if (node->IsRootNode() && host_window)
     9693:18146-block 205
call    0 returned 9693
branch  1 taken 1077 (fallthrough)
branch  2 taken 8616
     1077:18146-block 207
branch  3 taken 1077 (fallthrough)
branch  4 taken 0
     1077:18146-block 208
     8616:18146-block 209
     9693:18146-block 210
branch  5 taken 1077 (fallthrough)
branch  6 taken 8616
        -:18147:    {
     1077:18148:        DockNodeTreeUpdatePosSize(node, host_window->Pos, host_window->Size);
     1077:18148-block 211
call    0 returned 1077
     1077:18149:        PushStyleColor(ImGuiCol_Separator, g.Style.Colors[ImGuiCol_Border]);
call    0 returned 1077
     1077:18150:        PushStyleColor(ImGuiCol_SeparatorActive, g.Style.Colors[ImGuiCol_ResizeGripActive]);
call    0 returned 1077
     1077:18151:        PushStyleColor(ImGuiCol_SeparatorHovered, g.Style.Colors[ImGuiCol_ResizeGripHovered]);
call    0 returned 1077
     1077:18152:        DockNodeTreeUpdateSplitter(node);
call    0 returned 1077
     1077:18153:        PopStyleColor(3);
call    0 returned 1077
        -:18154:    }
        -:18155:
        -:18156:    // Draw empty node background (currently can only be the Central Node)
     9693:18157:    if (host_window && node->IsEmpty() && node->IsVisible)
     9693:18157-block 217
branch  0 taken 9693 (fallthrough)
branch  1 taken 0
     9693:18157-block 218
call    2 returned 9693
branch  3 taken 5 (fallthrough)
branch  4 taken 9688
        5:18157-block 220
branch  5 taken 1 (fallthrough)
branch  6 taken 4
        1:18157-block 221
     9692:18157-block 222
     9693:18157-block 223
branch  7 taken 1 (fallthrough)
branch  8 taken 9692
        -:18158:    {
        1:18159:        host_window->DrawList->ChannelsSetCurrent(DOCKING_HOST_DRAW_CHANNEL_BG);
        1:18159-block 224
call    0 returned 1
       1*:18160:        node->LastBgColor = (node_flags & ImGuiDockNodeFlags_PassthruCentralNode) ? 0 : GetColorU32(ImGuiCol_DockingEmptyBg);
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:18160-block 226
call    2 returned 1
    %%%%%:18160-block 227
        1:18161:        if (node->LastBgColor != 0)
        1:18161-block 228
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:18162:            host_window->DrawList->AddRectFilled(node->Pos, node->Pos + node->Size, node->LastBgColor);
        1:18162-block 229
call    0 returned 1
call    1 returned 1
branch  2 taken 1 (fallthrough)
branch  3 taken 0 (throw)
        1:18162-block 231
    $$$$$:18162-block 287
call    4 never executed
        1:18163:        node->IsBgDrawnThisFrame = true;
        1:18163-block 232
        -:18164:    }
        -:18165:
        -:18166:    // Draw whole dockspace background if ImGuiDockNodeFlags_PassthruCentralNode if set.
        -:18167:    // We need to draw a background at the root level if requested by ImGuiDockNodeFlags_PassthruCentralNode, but we will only know the correct pos/size
        -:18168:    // _after_ processing the resizing splitters. So we are using the DrawList channel splitting facility to submit drawing primitives out of order!
    9693*:18169:    const bool render_dockspace_bg = node->IsRootNode() && host_window && (node_flags & ImGuiDockNodeFlags_PassthruCentralNode) != 0;
     9693:18169-block 233
call    0 returned 9693
branch  1 taken 1077 (fallthrough)
branch  2 taken 8616
     1077:18169-block 235
branch  3 taken 1077 (fallthrough)
branch  4 taken 0
     1077:18169-block 236
branch  5 taken 0 (fallthrough)
branch  6 taken 1077
    %%%%%:18169-block 237
     9693:18169-block 238
    9693*:18170:    if (render_dockspace_bg && node->IsVisible)
     9693:18170-block 239
branch  0 taken 0 (fallthrough)
branch  1 taken 9693
    %%%%%:18170-block 240
branch  2 never executed (fallthrough)
branch  3 never executed
        -:18171:    {
    #####:18172:        host_window->DrawList->ChannelsSetCurrent(DOCKING_HOST_DRAW_CHANNEL_BG);
    %%%%%:18172-block 241
call    0 never executed
    #####:18173:        if (central_node_hole)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:18174:            RenderRectFilledWithHole(host_window->DrawList, node->Rect(), central_node->Rect(), GetColorU32(ImGuiCol_WindowBg), 0.0f);
    %%%%%:18174-block 243
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    %%%%%:18174-block 247
    $$$$$:18174-block 288
    $$$$$:18174-block 289
call    6 never executed
        -:18175:        else
    #####:18176:            host_window->DrawList->AddRectFilled(node->Pos, node->Pos + node->Size, GetColorU32(ImGuiCol_WindowBg), 0.0f);
    %%%%%:18176-block 248
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%:18176-block 251
        -:18177:    }
        -:18178:
        -:18179:    // Draw and populate Tab Bar
     9693:18180:    if (host_window)
     9693:18180-block 252
branch  0 taken 9693 (fallthrough)
branch  1 taken 0
     9693:18181:        host_window->DrawList->ChannelsSetCurrent(DOCKING_HOST_DRAW_CHANNEL_FG);
     9693:18181-block 253
call    0 returned 9693
     9693:18182:    if (host_window && node->Windows.Size > 0)
     9693:18182-block 254
branch  0 taken 9693 (fallthrough)
branch  1 taken 0
     9693:18182-block 255
branch  2 taken 5380 (fallthrough)
branch  3 taken 4313
        -:18183:    {
     5380:18184:        DockNodeUpdateTabBar(node, host_window);
     5380:18184-block 256
call    0 returned 5380
        -:18185:    }
        -:18186:    else
        -:18187:    {
     4313:18188:        node->WantCloseAll = false;
     4313:18189:        node->WantCloseTabId = 0;
     4313:18190:        node->IsFocused = false;
     4313:18190-block 257
        -:18191:    }
     9693:18192:    if (node->TabBar && node->TabBar->SelectedTabId)
     9693:18192-block 258
branch  0 taken 5380 (fallthrough)
branch  1 taken 4313
     5380:18192-block 259
branch  2 taken 5380 (fallthrough)
branch  3 taken 0
     5380:18193:        node->SelectedTabId = node->TabBar->SelectedTabId;
     5380:18193-block 260
     4313:18194:    else if (node->Windows.Size > 0)
     4313:18194-block 261
branch  0 taken 0 (fallthrough)
branch  1 taken 4313
    #####:18195:        node->SelectedTabId = node->Windows[0]->TabId;
    %%%%%:18195-block 262
call    0 never executed
        -:18196:
        -:18197:    // Draw payload drop target
     9693:18198:    if (host_window && node->IsVisible)
     9693:18198-block 264
branch  0 taken 9693 (fallthrough)
branch  1 taken 0
     9693:18198-block 265
branch  2 taken 9688 (fallthrough)
branch  3 taken 5
    9688*:18199:        if (node->IsRootNode() && (g.MovingWindow == NULL || g.MovingWindow->RootWindowDockTree != host_window))
     9688:18199-block 266
call    0 returned 9688
branch  1 taken 1077 (fallthrough)
branch  2 taken 8611
     1077:18199-block 268
branch  3 taken 0 (fallthrough)
branch  4 taken 1077
    %%%%%:18199-block 269
branch  5 never executed (fallthrough)
branch  6 never executed
     1077:18199-block 270
     8611:18199-block 271
     9688:18199-block 272
branch  7 taken 1077 (fallthrough)
branch  8 taken 8611
     1077:18200:            BeginDockableDragDropTarget(host_window);
     1077:18200-block 273
call    0 returned 1077
        -:18201:
        -:18202:    // We update this after DockNodeUpdateTabBar()
     9693:18203:    node->LastFrameActive = g.FrameCount;
        -:18204:
        -:18205:    // Recurse into children
        -:18206:    // FIXME-DOCK FIXME-OPT: Should not need to recurse into children
     9693:18207:    if (host_window)
     9693:18207-block 274
branch  0 taken 9693 (fallthrough)
branch  1 taken 0
        -:18208:    {
     9693:18209:        if (node->ChildNodes[0])
     9693:18209-block 275
branch  0 taken 4308 (fallthrough)
branch  1 taken 5385
     4308:18210:            DockNodeUpdate(node->ChildNodes[0]);
     4308:18210-block 276
call    0 returned 4308
     9693:18211:        if (node->ChildNodes[1])
     9693:18211-block 277
branch  0 taken 4308 (fallthrough)
branch  1 taken 5385
     4308:18212:            DockNodeUpdate(node->ChildNodes[1]);
     4308:18212-block 278
call    0 returned 4308
        -:18213:
        -:18214:        // Render outer borders last (after the tab bar)
     9693:18215:        if (node->IsRootNode())
     9693:18215-block 279
call    0 returned 9693
branch  1 taken 1077 (fallthrough)
branch  2 taken 8616
     1077:18216:            RenderWindowOuterBorders(host_window);
     1077:18216-block 281
call    0 returned 1077
        -:18217:    }
        -:18218:
        -:18219:    // End host window
     9693:18220:    if (beginned_into_host_window) //-V1020
     9693:18220-block 282
branch  0 taken 0 (fallthrough)
branch  1 taken 9693
    #####:18221:        End();
    %%%%%:18221-block 283
call    0 never executed
        -:18222:}
        -:18223:
        -:18224:// Compare TabItem nodes given the last known DockOrder (will persist in .ini file as hint), used to sort tabs when multiple tabs are added on the same frame.
function _ZL26TabItemComparerByDockOrderPKvS0_ called 0 returned 0% blocks executed 0%
    #####:18225:static int IMGUI_CDECL TabItemComparerByDockOrder(const void* lhs, const void* rhs)
        -:18226:{
    #####:18227:    ImGuiWindow* a = ((const ImGuiTabItem*)lhs)->Window;
    #####:18228:    ImGuiWindow* b = ((const ImGuiTabItem*)rhs)->Window;
    #####:18229:    if (int d = ((a->DockOrder == -1) ? INT_MAX : a->DockOrder) - ((b->DockOrder == -1) ? INT_MAX : b->DockOrder))
    %%%%%:18229-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18229-block 3
    %%%%%:18229-block 4
    %%%%%:18229-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:18229-block 6
    %%%%%:18229-block 7
    %%%%%:18229-block 8
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:18230:        return d;
    %%%%%:18230-block 9
    #####:18231:    return (a->BeginOrderWithinContext - b->BeginOrderWithinContext);
    %%%%%:18231-block 10
        -:18232:}
        -:18233:
        -:18234:// Default handler for g.DockNodeWindowMenuHandler(): display the list of windows for a given dock-node.
        -:18235:// This is exceptionally stored in a function pointer to also user applications to tweak this menu (undocumented)
        -:18236:// Custom overrides may want to decorate, group, sort entries.
        -:18237:// Please note those are internal structures: if you copy this expect occasional breakage.
        -:18238:// (if you don't need to modify the "Tabs.Size == 1" behavior/path it is recommend you call this function in your handler)
function _ZN5ImGui33DockNodeWindowMenuHandler_DefaultEP12ImGuiContextP13ImGuiDockNodeP11ImGuiTabBar called 0 returned 0% blocks executed 0%
    #####:18239:void ImGui::DockNodeWindowMenuHandler_Default(ImGuiContext* ctx, ImGuiDockNode* node, ImGuiTabBar* tab_bar)
        -:18240:{
        -:18241:    IM_UNUSED(ctx);
    #####:18242:    if (tab_bar->Tabs.Size == 1)
    %%%%%:18242-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -:18243:    {
        -:18244:        // "Hide tab bar" option. Being one of our rare user-facing string we pull it from a table.
    #####:18245:        if (MenuItem(LocalizeGetMsg(ImGuiLocKey_DockingHideTabBar), NULL, node->IsHiddenTabBar()))
    %%%%%:18245-block 3
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:18246:            node->WantHiddenTabBarToggle = true;
    %%%%%:18246-block 7
        -:18247:    }
        -:18248:    else
        -:18249:    {
        -:18250:        // Display a selectable list of windows in this docking node
    #####:18251:        for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)
    %%%%%:18251-block 8
    %%%%%:18251-block 19
    %%%%%:18251-block 20
branch  0 never executed
branch  1 never executed (fallthrough)
        -:18252:        {
    #####:18253:            ImGuiTabItem* tab = &tab_bar->Tabs[tab_n];
    %%%%%:18253-block 9
call    0 never executed
    #####:18254:            if (tab->Flags & ImGuiTabItemFlags_Button)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:18255:                continue;
    %%%%%:18255-block 11
    #####:18256:            if (Selectable(TabBarGetTabName(tab_bar, tab), tab->ID == tab_bar->SelectedTabId))
    %%%%%:18256-block 12
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:18256-block 14
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    %%%%%:18256-block 15
branch  7 never executed (fallthrough)
branch  8 never executed
    #####:18257:                TabBarQueueFocus(tab_bar, tab);
    %%%%%:18257-block 16
call    0 never executed
    #####:18258:            SameLine();
    %%%%%:18258-block 17
call    0 never executed
    #####:18259:            Text("   ");
call    0 never executed
        -:18260:        }
        -:18261:    }
    #####:18262:}
    %%%%%:18262-block 21
        -:18263:
function _ZN5ImGuiL24DockNodeWindowMenuUpdateEP13ImGuiDockNodeP11ImGuiTabBar called 0 returned 0% blocks executed 0%
    #####:18264:static void ImGui::DockNodeWindowMenuUpdate(ImGuiDockNode* node, ImGuiTabBar* tab_bar)
        -:18265:{
        -:18266:    // Try to position the menu so it is more likely to stays within the same viewport
    #####:18267:    ImGuiContext& g = *GImGui;
    #####:18268:    if (g.Style.WindowMenuButtonPosition == ImGuiDir_Left)
    %%%%%:18268-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:18269:        SetNextWindowPos(ImVec2(node->Pos.x, node->Pos.y + GetFrameHeight()), ImGuiCond_Always, ImVec2(0.0f, 0.0f));
    %%%%%:18269-block 3
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:18270:    else
    #####:18271:        SetNextWindowPos(ImVec2(node->Pos.x + node->Size.x, node->Pos.y + GetFrameHeight()), ImGuiCond_Always, ImVec2(1.0f, 0.0f));
    %%%%%:18271-block 8
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:18272:    if (BeginPopup("#WindowMenu"))
    %%%%%:18272-block 13
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -:18273:    {
    #####:18274:        node->IsFocused = true;
    #####:18275:        g.DockNodeWindowMenuHandler(&g, node, tab_bar);
    %%%%%:18275-block 15
call    0 never executed
    #####:18276:        EndPopup();
call    0 never executed
        -:18277:    }
    #####:18278:}
        -:18279:
        -:18280:// User helper to append/amend into a dock node tab bar. Most commonly used to add e.g. a "+" button.
function _ZN5ImGui24DockNodeBeginAmendTabBarEP13ImGuiDockNode called 0 returned 0% blocks executed 0%
    #####:18281:bool ImGui::DockNodeBeginAmendTabBar(ImGuiDockNode* node)
        -:18282:{
    #####:18283:    if (node->TabBar == NULL || node->HostWindow == NULL)
    %%%%%:18283-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18283-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:18284:        return false;
    %%%%%:18284-block 4
    #####:18285:    if (node->MergedFlags & ImGuiDockNodeFlags_KeepAliveOnly)
    %%%%%:18285-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:18286:        return false;
    %%%%%:18286-block 6
    #####:18287:    if (node->TabBar->ID == 0)
    %%%%%:18287-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:18288:        return false;
    %%%%%:18288-block 8
    #####:18289:    Begin(node->HostWindow->Name);
    %%%%%:18289-block 9
call    0 never executed
    #####:18290:    PushOverrideID(node->ID);
call    0 never executed
    #####:18291:    bool ret = BeginTabBarEx(node->TabBar, node->TabBar->BarRect, node->TabBar->Flags);
call    0 never executed
        -:18292:    IM_UNUSED(ret);
    #####:18293:    IM_ASSERT(ret);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18293-block 13
call    2 never executed
    #####:18294:    return true;
    %%%%%:18294-block 14
        -:18295:}
        -:18296:
function _ZN5ImGui22DockNodeEndAmendTabBarEv called 0 returned 0% blocks executed 0%
    #####:18297:void ImGui::DockNodeEndAmendTabBar()
        -:18298:{
    #####:18299:    EndTabBar();
    %%%%%:18299-block 2
call    0 never executed
    #####:18300:    PopID();
call    0 never executed
    #####:18301:    End();
call    0 never executed
    #####:18302:}
        -:18303:
function _ZL29IsDockNodeTitleBarHighlightedP13ImGuiDockNodeS0_ called 5380 returned 100% blocks executed 67%
     5380:18304:static bool IsDockNodeTitleBarHighlighted(ImGuiDockNode* node, ImGuiDockNode* root_node)
        -:18305:{
        -:18306:    // CTRL+Tab highlight (only highlighting leaf node, not whole hierarchy)
     5380:18307:    ImGuiContext& g = *GImGui;
     5380:18308:    if (g.NavWindowingTarget)
     5380:18308-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    #####:18309:        return (g.NavWindowingTarget->DockNode == node);
    %%%%%:18309-block 3
        -:18310:
        -:18311:    // FIXME-DOCKING: May want alternative to treat central node void differently? e.g. if (g.NavWindow == host_window)
     5380:18312:    if (g.NavWindow && root_node->LastFocusedNodeId == node->ID)
     5380:18312-block 4
branch  0 taken 5380 (fallthrough)
branch  1 taken 0
     5380:18312-block 5
branch  2 taken 1076 (fallthrough)
branch  3 taken 4304
        -:18313:    {
        -:18314:        // FIXME: This could all be backed in RootWindowForTitleBarHighlight? Probably need to reorganize for both dock nodes + other RootWindowForTitleBarHighlight users (not-node)
     1076:18315:        ImGuiWindow* parent_window = g.NavWindow->RootWindow;
     1076:18316:        while (parent_window->Flags & ImGuiWindowFlags_ChildMenu)
     1076:18316-block 6
     1076:18316-block 8
branch  0 taken 0
branch  1 taken 1076 (fallthrough)
    #####:18317:            parent_window = parent_window->ParentWindow->RootWindow;
    %%%%%:18317-block 7
    1076*:18318:        ImGuiDockNode* start_parent_node = parent_window->DockNodeAsHost ? parent_window->DockNodeAsHost : parent_window->DockNode;
     1076:18318-block 9
branch  0 taken 0 (fallthrough)
branch  1 taken 1076
    %%%%%:18318-block 10
     1076:18318-block 11
    1076*:18319:        for (ImGuiDockNode* parent_node = start_parent_node; parent_node != NULL; parent_node = parent_node->HostWindow ? parent_node->HostWindow->RootWindow->DockNode : NULL)
     1076:18319-block 12
    %%%%%:18319-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18319-block 17
    %%%%%:18319-block 18
    %%%%%:18319-block 19
     1076:18319-block 20
branch  2 taken 1076
branch  3 taken 0 (fallthrough)
     1076:18320:            if ((parent_node = ImGui::DockNodeGetRootNode(parent_node)) == root_node)
     1076:18320-block 13
call    0 returned 1076
branch  1 taken 1076 (fallthrough)
branch  2 taken 0
     1076:18321:                return true;
     1076:18321-block 15
        -:18322:    }
     4304:18323:    return false;
     4304:18323-block 21
        -:18324:}
        -:18325:
        -:18326:// Submit the tab bar corresponding to a dock node and various housekeeping details.
function _ZN5ImGuiL20DockNodeUpdateTabBarEP13ImGuiDockNodeP11ImGuiWindow called 5380 returned 100% blocks executed 60%
     5380:18327:static void ImGui::DockNodeUpdateTabBar(ImGuiDockNode* node, ImGuiWindow* host_window)
        -:18328:{
     5380:18329:    ImGuiContext& g = *GImGui;
     5380:18330:    ImGuiStyle& style = g.Style;
        -:18331:
     5380:18332:    const bool node_was_active = (node->LastFrameActive + 1 == g.FrameCount);
    5380*:18333:    const bool closed_all = node->WantCloseAll && node_was_active;
     5380:18333-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    %%%%%:18333-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:18333-block 4
     5380:18333-block 5
    5380*:18334:    const ImGuiID closed_one = node->WantCloseTabId && node_was_active;
     5380:18334-block 6
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    %%%%%:18334-block 7
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:18334-block 8
     5380:18334-block 9
     5380:18335:    node->WantCloseAll = false;
     5380:18336:    node->WantCloseTabId = 0;
        -:18337:
        -:18338:    // Decide if we should use a focused title bar color
     5380:18339:    bool is_focused = false;
     5380:18340:    ImGuiDockNode* root_node = DockNodeGetRootNode(node);
     5380:18340-block 10
call    0 returned 5380
     5380:18341:    if (IsDockNodeTitleBarHighlighted(node, root_node))
call    0 returned 5380
branch  1 taken 1076 (fallthrough)
branch  2 taken 4304
     1076:18342:        is_focused = true;
     1076:18342-block 13
        -:18343:
        -:18344:    // Hidden tab bar will show a triangle on the upper-left (in Begin)
    5380*:18345:    if (node->IsHiddenTabBar() || node->IsNoTabBar())
     5380:18345-block 14
call    0 returned 5380
branch  1 taken 5380 (fallthrough)
branch  2 taken 0
     5380:18345-block 16
call    3 returned 5380
branch  4 taken 0 (fallthrough)
branch  5 taken 5380
    %%%%%:18345-block 18
     5380:18345-block 19
     5380:18345-block 20
branch  6 taken 0 (fallthrough)
branch  7 taken 5380
        -:18346:    {
    #####:18347:        node->VisibleWindow = (node->Windows.Size > 0) ? node->Windows[0] : NULL;
    %%%%%:18347-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18347-block 22
call    2 never executed
    %%%%%:18347-block 24
    #####:18348:        node->IsFocused = is_focused;
    #####:18349:        if (is_focused)
    %%%%%:18349-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:18350:            node->LastFrameFocused = g.FrameCount;
    %%%%%:18350-block 26
    #####:18351:        if (node->VisibleWindow)
    %%%%%:18351-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
        -:18352:        {
        -:18353:            // Notify root of visible window (used to display title in OS task bar)
    #####:18354:            if (is_focused || root_node->VisibleWindow == NULL)
    %%%%%:18354-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18354-block 29
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:18355:                root_node->VisibleWindow = node->VisibleWindow;
    %%%%%:18355-block 30
    #####:18356:            if (node->TabBar)
    %%%%%:18356-block 31
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:18357:                node->TabBar->VisibleTabId = node->VisibleWindow->TabId;
    %%%%%:18357-block 32
        -:18358:        }
    #####:18359:        return;
    %%%%%:18359-block 33
        -:18360:    }
        -:18361:
        -:18362:    // Move ourselves to the Menu layer (so we can be accessed by tapping Alt) + undo SkipItems flag in order to draw over the title bar even if the window is collapsed
     5380:18363:    bool backup_skip_item = host_window->SkipItems;
     5380:18364:    if (!node->IsDockSpace())
     5380:18364-block 34
call    0 returned 5380
branch  1 taken 5380 (fallthrough)
branch  2 taken 0
        -:18365:    {
     5380:18366:        host_window->SkipItems = false;
     5380:18367:        host_window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;
     5380:18367-block 36
        -:18368:    }
        -:18369:
        -:18370:    // Use PushOverrideID() instead of PushID() to use the node id _without_ the host window ID.
        -:18371:    // This is to facilitate computing those ID from the outside, and will affect more or less only the ID of the collapse button, popup and tabs,
        -:18372:    // as docked windows themselves will override the stack with their own root ID.
     5380:18373:    PushOverrideID(node->ID);
     5380:18373-block 37
call    0 returned 5380
branch  1 taken 5380 (fallthrough)
branch  2 taken 0 (throw)
     5380:18374:    ImGuiTabBar* tab_bar = node->TabBar;
     5380:18375:    bool tab_bar_is_recreated = (tab_bar == NULL); // Tab bar are automatically destroyed when a node gets hidden
     5380:18376:    if (tab_bar == NULL)
     5380:18376-block 38
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
        -:18377:    {
    #####:18378:        DockNodeAddTabBar(node);
    %%%%%:18378-block 39
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:18379:        tab_bar = node->TabBar;
    %%%%%:18379-block 40
        -:18380:    }
        -:18381:
     5380:18382:    ImGuiID focus_tab_id = 0;
     5380:18383:    node->IsFocused = is_focused;
        -:18384:
     5380:18385:    const ImGuiDockNodeFlags node_flags = node->MergedFlags;
    5380*:18386:    const bool has_window_menu_button = (node_flags & ImGuiDockNodeFlags_NoWindowMenuButton) == 0 && (style.WindowMenuButtonPosition != ImGuiDir_None);
     5380:18386-block 41
branch  0 taken 5380 (fallthrough)
branch  1 taken 0
     5380:18386-block 42
branch  2 taken 5380 (fallthrough)
branch  3 taken 0
     5380:18386-block 43
    %%%%%:18386-block 44
        -:18387:
        -:18388:    // In a dock node, the Collapse Button turns into the Window Menu button.
        -:18389:    // FIXME-DOCK FIXME-OPT: Could we recycle popups id across multiple dock nodes?
    5380*:18390:    if (has_window_menu_button && IsPopupOpen("#WindowMenu"))
     5380:18390-block 45
branch  0 taken 5380 (fallthrough)
branch  1 taken 0
     5380:18390-block 46
call    2 returned 5380
branch  3 taken 5380 (fallthrough)
branch  4 taken 0 (throw)
     5380:18390-block 47
branch  5 taken 0 (fallthrough)
branch  6 taken 5380
    %%%%%:18390-block 48
     5380:18390-block 49
     5380:18390-block 50
branch  7 taken 0 (fallthrough)
branch  8 taken 5380
        -:18391:    {
    #####:18392:        ImGuiID next_selected_tab_id = tab_bar->NextSelectedTabId;
    #####:18393:        DockNodeWindowMenuUpdate(node, tab_bar);
    %%%%%:18393-block 51
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:18394:        if (tab_bar->NextSelectedTabId != 0 && tab_bar->NextSelectedTabId != next_selected_tab_id)
    %%%%%:18394-block 52
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18394-block 53
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:18395:            focus_tab_id = tab_bar->NextSelectedTabId;
    %%%%%:18395-block 54
    #####:18396:        is_focused |= node->IsFocused;
    %%%%%:18396-block 55
        -:18397:    }
        -:18398:
        -:18399:    // Layout
     5380:18400:    ImRect title_bar_rect, tab_bar_rect;
     5380:18401:    ImVec2 window_menu_button_pos;
     5380:18402:    ImVec2 close_button_pos;
     5380:18403:    DockNodeCalcTabBarLayout(node, &title_bar_rect, &tab_bar_rect, &window_menu_button_pos, &close_button_pos);
     5380:18403-block 56
call    0 returned 5380
        -:18404:
        -:18405:    // Submit new tabs, they will be added as Unsorted and sorted below based on relative DockOrder value.
     5380:18406:    const int tabs_count_old = tab_bar->Tabs.Size;
    10760:18407:    for (int window_n = 0; window_n < node->Windows.Size; window_n++)
     5380:18407-block 62
    10760:18407-block 63
branch  0 taken 5380
branch  1 taken 5380 (fallthrough)
        -:18408:    {
     5380:18409:        ImGuiWindow* window = node->Windows[window_n];
     5380:18409-block 58
call    0 returned 5380
     5380:18410:        if (TabBarFindTabByID(tab_bar, window->TabId) == NULL)
call    0 returned 5380
branch  1 taken 5380 (fallthrough)
branch  2 taken 0 (throw)
     5380:18410-block 60
branch  3 taken 0 (fallthrough)
branch  4 taken 5380
    #####:18411:            TabBarAddTab(tab_bar, ImGuiTabItemFlags_Unsorted, window);
    %%%%%:18411-block 61
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:18412:    }
        -:18413:
        -:18414:    // Title bar
     5380:18415:    if (is_focused)
     5380:18415-block 64
branch  0 taken 1076 (fallthrough)
branch  1 taken 4304
     1076:18416:        node->LastFrameFocused = g.FrameCount;
     1076:18416-block 65
    5380*:18417:    ImU32 title_bar_col = GetColorU32(host_window->Collapsed ? ImGuiCol_TitleBgCollapsed : is_focused ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBg);
     5380:18417-block 66
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    %%%%%:18417-block 67
     5380:18417-block 68
branch  2 taken 1076 (fallthrough)
branch  3 taken 4304
     1076:18417-block 69
     4304:18417-block 70
     5380:18417-block 71
     5380:18417-block 72
call    4 returned 5380
     5380:18418:    ImDrawFlags rounding_flags = CalcRoundingFlagsForRectInRect(title_bar_rect, host_window->Rect(), g.Style.DockingSeparatorSize);
call    0 returned 5380
call    1 returned 5380
branch  2 taken 5380 (fallthrough)
branch  3 taken 0 (throw)
    $$$$$:18418-block 241
     5380:18419:    host_window->DrawList->AddRectFilled(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, host_window->WindowRounding, rounding_flags);
     5380:18419-block 75
call    0 returned 5380
branch  1 taken 5380 (fallthrough)
branch  2 taken 0 (throw)
        -:18420:
        -:18421:    // Docking/Collapse button
     5380:18422:    if (has_window_menu_button)
     5380:18422-block 76
branch  0 taken 5380 (fallthrough)
branch  1 taken 0
        -:18423:    {
     5380:18424:        if (CollapseButton(host_window->GetID("#COLLAPSE"), window_menu_button_pos, node)) // == DockNodeGetWindowMenuButtonId(node)
     5380:18424-block 77
call    0 returned 5380
branch  1 taken 5380 (fallthrough)
branch  2 taken 0 (throw)
     5380:18424-block 78
call    3 returned 5380
branch  4 taken 5380 (fallthrough)
branch  5 taken 0 (throw)
     5380:18424-block 79
branch  6 taken 0 (fallthrough)
branch  7 taken 5380
    #####:18425:            OpenPopup("#WindowMenu");
    %%%%%:18425-block 80
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
     5380:18426:        if (IsItemActive())
     5380:18426-block 81
call    0 returned 5380
branch  1 taken 0 (fallthrough)
branch  2 taken 5380
    #####:18427:            focus_tab_id = tab_bar->SelectedTabId;
    %%%%%:18427-block 83
    5380*:18428:        if (IsItemHovered(ImGuiHoveredFlags_ForTooltip | ImGuiHoveredFlags_DelayNormal) && g.HoveredIdTimer > 0.5f)
     5380:18428-block 84
call    0 returned 5380
branch  1 taken 5380 (fallthrough)
branch  2 taken 0 (throw)
     5380:18428-block 85
branch  3 taken 0 (fallthrough)
branch  4 taken 5380
    %%%%%:18428-block 86
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:18428-block 87
     5380:18428-block 88
     5380:18428-block 89
branch  7 taken 0 (fallthrough)
branch  8 taken 5380
    #####:18429:            SetTooltip("%s", LocalizeGetMsg(ImGuiLocKey_DockingDragToUndockOrMoveNode));
    %%%%%:18429-block 90
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
        -:18430:    }
        -:18431:
        -:18432:    // If multiple tabs are appearing on the same frame, sort them based on their persistent DockOrder value
     5380:18433:    int tabs_unsorted_start = tab_bar->Tabs.Size;
     5385:18434:    for (int tab_n = tab_bar->Tabs.Size - 1; tab_n >= 0 && (tab_bar->Tabs[tab_n].Flags & ImGuiTabItemFlags_Unsorted); tab_n--)
     5380:18434-block 92
     5385:18434-block 95
branch  0 taken 5380 (fallthrough)
branch  1 taken 5
     5380:18434-block 96
call    2 returned 5380
branch  3 taken 5 (fallthrough)
branch  4 taken 5375
        5:18434-block 98
     5380:18434-block 99
     5385:18434-block 100
branch  5 taken 5
branch  6 taken 5380 (fallthrough)
        -:18435:    {
        -:18436:        // FIXME-DOCK: Consider only clearing the flag after the tab has been alive for a few consecutive frames, allowing late comers to not break sorting?
        5:18437:        tab_bar->Tabs[tab_n].Flags &= ~ImGuiTabItemFlags_Unsorted;
        5:18437-block 93
call    0 returned 5
        5:18438:        tabs_unsorted_start = tab_n;
        -:18439:    }
     5380:18440:    if (tab_bar->Tabs.Size > tabs_unsorted_start)
     5380:18440-block 101
branch  0 taken 5 (fallthrough)
branch  1 taken 5375
        -:18441:    {
       5*:18442:        IMGUI_DEBUG_LOG_DOCKING("[docking] In node 0x%08X: %d new appearing tabs:%s\n", node->ID, tab_bar->Tabs.Size - tabs_unsorted_start, (tab_bar->Tabs.Size > tabs_unsorted_start + 1) ? " (will sort)" : "");
        5:18442-block 102
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    %%%%%:18442-block 103
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:18442-block 104
    %%%%%:18442-block 105
    %%%%%:18442-block 106
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
       10:18443:        for (int tab_n = tabs_unsorted_start; tab_n < tab_bar->Tabs.Size; tab_n++)
        5:18443-block 107
        5:18443-block 115
       10:18443-block 116
branch  0 taken 5
branch  1 taken 5 (fallthrough)
        -:18444:        {
        5:18445:            ImGuiTabItem* tab = &tab_bar->Tabs[tab_n];
        5:18445-block 108
call    0 returned 5
       5*:18446:            IMGUI_DEBUG_LOG_DOCKING("[docking] - Tab 0x%08X '%s' Order %d\n", tab->ID, TabBarGetTabName(tab_bar, tab), tab->Window ? tab->Window->DockOrder : -1);
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    %%%%%:18446-block 110
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:18446-block 111
    %%%%%:18446-block 112
    %%%%%:18446-block 113
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    %%%%%:18446-block 114
call    7 never executed
branch  8 never executed (fallthrough)
branch  9 never executed (throw)
        -:18447:        }
       5*:18448:        IMGUI_DEBUG_LOG_DOCKING("[docking] SelectedTabId = 0x%08X, NavWindow->TabId = 0x%08X\n", node->SelectedTabId, g.NavWindow ? g.NavWindow->TabId : -1);
        5:18448-block 117
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    %%%%%:18448-block 118
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:18448-block 119
    %%%%%:18448-block 120
    %%%%%:18448-block 121
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
        5:18449:        if (tab_bar->Tabs.Size > tabs_unsorted_start + 1)
        5:18449-block 122
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    #####:18450:            ImQsort(tab_bar->Tabs.Data + tabs_unsorted_start, tab_bar->Tabs.Size - tabs_unsorted_start, sizeof(ImGuiTabItem), TabItemComparerByDockOrder);
    %%%%%:18450-block 123
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:18451:    }
        -:18452:
        -:18453:    // Apply NavWindow focus back to the tab bar
     5380:18454:    if (g.NavWindow && g.NavWindow->RootWindow->DockNode == node)
     5380:18454-block 124
branch  0 taken 5380 (fallthrough)
branch  1 taken 0
     5380:18454-block 125
branch  2 taken 1076 (fallthrough)
branch  3 taken 4304
     1076:18455:        tab_bar->SelectedTabId = g.NavWindow->RootWindow->TabId;
     1076:18455-block 126
        -:18456:
        -:18457:    // Selected newly added tabs, or persistent tab ID if the tab bar was just recreated
    5380*:18458:    if (tab_bar_is_recreated && TabBarFindTabByID(tab_bar, node->SelectedTabId) != NULL)
     5380:18458-block 127
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    %%%%%:18458-block 128
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%:18458-block 129
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:18458-block 130
     5380:18458-block 131
     5380:18458-block 132
branch  7 taken 0 (fallthrough)
branch  8 taken 5380
    #####:18459:        tab_bar->SelectedTabId = tab_bar->NextSelectedTabId = node->SelectedTabId;
    %%%%%:18459-block 133
     5380:18460:    else if (tab_bar->Tabs.Size > tabs_count_old)
     5380:18460-block 134
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    #####:18461:        tab_bar->SelectedTabId = tab_bar->NextSelectedTabId = tab_bar->Tabs.back().Window->TabId;
    %%%%%:18461-block 135
call    0 never executed
        -:18462:
        -:18463:    // Begin tab bar
     5380:18464:    ImGuiTabBarFlags tab_bar_flags = ImGuiTabBarFlags_Reorderable | ImGuiTabBarFlags_AutoSelectNewTabs; // | ImGuiTabBarFlags_NoTabListScrollingButtons);
     5380:18465:    tab_bar_flags |= ImGuiTabBarFlags_SaveSettings | ImGuiTabBarFlags_DockNode;// | ImGuiTabBarFlags_FittingPolicyScroll;
     5380:18466:    tab_bar_flags |= ImGuiTabBarFlags_DrawSelectedOverline;
     5380:18467:    if (!host_window->Collapsed && is_focused)
     5380:18467-block 137
branch  0 taken 5380 (fallthrough)
branch  1 taken 0
     5380:18467-block 138
branch  2 taken 1076 (fallthrough)
branch  3 taken 4304
     1076:18468:        tab_bar_flags |= ImGuiTabBarFlags_IsFocused;
     1076:18468-block 139
     5380:18469:    tab_bar->ID = GetID("#TabBar");
     5380:18469-block 140
call    0 returned 5380
branch  1 taken 5380 (fallthrough)
branch  2 taken 0 (throw)
     5380:18470:    tab_bar->SeparatorMinX = node->Pos.x + host_window->WindowBorderSize; // Separator cover the whole node width
     5380:18471:    tab_bar->SeparatorMaxX = node->Pos.x + node->Size.x - host_window->WindowBorderSize;
     5380:18472:    BeginTabBarEx(tab_bar, tab_bar_rect, tab_bar_flags);
     5380:18472-block 141
call    0 returned 5380
branch  1 taken 5380 (fallthrough)
branch  2 taken 0 (throw)
        -:18473:    //host_window->DrawList->AddRect(tab_bar_rect.Min, tab_bar_rect.Max, IM_COL32(255,0,255,255));
        -:18474:
        -:18475:    // Backup style colors
     5380:18476:    ImVec4 backup_style_cols[ImGuiWindowDockStyleCol_COUNT];
    48420:18477:    for (int color_n = 0; color_n < ImGuiWindowDockStyleCol_COUNT; color_n++)
     5380:18477-block 142
    48420:18477-block 144
branch  0 taken 43040
branch  1 taken 5380 (fallthrough)
    43040:18478:        backup_style_cols[color_n] = g.Style.Colors[GWindowDockStyleColors[color_n]];
    43040:18478-block 143
        -:18479:
        -:18480:    // Submit actual tabs
     5380:18481:    node->VisibleWindow = NULL;
    10760:18482:    for (int window_n = 0; window_n < node->Windows.Size; window_n++)
     5380:18482-block 145
     5380:18482-block 175
    10760:18482-block 176
branch  0 taken 5380
branch  1 taken 5380 (fallthrough)
        -:18483:    {
     5380:18484:        ImGuiWindow* window = node->Windows[window_n];
     5380:18484-block 146
call    0 returned 5380
    5380*:18485:        if ((closed_all || closed_one == window->TabId) && window->HasCloseButton && !(window->Flags & ImGuiWindowFlags_UnsavedDocument))
branch  0 taken 5380 (fallthrough)
branch  1 taken 0
     5380:18485-block 148
branch  2 taken 0 (fallthrough)
branch  3 taken 5380
    %%%%%:18485-block 149
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:18485-block 150
branch  6 never executed (fallthrough)
branch  7 never executed
    #####:18486:            continue;
    %%%%%:18486-block 151
    5380*:18487:        if (window->LastFrameActive + 1 >= g.FrameCount || !node_was_active)
     5380:18487-block 152
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    %%%%%:18487-block 153
branch  2 never executed (fallthrough)
branch  3 never executed
        -:18488:        {
     5380:18489:            ImGuiTabItemFlags tab_item_flags = 0;
     5380:18490:            tab_item_flags |= window->WindowClass.TabItemFlagsOverrideSet;
     5380:18491:            if (window->Flags & ImGuiWindowFlags_UnsavedDocument)
     5380:18491-block 154
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    #####:18492:                tab_item_flags |= ImGuiTabItemFlags_UnsavedDocument;
    %%%%%:18492-block 155
     5380:18493:            if (tab_bar->Flags & ImGuiTabBarFlags_NoCloseWithMiddleMouseButton)
     5380:18493-block 156
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    #####:18494:                tab_item_flags |= ImGuiTabItemFlags_NoCloseWithMiddleMouseButton;
    %%%%%:18494-block 157
        -:18495:
        -:18496:            // Apply stored style overrides for the window
    48420:18497:            for (int color_n = 0; color_n < ImGuiWindowDockStyleCol_COUNT; color_n++)
     5380:18497-block 158
    48420:18497-block 161
branch  0 taken 43040
branch  1 taken 5380 (fallthrough)
    43040:18498:                g.Style.Colors[GWindowDockStyleColors[color_n]] = ColorConvertU32ToFloat4(window->DockStyle.Colors[color_n]);
    43040:18498-block 159
call    0 returned 43040
        -:18499:
        -:18500:            // Note that TabItemEx() calls TabBarCalcTabID() so our tab item ID will ignore the current ID stack (rightly so)
     5380:18501:            bool tab_open = true;
    5380*:18502:            TabItemEx(tab_bar, window->Name, window->HasCloseButton ? &tab_open : NULL, tab_item_flags, window);
     5380:18502-block 162
branch  0 taken 5380 (fallthrough)
branch  1 taken 0
     5380:18502-block 163
    %%%%%:18502-block 164
     5380:18502-block 165
call    2 returned 5380
branch  3 taken 5380 (fallthrough)
branch  4 taken 0 (throw)
     5380:18503:            if (!tab_open)
     5380:18503-block 166
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    #####:18504:                node->WantCloseTabId = window->TabId;
    %%%%%:18504-block 167
     5380:18505:            if (tab_bar->VisibleTabId == window->TabId)
     5380:18505-block 168
branch  0 taken 5380 (fallthrough)
branch  1 taken 0
     5380:18506:                node->VisibleWindow = window;
     5380:18506-block 169
        -:18507:
        -:18508:            // Store last item data so it can be queried with IsItemXXX functions after the user Begin() call
     5380:18509:            window->DockTabItemStatusFlags = g.LastItemData.StatusFlags;
     5380:18510:            window->DockTabItemRect = g.LastItemData.Rect;
        -:18511:
        -:18512:            // Update navigation ID on menu layer
     5380:18513:            if (g.NavWindow && g.NavWindow->RootWindow == window && (window->DC.NavLayersActiveMask & (1 << ImGuiNavLayer_Menu)) == 0)
     5380:18513-block 170
branch  0 taken 5380 (fallthrough)
branch  1 taken 0
     5380:18513-block 171
branch  2 taken 1076 (fallthrough)
branch  3 taken 4304
     1076:18513-block 172
branch  4 taken 1076 (fallthrough)
branch  5 taken 0
     1076:18514:                host_window->NavLastIds[1] = window->TabId;
     1076:18514-block 173
        -:18515:        }
        -:18516:    }
        -:18517:
        -:18518:    // Restore style colors
    48420:18519:    for (int color_n = 0; color_n < ImGuiWindowDockStyleCol_COUNT; color_n++)
     5380:18519-block 177
    48420:18519-block 179
branch  0 taken 43040
branch  1 taken 5380 (fallthrough)
    43040:18520:        g.Style.Colors[GWindowDockStyleColors[color_n]] = backup_style_cols[color_n];
    43040:18520-block 178
        -:18521:
        -:18522:    // Notify root of visible window (used to display title in OS task bar)
     5380:18523:    if (node->VisibleWindow)
     5380:18523-block 180
branch  0 taken 5380 (fallthrough)
branch  1 taken 0
     5380:18524:        if (is_focused || root_node->VisibleWindow == NULL)
     5380:18524-block 181
branch  0 taken 4304 (fallthrough)
branch  1 taken 1076
     4304:18524-block 182
branch  2 taken 1 (fallthrough)
branch  3 taken 4303
     1077:18525:            root_node->VisibleWindow = node->VisibleWindow;
     1077:18525-block 183
        -:18526:
        -:18527:    // Close button (after VisibleWindow was updated)
        -:18528:    // Note that VisibleWindow may have been overrided by CTRL+Tabbing, so VisibleWindow->TabId may be != from tab_bar->SelectedTabId
    5380*:18529:    const bool close_button_is_enabled = node->HasCloseButton && node->VisibleWindow && node->VisibleWindow->HasCloseButton;
     5380:18529-block 184
branch  0 taken 5380 (fallthrough)
branch  1 taken 0
     5380:18529-block 185
branch  2 taken 5380 (fallthrough)
branch  3 taken 0
     5380:18529-block 186
branch  4 taken 5380 (fallthrough)
branch  5 taken 0
     5380:18529-block 187
    %%%%%:18529-block 188
     5380:18530:    const bool close_button_is_visible = node->HasCloseButton;
        -:18531:    //const bool close_button_is_visible = close_button_is_enabled; // Most people would expect this behavior of not even showing the button (leaving a hole since we can't claim that space as other windows in the tba bar have one)
     5380:18532:    if (close_button_is_visible)
     5380:18532-block 189
branch  0 taken 5380 (fallthrough)
branch  1 taken 0
        -:18533:    {
     5380:18534:        if (!close_button_is_enabled)
     5380:18534-block 190
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
        -:18535:        {
    #####:18536:            PushItemFlag(ImGuiItemFlags_Disabled, true);
    %%%%%:18536-block 191
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:18537:            PushStyleColor(ImGuiCol_Text, style.Colors[ImGuiCol_Text] * ImVec4(1.0f,1.0f,1.0f,0.4f));
    %%%%%:18537-block 192
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%:18537-block 195
    $$$$$:18537-block 243
    $$$$$:18537-block 244
        -:18538:        }
     5380:18539:        if (CloseButton(host_window->GetID("#CLOSE"), close_button_pos))
     5380:18539-block 196
call    0 returned 5380
branch  1 taken 5380 (fallthrough)
branch  2 taken 0 (throw)
     5380:18539-block 197
call    3 returned 5380
branch  4 taken 5380 (fallthrough)
branch  5 taken 0 (throw)
     5380:18539-block 198
branch  6 taken 0 (fallthrough)
branch  7 taken 5380
        -:18540:        {
    #####:18541:            node->WantCloseAll = true;
    #####:18542:            for (int n = 0; n < tab_bar->Tabs.Size; n++)
    %%%%%:18542-block 199
    %%%%%:18542-block 202
    %%%%%:18542-block 203
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:18543:                TabBarCloseTab(tab_bar, &tab_bar->Tabs[n]);
    %%%%%:18543-block 200
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
        -:18544:        }
        -:18545:        //if (IsItemActive())
        -:18546:        //    focus_tab_id = tab_bar->SelectedTabId;
     5380:18547:        if (!close_button_is_enabled)
     5380:18547-block 204
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
        -:18548:        {
    #####:18549:            PopStyleColor();
    %%%%%:18549-block 205
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:18550:            PopItemFlag();
    %%%%%:18550-block 206
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:18551:        }
        -:18552:    }
        -:18553:
        -:18554:    // When clicking on the title bar outside of tabs, we still focus the selected tab for that node
        -:18555:    // FIXME: TabItems submitted earlier use AllowItemOverlap so we manually perform a more specific test for now (hovered || held) in order to not cover them.
     5380:18556:    ImGuiID title_bar_id = host_window->GetID("#TITLEBAR");
     5380:18556-block 207
call    0 returned 5380
branch  1 taken 5380 (fallthrough)
branch  2 taken 0 (throw)
    5380*:18557:    if (g.HoveredId == 0 || g.HoveredId == title_bar_id || g.ActiveId == title_bar_id)
     5380:18557-block 208
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    %%%%%:18557-block 209
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:18557-block 210
branch  4 never executed (fallthrough)
branch  5 never executed
        -:18558:    {
        -:18559:        // AllowOverlap mode required for appending into dock node tab bar,
        -:18560:        // otherwise dragging window will steal HoveredId and amended tabs cannot get them.
        -:18561:        bool held;
     5380:18562:        KeepAliveID(title_bar_id);
     5380:18562-block 211
call    0 returned 5380
     5380:18563:        ButtonBehavior(title_bar_rect, title_bar_id, NULL, &held, ImGuiButtonFlags_AllowOverlap);
call    0 returned 5380
branch  1 taken 5380 (fallthrough)
branch  2 taken 0 (throw)
     5380:18564:        if (g.HoveredId == title_bar_id)
     5380:18564-block 213
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
        -:18565:        {
    #####:18566:            g.LastItemData.ID = title_bar_id;
    %%%%%:18566-block 214
        -:18567:        }
     5380:18568:        if (held)
     5380:18568-block 215
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
        -:18569:        {
    #####:18570:            if (IsMouseClicked(0))
    %%%%%:18570-block 216
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:18570-block 217
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:18571:                focus_tab_id = tab_bar->SelectedTabId;
    %%%%%:18571-block 218
        -:18572:
        -:18573:            // Forward moving request to selected window
    #####:18574:            if (ImGuiTabItem* tab = TabBarFindTabByID(tab_bar, tab_bar->SelectedTabId))
    %%%%%:18574-block 219
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:18574-block 220
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:18575:                StartMouseMovingWindowOrNode(tab->Window ? tab->Window : node->HostWindow, node, false); // Undock from tab bar empty space
    %%%%%:18575-block 221
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18575-block 222
    %%%%%:18575-block 223
    %%%%%:18575-block 224
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
        -:18576:        }
        -:18577:    }
        -:18578:
        -:18579:    // Forward focus from host node to selected window
        -:18580:    //if (is_focused && g.NavWindow == host_window && !g.NavWindowingTarget)
        -:18581:    //    focus_tab_id = tab_bar->SelectedTabId;
        -:18582:
        -:18583:    // When clicked on a tab we requested focus to the docked child
        -:18584:    // This overrides the value set by "forward focus from host node to selected window".
     5380:18585:    if (tab_bar->NextSelectedTabId)
     5380:18585-block 226
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    #####:18586:        focus_tab_id = tab_bar->NextSelectedTabId;
    %%%%%:18586-block 227
        -:18587:
        -:18588:    // Apply navigation focus
     5380:18589:    if (focus_tab_id != 0)
     5380:18589-block 228
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    #####:18590:        if (ImGuiTabItem* tab = TabBarFindTabByID(tab_bar, focus_tab_id))
    %%%%%:18590-block 229
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:18590-block 230
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:18591:            if (tab->Window)
    %%%%%:18591-block 231
branch  0 never executed (fallthrough)
branch  1 never executed
        -:18592:            {
    #####:18593:                FocusWindow(tab->Window);
    %%%%%:18593-block 232
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:18594:                NavInitWindow(tab->Window, false);
    %%%%%:18594-block 233
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:18595:            }
        -:18596:
     5380:18597:    EndTabBar();
     5380:18597-block 234
call    0 returned 5380
branch  1 taken 5380 (fallthrough)
branch  2 taken 0 (throw)
     5380:18598:    PopID();
     5380:18598-block 235
call    0 returned 5380
branch  1 taken 5380 (fallthrough)
branch  2 taken 0 (throw)
        -:18599:
        -:18600:    // Restore SkipItems flag
     5380:18601:    if (!node->IsDockSpace())
     5380:18601-block 236
call    0 returned 5380
branch  1 taken 5380 (fallthrough)
branch  2 taken 0
        -:18602:    {
     5380:18603:        host_window->DC.NavLayerCurrent = ImGuiNavLayer_Main;
     5380:18604:        host_window->SkipItems = backup_skip_item;
     5380:18604-block 238
        -:18605:    }
        -:18606:}
        -:18607:
function _ZN5ImGuiL17DockNodeAddTabBarEP13ImGuiDockNode called 5 returned 100% blocks executed 67%
        5:18608:static void ImGui::DockNodeAddTabBar(ImGuiDockNode* node)
        -:18609:{
       5*:18610:    IM_ASSERT(node->TabBar == NULL);
        5:18610-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    %%%%%:18610-block 3
call    2 never executed
        5:18611:    node->TabBar = IM_NEW(ImGuiTabBar);
        5:18611-block 4
call    0 returned 5
call    1 returned 5
call    2 returned 5
branch  3 taken 5 (fallthrough)
branch  4 taken 0 (throw)
    $$$$$:18611-block 8
branch  5 never executed (fallthrough)
branch  6 never executed
    $$$$$:18611-block 9
call    7 never executed
        5:18612:}
        5:18612-block 7
        -:18613:
function _ZN5ImGuiL20DockNodeRemoveTabBarEP13ImGuiDockNode called 0 returned 0% blocks executed 0%
    #####:18614:static void ImGui::DockNodeRemoveTabBar(ImGuiDockNode* node)
        -:18615:{
    #####:18616:    if (node->TabBar == NULL)
    %%%%%:18616-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:18617:        return;
    %%%%%:18617-block 3
    #####:18618:    IM_DELETE(node->TabBar);
    %%%%%:18618-block 4
call    0 never executed
    #####:18619:    node->TabBar = NULL;
        -:18620:}
        -:18621:
function _ZL24DockNodeIsDropAllowedOneP11ImGuiWindowS0_ called 0 returned 0% blocks executed 0%
    #####:18622:static bool DockNodeIsDropAllowedOne(ImGuiWindow* payload, ImGuiWindow* host_window)
        -:18623:{
    #####:18624:    if (host_window->DockNodeAsHost && host_window->DockNodeAsHost->IsDockSpace() && payload->BeginOrderWithinContext < host_window->BeginOrderWithinContext)
    %%%%%:18624-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18624-block 3
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:18624-block 5
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:18624-block 6
    %%%%%:18624-block 7
    %%%%%:18624-block 8
branch  7 never executed (fallthrough)
branch  8 never executed
    #####:18625:        return false;
    %%%%%:18625-block 9
        -:18626:
    #####:18627:    ImGuiWindowClass* host_class = host_window->DockNodeAsHost ? &host_window->DockNodeAsHost->WindowClass : &host_window->WindowClass;
    %%%%%:18627-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18627-block 11
    %%%%%:18627-block 12
    #####:18628:    ImGuiWindowClass* payload_class = &payload->WindowClass;
    #####:18629:    if (host_class->ClassId != payload_class->ClassId)
    %%%%%:18629-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
        -:18630:    {
    #####:18631:        bool pass = false;
    #####:18632:        if (host_class->ClassId != 0 && host_class->DockingAllowUnclassed && payload_class->ClassId == 0)
    %%%%%:18632-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18632-block 15
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:18632-block 16
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:18633:            pass = true;
    %%%%%:18633-block 17
    #####:18634:        if (payload_class->ClassId != 0 && payload_class->DockingAllowUnclassed && host_class->ClassId == 0)
    %%%%%:18634-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18634-block 19
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:18634-block 20
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:18635:            pass = true;
    %%%%%:18635-block 21
    #####:18636:        if (!pass)
    %%%%%:18636-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:18637:            return false;
    %%%%%:18637-block 23
        -:18638:    }
        -:18639:
        -:18640:    // Prevent docking any window created above a popup
        -:18641:    // Technically we should support it (e.g. in the case of a long-lived modal window that had fancy docking features),
        -:18642:    // by e.g. adding a 'if (!ImGui::IsWindowWithinBeginStackOf(host_window, popup_window))' test.
        -:18643:    // But it would requires more work on our end because the dock host windows is technically created in NewFrame()
        -:18644:    // and our ->ParentXXX and ->RootXXX pointers inside windows are currently mislading or lacking.
    #####:18645:    ImGuiContext& g = *GImGui;
    #####:18646:    for (int i = g.OpenPopupStack.Size - 1; i >= 0; i--)
    %%%%%:18646-block 24
    %%%%%:18646-block 30
    %%%%%:18646-block 31
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:18647:        if (ImGuiWindow* popup_window = g.OpenPopupStack[i].Window)
    %%%%%:18647-block 25
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:18648:            if (ImGui::IsWindowWithinBeginStackOf(payload, popup_window))   // Payload is created from within a popup begin stack.
    %%%%%:18648-block 27
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:18649:                return false;
    %%%%%:18649-block 29
        -:18650:
    #####:18651:    return true;
    %%%%%:18651-block 32
        -:18652:}
        -:18653:
function _ZN5ImGuiL21DockNodeIsDropAllowedEP11ImGuiWindowS1_ called 0 returned 0% blocks executed 0%
    #####:18654:static bool ImGui::DockNodeIsDropAllowed(ImGuiWindow* host_window, ImGuiWindow* root_payload)
        -:18655:{
    #####:18656:    if (root_payload->DockNodeAsHost && root_payload->DockNodeAsHost->IsSplitNode()) // FIXME-DOCK: Missing filtering
    %%%%%:18656-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18656-block 3
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:18656-block 5
    %%%%%:18656-block 6
    %%%%%:18656-block 7
branch  5 never executed (fallthrough)
branch  6 never executed
    #####:18657:        return true;
    %%%%%:18657-block 8
        -:18658:
    #####:18659:    const int payload_count = root_payload->DockNodeAsHost ? root_payload->DockNodeAsHost->Windows.Size : 1;
    %%%%%:18659-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18659-block 10
    %%%%%:18659-block 11
    #####:18660:    for (int payload_n = 0; payload_n < payload_count; payload_n++)
    %%%%%:18660-block 12
    %%%%%:18660-block 20
    %%%%%:18660-block 21
branch  0 never executed
branch  1 never executed (fallthrough)
        -:18661:    {
    #####:18662:        ImGuiWindow* payload = root_payload->DockNodeAsHost ? root_payload->DockNodeAsHost->Windows[payload_n] : root_payload;
    %%%%%:18662-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18662-block 14
call    2 never executed
    %%%%%:18662-block 16
    #####:18663:        if (DockNodeIsDropAllowedOne(payload, host_window))
    %%%%%:18663-block 17
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:18664:            return true;
    %%%%%:18664-block 19
        -:18665:    }
    #####:18666:    return false;
    %%%%%:18666-block 22
        -:18667:}
        -:18668:
        -:18669:// window menu button == collapse button when not in a dock node.
        -:18670:// FIXME: This is similar to RenderWindowTitleBarContents(), may want to share code.
function _ZN5ImGuiL24DockNodeCalcTabBarLayoutEPK13ImGuiDockNodeP6ImRectS4_P6ImVec2S6_ called 5380 returned 100% blocks executed 95%
     5380:18671:static void ImGui::DockNodeCalcTabBarLayout(const ImGuiDockNode* node, ImRect* out_title_rect, ImRect* out_tab_bar_rect, ImVec2* out_window_menu_button_pos, ImVec2* out_close_button_pos)
        -:18672:{
     5380:18673:    ImGuiContext& g = *GImGui;
     5380:18674:    ImGuiStyle& style = g.Style;
        -:18675:
     5380:18676:    ImRect r = ImRect(node->Pos.x, node->Pos.y, node->Pos.x + node->Size.x, node->Pos.y + g.FontSize + g.Style.FramePadding.y * 2.0f);
     5380:18676-block 2
call    0 returned 5380
     5380:18677:    if (out_title_rect) { *out_title_rect = r; }
branch  0 taken 5380 (fallthrough)
branch  1 taken 0
     5380:18677-block 4
        -:18678:
     5380:18679:    r.Min.x += style.WindowBorderSize;
     5380:18680:    r.Max.x -= style.WindowBorderSize;
        -:18681:
     5380:18682:    float button_sz = g.FontSize;
     5380:18683:    r.Min.x += style.FramePadding.x;
     5380:18684:    r.Max.x -= style.FramePadding.x;
     5380:18685:    ImVec2 window_menu_button_pos = ImVec2(r.Min.x, r.Min.y + style.FramePadding.y);
     5380:18685-block 5
call    0 returned 5380
     5380:18686:    if (node->HasCloseButton)
branch  0 taken 5380 (fallthrough)
branch  1 taken 0
        -:18687:    {
     5380:18688:        if (out_close_button_pos) *out_close_button_pos = ImVec2(r.Max.x - button_sz, r.Min.y + style.FramePadding.y);
     5380:18688-block 7
branch  0 taken 5380 (fallthrough)
branch  1 taken 0
     5380:18688-block 8
call    2 returned 5380
     5380:18689:        r.Max.x -= button_sz + style.ItemInnerSpacing.x;
     5380:18689-block 10
        -:18690:    }
     5380:18691:    if (node->HasWindowMenuButton && style.WindowMenuButtonPosition == ImGuiDir_Left)
     5380:18691-block 11
branch  0 taken 5380 (fallthrough)
branch  1 taken 0
     5380:18691-block 12
branch  2 taken 0 (fallthrough)
branch  3 taken 5380
        -:18692:    {
    #####:18693:        r.Min.x += button_sz + style.ItemInnerSpacing.x;
    %%%%%:18693-block 13
        -:18694:    }
     5380:18695:    else if (node->HasWindowMenuButton && style.WindowMenuButtonPosition == ImGuiDir_Right)
     5380:18695-block 14
branch  0 taken 5380 (fallthrough)
branch  1 taken 0
     5380:18695-block 15
branch  2 taken 5380 (fallthrough)
branch  3 taken 0
        -:18696:    {
     5380:18697:        window_menu_button_pos = ImVec2(r.Max.x - button_sz, r.Min.y + style.FramePadding.y);
     5380:18697-block 16
call    0 returned 5380
     5380:18698:        r.Max.x -= button_sz + style.ItemInnerSpacing.x;
        -:18699:    }
     5380:18700:    if (out_tab_bar_rect) { *out_tab_bar_rect = r; }
     5380:18700-block 18
branch  0 taken 5380 (fallthrough)
branch  1 taken 0
     5380:18700-block 19
     5380:18701:    if (out_window_menu_button_pos) { *out_window_menu_button_pos = window_menu_button_pos; }
     5380:18701-block 20
branch  0 taken 5380 (fallthrough)
branch  1 taken 0
     5380:18701-block 21
     5380:18702:}
        -:18703:
function _ZN5ImGuiL22DockNodeCalcSplitRectsER6ImVec2S1_S1_S1_8ImGuiDirS0_ called 0 returned 0% blocks executed 0%
    #####:18704:void ImGui::DockNodeCalcSplitRects(ImVec2& pos_old, ImVec2& size_old, ImVec2& pos_new, ImVec2& size_new, ImGuiDir dir, ImVec2 size_new_desired)
        -:18705:{
    #####:18706:    ImGuiContext& g = *GImGui;
    #####:18707:    const float dock_spacing = g.Style.ItemInnerSpacing.x;
    #####:18708:    const ImGuiAxis axis = (dir == ImGuiDir_Left || dir == ImGuiDir_Right) ? ImGuiAxis_X : ImGuiAxis_Y;
    %%%%%:18708-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18708-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:18708-block 4
    %%%%%:18708-block 5
    #####:18709:    pos_new[axis ^ 1] = pos_old[axis ^ 1];
    %%%%%:18709-block 6
call    0 never executed
call    1 never executed
    #####:18710:    size_new[axis ^ 1] = size_old[axis ^ 1];
call    0 never executed
call    1 never executed
        -:18711:
        -:18712:    // Distribute size on given axis (with a desired size or equally)
    #####:18713:    const float w_avail = size_old[axis] - dock_spacing;
call    0 never executed
    #####:18714:    if (size_new_desired[axis] > 0.0f && size_new_desired[axis] <= w_avail * 0.5f)
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:18714-block 13
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:18714-block 15
    %%%%%:18714-block 16
    %%%%%:18714-block 17
branch  6 never executed (fallthrough)
branch  7 never executed
        -:18715:    {
    #####:18716:        size_new[axis] = size_new_desired[axis];
    %%%%%:18716-block 18
call    0 never executed
call    1 never executed
    #####:18717:        size_old[axis] = IM_TRUNC(w_avail - size_new[axis]);
call    0 never executed
call    1 never executed
        -:18718:    }
        -:18719:    else
        -:18720:    {
    #####:18721:        size_new[axis] = IM_TRUNC(w_avail * 0.5f);
    %%%%%:18721-block 23
call    0 never executed
    #####:18722:        size_old[axis] = IM_TRUNC(w_avail - size_new[axis]);
call    0 never executed
call    1 never executed
        -:18723:    }
        -:18724:
        -:18725:    // Position each node
    #####:18726:    if (dir == ImGuiDir_Right || dir == ImGuiDir_Down)
    %%%%%:18726-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18726-block 28
branch  2 never executed (fallthrough)
branch  3 never executed
        -:18727:    {
    #####:18728:        pos_new[axis] = pos_old[axis] + size_old[axis] + dock_spacing;
    %%%%%:18728-block 29
call    0 never executed
call    1 never executed
call    2 never executed
        -:18729:    }
    #####:18730:    else if (dir == ImGuiDir_Left || dir == ImGuiDir_Up)
    %%%%%:18730-block 33
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18730-block 34
branch  2 never executed (fallthrough)
branch  3 never executed
        -:18731:    {
    #####:18732:        pos_new[axis] = pos_old[axis];
    %%%%%:18732-block 35
call    0 never executed
call    1 never executed
    #####:18733:        pos_old[axis] = pos_new[axis] + size_new[axis] + dock_spacing;
call    0 never executed
call    1 never executed
call    2 never executed
        -:18734:    }
    #####:18735:}
        -:18736:
        -:18737:// Retrieve the drop rectangles for a given direction or for the center + perform hit testing.
function _ZN5ImGuiL36DockNodeCalcDropRectsAndTestMousePosERK6ImRect8ImGuiDirRS0_bP6ImVec2 called 0 returned 0% blocks executed 0%
    #####:18738:bool ImGui::DockNodeCalcDropRectsAndTestMousePos(const ImRect& parent, ImGuiDir dir, ImRect& out_r, bool outer_docking, ImVec2* test_mouse_pos)
        -:18739:{
    #####:18740:    ImGuiContext& g = *GImGui;
        -:18741:
    #####:18742:    const float parent_smaller_axis = ImMin(parent.GetWidth(), parent.GetHeight());
    %%%%%:18742-block 2
call    0 never executed
call    1 never executed
call    2 never executed
    #####:18743:    const float hs_for_central_nodes = ImMin(g.FontSize * 1.5f, ImMax(g.FontSize * 0.5f, parent_smaller_axis / 8.0f));
call    0 never executed
call    1 never executed
        -:18744:    float hs_w; // Half-size, longer axis
        -:18745:    float hs_h; // Half-size, smaller axis
    #####:18746:    ImVec2 off; // Distance from edge or center
    #####:18747:    if (outer_docking)
branch  0 never executed (fallthrough)
branch  1 never executed
        -:18748:    {
        -:18749:        //hs_w = ImTrunc(ImClamp(parent_smaller_axis - hs_for_central_nodes * 4.0f, g.FontSize * 0.5f, g.FontSize * 8.0f));
        -:18750:        //hs_h = ImTrunc(hs_w * 0.15f);
        -:18751:        //off = ImVec2(ImTrunc(parent.GetWidth() * 0.5f - GetFrameHeightWithSpacing() * 1.4f - hs_h), ImTrunc(parent.GetHeight() * 0.5f - GetFrameHeightWithSpacing() * 1.4f - hs_h));
    #####:18752:        hs_w = ImTrunc(hs_for_central_nodes * 1.50f);
    %%%%%:18752-block 8
call    0 never executed
    #####:18753:        hs_h = ImTrunc(hs_for_central_nodes * 0.80f);
call    0 never executed
    #####:18754:        off = ImTrunc(ImVec2(parent.GetWidth() * 0.5f - hs_h, parent.GetHeight() * 0.5f - hs_h));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:18755:    }
        -:18756:    else
        -:18757:    {
    #####:18758:        hs_w = ImTrunc(hs_for_central_nodes);
    %%%%%:18758-block 15
call    0 never executed
    #####:18759:        hs_h = ImTrunc(hs_for_central_nodes * 0.90f);
call    0 never executed
    #####:18760:        off = ImTrunc(ImVec2(hs_w * 2.40f, hs_w * 2.40f));
call    0 never executed
call    1 never executed
        -:18761:    }
        -:18762:
    #####:18763:    ImVec2 c = ImTrunc(parent.GetCenter());
    %%%%%:18763-block 20
call    0 never executed
call    1 never executed
    #####:18764:    if      (dir == ImGuiDir_None)  { out_r = ImRect(c.x - hs_w, c.y - hs_w,         c.x + hs_w, c.y + hs_w);         }
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18764-block 23
call    2 never executed
    #####:18765:    else if (dir == ImGuiDir_Up)    { out_r = ImRect(c.x - hs_w, c.y - off.y - hs_h, c.x + hs_w, c.y - off.y + hs_h); }
    %%%%%:18765-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18765-block 26
call    2 never executed
    #####:18766:    else if (dir == ImGuiDir_Down)  { out_r = ImRect(c.x - hs_w, c.y + off.y - hs_h, c.x + hs_w, c.y + off.y + hs_h); }
    %%%%%:18766-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18766-block 29
call    2 never executed
    #####:18767:    else if (dir == ImGuiDir_Left)  { out_r = ImRect(c.x - off.x - hs_h, c.y - hs_w, c.x - off.x + hs_h, c.y + hs_w); }
    %%%%%:18767-block 31
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18767-block 32
call    2 never executed
    #####:18768:    else if (dir == ImGuiDir_Right) { out_r = ImRect(c.x + off.x - hs_h, c.y - hs_w, c.x + off.x + hs_h, c.y + hs_w); }
    %%%%%:18768-block 34
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18768-block 35
call    2 never executed
        -:18769:
    #####:18770:    if (test_mouse_pos == NULL)
    %%%%%:18770-block 37
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:18771:        return false;
    %%%%%:18771-block 38
        -:18772:
    #####:18773:    ImRect hit_r = out_r;
    #####:18774:    if (!outer_docking)
    %%%%%:18774-block 39
branch  0 never executed (fallthrough)
branch  1 never executed
        -:18775:    {
        -:18776:        // Custom hit testing for the 5-way selection, designed to reduce flickering when moving diagonally between sides
    #####:18777:        hit_r.Expand(ImTrunc(hs_w * 0.30f));
    %%%%%:18777-block 40
call    0 never executed
call    1 never executed
    #####:18778:        ImVec2 mouse_delta = (*test_mouse_pos - c);
call    0 never executed
    #####:18779:        float mouse_delta_len2 = ImLengthSqr(mouse_delta);
call    0 never executed
    #####:18780:        float r_threshold_center = hs_w * 1.4f;
    #####:18781:        float r_threshold_sides = hs_w * (1.4f + 1.2f);
    #####:18782:        if (mouse_delta_len2 < r_threshold_center * r_threshold_center)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:18783:            return (dir == ImGuiDir_None);
    %%%%%:18783-block 45
    %%%%%:18783-block 50
    #####:18784:        if (mouse_delta_len2 < r_threshold_sides * r_threshold_sides)
    %%%%%:18784-block 46
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:18785:            return (dir == ImGetDirQuadrantFromDelta(mouse_delta.x, mouse_delta.y));
    %%%%%:18785-block 47
call    0 never executed
        -:18786:    }
    #####:18787:    return hit_r.Contains(*test_mouse_pos);
    %%%%%:18787-block 51
call    0 never executed
        -:18788:}
        -:18789:
        -:18790:// host_node may be NULL if the window doesn't have a DockNode already.
        -:18791:// FIXME-DOCK: This is misnamed since it's also doing the filtering.
function _ZN5ImGuiL24DockNodePreviewDockSetupEP11ImGuiWindowP13ImGuiDockNodeS1_S3_P20ImGuiDockPreviewDatabb called 0 returned 0% blocks executed 0%
    #####:18792:static void ImGui::DockNodePreviewDockSetup(ImGuiWindow* host_window, ImGuiDockNode* host_node, ImGuiWindow* payload_window, ImGuiDockNode* payload_node, ImGuiDockPreviewData* data, bool is_explicit_target, bool is_outer_docking)
        -:18793:{
    #####:18794:    ImGuiContext& g = *GImGui;
        -:18795:
        -:18796:    // There is an edge case when docking into a dockspace which only has inactive nodes.
        -:18797:    // In this case DockNodeTreeFindNodeByPos() will have selected a leaf node which is inactive.
        -:18798:    // Because the inactive leaf node doesn't have proper pos/size yet, we'll use the root node as reference.
    #####:18799:    if (payload_node == NULL)
    %%%%%:18799-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:18800:        payload_node = payload_window->DockNodeAsHost;
    %%%%%:18800-block 3
    #####:18801:    ImGuiDockNode* ref_node_for_rect = (host_node && !host_node->IsVisible) ? DockNodeGetRootNode(host_node) : host_node;
    %%%%%:18801-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18801-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:18801-block 6
call    4 never executed
    %%%%%:18801-block 7
    #####:18802:    if (ref_node_for_rect)
    %%%%%:18802-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:18803:        IM_ASSERT(ref_node_for_rect->IsVisible == true);
    %%%%%:18803-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18803-block 10
call    2 never executed
        -:18804:
        -:18805:    // Filter, figure out where we are allowed to dock
    #####:18806:    ImGuiDockNodeFlags src_node_flags = payload_node ? payload_node->MergedFlags : payload_window->WindowClass.DockNodeFlagsOverrideSet;
    %%%%%:18806-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18806-block 12
    %%%%%:18806-block 13
    #####:18807:    ImGuiDockNodeFlags dst_node_flags = host_node ? host_node->MergedFlags : host_window->WindowClass.DockNodeFlagsOverrideSet;
    %%%%%:18807-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18807-block 15
    %%%%%:18807-block 16
    #####:18808:    data->IsCenterAvailable = true;
    #####:18809:    if (is_outer_docking)
    %%%%%:18809-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:18810:        data->IsCenterAvailable = false;
    %%%%%:18810-block 18
    #####:18811:    else if (dst_node_flags & ImGuiDockNodeFlags_NoDockingOverMe)
    %%%%%:18811-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:18812:        data->IsCenterAvailable = false;
    %%%%%:18812-block 20
    #####:18813:    else if (host_node && (dst_node_flags & ImGuiDockNodeFlags_NoDockingOverCentralNode) && host_node->IsCentralNode())
    %%%%%:18813-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18813-block 22
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:18813-block 23
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:18813-block 25
    %%%%%:18813-block 26
    %%%%%:18813-block 27
branch  7 never executed (fallthrough)
branch  8 never executed
    #####:18814:        data->IsCenterAvailable = false;
    %%%%%:18814-block 28
    #####:18815:    else if ((!host_node || !host_node->IsEmpty()) && payload_node && payload_node->IsSplitNode() && (payload_node->OnlyNodeWithWindows == NULL)) // Is _visibly_ split?
    %%%%%:18815-block 29
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18815-block 30
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:18815-block 32
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:18815-block 33
call    7 never executed
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%:18815-block 35
branch 10 never executed (fallthrough)
branch 11 never executed
    %%%%%:18815-block 36
    %%%%%:18815-block 37
    %%%%%:18815-block 38
branch 12 never executed (fallthrough)
branch 13 never executed
    #####:18816:        data->IsCenterAvailable = false;
    %%%%%:18816-block 39
    #####:18817:    else if ((src_node_flags & ImGuiDockNodeFlags_NoDockingOverOther) && (!host_node || !host_node->IsEmpty()))
    %%%%%:18817-block 40
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18817-block 41
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:18817-block 42
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:18817-block 44
    %%%%%:18817-block 45
    %%%%%:18817-block 46
branch  7 never executed (fallthrough)
branch  8 never executed
    #####:18818:        data->IsCenterAvailable = false;
    %%%%%:18818-block 47
    #####:18819:    else if ((src_node_flags & ImGuiDockNodeFlags_NoDockingOverEmpty) && host_node && host_node->IsEmpty())
    %%%%%:18819-block 48
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18819-block 49
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:18819-block 50
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:18819-block 52
    %%%%%:18819-block 53
    %%%%%:18819-block 54
branch  7 never executed (fallthrough)
branch  8 never executed
    #####:18820:        data->IsCenterAvailable = false;
    %%%%%:18820-block 55
        -:18821:
    #####:18822:    data->IsSidesAvailable = true;
    #####:18823:    if ((dst_node_flags & ImGuiDockNodeFlags_NoDockingSplit) || g.IO.ConfigDockingNoSplit)
    %%%%%:18823-block 56
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18823-block 57
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:18824:        data->IsSidesAvailable = false;
    %%%%%:18824-block 58
    #####:18825:    else if (!is_outer_docking && host_node && host_node->ParentNode == NULL && host_node->IsCentralNode())
    %%%%%:18825-block 59
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18825-block 60
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:18825-block 61
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:18825-block 62
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%:18825-block 64
    %%%%%:18825-block 65
    %%%%%:18825-block 66
branch  9 never executed (fallthrough)
branch 10 never executed
    #####:18826:        data->IsSidesAvailable = false;
    %%%%%:18826-block 67
    #####:18827:    else if (src_node_flags & ImGuiDockNodeFlags_NoDockingSplitOther)
    %%%%%:18827-block 68
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:18828:        data->IsSidesAvailable = false;
    %%%%%:18828-block 69
        -:18829:
        -:18830:    // Build a tentative future node (reuse same structure because it is practical. Shape will be readjusted when previewing a split)
    #####:18831:    data->FutureNode.HasCloseButton = (host_node ? host_node->HasCloseButton : host_window->HasCloseButton) || (payload_window->HasCloseButton);
    %%%%%:18831-block 70
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18831-block 71
branch  2 never executed
branch  3 never executed
    %%%%%:18831-block 72
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:18831-block 73
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%:18831-block 74
    %%%%%:18831-block 75
    #####:18832:    data->FutureNode.HasWindowMenuButton = host_node ? true : ((host_window->Flags & ImGuiWindowFlags_NoCollapse) == 0);
    %%%%%:18832-block 76
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18832-block 77
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:18832-block 78
    %%%%%:18832-block 79
    #####:18833:    data->FutureNode.Pos = ref_node_for_rect ? ref_node_for_rect->Pos : host_window->Pos;
    %%%%%:18833-block 80
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18833-block 81
    %%%%%:18833-block 82
    #####:18834:    data->FutureNode.Size = ref_node_for_rect ? ref_node_for_rect->Size : host_window->Size;
    %%%%%:18834-block 83
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18834-block 84
    %%%%%:18834-block 85
        -:18835:
        -:18836:    // Calculate drop shapes geometry for allowed splitting directions
        -:18837:    IM_ASSERT(ImGuiDir_None == -1);
    #####:18838:    data->SplitNode = host_node;
    #####:18839:    data->SplitDir = ImGuiDir_None;
    #####:18840:    data->IsSplitDirExplicit = false;
    #####:18841:    if (!host_window->Collapsed)
    %%%%%:18841-block 86
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:18842:        for (int dir = ImGuiDir_None; dir < ImGuiDir_COUNT; dir++)
    %%%%%:18842-block 87
    %%%%%:18842-block 98
    %%%%%:18842-block 99
branch  0 never executed
branch  1 never executed (fallthrough)
        -:18843:        {
    #####:18844:            if (dir == ImGuiDir_None && !data->IsCenterAvailable)
    %%%%%:18844-block 88
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18844-block 89
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:18845:                continue;
    %%%%%:18845-block 90
    #####:18846:            if (dir != ImGuiDir_None && !data->IsSidesAvailable)
    %%%%%:18846-block 91
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18846-block 92
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:18847:                continue;
    %%%%%:18847-block 93
    #####:18848:            if (DockNodeCalcDropRectsAndTestMousePos(data->FutureNode.Rect(), (ImGuiDir)dir, data->DropRectsDraw[dir+1], is_outer_docking, &g.IO.MousePos))
    %%%%%:18848-block 94
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:18848-block 96
branch  4 never executed (fallthrough)
branch  5 never executed
        -:18849:            {
    #####:18850:                data->SplitDir = (ImGuiDir)dir;
    #####:18851:                data->IsSplitDirExplicit = true;
    %%%%%:18851-block 97
        -:18852:            }
        -:18853:        }
        -:18854:
        -:18855:    // When docking without holding Shift, we only allow and preview docking when hovering over a drop rect or over the title bar
    #####:18856:    data->IsDropAllowed = (data->SplitDir != ImGuiDir_None) || (data->IsCenterAvailable);
    %%%%%:18856-block 100
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18856-block 101
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:18856-block 102
    %%%%%:18856-block 103
    #####:18857:    if (!is_explicit_target && !data->IsSplitDirExplicit && !g.IO.ConfigDockingWithShift)
    %%%%%:18857-block 104
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18857-block 105
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:18857-block 106
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:18858:        data->IsDropAllowed = false;
    %%%%%:18858-block 107
        -:18859:
        -:18860:    // Calculate split area
    #####:18861:    data->SplitRatio = 0.0f;
    #####:18862:    if (data->SplitDir != ImGuiDir_None)
    %%%%%:18862-block 108
branch  0 never executed (fallthrough)
branch  1 never executed
        -:18863:    {
    #####:18864:        ImGuiDir split_dir = data->SplitDir;
    #####:18865:        ImGuiAxis split_axis = (split_dir == ImGuiDir_Left || split_dir == ImGuiDir_Right) ? ImGuiAxis_X : ImGuiAxis_Y;
    %%%%%:18865-block 109
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18865-block 110
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:18865-block 111
    %%%%%:18865-block 112
    #####:18866:        ImVec2 pos_new, pos_old = data->FutureNode.Pos;
    #####:18867:        ImVec2 size_new, size_old = data->FutureNode.Size;
    #####:18868:        DockNodeCalcSplitRects(pos_old, size_old, pos_new, size_new, split_dir, payload_window->Size);
    %%%%%:18868-block 113
call    0 never executed
        -:18869:
        -:18870:        // Calculate split ratio so we can pass it down the docking request
    #####:18871:        float split_ratio = ImSaturate(size_new[split_axis] / data->FutureNode.Size[split_axis]);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:18872:        data->FutureNode.Pos = pos_new;
    #####:18873:        data->FutureNode.Size = size_new;
    #####:18874:        data->SplitRatio = (split_dir == ImGuiDir_Right || split_dir == ImGuiDir_Down) ? (1.0f - split_ratio) : (split_ratio);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18874-block 118
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:18874-block 119
    %%%%%:18874-block 120
    %%%%%:18874-block 121
        -:18875:    }
    #####:18876:}
    %%%%%:18876-block 122
        -:18877:
function _ZN5ImGuiL25DockNodePreviewDockRenderEP11ImGuiWindowP13ImGuiDockNodeS1_PK20ImGuiDockPreviewData called 0 returned 0% blocks executed 0%
    #####:18878:static void ImGui::DockNodePreviewDockRender(ImGuiWindow* host_window, ImGuiDockNode* host_node, ImGuiWindow* root_payload, const ImGuiDockPreviewData* data)
        -:18879:{
    #####:18880:    ImGuiContext& g = *GImGui;
    #####:18881:    IM_ASSERT(g.CurrentWindow == host_window);   // Because we rely on font size to calculate tab sizes
    %%%%%:18881-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18881-block 3
call    2 never executed
        -:18882:
        -:18883:    // With this option, we only display the preview on the target viewport, and the payload viewport is made transparent.
        -:18884:    // To compensate for the single layer obstructed by the payload, we'll increase the alpha of the preview nodes.
    #####:18885:    const bool is_transparent_payload = g.IO.ConfigDockingTransparentPayload;
        -:18886:
        -:18887:    // In case the two windows involved are on different viewports, we will draw the overlay on each of them.
    #####:18888:    int overlay_draw_lists_count = 0;
        -:18889:    ImDrawList* overlay_draw_lists[2];
    #####:18890:    overlay_draw_lists[overlay_draw_lists_count++] = GetForegroundDrawList(host_window->Viewport);
    %%%%%:18890-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:18891:    if (host_window->Viewport != root_payload->Viewport && !is_transparent_payload)
    %%%%%:18891-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18891-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:18892:        overlay_draw_lists[overlay_draw_lists_count++] = GetForegroundDrawList(root_payload->Viewport);
    %%%%%:18892-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:18892-block 8
        -:18893:
        -:18894:    // Draw main preview rectangle
    #####:18895:    const ImU32 overlay_col_main = GetColorU32(ImGuiCol_DockingPreview, is_transparent_payload ? 0.60f : 0.40f);
    %%%%%:18895-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18895-block 10
    %%%%%:18895-block 11
    %%%%%:18895-block 12
call    2 never executed
    #####:18896:    const ImU32 overlay_col_drop = GetColorU32(ImGuiCol_DockingPreview, is_transparent_payload ? 0.90f : 0.70f);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18896-block 14
    %%%%%:18896-block 15
    %%%%%:18896-block 16
call    2 never executed
    #####:18897:    const ImU32 overlay_col_drop_hovered = GetColorU32(ImGuiCol_DockingPreview, is_transparent_payload ? 1.20f : 1.00f);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18897-block 18
    %%%%%:18897-block 19
    %%%%%:18897-block 20
call    2 never executed
    #####:18898:    const ImU32 overlay_col_lines = GetColorU32(ImGuiCol_NavWindowingHighlight, is_transparent_payload ? 0.80f : 0.60f);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18898-block 22
    %%%%%:18898-block 23
    %%%%%:18898-block 24
call    2 never executed
        -:18899:
        -:18900:    // Display area preview
    #####:18901:    const bool can_preview_tabs = (root_payload->DockNodeAsHost == NULL || root_payload->DockNodeAsHost->Windows.Size > 0);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18901-block 26
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:18901-block 27
    %%%%%:18901-block 28
    #####:18902:    if (data->IsDropAllowed)
    %%%%%:18902-block 29
branch  0 never executed (fallthrough)
branch  1 never executed
        -:18903:    {
    #####:18904:        ImRect overlay_rect = data->FutureNode.Rect();
    %%%%%:18904-block 30
call    0 never executed
    #####:18905:        if (data->SplitDir == ImGuiDir_None && can_preview_tabs)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18905-block 32
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:18906:            overlay_rect.Min.y += GetFrameHeight();
    %%%%%:18906-block 33
call    0 never executed
    #####:18907:        if (data->SplitDir != ImGuiDir_None || data->IsCenterAvailable)
    %%%%%:18907-block 35
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18907-block 36
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:18908:            for (int overlay_n = 0; overlay_n < overlay_draw_lists_count; overlay_n++)
    %%%%%:18908-block 37
    %%%%%:18908-block 42
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:18909:                overlay_draw_lists[overlay_n]->AddRectFilled(overlay_rect.Min, overlay_rect.Max, overlay_col_main, host_window->WindowRounding, CalcRoundingFlagsForRectInRect(overlay_rect, host_window->Rect(), g.Style.DockingSeparatorSize));
    %%%%%:18909-block 38
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:18909-block 40
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    %%%%%:18909-block 41
    $$$$$:18909-block 145
        -:18910:    }
        -:18911:
        -:18912:    // Display tab shape/label preview unless we are splitting node (it generally makes the situation harder to read)
    #####:18913:    if (data->IsDropAllowed && can_preview_tabs && data->SplitDir == ImGuiDir_None && data->IsCenterAvailable)
    %%%%%:18913-block 44
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18913-block 45
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:18913-block 46
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:18913-block 47
branch  6 never executed (fallthrough)
branch  7 never executed
        -:18914:    {
        -:18915:        // Compute target tab bar geometry so we can locate our preview tabs
    #####:18916:        ImRect tab_bar_rect;
    #####:18917:        DockNodeCalcTabBarLayout(&data->FutureNode, NULL, &tab_bar_rect, NULL, NULL);
    %%%%%:18917-block 48
call    0 never executed
    #####:18918:        ImVec2 tab_pos = tab_bar_rect.Min;
    #####:18919:        if (host_node && host_node->TabBar)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18919-block 50
branch  2 never executed (fallthrough)
branch  3 never executed
        -:18920:        {
    #####:18921:            if (!host_node->IsHiddenTabBar() && !host_node->IsNoTabBar())
    %%%%%:18921-block 51
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:18921-block 53
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:18921-block 55
    %%%%%:18921-block 56
    %%%%%:18921-block 57
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%:18921-block 62
    #####:18922:                tab_pos.x += host_node->TabBar->WidthAllTabs + g.Style.ItemInnerSpacing.x; // We don't use OffsetNewTab because when using non-persistent-order tab bar it is incremented with each Tab submission.
    %%%%%:18922-block 58
        -:18923:            else
    #####:18924:                tab_pos.x += g.Style.ItemInnerSpacing.x + TabItemCalcSize(host_node->Windows[0]).x;
    %%%%%:18924-block 59
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:18924-block 61
        -:18925:        }
    #####:18926:        else if (!(host_window->Flags & ImGuiWindowFlags_DockNodeHost))
    %%%%%:18926-block 63
branch  0 never executed (fallthrough)
branch  1 never executed
        -:18927:        {
    #####:18928:            tab_pos.x += g.Style.ItemInnerSpacing.x + TabItemCalcSize(host_window).x; // Account for slight offset which will be added when changing from title bar to tab bar
    %%%%%:18928-block 64
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:18928-block 65
        -:18929:        }
        -:18930:
        -:18931:        // Draw tab shape/label preview (payload may be a loose window or a host window carrying multiple tabbed windows)
    #####:18932:        if (root_payload->DockNodeAsHost)
    %%%%%:18932-block 66
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:18933:            IM_ASSERT(root_payload->DockNodeAsHost->Windows.Size <= root_payload->DockNodeAsHost->TabBar->Tabs.Size);
    %%%%%:18933-block 67
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18933-block 68
call    2 never executed
    #####:18934:        ImGuiTabBar* tab_bar_with_payload = root_payload->DockNodeAsHost ? root_payload->DockNodeAsHost->TabBar : NULL;
    %%%%%:18934-block 69
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18934-block 70
    %%%%%:18934-block 71
    #####:18935:        const int payload_count = tab_bar_with_payload ? tab_bar_with_payload->Tabs.Size : 1;
    %%%%%:18935-block 72
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18935-block 73
    %%%%%:18935-block 74
    #####:18936:        for (int payload_n = 0; payload_n < payload_count; payload_n++)
    %%%%%:18936-block 75
    %%%%%:18936-block 105
    %%%%%:18936-block 106
branch  0 never executed
branch  1 never executed (fallthrough)
        -:18937:        {
        -:18938:            // DockNode's TabBar may have non-window Tabs manually appended by user
    #####:18939:            ImGuiWindow* payload_window = tab_bar_with_payload ? tab_bar_with_payload->Tabs[payload_n].Window : root_payload;
    %%%%%:18939-block 76
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18939-block 77
call    2 never executed
    %%%%%:18939-block 79
    #####:18940:            if (tab_bar_with_payload && payload_window == NULL)
    %%%%%:18940-block 80
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18940-block 81
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:18941:                continue;
    %%%%%:18941-block 82
    %%%%%:18941-block 104
    #####:18942:            if (!DockNodeIsDropAllowedOne(payload_window, host_window))
    %%%%%:18942-block 83
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:18942-block 84
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:18943:                continue;
    %%%%%:18943-block 85
        -:18944:
        -:18945:            // Calculate the tab bounding box for each payload window
    #####:18946:            ImVec2 tab_size = TabItemCalcSize(payload_window);
    %%%%%:18946-block 86
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:18947:            ImRect tab_bb(tab_pos.x, tab_pos.y, tab_pos.x + tab_size.x, tab_pos.y + tab_size.y);
    %%%%%:18947-block 87
call    0 never executed
    #####:18948:            tab_pos.x += tab_size.x + g.Style.ItemInnerSpacing.x;
    #####:18949:            const ImU32 overlay_col_text = GetColorU32(payload_window->DockStyle.Colors[ImGuiWindowDockStyleCol_Text]);
call    0 never executed
    #####:18950:            const ImU32 overlay_col_tabs = GetColorU32(payload_window->DockStyle.Colors[ImGuiWindowDockStyleCol_TabSelected]);
call    0 never executed
    #####:18951:            PushStyleColor(ImGuiCol_Text, overlay_col_text);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:18952:            for (int overlay_n = 0; overlay_n < overlay_draw_lists_count; overlay_n++)
    %%%%%:18952-block 91
    %%%%%:18952-block 100
    %%%%%:18952-block 101
branch  0 never executed
branch  1 never executed (fallthrough)
        -:18953:            {
    #####:18954:                ImGuiTabItemFlags tab_flags = (payload_window->Flags & ImGuiWindowFlags_UnsavedDocument) ? ImGuiTabItemFlags_UnsavedDocument : 0;
    #####:18955:                if (!tab_bar_rect.Contains(tab_bb))
    %%%%%:18955-block 92
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:18956:                    overlay_draw_lists[overlay_n]->PushClipRect(tab_bar_rect.Min, tab_bar_rect.Max);
    %%%%%:18956-block 94
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:18957:                TabItemBackground(overlay_draw_lists[overlay_n], tab_bb, tab_flags, overlay_col_tabs);
    %%%%%:18957-block 95
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:18958:                TabItemLabelAndCloseButton(overlay_draw_lists[overlay_n], tab_bb, tab_flags, g.Style.FramePadding, payload_window->Name, 0, 0, false, NULL, NULL);
    %%%%%:18958-block 96
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:18959:                if (!tab_bar_rect.Contains(tab_bb))
    %%%%%:18959-block 97
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:18960:                    overlay_draw_lists[overlay_n]->PopClipRect();
    %%%%%:18960-block 99
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:18961:            }
    #####:18962:            PopStyleColor();
    %%%%%:18962-block 102
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:18963:        }
        -:18964:    }
        -:18965:
        -:18966:    // Display drop boxes
    #####:18967:    const float overlay_rounding = ImMax(3.0f, g.Style.FrameRounding);
    %%%%%:18967-block 108
call    0 never executed
    #####:18968:    for (int dir = ImGuiDir_None; dir < ImGuiDir_COUNT; dir++)
    %%%%%:18968-block 141
    %%%%%:18968-block 142
branch  0 never executed
branch  1 never executed (fallthrough)
        -:18969:    {
    #####:18970:        if (!data->DropRectsDraw[dir + 1].IsInverted())
    %%%%%:18970-block 110
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -:18971:        {
    #####:18972:            ImRect draw_r = data->DropRectsDraw[dir + 1];
    #####:18973:            ImRect draw_r_in = draw_r;
    #####:18974:            draw_r_in.Expand(-2.0f);
    %%%%%:18974-block 112
call    0 never executed
    #####:18975:            ImU32 overlay_col = (data->SplitDir == (ImGuiDir)dir && data->IsSplitDirExplicit) ? overlay_col_drop_hovered : overlay_col_drop;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18975-block 114
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:18975-block 115
    %%%%%:18975-block 116
    #####:18976:            for (int overlay_n = 0; overlay_n < overlay_draw_lists_count; overlay_n++)
    %%%%%:18976-block 117
    %%%%%:18976-block 134
    %%%%%:18976-block 135
branch  0 never executed
branch  1 never executed (fallthrough)
        -:18977:            {
    #####:18978:                ImVec2 center = ImFloor(draw_r_in.GetCenter());
    %%%%%:18978-block 118
call    0 never executed
call    1 never executed
    #####:18979:                overlay_draw_lists[overlay_n]->AddRectFilled(draw_r.Min, draw_r.Max, overlay_col, overlay_rounding);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:18980:                overlay_draw_lists[overlay_n]->AddRect(draw_r_in.Min, draw_r_in.Max, overlay_col_lines, overlay_rounding);
    %%%%%:18980-block 121
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:18981:                if (dir == ImGuiDir_Left || dir == ImGuiDir_Right)
    %%%%%:18981-block 122
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18981-block 123
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:18982:                    overlay_draw_lists[overlay_n]->AddLine(ImVec2(center.x, draw_r_in.Min.y), ImVec2(center.x, draw_r_in.Max.y), overlay_col_lines);
    %%%%%:18982-block 124
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%:18982-block 127
    $$$$$:18982-block 149
    $$$$$:18982-block 150
    #####:18983:                if (dir == ImGuiDir_Up || dir == ImGuiDir_Down)
    %%%%%:18983-block 128
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18983-block 129
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:18984:                    overlay_draw_lists[overlay_n]->AddLine(ImVec2(draw_r_in.Min.x, center.y), ImVec2(draw_r_in.Max.x, center.y), overlay_col_lines);
    %%%%%:18984-block 130
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%:18984-block 133
    $$$$$:18984-block 151
    $$$$$:18984-block 152
        -:18985:            }
        -:18986:        }
        -:18987:
        -:18988:        // Stop after ImGuiDir_None
    #####:18989:        if ((host_node && (host_node->MergedFlags & ImGuiDockNodeFlags_NoDockingSplit)) || g.IO.ConfigDockingNoSplit)
    %%%%%:18989-block 137
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:18989-block 138
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:18989-block 139
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:18990:            return;
    %%%%%:18990-block 140
        -:18991:    }
        -:18992:}
        -:18993:
        -:18994://-----------------------------------------------------------------------------
        -:18995:// Docking: ImGuiDockNode Tree manipulation functions
        -:18996://-----------------------------------------------------------------------------
        -:18997:// - DockNodeTreeSplit()
        -:18998:// - DockNodeTreeMerge()
        -:18999:// - DockNodeTreeUpdatePosSize()
        -:19000:// - DockNodeTreeUpdateSplitterFindTouchingNode()
        -:19001:// - DockNodeTreeUpdateSplitter()
        -:19002:// - DockNodeTreeFindFallbackLeafNode()
        -:19003:// - DockNodeTreeFindNodeByPos()
        -:19004://-----------------------------------------------------------------------------
        -:19005:
function _ZN5ImGuiL17DockNodeTreeSplitEP12ImGuiContextP13ImGuiDockNode9ImGuiAxisifS3_ called 0 returned 0% blocks executed 0%
    #####:19006:void ImGui::DockNodeTreeSplit(ImGuiContext* ctx, ImGuiDockNode* parent_node, ImGuiAxis split_axis, int split_inheritor_child_idx, float split_ratio, ImGuiDockNode* new_node)
        -:19007:{
    #####:19008:    ImGuiContext& g = *GImGui;
    #####:19009:    IM_ASSERT(split_axis != ImGuiAxis_None);
    %%%%%:19009-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19009-block 3
call    2 never executed
        -:19010:
    #####:19011:    ImGuiDockNode* child_0 = (new_node && split_inheritor_child_idx != 0) ? new_node : DockContextAddNode(ctx, 0);
    %%%%%:19011-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19011-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:19011-block 6
call    4 never executed
    %%%%%:19011-block 8
    #####:19012:    child_0->ParentNode = parent_node;
        -:19013:
    #####:19014:    ImGuiDockNode* child_1 = (new_node && split_inheritor_child_idx != 1) ? new_node : DockContextAddNode(ctx, 0);
    %%%%%:19014-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19014-block 10
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:19014-block 11
call    4 never executed
    %%%%%:19014-block 13
    #####:19015:    child_1->ParentNode = parent_node;
        -:19016:
    #####:19017:    ImGuiDockNode* child_inheritor = (split_inheritor_child_idx == 0) ? child_0 : child_1;
    %%%%%:19017-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19017-block 15
    %%%%%:19017-block 16
    #####:19018:    DockNodeMoveChildNodes(child_inheritor, parent_node);
    %%%%%:19018-block 17
call    0 never executed
    #####:19019:    parent_node->ChildNodes[0] = child_0;
    #####:19020:    parent_node->ChildNodes[1] = child_1;
    #####:19021:    parent_node->ChildNodes[split_inheritor_child_idx]->VisibleWindow = parent_node->VisibleWindow;
    #####:19022:    parent_node->SplitAxis = split_axis;
    #####:19023:    parent_node->VisibleWindow = NULL;
    #####:19024:    parent_node->AuthorityForPos = parent_node->AuthorityForSize = ImGuiDataAuthority_DockNode;
        -:19025:
    #####:19026:    float size_avail = (parent_node->Size[split_axis] - g.Style.DockingSeparatorSize);
call    0 never executed
    #####:19027:    size_avail = ImMax(size_avail, g.Style.WindowMinSize[split_axis] * 2.0f);
call    0 never executed
call    1 never executed
    #####:19028:    IM_ASSERT(size_avail > 0.0f); // If you created a node manually with DockBuilderAddNode(), you need to also call DockBuilderSetNodeSize() before splitting.
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19028-block 22
call    2 never executed
    #####:19029:    child_0->SizeRef = child_1->SizeRef = parent_node->Size;
    #####:19030:    child_0->SizeRef[split_axis] = ImTrunc(size_avail * split_ratio);
    %%%%%:19030-block 23
call    0 never executed
call    1 never executed
    #####:19031:    child_1->SizeRef[split_axis] = ImTrunc(size_avail - child_0->SizeRef[split_axis]);
call    0 never executed
call    1 never executed
call    2 never executed
        -:19032:
    #####:19033:    DockNodeMoveWindows(parent_node->ChildNodes[split_inheritor_child_idx], parent_node);
call    0 never executed
    #####:19034:    DockSettingsRenameNodeReferences(parent_node->ID, parent_node->ChildNodes[split_inheritor_child_idx]->ID);
call    0 never executed
    #####:19035:    DockNodeUpdateHasCentralNodeChild(DockNodeGetRootNode(parent_node));
call    0 never executed
call    1 never executed
    #####:19036:    DockNodeTreeUpdatePosSize(parent_node, parent_node->Pos, parent_node->Size);
call    0 never executed
        -:19037:
        -:19038:    // Flags transfer (e.g. this is where we transfer the ImGuiDockNodeFlags_CentralNode property)
    #####:19039:    child_0->SharedFlags = parent_node->SharedFlags & ImGuiDockNodeFlags_SharedFlagsInheritMask_;
    #####:19040:    child_1->SharedFlags = parent_node->SharedFlags & ImGuiDockNodeFlags_SharedFlagsInheritMask_;
    #####:19041:    child_inheritor->LocalFlags = parent_node->LocalFlags & ImGuiDockNodeFlags_LocalFlagsTransferMask_;
    #####:19042:    parent_node->LocalFlags &= ~ImGuiDockNodeFlags_LocalFlagsTransferMask_;
    #####:19043:    child_0->UpdateMergedFlags();
call    0 never executed
    #####:19044:    child_1->UpdateMergedFlags();
call    0 never executed
    #####:19045:    parent_node->UpdateMergedFlags();
call    0 never executed
    #####:19046:    if (child_inheritor->IsCentralNode())
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:19047:        DockNodeGetRootNode(parent_node)->CentralNode = child_inheritor;
    %%%%%:19047-block 38
call    0 never executed
    #####:19048:}
        -:19049:
function _ZN5ImGuiL17DockNodeTreeMergeEP12ImGuiContextP13ImGuiDockNodeS3_ called 0 returned 0% blocks executed 0%
    #####:19050:void ImGui::DockNodeTreeMerge(ImGuiContext* ctx, ImGuiDockNode* parent_node, ImGuiDockNode* merge_lead_child)
        -:19051:{
        -:19052:    // When called from DockContextProcessUndockNode() it is possible that one of the child is NULL.
    #####:19053:    ImGuiContext& g = *GImGui;
    #####:19054:    ImGuiDockNode* child_0 = parent_node->ChildNodes[0];
    #####:19055:    ImGuiDockNode* child_1 = parent_node->ChildNodes[1];
    #####:19056:    IM_ASSERT(child_0 || child_1);
    %%%%%:19056-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19056-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:19056-block 4
call    4 never executed
    #####:19057:    IM_ASSERT(merge_lead_child == child_0 || merge_lead_child == child_1);
    %%%%%:19057-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19057-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:19057-block 7
call    4 never executed
    #####:19058:    if ((child_0 && child_0->Windows.Size > 0) || (child_1 && child_1->Windows.Size > 0))
    %%%%%:19058-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19058-block 9
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:19058-block 10
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:19058-block 11
branch  6 never executed (fallthrough)
branch  7 never executed
        -:19059:    {
    #####:19060:        IM_ASSERT(parent_node->TabBar == NULL);
    %%%%%:19060-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19060-block 13
call    2 never executed
    #####:19061:        IM_ASSERT(parent_node->Windows.Size == 0);
    %%%%%:19061-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19061-block 15
call    2 never executed
        -:19062:    }
    #####:19063:    IMGUI_DEBUG_LOG_DOCKING("[docking] DockNodeTreeMerge: 0x%08X + 0x%08X back into parent 0x%08X\n", child_0 ? child_0->ID : 0, child_1 ? child_1->ID : 0, parent_node->ID);
    %%%%%:19063-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19063-block 17
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:19063-block 18
    %%%%%:19063-block 19
    %%%%%:19063-block 20
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:19063-block 21
    %%%%%:19063-block 22
    %%%%%:19063-block 23
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed (throw)
        -:19064:
    #####:19065:    ImVec2 backup_last_explicit_size = parent_node->SizeRef;
    #####:19066:    DockNodeMoveChildNodes(parent_node, merge_lead_child);
    %%%%%:19066-block 24
call    0 never executed
    #####:19067:    if (child_0)
branch  0 never executed (fallthrough)
branch  1 never executed
        -:19068:    {
    #####:19069:        DockNodeMoveWindows(parent_node, child_0); // Generally only 1 of the 2 child node will have windows
    %%%%%:19069-block 26
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:19070:        DockSettingsRenameNodeReferences(child_0->ID, parent_node->ID);
    %%%%%:19070-block 27
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:19071:    }
    #####:19072:    if (child_1)
    %%%%%:19072-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
        -:19073:    {
    #####:19074:        DockNodeMoveWindows(parent_node, child_1);
    %%%%%:19074-block 29
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:19075:        DockSettingsRenameNodeReferences(child_1->ID, parent_node->ID);
    %%%%%:19075-block 30
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:19076:    }
    #####:19077:    DockNodeApplyPosSizeToWindows(parent_node);
    %%%%%:19077-block 31
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:19078:    parent_node->AuthorityForPos = parent_node->AuthorityForSize = parent_node->AuthorityForViewport = ImGuiDataAuthority_Auto;
    #####:19079:    parent_node->VisibleWindow = merge_lead_child->VisibleWindow;
    #####:19080:    parent_node->SizeRef = backup_last_explicit_size;
        -:19081:
        -:19082:    // Flags transfer
    #####:19083:    parent_node->LocalFlags &= ~ImGuiDockNodeFlags_LocalFlagsTransferMask_; // Preserve Dockspace flag
    #####:19084:    parent_node->LocalFlags |= (child_0 ? child_0->LocalFlags : 0) & ImGuiDockNodeFlags_LocalFlagsTransferMask_;
    %%%%%:19084-block 32
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19084-block 33
    %%%%%:19084-block 34
    #####:19085:    parent_node->LocalFlags |= (child_1 ? child_1->LocalFlags : 0) & ImGuiDockNodeFlags_LocalFlagsTransferMask_;
    %%%%%:19085-block 35
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19085-block 36
    %%%%%:19085-block 37
    #####:19086:    parent_node->LocalFlagsInWindows = (child_0 ? child_0->LocalFlagsInWindows : 0) | (child_1 ? child_1->LocalFlagsInWindows : 0); // FIXME: Would be more consistent to update from actual windows
    %%%%%:19086-block 38
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19086-block 39
    %%%%%:19086-block 40
    %%%%%:19086-block 41
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:19086-block 42
    %%%%%:19086-block 43
    #####:19087:    parent_node->UpdateMergedFlags();
    %%%%%:19087-block 44
call    0 never executed
        -:19088:
    #####:19089:    if (child_0)
branch  0 never executed (fallthrough)
branch  1 never executed
        -:19090:    {
    #####:19091:        ctx->DockContext.Nodes.SetVoidPtr(child_0->ID, NULL);
    %%%%%:19091-block 46
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:19092:        IM_DELETE(child_0);
    %%%%%:19092-block 47
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:19093:    }
    #####:19094:    if (child_1)
    %%%%%:19094-block 48
branch  0 never executed (fallthrough)
branch  1 never executed
        -:19095:    {
    #####:19096:        ctx->DockContext.Nodes.SetVoidPtr(child_1->ID, NULL);
    %%%%%:19096-block 49
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:19097:        IM_DELETE(child_1);
    %%%%%:19097-block 50
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:19098:    }
    #####:19099:}
    %%%%%:19099-block 51
        -:19100:
        -:19101:// Update Pos/Size for a node hierarchy (don't affect child Windows yet)
        -:19102:// (Depth-first, Pre-Order)
function _ZN5ImGuiL25DockNodeTreeUpdatePosSizeEP13ImGuiDockNode6ImVec2S2_S1_ called 9696 returned 100% blocks executed 65%
     9696:19103:void ImGui::DockNodeTreeUpdatePosSize(ImGuiDockNode* node, ImVec2 pos, ImVec2 size, ImGuiDockNode* only_write_to_single_node)
        -:19104:{
        -:19105:    // During the regular dock node update we write to all nodes.
        -:19106:    // 'only_write_to_single_node' is only set when turning a node visible mid-frame and we need its size right-away.
     9696:19107:    ImGuiContext& g = *GImGui;
     9696:19108:    const bool write_to_node = only_write_to_single_node == NULL || only_write_to_single_node == node;
     9696:19108-block 2
branch  0 taken 4 (fallthrough)
branch  1 taken 9692
        4:19108-block 3
branch  2 taken 0 (fallthrough)
branch  3 taken 4
     9692:19108-block 4
        4:19108-block 5
     9696:19109:    if (write_to_node)
     9696:19109-block 6
branch  0 taken 9692 (fallthrough)
branch  1 taken 4
        -:19110:    {
     9692:19111:        node->Pos = pos;
     9692:19112:        node->Size = size;
     9692:19112-block 7
        -:19113:    }
        -:19114:
     9696:19115:    if (node->IsLeafNode())
     9696:19115-block 8
call    0 returned 9696
branch  1 taken 5383 (fallthrough)
branch  2 taken 4313
     5383:19116:        return;
     5383:19116-block 10
        -:19117:
     4313:19118:    ImGuiDockNode* child_0 = node->ChildNodes[0];
     4313:19119:    ImGuiDockNode* child_1 = node->ChildNodes[1];
     4313:19120:    ImVec2 child_0_pos = pos, child_1_pos = pos;
     4313:19121:    ImVec2 child_0_size = size, child_1_size = size;
        -:19122:
     4313:19123:    const bool child_0_is_toward_single_node = (only_write_to_single_node != NULL && DockNodeIsInHierarchyOf(only_write_to_single_node, child_0));
     4313:19123-block 11
branch  0 taken 4 (fallthrough)
branch  1 taken 4309
        4:19123-block 12
call    2 returned 4
branch  3 taken 3 (fallthrough)
branch  4 taken 1
        3:19123-block 14
     4310:19123-block 15
     4313:19124:    const bool child_1_is_toward_single_node = (only_write_to_single_node != NULL && DockNodeIsInHierarchyOf(only_write_to_single_node, child_1));
     4313:19124-block 16
branch  0 taken 4 (fallthrough)
branch  1 taken 4309
        4:19124-block 17
call    2 returned 4
branch  3 taken 1 (fallthrough)
branch  4 taken 3
        1:19124-block 19
     4312:19124-block 20
     4313:19125:    const bool child_0_is_or_will_be_visible = child_0->IsVisible || child_0_is_toward_single_node;
     4313:19125-block 21
branch  0 taken 7 (fallthrough)
branch  1 taken 4306
        7:19125-block 22
branch  2 taken 3 (fallthrough)
branch  3 taken 4
     4309:19125-block 23
        4:19125-block 24
     4313:19126:    const bool child_1_is_or_will_be_visible = child_1->IsVisible || child_1_is_toward_single_node;
     4313:19126-block 25
branch  0 taken 4 (fallthrough)
branch  1 taken 4309
        4:19126-block 26
branch  2 taken 1 (fallthrough)
branch  3 taken 3
     4310:19126-block 27
        3:19126-block 28
        -:19127:
     4313:19128:    if (child_0_is_or_will_be_visible && child_1_is_or_will_be_visible)
     4313:19128-block 29
branch  0 taken 4309 (fallthrough)
branch  1 taken 4
     4309:19128-block 30
branch  2 taken 4308 (fallthrough)
branch  3 taken 1
        -:19129:    {
     4308:19130:        const float spacing = g.Style.DockingSeparatorSize;
     4308:19131:        const ImGuiAxis axis = (ImGuiAxis)node->SplitAxis;
     4308:19132:        const float size_avail = ImMax(size[axis] - spacing, 0.0f);
     4308:19132-block 31
call    0 returned 4308
call    1 returned 4308
        -:19133:
        -:19134:        // Size allocation policy
        -:19135:        // 1) The first 0..WindowMinSize[axis]*2 are allocated evenly to both windows.
     4308:19136:        const float size_min_each = ImTrunc(ImMin(size_avail, g.Style.WindowMinSize[axis] * 2.0f) * 0.5f);
call    0 returned 4308
call    1 returned 4308
call    2 returned 4308
        -:19137:
        -:19138:        // FIXME: Blocks 2) and 3) are essentially doing nearly the same thing.
        -:19139:        // Difference are: write-back to SizeRef; application of a minimum size; rounding before ImTrunc()
        -:19140:        // Clarify and rework differences between Size & SizeRef and purpose of WantLockSizeOnce
        -:19141:
        -:19142:        // 2) Process locked absolute size (during a splitter resize we preserve the child of nodes not touching the splitter edge)
    4308*:19143:        if (child_0->WantLockSizeOnce && !child_1->WantLockSizeOnce)
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
    %%%%%:19143-block 37
branch  2 never executed (fallthrough)
branch  3 never executed
        -:19144:        {
    #####:19145:            child_0_size[axis] = child_0->SizeRef[axis] = ImMin(size_avail - 1.0f, child_0->Size[axis]);
    %%%%%:19145-block 38
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:19146:            child_1_size[axis] = child_1->SizeRef[axis] = (size_avail - child_0_size[axis]);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:19147:            IM_ASSERT(child_0->SizeRef[axis] > 0.0f && child_1->SizeRef[axis] > 0.0f);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:19147-block 47
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:19147-block 49
    %%%%%:19147-block 50
call    6 never executed
    %%%%%:19147-block 51
        -:19148:        }
    4308*:19149:        else if (child_1->WantLockSizeOnce && !child_0->WantLockSizeOnce)
     4308:19149-block 52
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
    %%%%%:19149-block 53
branch  2 never executed (fallthrough)
branch  3 never executed
        -:19150:        {
    #####:19151:            child_1_size[axis] = child_1->SizeRef[axis] = ImMin(size_avail - 1.0f, child_1->Size[axis]);
    %%%%%:19151-block 54
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:19152:            child_0_size[axis] = child_0->SizeRef[axis] = (size_avail - child_1_size[axis]);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:19153:            IM_ASSERT(child_0->SizeRef[axis] > 0.0f && child_1->SizeRef[axis] > 0.0f);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:19153-block 63
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:19153-block 65
    %%%%%:19153-block 66
call    6 never executed
    %%%%%:19153-block 67
        -:19154:        }
    4308*:19155:        else if (child_0->WantLockSizeOnce && child_1->WantLockSizeOnce)
     4308:19155-block 68
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
    %%%%%:19155-block 69
branch  2 never executed (fallthrough)
branch  3 never executed
        -:19156:        {
        -:19157:            // FIXME-DOCK: We cannot honor the requested size, so apply ratio.
        -:19158:            // Currently this path will only be taken if code programmatically sets WantLockSizeOnce
    #####:19159:            float split_ratio = child_0_size[axis] / (child_0_size[axis] + child_1_size[axis]);
    %%%%%:19159-block 70
call    0 never executed
call    1 never executed
call    2 never executed
    #####:19160:            child_0_size[axis] = child_0->SizeRef[axis] = ImTrunc(size_avail * split_ratio);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:19161:            child_1_size[axis] = child_1->SizeRef[axis] = (size_avail - child_0_size[axis]);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:19162:            IM_ASSERT(child_0->SizeRef[axis] > 0.0f && child_1->SizeRef[axis] > 0.0f);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:19162-block 81
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:19162-block 83
    %%%%%:19162-block 84
call    6 never executed
    #####:19163:        }
    %%%%%:19163-block 85
        -:19164:
        -:19165:        // 3) If one window is the central node (~ use remaining space, should be made explicit!), use explicit size from the other, and remainder for the central node
     4308:19166:        else if (child_0->SizeRef[axis] != 0.0f && child_1->HasCentralNodeChild)
     4308:19166-block 86
call    0 returned 4308
branch  1 taken 4308 (fallthrough)
branch  2 taken 0
     4308:19166-block 88
branch  3 taken 2155 (fallthrough)
branch  4 taken 2153
     2155:19166-block 89
     2153:19166-block 90
     4308:19166-block 91
branch  5 taken 2155 (fallthrough)
branch  6 taken 2153
        -:19167:        {
     2155:19168:            child_0_size[axis] = ImMin(size_avail - size_min_each, child_0->SizeRef[axis]);
     2155:19168-block 92
call    0 returned 2155
call    1 returned 2155
call    2 returned 2155
     2155:19169:            child_1_size[axis] = (size_avail - child_0_size[axis]);
call    0 returned 2155
call    1 returned 2155
        -:19170:        }
     2153:19171:        else if (child_1->SizeRef[axis] != 0.0f && child_0->HasCentralNodeChild)
     2153:19171-block 98
call    0 returned 2153
branch  1 taken 2153 (fallthrough)
branch  2 taken 0
     2153:19171-block 100
branch  3 taken 1077 (fallthrough)
branch  4 taken 1076
     1077:19171-block 101
     1076:19171-block 102
     2153:19171-block 103
branch  5 taken 1077 (fallthrough)
branch  6 taken 1076
        -:19172:        {
     1077:19173:            child_1_size[axis] = ImMin(size_avail - size_min_each, child_1->SizeRef[axis]);
     1077:19173-block 104
call    0 returned 1077
call    1 returned 1077
call    2 returned 1077
     1077:19174:            child_0_size[axis] = (size_avail - child_1_size[axis]);
call    0 returned 1077
call    1 returned 1077
        -:19175:        }
        -:19176:        else
        -:19177:        {
        -:19178:            // 4) Otherwise distribute according to the relative ratio of each SizeRef value
     1076:19179:            float split_ratio = child_0->SizeRef[axis] / (child_0->SizeRef[axis] + child_1->SizeRef[axis]);
     1076:19179-block 110
call    0 returned 1076
call    1 returned 1076
call    2 returned 1076
     1076:19180:            child_0_size[axis] = ImMax(size_min_each, ImTrunc(size_avail * split_ratio + 0.5f));
call    0 returned 1076
call    1 returned 1076
call    2 returned 1076
     1076:19181:            child_1_size[axis] = (size_avail - child_0_size[axis]);
call    0 returned 1076
call    1 returned 1076
        -:19182:        }
        -:19183:
     4308:19184:        child_1_pos[axis] += spacing + child_0_size[axis];
     4308:19184-block 119
call    0 returned 4308
call    1 returned 4308
        -:19185:    }
        -:19186:
     4313:19187:    if (only_write_to_single_node == NULL)
     4313:19187-block 122
branch  0 taken 4309 (fallthrough)
branch  1 taken 4
     4309:19188:        child_0->WantLockSizeOnce = child_1->WantLockSizeOnce = false;
     4309:19188-block 123
        -:19189:
     4313:19190:    const bool child_0_recurse = only_write_to_single_node ? child_0_is_toward_single_node : child_0->IsVisible;
     4313:19190-block 124
branch  0 taken 4309 (fallthrough)
branch  1 taken 4
     4309:19190-block 125
        4:19190-block 126
     4313:19191:    const bool child_1_recurse = only_write_to_single_node ? child_1_is_toward_single_node : child_1->IsVisible;
     4313:19191-block 127
branch  0 taken 4309 (fallthrough)
branch  1 taken 4
     4309:19191-block 128
        4:19191-block 129
     4313:19192:    if (child_0_recurse)
     4313:19192-block 130
branch  0 taken 4308 (fallthrough)
branch  1 taken 5
     4308:19193:        DockNodeTreeUpdatePosSize(child_0, child_0_pos, child_0_size);
     4308:19193-block 131
call    0 returned 4308
branch  1 taken 4308 (fallthrough)
branch  2 taken 0 (throw)
     4313:19194:    if (child_1_recurse)
     4313:19194-block 132
branch  0 taken 4307 (fallthrough)
branch  1 taken 6
     4307:19195:        DockNodeTreeUpdatePosSize(child_1, child_1_pos, child_1_size);
     4307:19195-block 133
call    0 returned 4307
branch  1 taken 4307 (fallthrough)
branch  2 taken 0 (throw)
        -:19196:}
        -:19197:
function _ZL42DockNodeTreeUpdateSplitterFindTouchingNodeP13ImGuiDockNode9ImGuiAxisiP8ImVectorIS0_E called 0 returned 0% blocks executed 0%
    #####:19198:static void DockNodeTreeUpdateSplitterFindTouchingNode(ImGuiDockNode* node, ImGuiAxis axis, int side, ImVector<ImGuiDockNode*>* touching_nodes)
        -:19199:{
    #####:19200:    if (node->IsLeafNode())
    %%%%%:19200-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -:19201:    {
    #####:19202:        touching_nodes->push_back(node);
    %%%%%:19202-block 4
call    0 never executed
    #####:19203:        return;
        -:19204:    }
    #####:19205:    if (node->ChildNodes[0]->IsVisible)
    %%%%%:19205-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:19206:        if (node->SplitAxis != axis || side == 0 || !node->ChildNodes[1]->IsVisible)
    %%%%%:19206-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19206-block 8
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:19206-block 9
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:19207:            DockNodeTreeUpdateSplitterFindTouchingNode(node->ChildNodes[0], axis, side, touching_nodes);
    %%%%%:19207-block 10
call    0 never executed
    #####:19208:    if (node->ChildNodes[1]->IsVisible)
    %%%%%:19208-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:19209:        if (node->SplitAxis != axis || side == 1 || !node->ChildNodes[0]->IsVisible)
    %%%%%:19209-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19209-block 13
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:19209-block 14
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:19210:            DockNodeTreeUpdateSplitterFindTouchingNode(node->ChildNodes[1], axis, side, touching_nodes);
    %%%%%:19210-block 15
call    0 never executed
        -:19211:}
        -:19212:
        -:19213:// (Depth-First, Pre-Order)
function _ZN5ImGuiL26DockNodeTreeUpdateSplitterEP13ImGuiDockNode called 9688 returned 100% blocks executed 50%
     9688:19214:void ImGui::DockNodeTreeUpdateSplitter(ImGuiDockNode* node)
        -:19215:{
     9688:19216:    if (node->IsLeafNode())
     9688:19216-block 2
call    0 returned 9688
branch  1 taken 5381 (fallthrough)
branch  2 taken 4307
     5381:19217:        return;
     5381:19217-block 4
        -:19218:
     4307:19219:    ImGuiContext& g = *GImGui;
        -:19220:
     4307:19221:    ImGuiDockNode* child_0 = node->ChildNodes[0];
     4307:19222:    ImGuiDockNode* child_1 = node->ChildNodes[1];
     4307:19223:    if (child_0->IsVisible && child_1->IsVisible)
     4307:19223-block 5
branch  0 taken 4305 (fallthrough)
branch  1 taken 2
     4305:19223-block 6
branch  2 taken 4304 (fallthrough)
branch  3 taken 1
        -:19224:    {
        -:19225:        // Bounding box of the splitter cover the space between both nodes (w = Spacing, h = Size[xy^1] for when splitting horizontally)
     4304:19226:        const ImGuiAxis axis = (ImGuiAxis)node->SplitAxis;
    4304*:19227:        IM_ASSERT(axis != ImGuiAxis_None);
     4304:19227-block 7
branch  0 taken 0 (fallthrough)
branch  1 taken 4304
    %%%%%:19227-block 8
call    2 never executed
     4304:19228:        ImRect bb;
     4304:19229:        bb.Min = child_0->Pos;
     4304:19230:        bb.Max = child_1->Pos;
     4304:19231:        bb.Min[axis] += child_0->Size[axis];
     4304:19231-block 9
call    0 returned 4304
call    1 returned 4304
     4304:19232:        bb.Max[axis ^ 1] += child_1->Size[axis ^ 1];
call    0 returned 4304
call    1 returned 4304
        -:19233:        //if (g.IO.KeyCtrl) GetForegroundDrawList(g.CurrentWindow->Viewport)->AddRect(bb.Min, bb.Max, IM_COL32(255,0,255,255));
        -:19234:
     4304:19235:        const ImGuiDockNodeFlags merged_flags = child_0->MergedFlags | child_1->MergedFlags; // Merged flags for BOTH childs
     4304:19236:        const ImGuiDockNodeFlags no_resize_axis_flag = (axis == ImGuiAxis_X) ? ImGuiDockNodeFlags_NoResizeX : ImGuiDockNodeFlags_NoResizeY;
branch  0 taken 3228 (fallthrough)
branch  1 taken 1076
     3228:19236-block 14
     1076:19236-block 15
     4304:19237:        if ((merged_flags & ImGuiDockNodeFlags_NoResize) || (merged_flags & no_resize_axis_flag))
     4304:19237-block 16
branch  0 taken 4304 (fallthrough)
branch  1 taken 0
     4304:19237-block 17
branch  2 taken 0 (fallthrough)
branch  3 taken 4304
        -:19238:        {
    #####:19239:            ImGuiWindow* window = g.CurrentWindow;
    #####:19240:            window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(ImGuiCol_Separator), g.Style.FrameRounding);
    %%%%%:19240-block 18
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####:19241:        }
    %%%%%:19241-block 20
        -:19242:        else
        -:19243:        {
        -:19244:            //bb.Min[axis] += 1; // Display a little inward so highlight doesn't connect with nearby tabs on the neighbor node.
        -:19245:            //bb.Max[axis] -= 1;
     4304:19246:            PushID(node->ID);
     4304:19246-block 21
call    0 returned 4304
branch  1 taken 4304 (fallthrough)
branch  2 taken 0 (throw)
        -:19247:
        -:19248:            // Find resizing limits by gathering list of nodes that are touching the splitter line.
    25824:19249:            ImVector<ImGuiDockNode*> touching_nodes[2];
     4304:19249-block 22
     8608:19249-block 23
call    0 returned 8608
    12912:19249-block 25
branch  1 taken 8608
branch  2 taken 4304 (fallthrough)
     4304:19249-block 81
     8608:19249-block 84
call    3 returned 8608
    $$$$$:19249-block 94
    $$$$$:19249-block 97
call    4 never executed
     4304:19250:            float min_size = g.Style.WindowMinSize[axis];
     4304:19250-block 26
call    0 returned 4304
        -:19251:            float resize_limits[2];
     4304:19252:            resize_limits[0] = node->ChildNodes[0]->Pos[axis] + min_size;
call    0 returned 4304
     4304:19253:            resize_limits[1] = node->ChildNodes[1]->Pos[axis] + node->ChildNodes[1]->Size[axis] - min_size;
call    0 returned 4304
call    1 returned 4304
        -:19254:
     4304:19255:            ImGuiID splitter_id = GetID("##Splitter");
call    0 returned 4304
branch  1 taken 4304 (fallthrough)
branch  2 taken 0 (throw)
     4304:19256:            if (g.ActiveId == splitter_id) // Only process when splitter is active
     4304:19256-block 31
branch  0 taken 0 (fallthrough)
branch  1 taken 4304
        -:19257:            {
    #####:19258:                DockNodeTreeUpdateSplitterFindTouchingNode(child_0, axis, 1, &touching_nodes[0]);
    %%%%%:19258-block 32
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:19259:                DockNodeTreeUpdateSplitterFindTouchingNode(child_1, axis, 0, &touching_nodes[1]);
    %%%%%:19259-block 33
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:19260:                for (int touching_node_n = 0; touching_node_n < touching_nodes[0].Size; touching_node_n++)
    %%%%%:19260-block 34
    %%%%%:19260-block 40
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:19261:                    resize_limits[0] = ImMax(resize_limits[0], touching_nodes[0][touching_node_n]->Rect().Min[axis] + min_size);
    %%%%%:19261-block 35
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:19262:                for (int touching_node_n = 0; touching_node_n < touching_nodes[1].Size; touching_node_n++)
    %%%%%:19262-block 41
    %%%%%:19262-block 47
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:19263:                    resize_limits[1] = ImMin(resize_limits[1], touching_nodes[1][touching_node_n]->Rect().Max[axis] - min_size);
    %%%%%:19263-block 42
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:19264:
        -:19265:                // [DEBUG] Render touching nodes & limits
        -:19266:                /*
        -:19267:                ImDrawList* draw_list = node->HostWindow ? GetForegroundDrawList(node->HostWindow) : GetForegroundDrawList(GetMainViewport());
        -:19268:                for (int n = 0; n < 2; n++)
        -:19269:                {
        -:19270:                    for (int touching_node_n = 0; touching_node_n < touching_nodes[n].Size; touching_node_n++)
        -:19271:                        draw_list->AddRect(touching_nodes[n][touching_node_n]->Pos, touching_nodes[n][touching_node_n]->Pos + touching_nodes[n][touching_node_n]->Size, IM_COL32(0, 255, 0, 255));
        -:19272:                    if (axis == ImGuiAxis_X)
        -:19273:                        draw_list->AddLine(ImVec2(resize_limits[n], node->ChildNodes[n]->Pos.y), ImVec2(resize_limits[n], node->ChildNodes[n]->Pos.y + node->ChildNodes[n]->Size.y), IM_COL32(255, 0, 255, 255), 3.0f);
        -:19274:                    else
        -:19275:                        draw_list->AddLine(ImVec2(node->ChildNodes[n]->Pos.x, resize_limits[n]), ImVec2(node->ChildNodes[n]->Pos.x + node->ChildNodes[n]->Size.x, resize_limits[n]), IM_COL32(255, 0, 255, 255), 3.0f);
        -:19276:                }
        -:19277:                */
        -:19278:            }
        -:19279:
        -:19280:            // Use a short delay before highlighting the splitter (and changing the mouse cursor) in order for regular mouse movement to not highlight many splitters
     4304:19281:            float cur_size_0 = child_0->Size[axis];
     4304:19281-block 48
call    0 returned 4304
     4304:19282:            float cur_size_1 = child_1->Size[axis];
call    0 returned 4304
     4304:19283:            float min_size_0 = resize_limits[0] - child_0->Pos[axis];
call    0 returned 4304
     4304:19284:            float min_size_1 = child_1->Pos[axis] + child_1->Size[axis] - resize_limits[1];
call    0 returned 4304
call    1 returned 4304
     4304:19285:            ImU32 bg_col = GetColorU32(ImGuiCol_WindowBg);
call    0 returned 4304
     4304:19286:            if (SplitterBehavior(bb, GetID("##Splitter"), axis, &cur_size_0, &cur_size_1, min_size_0, min_size_1, WINDOWS_HOVER_PADDING, WINDOWS_RESIZE_FROM_EDGES_FEEDBACK_TIMER, bg_col))
call    0 returned 4304
branch  1 taken 4304 (fallthrough)
branch  2 taken 0 (throw)
     4304:19286-block 55
call    3 returned 4304
branch  4 taken 4304 (fallthrough)
branch  5 taken 0 (throw)
     4304:19286-block 56
branch  6 taken 0 (fallthrough)
branch  7 taken 4304
        -:19287:            {
    #####:19288:                if (touching_nodes[0].Size > 0 && touching_nodes[1].Size > 0)
    %%%%%:19288-block 57
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19288-block 58
branch  2 never executed (fallthrough)
branch  3 never executed
        -:19289:                {
    #####:19290:                    child_0->Size[axis] = child_0->SizeRef[axis] = cur_size_0;
    %%%%%:19290-block 59
call    0 never executed
call    1 never executed
    #####:19291:                    child_1->Pos[axis] -= cur_size_1 - child_1->Size[axis];
call    0 never executed
call    1 never executed
    #####:19292:                    child_1->Size[axis] = child_1->SizeRef[axis] = cur_size_1;
call    0 never executed
call    1 never executed
        -:19293:
        -:19294:                    // Lock the size of every node that is a sibling of the node we are touching
        -:19295:                    // This might be less desirable if we can merge sibling of a same axis into the same parental level.
    #####:19296:                    for (int side_n = 0; side_n < 2; side_n++)
    %%%%%:19296-block 75
    %%%%%:19296-block 76
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:19297:                        for (int touching_node_n = 0; touching_node_n < touching_nodes[side_n].Size; touching_node_n++)
    %%%%%:19297-block 66
    %%%%%:19297-block 73
    %%%%%:19297-block 74
branch  0 never executed
branch  1 never executed (fallthrough)
        -:19298:                        {
    #####:19299:                            ImGuiDockNode* touching_node = touching_nodes[side_n][touching_node_n];
    %%%%%:19299-block 67
call    0 never executed
        -:19300:                            //ImDrawList* draw_list = node->HostWindow ? GetForegroundDrawList(node->HostWindow) : GetForegroundDrawList(GetMainViewport());
        -:19301:                            //draw_list->AddRect(touching_node->Pos, touching_node->Pos + touching_node->Size, IM_COL32(255, 128, 0, 255));
    #####:19302:                            while (touching_node->ParentNode != node)
    %%%%%:19302-block 72
branch  0 never executed
branch  1 never executed (fallthrough)
        -:19303:                            {
    #####:19304:                                if (touching_node->ParentNode->SplitAxis == axis)
    %%%%%:19304-block 69
branch  0 never executed (fallthrough)
branch  1 never executed
        -:19305:                                {
        -:19306:                                    // Mark other node so its size will be preserved during the upcoming call to DockNodeTreeUpdatePosSize().
    #####:19307:                                    ImGuiDockNode* node_to_preserve = touching_node->ParentNode->ChildNodes[side_n];
    #####:19308:                                    node_to_preserve->WantLockSizeOnce = true;
    %%%%%:19308-block 70
        -:19309:                                    //draw_list->AddRect(touching_node->Pos, touching_node->Rect().Max, IM_COL32(255, 0, 0, 255));
        -:19310:                                    //draw_list->AddRectFilled(node_to_preserve->Pos, node_to_preserve->Rect().Max, IM_COL32(0, 255, 0, 100));
        -:19311:                                }
    #####:19312:                                touching_node = touching_node->ParentNode;
    %%%%%:19312-block 71
        -:19313:                            }
        -:19314:                        }
        -:19315:
    #####:19316:                    DockNodeTreeUpdatePosSize(child_0, child_0->Pos, child_0->Size);
    %%%%%:19316-block 77
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:19317:                    DockNodeTreeUpdatePosSize(child_1, child_1->Pos, child_1->Size);
    %%%%%:19317-block 78
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:19318:                    MarkIniSettingsDirty();
    %%%%%:19318-block 79
call    0 never executed
        -:19319:                }
        -:19320:            }
     4304:19321:            PopID();
     4304:19321-block 80
call    0 returned 4304
branch  1 taken 4304 (fallthrough)
branch  2 taken 0 (throw)
    12912:19322:        }
    12912:19322-block 82
branch  0 taken 8608 (fallthrough)
branch  1 taken 4304
    $$$$$:19322-block 95
branch  2 never executed (fallthrough)
branch  3 never executed
        -:19323:    }
        -:19324:
     4307:19325:    if (child_0->IsVisible)
     4307:19325-block 89
branch  0 taken 4305 (fallthrough)
branch  1 taken 2
     4305:19326:        DockNodeTreeUpdateSplitter(child_0);
     4305:19326-block 90
call    0 returned 4305
     4307:19327:    if (child_1->IsVisible)
     4307:19327-block 91
branch  0 taken 4306 (fallthrough)
branch  1 taken 1
     4306:19328:        DockNodeTreeUpdateSplitter(child_1);
     4306:19328-block 92
call    0 returned 4306
        -:19329:}
        -:19330:
function _ZN5ImGuiL32DockNodeTreeFindFallbackLeafNodeEP13ImGuiDockNode called 0 returned 0% blocks executed 0%
    #####:19331:ImGuiDockNode* ImGui::DockNodeTreeFindFallbackLeafNode(ImGuiDockNode* node)
        -:19332:{
    #####:19333:    if (node->IsLeafNode())
    %%%%%:19333-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:19334:        return node;
    %%%%%:19334-block 4
    #####:19335:    if (ImGuiDockNode* leaf_node = DockNodeTreeFindFallbackLeafNode(node->ChildNodes[0]))
    %%%%%:19335-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:19336:        return leaf_node;
    %%%%%:19336-block 7
    #####:19337:    if (ImGuiDockNode* leaf_node = DockNodeTreeFindFallbackLeafNode(node->ChildNodes[1]))
    %%%%%:19337-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:19338:        return leaf_node;
    %%%%%:19338-block 10
    #####:19339:    return NULL;
    %%%%%:19339-block 11
        -:19340:}
        -:19341:
function _ZN5ImGuiL32DockNodeTreeFindVisibleNodeByPosEP13ImGuiDockNode6ImVec2 called 0 returned 0% blocks executed 0%
    #####:19342:ImGuiDockNode* ImGui::DockNodeTreeFindVisibleNodeByPos(ImGuiDockNode* node, ImVec2 pos)
        -:19343:{
    #####:19344:    if (!node->IsVisible)
    %%%%%:19344-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:19345:        return NULL;
    %%%%%:19345-block 3
        -:19346:
    #####:19347:    const float dock_spacing = 0.0f;// g.Style.ItemInnerSpacing.x; // FIXME: Relation to DOCKING_SPLITTER_SIZE?
    #####:19348:    ImRect r(node->Pos, node->Pos + node->Size);
    %%%%%:19348-block 4
call    0 never executed
call    1 never executed
    #####:19349:    r.Expand(dock_spacing * 0.5f);
call    0 never executed
    #####:19350:    bool inside = r.Contains(pos);
call    0 never executed
    #####:19351:    if (!inside)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:19352:        return NULL;
    %%%%%:19352-block 9
        -:19353:
    #####:19354:    if (node->IsLeafNode())
    %%%%%:19354-block 10
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:19355:        return node;
    %%%%%:19355-block 12
    #####:19356:    if (ImGuiDockNode* hovered_node = DockNodeTreeFindVisibleNodeByPos(node->ChildNodes[0], pos))
    %%%%%:19356-block 13
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:19356-block 14
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:19357:        return hovered_node;
    %%%%%:19357-block 15
    #####:19358:    if (ImGuiDockNode* hovered_node = DockNodeTreeFindVisibleNodeByPos(node->ChildNodes[1], pos))
    %%%%%:19358-block 16
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:19358-block 17
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:19359:        return hovered_node;
    %%%%%:19359-block 18
        -:19360:
        -:19361:    // This means we are hovering over the splitter/spacing of a parent node
    #####:19362:    return node;
    %%%%%:19362-block 19
        -:19363:}
        -:19364:
        -:19365://-----------------------------------------------------------------------------
        -:19366:// Docking: Public Functions (SetWindowDock, DockSpace, DockSpaceOverViewport)
        -:19367://-----------------------------------------------------------------------------
        -:19368:// - SetWindowDock() [Internal]
        -:19369:// - DockSpace()
        -:19370:// - DockSpaceOverViewport()
        -:19371://-----------------------------------------------------------------------------
        -:19372:
        -:19373:// [Internal] Called via SetNextWindowDockID()
function _ZN5ImGui13SetWindowDockEP11ImGuiWindowji called 0 returned 0% blocks executed 0%
    #####:19374:void ImGui::SetWindowDock(ImGuiWindow* window, ImGuiID dock_id, ImGuiCond cond)
        -:19375:{
        -:19376:    // Test condition (NB: bit 0 is always true) and clear flags for next time
    #####:19377:    if (cond && (window->SetWindowDockAllowFlags & cond) == 0)
    %%%%%:19377-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19377-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:19378:        return;
    %%%%%:19378-block 4
    #####:19379:    window->SetWindowDockAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);
        -:19380:
    #####:19381:    if (window->DockId == dock_id)
    %%%%%:19381-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:19382:        return;
    %%%%%:19382-block 6
        -:19383:
        -:19384:    // If the user attempt to set a dock id that is a split node, we'll dig within to find a suitable docking spot
    #####:19385:    ImGuiContext& g = *GImGui;
    #####:19386:    if (ImGuiDockNode* new_node = DockContextFindNodeByID(&g, dock_id))
    %%%%%:19386-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:19387:        if (new_node->IsSplitNode())
    %%%%%:19387-block 9
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -:19388:        {
        -:19389:            // Policy: Find central node or latest focused node. We first move back to our root node.
    #####:19390:            new_node = DockNodeGetRootNode(new_node);
    %%%%%:19390-block 11
call    0 never executed
    #####:19391:            if (new_node->CentralNode)
branch  0 never executed (fallthrough)
branch  1 never executed
        -:19392:            {
    #####:19393:                IM_ASSERT(new_node->CentralNode->IsCentralNode());
    %%%%%:19393-block 13
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:19393-block 15
call    3 never executed
    #####:19394:                dock_id = new_node->CentralNode->ID;
    %%%%%:19394-block 16
        -:19395:            }
        -:19396:            else
        -:19397:            {
    #####:19398:                dock_id = new_node->LastFocusedNodeId;
    %%%%%:19398-block 17
        -:19399:            }
        -:19400:        }
        -:19401:
    #####:19402:    if (window->DockId == dock_id)
    %%%%%:19402-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:19403:        return;
    %%%%%:19403-block 19
        -:19404:
    #####:19405:    if (window->DockNode)
    %%%%%:19405-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:19406:        DockNodeRemoveWindow(window->DockNode, window, 0);
    %%%%%:19406-block 21
call    0 never executed
    #####:19407:    window->DockId = dock_id;
    %%%%%:19407-block 22
        -:19408:}
        -:19409:
        -:19410:// Create an explicit dockspace node within an existing window. Also expose dock node flags and creates a CentralNode by default.
        -:19411:// The Central Node is always displayed even when empty and shrink/extend according to the requested size of its neighbors.
        -:19412:// DockSpace() needs to be submitted _before_ any window they can host. If you use a dockspace, submit it early in your app.
        -:19413:// When ImGuiDockNodeFlags_KeepAliveOnly is set, nothing is submitted in the current window (function may be called from any location).
function _ZN5ImGui9DockSpaceEjRK6ImVec2iPK16ImGuiWindowClass called 1077 returned 100% blocks executed 69%
     1077:19414:ImGuiID ImGui::DockSpace(ImGuiID dockspace_id, const ImVec2& size_arg, ImGuiDockNodeFlags flags, const ImGuiWindowClass* window_class)
        -:19415:{
     1077:19416:    ImGuiContext& g = *GImGui;
     1077:19417:    ImGuiWindow* window = GetCurrentWindowRead();
     1077:19417-block 2
call    0 returned 1077
     1077:19418:    if (!(g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable))
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####:19419:        return 0;
    %%%%%:19419-block 4
        -:19420:
        -:19421:    // Early out if parent window is hidden/collapsed
        -:19422:    // This is faster but also DockNodeUpdateTabBar() relies on TabBarLayout() running (which won't if SkipItems=true) to set NextSelectedTabId = 0). See #2960.
        -:19423:    // If for whichever reason this is causing problem we would need to ensure that DockNodeUpdateTabBar() ends up clearing NextSelectedTabId even if SkipItems=true.
     1077:19424:    if (window->SkipItems)
     1077:19424-block 5
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####:19425:        flags |= ImGuiDockNodeFlags_KeepAliveOnly;
    %%%%%:19425-block 6
     1077:19426:    if ((flags & ImGuiDockNodeFlags_KeepAliveOnly) == 0)
     1077:19426-block 7
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:19427:        window = GetCurrentWindow(); // call to set window->WriteAccessed = true;
     1077:19427-block 8
call    0 returned 1077
        -:19428:
    1077*:19429:    IM_ASSERT((flags & ImGuiDockNodeFlags_DockSpace) == 0);
     1077:19429-block 9
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:19429-block 10
call    2 never executed
    1077*:19430:    IM_ASSERT(dockspace_id != 0);
     1077:19430-block 11
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:19430-block 12
call    2 never executed
     1077:19431:    ImGuiDockNode* node = DockContextFindNodeByID(&g, dockspace_id);
     1077:19431-block 13
call    0 returned 1077
     1077:19432:    if (node == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
        -:19433:    {
    #####:19434:        IMGUI_DEBUG_LOG_DOCKING("[docking] DockSpace: dockspace node 0x%08X created\n", dockspace_id);
    %%%%%:19434-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19434-block 16
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####:19435:        node = DockContextAddNode(&g, dockspace_id);
    %%%%%:19435-block 17
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:19436:        node->SetLocalFlags(ImGuiDockNodeFlags_CentralNode);
    %%%%%:19436-block 18
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:19437:    }
    1077*:19438:    if (window_class && window_class->ClassId != node->WindowClass.ClassId)
     1077:19438-block 19
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:19438-block 20
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:19439:        IMGUI_DEBUG_LOG_DOCKING("[docking] DockSpace: dockspace node 0x%08X: setup WindowClass 0x%08X -> 0x%08X\n", dockspace_id, node->WindowClass.ClassId, window_class->ClassId);
    %%%%%:19439-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19439-block 22
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
     1077:19440:    node->SharedFlags = flags;
    1077*:19441:    node->WindowClass = window_class ? *window_class : ImGuiWindowClass();
     1077:19441-block 23
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:19441-block 24
     1077:19441-block 25
call    2 returned 1077
        -:19442:
        -:19443:    // When a DockSpace transitioned form implicit to explicit this may be called a second time
        -:19444:    // It is possible that the node has already been claimed by a docked window which appeared before the DockSpace() node, so we overwrite IsDockSpace again.
    1077*:19445:    if (node->LastFrameActive == g.FrameCount && !(flags & ImGuiDockNodeFlags_KeepAliveOnly))
     1077:19445-block 26
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:19445-block 27
branch  2 never executed (fallthrough)
branch  3 never executed
        -:19446:    {
    #####:19447:        IM_ASSERT(node->IsDockSpace() == false && "Cannot call DockSpace() twice a frame with the same ID");
    %%%%%:19447-block 28
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:19447-block 30
    %%%%%:19447-block 31
call    3 never executed
    #####:19448:        node->SetLocalFlags(node->LocalFlags | ImGuiDockNodeFlags_DockSpace);
    %%%%%:19448-block 32
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:19449:        return dockspace_id;
    %%%%%:19449-block 33
        -:19450:    }
     1077:19451:    node->SetLocalFlags(node->LocalFlags | ImGuiDockNodeFlags_DockSpace);
     1077:19451-block 34
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -:19452:
        -:19453:    // Keep alive mode, this is allow windows docked into this node so stay docked even if they are not visible
     1077:19454:    if (flags & ImGuiDockNodeFlags_KeepAliveOnly)
     1077:19454-block 35
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
        -:19455:    {
    #####:19456:        node->LastFrameAlive = g.FrameCount;
    #####:19457:        return dockspace_id;
    %%%%%:19457-block 36
        -:19458:    }
        -:19459:
     1077:19460:    const ImVec2 content_avail = GetContentRegionAvail();
     1077:19460-block 37
call    0 returned 1077
     1077:19461:    ImVec2 size = ImTrunc(size_arg);
call    0 returned 1077
     1077:19462:    if (size.x <= 0.0f)
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:19463:        size.x = ImMax(content_avail.x + size.x, 4.0f); // Arbitrary minimum child size (0.0f causing too much issues)
     1077:19463-block 40
call    0 returned 1077
     1077:19464:    if (size.y <= 0.0f)
     1077:19464-block 42
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:19465:        size.y = ImMax(content_avail.y + size.y, 4.0f);
     1077:19465-block 43
call    0 returned 1077
    1077*:19466:    IM_ASSERT(size.x > 0.0f && size.y > 0.0f);
     1077:19466-block 45
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:19466-block 46
branch  2 taken 1077 (fallthrough)
branch  3 taken 0
     1077:19466-block 47
    %%%%%:19466-block 48
call    4 never executed
        -:19467:
     1077:19468:    node->Pos = window->DC.CursorPos;
     1077:19469:    node->Size = node->SizeRef = size;
     1077:19470:    SetNextWindowPos(node->Pos);
     1077:19470-block 49
call    0 returned 1077
call    1 returned 1077
     1077:19471:    SetNextWindowSize(node->Size);
call    0 returned 1077
     1077:19472:    g.NextWindowData.PosUndock = false;
        -:19473:
        -:19474:    // FIXME-DOCK: Why do we need a child window to host a dockspace, could we host it in the existing window?
        -:19475:    // FIXME-DOCK: What is the reason for not simply calling BeginChild()? (OK to have a reason but should be commented)
     1077:19476:    ImGuiWindowFlags window_flags = ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_DockNodeHost;
     1077:19477:    window_flags |= ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoTitleBar;
     1077:19478:    window_flags |= ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoScrollWithMouse;
     1077:19479:    window_flags |= ImGuiWindowFlags_NoBackground;
        -:19480:
        -:19481:    char title[256];
     1077:19482:    ImFormatString(title, IM_ARRAYSIZE(title), "%s/DockSpace_%08X", window->Name, dockspace_id);
call    0 returned 1077
        -:19483:
     1077:19484:    PushStyleVar(ImGuiStyleVar_ChildBorderSize, 0.0f);
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:19485:    Begin(title, NULL, window_flags);
     1077:19485-block 54
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:19486:    PopStyleVar();
     1077:19486-block 55
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -:19487:
     1077:19488:    ImGuiWindow* host_window = g.CurrentWindow;
     1077:19489:    DockNodeSetupHostWindow(node, host_window);
     1077:19489-block 56
call    0 returned 1077
     1077:19490:    host_window->ChildId = window->GetID(title);
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:19491:    node->OnlyNodeWithWindows = NULL;
        -:19492:
    1077*:19493:    IM_ASSERT(node->IsRootNode());
     1077:19493-block 58
call    0 returned 1077
branch  1 taken 0 (fallthrough)
branch  2 taken 1077
    %%%%%:19493-block 60
call    3 never executed
        -:19494:
        -:19495:    // We need to handle the rare case were a central node is missing.
        -:19496:    // This can happen if the node was first created manually with DockBuilderAddNode() but _without_ the ImGuiDockNodeFlags_Dockspace.
        -:19497:    // Doing it correctly would set the _CentralNode flags, which would then propagate according to subsequent split.
        -:19498:    // It would also be ambiguous to attempt to assign a central node while there are split nodes, so we wait until there's a single node remaining.
        -:19499:    // The specific sub-property of _CentralNode we are interested in recovering here is the "Don't delete when empty" property,
        -:19500:    // as it doesn't make sense for an empty dockspace to not have this property.
    1077*:19501:    if (node->IsLeafNode() && !node->IsCentralNode())
     1077:19501-block 61
call    0 returned 1077
branch  1 taken 0 (fallthrough)
branch  2 taken 1077
    %%%%%:19501-block 63
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:19501-block 65
     1077:19501-block 66
     1077:19501-block 67
branch  6 taken 0 (fallthrough)
branch  7 taken 1077
    #####:19502:        node->SetLocalFlags(node->LocalFlags | ImGuiDockNodeFlags_CentralNode);
    %%%%%:19502-block 68
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:19503:
        -:19504:    // Update the node
     1077:19505:    DockNodeUpdate(node);
     1077:19505-block 69
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -:19506:
     1077:19507:    End();
     1077:19507-block 70
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -:19508:
     1077:19509:    ImRect bb(node->Pos, node->Pos + size);
     1077:19509-block 71
call    0 returned 1077
call    1 returned 1077
     1077:19510:    ItemSize(size);
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:19511:    ItemAdd(bb, dockspace_id, NULL, ImGuiItemFlags_NoNav); // Not a nav point (could be, would need to draw the nav rect and replicate/refactor activation from BeginChild(), but seems like CTRL+Tab works better here?)
     1077:19511-block 74
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:19512:    if ((g.LastItemData.StatusFlags & ImGuiItemStatusFlags_HoveredRect) && IsWindowChildOf(g.HoveredWindow, host_window, false, true)) // To fullfill IsItemHovered(), similar to EndChild()
     1077:19512-block 75
branch  0 taken 1075 (fallthrough)
branch  1 taken 2
     1075:19512-block 76
call    2 returned 1075
branch  3 taken 1075 (fallthrough)
branch  4 taken 0
     1075:19512-block 78
        2:19512-block 79
     1077:19512-block 80
branch  5 taken 1075 (fallthrough)
branch  6 taken 2
     1075:19513:        g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredWindow;
     1075:19513-block 81
        -:19514:
     1077:19515:    return dockspace_id;
     1077:19515-block 82
        -:19516:}
        -:19517:
        -:19518:// Tips: Use with ImGuiDockNodeFlags_PassthruCentralNode!
        -:19519:// The limitation with this call is that your window won't have a local menu bar, but you can also use BeginMainMenuBar().
        -:19520:// Even though we could pass window flags, it would also require the user to be able to call BeginMenuBar() somehow meaning we can't Begin/End in a single function.
        -:19521:// If you really want a menu bar inside the same window as the one hosting the dockspace, you will need to copy this code somewhere and tweak it.
function _ZN5ImGui21DockSpaceOverViewportEjPK13ImGuiViewportiPK16ImGuiWindowClass called 1077 returned 100% blocks executed 81%
     1077:19522:ImGuiID ImGui::DockSpaceOverViewport(ImGuiID dockspace_id, const ImGuiViewport* viewport, ImGuiDockNodeFlags dockspace_flags, const ImGuiWindowClass* window_class)
        -:19523:{
     1077:19524:    if (viewport == NULL)
     1077:19524-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####:19525:        viewport = GetMainViewport();
    %%%%%:19525-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:19525-block 4
        -:19526:
        -:19527:    // Submit a window filling the entire viewport
     1077:19528:    SetNextWindowPos(viewport->WorkPos);
     1077:19528-block 5
call    0 returned 1077
call    1 returned 1077
     1077:19529:    SetNextWindowSize(viewport->WorkSize);
call    0 returned 1077
     1077:19530:    SetNextWindowViewport(viewport->ID);
call    0 returned 1077
        -:19531:
     1077:19532:    ImGuiWindowFlags host_window_flags = 0;
     1077:19533:    host_window_flags |= ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoDocking;
     1077:19534:    host_window_flags |= ImGuiWindowFlags_NoBringToFrontOnFocus | ImGuiWindowFlags_NoNavFocus;
     1077:19535:    if (dockspace_flags & ImGuiDockNodeFlags_PassthruCentralNode)
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####:19536:        host_window_flags |= ImGuiWindowFlags_NoBackground;
    %%%%%:19536-block 10
        -:19537:
        -:19538:    char label[32];
     1077:19539:    ImFormatString(label, IM_ARRAYSIZE(label), "WindowOverViewport_%08X", viewport->ID);
     1077:19539-block 11
call    0 returned 1077
        -:19540:
     1077:19541:    PushStyleVar(ImGuiStyleVar_WindowRounding, 0.0f);
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:19542:    PushStyleVar(ImGuiStyleVar_WindowBorderSize, 0.0f);
     1077:19542-block 13
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:19543:    PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0.0f, 0.0f));
     1077:19543-block 14
call    0 returned 1077
call    1 returned 1077
branch  2 taken 1077 (fallthrough)
branch  3 taken 0 (throw)
    $$$$$:19543-block 26
     1077:19544:    Begin(label, NULL, host_window_flags);
     1077:19544-block 16
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:19545:    PopStyleVar(3);
     1077:19545-block 17
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -:19546:
        -:19547:    // Submit the dockspace
     1077:19548:    if (dockspace_id == 0)
     1077:19548-block 18
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:19549:        dockspace_id = GetID("DockSpace");
     1077:19549-block 19
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:19549-block 20
     1077:19550:    DockSpace(dockspace_id, ImVec2(0.0f, 0.0f), dockspace_flags, window_class);
     1077:19550-block 21
call    0 returned 1077
call    1 returned 1077
branch  2 taken 1077 (fallthrough)
branch  3 taken 0 (throw)
    $$$$$:19550-block 27
        -:19551:
     1077:19552:    End();
     1077:19552-block 23
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -:19553:
     1077:19554:    return dockspace_id;
     1077:19554-block 24
     1077:19554-block 25
        -:19555:}
        -:19556:
        -:19557://-----------------------------------------------------------------------------
        -:19558:// Docking: Builder Functions
        -:19559://-----------------------------------------------------------------------------
        -:19560:// Very early end-user API to manipulate dock nodes.
        -:19561:// Only available in imgui_internal.h. Expect this API to change/break!
        -:19562:// It is expected that those functions are all called _before_ the dockspace node submission.
        -:19563://-----------------------------------------------------------------------------
        -:19564:// - DockBuilderDockWindow()
        -:19565:// - DockBuilderGetNode()
        -:19566:// - DockBuilderSetNodePos()
        -:19567:// - DockBuilderSetNodeSize()
        -:19568:// - DockBuilderAddNode()
        -:19569:// - DockBuilderRemoveNode()
        -:19570:// - DockBuilderRemoveNodeChildNodes()
        -:19571:// - DockBuilderRemoveNodeDockedWindows()
        -:19572:// - DockBuilderSplitNode()
        -:19573:// - DockBuilderCopyNodeRec()
        -:19574:// - DockBuilderCopyNode()
        -:19575:// - DockBuilderCopyWindowSettings()
        -:19576:// - DockBuilderCopyDockSpace()
        -:19577:// - DockBuilderFinish()
        -:19578://-----------------------------------------------------------------------------
        -:19579:
function _ZN5ImGui21DockBuilderDockWindowEPKcj called 0 returned 0% blocks executed 0%
    #####:19580:void ImGui::DockBuilderDockWindow(const char* window_name, ImGuiID node_id)
        -:19581:{
        -:19582:    // We don't preserve relative order of multiple docked windows (by clearing DockOrder back to -1)
    #####:19583:    ImGuiContext& g = *GImGui; IM_UNUSED(g);
    #####:19584:    IMGUI_DEBUG_LOG_DOCKING("[docking] DockBuilderDockWindow '%s' to node 0x%08X\n", window_name, node_id);
    %%%%%:19584-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19584-block 3
call    2 never executed
    #####:19585:    ImGuiID window_id = ImHashStr(window_name);
    %%%%%:19585-block 4
call    0 never executed
    #####:19586:    if (ImGuiWindow* window = FindWindowByID(window_id))
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -:19587:    {
        -:19588:        // Apply to created window
    #####:19589:        ImGuiID prev_node_id = window->DockId;
    #####:19590:        SetWindowDock(window, node_id, ImGuiCond_Always);
    %%%%%:19590-block 7
call    0 never executed
    #####:19591:        if (window->DockId != prev_node_id)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:19592:            window->DockOrder = -1;
    %%%%%:19592-block 9
        -:19593:    }
        -:19594:    else
        -:19595:    {
        -:19596:        // Apply to settings
    #####:19597:        ImGuiWindowSettings* settings = FindWindowSettingsByID(window_id);
    %%%%%:19597-block 10
call    0 never executed
    #####:19598:        if (settings == NULL)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:19599:            settings = CreateNewWindowSettings(window_name);
    %%%%%:19599-block 12
call    0 never executed
    #####:19600:        if (settings->DockId != node_id)
    %%%%%:19600-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:19601:            settings->DockOrder = -1;
    %%%%%:19601-block 15
    #####:19602:        settings->DockId = node_id;
    %%%%%:19602-block 16
        -:19603:    }
    #####:19604:}
        -:19605:
function _ZN5ImGui18DockBuilderGetNodeEj called 0 returned 0% blocks executed 0%
    #####:19606:ImGuiDockNode* ImGui::DockBuilderGetNode(ImGuiID node_id)
        -:19607:{
    #####:19608:    ImGuiContext& g = *GImGui;
    #####:19609:    return DockContextFindNodeByID(&g, node_id);
    %%%%%:19609-block 2
call    0 never executed
        -:19610:}
        -:19611:
function _ZN5ImGui21DockBuilderSetNodePosEj6ImVec2 called 0 returned 0% blocks executed 0%
    #####:19612:void ImGui::DockBuilderSetNodePos(ImGuiID node_id, ImVec2 pos)
        -:19613:{
    #####:19614:    ImGuiContext& g = *GImGui;
    #####:19615:    ImGuiDockNode* node = DockContextFindNodeByID(&g, node_id);
    %%%%%:19615-block 2
call    0 never executed
    #####:19616:    if (node == NULL)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:19617:        return;
    %%%%%:19617-block 4
    #####:19618:    node->Pos = pos;
    #####:19619:    node->AuthorityForPos = ImGuiDataAuthority_DockNode;
    %%%%%:19619-block 5
        -:19620:}
        -:19621:
function _ZN5ImGui22DockBuilderSetNodeSizeEj6ImVec2 called 0 returned 0% blocks executed 0%
    #####:19622:void ImGui::DockBuilderSetNodeSize(ImGuiID node_id, ImVec2 size)
        -:19623:{
    #####:19624:    ImGuiContext& g = *GImGui;
    #####:19625:    ImGuiDockNode* node = DockContextFindNodeByID(&g, node_id);
    %%%%%:19625-block 2
call    0 never executed
    #####:19626:    if (node == NULL)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:19627:        return;
    %%%%%:19627-block 4
    #####:19628:    IM_ASSERT(size.x > 0.0f && size.y > 0.0f);
    %%%%%:19628-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19628-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:19628-block 7
    %%%%%:19628-block 8
call    4 never executed
    #####:19629:    node->Size = node->SizeRef = size;
    #####:19630:    node->AuthorityForSize = ImGuiDataAuthority_DockNode;
    %%%%%:19630-block 9
        -:19631:}
        -:19632:
        -:19633:// Make sure to use the ImGuiDockNodeFlags_DockSpace flag to create a dockspace node! Otherwise this will create a floating node!
        -:19634:// - Floating node: you can then call DockBuilderSetNodePos()/DockBuilderSetNodeSize() to position and size the floating node.
        -:19635:// - Dockspace node: calling DockBuilderSetNodePos() is unnecessary.
        -:19636:// - If you intend to split a node immediately after creation using DockBuilderSplitNode(), make sure to call DockBuilderSetNodeSize() beforehand!
        -:19637://   For various reason, the splitting code currently needs a base size otherwise space may not be allocated as precisely as you would expect.
        -:19638:// - Use (id == 0) to let the system allocate a node identifier.
        -:19639:// - Existing node with a same id will be removed.
function _ZN5ImGui18DockBuilderAddNodeEji called 0 returned 0% blocks executed 0%
    #####:19640:ImGuiID ImGui::DockBuilderAddNode(ImGuiID node_id, ImGuiDockNodeFlags flags)
        -:19641:{
    #####:19642:    ImGuiContext& g = *GImGui; IM_UNUSED(g);
    #####:19643:    IMGUI_DEBUG_LOG_DOCKING("[docking] DockBuilderAddNode 0x%08X flags=%08X\n", node_id, flags);
    %%%%%:19643-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19643-block 3
call    2 never executed
        -:19644:
    #####:19645:    if (node_id != 0)
    %%%%%:19645-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:19646:        DockBuilderRemoveNode(node_id);
    %%%%%:19646-block 5
call    0 never executed
        -:19647:
    #####:19648:    ImGuiDockNode* node = NULL;
    #####:19649:    if (flags & ImGuiDockNodeFlags_DockSpace)
    %%%%%:19649-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
        -:19650:    {
    #####:19651:        DockSpace(node_id, ImVec2(0, 0), (flags & ~ImGuiDockNodeFlags_DockSpace) | ImGuiDockNodeFlags_KeepAliveOnly);
    %%%%%:19651-block 7
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####:19652:        node = DockContextFindNodeByID(&g, node_id);
    %%%%%:19652-block 9
call    0 never executed
        -:19653:    }
        -:19654:    else
        -:19655:    {
    #####:19656:        node = DockContextAddNode(&g, node_id);
    %%%%%:19656-block 10
call    0 never executed
    #####:19657:        node->SetLocalFlags(flags);
call    0 never executed
        -:19658:    }
    #####:19659:    node->LastFrameAlive = g.FrameCount;   // Set this otherwise BeginDocked will undock during the same frame.
    #####:19660:    return node->ID;
    %%%%%:19660-block 12
    %%%%%:19660-block 13
        -:19661:}
        -:19662:
function _ZN5ImGui21DockBuilderRemoveNodeEj called 0 returned 0% blocks executed 0%
    #####:19663:void ImGui::DockBuilderRemoveNode(ImGuiID node_id)
        -:19664:{
    #####:19665:    ImGuiContext& g = *GImGui; IM_UNUSED(g);
    #####:19666:    IMGUI_DEBUG_LOG_DOCKING("[docking] DockBuilderRemoveNode 0x%08X\n", node_id);
    %%%%%:19666-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19666-block 3
call    2 never executed
        -:19667:
    #####:19668:    ImGuiDockNode* node = DockContextFindNodeByID(&g, node_id);
    %%%%%:19668-block 4
call    0 never executed
    #####:19669:    if (node == NULL)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:19670:        return;
    %%%%%:19670-block 6
    #####:19671:    DockBuilderRemoveNodeDockedWindows(node_id, true);
    %%%%%:19671-block 7
call    0 never executed
    #####:19672:    DockBuilderRemoveNodeChildNodes(node_id);
call    0 never executed
        -:19673:    // Node may have moved or deleted if e.g. any merge happened
    #####:19674:    node = DockContextFindNodeByID(&g, node_id);
call    0 never executed
    #####:19675:    if (node == NULL)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:19676:        return;
    %%%%%:19676-block 11
    #####:19677:    if (node->IsCentralNode() && node->ParentNode)
    %%%%%:19677-block 12
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:19677-block 14
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:19677-block 15
    %%%%%:19677-block 16
    %%%%%:19677-block 17
branch  5 never executed (fallthrough)
branch  6 never executed
    #####:19678:        node->ParentNode->SetLocalFlags(node->ParentNode->LocalFlags | ImGuiDockNodeFlags_CentralNode);
    %%%%%:19678-block 18
call    0 never executed
    #####:19679:    DockContextRemoveNode(&g, node, true);
    %%%%%:19679-block 19
call    0 never executed
        -:19680:}
        -:19681:
        -:19682:// root_id = 0 to remove all, root_id != 0 to remove child of given node.
function _ZN5ImGui31DockBuilderRemoveNodeChildNodesEj called 1 returned 100% blocks executed 34%
        1:19683:void ImGui::DockBuilderRemoveNodeChildNodes(ImGuiID root_id)
        -:19684:{
        1:19685:    ImGuiContext& g = *GImGui;
        1:19686:    ImGuiDockContext* dc = &g.DockContext;
        -:19687:
       1*:19688:    ImGuiDockNode* root_node = root_id ? DockContextFindNodeByID(&g, root_id) : NULL;
        1:19688-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%:19688-block 3
call    2 never executed
        1:19688-block 4
       1*:19689:    if (root_id && root_node == NULL)
        1:19689-block 5
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%:19689-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:19690:        return;
    %%%%%:19690-block 7
        1:19691:    bool has_central_node = false;
        -:19692:
       1*:19693:    ImGuiDataAuthority backup_root_node_authority_for_pos = root_node ? root_node->AuthorityForPos : ImGuiDataAuthority_Auto;
        1:19693-block 8
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%:19693-block 9
        1:19693-block 10
       1*:19694:    ImGuiDataAuthority backup_root_node_authority_for_size = root_node ? root_node->AuthorityForSize : ImGuiDataAuthority_Auto;
        1:19694-block 11
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%:19694-block 12
        1:19694-block 13
        -:19695:
        -:19696:    // Process active windows
        1:19697:    ImVector<ImGuiDockNode*> nodes_to_remove;
        1:19697-block 14
call    0 returned 1
       1*:19698:    for (int n = 0; n < dc->Nodes.Data.Size; n++)
    %%%%%:19698-block 34
        1:19698-block 35
branch  0 taken 0
branch  1 taken 1 (fallthrough)
    #####:19699:        if (ImGuiDockNode* node = (ImGuiDockNode*)dc->Nodes.Data[n].val_p)
    %%%%%:19699-block 16
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -:19700:        {
    #####:19701:            bool want_removal = (root_id == 0) || (node->ID != root_id && DockNodeGetRootNode(node)->ID == root_id);
    %%%%%:19701-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19701-block 19
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:19701-block 20
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:19701-block 22
    %%%%%:19701-block 23
    #####:19702:            if (want_removal)
    %%%%%:19702-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
        -:19703:            {
    #####:19704:                if (node->IsCentralNode())
    %%%%%:19704-block 25
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:19705:                    has_central_node = true;
    %%%%%:19705-block 27
    #####:19706:                if (root_id != 0)
    %%%%%:19706-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:19707:                    DockContextQueueNotifyRemovedNode(&g, node);
    %%%%%:19707-block 29
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:19708:                if (root_node)
    %%%%%:19708-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
        -:19709:                {
    #####:19710:                    DockNodeMoveWindows(root_node, node);
    %%%%%:19710-block 31
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:19711:                    DockSettingsRenameNodeReferences(node->ID, root_node->ID);
    %%%%%:19711-block 32
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:19712:                }
    #####:19713:                nodes_to_remove.push_back(node);
    %%%%%:19713-block 33
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:19714:            }
        -:19715:        }
        -:19716:
        -:19717:    // DockNodeMoveWindows->DockNodeAddWindow will normally set those when reaching two windows (which is only adequate during interactive merge)
        -:19718:    // Make sure we don't lose our current pos/size. (FIXME-DOCK: Consider tidying up that code in DockNodeAddWindow instead)
        1:19719:    if (root_node)
        1:19719-block 36
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:19720:    {
    #####:19721:        root_node->AuthorityForPos = backup_root_node_authority_for_pos;
    #####:19722:        root_node->AuthorityForSize = backup_root_node_authority_for_size;
    %%%%%:19722-block 37
        -:19723:    }
        -:19724:
        -:19725:    // Apply to settings
       1*:19726:    for (ImGuiWindowSettings* settings = g.SettingsWindows.begin(); settings != NULL; settings = g.SettingsWindows.next_chunk(settings))
        1:19726-block 38
call    0 returned 1
    %%%%%:19726-block 47
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:19726-block 48
        1:19726-block 49
branch  4 taken 0
branch  5 taken 1 (fallthrough)
    #####:19727:        if (ImGuiID window_settings_dock_id = settings->DockId)
    %%%%%:19727-block 39
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:19728:            for (int n = 0; n < nodes_to_remove.Size; n++)
    %%%%%:19728-block 40
    %%%%%:19728-block 44
    %%%%%:19728-block 45
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:19729:                if (nodes_to_remove[n]->ID == window_settings_dock_id)
    %%%%%:19729-block 41
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -:19730:                {
    #####:19731:                    settings->DockId = root_id;
    #####:19732:                    break;
    %%%%%:19732-block 43
        -:19733:                }
        -:19734:
        -:19735:    // Not really efficient, but easier to destroy a whole hierarchy considering DockContextRemoveNode is attempting to merge nodes
        1:19736:    if (nodes_to_remove.Size > 1)
        1:19736-block 50
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:19737:        ImQsort(nodes_to_remove.Data, nodes_to_remove.Size, sizeof(ImGuiDockNode*), DockNodeComparerDepthMostFirst);
    %%%%%:19737-block 51
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
       1*:19738:    for (int n = 0; n < nodes_to_remove.Size; n++)
        1:19738-block 52
    %%%%%:19738-block 55
        1:19738-block 56
branch  0 taken 0
branch  1 taken 1 (fallthrough)
    #####:19739:        DockContextRemoveNode(&g, nodes_to_remove[n], false);
    %%%%%:19739-block 53
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
        -:19740:
        1:19741:    if (root_id == 0)
        1:19741-block 57
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -:19742:    {
        1:19743:        dc->Nodes.Clear();
        1:19743-block 58
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:19744:        dc->Requests.clear();
        1:19744-block 59
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:19745:    }
    #####:19746:    else if (has_central_node)
    %%%%%:19746-block 60
branch  0 never executed (fallthrough)
branch  1 never executed
        -:19747:    {
    #####:19748:        root_node->CentralNode = root_node;
    #####:19749:        root_node->SetLocalFlags(root_node->LocalFlags | ImGuiDockNodeFlags_CentralNode);
    %%%%%:19749-block 61
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:19750:    }
        1:19751:}
        1:19751-block 62
call    0 returned 1
    $$$$$:19751-block 66
call    1 never executed
        -:19752:
function _ZN5ImGui34DockBuilderRemoveNodeDockedWindowsEjb called 1 returned 100% blocks executed 17%
        1:19753:void ImGui::DockBuilderRemoveNodeDockedWindows(ImGuiID root_id, bool clear_settings_refs)
        -:19754:{
        -:19755:    // Clear references in settings
        1:19756:    ImGuiContext& g = *GImGui;
        1:19757:    if (clear_settings_refs)
        1:19757-block 2
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -:19758:    {
       1*:19759:        for (ImGuiWindowSettings* settings = g.SettingsWindows.begin(); settings != NULL; settings = g.SettingsWindows.next_chunk(settings))
        1:19759-block 3
call    0 returned 1
    %%%%%:19759-block 17
call    1 never executed
        1:19759-block 19
branch  2 taken 0
branch  3 taken 1 (fallthrough)
        -:19760:        {
    #####:19761:            bool want_removal = (root_id == 0) || (settings->DockId == root_id);
    %%%%%:19761-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19761-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:19761-block 6
    %%%%%:19761-block 7
    #####:19762:            if (!want_removal && settings->DockId != 0)
    %%%%%:19762-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19762-block 9
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:19763:                if (ImGuiDockNode* node = DockContextFindNodeByID(&g, settings->DockId))
    %%%%%:19763-block 10
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:19764:                    if (DockNodeGetRootNode(node)->ID == root_id)
    %%%%%:19764-block 12
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:19765:                        want_removal = true;
    %%%%%:19765-block 14
    #####:19766:            if (want_removal)
    %%%%%:19766-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:19767:                settings->DockId = 0;
    %%%%%:19767-block 16
        -:19768:        }
        -:19769:    }
        -:19770:
        -:19771:    // Clear references in windows
       1*:19772:    for (int n = 0; n < g.Windows.Size; n++)
        1:19772-block 20
    %%%%%:19772-block 35
        1:19772-block 36
branch  0 taken 0
branch  1 taken 1 (fallthrough)
        -:19773:    {
    #####:19774:        ImGuiWindow* window = g.Windows[n];
    %%%%%:19774-block 21
call    0 never executed
    #####:19775:        bool want_removal = (root_id == 0) || (window->DockNode && DockNodeGetRootNode(window->DockNode)->ID == root_id) || (window->DockNodeAsHost && window->DockNodeAsHost->ID == root_id);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19775-block 23
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:19775-block 24
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:19775-block 26
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%:19775-block 27
branch  9 never executed (fallthrough)
branch 10 never executed
    %%%%%:19775-block 28
    %%%%%:19775-block 29
    #####:19776:        if (want_removal)
    %%%%%:19776-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
        -:19777:        {
    #####:19778:            const ImGuiID backup_dock_id = window->DockId;
        -:19779:            IM_UNUSED(backup_dock_id);
    #####:19780:            DockContextProcessUndockWindow(&g, window, clear_settings_refs);
    %%%%%:19780-block 31
call    0 never executed
    #####:19781:            if (!clear_settings_refs)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:19782:                IM_ASSERT(window->DockId == backup_dock_id);
    %%%%%:19782-block 33
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19782-block 34
call    2 never executed
        -:19783:        }
        -:19784:    }
        1:19785:}
        -:19786:
        -:19787:// If 'out_id_at_dir' or 'out_id_at_opposite_dir' are non NULL, the function will write out the ID of the two new nodes created.
        -:19788:// Return value is ID of the node at the specified direction, so same as (*out_id_at_dir) if that pointer is set.
        -:19789:// FIXME-DOCK: We are not exposing nor using split_outer.
function _ZN5ImGui20DockBuilderSplitNodeEj8ImGuiDirfPjS1_ called 0 returned 0% blocks executed 0%
    #####:19790:ImGuiID ImGui::DockBuilderSplitNode(ImGuiID id, ImGuiDir split_dir, float size_ratio_for_node_at_dir, ImGuiID* out_id_at_dir, ImGuiID* out_id_at_opposite_dir)
        -:19791:{
    #####:19792:    ImGuiContext& g = *GImGui;
    #####:19793:    IM_ASSERT(split_dir != ImGuiDir_None);
    %%%%%:19793-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19793-block 3
call    2 never executed
    #####:19794:    IMGUI_DEBUG_LOG_DOCKING("[docking] DockBuilderSplitNode: node 0x%08X, split_dir %d\n", id, split_dir);
    %%%%%:19794-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19794-block 5
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
        -:19795:
    #####:19796:    ImGuiDockNode* node = DockContextFindNodeByID(&g, id);
    %%%%%:19796-block 6
call    0 never executed
    #####:19797:    if (node == NULL)
branch  0 never executed (fallthrough)
branch  1 never executed
        -:19798:    {
    #####:19799:        IM_ASSERT(node != NULL);
    %%%%%:19799-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19799-block 9
call    2 never executed
    #####:19800:        return 0;
    %%%%%:19800-block 10
        -:19801:    }
        -:19802:
    #####:19803:    IM_ASSERT(!node->IsSplitNode()); // Assert if already Split
    %%%%%:19803-block 11
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:19803-block 13
call    3 never executed
        -:19804:
    #####:19805:    ImGuiDockRequest req;
    %%%%%:19805-block 14
call    0 never executed
    #####:19806:    req.Type = ImGuiDockRequestType_Split;
    #####:19807:    req.DockTargetWindow = NULL;
    #####:19808:    req.DockTargetNode = node;
    #####:19809:    req.DockPayload = NULL;
    #####:19810:    req.DockSplitDir = split_dir;
    #####:19811:    req.DockSplitRatio = ImSaturate((split_dir == ImGuiDir_Left || split_dir == ImGuiDir_Up) ? size_ratio_for_node_at_dir : 1.0f - size_ratio_for_node_at_dir);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19811-block 16
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:19811-block 17
    %%%%%:19811-block 18
    %%%%%:19811-block 19
call    4 never executed
    #####:19812:    req.DockSplitOuter = false;
    #####:19813:    DockContextProcessDock(&g, &req);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:19814:
    #####:19815:    ImGuiID id_at_dir = node->ChildNodes[(split_dir == ImGuiDir_Left || split_dir == ImGuiDir_Up) ? 0 : 1]->ID;
    %%%%%:19815-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19815-block 22
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:19815-block 23
    %%%%%:19815-block 24
    #####:19816:    ImGuiID id_at_opposite_dir = node->ChildNodes[(split_dir == ImGuiDir_Left || split_dir == ImGuiDir_Up) ? 1 : 0]->ID;
    %%%%%:19816-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19816-block 26
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:19816-block 27
    %%%%%:19816-block 28
    #####:19817:    if (out_id_at_dir)
    %%%%%:19817-block 29
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:19818:        *out_id_at_dir = id_at_dir;
    %%%%%:19818-block 30
    #####:19819:    if (out_id_at_opposite_dir)
    %%%%%:19819-block 31
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:19820:        *out_id_at_opposite_dir = id_at_opposite_dir;
    %%%%%:19820-block 32
    #####:19821:    return id_at_dir;
    %%%%%:19821-block 33
        -:19822:}
        -:19823:
function _ZL22DockBuilderCopyNodeRecP13ImGuiDockNodejP8ImVectorIjE called 0 returned 0% blocks executed 0%
    #####:19824:static ImGuiDockNode* DockBuilderCopyNodeRec(ImGuiDockNode* src_node, ImGuiID dst_node_id_if_known, ImVector<ImGuiID>* out_node_remap_pairs)
        -:19825:{
    #####:19826:    ImGuiContext& g = *GImGui;
    #####:19827:    ImGuiDockNode* dst_node = ImGui::DockContextAddNode(&g, dst_node_id_if_known);
    %%%%%:19827-block 2
call    0 never executed
    #####:19828:    dst_node->SharedFlags = src_node->SharedFlags;
    #####:19829:    dst_node->LocalFlags = src_node->LocalFlags;
    #####:19830:    dst_node->LocalFlagsInWindows = ImGuiDockNodeFlags_None;
    #####:19831:    dst_node->Pos = src_node->Pos;
    #####:19832:    dst_node->Size = src_node->Size;
    #####:19833:    dst_node->SizeRef = src_node->SizeRef;
    #####:19834:    dst_node->SplitAxis = src_node->SplitAxis;
    #####:19835:    dst_node->UpdateMergedFlags();
call    0 never executed
        -:19836:
    #####:19837:    out_node_remap_pairs->push_back(src_node->ID);
call    0 never executed
    #####:19838:    out_node_remap_pairs->push_back(dst_node->ID);
call    0 never executed
        -:19839:
    #####:19840:    for (int child_n = 0; child_n < IM_ARRAYSIZE(src_node->ChildNodes); child_n++)
    %%%%%:19840-block 10
    %%%%%:19840-block 11
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:19841:        if (src_node->ChildNodes[child_n])
    %%%%%:19841-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
        -:19842:        {
    #####:19843:            dst_node->ChildNodes[child_n] = DockBuilderCopyNodeRec(src_node->ChildNodes[child_n], 0, out_node_remap_pairs);
    %%%%%:19843-block 8
call    0 never executed
    #####:19844:            dst_node->ChildNodes[child_n]->ParentNode = dst_node;
        -:19845:        }
        -:19846:
    #####:19847:    IMGUI_DEBUG_LOG_DOCKING("[docking] Fork node %08X -> %08X (%d childs)\n", src_node->ID, dst_node->ID, dst_node->IsSplitNode() ? 2 : 0);
    %%%%%:19847-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19847-block 13
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:19847-block 15
    %%%%%:19847-block 16
    %%%%%:19847-block 17
call    5 never executed
    #####:19848:    return dst_node;
    %%%%%:19848-block 18
        -:19849:}
        -:19850:
function _ZN5ImGui19DockBuilderCopyNodeEjjP8ImVectorIjE called 0 returned 0% blocks executed 0%
    #####:19851:void ImGui::DockBuilderCopyNode(ImGuiID src_node_id, ImGuiID dst_node_id, ImVector<ImGuiID>* out_node_remap_pairs)
        -:19852:{
    #####:19853:    ImGuiContext& g = *GImGui;
    #####:19854:    IM_ASSERT(src_node_id != 0);
    %%%%%:19854-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19854-block 3
call    2 never executed
    #####:19855:    IM_ASSERT(dst_node_id != 0);
    %%%%%:19855-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19855-block 5
call    2 never executed
    #####:19856:    IM_ASSERT(out_node_remap_pairs != NULL);
    %%%%%:19856-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19856-block 7
call    2 never executed
        -:19857:
    #####:19858:    DockBuilderRemoveNode(dst_node_id);
    %%%%%:19858-block 8
call    0 never executed
        -:19859:
    #####:19860:    ImGuiDockNode* src_node = DockContextFindNodeByID(&g, src_node_id);
call    0 never executed
    #####:19861:    IM_ASSERT(src_node != NULL);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19861-block 11
call    2 never executed
        -:19862:
    #####:19863:    out_node_remap_pairs->clear();
    %%%%%:19863-block 12
call    0 never executed
    #####:19864:    DockBuilderCopyNodeRec(src_node, dst_node_id, out_node_remap_pairs);
call    0 never executed
        -:19865:
    #####:19866:    IM_ASSERT((out_node_remap_pairs->Size % 2) == 0);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19866-block 15
call    2 never executed
    #####:19867:}
        -:19868:
function _ZN5ImGui29DockBuilderCopyWindowSettingsEPKcS1_ called 0 returned 0% blocks executed 0%
    #####:19869:void ImGui::DockBuilderCopyWindowSettings(const char* src_name, const char* dst_name)
        -:19870:{
    #####:19871:    ImGuiWindow* src_window = FindWindowByName(src_name);
    %%%%%:19871-block 2
call    0 never executed
    #####:19872:    if (src_window == NULL)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:19873:        return;
    %%%%%:19873-block 4
    #####:19874:    if (ImGuiWindow* dst_window = FindWindowByName(dst_name))
    %%%%%:19874-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -:19875:    {
    #####:19876:        dst_window->Pos = src_window->Pos;
    #####:19877:        dst_window->Size = src_window->Size;
    #####:19878:        dst_window->SizeFull = src_window->SizeFull;
    #####:19879:        dst_window->Collapsed = src_window->Collapsed;
    %%%%%:19879-block 7
        -:19880:    }
        -:19881:    else
        -:19882:    {
    #####:19883:        ImGuiWindowSettings* dst_settings = FindWindowSettingsByID(ImHashStr(dst_name));
    %%%%%:19883-block 8
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####:19884:        if (!dst_settings)
    %%%%%:19884-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:19885:            dst_settings = CreateNewWindowSettings(dst_name);
    %%%%%:19885-block 11
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:19885-block 12
    #####:19886:        ImVec2ih window_pos_2ih = ImVec2ih(src_window->Pos);
    %%%%%:19886-block 13
call    0 never executed
    #####:19887:        if (src_window->ViewportId != 0 && src_window->ViewportId != IMGUI_VIEWPORT_DEFAULT_ID)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19887-block 15
branch  2 never executed (fallthrough)
branch  3 never executed
        -:19888:        {
    #####:19889:            dst_settings->ViewportPos = window_pos_2ih;
    #####:19890:            dst_settings->ViewportId = src_window->ViewportId;
    #####:19891:            dst_settings->Pos = ImVec2ih(0, 0);
    %%%%%:19891-block 16
call    0 never executed
        -:19892:        }
        -:19893:        else
        -:19894:        {
    #####:19895:            dst_settings->Pos = window_pos_2ih;
    %%%%%:19895-block 18
        -:19896:        }
    #####:19897:        dst_settings->Size = ImVec2ih(src_window->SizeFull);
    %%%%%:19897-block 19
call    0 never executed
    #####:19898:        dst_settings->Collapsed = src_window->Collapsed;
        -:19899:    }
        -:19900:}
        -:19901:
        -:19902:// FIXME: Will probably want to change this signature, in particular how the window remapping pairs are passed.
function _ZN5ImGui24DockBuilderCopyDockSpaceEjjP8ImVectorIPKcE called 0 returned 0% blocks executed 0%
    #####:19903:void ImGui::DockBuilderCopyDockSpace(ImGuiID src_dockspace_id, ImGuiID dst_dockspace_id, ImVector<const char*>* in_window_remap_pairs)
        -:19904:{
    #####:19905:    ImGuiContext& g = *GImGui;
    #####:19906:    IM_ASSERT(src_dockspace_id != 0);
    %%%%%:19906-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19906-block 3
call    2 never executed
    #####:19907:    IM_ASSERT(dst_dockspace_id != 0);
    %%%%%:19907-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19907-block 5
call    2 never executed
    #####:19908:    IM_ASSERT(in_window_remap_pairs != NULL);
    %%%%%:19908-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19908-block 7
call    2 never executed
    #####:19909:    IM_ASSERT((in_window_remap_pairs->Size % 2) == 0);
    %%%%%:19909-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19909-block 9
call    2 never executed
        -:19910:
        -:19911:    // Duplicate entire dock
        -:19912:    // FIXME: When overwriting dst_dockspace_id, windows that aren't part of our dockspace window class but that are docked in a same node will be split apart,
        -:19913:    // whereas we could attempt to at least keep them together in a new, same floating node.
    #####:19914:    ImVector<ImGuiID> node_remap_pairs;
    %%%%%:19914-block 10
call    0 never executed
    #####:19915:    DockBuilderCopyNode(src_dockspace_id, dst_dockspace_id, &node_remap_pairs);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:19916:
        -:19917:    // Attempt to transition all the upcoming windows associated to dst_dockspace_id into the newly created hierarchy of dock nodes
        -:19918:    // (The windows associated to src_dockspace_id are staying in place)
    #####:19919:    ImVector<ImGuiID> src_windows;
    %%%%%:19919-block 12
call    0 never executed
    #####:19920:    for (int remap_window_n = 0; remap_window_n < in_window_remap_pairs->Size; remap_window_n += 2)
    %%%%%:19920-block 38
    %%%%%:19920-block 39
branch  0 never executed
branch  1 never executed (fallthrough)
        -:19921:    {
    #####:19922:        const char* src_window_name = (*in_window_remap_pairs)[remap_window_n];
    %%%%%:19922-block 14
call    0 never executed
    #####:19923:        const char* dst_window_name = (*in_window_remap_pairs)[remap_window_n + 1];
call    0 never executed
    #####:19924:        ImGuiID src_window_id = ImHashStr(src_window_name);
call    0 never executed
    #####:19925:        src_windows.push_back(src_window_id);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:19926:
        -:19927:        // Search in the remapping tables
    #####:19928:        ImGuiID src_dock_id = 0;
    #####:19929:        if (ImGuiWindow* src_window = FindWindowByID(src_window_id))
    %%%%%:19929-block 18
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:19930:            src_dock_id = src_window->DockId;
    %%%%%:19930-block 20
    #####:19931:        else if (ImGuiWindowSettings* src_window_settings = FindWindowSettingsByID(src_window_id))
    %%%%%:19931-block 21
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:19931-block 22
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:19932:            src_dock_id = src_window_settings->DockId;
    %%%%%:19932-block 23
    #####:19933:        ImGuiID dst_dock_id = 0;
    #####:19934:        for (int dock_remap_n = 0; dock_remap_n < node_remap_pairs.Size; dock_remap_n += 2)
    %%%%%:19934-block 24
    %%%%%:19934-block 29
    %%%%%:19934-block 30
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:19935:            if (node_remap_pairs[dock_remap_n] == src_dock_id)
    %%%%%:19935-block 25
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -:19936:            {
    #####:19937:                dst_dock_id = node_remap_pairs[dock_remap_n + 1];
    %%%%%:19937-block 27
call    0 never executed
        -:19938:                //node_remap_pairs[dock_remap_n] = node_remap_pairs[dock_remap_n + 1] = 0; // Clear
    #####:19939:                break;
        -:19940:            }
        -:19941:
    #####:19942:        if (dst_dock_id != 0)
    %%%%%:19942-block 31
branch  0 never executed (fallthrough)
branch  1 never executed
        -:19943:        {
        -:19944:            // Docked windows gets redocked into the new node hierarchy.
    #####:19945:            IMGUI_DEBUG_LOG_DOCKING("[docking] Remap live window '%s' 0x%08X -> '%s' 0x%08X\n", src_window_name, src_dock_id, dst_window_name, dst_dock_id);
    %%%%%:19945-block 32
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19945-block 33
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####:19946:            DockBuilderDockWindow(dst_window_name, dst_dock_id);
    %%%%%:19946-block 34
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:19947:        }
        -:19948:        else
        -:19949:        {
        -:19950:            // Floating windows gets their settings transferred (regardless of whether the new window already exist or not)
        -:19951:            // When this is leading to a Copy and not a Move, we would get two overlapping floating windows. Could we possibly dock them together?
    #####:19952:            IMGUI_DEBUG_LOG_DOCKING("[docking] Remap window settings '%s' -> '%s'\n", src_window_name, dst_window_name);
    %%%%%:19952-block 35
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19952-block 36
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####:19953:            DockBuilderCopyWindowSettings(src_window_name, dst_window_name);
    %%%%%:19953-block 37
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:19954:        }
        -:19955:    }
        -:19956:
        -:19957:    // Anything else in the source nodes of 'node_remap_pairs' are windows that are not included in the remapping list.
        -:19958:    // Find those windows and move to them to the cloned dock node. This may be optional?
        -:19959:    // Dock those are a second step as undocking would invalidate source dock nodes.
function _ZZN5ImGui24DockBuilderCopyDockSpaceEjjP8ImVectorIPKcEEN23DockRemainingWindowTaskC2EP11ImGuiWindowj called 0 returned 0% blocks executed 0%
    #####:19960:    struct DockRemainingWindowTask { ImGuiWindow* Window; ImGuiID DockId; DockRemainingWindowTask(ImGuiWindow* window, ImGuiID dock_id) { Window = window; DockId = dock_id; } };
    #####:19961:    ImVector<DockRemainingWindowTask> dock_remaining_windows;
    %%%%%:19961-block 40
call    0 never executed
    #####:19962:    for (int dock_remap_n = 0; dock_remap_n < node_remap_pairs.Size; dock_remap_n += 2)
    %%%%%:19962-block 58
    %%%%%:19962-block 59
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:19963:        if (ImGuiID src_dock_id = node_remap_pairs[dock_remap_n])
    %%%%%:19963-block 42
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -:19964:        {
    #####:19965:            ImGuiID dst_dock_id = node_remap_pairs[dock_remap_n + 1];
    %%%%%:19965-block 44
call    0 never executed
    #####:19966:            ImGuiDockNode* node = DockBuilderGetNode(src_dock_id);
call    0 never executed
    #####:19967:            for (int window_n = 0; window_n < node->Windows.Size; window_n++)
    %%%%%:19967-block 56
    %%%%%:19967-block 57
branch  0 never executed
branch  1 never executed (fallthrough)
        -:19968:            {
    #####:19969:                ImGuiWindow* window = node->Windows[window_n];
    %%%%%:19969-block 47
call    0 never executed
    #####:19970:                if (src_windows.contains(window->ID))
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:19971:                    continue;
    %%%%%:19971-block 50
        -:19972:
        -:19973:                // Docked windows gets redocked into the new node hierarchy.
    #####:19974:                IMGUI_DEBUG_LOG_DOCKING("[docking] Remap window '%s' %08X -> %08X\n", window->Name, src_dock_id, dst_dock_id);
    %%%%%:19974-block 51
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:19974-block 52
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####:19975:                dock_remaining_windows.push_back(DockRemainingWindowTask(window, dst_dock_id));
    %%%%%:19975-block 53
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:19975-block 55
    $$$$$:19975-block 70
        -:19976:            }
        -:19977:        }
    #####:19978:    for (const DockRemainingWindowTask& task : dock_remaining_windows)
    %%%%%:19978-block 60
call    0 never executed
call    1 never executed
    %%%%%:19978-block 63
    %%%%%:19978-block 64
branch  2 never executed
branch  3 never executed (fallthrough)
    #####:19979:        DockBuilderDockWindow(task.Window->Name, task.DockId);
    %%%%%:19979-block 62
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:19980:}
    %%%%%:19980-block 65
call    0 never executed
call    1 never executed
call    2 never executed
    $$$$$:19980-block 71
call    3 never executed
    $$$$$:19980-block 73
call    4 never executed
    $$$$$:19980-block 75
call    5 never executed
        -:19981:
        -:19982:// FIXME-DOCK: This is awkward because in series of split user is likely to loose access to its root node.
function _ZN5ImGui17DockBuilderFinishEj called 0 returned 0% blocks executed 0%
    #####:19983:void ImGui::DockBuilderFinish(ImGuiID root_id)
        -:19984:{
    #####:19985:    ImGuiContext& g = *GImGui;
        -:19986:    //DockContextRebuild(&g);
    #####:19987:    DockContextBuildAddWindowsToNodes(&g, root_id);
    %%%%%:19987-block 2
call    0 never executed
    #####:19988:}
        -:19989:
        -:19990://-----------------------------------------------------------------------------
        -:19991:// Docking: Begin/End Support Functions (called from Begin/End)
        -:19992://-----------------------------------------------------------------------------
        -:19993:// - GetWindowAlwaysWantOwnTabBar()
        -:19994:// - DockContextBindNodeToWindow()
        -:19995:// - BeginDocked()
        -:19996:// - BeginDockableDragDropSource()
        -:19997:// - BeginDockableDragDropTarget()
        -:19998://-----------------------------------------------------------------------------
        -:19999:
function _ZN5ImGui28GetWindowAlwaysWantOwnTabBarEP11ImGuiWindow called 16368 returned 100% blocks executed 100%
    16368:20000:bool ImGui::GetWindowAlwaysWantOwnTabBar(ImGuiWindow* window)
        -:20001:{
    16368:20002:    ImGuiContext& g = *GImGui;
    16368:20003:    if (g.IO.ConfigDockingAlwaysTabBar || window->WindowClass.DockingAlwaysTabBar)
    16368:20003-block 2
branch  0 taken 1 (fallthrough)
branch  1 taken 16367
        1:20003-block 3
branch  2 taken 0 (fallthrough)
branch  3 taken 1
    16367:20004:        if ((window->Flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoDocking)) == 0)
    16367:20004-block 4
branch  0 taken 6461 (fallthrough)
branch  1 taken 9906
     6461:20005:            if (!window->IsFallbackWindow)    // We don't support AlwaysTabBar on the fallback/implicit window to avoid unused dock-node overhead/noise
     6461:20005-block 5
branch  0 taken 5385 (fallthrough)
branch  1 taken 1076
     5385:20006:                return true;
     5385:20006-block 6
    10983:20007:    return false;
    10983:20007-block 7
        -:20008:}
        -:20009:
function _ZN5ImGuiL27DockContextBindNodeToWindowEP12ImGuiContextP11ImGuiWindow called 5 returned 100% blocks executed 74%
        5:20010:static ImGuiDockNode* ImGui::DockContextBindNodeToWindow(ImGuiContext* ctx, ImGuiWindow* window)
        -:20011:{
        5:20012:    ImGuiContext& g = *ctx;
        5:20013:    ImGuiDockNode* node = DockContextFindNodeByID(ctx, window->DockId);
        5:20013-block 2
call    0 returned 5
       5*:20014:    IM_ASSERT(window->DockNode == NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    %%%%%:20014-block 4
call    2 never executed
        -:20015:
        -:20016:    // We should not be docking into a split node (SetWindowDock should avoid this)
       5*:20017:    if (node && node->IsSplitNode())
        5:20017-block 5
branch  0 taken 5 (fallthrough)
branch  1 taken 0
        5:20017-block 6
call    2 returned 5
branch  3 taken 0 (fallthrough)
branch  4 taken 5
    %%%%%:20017-block 8
        5:20017-block 9
        5:20017-block 10
branch  5 taken 0 (fallthrough)
branch  6 taken 5
        -:20018:    {
    #####:20019:        DockContextProcessUndockWindow(ctx, window);
    %%%%%:20019-block 11
call    0 never executed
    #####:20020:        return NULL;
        -:20021:    }
        -:20022:
        -:20023:    // Create node
        5:20024:    if (node == NULL)
        5:20024-block 13
branch  0 taken 0 (fallthrough)
branch  1 taken 5
        -:20025:    {
    #####:20026:        node = DockContextAddNode(ctx, window->DockId);
    %%%%%:20026-block 14
call    0 never executed
    #####:20027:        node->AuthorityForPos = node->AuthorityForSize = node->AuthorityForViewport = ImGuiDataAuthority_Window;
    #####:20028:        node->LastFrameAlive = g.FrameCount;
        -:20029:    }
        -:20030:
        -:20031:    // If the node just turned visible and is part of a hierarchy, it doesn't have a Size assigned by DockNodeTreeUpdatePosSize() yet,
        -:20032:    // so we're forcing a Pos/Size update from the first ancestor that is already visible (often it will be the root node).
        -:20033:    // If we don't do this, the window will be assigned a zero-size on its first frame, which won't ideally warm up the layout.
        -:20034:    // This is a little wonky because we don't normally update the Pos/Size of visible node mid-frame.
        5:20035:    if (!node->IsVisible)
        5:20035-block 16
branch  0 taken 4 (fallthrough)
branch  1 taken 1
        -:20036:    {
        4:20037:        ImGuiDockNode* ancestor_node = node;
       10:20038:        while (!ancestor_node->IsVisible && ancestor_node->ParentNode)
        4:20038-block 17
       10:20038-block 19
branch  0 taken 6 (fallthrough)
branch  1 taken 4
        6:20038-block 20
branch  2 taken 6
branch  3 taken 0 (fallthrough)
        6:20039:            ancestor_node = ancestor_node->ParentNode;
        6:20039-block 18
       4*:20040:        IM_ASSERT(ancestor_node->Size.x > 0.0f && ancestor_node->Size.y > 0.0f);
        4:20040-block 21
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4:20040-block 22
branch  2 taken 4 (fallthrough)
branch  3 taken 0
        4:20040-block 23
    %%%%%:20040-block 24
call    4 never executed
        4:20041:        DockNodeUpdateHasCentralNodeChild(DockNodeGetRootNode(ancestor_node));
        4:20041-block 25
call    0 returned 4
call    1 returned 4
        4:20042:        DockNodeTreeUpdatePosSize(ancestor_node, ancestor_node->Pos, ancestor_node->Size, node);
call    0 returned 4
        -:20043:    }
        -:20044:
        -:20045:    // Add window to node
        5:20046:    bool node_was_visible = node->IsVisible;
        5:20047:    DockNodeAddWindow(node, window, true);
        5:20047-block 28
call    0 returned 5
        5:20048:    node->IsVisible = node_was_visible; // Don't mark visible right away (so DockContextEndFrame() doesn't render it, maybe other side effects? will see)
       5*:20049:    IM_ASSERT(node == window->DockNode);
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    %%%%%:20049-block 30
call    2 never executed
        5:20050:    return node;
        5:20050-block 31
        -:20051:}
        -:20052:
function _ZL23StoreDockStyleForWindowP11ImGuiWindow called 5385 returned 100% blocks executed 100%
     5385:20053:static void StoreDockStyleForWindow(ImGuiWindow* window)
        -:20054:{
     5385:20055:    ImGuiContext& g = *GImGui;
    48465:20056:    for (int color_n = 0; color_n < ImGuiWindowDockStyleCol_COUNT; color_n++)
     5385:20056-block 2
    48465:20056-block 5
branch  0 taken 43080
branch  1 taken 5385 (fallthrough)
    43080:20057:        window->DockStyle.Colors[color_n] = ImGui::ColorConvertFloat4ToU32(g.Style.Colors[GWindowDockStyleColors[color_n]]);
    43080:20057-block 3
call    0 returned 43080
     5385:20058:}
        -:20059:
function _ZN5ImGui11BeginDockedEP11ImGuiWindowPb called 5385 returned 100% blocks executed 54%
     5385:20060:void ImGui::BeginDocked(ImGuiWindow* window, bool* p_open)
        -:20061:{
     5385:20062:    ImGuiContext& g = *GImGui;
        -:20063:
        -:20064:    // Clear fields ahead so most early-out paths don't have to do it
     5385:20065:    window->DockIsActive = window->DockNodeIsVisible = window->DockTabIsVisible = false;
        -:20066:
     5385:20067:    const bool auto_dock_node = GetWindowAlwaysWantOwnTabBar(window);
     5385:20067-block 2
call    0 returned 5385
     5385:20068:    if (auto_dock_node)
branch  0 taken 5385 (fallthrough)
branch  1 taken 0
        -:20069:    {
     5385:20070:        if (window->DockId == 0)
     5385:20070-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 5385
        -:20071:        {
    #####:20072:            IM_ASSERT(window->DockNode == NULL);
    %%%%%:20072-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:20072-block 6
call    2 never executed
    #####:20073:            window->DockId = DockContextGenNodeID(&g);
    %%%%%:20073-block 7
call    0 never executed
        -:20074:        }
        -:20075:    }
        -:20076:    else
        -:20077:    {
        -:20078:        // Calling SetNextWindowPos() undock windows by default (by setting PosUndock)
    #####:20079:        bool want_undock = false;
    #####:20080:        want_undock |= (window->Flags & ImGuiWindowFlags_NoDocking) != 0;
    #####:20081:        want_undock |= (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasPos) && (window->SetWindowPosAllowFlags & g.NextWindowData.PosCond) && g.NextWindowData.PosUndock;
    %%%%%:20081-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:20081-block 10
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:20081-block 11
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:20081-block 12
    %%%%%:20081-block 13
    #####:20082:        if (want_undock)
    %%%%%:20082-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
        -:20083:        {
    #####:20084:            DockContextProcessUndockWindow(&g, window);
    %%%%%:20084-block 15
call    0 never executed
    #####:20085:            return;
        -:20086:        }
        -:20087:    }
        -:20088:
        -:20089:    // Bind to our dock node
     5385:20090:    ImGuiDockNode* node = window->DockNode;
     5385:20091:    if (node != NULL)
     5385:20091-block 17
branch  0 taken 5380 (fallthrough)
branch  1 taken 5
    5380*:20092:        IM_ASSERT(window->DockId == node->ID);
     5380:20092-block 18
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    %%%%%:20092-block 19
call    2 never executed
     5385:20093:    if (window->DockId != 0 && node == NULL)
     5385:20093-block 20
branch  0 taken 5385 (fallthrough)
branch  1 taken 0
     5385:20093-block 21
branch  2 taken 5 (fallthrough)
branch  3 taken 5380
        -:20094:    {
        5:20095:        node = DockContextBindNodeToWindow(&g, window);
        5:20095-block 22
call    0 returned 5
        5:20096:        if (node == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    #####:20097:            return;
    %%%%%:20097-block 24
        -:20098:    }
        -:20099:
        -:20100:#if 0
        -:20101:    // Undock if the ImGuiDockNodeFlags_NoDockingInCentralNode got set
        -:20102:    if (node->IsCentralNode && (node->Flags & ImGuiDockNodeFlags_NoDockingInCentralNode))
        -:20103:    {
        -:20104:        DockContextProcessUndockWindow(ctx, window);
        -:20105:        return;
        -:20106:    }
        -:20107:#endif
        -:20108:
        -:20109:    // Undock if our dockspace node disappeared
        -:20110:    // Note how we are testing for LastFrameAlive and NOT LastFrameActive. A DockSpace node can be maintained alive while being inactive with ImGuiDockNodeFlags_KeepAliveOnly.
     5385:20111:    if (node->LastFrameAlive < g.FrameCount)
     5385:20111-block 25
branch  0 taken 0 (fallthrough)
branch  1 taken 5385
        -:20112:    {
        -:20113:        // If the window has been orphaned, transition the docknode to an implicit node processed in DockContextNewFrameUpdateDocking()
    #####:20114:        ImGuiDockNode* root_node = DockNodeGetRootNode(node);
    %%%%%:20114-block 26
call    0 never executed
    #####:20115:        if (root_node->LastFrameAlive < g.FrameCount)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:20116:            DockContextProcessUndockWindow(&g, window);
    %%%%%:20116-block 28
call    0 never executed
        -:20117:        else
    #####:20118:            window->DockIsActive = true;
    %%%%%:20118-block 29
    #####:20119:        return;
    %%%%%:20119-block 30
        -:20120:    }
        -:20121:
        -:20122:    // Store style overrides
     5385:20123:    StoreDockStyleForWindow(window);
     5385:20123-block 31
call    0 returned 5385
        -:20124:
        -:20125:    // Fast path return. It is common for windows to hold on a persistent DockId but be the only visible window,
        -:20126:    // and never create neither a host window neither a tab bar.
        -:20127:    // FIXME-DOCK: replace ->HostWindow NULL compare with something more explicit (~was initially intended as a first frame test)
     5385:20128:    if (node->HostWindow == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 5385
        -:20129:    {
    #####:20130:        if (node->State == ImGuiDockNodeState_HostWindowHiddenBecauseWindowsAreResizing)
    %%%%%:20130-block 33
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:20131:            window->DockIsActive = true;
    %%%%%:20131-block 34
    #####:20132:        if (node->Windows.Size > 1 && window->Appearing) // Only hide appearing window
    %%%%%:20132-block 35
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:20132-block 36
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:20133:            DockNodeHideWindowDuringHostWindowCreation(window);
    %%%%%:20133-block 37
call    0 never executed
    #####:20134:        return;
    %%%%%:20134-block 38
        -:20135:    }
        -:20136:
        -:20137:    // We can have zero-sized nodes (e.g. children of a small-size dockspace)
    5385*:20138:    IM_ASSERT(node->HostWindow);
     5385:20138-block 39
branch  0 taken 0 (fallthrough)
branch  1 taken 5385
    %%%%%:20138-block 40
call    2 never executed
    5385*:20139:    IM_ASSERT(node->IsLeafNode());
     5385:20139-block 41
call    0 returned 5385
branch  1 taken 0 (fallthrough)
branch  2 taken 5385
    %%%%%:20139-block 43
call    3 never executed
    5385*:20140:    IM_ASSERT(node->Size.x >= 0.0f && node->Size.y >= 0.0f);
     5385:20140-block 44
branch  0 taken 5385 (fallthrough)
branch  1 taken 0
     5385:20140-block 45
branch  2 taken 5385 (fallthrough)
branch  3 taken 0
     5385:20140-block 46
    %%%%%:20140-block 47
call    4 never executed
     5385:20141:    node->State = ImGuiDockNodeState_HostWindowVisible;
        -:20142:
        -:20143:    // Undock if we are submitted earlier than the host window
     5385:20144:    if (!(node->MergedFlags & ImGuiDockNodeFlags_KeepAliveOnly) && window->BeginOrderWithinContext < node->HostWindow->BeginOrderWithinContext)
     5385:20144-block 48
branch  0 taken 5385 (fallthrough)
branch  1 taken 0
     5385:20144-block 49
branch  2 taken 0 (fallthrough)
branch  3 taken 5385
        -:20145:    {
    #####:20146:        DockContextProcessUndockWindow(&g, window);
    %%%%%:20146-block 50
call    0 never executed
    #####:20147:        return;
        -:20148:    }
        -:20149:
        -:20150:    // Position/Size window
     5385:20151:    SetNextWindowPos(node->Pos);
     5385:20151-block 52
call    0 returned 5385
call    1 returned 5385
     5385:20152:    SetNextWindowSize(node->Size);
call    0 returned 5385
     5385:20153:    g.NextWindowData.PosUndock = false; // Cancel implicit undocking of SetNextWindowPos()
     5385:20154:    window->DockIsActive = true;
     5385:20155:    window->DockNodeIsVisible = true;
     5385:20156:    window->DockTabIsVisible = false;
     5385:20157:    if (node->MergedFlags & ImGuiDockNodeFlags_KeepAliveOnly)
branch  0 taken 0 (fallthrough)
branch  1 taken 5385
    #####:20158:        return;
    %%%%%:20158-block 56
        -:20159:
        -:20160:    // When the window is selected we mark it as visible.
     5385:20161:    if (node->VisibleWindow == window)
     5385:20161-block 57
branch  0 taken 5380 (fallthrough)
branch  1 taken 5
     5380:20162:        window->DockTabIsVisible = true;
     5380:20162-block 58
        -:20163:
        -:20164:    // Update window flag
    5385*:20165:    IM_ASSERT((window->Flags & ImGuiWindowFlags_ChildWindow) == 0);
     5385:20165-block 59
branch  0 taken 0 (fallthrough)
branch  1 taken 5385
    %%%%%:20165-block 60
call    2 never executed
     5385:20166:    window->Flags |= ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_NoResize;
     5385:20167:    window->ChildFlags |= ImGuiChildFlags_AlwaysUseWindowPadding;
    5385*:20168:    if (node->IsHiddenTabBar() || node->IsNoTabBar())
     5385:20168-block 61
call    0 returned 5385
branch  1 taken 5385 (fallthrough)
branch  2 taken 0
     5385:20168-block 63
call    3 returned 5385
branch  4 taken 0 (fallthrough)
branch  5 taken 5385
    %%%%%:20168-block 65
     5385:20168-block 66
     5385:20168-block 67
branch  6 taken 0 (fallthrough)
branch  7 taken 5385
    #####:20169:        window->Flags |= ImGuiWindowFlags_NoTitleBar;
    %%%%%:20169-block 68
        -:20170:    else
     5385:20171:        window->Flags &= ~ImGuiWindowFlags_NoTitleBar;      // Clear the NoTitleBar flag in case the user set it: confusingly enough we need a title bar height so we are correctly offset, but it won't be displayed!
     5385:20171-block 69
        -:20172:
        -:20173:    // Save new dock order only if the window has been visible once already
        -:20174:    // This allows multiple windows to be created in the same frame and have their respective dock orders preserved.
     5385:20175:    if (node->TabBar && window->WasActive)
     5385:20175-block 70
branch  0 taken 5385 (fallthrough)
branch  1 taken 0
     5385:20175-block 71
branch  2 taken 5380 (fallthrough)
branch  3 taken 5
     5380:20176:        window->DockOrder = (short)DockNodeGetTabOrder(window);
     5380:20176-block 72
call    0 returned 5380
        -:20177:
    5385*:20178:    if ((node->WantCloseAll || node->WantCloseTabId == window->TabId) && p_open != NULL)
     5385:20178-block 74
branch  0 taken 5385 (fallthrough)
branch  1 taken 0
     5385:20178-block 75
branch  2 taken 0 (fallthrough)
branch  3 taken 5385
    %%%%%:20178-block 76
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:20179:        *p_open = false;
    %%%%%:20179-block 77
        -:20180:
        -:20181:    // Update ChildId to allow returning from Child to Parent with Escape
     5385:20182:    ImGuiWindow* parent_window = window->DockNode->HostWindow;
     5385:20183:    window->ChildId = parent_window->GetID(window->Name);
     5385:20183-block 78
call    0 returned 5385
        -:20184:}
        -:20185:
function _ZN5ImGui27BeginDockableDragDropSourceEP11ImGuiWindow called 0 returned 0% blocks executed 0%
    #####:20186:void ImGui::BeginDockableDragDropSource(ImGuiWindow* window)
        -:20187:{
    #####:20188:    ImGuiContext& g = *GImGui;
    #####:20189:    IM_ASSERT(g.ActiveId == window->MoveId);
    %%%%%:20189-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:20189-block 3
call    2 never executed
    #####:20190:    IM_ASSERT(g.MovingWindow == window);
    %%%%%:20190-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:20190-block 5
call    2 never executed
    #####:20191:    IM_ASSERT(g.CurrentWindow == window);
    %%%%%:20191-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:20191-block 7
call    2 never executed
        -:20192:
        -:20193:    // 0: Hold SHIFT to disable docking, 1: Hold SHIFT to enable docking.
    #####:20194:    if (g.IO.ConfigDockingWithShift != g.IO.KeyShift)
    %%%%%:20194-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
        -:20195:    {
        -:20196:        // When ConfigDockingWithShift is set, display a tooltip to increase UI affordance.
        -:20197:        // We cannot set for HoveredWindowUnderMovingWindow != NULL here, as it is only valid/useful when drag and drop is already active
        -:20198:        // (because of the 'is_mouse_dragging_with_an_expected_destination' logic in UpdateViewportsNewFrame() function)
    #####:20199:        IM_ASSERT(g.NextWindowData.Flags == 0);
    %%%%%:20199-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:20199-block 10
call    2 never executed
    #####:20200:        if (g.IO.ConfigDockingWithShift && g.MouseStationaryTimer >= 1.0f && g.ActiveId >= 1.0f)
    %%%%%:20200-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:20200-block 12
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:20200-block 13
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:20201:            SetTooltip("%s", LocalizeGetMsg(ImGuiLocKey_DockingHoldShiftToDock));
    %%%%%:20201-block 14
call    0 never executed
call    1 never executed
    #####:20202:        return;
    %%%%%:20202-block 16
        -:20203:    }
        -:20204:
    #####:20205:    g.LastItemData.ID = window->MoveId;
    #####:20206:    window = window->RootWindowDockTree;
    #####:20207:    IM_ASSERT((window->Flags & ImGuiWindowFlags_NoDocking) == 0);
    %%%%%:20207-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:20207-block 18
call    2 never executed
    #####:20208:    bool is_drag_docking = (g.IO.ConfigDockingWithShift) || ImRect(0, 0, window->SizeFull.x, GetFrameHeight()).Contains(g.ActiveIdClickOffset); // FIXME-DOCKING: Need to make this stateful and explicit
    %%%%%:20208-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:20208-block 20
call    2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:20208-block 24
    %%%%%:20208-block 25
    #####:20209:    ImGuiDragDropFlags drag_drop_flags = ImGuiDragDropFlags_SourceNoPreviewTooltip | ImGuiDragDropFlags_SourceNoHoldToOpenOthers | ImGuiDragDropFlags_PayloadAutoExpire | ImGuiDragDropFlags_PayloadNoCrossContext | ImGuiDragDropFlags_PayloadNoCrossProcess;
    #####:20210:    if (is_drag_docking && BeginDragDropSource(drag_drop_flags))
    %%%%%:20210-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:20210-block 27
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:20210-block 29
    %%%%%:20210-block 30
    %%%%%:20210-block 31
branch  5 never executed (fallthrough)
branch  6 never executed
        -:20211:    {
    #####:20212:        SetDragDropPayload(IMGUI_PAYLOAD_TYPE_WINDOW, &window, sizeof(window));
    %%%%%:20212-block 32
call    0 never executed
    #####:20213:        EndDragDropSource();
call    0 never executed
    #####:20214:        StoreDockStyleForWindow(window); // Store style overrides while dragging (even when not docked) because docking preview may need it.
call    0 never executed
        -:20215:    }
        -:20216:}
        -:20217:
function _ZN5ImGui27BeginDockableDragDropTargetEP11ImGuiWindow called 1077 returned 100% blocks executed 5%
     1077:20218:void ImGui::BeginDockableDragDropTarget(ImGuiWindow* window)
        -:20219:{
     1077:20220:    ImGuiContext& g = *GImGui;
        -:20221:
        -:20222:    //IM_ASSERT(window->RootWindowDockTree == window); // May also be a DockSpace
    1077*:20223:    IM_ASSERT((window->Flags & ImGuiWindowFlags_NoDocking) == 0);
     1077:20223-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:20223-block 3
call    2 never executed
     1077:20224:    if (!g.DragDropActive)
     1077:20224-block 4
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:20225:        return;
     1077:20225-block 5
        -:20226:    //GetForegroundDrawList(window)->AddRect(window->Pos, window->Pos + window->Size, IM_COL32(255, 255, 0, 255));
    #####:20227:    if (!BeginDragDropTargetCustom(window->Rect(), window->ID))
    %%%%%:20227-block 6
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:20228:        return;
    %%%%%:20228-block 9
        -:20229:
        -:20230:    // Peek into the payload before calling AcceptDragDropPayload() so we can handle overlapping dock nodes with filtering
        -:20231:    // (this is a little unusual pattern, normally most code would call AcceptDragDropPayload directly)
    #####:20232:    const ImGuiPayload* payload = &g.DragDropPayload;
    #####:20233:    if (!payload->IsDataType(IMGUI_PAYLOAD_TYPE_WINDOW) || !DockNodeIsDropAllowed(window, *(ImGuiWindow**)payload->Data))
    %%%%%:20233-block 10
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:20233-block 12
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:20233-block 14
    %%%%%:20233-block 15
    %%%%%:20233-block 16
branch  6 never executed (fallthrough)
branch  7 never executed
        -:20234:    {
    #####:20235:        EndDragDropTarget();
    %%%%%:20235-block 17
call    0 never executed
    #####:20236:        return;
        -:20237:    }
        -:20238:
    #####:20239:    ImGuiWindow* payload_window = *(ImGuiWindow**)payload->Data;
    #####:20240:    if (AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_WINDOW, ImGuiDragDropFlags_AcceptBeforeDelivery | ImGuiDragDropFlags_AcceptNoDrawDefaultRect))
    %%%%%:20240-block 19
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -:20241:    {
        -:20242:        // Select target node
        -:20243:        // (Important: we cannot use g.HoveredDockNode here! Because each of our target node have filters based on payload, each candidate drop target will do its own evaluation)
    #####:20244:        bool dock_into_floating_window = false;
    #####:20245:        ImGuiDockNode* node = NULL;
    #####:20246:        if (window->DockNodeAsHost)
    %%%%%:20246-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
        -:20247:        {
        -:20248:            // Cannot assume that node will != NULL even though we passed the rectangle test: it depends on padding/spacing handled by DockNodeTreeFindVisibleNodeByPos().
    #####:20249:            node = DockNodeTreeFindVisibleNodeByPos(window->DockNodeAsHost, g.IO.MousePos);
    %%%%%:20249-block 22
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:20250:
        -:20251:            // There is an edge case when docking into a dockspace which only has _inactive_ nodes (because none of the windows are active)
        -:20252:            // In this case we need to fallback into any leaf mode, possibly the central node.
        -:20253:            // FIXME-20181220: We should not have to test for IsLeafNode() here but we have another bug to fix first.
    #####:20254:            if (node && node->IsDockSpace() && node->IsRootNode())
    %%%%%:20254-block 23
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:20254-block 24
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:20254-block 26
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%:20254-block 28
    %%%%%:20254-block 29
    %%%%%:20254-block 30
branch  8 never executed (fallthrough)
branch  9 never executed
    #####:20255:                node = (node->CentralNode && node->IsLeafNode()) ? node->CentralNode : DockNodeTreeFindFallbackLeafNode(node);
    %%%%%:20255-block 31
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:20255-block 32
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:20255-block 34
    %%%%%:20255-block 35
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
    %%%%%:20255-block 36
    %%%%%:20255-block 37
        -:20256:        }
        -:20257:        else
        -:20258:        {
    #####:20259:            if (window->DockNode)
    %%%%%:20259-block 38
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:20260:                node = window->DockNode;
    %%%%%:20260-block 39
        -:20261:            else
    #####:20262:                dock_into_floating_window = true; // Dock into a regular window
    %%%%%:20262-block 40
        -:20263:        }
        -:20264:
    #####:20265:        const ImRect explicit_target_rect = (node && node->TabBar && !node->IsHiddenTabBar() && !node->IsNoTabBar()) ? node->TabBar->BarRect : ImRect(window->Pos, window->Pos + ImVec2(window->Size.x, GetFrameHeight()));
    %%%%%:20265-block 41
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:20265-block 42
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:20265-block 43
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:20265-block 45
call    7 never executed
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%:20265-block 47
    %%%%%:20265-block 48
call   10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
    #####:20266:        const bool is_explicit_target = g.IO.ConfigDockingWithShift || IsMouseHoveringRect(explicit_target_rect.Min, explicit_target_rect.Max);
    %%%%%:20266-block 52
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:20266-block 53
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:20266-block 55
    %%%%%:20266-block 56
        -:20267:
        -:20268:        // Preview docking request and find out split direction/ratio
        -:20269:        //const bool do_preview = true;     // Ignore testing for payload->IsPreview() which removes one frame of delay, but breaks overlapping drop targets within the same window.
    #####:20270:        const bool do_preview = payload->IsPreview() || payload->IsDelivery();
    %%%%%:20270-block 57
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:20270-block 59
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:20270-block 61
    %%%%%:20270-block 62
    #####:20271:        if (do_preview && (node != NULL || dock_into_floating_window))
    %%%%%:20271-block 63
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:20271-block 64
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:20271-block 65
branch  4 never executed (fallthrough)
branch  5 never executed
        -:20272:        {
        -:20273:            // If we have a non-leaf node it means we are hovering the border of a parent node, in which case only outer markers will appear.
    #####:20274:            ImGuiDockPreviewData split_inner;
    %%%%%:20274-block 66
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:20275:            ImGuiDockPreviewData split_outer;
    %%%%%:20275-block 67
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:20276:            ImGuiDockPreviewData* split_data = &split_inner;
    #####:20277:            if (node && (node->ParentNode || node->IsCentralNode() || !node->IsLeafNode()))
    %%%%%:20277-block 68
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:20277-block 69
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:20277-block 70
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:20277-block 72
call    7 never executed
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%:20277-block 74
    %%%%%:20277-block 75
    %%%%%:20277-block 76
branch 10 never executed (fallthrough)
branch 11 never executed
    #####:20278:                if (ImGuiDockNode* root_node = DockNodeGetRootNode(node))
    %%%%%:20278-block 77
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -:20279:                {
    #####:20280:                    DockNodePreviewDockSetup(window, root_node, payload_window, NULL, &split_outer, is_explicit_target, true);
    %%%%%:20280-block 79
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:20281:                    if (split_outer.IsSplitDirExplicit)
    %%%%%:20281-block 80
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:20282:                        split_data = &split_outer;
    %%%%%:20282-block 81
        -:20283:                }
    #####:20284:            if (!node || node->IsLeafNode())
    %%%%%:20284-block 82
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:20284-block 83
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:20284-block 85
    %%%%%:20284-block 86
    %%%%%:20284-block 87
branch  5 never executed (fallthrough)
branch  6 never executed
    #####:20285:                DockNodePreviewDockSetup(window, node, payload_window, NULL, &split_inner, is_explicit_target, false);
    %%%%%:20285-block 88
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:20286:            if (split_data == &split_outer)
    %%%%%:20286-block 89
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:20287:                split_inner.IsDropAllowed = false;
    %%%%%:20287-block 90
        -:20288:
        -:20289:            // Draw inner then outer, so that previewed tab (in inner data) will be behind the outer drop boxes
    #####:20290:            DockNodePreviewDockRender(window, node, payload_window, &split_inner);
    %%%%%:20290-block 91
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:20291:            DockNodePreviewDockRender(window, node, payload_window, &split_outer);
    %%%%%:20291-block 92
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:20292:
        -:20293:            // Queue docking request
    #####:20294:            if (split_data->IsDropAllowed && payload->IsDelivery())
    %%%%%:20294-block 93
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:20294-block 94
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:20294-block 96
    %%%%%:20294-block 97
    %%%%%:20294-block 98
branch  5 never executed (fallthrough)
branch  6 never executed
    #####:20295:                DockContextQueueDock(&g, window, split_data->SplitNode, payload_window, split_data->SplitDir, split_data->SplitRatio, split_data == &split_outer);
    %%%%%:20295-block 99
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:20296:        }
    %%%%%:20296-block 100
call    0 never executed
call    1 never executed
    $$$$$:20296-block 106
call    2 never executed
    $$$$$:20296-block 108
call    3 never executed
        -:20297:    }
    #####:20298:    EndDragDropTarget();
    %%%%%:20298-block 104
call    0 never executed
        -:20299:}
        -:20300:
        -:20301://-----------------------------------------------------------------------------
        -:20302:// Docking: Settings
        -:20303://-----------------------------------------------------------------------------
        -:20304:// - DockSettingsRenameNodeReferences()
        -:20305:// - DockSettingsRemoveNodeReferences()
        -:20306:// - DockSettingsFindNodeSettings()
        -:20307:// - DockSettingsHandler_ApplyAll()
        -:20308:// - DockSettingsHandler_ReadOpen()
        -:20309:// - DockSettingsHandler_ReadLine()
        -:20310:// - DockSettingsHandler_DockNodeToSettings()
        -:20311:// - DockSettingsHandler_WriteAll()
        -:20312://-----------------------------------------------------------------------------
        -:20313:
function _ZN5ImGuiL32DockSettingsRenameNodeReferencesEjj called 0 returned 0% blocks executed 0%
    #####:20314:static void ImGui::DockSettingsRenameNodeReferences(ImGuiID old_node_id, ImGuiID new_node_id)
        -:20315:{
    #####:20316:    ImGuiContext& g = *GImGui;
    #####:20317:    IMGUI_DEBUG_LOG_DOCKING("[docking] DockSettingsRenameNodeReferences: from 0x%08X -> to 0x%08X\n", old_node_id, new_node_id);
    %%%%%:20317-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:20317-block 3
call    2 never executed
    #####:20318:    for (int window_n = 0; window_n < g.Windows.Size; window_n++)
    %%%%%:20318-block 4
    %%%%%:20318-block 9
    %%%%%:20318-block 10
branch  0 never executed
branch  1 never executed (fallthrough)
        -:20319:    {
    #####:20320:        ImGuiWindow* window = g.Windows[window_n];
    %%%%%:20320-block 5
call    0 never executed
    #####:20321:        if (window->DockId == old_node_id && window->DockNode == NULL)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:20321-block 7
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:20322:            window->DockId = new_node_id;
    %%%%%:20322-block 8
        -:20323:    }
        -:20324:    //// FIXME-OPT: We could remove this loop by storing the index in the map
    #####:20325:    for (ImGuiWindowSettings* settings = g.SettingsWindows.begin(); settings != NULL; settings = g.SettingsWindows.next_chunk(settings))
    %%%%%:20325-block 11
call    0 never executed
    %%%%%:20325-block 14
call    1 never executed
    %%%%%:20325-block 16
branch  2 never executed
branch  3 never executed (fallthrough)
    #####:20326:        if (settings->DockId == old_node_id)
    %%%%%:20326-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:20327:            settings->DockId = new_node_id;
    %%%%%:20327-block 13
    #####:20328:}
        -:20329:
        -:20330:// Remove references stored in ImGuiWindowSettings to the given ImGuiDockNodeSettings
function _ZN5ImGuiL32DockSettingsRemoveNodeReferencesEPji called 0 returned 0% blocks executed 0%
    #####:20331:static void ImGui::DockSettingsRemoveNodeReferences(ImGuiID* node_ids, int node_ids_count)
        -:20332:{
    #####:20333:    ImGuiContext& g = *GImGui;
    #####:20334:    int found = 0;
        -:20335:    //// FIXME-OPT: We could remove this loop by storing the index in the map
    #####:20336:    for (ImGuiWindowSettings* settings = g.SettingsWindows.begin(); settings != NULL; settings = g.SettingsWindows.next_chunk(settings))
    %%%%%:20336-block 2
call    0 never executed
    %%%%%:20336-block 10
call    1 never executed
    %%%%%:20336-block 12
branch  2 never executed
branch  3 never executed (fallthrough)
    #####:20337:        for (int node_n = 0; node_n < node_ids_count; node_n++)
    %%%%%:20337-block 3
    %%%%%:20337-block 8
    %%%%%:20337-block 9
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:20338:            if (settings->DockId == node_ids[node_n])
    %%%%%:20338-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
        -:20339:            {
    #####:20340:                settings->DockId = 0;
    #####:20341:                settings->DockOrder = -1;
    #####:20342:                if (++found < node_ids_count)
    %%%%%:20342-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:20343:                    break;
    %%%%%:20343-block 6
    #####:20344:                return;
    %%%%%:20344-block 7
        -:20345:            }
        -:20346:}
        -:20347:
function _ZN5ImGuiL28DockSettingsFindNodeSettingsEP12ImGuiContextj called 8 returned 100% blocks executed 88%
        8:20348:static ImGuiDockNodeSettings* ImGui::DockSettingsFindNodeSettings(ImGuiContext* ctx, ImGuiID id)
        -:20349:{
        -:20350:    // FIXME-OPT
        8:20351:    ImGuiDockContext* dc = &ctx->DockContext;
       30:20352:    for (int n = 0; n < dc->NodesSettings.Size; n++)
        8:20352-block 2
       22:20352-block 6
       30:20352-block 7
branch  0 taken 30
branch  1 taken 0 (fallthrough)
       30:20353:        if (dc->NodesSettings[n].ID == id)
       30:20353-block 3
call    0 returned 30
branch  1 taken 8 (fallthrough)
branch  2 taken 22
        8:20354:            return &dc->NodesSettings[n];
        8:20354-block 5
call    0 returned 8
    #####:20355:    return NULL;
    %%%%%:20355-block 8
        -:20356:}
        -:20357:
        -:20358:// Clear settings data
function _ZN5ImGuiL28DockSettingsHandler_ClearAllEP12ImGuiContextP20ImGuiSettingsHandler called 1 returned 100% blocks executed 100%
        1:20359:static void ImGui::DockSettingsHandler_ClearAll(ImGuiContext* ctx, ImGuiSettingsHandler*)
        -:20360:{
        1:20361:    ImGuiDockContext* dc = &ctx->DockContext;
        1:20362:    dc->NodesSettings.clear();
        1:20362-block 2
call    0 returned 1
        1:20363:    DockContextClearNodes(ctx, 0, true);
call    0 returned 1
        1:20364:}
        -:20365:
        -:20366:// Recreate nodes based on settings data
function _ZN5ImGuiL28DockSettingsHandler_ApplyAllEP12ImGuiContextP20ImGuiSettingsHandler called 1 returned 100% blocks executed 100%
        1:20367:static void ImGui::DockSettingsHandler_ApplyAll(ImGuiContext* ctx, ImGuiSettingsHandler*)
        -:20368:{
        -:20369:    // Prune settings at boot time only
        1:20370:    ImGuiDockContext* dc = &ctx->DockContext;
        1:20371:    if (ctx->Windows.Size == 0)
        1:20371-block 2
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:20372:        DockContextPruneUnusedSettingsNodes(ctx);
        1:20372-block 3
call    0 returned 1
        1:20373:    DockContextBuildNodesFromSettings(ctx, dc->NodesSettings.Data, dc->NodesSettings.Size);
        1:20373-block 4
call    0 returned 1
        1:20374:    DockContextBuildAddWindowsToNodes(ctx, 0);
call    0 returned 1
        1:20375:}
        -:20376:
function _ZN5ImGuiL28DockSettingsHandler_ReadOpenEP12ImGuiContextP20ImGuiSettingsHandlerPKc called 1 returned 100% blocks executed 75%
        1:20377:static void* ImGui::DockSettingsHandler_ReadOpen(ImGuiContext*, ImGuiSettingsHandler*, const char* name)
        -:20378:{
        1:20379:    if (strcmp(name, "Data") != 0)
        1:20379-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:20380:        return NULL;
    %%%%%:20380-block 3
        1:20381:    return (void*)1;
        1:20381-block 4
        -:20382:}
        -:20383:
function _ZN5ImGuiL28DockSettingsHandler_ReadLineEP12ImGuiContextP20ImGuiSettingsHandlerPvPKc called 10 returned 100% blocks executed 76%
       10:20384:static void ImGui::DockSettingsHandler_ReadLine(ImGuiContext* ctx, ImGuiSettingsHandler*, void*, const char* line)
        -:20385:{
       10:20386:    char c = 0;
       10:20387:    int x = 0, y = 0;
       10:20388:    int r = 0;
        -:20389:
        -:20390:    // Parsing, e.g.
        -:20391:    // " DockNode   ID=0x00000001 Pos=383,193 Size=201,322 Split=Y,0.506 "
        -:20392:    // "   DockNode ID=0x00000002 Parent=0x00000001 "
        -:20393:    // Important: this code expect currently fields in a fixed order.
       10:20394:    ImGuiDockNodeSettings node;
       10:20394-block 2
call    0 returned 10
       10:20395:    line = ImStrSkipBlank(line);
call    0 returned 10
       10:20396:    if      (strncmp(line, "DockNode", 8) == 0)  { line = ImStrSkipBlank(line + strlen("DockNode")); }
branch  0 taken 8 (fallthrough)
branch  1 taken 2
        8:20396-block 5
call    2 returned 8
        2:20397:    else if (strncmp(line, "DockSpace", 9) == 0) { line = ImStrSkipBlank(line + strlen("DockSpace")); node.Flags |= ImGuiDockNodeFlags_DockSpace; }
        2:20397-block 6
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1:20397-block 7
call    2 returned 1
        1:20398:    else return;
        1:20398-block 9
        1:20398-block 62
       9*:20399:    if (sscanf(line, "ID=0x%08X%n",      &node.ID, &r) == 1)            { line += r; } else return;
        9:20399-block 10
branch  0 taken 9 (fallthrough)
branch  1 taken 0
        9:20399-block 11
    %%%%%:20399-block 12
       9*:20400:    if (sscanf(line, " Parent=0x%08X%n", &node.ParentNodeId, &r) == 1)  { line += r; if (node.ParentNodeId == 0) return; }
        9:20400-block 13
branch  0 taken 8 (fallthrough)
branch  1 taken 1
        8:20400-block 14
branch  2 taken 0 (fallthrough)
branch  3 taken 8
    %%%%%:20400-block 15
       9*:20401:    if (sscanf(line, " Window=0x%08X%n", &node.ParentWindowId, &r) ==1) { line += r; if (node.ParentWindowId == 0) return; }
        9:20401-block 16
branch  0 taken 1 (fallthrough)
branch  1 taken 8
        1:20401-block 17
branch  2 taken 0 (fallthrough)
branch  3 taken 1
    %%%%%:20401-block 18
        9:20402:    if (node.ParentNodeId == 0)
        9:20402-block 19
branch  0 taken 1 (fallthrough)
branch  1 taken 8
        -:20403:    {
       1*:20404:        if (sscanf(line, " Pos=%i,%i%n",  &x, &y, &r) == 2)         { line += r; node.Pos = ImVec2ih((short)x, (short)y); } else return;
        1:20404-block 20
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:20404-block 21
call    2 returned 1
    %%%%%:20404-block 23
       1*:20405:        if (sscanf(line, " Size=%i,%i%n", &x, &y, &r) == 2)         { line += r; node.Size = ImVec2ih((short)x, (short)y); } else return;
        1:20405-block 24
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:20405-block 25
call    2 returned 1
    %%%%%:20405-block 27
        -:20406:    }
        -:20407:    else
        -:20408:    {
        8:20409:        if (sscanf(line, " SizeRef=%i,%i%n", &x, &y, &r) == 2)      { line += r; node.SizeRef = ImVec2ih((short)x, (short)y); }
        8:20409-block 28
branch  0 taken 8 (fallthrough)
branch  1 taken 0
        8:20409-block 29
call    2 returned 8
        -:20410:    }
        9:20411:    if (sscanf(line, " Split=%c%n", &c, &r) == 1)                   { line += r; if (c == 'X') node.SplitAxis = ImGuiAxis_X; else if (c == 'Y') node.SplitAxis = ImGuiAxis_Y; }
        9:20411-block 31
branch  0 taken 4 (fallthrough)
branch  1 taken 5
        4:20411-block 32
branch  2 taken 3 (fallthrough)
branch  3 taken 1
        3:20411-block 33
        1:20411-block 34
branch  4 taken 1 (fallthrough)
branch  5 taken 0
        1:20411-block 35
       9*:20412:    if (sscanf(line, " NoResize=%d%n", &x, &r) == 1)                { line += r; if (x != 0) node.Flags |= ImGuiDockNodeFlags_NoResize; }
        9:20412-block 36
branch  0 taken 0 (fallthrough)
branch  1 taken 9
    %%%%%:20412-block 37
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:20412-block 38
        9:20413:    if (sscanf(line, " CentralNode=%d%n", &x, &r) == 1)             { line += r; if (x != 0) node.Flags |= ImGuiDockNodeFlags_CentralNode; }
        9:20413-block 39
branch  0 taken 1 (fallthrough)
branch  1 taken 8
        1:20413-block 40
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1:20413-block 41
       9*:20414:    if (sscanf(line, " NoTabBar=%d%n", &x, &r) == 1)                { line += r; if (x != 0) node.Flags |= ImGuiDockNodeFlags_NoTabBar; }
        9:20414-block 42
branch  0 taken 0 (fallthrough)
branch  1 taken 9
    %%%%%:20414-block 43
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:20414-block 44
       9*:20415:    if (sscanf(line, " HiddenTabBar=%d%n", &x, &r) == 1)            { line += r; if (x != 0) node.Flags |= ImGuiDockNodeFlags_HiddenTabBar; }
        9:20415-block 45
branch  0 taken 0 (fallthrough)
branch  1 taken 9
    %%%%%:20415-block 46
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:20415-block 47
       9*:20416:    if (sscanf(line, " NoWindowMenuButton=%d%n", &x, &r) == 1)      { line += r; if (x != 0) node.Flags |= ImGuiDockNodeFlags_NoWindowMenuButton; }
        9:20416-block 48
branch  0 taken 0 (fallthrough)
branch  1 taken 9
    %%%%%:20416-block 49
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:20416-block 50
       9*:20417:    if (sscanf(line, " NoCloseButton=%d%n", &x, &r) == 1)           { line += r; if (x != 0) node.Flags |= ImGuiDockNodeFlags_NoCloseButton; }
        9:20417-block 51
branch  0 taken 0 (fallthrough)
branch  1 taken 9
    %%%%%:20417-block 52
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:20417-block 53
        9:20418:    if (sscanf(line, " Selected=0x%08X%n", &node.SelectedTabId,&r) == 1) { line += r; }
        9:20418-block 54
branch  0 taken 7 (fallthrough)
branch  1 taken 2
        7:20418-block 55
        9:20419:    if (node.ParentNodeId != 0)
        9:20419-block 56
branch  0 taken 8 (fallthrough)
branch  1 taken 1
        8:20420:        if (ImGuiDockNodeSettings* parent_settings = DockSettingsFindNodeSettings(ctx, node.ParentNodeId))
        8:20420-block 57
call    0 returned 8
branch  1 taken 8 (fallthrough)
branch  2 taken 0 (throw)
        8:20420-block 58
branch  3 taken 8 (fallthrough)
branch  4 taken 0
        8:20421:            node.Depth = parent_settings->Depth + 1;
        8:20421-block 59
        9:20422:    ctx->DockContext.NodesSettings.push_back(node);
        9:20422-block 60
call    0 returned 9
branch  1 taken 9 (fallthrough)
branch  2 taken 0 (throw)
        -:20423:}
        -:20424:
function _ZL38DockSettingsHandler_DockNodeToSettingsP16ImGuiDockContextP13ImGuiDockNodei called 18 returned 100% blocks executed 96%
       18:20425:static void DockSettingsHandler_DockNodeToSettings(ImGuiDockContext* dc, ImGuiDockNode* node, int depth)
        -:20426:{
       18:20427:    ImGuiDockNodeSettings node_settings;
       18:20427-block 2
call    0 returned 18
      18*:20428:    IM_ASSERT(depth < (1 << (sizeof(node_settings.Depth) << 3)));
branch  0 taken 0 (fallthrough)
branch  1 taken 18
    %%%%%:20428-block 4
call    2 never executed
       18:20429:    node_settings.ID = node->ID;
       18:20430:    node_settings.ParentNodeId = node->ParentNode ? node->ParentNode->ID : 0;
       18:20430-block 5
branch  0 taken 16 (fallthrough)
branch  1 taken 2
       16:20430-block 6
        2:20430-block 7
       18:20431:    node_settings.ParentWindowId = (node->IsDockSpace() && node->HostWindow && node->HostWindow->ParentWindow) ? node->HostWindow->ParentWindow->ID : 0;
       18:20431-block 8
call    0 returned 18
branch  1 taken 2 (fallthrough)
branch  2 taken 16
        2:20431-block 10
branch  3 taken 2 (fallthrough)
branch  4 taken 0
        2:20431-block 11
branch  5 taken 2 (fallthrough)
branch  6 taken 0
        2:20431-block 12
       16:20431-block 13
       18:20432:    node_settings.SelectedTabId = node->SelectedTabId;
       18:20433:    node_settings.SplitAxis = (signed char)(node->IsSplitNode() ? node->SplitAxis : ImGuiAxis_None);
       18:20433-block 14
call    0 returned 18
branch  1 taken 8 (fallthrough)
branch  2 taken 10
        8:20433-block 16
       10:20433-block 17
       18:20434:    node_settings.Depth = (char)depth;
       18:20435:    node_settings.Flags = (node->LocalFlags & ImGuiDockNodeFlags_SavedFlagsMask_);
       18:20436:    node_settings.Pos = ImVec2ih(node->Pos);
       18:20436-block 18
call    0 returned 18
       18:20437:    node_settings.Size = ImVec2ih(node->Size);
call    0 returned 18
       18:20438:    node_settings.SizeRef = ImVec2ih(node->SizeRef);
call    0 returned 18
       18:20439:    dc->NodesSettings.push_back(node_settings);
call    0 returned 18
branch  1 taken 18 (fallthrough)
branch  2 taken 0 (throw)
       18:20440:    if (node->ChildNodes[0])
       18:20440-block 22
branch  0 taken 8 (fallthrough)
branch  1 taken 10
        8:20441:        DockSettingsHandler_DockNodeToSettings(dc, node->ChildNodes[0], depth + 1);
        8:20441-block 23
call    0 returned 8
branch  1 taken 8 (fallthrough)
branch  2 taken 0 (throw)
       18:20442:    if (node->ChildNodes[1])
       18:20442-block 24
branch  0 taken 8 (fallthrough)
branch  1 taken 10
        8:20443:        DockSettingsHandler_DockNodeToSettings(dc, node->ChildNodes[1], depth + 1);
        8:20443-block 25
call    0 returned 8
branch  1 taken 8 (fallthrough)
branch  2 taken 0 (throw)
       18:20444:}
       18:20444-block 26
        -:20445:
function _ZN5ImGuiL28DockSettingsHandler_WriteAllEP12ImGuiContextP20ImGuiSettingsHandlerP15ImGuiTextBuffer called 2 returned 100% blocks executed 64%
        2:20446:static void ImGui::DockSettingsHandler_WriteAll(ImGuiContext* ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* buf)
        -:20447:{
        2:20448:    ImGuiContext& g = *ctx;
        2:20449:    ImGuiDockContext* dc = &ctx->DockContext;
        2:20450:    if (!(g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable))
        2:20450-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:20451:        return;
    %%%%%:20451-block 3
        -:20452:
        -:20453:    // Gather settings data
        -:20454:    // (unlike our windows settings, because nodes are always built we can do a full rewrite of the SettingsNode buffer)
        2:20455:    dc->NodesSettings.resize(0);
        2:20455-block 4
call    0 returned 2
        2:20456:    dc->NodesSettings.reserve(dc->Nodes.Data.Size);
call    0 returned 2
       20:20457:    for (int n = 0; n < dc->Nodes.Data.Size; n++)
       18:20457-block 12
       20:20457-block 13
branch  0 taken 18
branch  1 taken 2 (fallthrough)
       18:20458:        if (ImGuiDockNode* node = (ImGuiDockNode*)dc->Nodes.Data[n].val_p)
       18:20458-block 7
call    0 returned 18
branch  1 taken 18 (fallthrough)
branch  2 taken 0
       18:20459:            if (node->IsRootNode())
       18:20459-block 9
call    0 returned 18
branch  1 taken 2 (fallthrough)
branch  2 taken 16
        2:20460:                DockSettingsHandler_DockNodeToSettings(dc, node, 0);
        2:20460-block 11
call    0 returned 2
        -:20461:
        2:20462:    int max_depth = 0;
       20:20463:    for (int node_n = 0; node_n < dc->NodesSettings.Size; node_n++)
        2:20463-block 14
       20:20463-block 18
branch  0 taken 18
branch  1 taken 2 (fallthrough)
       18:20464:        max_depth = ImMax((int)dc->NodesSettings[node_n].Depth, max_depth);
       18:20464-block 15
call    0 returned 18
call    1 returned 18
        -:20465:
        -:20466:    // Write to text buffer
        2:20467:    buf->appendf("[%s][Data]\n", handler->TypeName);
        2:20467-block 19
call    0 returned 2
       20:20468:    for (int node_n = 0; node_n < dc->NodesSettings.Size; node_n++)
       20:20468-block 77
branch  0 taken 18
branch  1 taken 2 (fallthrough)
        -:20469:    {
       18:20470:        const int line_start_pos = buf->size(); (void)line_start_pos;
       18:20470-block 21
call    0 returned 18
       18:20471:        const ImGuiDockNodeSettings* node_settings = &dc->NodesSettings[node_n];
call    0 returned 18
       18:20472:        buf->appendf("%*s%s%*s", node_settings->Depth * 2, "", (node_settings->Flags & ImGuiDockNodeFlags_DockSpace) ? "DockSpace" : "DockNode ", (max_depth - node_settings->Depth) * 2, "");  // Text align nodes to facilitate looking at .ini file
branch  0 taken 2 (fallthrough)
branch  1 taken 16
        2:20472-block 24
       16:20472-block 25
       18:20472-block 26
call    2 returned 18
       18:20473:        buf->appendf(" ID=0x%08X", node_settings->ID);
call    0 returned 18
       18:20474:        if (node_settings->ParentNodeId)
branch  0 taken 16 (fallthrough)
branch  1 taken 2
        -:20475:        {
       16:20476:            buf->appendf(" Parent=0x%08X SizeRef=%d,%d", node_settings->ParentNodeId, node_settings->SizeRef.x, node_settings->SizeRef.y);
       16:20476-block 29
call    0 returned 16
        -:20477:        }
        -:20478:        else
        -:20479:        {
        2:20480:            if (node_settings->ParentWindowId)
        2:20480-block 30
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2:20481:                buf->appendf(" Window=0x%08X", node_settings->ParentWindowId);
        2:20481-block 31
call    0 returned 2
        2:20482:            buf->appendf(" Pos=%d,%d Size=%d,%d", node_settings->Pos.x, node_settings->Pos.y, node_settings->Size.x, node_settings->Size.y);
        2:20482-block 32
call    0 returned 2
        -:20483:        }
       18:20484:        if (node_settings->SplitAxis != ImGuiAxis_None)
       18:20484-block 33
branch  0 taken 8 (fallthrough)
branch  1 taken 10
        8:20485:            buf->appendf(" Split=%c", (node_settings->SplitAxis == ImGuiAxis_X) ? 'X' : 'Y');
        8:20485-block 34
branch  0 taken 6 (fallthrough)
branch  1 taken 2
        6:20485-block 35
        2:20485-block 36
        8:20485-block 37
call    2 returned 8
       18:20486:        if (node_settings->Flags & ImGuiDockNodeFlags_NoResize)
       18:20486-block 38
branch  0 taken 0 (fallthrough)
branch  1 taken 18
    #####:20487:            buf->appendf(" NoResize=1");
    %%%%%:20487-block 39
call    0 never executed
       18:20488:        if (node_settings->Flags & ImGuiDockNodeFlags_CentralNode)
       18:20488-block 40
branch  0 taken 2 (fallthrough)
branch  1 taken 16
        2:20489:            buf->appendf(" CentralNode=1");
        2:20489-block 41
call    0 returned 2
       18:20490:        if (node_settings->Flags & ImGuiDockNodeFlags_NoTabBar)
       18:20490-block 42
branch  0 taken 0 (fallthrough)
branch  1 taken 18
    #####:20491:            buf->appendf(" NoTabBar=1");
    %%%%%:20491-block 43
call    0 never executed
       18:20492:        if (node_settings->Flags & ImGuiDockNodeFlags_HiddenTabBar)
       18:20492-block 44
branch  0 taken 0 (fallthrough)
branch  1 taken 18
    #####:20493:            buf->appendf(" HiddenTabBar=1");
    %%%%%:20493-block 45
call    0 never executed
       18:20494:        if (node_settings->Flags & ImGuiDockNodeFlags_NoWindowMenuButton)
       18:20494-block 46
branch  0 taken 0 (fallthrough)
branch  1 taken 18
    #####:20495:            buf->appendf(" NoWindowMenuButton=1");
    %%%%%:20495-block 47
call    0 never executed
       18:20496:        if (node_settings->Flags & ImGuiDockNodeFlags_NoCloseButton)
       18:20496-block 48
branch  0 taken 0 (fallthrough)
branch  1 taken 18
    #####:20497:            buf->appendf(" NoCloseButton=1");
    %%%%%:20497-block 49
call    0 never executed
       18:20498:        if (node_settings->SelectedTabId)
       18:20498-block 50
branch  0 taken 14 (fallthrough)
branch  1 taken 4
       14:20499:            buf->appendf(" Selected=0x%08X", node_settings->SelectedTabId);
       14:20499-block 51
call    0 returned 14
        -:20500:
        -:20501:        // [DEBUG] Include comments in the .ini file to ease debugging (this makes saving slower!)
       18:20502:        if (g.IO.ConfigDebugIniSettings)
       18:20502-block 52
branch  0 taken 0 (fallthrough)
branch  1 taken 18
    #####:20503:            if (ImGuiDockNode* node = DockContextFindNodeByID(ctx, node_settings->ID))
    %%%%%:20503-block 53
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -:20504:            {
    #####:20505:                buf->appendf("%*s", ImMax(2, (line_start_pos + 92) - buf->size()), "");     // Align everything
    %%%%%:20505-block 55
call    0 never executed
call    1 never executed
call    2 never executed
    #####:20506:                if (node->IsDockSpace() && node->HostWindow && node->HostWindow->ParentWindow)
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:20506-block 60
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:20506-block 61
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:20506-block 62
    %%%%%:20506-block 63
    %%%%%:20506-block 64
branch  7 never executed (fallthrough)
branch  8 never executed
    #####:20507:                    buf->appendf(" ; in '%s'", node->HostWindow->ParentWindow->Name);
    %%%%%:20507-block 65
call    0 never executed
        -:20508:                // Iterate settings so we can give info about windows that didn't exist during the session.
    #####:20509:                int contains_window = 0;
    #####:20510:                for (ImGuiWindowSettings* settings = g.SettingsWindows.begin(); settings != NULL; settings = g.SettingsWindows.next_chunk(settings))
    %%%%%:20510-block 66
call    0 never executed
    %%%%%:20510-block 72
call    1 never executed
    %%%%%:20510-block 74
branch  2 never executed
branch  3 never executed (fallthrough)
    #####:20511:                    if (settings->DockId == node_settings->ID)
    %%%%%:20511-block 67
branch  0 never executed (fallthrough)
branch  1 never executed
        -:20512:                    {
    #####:20513:                        if (contains_window++ == 0)
    %%%%%:20513-block 68
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:20514:                            buf->appendf(" ; contains ");
    %%%%%:20514-block 69
call    0 never executed
    #####:20515:                        buf->appendf("'%s' ", settings->GetName());
    %%%%%:20515-block 70
call    0 never executed
call    1 never executed
        -:20516:                    }
        -:20517:            }
        -:20518:
       18:20519:        buf->appendf("\n");
       18:20519-block 75
call    0 returned 18
        -:20520:    }
        2:20521:    buf->appendf("\n");
        2:20521-block 78
call    0 returned 2
        -:20522:}
        -:20523:
        -:20524:
        -:20525://-----------------------------------------------------------------------------
        -:20526:// [SECTION] PLATFORM DEPENDENT HELPERS
        -:20527://-----------------------------------------------------------------------------
        -:20528:// - Default clipboard handlers
        -:20529:// - Default shell function handlers
        -:20530:// - Default IME handlers
        -:20531://-----------------------------------------------------------------------------
        -:20532:
        -:20533:#if defined(_WIN32) && !defined(IMGUI_DISABLE_WIN32_FUNCTIONS) && !defined(IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS)
        -:20534:
        -:20535:#ifdef _MSC_VER
        -:20536:#pragma comment(lib, "user32")
        -:20537:#pragma comment(lib, "kernel32")
        -:20538:#endif
        -:20539:
        -:20540:// Win32 clipboard implementation
        -:20541:// We use g.ClipboardHandlerData for temporary storage to ensure it is freed on Shutdown()
        -:20542:static const char* Platform_GetClipboardTextFn_DefaultImpl(ImGuiContext* ctx)
        -:20543:{
        -:20544:    ImGuiContext& g = *ctx;
        -:20545:    g.ClipboardHandlerData.clear();
        -:20546:    if (!::OpenClipboard(NULL))
        -:20547:        return NULL;
        -:20548:    HANDLE wbuf_handle = ::GetClipboardData(CF_UNICODETEXT);
        -:20549:    if (wbuf_handle == NULL)
        -:20550:    {
        -:20551:        ::CloseClipboard();
        -:20552:        return NULL;
        -:20553:    }
        -:20554:    if (const WCHAR* wbuf_global = (const WCHAR*)::GlobalLock(wbuf_handle))
        -:20555:    {
        -:20556:        int buf_len = ::WideCharToMultiByte(CP_UTF8, 0, wbuf_global, -1, NULL, 0, NULL, NULL);
        -:20557:        g.ClipboardHandlerData.resize(buf_len);
        -:20558:        ::WideCharToMultiByte(CP_UTF8, 0, wbuf_global, -1, g.ClipboardHandlerData.Data, buf_len, NULL, NULL);
        -:20559:    }
        -:20560:    ::GlobalUnlock(wbuf_handle);
        -:20561:    ::CloseClipboard();
        -:20562:    return g.ClipboardHandlerData.Data;
        -:20563:}
        -:20564:
        -:20565:static void Platform_SetClipboardTextFn_DefaultImpl(ImGuiContext*, const char* text)
        -:20566:{
        -:20567:    if (!::OpenClipboard(NULL))
        -:20568:        return;
        -:20569:    const int wbuf_length = ::MultiByteToWideChar(CP_UTF8, 0, text, -1, NULL, 0);
        -:20570:    HGLOBAL wbuf_handle = ::GlobalAlloc(GMEM_MOVEABLE, (SIZE_T)wbuf_length * sizeof(WCHAR));
        -:20571:    if (wbuf_handle == NULL)
        -:20572:    {
        -:20573:        ::CloseClipboard();
        -:20574:        return;
        -:20575:    }
        -:20576:    WCHAR* wbuf_global = (WCHAR*)::GlobalLock(wbuf_handle);
        -:20577:    ::MultiByteToWideChar(CP_UTF8, 0, text, -1, wbuf_global, wbuf_length);
        -:20578:    ::GlobalUnlock(wbuf_handle);
        -:20579:    ::EmptyClipboard();
        -:20580:    if (::SetClipboardData(CF_UNICODETEXT, wbuf_handle) == NULL)
        -:20581:        ::GlobalFree(wbuf_handle);
        -:20582:    ::CloseClipboard();
        -:20583:}
        -:20584:
        -:20585:#elif defined(__APPLE__) && TARGET_OS_OSX && defined(IMGUI_ENABLE_OSX_DEFAULT_CLIPBOARD_FUNCTIONS)
        -:20586:
        -:20587:#include <Carbon/Carbon.h>  // Use old API to avoid need for separate .mm file
        -:20588:static PasteboardRef main_clipboard = 0;
        -:20589:
        -:20590:// OSX clipboard implementation
        -:20591:// If you enable this you will need to add '-framework ApplicationServices' to your linker command-line!
        -:20592:static void Platform_SetClipboardTextFn_DefaultImpl(ImGuiContext*, const char* text)
        -:20593:{
        -:20594:    if (!main_clipboard)
        -:20595:        PasteboardCreate(kPasteboardClipboard, &main_clipboard);
        -:20596:    PasteboardClear(main_clipboard);
        -:20597:    CFDataRef cf_data = CFDataCreate(kCFAllocatorDefault, (const UInt8*)text, strlen(text));
        -:20598:    if (cf_data)
        -:20599:    {
        -:20600:        PasteboardPutItemFlavor(main_clipboard, (PasteboardItemID)1, CFSTR("public.utf8-plain-text"), cf_data, 0);
        -:20601:        CFRelease(cf_data);
        -:20602:    }
        -:20603:}
        -:20604:
        -:20605:static const char* Platform_GetClipboardTextFn_DefaultImpl(ImGuiContext* ctx)
        -:20606:{
        -:20607:    ImGuiContext& g = *ctx;
        -:20608:    if (!main_clipboard)
        -:20609:        PasteboardCreate(kPasteboardClipboard, &main_clipboard);
        -:20610:    PasteboardSynchronize(main_clipboard);
        -:20611:
        -:20612:    ItemCount item_count = 0;
        -:20613:    PasteboardGetItemCount(main_clipboard, &item_count);
        -:20614:    for (ItemCount i = 0; i < item_count; i++)
        -:20615:    {
        -:20616:        PasteboardItemID item_id = 0;
        -:20617:        PasteboardGetItemIdentifier(main_clipboard, i + 1, &item_id);
        -:20618:        CFArrayRef flavor_type_array = 0;
        -:20619:        PasteboardCopyItemFlavors(main_clipboard, item_id, &flavor_type_array);
        -:20620:        for (CFIndex j = 0, nj = CFArrayGetCount(flavor_type_array); j < nj; j++)
        -:20621:        {
        -:20622:            CFDataRef cf_data;
        -:20623:            if (PasteboardCopyItemFlavorData(main_clipboard, item_id, CFSTR("public.utf8-plain-text"), &cf_data) == noErr)
        -:20624:            {
        -:20625:                g.ClipboardHandlerData.clear();
        -:20626:                int length = (int)CFDataGetLength(cf_data);
        -:20627:                g.ClipboardHandlerData.resize(length + 1);
        -:20628:                CFDataGetBytes(cf_data, CFRangeMake(0, length), (UInt8*)g.ClipboardHandlerData.Data);
        -:20629:                g.ClipboardHandlerData[length] = 0;
        -:20630:                CFRelease(cf_data);
        -:20631:                return g.ClipboardHandlerData.Data;
        -:20632:            }
        -:20633:        }
        -:20634:    }
        -:20635:    return NULL;
        -:20636:}
        -:20637:
        -:20638:#else
        -:20639:
        -:20640:// Local Dear ImGui-only clipboard implementation, if user hasn't defined better clipboard handlers.
function _ZL39Platform_GetClipboardTextFn_DefaultImplP12ImGuiContext called 0 returned 0% blocks executed 0%
    #####:20641:static const char* Platform_GetClipboardTextFn_DefaultImpl(ImGuiContext* ctx)
        -:20642:{
    #####:20643:    ImGuiContext& g = *ctx;
    #####:20644:    return g.ClipboardHandlerData.empty() ? NULL : g.ClipboardHandlerData.begin();
    %%%%%:20644-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:20644-block 4
    %%%%%:20644-block 5
call    3 never executed
    %%%%%:20644-block 6
        -:20645:}
        -:20646:
function _ZL39Platform_SetClipboardTextFn_DefaultImplP12ImGuiContextPKc called 0 returned 0% blocks executed 0%
    #####:20647:static void Platform_SetClipboardTextFn_DefaultImpl(ImGuiContext* ctx, const char* text)
        -:20648:{
    #####:20649:    ImGuiContext& g = *ctx;
    #####:20650:    g.ClipboardHandlerData.clear();
    %%%%%:20650-block 2
call    0 never executed
    #####:20651:    const char* text_end = text + strlen(text);
    #####:20652:    g.ClipboardHandlerData.resize((int)(text_end - text) + 1);
call    0 never executed
    #####:20653:    memcpy(&g.ClipboardHandlerData[0], text, (size_t)(text_end - text));
call    0 never executed
    #####:20654:    g.ClipboardHandlerData[(int)(text_end - text)] = 0;
call    0 never executed
    #####:20655:}
        -:20656:
        -:20657:#endif // Default clipboard handlers
        -:20658:
        -:20659://-----------------------------------------------------------------------------
        -:20660:
        -:20661:#ifndef IMGUI_DISABLE_DEFAULT_SHELL_FUNCTIONS
        -:20662:#if defined(__APPLE__) && TARGET_OS_IPHONE
        -:20663:#define IMGUI_DISABLE_DEFAULT_SHELL_FUNCTIONS
        -:20664:#endif
        -:20665:
        -:20666:#if defined(_WIN32) && defined(IMGUI_DISABLE_WIN32_FUNCTIONS)
        -:20667:#define IMGUI_DISABLE_DEFAULT_SHELL_FUNCTIONS
        -:20668:#endif
        -:20669:#endif
        -:20670:
        -:20671:#ifndef IMGUI_DISABLE_DEFAULT_SHELL_FUNCTIONS
        -:20672:#ifdef _WIN32
        -:20673:#include <shellapi.h>   // ShellExecuteA()
        -:20674:#ifdef _MSC_VER
        -:20675:#pragma comment(lib, "shell32")
        -:20676:#endif
        -:20677:static bool Platform_OpenInShellFn_DefaultImpl(ImGuiContext*, const char* path)
        -:20678:{
        -:20679:    return (INT_PTR)::ShellExecuteA(NULL, "open", path, NULL, NULL, SW_SHOWDEFAULT) > 32;
        -:20680:}
        -:20681:#else
        -:20682:#include <sys/wait.h>
        -:20683:#include <unistd.h>
function _ZL34Platform_OpenInShellFn_DefaultImplP12ImGuiContextPKc called 0 returned 0% blocks executed 0%
    #####:20684:static bool Platform_OpenInShellFn_DefaultImpl(ImGuiContext*, const char* path)
        -:20685:{
        -:20686:#if defined(__APPLE__)
        -:20687:    const char* args[] { "open", "--", path, NULL };
        -:20688:#else
    #####:20689:    const char* args[] { "xdg-open", path, NULL };
        -:20690:#endif
    #####:20691:    pid_t pid = fork();
    %%%%%:20691-block 2
call    0 never executed
    #####:20692:    if (pid < 0)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:20693:        return false;
    %%%%%:20693-block 4
    #####:20694:    if (!pid)
    %%%%%:20694-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
        -:20695:    {
    #####:20696:        execvp(args[0], const_cast<char **>(args));
    #####:20697:        exit(-1);
    %%%%%:20697-block 6
call    0 never executed
        -:20698:    }
        -:20699:    else
        -:20700:    {
        -:20701:        int status;
    #####:20702:        waitpid(pid, &status, 0);
    %%%%%:20702-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:20703:        return WEXITSTATUS(status) == 0;
    %%%%%:20703-block 8
        -:20704:    }
        -:20705:}
        -:20706:#endif
        -:20707:#else
        -:20708:static bool Platform_OpenInShellFn_DefaultImpl(ImGuiContext*, const char*) { return false; }
        -:20709:#endif // Default shell handlers
        -:20710:
        -:20711://-----------------------------------------------------------------------------
        -:20712:
        -:20713:// Win32 API IME support (for Asian languages, etc.)
        -:20714:#if defined(_WIN32) && !defined(IMGUI_DISABLE_WIN32_FUNCTIONS) && !defined(IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS)
        -:20715:
        -:20716:#include <imm.h>
        -:20717:#ifdef _MSC_VER
        -:20718:#pragma comment(lib, "imm32")
        -:20719:#endif
        -:20720:
        -:20721:static void Platform_SetImeDataFn_DefaultImpl(ImGuiContext*, ImGuiViewport* viewport, ImGuiPlatformImeData* data)
        -:20722:{
        -:20723:    // Notify OS Input Method Editor of text input position
        -:20724:    HWND hwnd = (HWND)viewport->PlatformHandleRaw;
        -:20725:    if (hwnd == 0)
        -:20726:        return;
        -:20727:
        -:20728:    //::ImmAssociateContextEx(hwnd, NULL, data->WantVisible ? IACE_DEFAULT : 0);
        -:20729:    if (HIMC himc = ::ImmGetContext(hwnd))
        -:20730:    {
        -:20731:        COMPOSITIONFORM composition_form = {};
        -:20732:        composition_form.ptCurrentPos.x = (LONG)(data->InputPos.x - viewport->Pos.x);
        -:20733:        composition_form.ptCurrentPos.y = (LONG)(data->InputPos.y - viewport->Pos.y);
        -:20734:        composition_form.dwStyle = CFS_FORCE_POSITION;
        -:20735:        ::ImmSetCompositionWindow(himc, &composition_form);
        -:20736:        CANDIDATEFORM candidate_form = {};
        -:20737:        candidate_form.dwStyle = CFS_CANDIDATEPOS;
        -:20738:        candidate_form.ptCurrentPos.x = (LONG)(data->InputPos.x - viewport->Pos.x);
        -:20739:        candidate_form.ptCurrentPos.y = (LONG)(data->InputPos.y - viewport->Pos.y);
        -:20740:        ::ImmSetCandidateWindow(himc, &candidate_form);
        -:20741:        ::ImmReleaseContext(hwnd, himc);
        -:20742:    }
        -:20743:}
        -:20744:
        -:20745:#else
        -:20746:
function _ZL33Platform_SetImeDataFn_DefaultImplP12ImGuiContextP13ImGuiViewportP20ImGuiPlatformImeData called 0 returned 0% blocks executed 0%
    #####:20747:static void Platform_SetImeDataFn_DefaultImpl(ImGuiContext*, ImGuiViewport*, ImGuiPlatformImeData*) {}
        -:20748:
        -:20749:#endif // Default IME handlers
        -:20750:
        -:20751://-----------------------------------------------------------------------------
        -:20752:// [SECTION] METRICS/DEBUGGER WINDOW
        -:20753://-----------------------------------------------------------------------------
        -:20754:// - DebugRenderViewportThumbnail() [Internal]
        -:20755:// - RenderViewportsThumbnails() [Internal]
        -:20756:// - DebugTextEncoding()
        -:20757:// - MetricsHelpMarker() [Internal]
        -:20758:// - ShowFontAtlas() [Internal]
        -:20759:// - ShowMetricsWindow()
        -:20760:// - DebugNodeColumns() [Internal]
        -:20761:// - DebugNodeDockNode() [Internal]
        -:20762:// - DebugNodeDrawList() [Internal]
        -:20763:// - DebugNodeDrawCmdShowMeshAndBoundingBox() [Internal]
        -:20764:// - DebugNodeFont() [Internal]
        -:20765:// - DebugNodeFontGlyph() [Internal]
        -:20766:// - DebugNodeStorage() [Internal]
        -:20767:// - DebugNodeTabBar() [Internal]
        -:20768:// - DebugNodeViewport() [Internal]
        -:20769:// - DebugNodeWindow() [Internal]
        -:20770:// - DebugNodeWindowSettings() [Internal]
        -:20771:// - DebugNodeWindowsList() [Internal]
        -:20772:// - DebugNodeWindowsListByBeginStackParent() [Internal]
        -:20773://-----------------------------------------------------------------------------
        -:20774:
        -:20775:#ifndef IMGUI_DISABLE_DEBUG_TOOLS
        -:20776:
function _ZN5ImGui28DebugRenderViewportThumbnailEP10ImDrawListP14ImGuiViewportPRK6ImRect called 0 returned 0% blocks executed 0%
    #####:20777:void ImGui::DebugRenderViewportThumbnail(ImDrawList* draw_list, ImGuiViewportP* viewport, const ImRect& bb)
        -:20778:{
    #####:20779:    ImGuiContext& g = *GImGui;
    #####:20780:    ImGuiWindow* window = g.CurrentWindow;
        -:20781:
    #####:20782:    ImVec2 scale = bb.GetSize() / viewport->Size;
    %%%%%:20782-block 2
call    0 never executed
call    1 never executed
    #####:20783:    ImVec2 off = bb.Min - viewport->Pos * scale;
call    0 never executed
call    1 never executed
    #####:20784:    float alpha_mul = (viewport->Flags & ImGuiViewportFlags_IsMinimized) ? 0.30f : 1.00f;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:20784-block 7
    %%%%%:20784-block 8
    #####:20785:    window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(ImGuiCol_Border, alpha_mul * 0.40f));
    %%%%%:20785-block 9
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####:20786:    for (ImGuiWindow* thumb_window : g.Windows)
    %%%%%:20786-block 11
call    0 never executed
call    1 never executed
    %%%%%:20786-block 56
    %%%%%:20786-block 57
branch  2 never executed
branch  3 never executed (fallthrough)
        -:20787:    {
    #####:20788:        if (!thumb_window->WasActive || (thumb_window->Flags & ImGuiWindowFlags_ChildWindow))
    %%%%%:20788-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:20788-block 14
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:20789:            continue;
    %%%%%:20789-block 15
    %%%%%:20789-block 55
    #####:20790:        if (thumb_window->Viewport != viewport)
    %%%%%:20790-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:20791:            continue;
    %%%%%:20791-block 17
        -:20792:
    #####:20793:        ImRect thumb_r = thumb_window->Rect();
    %%%%%:20793-block 18
call    0 never executed
    #####:20794:        ImRect title_r = thumb_window->TitleBarRect();
call    0 never executed
    #####:20795:        thumb_r = ImRect(ImTrunc(off + thumb_r.Min * scale), ImTrunc(off +  thumb_r.Max * scale));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
    #####:20796:        title_r = ImRect(ImTrunc(off + title_r.Min * scale), ImTrunc(off +  ImVec2(title_r.Max.x, title_r.Min.y + title_r.GetHeight() * 3.0f) * scale)); // Exaggerate title bar height
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
    #####:20797:        thumb_r.ClipWithFull(bb);
call    0 never executed
    #####:20798:        title_r.ClipWithFull(bb);
call    0 never executed
    #####:20799:        const bool window_is_focused = (g.NavWindow && thumb_window->RootWindowForTitleBarHighlight == g.NavWindow->RootWindowForTitleBarHighlight);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:20799-block 39
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:20799-block 40
    %%%%%:20799-block 41
    #####:20800:        window->DrawList->AddRectFilled(thumb_r.Min, thumb_r.Max, GetColorU32(ImGuiCol_WindowBg, alpha_mul));
    %%%%%:20800-block 42
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####:20801:        window->DrawList->AddRectFilled(title_r.Min, title_r.Max, GetColorU32(window_is_focused ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBg, alpha_mul));
    %%%%%:20801-block 44
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:20801-block 45
    %%%%%:20801-block 46
    %%%%%:20801-block 47
call    2 never executed
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    #####:20802:        window->DrawList->AddRect(thumb_r.Min, thumb_r.Max, GetColorU32(ImGuiCol_Border, alpha_mul));
    %%%%%:20802-block 49
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####:20803:        window->DrawList->AddText(g.Font, g.FontSize * 1.0f, title_r.Min, GetColorU32(ImGuiCol_Text, alpha_mul), thumb_window->Name, FindRenderedTextEnd(thumb_window->Name));
    %%%%%:20803-block 51
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
        -:20804:    }
    #####:20805:    draw_list->AddRect(bb.Min, bb.Max, GetColorU32(ImGuiCol_Border, alpha_mul));
    %%%%%:20805-block 58
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####:20806:    if (viewport->ID == g.DebugMetricsConfig.HighlightViewportID)
    %%%%%:20806-block 60
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:20807:        window->DrawList->AddRect(bb.Min, bb.Max, IM_COL32(255, 255, 0, 255));
    %%%%%:20807-block 61
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:20808:}
    %%%%%:20808-block 62
        -:20809:
function _ZL25RenderViewportsThumbnailsv called 0 returned 0% blocks executed 0%
    #####:20810:static void RenderViewportsThumbnails()
        -:20811:{
    #####:20812:    ImGuiContext& g = *GImGui;
    #####:20813:    ImGuiWindow* window = g.CurrentWindow;
        -:20814:
        -:20815:    // Draw monitor and calculate their boundaries
    #####:20816:    float SCALE = 1.0f / 8.0f;
    #####:20817:    ImRect bb_full(FLT_MAX, FLT_MAX, -FLT_MAX, -FLT_MAX);
    #####:20818:    for (ImGuiPlatformMonitor& monitor : g.PlatformIO.Monitors)
    %%%%%:20818-block 2
call    0 never executed
call    1 never executed
    %%%%%:20818-block 8
branch  2 never executed
branch  3 never executed (fallthrough)
    #####:20819:        bb_full.Add(ImRect(monitor.MainPos, monitor.MainPos + monitor.MainSize));
    %%%%%:20819-block 4
call    0 never executed
call    1 never executed
call    2 never executed
    #####:20820:    ImVec2 p = window->DC.CursorPos;
    #####:20821:    ImVec2 off = p - bb_full.Min * SCALE;
    %%%%%:20821-block 9
call    0 never executed
call    1 never executed
    #####:20822:    for (ImGuiPlatformMonitor& monitor : g.PlatformIO.Monitors)
call    0 never executed
call    1 never executed
    %%%%%:20822-block 26
    %%%%%:20822-block 27
branch  2 never executed
branch  3 never executed (fallthrough)
        -:20823:    {
    #####:20824:        ImRect monitor_draw_bb(off + (monitor.MainPos) * SCALE, off + (monitor.MainPos + monitor.MainSize) * SCALE);
    %%%%%:20824-block 13
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####:20825:        window->DrawList->AddRect(monitor_draw_bb.Min, monitor_draw_bb.Max, (g.DebugMetricsConfig.HighlightMonitorIdx == g.PlatformIO.Monitors.index_from_ptr(&monitor)) ? IM_COL32(255, 255, 0, 255) : ImGui::GetColorU32(ImGuiCol_Border), 4.0f);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:20825-block 21
call    3 never executed
    %%%%%:20825-block 22
    %%%%%:20825-block 23
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    #####:20826:        window->DrawList->AddRectFilled(monitor_draw_bb.Min, monitor_draw_bb.Max, ImGui::GetColorU32(ImGuiCol_Border, 0.10f), 4.0f);
    %%%%%:20826-block 24
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
        -:20827:    }
        -:20828:
        -:20829:    // Draw viewports
    #####:20830:    for (ImGuiViewportP* viewport : g.Viewports)
    %%%%%:20830-block 28
call    0 never executed
call    1 never executed
    %%%%%:20830-block 37
    %%%%%:20830-block 38
branch  2 never executed
branch  3 never executed (fallthrough)
        -:20831:    {
    #####:20832:        ImRect viewport_draw_bb(off + (viewport->Pos) * SCALE, off + (viewport->Pos + viewport->Size) * SCALE);
    %%%%%:20832-block 30
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####:20833:        ImGui::DebugRenderViewportThumbnail(window->DrawList, viewport, viewport_draw_bb);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:20834:    }
    #####:20835:    ImGui::Dummy(bb_full.GetSize() * SCALE);
    %%%%%:20835-block 39
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    $$$$$:20835-block 45
    $$$$$:20835-block 46
    #####:20836:}
    %%%%%:20836-block 42
        -:20837:
function _ZL39ViewportComparerByLastFocusedStampCountPKvS0_ called 0 returned 0% blocks executed 0%
    #####:20838:static int IMGUI_CDECL ViewportComparerByLastFocusedStampCount(const void* lhs, const void* rhs)
        -:20839:{
    #####:20840:    const ImGuiViewportP* a = *(const ImGuiViewportP* const*)lhs;
    #####:20841:    const ImGuiViewportP* b = *(const ImGuiViewportP* const*)rhs;
    #####:20842:    return b->LastFocusedStampCount - a->LastFocusedStampCount;
    %%%%%:20842-block 2
        -:20843:}
        -:20844:
        -:20845:// Draw an arbitrary US keyboard layout to visualize translated keys
function _ZN5ImGui26DebugRenderKeyboardPreviewEP10ImDrawList called 0 returned 0% blocks executed 0%
    #####:20846:void ImGui::DebugRenderKeyboardPreview(ImDrawList* draw_list)
        -:20847:{
    #####:20848:    const float scale = ImGui::GetFontSize() / 13.0f;
    %%%%%:20848-block 2
call    0 never executed
    #####:20849:    const ImVec2 key_size = ImVec2(35.0f, 35.0f) * scale;
call    0 never executed
call    1 never executed
    #####:20850:    const float  key_rounding = 3.0f * scale;
    #####:20851:    const ImVec2 key_face_size = ImVec2(25.0f, 25.0f) * scale;
call    0 never executed
call    1 never executed
    #####:20852:    const ImVec2 key_face_pos = ImVec2(5.0f, 3.0f) * scale;
call    0 never executed
call    1 never executed
    #####:20853:    const float  key_face_rounding = 2.0f * scale;
    #####:20854:    const ImVec2 key_label_pos = ImVec2(7.0f, 4.0f) * scale;
call    0 never executed
call    1 never executed
    #####:20855:    const ImVec2 key_step = ImVec2(key_size.x - 1.0f, key_size.y - 1.0f);
call    0 never executed
    #####:20856:    const float  key_row_offset = 9.0f * scale;
        -:20857:
    #####:20858:    ImVec2 board_min = GetCursorScreenPos();
call    0 never executed
    #####:20859:    ImVec2 board_max = ImVec2(board_min.x + 3 * key_step.x + 2 * key_row_offset + 10.0f, board_min.y + 3 * key_step.y + 10.0f);
call    0 never executed
    #####:20860:    ImVec2 start_pos = ImVec2(board_min.x + 5.0f - key_step.x, board_min.y);
call    0 never executed
        -:20861:
        -:20862:    struct KeyLayoutData { int Row, Col; const char* Label; ImGuiKey Key; };
    #####:20863:    const KeyLayoutData keys_to_display[] =
        -:20864:    {
        -:20865:        { 0, 0, "", ImGuiKey_Tab },      { 0, 1, "Q", ImGuiKey_Q }, { 0, 2, "W", ImGuiKey_W }, { 0, 3, "E", ImGuiKey_E }, { 0, 4, "R", ImGuiKey_R },
        -:20866:        { 1, 0, "", ImGuiKey_CapsLock }, { 1, 1, "A", ImGuiKey_A }, { 1, 2, "S", ImGuiKey_S }, { 1, 3, "D", ImGuiKey_D }, { 1, 4, "F", ImGuiKey_F },
        -:20867:        { 2, 0, "", ImGuiKey_LeftShift },{ 2, 1, "Z", ImGuiKey_Z }, { 2, 2, "X", ImGuiKey_X }, { 2, 3, "C", ImGuiKey_C }, { 2, 4, "V", ImGuiKey_V }
        -:20868:    };
        -:20869:
        -:20870:    // Elements rendered manually via ImDrawList API are not clipped automatically.
        -:20871:    // While not strictly necessary, here IsItemVisible() is used to avoid rendering these shapes when they are out of view.
    #####:20872:    Dummy(board_max - board_min);
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$:20872-block 40
    #####:20873:    if (!IsItemVisible())
    %%%%%:20873-block 17
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:20874:        return;
    %%%%%:20874-block 19
    #####:20875:    draw_list->PushClipRect(board_min, board_max, true);
    %%%%%:20875-block 20
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:20876:    for (int n = 0; n < IM_ARRAYSIZE(keys_to_display); n++)
    %%%%%:20876-block 21
    %%%%%:20876-block 35
    %%%%%:20876-block 36
branch  0 never executed
branch  1 never executed (fallthrough)
        -:20877:    {
    #####:20878:        const KeyLayoutData* key_data = &keys_to_display[n];
    #####:20879:        ImVec2 key_min = ImVec2(start_pos.x + key_data->Col * key_step.x + key_data->Row * key_row_offset, start_pos.y + key_data->Row * key_step.y);
    %%%%%:20879-block 22
call    0 never executed
    #####:20880:        ImVec2 key_max = key_min + key_size;
call    0 never executed
    #####:20881:        draw_list->AddRectFilled(key_min, key_max, IM_COL32(204, 204, 204, 255), key_rounding);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:20882:        draw_list->AddRect(key_min, key_max, IM_COL32(24, 24, 24, 255), key_rounding);
    %%%%%:20882-block 25
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:20883:        ImVec2 face_min = ImVec2(key_min.x + key_face_pos.x, key_min.y + key_face_pos.y);
    %%%%%:20883-block 26
call    0 never executed
    #####:20884:        ImVec2 face_max = ImVec2(face_min.x + key_face_size.x, face_min.y + key_face_size.y);
call    0 never executed
    #####:20885:        draw_list->AddRect(face_min, face_max, IM_COL32(193, 193, 193, 255), key_face_rounding, ImDrawFlags_None, 2.0f);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:20886:        draw_list->AddRectFilled(face_min, face_max, IM_COL32(252, 252, 252, 255), key_face_rounding);
    %%%%%:20886-block 29
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:20887:        ImVec2 label_min = ImVec2(key_min.x + key_label_pos.x, key_min.y + key_label_pos.y);
    %%%%%:20887-block 30
call    0 never executed
    #####:20888:        draw_list->AddText(label_min, IM_COL32(64, 64, 64, 255), key_data->Label);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:20889:        if (IsKeyDown(key_data->Key))
    %%%%%:20889-block 32
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:20889-block 33
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:20890:            draw_list->AddRectFilled(key_min, key_max, IM_COL32(255, 0, 0, 128), key_rounding);
    %%%%%:20890-block 34
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:20891:    }
    #####:20892:    draw_list->PopClipRect();
    %%%%%:20892-block 37
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:20893:}
        -:20894:
        -:20895:// Helper tool to diagnose between text encoding issues and font loading issues. Pass your UTF-8 string and verify that there are correct.
function _ZN5ImGui17DebugTextEncodingEPKc called 0 returned 0% blocks executed 0%
    #####:20896:void ImGui::DebugTextEncoding(const char* str)
        -:20897:{
    #####:20898:    Text("Text: \"%s\"", str);
    %%%%%:20898-block 2
call    0 never executed
    #####:20899:    if (!BeginTable("##DebugTextEncoding", 4, ImGuiTableFlags_Borders | ImGuiTableFlags_RowBg | ImGuiTableFlags_SizingFixedFit | ImGuiTableFlags_Resizable))
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:20899-block 5
branch  4 never executed (fallthrough)
branch  5 never executed
    $$$$$:20899-block 38
call    6 never executed
    #####:20900:        return;
    %%%%%:20900-block 6
    #####:20901:    TableSetupColumn("Offset");
    %%%%%:20901-block 7
call    0 never executed
    #####:20902:    TableSetupColumn("UTF-8");
call    0 never executed
    #####:20903:    TableSetupColumn("Glyph");
call    0 never executed
    #####:20904:    TableSetupColumn("Codepoint");
call    0 never executed
    #####:20905:    TableHeadersRow();
call    0 never executed
    #####:20906:    for (const char* p = str; *p != 0; )
    %%%%%:20906-block 35
branch  0 never executed
branch  1 never executed (fallthrough)
        -:20907:    {
        -:20908:        unsigned int c;
    #####:20909:        const int c_utf8_len = ImTextCharFromUtf8(&c, p, NULL);
    %%%%%:20909-block 13
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:20910:        TableNextColumn();
    %%%%%:20910-block 14
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:20911:        Text("%d", (int)(p - str));
    %%%%%:20911-block 15
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:20912:        TableNextColumn();
    %%%%%:20912-block 16
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:20913:        for (int byte_index = 0; byte_index < c_utf8_len; byte_index++)
    %%%%%:20913-block 17
    %%%%%:20913-block 21
    %%%%%:20913-block 22
branch  0 never executed
branch  1 never executed (fallthrough)
        -:20914:        {
    #####:20915:            if (byte_index > 0)
    %%%%%:20915-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:20916:                SameLine();
    %%%%%:20916-block 19
call    0 never executed
    #####:20917:            Text("0x%02X", (int)(unsigned char)p[byte_index]);
    %%%%%:20917-block 20
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:20918:        }
    #####:20919:        TableNextColumn();
    %%%%%:20919-block 23
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:20920:        if (GetFont()->FindGlyphNoFallback((ImWchar)c))
    %%%%%:20920-block 24
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:20920-block 26
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:20921:            TextUnformatted(p, p + c_utf8_len);
    %%%%%:20921-block 27
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:20922:        else
    #####:20923:            TextUnformatted((c == IM_UNICODE_CODEPOINT_INVALID) ? "[invalid]" : "[missing]");
    %%%%%:20923-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:20923-block 29
    %%%%%:20923-block 30
    %%%%%:20923-block 31
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####:20924:        TableNextColumn();
    %%%%%:20924-block 32
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:20925:        Text("U+%04X", (int)c);
    %%%%%:20925-block 33
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:20926:        p += c_utf8_len;
    %%%%%:20926-block 34
        -:20927:    }
    #####:20928:    EndTable();
    %%%%%:20928-block 36
call    0 never executed
        -:20929:}
        -:20930:
function _ZL24DebugFlashStyleColorStopv called 0 returned 0% blocks executed 0%
    #####:20931:static void DebugFlashStyleColorStop()
        -:20932:{
    #####:20933:    ImGuiContext& g = *GImGui;
    #####:20934:    if (g.DebugFlashStyleColorIdx != ImGuiCol_COUNT)
    %%%%%:20934-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:20935:        g.Style.Colors[g.DebugFlashStyleColorIdx] = g.DebugFlashStyleColorBackup;
    %%%%%:20935-block 3
    #####:20936:    g.DebugFlashStyleColorIdx = ImGuiCol_COUNT;
    #####:20937:}
        -:20938:
        -:20939:// Flash a given style color for some + inhibit modifications of this color via PushStyleColor() calls.
function _ZN5ImGui20DebugFlashStyleColorEi called 0 returned 0% blocks executed 0%
    #####:20940:void ImGui::DebugFlashStyleColor(ImGuiCol idx)
        -:20941:{
    #####:20942:    ImGuiContext& g = *GImGui;
    #####:20943:    DebugFlashStyleColorStop();
    %%%%%:20943-block 2
call    0 never executed
    #####:20944:    g.DebugFlashStyleColorTime = 0.5f;
    #####:20945:    g.DebugFlashStyleColorIdx = idx;
    #####:20946:    g.DebugFlashStyleColorBackup = g.Style.Colors[idx];
    #####:20947:}
        -:20948:
function _ZN5ImGuiL30UpdateDebugToolFlashStyleColorEv called 1077 returned 100% blocks executed 50%
     1077:20949:void ImGui::UpdateDebugToolFlashStyleColor()
        -:20950:{
     1077:20951:    ImGuiContext& g = *GImGui;
     1077:20952:    if (g.DebugFlashStyleColorTime <= 0.0f)
     1077:20952-block 2
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:20953:        return;
     1077:20953-block 3
    #####:20954:    ColorConvertHSVtoRGB(ImCos(g.DebugFlashStyleColorTime * 6.0f) * 0.5f + 0.5f, 0.5f, 0.5f, g.Style.Colors[g.DebugFlashStyleColorIdx].x, g.Style.Colors[g.DebugFlashStyleColorIdx].y, g.Style.Colors[g.DebugFlashStyleColorIdx].z);
    %%%%%:20954-block 4
call    0 never executed
    #####:20955:    g.Style.Colors[g.DebugFlashStyleColorIdx].w = 1.0f;
    #####:20956:    if ((g.DebugFlashStyleColorTime -= g.IO.DeltaTime) <= 0.0f)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:20957:        DebugFlashStyleColorStop();
    %%%%%:20957-block 6
call    0 never executed
        -:20958:}
        -:20959:
        -:20960:// Avoid naming collision with imgui_demo.cpp's HelpMarker() for unity builds.
function _ZL17MetricsHelpMarkerPKc called 0 returned 0% blocks executed 0%
    #####:20961:static void MetricsHelpMarker(const char* desc)
        -:20962:{
    #####:20963:    ImGui::TextDisabled("(?)");
    %%%%%:20963-block 2
call    0 never executed
    #####:20964:    if (ImGui::BeginItemTooltip())
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -:20965:    {
    #####:20966:        ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);
    %%%%%:20966-block 5
call    0 never executed
call    1 never executed
    #####:20967:        ImGui::TextUnformatted(desc);
call    0 never executed
    #####:20968:        ImGui::PopTextWrapPos();
call    0 never executed
    #####:20969:        ImGui::EndTooltip();
call    0 never executed
        -:20970:    }
    #####:20971:}
        -:20972:
        -:20973:// [DEBUG] List fonts in a font atlas and display its texture
function _ZN5ImGui13ShowFontAtlasEP11ImFontAtlas called 0 returned 0% blocks executed 0%
    #####:20974:void ImGui::ShowFontAtlas(ImFontAtlas* atlas)
        -:20975:{
    #####:20976:    for (ImFont* font : atlas->Fonts)
    %%%%%:20976-block 2
call    0 never executed
call    1 never executed
    %%%%%:20976-block 8
branch  2 never executed
branch  3 never executed (fallthrough)
        -:20977:    {
    #####:20978:        PushID(font);
    %%%%%:20978-block 4
call    0 never executed
    #####:20979:        DebugNodeFont(font);
call    0 never executed
    #####:20980:        PopID();
call    0 never executed
        -:20981:    }
    #####:20982:    if (TreeNode("Font Atlas", "Font Atlas (%dx%d pixels)", atlas->TexWidth, atlas->TexHeight))
    %%%%%:20982-block 9
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -:20983:    {
    #####:20984:        ImGuiContext& g = *GImGui;
    #####:20985:        ImGuiMetricsConfig* cfg = &g.DebugMetricsConfig;
    #####:20986:        Checkbox("Tint with Text Color", &cfg->ShowAtlasTintedWithTextColor); // Using text color ensure visibility of core atlas data, but will alter custom colored icons
    %%%%%:20986-block 11
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:20987:        ImVec4 tint_col = cfg->ShowAtlasTintedWithTextColor ? GetStyleColorVec4(ImGuiCol_Text) : ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
    %%%%%:20987-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:20987-block 13
call    2 never executed
    %%%%%:20987-block 15
call    3 never executed
    #####:20988:        ImVec4 border_col = GetStyleColorVec4(ImGuiCol_Border);
    %%%%%:20988-block 16
call    0 never executed
    #####:20989:        Image(atlas->TexID, ImVec2((float)atlas->TexWidth, (float)atlas->TexHeight), ImVec2(0.0f, 0.0f), ImVec2(1.0f, 1.0f), tint_col, border_col);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    $$$$$:20989-block 24
    $$$$$:20989-block 25
    $$$$$:20989-block 26
    #####:20990:        TreePop();
    %%%%%:20990-block 21
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:20991:    }
    #####:20992:}
    %%%%%:20992-block 23
        -:20993:
function _ZN5ImGui17ShowMetricsWindowEPb called 0 returned 0% blocks executed 0%
    #####:20994:void ImGui::ShowMetricsWindow(bool* p_open)
        -:20995:{
    #####:20996:    ImGuiContext& g = *GImGui;
    #####:20997:    ImGuiIO& io = g.IO;
    #####:20998:    ImGuiMetricsConfig* cfg = &g.DebugMetricsConfig;
    #####:20999:    if (cfg->ShowDebugLog)
    %%%%%:20999-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:21000:        ShowDebugLogWindow(&cfg->ShowDebugLog);
    %%%%%:21000-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21001:    if (cfg->ShowIDStackTool)
    %%%%%:21001-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:21002:        ShowIDStackToolWindow(&cfg->ShowIDStackTool);
    %%%%%:21002-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21003:
    #####:21004:    if (!Begin("Dear ImGui Metrics/Debugger", p_open) || GetCurrentWindow()->BeginCount > 1)
    %%%%%:21004-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21004-block 7
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:21004-block 8
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%:21004-block 10
    %%%%%:21004-block 11
    %%%%%:21004-block 12
branch  8 never executed (fallthrough)
branch  9 never executed
        -:21005:    {
    #####:21006:        End();
    %%%%%:21006-block 13
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21007:        return;
    %%%%%:21007-block 14
        -:21008:    }
        -:21009:
        -:21010:    // [DEBUG] Clear debug breaks hooks after exactly one cycle.
    #####:21011:    DebugBreakClearData();
    %%%%%:21011-block 15
call    0 never executed
        -:21012:
        -:21013:    // Basic info
    #####:21014:    Text("Dear ImGui %s (%d)", IMGUI_VERSION, IMGUI_VERSION_NUM);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21015:    if (g.ContextName[0] != 0)
    %%%%%:21015-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
        -:21016:    {
    #####:21017:        SameLine();
    %%%%%:21017-block 18
call    0 never executed
    #####:21018:        Text("(Context Name: \"%s\")", g.ContextName);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21019:    }
    #####:21020:    Text("Application average %.3f ms/frame (%.1f FPS)", 1000.0f / io.Framerate, io.Framerate);
    %%%%%:21020-block 20
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21021:    Text("%d vertices, %d indices (%d triangles)", io.MetricsRenderVertices, io.MetricsRenderIndices, io.MetricsRenderIndices / 3);
    %%%%%:21021-block 21
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21022:    Text("%d visible windows, %d current allocations", io.MetricsRenderWindows, g.DebugAllocInfo.TotalAllocCount - g.DebugAllocInfo.TotalFreeCount);
    %%%%%:21022-block 22
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21023:    //SameLine(); if (SmallButton("GC")) { g.GcCompactAll = true; }
        -:21024:
    #####:21025:    Separator();
    %%%%%:21025-block 23
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21026:
        -:21027:    // Debugging enums
        -:21028:    enum { WRT_OuterRect, WRT_OuterRectClipped, WRT_InnerRect, WRT_InnerClipRect, WRT_WorkRect, WRT_Content, WRT_ContentIdeal, WRT_ContentRegionRect, WRT_Count }; // Windows Rect Type
    #####:21029:    const char* wrt_rects_names[WRT_Count] = { "OuterRect", "OuterRectClipped", "InnerRect", "InnerClipRect", "WorkRect", "Content", "ContentIdeal", "ContentRegionRect" };
        -:21030:    enum { TRT_OuterRect, TRT_InnerRect, TRT_WorkRect, TRT_HostClipRect, TRT_InnerClipRect, TRT_BackgroundClipRect, TRT_ColumnsRect, TRT_ColumnsWorkRect, TRT_ColumnsClipRect, TRT_ColumnsContentHeadersUsed, TRT_ColumnsContentHeadersIdeal, TRT_ColumnsContentFrozen, TRT_ColumnsContentUnfrozen, TRT_Count }; // Tables Rect Type
    #####:21031:    const char* trt_rects_names[TRT_Count] = { "OuterRect", "InnerRect", "WorkRect", "HostClipRect", "InnerClipRect", "BackgroundClipRect", "ColumnsRect", "ColumnsWorkRect", "ColumnsClipRect", "ColumnsContentHeadersUsed", "ColumnsContentHeadersIdeal", "ColumnsContentFrozen", "ColumnsContentUnfrozen" };
    #####:21032:    if (cfg->ShowWindowsRectsType < 0)
    %%%%%:21032-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:21033:        cfg->ShowWindowsRectsType = WRT_WorkRect;
    %%%%%:21033-block 25
    #####:21034:    if (cfg->ShowTablesRectsType < 0)
    %%%%%:21034-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:21035:        cfg->ShowTablesRectsType = TRT_WorkRect;
    %%%%%:21035-block 27
        -:21036:
        -:21037:    struct Funcs
        -:21038:    {
function _ZZN5ImGui17ShowMetricsWindowEPbEN5Funcs12GetTableRectEP10ImGuiTableii called 0 returned 0% blocks executed 0%
    #####:21039:        static ImRect GetTableRect(ImGuiTable* table, int rect_type, int n)
        -:21040:        {
    #####:21041:            ImGuiTableInstanceData* table_instance = TableGetInstanceData(table, table->InstanceCurrent); // Always using last submitted instance
    %%%%%:21041-block 2
call    0 never executed
    #####:21042:            if (rect_type == TRT_OuterRect)                     { return table->OuterRect; }
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21042-block 4
    #####:21043:            else if (rect_type == TRT_InnerRect)                { return table->InnerRect; }
    %%%%%:21043-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21043-block 6
    #####:21044:            else if (rect_type == TRT_WorkRect)                 { return table->WorkRect; }
    %%%%%:21044-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21044-block 8
    #####:21045:            else if (rect_type == TRT_HostClipRect)             { return table->HostClipRect; }
    %%%%%:21045-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21045-block 10
    #####:21046:            else if (rect_type == TRT_InnerClipRect)            { return table->InnerClipRect; }
    %%%%%:21046-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21046-block 12
    #####:21047:            else if (rect_type == TRT_BackgroundClipRect)       { return table->BgClipRect; }
    %%%%%:21047-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21047-block 14
    #####:21048:            else if (rect_type == TRT_ColumnsRect)              { ImGuiTableColumn* c = &table->Columns[n]; return ImRect(c->MinX, table->InnerClipRect.Min.y, c->MaxX, table->InnerClipRect.Min.y + table_instance->LastOuterHeight); }
    %%%%%:21048-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21048-block 16
call    2 never executed
call    3 never executed
    %%%%%:21048-block 19
    #####:21049:            else if (rect_type == TRT_ColumnsWorkRect)          { ImGuiTableColumn* c = &table->Columns[n]; return ImRect(c->WorkMinX, table->WorkRect.Min.y, c->WorkMaxX, table->WorkRect.Max.y); }
    %%%%%:21049-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21049-block 21
call    2 never executed
call    3 never executed
    %%%%%:21049-block 24
    #####:21050:            else if (rect_type == TRT_ColumnsClipRect)          { ImGuiTableColumn* c = &table->Columns[n]; return c->ClipRect; }
    %%%%%:21050-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21050-block 26
call    2 never executed
    #####:21051:            else if (rect_type == TRT_ColumnsContentHeadersUsed){ ImGuiTableColumn* c = &table->Columns[n]; return ImRect(c->WorkMinX, table->InnerClipRect.Min.y, c->ContentMaxXHeadersUsed, table->InnerClipRect.Min.y + table_instance->LastTopHeadersRowHeight); } // Note: y1/y2 not always accurate
    %%%%%:21051-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21051-block 29
call    2 never executed
call    3 never executed
    %%%%%:21051-block 32
    #####:21052:            else if (rect_type == TRT_ColumnsContentHeadersIdeal){ImGuiTableColumn* c = &table->Columns[n]; return ImRect(c->WorkMinX, table->InnerClipRect.Min.y, c->ContentMaxXHeadersIdeal, table->InnerClipRect.Min.y + table_instance->LastTopHeadersRowHeight); }
    %%%%%:21052-block 33
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21052-block 34
call    2 never executed
call    3 never executed
    %%%%%:21052-block 37
    #####:21053:            else if (rect_type == TRT_ColumnsContentFrozen)     { ImGuiTableColumn* c = &table->Columns[n]; return ImRect(c->WorkMinX, table->InnerClipRect.Min.y, c->ContentMaxXFrozen, table->InnerClipRect.Min.y + table_instance->LastFrozenHeight); }
    %%%%%:21053-block 38
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21053-block 39
call    2 never executed
call    3 never executed
    %%%%%:21053-block 42
    #####:21054:            else if (rect_type == TRT_ColumnsContentUnfrozen)   { ImGuiTableColumn* c = &table->Columns[n]; return ImRect(c->WorkMinX, table->InnerClipRect.Min.y + table_instance->LastFrozenHeight, c->ContentMaxXUnfrozen, table->InnerClipRect.Max.y); }
    %%%%%:21054-block 43
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21054-block 44
call    2 never executed
call    3 never executed
    %%%%%:21054-block 47
    #####:21055:            IM_ASSERT(0);
    %%%%%:21055-block 48
call    0 never executed
        -:21056:            return ImRect();
        -:21057:        }
        -:21058:
function _ZZN5ImGui17ShowMetricsWindowEPbEN5Funcs13GetWindowRectEP11ImGuiWindowi called 0 returned 0% blocks executed 0%
    #####:21059:        static ImRect GetWindowRect(ImGuiWindow* window, int rect_type)
        -:21060:        {
    #####:21061:            if (rect_type == WRT_OuterRect)                 { return window->Rect(); }
    %%%%%:21061-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21061-block 3
call    2 never executed
    #####:21062:            else if (rect_type == WRT_OuterRectClipped)     { return window->OuterRectClipped; }
    %%%%%:21062-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21062-block 5
    #####:21063:            else if (rect_type == WRT_InnerRect)            { return window->InnerRect; }
    %%%%%:21063-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21063-block 7
    #####:21064:            else if (rect_type == WRT_InnerClipRect)        { return window->InnerClipRect; }
    %%%%%:21064-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21064-block 9
    #####:21065:            else if (rect_type == WRT_WorkRect)             { return window->WorkRect; }
    %%%%%:21065-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21065-block 11
    #####:21066:            else if (rect_type == WRT_Content)              { ImVec2 min = window->InnerRect.Min - window->Scroll + window->WindowPadding; return ImRect(min, min + window->ContentSize); }
    %%%%%:21066-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21066-block 13
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    %%%%%:21066-block 18
    #####:21067:            else if (rect_type == WRT_ContentIdeal)         { ImVec2 min = window->InnerRect.Min - window->Scroll + window->WindowPadding; return ImRect(min, min + window->ContentSizeIdeal); }
    %%%%%:21067-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21067-block 20
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    %%%%%:21067-block 25
    #####:21068:            else if (rect_type == WRT_ContentRegionRect)    { return window->ContentRegionRect; }
    %%%%%:21068-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21068-block 27
    #####:21069:            IM_ASSERT(0);
    %%%%%:21069-block 28
call    0 never executed
        -:21070:            return ImRect();
        -:21071:        }
        -:21072:    };
        -:21073:
        -:21074:    // Tools
    #####:21075:    if (TreeNode("Tools"))
    %%%%%:21075-block 28
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21075-block 29
branch  3 never executed (fallthrough)
branch  4 never executed
        -:21076:    {
        -:21077:        // Debug Break features
        -:21078:        // The Item Picker tool is super useful to visually select an item and break into the call-stack of where it was submitted.
    #####:21079:        SeparatorTextEx(0, "Debug breaks", NULL, CalcTextSize("(?)").x + g.Style.SeparatorTextPadding.x);
    %%%%%:21079-block 30
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21079-block 31
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    #####:21080:        SameLine();
    %%%%%:21080-block 32
call    0 never executed
    #####:21081:        MetricsHelpMarker("Will call the IM_DEBUG_BREAK() macro to break in debugger.\nWarning: If you don't have a debugger attached, this will probably crash.");
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21082:        if (Checkbox("Show Item Picker", &g.DebugItemPickerActive) && g.DebugItemPickerActive)
    %%%%%:21082-block 34
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21082-block 35
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:21082-block 36
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:21082-block 37
    %%%%%:21082-block 38
    %%%%%:21082-block 39
branch  7 never executed (fallthrough)
branch  8 never executed
    #####:21083:            DebugStartItemPicker();
    %%%%%:21083-block 40
call    0 never executed
    #####:21084:        Checkbox("Show \"Debug Break\" buttons in other sections (io.ConfigDebugIsDebuggerPresent)", &g.IO.ConfigDebugIsDebuggerPresent);
    %%%%%:21084-block 41
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21085:
    #####:21086:        SeparatorText("Visualize");
    %%%%%:21086-block 42
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21087:
    #####:21088:        Checkbox("Show Debug Log", &cfg->ShowDebugLog);
    %%%%%:21088-block 43
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21089:        SameLine();
    %%%%%:21089-block 44
call    0 never executed
    #####:21090:        MetricsHelpMarker("You can also call ImGui::ShowDebugLogWindow() from your code.");
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21091:
    #####:21092:        Checkbox("Show ID Stack Tool", &cfg->ShowIDStackTool);
    %%%%%:21092-block 46
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21093:        SameLine();
    %%%%%:21093-block 47
call    0 never executed
    #####:21094:        MetricsHelpMarker("You can also call ImGui::ShowIDStackToolWindow() from your code.");
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21095:
    #####:21096:        Checkbox("Show windows begin order", &cfg->ShowWindowsBeginOrder);
    %%%%%:21096-block 49
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21097:        Checkbox("Show windows rectangles", &cfg->ShowWindowsRects);
    %%%%%:21097-block 50
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21098:        SameLine();
    %%%%%:21098-block 51
call    0 never executed
    #####:21099:        SetNextItemWidth(GetFontSize() * 12);
call    0 never executed
call    1 never executed
    #####:21100:        cfg->ShowWindowsRects |= Combo("##show_windows_rect_type", &cfg->ShowWindowsRectsType, wrt_rects_names, WRT_Count, WRT_Count);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21101:        if (cfg->ShowWindowsRects && g.NavWindow != NULL)
    %%%%%:21101-block 55
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21101-block 56
branch  2 never executed (fallthrough)
branch  3 never executed
        -:21102:        {
    #####:21103:            BulletText("'%s':", g.NavWindow->Name);
    %%%%%:21103-block 57
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21104:            Indent();
    %%%%%:21104-block 58
call    0 never executed
    #####:21105:            for (int rect_n = 0; rect_n < WRT_Count; rect_n++)
    %%%%%:21105-block 64
    %%%%%:21105-block 65
branch  0 never executed
branch  1 never executed (fallthrough)
        -:21106:            {
    #####:21107:                ImRect r = Funcs::GetWindowRect(g.NavWindow, rect_n);
    %%%%%:21107-block 60
call    0 never executed
    #####:21108:                Text("(%6.1f,%6.1f) (%6.1f,%6.1f) Size (%6.1f,%6.1f) %s", r.Min.x, r.Min.y, r.Max.x, r.Max.y, r.GetWidth(), r.GetHeight(), wrt_rects_names[rect_n]);
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
        -:21109:            }
    #####:21110:            Unindent();
    %%%%%:21110-block 66
call    0 never executed
        -:21111:        }
        -:21112:
    #####:21113:        Checkbox("Show tables rectangles", &cfg->ShowTablesRects);
    %%%%%:21113-block 67
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21114:        SameLine();
    %%%%%:21114-block 68
call    0 never executed
    #####:21115:        SetNextItemWidth(GetFontSize() * 12);
call    0 never executed
call    1 never executed
    #####:21116:        cfg->ShowTablesRects |= Combo("##show_table_rects_type", &cfg->ShowTablesRectsType, trt_rects_names, TRT_Count, TRT_Count);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21117:        if (cfg->ShowTablesRects && g.NavWindow != NULL)
    %%%%%:21117-block 72
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21117-block 73
branch  2 never executed (fallthrough)
branch  3 never executed
        -:21118:        {
    #####:21119:            for (int table_n = 0; table_n < g.Tables.GetMapSize(); table_n++)
    %%%%%:21119-block 74
    %%%%%:21119-block 135
    %%%%%:21119-block 136
call    0 never executed
branch  1 never executed
branch  2 never executed (fallthrough)
        -:21120:            {
    #####:21121:                ImGuiTable* table = g.Tables.TryGetMapData(table_n);
    %%%%%:21121-block 75
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21122:                if (table == NULL || table->LastFrameActive < g.FrameCount - 1 || (table->OuterWindow != g.NavWindow && table->InnerWindow != g.NavWindow))
    %%%%%:21122-block 76
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21122-block 77
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:21122-block 78
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:21122-block 79
branch  6 never executed (fallthrough)
branch  7 never executed
    #####:21123:                    continue;
    %%%%%:21123-block 80
        -:21124:
    #####:21125:                BulletText("Table 0x%08X (%d columns, in '%s')", table->ID, table->ColumnsCount, table->OuterWindow->Name);
    %%%%%:21125-block 81
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21126:                if (IsItemHovered())
    %%%%%:21126-block 82
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21126-block 83
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:21127:                    GetForegroundDrawList()->AddRect(table->OuterRect.Min - ImVec2(1, 1), table->OuterRect.Max + ImVec2(1, 1), IM_COL32(255, 255, 0, 255), 0.0f, 0, 2.0f);
    %%%%%:21127-block 84
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21127-block 85
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
branch  8 never executed (fallthrough)
branch  9 never executed (throw)
    %%%%%:21127-block 90
    $$$$$:21127-block 812
    $$$$$:21127-block 813
    $$$$$:21127-block 814
    $$$$$:21127-block 815
    #####:21128:                Indent();
    %%%%%:21128-block 91
call    0 never executed
        -:21129:                char buf[128];
    #####:21130:                for (int rect_n = 0; rect_n < TRT_Count; rect_n++)
    %%%%%:21130-block 131
    %%%%%:21130-block 132
branch  0 never executed
branch  1 never executed (fallthrough)
        -:21131:                {
    #####:21132:                    if (rect_n >= TRT_ColumnsRect)
    %%%%%:21132-block 93
branch  0 never executed (fallthrough)
branch  1 never executed
        -:21133:                    {
    #####:21134:                        if (rect_n != TRT_ColumnsRect && rect_n != TRT_ColumnsClipRect)
    %%%%%:21134-block 94
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21134-block 95
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:21135:                            continue;
    %%%%%:21135-block 96
    #####:21136:                        for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
    %%%%%:21136-block 97
    %%%%%:21136-block 113
    %%%%%:21136-block 114
branch  0 never executed
branch  1 never executed
        -:21137:                        {
    #####:21138:                            ImRect r = Funcs::GetTableRect(table, rect_n, column_n);
    %%%%%:21138-block 98
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21139:                            ImFormatString(buf, IM_ARRAYSIZE(buf), "(%6.1f,%6.1f) (%6.1f,%6.1f) Size (%6.1f,%6.1f) Col %d %s", r.Min.x, r.Min.y, r.Max.x, r.Max.y, r.GetWidth(), r.GetHeight(), column_n, trt_rects_names[rect_n]);
    %%%%%:21139-block 99
call    0 never executed
call    1 never executed
call    2 never executed
    #####:21140:                            Selectable(buf);
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$:21140-block 816
    #####:21141:                            if (IsItemHovered())
    %%%%%:21141-block 104
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21141-block 105
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:21142:                                GetForegroundDrawList()->AddRect(r.Min - ImVec2(1, 1), r.Max + ImVec2(1, 1), IM_COL32(255, 255, 0, 255), 0.0f, 0, 2.0f);
    %%%%%:21142-block 106
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21142-block 107
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
branch  8 never executed (fallthrough)
branch  9 never executed (throw)
    %%%%%:21142-block 112
    $$$$$:21142-block 817
    $$$$$:21142-block 818
    $$$$$:21142-block 819
    $$$$$:21142-block 820
        -:21143:                        }
        -:21144:                    }
        -:21145:                    else
        -:21146:                    {
    #####:21147:                        ImRect r = Funcs::GetTableRect(table, rect_n, -1);
    %%%%%:21147-block 115
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21148:                        ImFormatString(buf, IM_ARRAYSIZE(buf), "(%6.1f,%6.1f) (%6.1f,%6.1f) Size (%6.1f,%6.1f) %s", r.Min.x, r.Min.y, r.Max.x, r.Max.y, r.GetWidth(), r.GetHeight(), trt_rects_names[rect_n]);
    %%%%%:21148-block 116
call    0 never executed
call    1 never executed
call    2 never executed
    #####:21149:                        Selectable(buf);
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$:21149-block 822
    #####:21150:                        if (IsItemHovered())
    %%%%%:21150-block 121
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21150-block 122
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:21151:                            GetForegroundDrawList()->AddRect(r.Min - ImVec2(1, 1), r.Max + ImVec2(1, 1), IM_COL32(255, 255, 0, 255), 0.0f, 0, 2.0f);
    %%%%%:21151-block 123
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21151-block 124
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
branch  8 never executed (fallthrough)
branch  9 never executed (throw)
    %%%%%:21151-block 129
    $$$$$:21151-block 823
    $$$$$:21151-block 824
    $$$$$:21151-block 825
    $$$$$:21151-block 826
        -:21152:                    }
        -:21153:                }
    #####:21154:                Unindent();
    %%%%%:21154-block 133
call    0 never executed
        -:21155:            }
        -:21156:        }
    #####:21157:        Checkbox("Show groups rectangles", &g.DebugShowGroupRects); // Storing in context as this is used by group code and prefers to be in hot-data
    %%%%%:21157-block 138
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21158:
    #####:21159:        SeparatorText("Validate");
    %%%%%:21159-block 139
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21160:
    #####:21161:        Checkbox("Debug Begin/BeginChild return value", &io.ConfigDebugBeginReturnValueLoop);
    %%%%%:21161-block 140
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21162:        SameLine();
    %%%%%:21162-block 141
call    0 never executed
    #####:21163:        MetricsHelpMarker("Some calls to Begin()/BeginChild() will return false.\n\nWill cycle through window depths then repeat. Windows should be flickering while running.");
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21164:
    #####:21165:        Checkbox("UTF-8 Encoding viewer", &cfg->ShowTextEncodingViewer);
    %%%%%:21165-block 143
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21166:        SameLine();
    %%%%%:21166-block 144
call    0 never executed
    #####:21167:        MetricsHelpMarker("You can also call ImGui::DebugTextEncoding() from your code with a given string to test that your UTF-8 encoding settings are correct.");
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21168:        if (cfg->ShowTextEncodingViewer)
    %%%%%:21168-block 146
branch  0 never executed (fallthrough)
branch  1 never executed
        -:21169:        {
        -:21170:            static char buf[64] = "";
    #####:21171:            SetNextItemWidth(-FLT_MIN);
    %%%%%:21171-block 147
call    0 never executed
    #####:21172:            InputText("##DebugTextEncodingBuf", buf, IM_ARRAYSIZE(buf));
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21173:            if (buf[0] != 0)
    %%%%%:21173-block 149
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:21174:                DebugTextEncoding(buf);
    %%%%%:21174-block 150
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21175:        }
        -:21176:
    #####:21177:        TreePop();
    %%%%%:21177-block 151
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21178:    }
        -:21179:
        -:21180:    // Windows
    #####:21181:    if (TreeNode("Windows", "Windows (%d)", g.Windows.Size))
    %%%%%:21181-block 152
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21181-block 153
branch  3 never executed (fallthrough)
branch  4 never executed
        -:21182:    {
        -:21183:        //SetNextItemOpen(true, ImGuiCond_Once);
    #####:21184:        DebugNodeWindowsList(&g.Windows, "By display order");
    %%%%%:21184-block 154
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21185:        DebugNodeWindowsList(&g.WindowsFocusOrder, "By focus order (root windows)");
    %%%%%:21185-block 155
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21186:        if (TreeNode("By submission order (begin stack)"))
    %%%%%:21186-block 156
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21186-block 157
branch  3 never executed (fallthrough)
branch  4 never executed
        -:21187:        {
        -:21188:            // Here we display windows in their submitted order/hierarchy, however note that the Begin stack doesn't constitute a Parent<>Child relationship!
    #####:21189:            ImVector<ImGuiWindow*>& temp_buffer = g.WindowsTempSortBuffer;
    #####:21190:            temp_buffer.resize(0);
    %%%%%:21190-block 158
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21191:            for (ImGuiWindow* window : g.Windows)
    %%%%%:21191-block 159
call    0 never executed
call    1 never executed
    %%%%%:21191-block 163
    %%%%%:21191-block 164
branch  2 never executed
branch  3 never executed (fallthrough)
    #####:21192:                if (window->LastFrameActive + 1 >= g.FrameCount)
    %%%%%:21192-block 161
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:21193:                    temp_buffer.push_back(window);
    %%%%%:21193-block 162
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
function _ZZN5ImGui17ShowMetricsWindowEPbEN4Func26WindowComparerByBeginOrderEPKvS3_ called 0 returned 0% blocks executed 0%
    #####:21194:            struct Func { static int IMGUI_CDECL WindowComparerByBeginOrder(const void* lhs, const void* rhs) { return ((int)(*(const ImGuiWindow* const *)lhs)->BeginOrderWithinContext - (*(const ImGuiWindow* const*)rhs)->BeginOrderWithinContext); } };
    %%%%%:21194-block 2
    #####:21195:            ImQsort(temp_buffer.Data, (size_t)temp_buffer.Size, sizeof(ImGuiWindow*), Func::WindowComparerByBeginOrder);
    %%%%%:21195-block 165
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21196:            DebugNodeWindowsListByBeginStackParent(temp_buffer.Data, temp_buffer.Size, NULL);
    %%%%%:21196-block 166
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21197:            TreePop();
    %%%%%:21197-block 167
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21198:        }
        -:21199:
    #####:21200:        TreePop();
    %%%%%:21200-block 168
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21201:    }
        -:21202:
        -:21203:    // DrawLists
    #####:21204:    int drawlist_count = 0;
    #####:21205:    for (ImGuiViewportP* viewport : g.Viewports)
    %%%%%:21205-block 169
call    0 never executed
call    1 never executed
    %%%%%:21205-block 172
branch  2 never executed
branch  3 never executed (fallthrough)
    #####:21206:        drawlist_count += viewport->DrawDataP.CmdLists.Size;
    %%%%%:21206-block 171
    #####:21207:    if (TreeNode("DrawLists", "DrawLists (%d)", drawlist_count))
    %%%%%:21207-block 173
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21207-block 174
branch  3 never executed (fallthrough)
branch  4 never executed
        -:21208:    {
    #####:21209:        Checkbox("Show ImDrawCmd mesh when hovering", &cfg->ShowDrawCmdMesh);
    %%%%%:21209-block 175
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21210:        Checkbox("Show ImDrawCmd bounding boxes when hovering", &cfg->ShowDrawCmdBoundingBoxes);
    %%%%%:21210-block 176
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21211:        for (ImGuiViewportP* viewport : g.Viewports)
    %%%%%:21211-block 177
call    0 never executed
call    1 never executed
    %%%%%:21211-block 186
    %%%%%:21211-block 187
branch  2 never executed
branch  3 never executed (fallthrough)
        -:21212:        {
    #####:21213:            bool viewport_has_drawlist = false;
    #####:21214:            for (ImDrawList* draw_list : viewport->DrawDataP.CmdLists)
    %%%%%:21214-block 179
call    0 never executed
call    1 never executed
    %%%%%:21214-block 184
    %%%%%:21214-block 185
branch  2 never executed
branch  3 never executed (fallthrough)
        -:21215:            {
    #####:21216:                if (!viewport_has_drawlist)
    %%%%%:21216-block 181
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:21217:                    Text("Active DrawLists in Viewport #%d, ID: 0x%08X", viewport->Idx, viewport->ID);
    %%%%%:21217-block 182
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21218:                viewport_has_drawlist = true;
    #####:21219:                DebugNodeDrawList(NULL, viewport, draw_list, "DrawList");
    %%%%%:21219-block 183
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21220:            }
        -:21221:        }
    #####:21222:        TreePop();
    %%%%%:21222-block 188
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21223:    }
        -:21224:
        -:21225:    // Viewports
    #####:21226:    if (TreeNode("Viewports", "Viewports (%d)", g.Viewports.Size))
    %%%%%:21226-block 189
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21226-block 190
branch  3 never executed (fallthrough)
branch  4 never executed
        -:21227:    {
    #####:21228:        cfg->HighlightMonitorIdx = -1;
    #####:21229:        bool open = TreeNode("Monitors", "Monitors (%d)", g.PlatformIO.Monitors.Size);
    %%%%%:21229-block 191
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21230:        SameLine();
    %%%%%:21230-block 192
call    0 never executed
    #####:21231:        MetricsHelpMarker("Dear ImGui uses monitor data:\n- to query DPI settings on a per monitor basis\n- to position popup/tooltips so they don't straddle monitors.");
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21232:        if (open)
    %%%%%:21232-block 194
branch  0 never executed (fallthrough)
branch  1 never executed
        -:21233:        {
    #####:21234:            for (int i = 0; i < g.PlatformIO.Monitors.Size; i++)
    %%%%%:21234-block 195
    %%%%%:21234-block 201
    %%%%%:21234-block 202
branch  0 never executed
branch  1 never executed (fallthrough)
        -:21235:            {
    #####:21236:                DebugNodePlatformMonitor(&g.PlatformIO.Monitors[i], "Monitor", i);
    %%%%%:21236-block 196
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####:21237:                if (IsItemHovered())
    %%%%%:21237-block 198
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21237-block 199
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:21238:                    cfg->HighlightMonitorIdx = i;
    %%%%%:21238-block 200
        -:21239:            }
    #####:21240:            DebugNodePlatformMonitor(&g.FallbackMonitor, "Fallback", 0);
    %%%%%:21240-block 203
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21241:            TreePop();
    %%%%%:21241-block 204
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21242:        }
        -:21243:
    #####:21244:        SetNextItemOpen(true, ImGuiCond_Once);
    %%%%%:21244-block 205
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21245:        if (TreeNode("Windows Minimap"))
    %%%%%:21245-block 206
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21245-block 207
branch  3 never executed (fallthrough)
branch  4 never executed
        -:21246:        {
    #####:21247:            RenderViewportsThumbnails();
    %%%%%:21247-block 208
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21248:            TreePop();
    %%%%%:21248-block 209
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21249:        }
    #####:21250:        cfg->HighlightViewportID = 0;
        -:21251:
    #####:21252:        BulletText("MouseViewport: 0x%08X (UserHovered 0x%08X, LastHovered 0x%08X)", g.MouseViewport ? g.MouseViewport->ID : 0, g.IO.MouseHoveredViewport, g.MouseLastHoveredViewport ? g.MouseLastHoveredViewport->ID : 0);
    %%%%%:21252-block 210
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21252-block 211
    %%%%%:21252-block 212
    %%%%%:21252-block 213
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:21252-block 214
    %%%%%:21252-block 215
    %%%%%:21252-block 216
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    #####:21253:        if (TreeNode("Inferred Z order (front-to-back)"))
    %%%%%:21253-block 217
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21253-block 218
branch  3 never executed (fallthrough)
branch  4 never executed
        -:21254:        {
    #####:21255:            static ImVector<ImGuiViewportP*> viewports;
    %%%%%:21255-block 219
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21255-block 220
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:21255-block 222
call    5 never executed
call    6 never executed
call    7 never executed
    #####:21256:            viewports.resize(g.Viewports.Size);
    %%%%%:21256-block 225
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21257:            memcpy(viewports.Data, g.Viewports.Data, g.Viewports.size_in_bytes());
    %%%%%:21257-block 226
call    0 never executed
    #####:21258:            if (viewports.Size > 1)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:21259:                ImQsort(viewports.Data, viewports.Size, sizeof(ImGuiViewport*), ViewportComparerByLastFocusedStampCount);
    %%%%%:21259-block 228
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21260:            for (ImGuiViewportP* viewport : viewports)
    %%%%%:21260-block 229
call    0 never executed
call    1 never executed
    %%%%%:21260-block 246
    %%%%%:21260-block 247
branch  2 never executed
branch  3 never executed (fallthrough)
        -:21261:            {
    #####:21262:                BulletText("Viewport #%d, ID: 0x%08X, LastFocused = %08d, PlatformFocused = %s, Window: \"%s\"",
    %%%%%:21262-block 233
    %%%%%:21262-block 238
    %%%%%:21262-block 239
    %%%%%:21262-block 240
    %%%%%:21262-block 241
    %%%%%:21262-block 242
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21263:                    viewport->Idx, viewport->ID, viewport->LastFocusedStampCount,
    #####:21264:                    (g.PlatformIO.Platform_GetWindowFocus && viewport->PlatformWindowCreated) ? (g.PlatformIO.Platform_GetWindowFocus(viewport) ? "1" : "0") : "N/A",
    %%%%%:21264-block 234
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21264-block 235
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:21264-block 236
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    %%%%%:21264-block 237
branch  7 never executed (fallthrough)
branch  8 never executed
    #####:21265:                    viewport->Window ? viewport->Window->Name : "N/A");
    %%%%%:21265-block 231
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21265-block 232
    #####:21266:                if (IsItemHovered())
    %%%%%:21266-block 243
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21266-block 244
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:21267:                    cfg->HighlightViewportID = viewport->ID;
    %%%%%:21267-block 245
        -:21268:            }
    #####:21269:            TreePop();
    %%%%%:21269-block 248
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21270:        }
        -:21271:
    #####:21272:        for (ImGuiViewportP* viewport : g.Viewports)
    %%%%%:21272-block 249
call    0 never executed
call    1 never executed
    %%%%%:21272-block 252
    %%%%%:21272-block 253
branch  2 never executed
branch  3 never executed (fallthrough)
    #####:21273:            DebugNodeViewport(viewport);
    %%%%%:21273-block 251
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21274:        TreePop();
    %%%%%:21274-block 254
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21275:    }
        -:21276:
        -:21277:    // Details for Popups
    #####:21278:    if (TreeNode("Popups", "Popups (%d)", g.OpenPopupStack.Size))
    %%%%%:21278-block 255
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21278-block 256
branch  3 never executed (fallthrough)
branch  4 never executed
        -:21279:    {
    #####:21280:        for (const ImGuiPopupData& popup_data : g.OpenPopupStack)
    %%%%%:21280-block 257
call    0 never executed
call    1 never executed
    %%%%%:21280-block 278
    %%%%%:21280-block 279
branch  2 never executed
branch  3 never executed (fallthrough)
        -:21281:        {
        -:21282:            // As it's difficult to interact with tree nodes while popups are open, we display everything inline.
    #####:21283:            ImGuiWindow* window = popup_data.Window;
    #####:21284:            BulletText("PopupID: %08x, Window: '%s' (%s%s), RestoreNavWindow '%s', ParentWindow '%s'",
    %%%%%:21284-block 259
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21284-block 262
    %%%%%:21284-block 265
    %%%%%:21284-block 266
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:21284-block 268
    %%%%%:21284-block 269
    %%%%%:21284-block 270
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:21284-block 272
    %%%%%:21284-block 273
    %%%%%:21284-block 274
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%:21284-block 275
    %%%%%:21284-block 276
    #####:21285:                popup_data.PopupId, window ? window->Name : "NULL", window && (window->Flags & ImGuiWindowFlags_ChildWindow) ? "Child;" : "", window && (window->Flags & ImGuiWindowFlags_ChildMenu) ? "Menu;" : "",
    %%%%%:21285-block 267
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21285-block 271
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:21285-block 277
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    #####:21286:                popup_data.RestoreNavWindow ? popup_data.RestoreNavWindow->Name : "NULL", window && window->ParentWindow ? window->ParentWindow->Name : "NULL");
    %%%%%:21286-block 260
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21286-block 261
    %%%%%:21286-block 263
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:21286-block 264
        -:21287:        }
    #####:21288:        TreePop();
    %%%%%:21288-block 280
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21289:    }
        -:21290:
        -:21291:    // Details for TabBars
    #####:21292:    if (TreeNode("TabBars", "Tab Bars (%d)", g.TabBars.GetAliveCount()))
    %%%%%:21292-block 281
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:21292-block 283
branch  4 never executed (fallthrough)
branch  5 never executed
        -:21293:    {
    #####:21294:        for (int n = 0; n < g.TabBars.GetMapSize(); n++)
    %%%%%:21294-block 284
    %%%%%:21294-block 290
    %%%%%:21294-block 291
call    0 never executed
branch  1 never executed
branch  2 never executed (fallthrough)
    #####:21295:            if (ImGuiTabBar* tab_bar = g.TabBars.TryGetMapData(n))
    %%%%%:21295-block 285
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21295-block 286
branch  3 never executed (fallthrough)
branch  4 never executed
        -:21296:            {
    #####:21297:                PushID(tab_bar);
    %%%%%:21297-block 287
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21298:                DebugNodeTabBar(tab_bar, "TabBar");
    %%%%%:21298-block 288
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21299:                PopID();
    %%%%%:21299-block 289
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21300:            }
    #####:21301:        TreePop();
    %%%%%:21301-block 293
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21302:    }
        -:21303:
        -:21304:    // Details for Tables
    #####:21305:    if (TreeNode("Tables", "Tables (%d)", g.Tables.GetAliveCount()))
    %%%%%:21305-block 294
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:21305-block 296
branch  4 never executed (fallthrough)
branch  5 never executed
        -:21306:    {
    #####:21307:        for (int n = 0; n < g.Tables.GetMapSize(); n++)
    %%%%%:21307-block 297
    %%%%%:21307-block 301
    %%%%%:21307-block 302
call    0 never executed
branch  1 never executed
branch  2 never executed (fallthrough)
    #####:21308:            if (ImGuiTable* table = g.Tables.TryGetMapData(n))
    %%%%%:21308-block 298
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21308-block 299
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:21309:                DebugNodeTable(table);
    %%%%%:21309-block 300
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21310:        TreePop();
    %%%%%:21310-block 304
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21311:    }
        -:21312:
        -:21313:    // Details for Fonts
    #####:21314:    ImFontAtlas* atlas = g.IO.Fonts;
    #####:21315:    if (TreeNode("Fonts", "Fonts (%d)", atlas->Fonts.Size))
    %%%%%:21315-block 305
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21315-block 306
branch  3 never executed (fallthrough)
branch  4 never executed
        -:21316:    {
    #####:21317:        ShowFontAtlas(atlas);
    %%%%%:21317-block 307
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21318:        TreePop();
    %%%%%:21318-block 308
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21319:    }
        -:21320:
        -:21321:    // Details for InputText
    #####:21322:    if (TreeNode("InputText"))
    %%%%%:21322-block 309
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21322-block 310
branch  3 never executed (fallthrough)
branch  4 never executed
        -:21323:    {
    #####:21324:        DebugNodeInputTextState(&g.InputTextState);
    %%%%%:21324-block 311
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21325:        TreePop();
    %%%%%:21325-block 312
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21326:    }
        -:21327:
        -:21328:    // Details for TypingSelect
    #####:21329:    if (TreeNode("TypingSelect", "TypingSelect (%d)", g.TypingSelectState.SearchBuffer[0] != 0 ? 1 : 0))
    %%%%%:21329-block 313
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21329-block 314
    %%%%%:21329-block 315
    %%%%%:21329-block 316
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%:21329-block 317
branch  5 never executed (fallthrough)
branch  6 never executed
        -:21330:    {
    #####:21331:        DebugNodeTypingSelectState(&g.TypingSelectState);
    %%%%%:21331-block 318
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21332:        TreePop();
    %%%%%:21332-block 319
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21333:    }
        -:21334:
        -:21335:    // Details for MultiSelect
    #####:21336:    if (TreeNode("MultiSelect", "MultiSelect (%d)", g.MultiSelectStorage.GetAliveCount()))
    %%%%%:21336-block 320
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:21336-block 322
branch  4 never executed (fallthrough)
branch  5 never executed
        -:21337:    {
    #####:21338:        ImGuiBoxSelectState* bs = &g.BoxSelectState;
    #####:21339:        BulletText("BoxSelect ID=0x%08X, Starting = %d, Active %d", bs->ID, bs->IsStarting, bs->IsActive);
    %%%%%:21339-block 323
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21340:        for (int n = 0; n < g.MultiSelectStorage.GetMapSize(); n++)
    %%%%%:21340-block 324
    %%%%%:21340-block 328
    %%%%%:21340-block 329
call    0 never executed
branch  1 never executed
branch  2 never executed (fallthrough)
    #####:21341:            if (ImGuiMultiSelectState* state = g.MultiSelectStorage.TryGetMapData(n))
    %%%%%:21341-block 325
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21341-block 326
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:21342:                DebugNodeMultiSelectState(state);
    %%%%%:21342-block 327
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21343:        TreePop();
    %%%%%:21343-block 331
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21344:    }
        -:21345:
        -:21346:    // Details for Docking
        -:21347:#ifdef IMGUI_HAS_DOCK
    #####:21348:    if (TreeNode("Docking"))
    %%%%%:21348-block 332
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21348-block 333
branch  3 never executed (fallthrough)
branch  4 never executed
        -:21349:    {
        -:21350:        static bool root_nodes_only = true;
    #####:21351:        ImGuiDockContext* dc = &g.DockContext;
    #####:21352:        Checkbox("List root nodes", &root_nodes_only);
    %%%%%:21352-block 334
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21353:        Checkbox("Ctrl shows window dock info", &cfg->ShowDockingNodes);
    %%%%%:21353-block 335
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21354:        if (SmallButton("Clear nodes")) { DockContextClearNodes(&g, 0, true); }
    %%%%%:21354-block 336
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21354-block 337
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:21354-block 338
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
    #####:21355:        SameLine();
    %%%%%:21355-block 339
call    0 never executed
    #####:21356:        if (SmallButton("Rebuild all")) { dc->WantFullRebuild = true; }
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21356-block 341
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:21356-block 342
    #####:21357:        for (int n = 0; n < dc->Nodes.Data.Size; n++)
    %%%%%:21357-block 343
    %%%%%:21357-block 353
    %%%%%:21357-block 354
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:21358:            if (ImGuiDockNode* node = (ImGuiDockNode*)dc->Nodes.Data[n].val_p)
    %%%%%:21358-block 344
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:21359:                if (!root_nodes_only || node->IsRootNode())
    %%%%%:21359-block 346
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21359-block 347
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:21359-block 349
    %%%%%:21359-block 350
    %%%%%:21359-block 351
branch  5 never executed (fallthrough)
branch  6 never executed
    #####:21360:                    DebugNodeDockNode(node, "Node");
    %%%%%:21360-block 352
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21361:        TreePop();
    %%%%%:21361-block 355
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21362:    }
        -:21363:#endif // #ifdef IMGUI_HAS_DOCK
        -:21364:
        -:21365:    // Settings
    #####:21366:    if (TreeNode("Settings"))
    %%%%%:21366-block 356
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21366-block 357
branch  3 never executed (fallthrough)
branch  4 never executed
        -:21367:    {
    #####:21368:        if (SmallButton("Clear"))
    %%%%%:21368-block 358
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21368-block 359
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:21369:            ClearIniSettings();
    %%%%%:21369-block 360
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21370:        SameLine();
    %%%%%:21370-block 361
call    0 never executed
    #####:21371:        if (SmallButton("Save to memory"))
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21371-block 363
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:21372:            SaveIniSettingsToMemory();
    %%%%%:21372-block 364
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21373:        SameLine();
    %%%%%:21373-block 365
call    0 never executed
    #####:21374:        if (SmallButton("Save to disk"))
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21374-block 367
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:21375:            SaveIniSettingsToDisk(g.IO.IniFilename);
    %%%%%:21375-block 368
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21376:        SameLine();
    %%%%%:21376-block 369
call    0 never executed
    #####:21377:        if (g.IO.IniFilename)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:21378:            Text("\"%s\"", g.IO.IniFilename);
    %%%%%:21378-block 371
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21379:        else
    #####:21380:            TextUnformatted("<NULL>");
    %%%%%:21380-block 372
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21381:        Checkbox("io.ConfigDebugIniSettings", &io.ConfigDebugIniSettings);
    %%%%%:21381-block 373
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21382:        Text("SettingsDirtyTimer %.2f", g.SettingsDirtyTimer);
    %%%%%:21382-block 374
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21383:        if (TreeNode("SettingsHandlers", "Settings handlers: (%d)", g.SettingsHandlers.Size))
    %%%%%:21383-block 375
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21383-block 376
branch  3 never executed (fallthrough)
branch  4 never executed
        -:21384:        {
    #####:21385:            for (ImGuiSettingsHandler& handler : g.SettingsHandlers)
    %%%%%:21385-block 377
call    0 never executed
call    1 never executed
    %%%%%:21385-block 380
    %%%%%:21385-block 381
branch  2 never executed
branch  3 never executed (fallthrough)
    #####:21386:                BulletText("\"%s\"", handler.TypeName);
    %%%%%:21386-block 379
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21387:            TreePop();
    %%%%%:21387-block 382
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21388:        }
    #####:21389:        if (TreeNode("SettingsWindows", "Settings packed data: Windows: %d bytes", g.SettingsWindows.size()))
    %%%%%:21389-block 383
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:21389-block 385
branch  4 never executed (fallthrough)
branch  5 never executed
        -:21390:        {
    #####:21391:            for (ImGuiWindowSettings* settings = g.SettingsWindows.begin(); settings != NULL; settings = g.SettingsWindows.next_chunk(settings))
    %%%%%:21391-block 386
call    0 never executed
    %%%%%:21391-block 388
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:21391-block 389
    %%%%%:21391-block 390
branch  4 never executed
branch  5 never executed (fallthrough)
    #####:21392:                DebugNodeWindowSettings(settings);
    %%%%%:21392-block 387
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21393:            TreePop();
    %%%%%:21393-block 391
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21394:        }
        -:21395:
    #####:21396:        if (TreeNode("SettingsTables", "Settings packed data: Tables: %d bytes", g.SettingsTables.size()))
    %%%%%:21396-block 392
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:21396-block 394
branch  4 never executed (fallthrough)
branch  5 never executed
        -:21397:        {
    #####:21398:            for (ImGuiTableSettings* settings = g.SettingsTables.begin(); settings != NULL; settings = g.SettingsTables.next_chunk(settings))
    %%%%%:21398-block 395
call    0 never executed
    %%%%%:21398-block 397
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:21398-block 398
    %%%%%:21398-block 399
branch  4 never executed
branch  5 never executed (fallthrough)
    #####:21399:                DebugNodeTableSettings(settings);
    %%%%%:21399-block 396
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21400:            TreePop();
    %%%%%:21400-block 400
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21401:        }
        -:21402:
        -:21403:#ifdef IMGUI_HAS_DOCK
    #####:21404:        if (TreeNode("SettingsDocking", "Settings packed data: Docking"))
    %%%%%:21404-block 401
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21404-block 402
branch  3 never executed (fallthrough)
branch  4 never executed
        -:21405:        {
    #####:21406:            ImGuiDockContext* dc = &g.DockContext;
    #####:21407:            Text("In SettingsWindows:");
    %%%%%:21407-block 403
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21408:            for (ImGuiWindowSettings* settings = g.SettingsWindows.begin(); settings != NULL; settings = g.SettingsWindows.next_chunk(settings))
    %%%%%:21408-block 404
call    0 never executed
    %%%%%:21408-block 408
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:21408-block 409
    %%%%%:21408-block 410
branch  4 never executed
branch  5 never executed (fallthrough)
    #####:21409:                if (settings->DockId != 0)
    %%%%%:21409-block 405
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:21410:                    BulletText("Window '%s' -> DockId %08X DockOrder=%d", settings->GetName(), settings->DockId, settings->DockOrder);
    %%%%%:21410-block 406
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####:21411:            Text("In SettingsNodes:");
    %%%%%:21411-block 411
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21412:            for (int n = 0; n < dc->NodesSettings.Size; n++)
    %%%%%:21412-block 412
    %%%%%:21412-block 428
    %%%%%:21412-block 429
branch  0 never executed
branch  1 never executed (fallthrough)
        -:21413:            {
    #####:21414:                ImGuiDockNodeSettings* settings = &dc->NodesSettings[n];
    %%%%%:21414-block 413
call    0 never executed
    #####:21415:                const char* selected_tab_name = NULL;
    #####:21416:                if (settings->SelectedTabId)
branch  0 never executed (fallthrough)
branch  1 never executed
        -:21417:                {
    #####:21418:                    if (ImGuiWindow* window = FindWindowByID(settings->SelectedTabId))
    %%%%%:21418-block 415
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:21419:                        selected_tab_name = window->Name;
    %%%%%:21419-block 417
    #####:21420:                    else if (ImGuiWindowSettings* window_settings = FindWindowSettingsByID(settings->SelectedTabId))
    %%%%%:21420-block 418
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21420-block 419
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:21421:                        selected_tab_name = window_settings->GetName();
    %%%%%:21421-block 420
call    0 never executed
        -:21422:                }
    #####:21423:                BulletText("Node %08X, Parent %08X, SelectedTab %08X ('%s')", settings->ID, settings->ParentNodeId, settings->SelectedTabId, selected_tab_name ? selected_tab_name : settings->SelectedTabId ? "N/A" : "");
    %%%%%:21423-block 421
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21423-block 422
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:21423-block 423
    %%%%%:21423-block 424
    %%%%%:21423-block 425
    %%%%%:21423-block 426
    %%%%%:21423-block 427
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
        -:21424:            }
    #####:21425:            TreePop();
    %%%%%:21425-block 430
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21426:        }
        -:21427:#endif // #ifdef IMGUI_HAS_DOCK
        -:21428:
    #####:21429:        if (TreeNode("SettingsIniData", "Settings unpacked data (.ini): %d bytes", g.SettingsIniData.size()))
    %%%%%:21429-block 431
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:21429-block 433
branch  4 never executed (fallthrough)
branch  5 never executed
        -:21430:        {
    #####:21431:            InputTextMultiline("##Ini", (char*)(void*)g.SettingsIniData.c_str(), g.SettingsIniData.Buf.Size, ImVec2(-FLT_MIN, GetTextLineHeight() * 20), ImGuiInputTextFlags_ReadOnly);
    %%%%%:21431-block 434
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    $$$$$:21431-block 830
    #####:21432:            TreePop();
    %%%%%:21432-block 438
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21433:        }
    #####:21434:        TreePop();
    %%%%%:21434-block 439
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21435:    }
        -:21436:
        -:21437:    // Settings
    #####:21438:    if (TreeNode("Memory allocations"))
    %%%%%:21438-block 440
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21438-block 441
branch  3 never executed (fallthrough)
branch  4 never executed
        -:21439:    {
    #####:21440:        ImGuiDebugAllocInfo* info = &g.DebugAllocInfo;
    #####:21441:        Text("%d current allocations", info->TotalAllocCount - info->TotalFreeCount);
    %%%%%:21441-block 442
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21442:        if (SmallButton("GC now")) { g.GcCompactAll = true; }
    %%%%%:21442-block 443
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21442-block 444
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:21442-block 445
    #####:21443:        Text("Recent frames with allocations:");
    %%%%%:21443-block 446
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21444:        int buf_size = IM_ARRAYSIZE(info->LastEntriesBuf);
    #####:21445:        for (int n = buf_size - 1; n >= 0; n--)
    %%%%%:21445-block 447
    %%%%%:21445-block 452
    %%%%%:21445-block 453
branch  0 never executed
branch  1 never executed (fallthrough)
        -:21446:        {
    #####:21447:            ImGuiDebugAllocEntry* entry = &info->LastEntriesBuf[(info->LastEntriesIdx - n + buf_size) % buf_size];
    #####:21448:            BulletText("Frame %06d: %+3d ( %2d alloc, %2d free )", entry->FrameCount, entry->AllocCount - entry->FreeCount, entry->AllocCount, entry->FreeCount);
    %%%%%:21448-block 448
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21449:            if (n == 0)
    %%%%%:21449-block 449
branch  0 never executed (fallthrough)
branch  1 never executed
        -:21450:            {
    #####:21451:                SameLine();
    %%%%%:21451-block 450
call    0 never executed
    #####:21452:                Text("<- %d frames ago", g.FrameCount - entry->FrameCount);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21453:            }
        -:21454:        }
    #####:21455:        TreePop();
    %%%%%:21455-block 454
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21456:    }
        -:21457:
    #####:21458:    if (TreeNode("Inputs"))
    %%%%%:21458-block 455
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21458-block 456
branch  3 never executed (fallthrough)
branch  4 never executed
        -:21459:    {
    #####:21460:        Text("KEYBOARD/GAMEPAD/MOUSE KEYS");
    %%%%%:21460-block 457
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21461:        {
        -:21462:            // We iterate both legacy native range and named ImGuiKey ranges, which is a little odd but this allows displaying the data for old/new backends.
        -:21463:            // User code should never have to go through such hoops! You can generally iterate between ImGuiKey_NamedKey_BEGIN and ImGuiKey_NamedKey_END.
    #####:21464:            Indent();
    %%%%%:21464-block 458
call    0 never executed
        -:21465:#ifdef IMGUI_DISABLE_OBSOLETE_KEYIO
        -:21466:            struct funcs { static bool IsLegacyNativeDupe(ImGuiKey) { return false; } };
        -:21467:#else
function _ZZN5ImGui17ShowMetricsWindowEPbEN5funcs18IsLegacyNativeDupeE8ImGuiKey called 0 returned 0% blocks executed 0%
    #####:21468:            struct funcs { static bool IsLegacyNativeDupe(ImGuiKey key) { return key >= 0 && key < 512 && GetIO().KeyMap[key] != -1; } }; // Hide Native<>ImGuiKey duplicates when both exists in the array
    %%%%%:21468-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21468-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:21468-block 4
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:21468-block 6
    %%%%%:21468-block 7
    %%%%%:21468-block 8
        -:21469:            //Text("Legacy raw:");      for (ImGuiKey key = ImGuiKey_KeysData_OFFSET; key < ImGuiKey_COUNT; key++) { if (io.KeysDown[key]) { SameLine(); Text("\"%s\" %d", GetKeyName(key), key); } }
        -:21470:#endif
    #####:21471:            Text("Keys down:");         for (ImGuiKey key = ImGuiKey_KeysData_OFFSET; key < ImGuiKey_COUNT; key = (ImGuiKey)(key + 1)) { if (funcs::IsLegacyNativeDupe(key) || !IsKeyDown(key)) continue;     SameLine(); Text(IsNamedKey(key) ? "\"%s\"" : "\"%s\" %d", GetKeyName(key), key); SameLine(); Text("(%.02f)", GetKeyData(key)->DownDuration); }
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21471-block 460
    %%%%%:21471-block 461
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:21471-block 463
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed (throw)
    %%%%%:21471-block 464
branch  9 never executed (fallthrough)
branch 10 never executed
    %%%%%:21471-block 465
    %%%%%:21471-block 466
    %%%%%:21471-block 467
branch 11 never executed (fallthrough)
branch 12 never executed
    %%%%%:21471-block 468
    %%%%%:21471-block 469
call   13 never executed
call   14 never executed
call   15 never executed
branch 16 never executed (fallthrough)
branch 17 never executed
    %%%%%:21471-block 473
    %%%%%:21471-block 474
    %%%%%:21471-block 475
call   18 never executed
branch 19 never executed (fallthrough)
branch 20 never executed (throw)
    %%%%%:21471-block 476
call   21 never executed
call   22 never executed
branch 23 never executed (fallthrough)
branch 24 never executed (throw)
    %%%%%:21471-block 478
call   25 never executed
branch 26 never executed (fallthrough)
branch 27 never executed (throw)
    %%%%%:21471-block 479
    %%%%%:21471-block 480
branch 28 never executed
branch 29 never executed (fallthrough)
    #####:21472:            Text("Keys pressed:");      for (ImGuiKey key = ImGuiKey_KeysData_OFFSET; key < ImGuiKey_COUNT; key = (ImGuiKey)(key + 1)) { if (funcs::IsLegacyNativeDupe(key) || !IsKeyPressed(key)) continue;  SameLine(); Text(IsNamedKey(key) ? "\"%s\"" : "\"%s\" %d", GetKeyName(key), key); }
    %%%%%:21472-block 481
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21472-block 482
    %%%%%:21472-block 483
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:21472-block 485
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed (throw)
    %%%%%:21472-block 486
branch  9 never executed (fallthrough)
branch 10 never executed
    %%%%%:21472-block 487
    %%%%%:21472-block 488
    %%%%%:21472-block 489
branch 11 never executed (fallthrough)
branch 12 never executed
    %%%%%:21472-block 490
    %%%%%:21472-block 491
call   13 never executed
call   14 never executed
call   15 never executed
branch 16 never executed (fallthrough)
branch 17 never executed
    %%%%%:21472-block 495
    %%%%%:21472-block 496
    %%%%%:21472-block 497
call   18 never executed
branch 19 never executed (fallthrough)
branch 20 never executed (throw)
    %%%%%:21472-block 498
    %%%%%:21472-block 499
branch 21 never executed
branch 22 never executed (fallthrough)
    #####:21473:            Text("Keys released:");     for (ImGuiKey key = ImGuiKey_KeysData_OFFSET; key < ImGuiKey_COUNT; key = (ImGuiKey)(key + 1)) { if (funcs::IsLegacyNativeDupe(key) || !IsKeyReleased(key)) continue; SameLine(); Text(IsNamedKey(key) ? "\"%s\"" : "\"%s\" %d", GetKeyName(key), key); }
    %%%%%:21473-block 500
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21473-block 501
    %%%%%:21473-block 502
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:21473-block 504
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed (throw)
    %%%%%:21473-block 505
branch  9 never executed (fallthrough)
branch 10 never executed
    %%%%%:21473-block 506
    %%%%%:21473-block 507
    %%%%%:21473-block 508
branch 11 never executed (fallthrough)
branch 12 never executed
    %%%%%:21473-block 509
    %%%%%:21473-block 510
call   13 never executed
call   14 never executed
call   15 never executed
branch 16 never executed (fallthrough)
branch 17 never executed
    %%%%%:21473-block 514
    %%%%%:21473-block 515
    %%%%%:21473-block 516
call   18 never executed
branch 19 never executed (fallthrough)
branch 20 never executed (throw)
    %%%%%:21473-block 517
    %%%%%:21473-block 518
branch 21 never executed
branch 22 never executed (fallthrough)
    #####:21474:            Text("Keys mods: %s%s%s%s", io.KeyCtrl ? "CTRL " : "", io.KeyShift ? "SHIFT " : "", io.KeyAlt ? "ALT " : "", io.KeySuper ? "SUPER " : "");
    %%%%%:21474-block 519
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21474-block 520
    %%%%%:21474-block 521
    %%%%%:21474-block 522
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:21474-block 523
    %%%%%:21474-block 524
    %%%%%:21474-block 525
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:21474-block 526
    %%%%%:21474-block 527
    %%%%%:21474-block 528
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%:21474-block 529
    %%%%%:21474-block 530
    %%%%%:21474-block 531
call    8 never executed
branch  9 never executed (fallthrough)
branch 10 never executed (throw)
    #####:21475:            Text("Chars queue:");       for (int i = 0; i < io.InputQueueCharacters.Size; i++) { ImWchar c = io.InputQueueCharacters[i]; SameLine(); Text("\'%c\' (0x%04X)", (c > ' ' && c <= 255) ? (char)c : '?', c); } // FIXME: We should convert 'c' to UTF-8 here but the functions are not public.
    %%%%%:21475-block 532
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21475-block 533
    %%%%%:21475-block 534
call    3 never executed
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:21475-block 537
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%:21475-block 538
    %%%%%:21475-block 539
    %%%%%:21475-block 540
call    9 never executed
branch 10 never executed (fallthrough)
branch 11 never executed (throw)
    %%%%%:21475-block 541
    %%%%%:21475-block 542
branch 12 never executed
branch 13 never executed (fallthrough)
    #####:21476:            DebugRenderKeyboardPreview(GetWindowDrawList());
    %%%%%:21476-block 543
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####:21477:            Unindent();
    %%%%%:21477-block 545
call    0 never executed
        -:21478:        }
        -:21479:
    #####:21480:        Text("MOUSE STATE");
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21481:        {
    #####:21482:            Indent();
    %%%%%:21482-block 547
call    0 never executed
    #####:21483:            if (IsMousePosValid())
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:21484:                Text("Mouse pos: (%g, %g)", io.MousePos.x, io.MousePos.y);
    %%%%%:21484-block 550
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21485:            else
    #####:21486:                Text("Mouse pos: <INVALID>");
    %%%%%:21486-block 551
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21487:            Text("Mouse delta: (%g, %g)", io.MouseDelta.x, io.MouseDelta.y);
    %%%%%:21487-block 552
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21488:            int count = IM_ARRAYSIZE(io.MouseDown);
    #####:21489:            Text("Mouse down:");     for (int i = 0; i < count; i++) if (IsMouseDown(i)) { SameLine(); Text("b%d (%.02f secs)", i, io.MouseDownDuration[i]); }
    %%%%%:21489-block 553
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21489-block 554
    %%%%%:21489-block 555
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    %%%%%:21489-block 556
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%:21489-block 557
call    8 never executed
call    9 never executed
branch 10 never executed (fallthrough)
branch 11 never executed (throw)
    %%%%%:21489-block 559
    %%%%%:21489-block 560
branch 12 never executed
branch 13 never executed (fallthrough)
    #####:21490:            Text("Mouse clicked:");  for (int i = 0; i < count; i++) if (IsMouseClicked(i)) { SameLine(); Text("b%d (%d)", i, io.MouseClickedCount[i]); }
    %%%%%:21490-block 561
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21490-block 562
    %%%%%:21490-block 563
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    %%%%%:21490-block 564
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%:21490-block 565
call    8 never executed
call    9 never executed
branch 10 never executed (fallthrough)
branch 11 never executed (throw)
    %%%%%:21490-block 567
    %%%%%:21490-block 568
branch 12 never executed
branch 13 never executed (fallthrough)
    #####:21491:            Text("Mouse released:"); for (int i = 0; i < count; i++) if (IsMouseReleased(i)) { SameLine(); Text("b%d", i); }
    %%%%%:21491-block 569
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21491-block 570
    %%%%%:21491-block 571
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    %%%%%:21491-block 572
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%:21491-block 573
call    8 never executed
call    9 never executed
branch 10 never executed (fallthrough)
branch 11 never executed (throw)
    %%%%%:21491-block 575
    %%%%%:21491-block 576
branch 12 never executed
branch 13 never executed (fallthrough)
    #####:21492:            Text("Mouse wheel: %.1f", io.MouseWheel);
    %%%%%:21492-block 577
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21493:            Text("MouseStationaryTimer: %.2f", g.MouseStationaryTimer);
    %%%%%:21493-block 578
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21494:            Text("Mouse source: %s", GetMouseSourceName(io.MouseSource));
    %%%%%:21494-block 579
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####:21495:            Text("Pen Pressure: %.1f", io.PenPressure); // Note: currently unused
    %%%%%:21495-block 581
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21496:            Unindent();
    %%%%%:21496-block 582
call    0 never executed
        -:21497:        }
        -:21498:
    #####:21499:        Text("MOUSE WHEELING");
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21500:        {
    #####:21501:            Indent();
    %%%%%:21501-block 584
call    0 never executed
    #####:21502:            Text("WheelingWindow: '%s'", g.WheelingWindow ? g.WheelingWindow->Name : "NULL");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21502-block 586
    %%%%%:21502-block 587
    %%%%%:21502-block 588
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####:21503:            Text("WheelingWindowReleaseTimer: %.2f", g.WheelingWindowReleaseTimer);
    %%%%%:21503-block 589
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21504:            Text("WheelingAxisAvg[] = { %.3f, %.3f }, Main Axis: %s", g.WheelingAxisAvg.x, g.WheelingAxisAvg.y, (g.WheelingAxisAvg.x > g.WheelingAxisAvg.y) ? "X" : (g.WheelingAxisAvg.x < g.WheelingAxisAvg.y) ? "Y" : "<none>");
    %%%%%:21504-block 590
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21504-block 591
    %%%%%:21504-block 592
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:21504-block 593
    %%%%%:21504-block 594
    %%%%%:21504-block 595
    %%%%%:21504-block 596
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    #####:21505:            Unindent();
    %%%%%:21505-block 597
call    0 never executed
        -:21506:        }
        -:21507:
    #####:21508:        Text("KEY OWNERS");
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21509:        {
    #####:21510:            Indent();
    %%%%%:21510-block 599
call    0 never executed
    #####:21511:            if (BeginChild("##owners", ImVec2(-FLT_MIN, GetTextLineHeightWithSpacing() * 8), ImGuiChildFlags_FrameStyle | ImGuiChildFlags_ResizeY, ImGuiWindowFlags_NoSavedSettings))
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%:21511-block 603
branch  5 never executed (fallthrough)
branch  6 never executed
    $$$$$:21511-block 831
    #####:21512:                for (ImGuiKey key = ImGuiKey_NamedKey_BEGIN; key < ImGuiKey_NamedKey_END; key = (ImGuiKey)(key + 1))
    %%%%%:21512-block 604
    %%%%%:21512-block 617
    %%%%%:21512-block 618
branch  0 never executed
branch  1 never executed (fallthrough)
        -:21513:                {
    #####:21514:                    ImGuiKeyOwnerData* owner_data = GetKeyOwnerData(&g, key);
    %%%%%:21514-block 605
call    0 never executed
    #####:21515:                    if (owner_data->OwnerCurr == ImGuiKeyOwner_NoOwner)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:21516:                        continue;
    %%%%%:21516-block 607
    #####:21517:                    Text("%s: 0x%08X%s", GetKeyName(key), owner_data->OwnerCurr,
    %%%%%:21517-block 609
    %%%%%:21517-block 613
    %%%%%:21517-block 614
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####:21518:                        owner_data->LockUntilRelease ? " LockUntilRelease" : owner_data->LockThisFrame ? " LockThisFrame" : "");
    %%%%%:21518-block 608
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21518-block 610
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:21518-block 611
    %%%%%:21518-block 612
    #####:21519:                    DebugLocateItemOnHover(owner_data->OwnerCurr);
    %%%%%:21519-block 616
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21520:                }
    #####:21521:            EndChild();
    %%%%%:21521-block 619
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21522:            Unindent();
    %%%%%:21522-block 620
call    0 never executed
        -:21523:        }
    #####:21524:        Text("SHORTCUT ROUTING");
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21525:        SameLine();
    %%%%%:21525-block 622
call    0 never executed
    #####:21526:        MetricsHelpMarker("Declared shortcut routes automatically set key owner when mods matches.");
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21527:        {
    #####:21528:            Indent();
    %%%%%:21528-block 624
call    0 never executed
    #####:21529:            if (BeginChild("##routes", ImVec2(-FLT_MIN, GetTextLineHeightWithSpacing() * 8), ImGuiChildFlags_FrameStyle | ImGuiChildFlags_ResizeY, ImGuiWindowFlags_NoSavedSettings))
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%:21529-block 628
branch  5 never executed (fallthrough)
branch  6 never executed
    $$$$$:21529-block 832
    #####:21530:                for (ImGuiKey key = ImGuiKey_NamedKey_BEGIN; key < ImGuiKey_NamedKey_END; key = (ImGuiKey)(key + 1))
    %%%%%:21530-block 629
    %%%%%:21530-block 642
    %%%%%:21530-block 643
branch  0 never executed
branch  1 never executed (fallthrough)
        -:21531:                {
    #####:21532:                    ImGuiKeyRoutingTable* rt = &g.KeysRoutingTable;
    #####:21533:                    for (ImGuiKeyRoutingIndex idx = rt->Index[key - ImGuiKey_NamedKey_BEGIN]; idx != -1; )
    %%%%%:21533-block 630
    %%%%%:21533-block 641
branch  0 never executed
branch  1 never executed (fallthrough)
        -:21534:                    {
    #####:21535:                        ImGuiKeyRoutingData* routing_data = &rt->Entries[idx];
    %%%%%:21535-block 631
call    0 never executed
    #####:21536:                        ImGuiKeyChord key_chord = key | routing_data->Mods;
    #####:21537:                        Text("%s: 0x%08X (scored %d)", GetKeyChordName(key_chord), routing_data->RoutingCurr, routing_data->RoutingCurrScore);
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####:21538:                        DebugLocateItemOnHover(routing_data->RoutingCurr);
    %%%%%:21538-block 634
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21539:                        if (g.IO.ConfigDebugIsDebuggerPresent)
    %%%%%:21539-block 635
branch  0 never executed (fallthrough)
branch  1 never executed
        -:21540:                        {
    #####:21541:                            SameLine();
    %%%%%:21541-block 636
call    0 never executed
    #####:21542:                            if (DebugBreakButton("**DebugBreak**", "in SetShortcutRouting() for this KeyChord"))
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21542-block 638
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:21543:                                g.DebugBreakInShortcutRouting = key_chord;
    %%%%%:21543-block 639
        -:21544:                        }
    #####:21545:                        idx = routing_data->NextEntryIndex;
    %%%%%:21545-block 640
        -:21546:                    }
        -:21547:                }
    #####:21548:            EndChild();
    %%%%%:21548-block 644
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21549:            Text("(ActiveIdUsing: AllKeyboardKeys: %d, NavDirMask: 0x%X)", g.ActiveIdUsingAllKeyboardKeys, g.ActiveIdUsingNavDirMask);
    %%%%%:21549-block 645
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21550:            Unindent();
    %%%%%:21550-block 646
call    0 never executed
        -:21551:        }
    #####:21552:        TreePop();
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21553:    }
        -:21554:
    #####:21555:    if (TreeNode("Internal state"))
    %%%%%:21555-block 648
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21555-block 649
branch  3 never executed (fallthrough)
branch  4 never executed
        -:21556:    {
    #####:21557:        Text("WINDOWING");
    %%%%%:21557-block 650
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21558:        Indent();
    %%%%%:21558-block 651
call    0 never executed
    #####:21559:        Text("HoveredWindow: '%s'", g.HoveredWindow ? g.HoveredWindow->Name : "NULL");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21559-block 653
    %%%%%:21559-block 654
    %%%%%:21559-block 655
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####:21560:        Text("HoveredWindow->Root: '%s'", g.HoveredWindow ? g.HoveredWindow->RootWindowDockTree->Name : "NULL");
    %%%%%:21560-block 656
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21560-block 657
    %%%%%:21560-block 658
    %%%%%:21560-block 659
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####:21561:        Text("HoveredWindowUnderMovingWindow: '%s'", g.HoveredWindowUnderMovingWindow ? g.HoveredWindowUnderMovingWindow->Name : "NULL");
    %%%%%:21561-block 660
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21561-block 661
    %%%%%:21561-block 662
    %%%%%:21561-block 663
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####:21562:        Text("HoveredDockNode: 0x%08X", g.DebugHoveredDockNode ? g.DebugHoveredDockNode->ID : 0);
    %%%%%:21562-block 664
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21562-block 665
    %%%%%:21562-block 666
    %%%%%:21562-block 667
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####:21563:        Text("MovingWindow: '%s'", g.MovingWindow ? g.MovingWindow->Name : "NULL");
    %%%%%:21563-block 668
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21563-block 669
    %%%%%:21563-block 670
    %%%%%:21563-block 671
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####:21564:        Text("MouseViewport: 0x%08X (UserHovered 0x%08X, LastHovered 0x%08X)", g.MouseViewport->ID, g.IO.MouseHoveredViewport, g.MouseLastHoveredViewport ? g.MouseLastHoveredViewport->ID : 0);
    %%%%%:21564-block 672
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21564-block 673
    %%%%%:21564-block 674
    %%%%%:21564-block 675
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####:21565:        Unindent();
    %%%%%:21565-block 676
call    0 never executed
        -:21566:
    #####:21567:        Text("ITEMS");
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21568:        Indent();
    %%%%%:21568-block 678
call    0 never executed
    #####:21569:        Text("ActiveId: 0x%08X/0x%08X (%.2f sec), AllowOverlap: %d, Source: %s", g.ActiveId, g.ActiveIdPreviousFrame, g.ActiveIdTimer, g.ActiveIdAllowOverlap, GetInputSourceName(g.ActiveIdSource));
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####:21570:        DebugLocateItemOnHover(g.ActiveId);
    %%%%%:21570-block 681
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21571:        Text("ActiveIdWindow: '%s'", g.ActiveIdWindow ? g.ActiveIdWindow->Name : "NULL");
    %%%%%:21571-block 682
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21571-block 683
    %%%%%:21571-block 684
    %%%%%:21571-block 685
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####:21572:        Text("ActiveIdUsing: AllKeyboardKeys: %d, NavDirMask: %X", g.ActiveIdUsingAllKeyboardKeys, g.ActiveIdUsingNavDirMask);
    %%%%%:21572-block 686
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21573:        Text("HoveredId: 0x%08X (%.2f sec), AllowOverlap: %d", g.HoveredIdPreviousFrame, g.HoveredIdTimer, g.HoveredIdAllowOverlap); // Not displaying g.HoveredId as it is update mid-frame
    %%%%%:21573-block 687
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21574:        Text("HoverItemDelayId: 0x%08X, Timer: %.2f, ClearTimer: %.2f", g.HoverItemDelayId, g.HoverItemDelayTimer, g.HoverItemDelayClearTimer);
    %%%%%:21574-block 688
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21575:        Text("DragDrop: %d, SourceId = 0x%08X, Payload \"%s\" (%d bytes)", g.DragDropActive, g.DragDropPayload.SourceId, g.DragDropPayload.DataType, g.DragDropPayload.DataSize);
    %%%%%:21575-block 689
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21576:        DebugLocateItemOnHover(g.DragDropPayload.SourceId);
    %%%%%:21576-block 690
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21577:        Unindent();
    %%%%%:21577-block 691
call    0 never executed
        -:21578:
    #####:21579:        Text("NAV,FOCUS");
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21580:        Indent();
    %%%%%:21580-block 693
call    0 never executed
    #####:21581:        Text("NavWindow: '%s'", g.NavWindow ? g.NavWindow->Name : "NULL");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21581-block 695
    %%%%%:21581-block 696
    %%%%%:21581-block 697
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####:21582:        Text("NavId: 0x%08X, NavLayer: %d", g.NavId, g.NavLayer);
    %%%%%:21582-block 698
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21583:        DebugLocateItemOnHover(g.NavId);
    %%%%%:21583-block 699
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21584:        Text("NavInputSource: %s", GetInputSourceName(g.NavInputSource));
    %%%%%:21584-block 700
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####:21585:        Text("NavLastValidSelectionUserData = %" IM_PRId64 " (0x%" IM_PRIX64 ")", g.NavLastValidSelectionUserData, g.NavLastValidSelectionUserData);
    %%%%%:21585-block 702
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21586:        Text("NavActive: %d, NavVisible: %d", g.IO.NavActive, g.IO.NavVisible);
    %%%%%:21586-block 703
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21587:        Text("NavActivateId/DownId/PressedId: %08X/%08X/%08X", g.NavActivateId, g.NavActivateDownId, g.NavActivatePressedId);
    %%%%%:21587-block 704
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21588:        Text("NavActivateFlags: %04X", g.NavActivateFlags);
    %%%%%:21588-block 705
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21589:        Text("NavCursorVisible: %d, NavHighlightItemUnderNav: %d", g.NavCursorVisible, g.NavHighlightItemUnderNav);
    %%%%%:21589-block 706
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21590:        Text("NavFocusScopeId = 0x%08X", g.NavFocusScopeId);
    %%%%%:21590-block 707
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21591:        Text("NavFocusRoute[] = ");
    %%%%%:21591-block 708
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21592:        for (int path_n = g.NavFocusRoute.Size - 1; path_n >= 0; path_n--)
    %%%%%:21592-block 709
    %%%%%:21592-block 715
    %%%%%:21592-block 716
branch  0 never executed
branch  1 never executed (fallthrough)
        -:21593:        {
    #####:21594:            const ImGuiFocusScopeData& focus_scope = g.NavFocusRoute[path_n];
    %%%%%:21594-block 710
call    0 never executed
    #####:21595:            SameLine(0.0f, 0.0f);
call    0 never executed
    #####:21596:            Text("0x%08X/", focus_scope.ID);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21597:            SetItemTooltip("In window \"%s\"", FindWindowByID(focus_scope.WindowID)->Name);
    %%%%%:21597-block 713
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
        -:21598:        }
    #####:21599:        Text("NavWindowingTarget: '%s'", g.NavWindowingTarget ? g.NavWindowingTarget->Name : "NULL");
    %%%%%:21599-block 717
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21599-block 718
    %%%%%:21599-block 719
    %%%%%:21599-block 720
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####:21600:        Unindent();
    %%%%%:21600-block 721
call    0 never executed
        -:21601:
    #####:21602:        TreePop();
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21603:    }
        -:21604:
        -:21605:    // Overlay: Display windows Rectangles and Begin Order
    #####:21606:    if (cfg->ShowWindowsRects || cfg->ShowWindowsBeginOrder)
    %%%%%:21606-block 723
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21606-block 724
branch  2 never executed (fallthrough)
branch  3 never executed
        -:21607:    {
    #####:21608:        for (ImGuiWindow* window : g.Windows)
    %%%%%:21608-block 725
call    0 never executed
call    1 never executed
    %%%%%:21608-block 743
    %%%%%:21608-block 744
branch  2 never executed
branch  3 never executed (fallthrough)
        -:21609:        {
    #####:21610:            if (!window->WasActive)
    %%%%%:21610-block 727
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:21611:                continue;
    %%%%%:21611-block 728
    #####:21612:            ImDrawList* draw_list = GetForegroundDrawList(window);
    %%%%%:21612-block 729
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21613:            if (cfg->ShowWindowsRects)
    %%%%%:21613-block 730
branch  0 never executed (fallthrough)
branch  1 never executed
        -:21614:            {
    #####:21615:                ImRect r = Funcs::GetWindowRect(window, cfg->ShowWindowsRectsType);
    %%%%%:21615-block 731
call    0 never executed
    #####:21616:                draw_list->AddRect(r.Min, r.Max, IM_COL32(255, 0, 128, 255));
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21617:            }
    #####:21618:            if (cfg->ShowWindowsBeginOrder && !(window->Flags & ImGuiWindowFlags_ChildWindow))
    %%%%%:21618-block 734
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21618-block 735
branch  2 never executed (fallthrough)
branch  3 never executed
        -:21619:            {
        -:21620:                char buf[32];
    #####:21621:                ImFormatString(buf, IM_ARRAYSIZE(buf), "%d", window->BeginOrderWithinContext);
    %%%%%:21621-block 736
call    0 never executed
    #####:21622:                float font_size = GetFontSize();
call    0 never executed
    #####:21623:                draw_list->AddRectFilled(window->Pos, window->Pos + ImVec2(font_size, font_size), IM_COL32(200, 100, 100, 255));
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    $$$$$:21623-block 834
    $$$$$:21623-block 835
    #####:21624:                draw_list->AddText(window->Pos, IM_COL32(255, 255, 255, 255), buf);
    %%%%%:21624-block 741
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21625:            }
        -:21626:        }
        -:21627:    }
        -:21628:
        -:21629:    // Overlay: Display Tables Rectangles
    #####:21630:    if (cfg->ShowTablesRects)
    %%%%%:21630-block 745
branch  0 never executed (fallthrough)
branch  1 never executed
        -:21631:    {
    #####:21632:        for (int table_n = 0; table_n < g.Tables.GetMapSize(); table_n++)
    %%%%%:21632-block 746
    %%%%%:21632-block 767
    %%%%%:21632-block 768
call    0 never executed
branch  1 never executed
branch  2 never executed (fallthrough)
        -:21633:        {
    #####:21634:            ImGuiTable* table = g.Tables.TryGetMapData(table_n);
    %%%%%:21634-block 747
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21635:            if (table == NULL || table->LastFrameActive < g.FrameCount - 1)
    %%%%%:21635-block 748
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21635-block 749
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:21636:                continue;
    %%%%%:21636-block 750
    #####:21637:            ImDrawList* draw_list = GetForegroundDrawList(table->OuterWindow);
    %%%%%:21637-block 751
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21638:            if (cfg->ShowTablesRectsType >= TRT_ColumnsRect)
    %%%%%:21638-block 752
branch  0 never executed (fallthrough)
branch  1 never executed
        -:21639:            {
    #####:21640:                for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
    %%%%%:21640-block 753
    %%%%%:21640-block 762
    %%%%%:21640-block 763
branch  0 never executed
branch  1 never executed
        -:21641:                {
    #####:21642:                    ImRect r = Funcs::GetTableRect(table, cfg->ShowTablesRectsType, column_n);
    %%%%%:21642-block 754
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21643:                    ImU32 col = (table->HoveredColumnBody == column_n) ? IM_COL32(255, 255, 128, 255) : IM_COL32(255, 0, 128, 255);
    %%%%%:21643-block 755
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21643-block 756
    %%%%%:21643-block 757
    #####:21644:                    float thickness = (table->HoveredColumnBody == column_n) ? 3.0f : 1.0f;
    %%%%%:21644-block 758
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21644-block 759
    %%%%%:21644-block 760
    #####:21645:                    draw_list->AddRect(r.Min, r.Max, col, 0.0f, 0, thickness);
    %%%%%:21645-block 761
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21646:                }
        -:21647:            }
        -:21648:            else
        -:21649:            {
    #####:21650:                ImRect r = Funcs::GetTableRect(table, cfg->ShowTablesRectsType, -1);
    %%%%%:21650-block 764
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21651:                draw_list->AddRect(r.Min, r.Max, IM_COL32(255, 0, 128, 255));
    %%%%%:21651-block 765
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21652:            }
        -:21653:        }
        -:21654:    }
        -:21655:
        -:21656:#ifdef IMGUI_HAS_DOCK
        -:21657:    // Overlay: Display Docking info
    #####:21658:    if (cfg->ShowDockingNodes && g.IO.KeyCtrl && g.DebugHoveredDockNode)
    %%%%%:21658-block 770
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21658-block 771
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:21658-block 772
branch  4 never executed (fallthrough)
branch  5 never executed
        -:21659:    {
    #####:21660:        char buf[64] = "";
    #####:21661:        char* p = buf;
    #####:21662:        ImGuiDockNode* node = g.DebugHoveredDockNode;
    #####:21663:        ImDrawList* overlay_draw_list = node->HostWindow ? GetForegroundDrawList(node->HostWindow) : GetForegroundDrawList(GetMainViewport());
    %%%%%:21663-block 773
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21663-block 774
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%:21663-block 775
    %%%%%:21663-block 776
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
    %%%%%:21663-block 777
call    8 never executed
branch  9 never executed (fallthrough)
branch 10 never executed (throw)
    %%%%%:21663-block 778
    #####:21664:        p += ImFormatString(p, buf + IM_ARRAYSIZE(buf) - p, "DockId: %X%s\n", node->ID, node->IsCentralNode() ? " *CentralNode*" : "");
    %%%%%:21664-block 779
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:21664-block 781
    %%%%%:21664-block 782
    %%%%%:21664-block 783
call    3 never executed
    #####:21665:        p += ImFormatString(p, buf + IM_ARRAYSIZE(buf) - p, "WindowClass: %08X\n", node->WindowClass.ClassId);
call    0 never executed
    #####:21666:        p += ImFormatString(p, buf + IM_ARRAYSIZE(buf) - p, "Size: (%.0f, %.0f)\n", node->Size.x, node->Size.y);
call    0 never executed
    #####:21667:        p += ImFormatString(p, buf + IM_ARRAYSIZE(buf) - p, "SizeRef: (%.0f, %.0f)\n", node->SizeRef.x, node->SizeRef.y);
call    0 never executed
    #####:21668:        int depth = DockNodeGetDepth(node);
call    0 never executed
    #####:21669:        overlay_draw_list->AddRect(node->Pos + ImVec2(3, 3) * (float)depth, node->Pos + node->Size - ImVec2(3, 3) * (float)depth, IM_COL32(200, 100, 100, 255));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
branch  8 never executed (fallthrough)
branch  9 never executed (throw)
    $$$$$:21669-block 839
    $$$$$:21669-block 840
    $$$$$:21669-block 841
    $$$$$:21669-block 842
    $$$$$:21669-block 843
    $$$$$:21669-block 844
    $$$$$:21669-block 845
    #####:21670:        ImVec2 pos = node->Pos + ImVec2(3, 3) * (float)depth;
    %%%%%:21670-block 796
call    0 never executed
call    1 never executed
call    2 never executed
    #####:21671:        overlay_draw_list->AddRectFilled(pos - ImVec2(1, 1), pos + CalcTextSize(buf) + ImVec2(1, 1), IM_COL32(200, 100, 100, 255));
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:21671-block 801
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
branch  9 never executed (fallthrough)
branch 10 never executed (throw)
    $$$$$:21671-block 846
    $$$$$:21671-block 847
    $$$$$:21671-block 848
    $$$$$:21671-block 849
    $$$$$:21671-block 850
    $$$$$:21671-block 851
    #####:21672:        overlay_draw_list->AddText(NULL, 0.0f, pos, IM_COL32(255, 255, 255, 255), buf);
    %%%%%:21672-block 806
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21673:    }
        -:21674:#endif // #ifdef IMGUI_HAS_DOCK
        -:21675:
    #####:21676:    End();
    %%%%%:21676-block 808
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21677:}
        -:21678:
function _ZN5ImGui19DebugBreakClearDataEv called 0 returned 0% blocks executed 0%
    #####:21679:void ImGui::DebugBreakClearData()
        -:21680:{
        -:21681:    // Those fields are scattered in their respective subsystem to stay in hot-data locations
    #####:21682:    ImGuiContext& g = *GImGui;
    #####:21683:    g.DebugBreakInWindow = 0;
    #####:21684:    g.DebugBreakInTable = 0;
    #####:21685:    g.DebugBreakInShortcutRouting = ImGuiKey_None;
    #####:21686:}
        -:21687:
function _ZN5ImGui23DebugBreakButtonTooltipEbPKc called 0 returned 0% blocks executed 0%
    #####:21688:void ImGui::DebugBreakButtonTooltip(bool keyboard_only, const char* description_of_location)
        -:21689:{
    #####:21690:    if (!BeginItemTooltip())
    %%%%%:21690-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:21691:        return;
    %%%%%:21691-block 4
    #####:21692:    Text("To call IM_DEBUG_BREAK() %s:", description_of_location);
    %%%%%:21692-block 5
call    0 never executed
    #####:21693:    Separator();
call    0 never executed
    #####:21694:    TextUnformatted(keyboard_only ? "- Press 'Pause/Break' on keyboard." : "- Press 'Pause/Break' on keyboard.\n- or Click (may alter focus/active id).\n- or navigate using keyboard and press space.");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21694-block 8
    %%%%%:21694-block 9
    %%%%%:21694-block 10
call    2 never executed
    #####:21695:    Separator();
call    0 never executed
    #####:21696:    TextUnformatted("Choose one way that doesn't interfere with what you are trying to debug!\nYou need a debugger attached or this will crash!");
call    0 never executed
    #####:21697:    EndTooltip();
call    0 never executed
        -:21698:}
        -:21699:
        -:21700:// Special button that doesn't take focus, doesn't take input owner, and can be activated without a click etc.
        -:21701:// In order to reduce interferences with the contents we are trying to debug into.
function _ZN5ImGui16DebugBreakButtonEPKcS1_ called 0 returned 0% blocks executed 0%
    #####:21702:bool ImGui::DebugBreakButton(const char* label, const char* description_of_location)
        -:21703:{
    #####:21704:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%:21704-block 2
call    0 never executed
    #####:21705:    if (window->SkipItems)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:21706:        return false;
    %%%%%:21706-block 4
        -:21707:
    #####:21708:    ImGuiContext& g = *GImGui;
    #####:21709:    const ImGuiID id = window->GetID(label);
    %%%%%:21709-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21710:    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    %%%%%:21710-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21711:    ImVec2 pos = window->DC.CursorPos + ImVec2(0.0f, window->DC.CurrLineTextBaseOffset);
    %%%%%:21711-block 7
call    0 never executed
call    1 never executed
    #####:21712:    ImVec2 size = ImVec2(label_size.x + g.Style.FramePadding.x * 2.0f, label_size.y);
call    0 never executed
        -:21713:
    #####:21714:    const ImRect bb(pos, pos + size);
call    0 never executed
call    1 never executed
    #####:21715:    ItemSize(size, 0.0f);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21716:    if (!ItemAdd(bb, id))
    %%%%%:21716-block 13
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21716-block 14
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:21717:        return false;
    %%%%%:21717-block 15
        -:21718:
        -:21719:    // WE DO NOT USE ButtonEx() or ButtonBehavior() in order to reduce our side-effects.
    #####:21720:    bool hovered = ItemHoverable(bb, id, g.CurrentItemFlags);
    %%%%%:21720-block 16
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21721:    bool pressed = hovered && (IsKeyChordPressed(g.DebugBreakKeyChord) || IsMouseClicked(0) || g.NavActivateId == id);
    %%%%%:21721-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21721-block 18
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%:21721-block 19
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:21721-block 20
call    7 never executed
branch  8 never executed (fallthrough)
branch  9 never executed (throw)
    %%%%%:21721-block 21
branch 10 never executed (fallthrough)
branch 11 never executed
    %%%%%:21721-block 22
branch 12 never executed (fallthrough)
branch 13 never executed
    %%%%%:21721-block 23
    %%%%%:21721-block 24
    #####:21722:    DebugBreakButtonTooltip(false, description_of_location);
    %%%%%:21722-block 25
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21723:
    #####:21724:    ImVec4 col4f = GetStyleColorVec4(hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);
    %%%%%:21724-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21724-block 27
    %%%%%:21724-block 28
    %%%%%:21724-block 29
call    2 never executed
    #####:21725:    ImVec4 hsv;
    #####:21726:    ColorConvertRGBtoHSV(col4f.x, col4f.y, col4f.z, hsv.x, hsv.y, hsv.z);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21727:    ColorConvertHSVtoRGB(hsv.x + 0.20f, hsv.y, hsv.z, col4f.x, col4f.y, col4f.z);
    %%%%%:21727-block 31
call    0 never executed
        -:21728:
    #####:21729:    RenderNavCursor(bb, id);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21730:    RenderFrame(bb.Min, bb.Max, GetColorU32(col4f), true, g.Style.FrameRounding);
    %%%%%:21730-block 33
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####:21731:    RenderTextClipped(bb.Min, bb.Max, label, NULL, &label_size, g.Style.ButtonTextAlign, &bb);
    %%%%%:21731-block 35
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21732:
        -:21733:    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags);
    #####:21734:    return pressed;
    %%%%%:21734-block 36
        -:21735:}
        -:21736:
        -:21737:// [DEBUG] Display contents of Columns
function _ZN5ImGui16DebugNodeColumnsEP15ImGuiOldColumns called 0 returned 0% blocks executed 0%
    #####:21738:void ImGui::DebugNodeColumns(ImGuiOldColumns* columns)
        -:21739:{
    #####:21740:    if (!TreeNode((void*)(uintptr_t)columns->ID, "Columns Id: 0x%08X, Count: %d, Flags: 0x%04X", columns->ID, columns->Count, columns->Flags))
    %%%%%:21740-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:21741:        return;
    %%%%%:21741-block 4
    #####:21742:    BulletText("Width: %.1f (MinX: %.1f, MaxX: %.1f)", columns->OffMaxX - columns->OffMinX, columns->OffMinX, columns->OffMaxX);
    %%%%%:21742-block 5
call    0 never executed
    #####:21743:    for (ImGuiOldColumnData& column : columns->Columns)
call    0 never executed
call    1 never executed
    %%%%%:21743-block 12
branch  2 never executed
branch  3 never executed (fallthrough)
    #####:21744:        BulletText("Column %02d: OffsetNorm %.3f (= %.1f px)", (int)columns->Columns.index_from_ptr(&column), column.OffsetNorm, GetColumnOffsetFromNorm(columns, column.OffsetNorm));
    %%%%%:21744-block 8
call    0 never executed
call    1 never executed
call    2 never executed
    #####:21745:    TreePop();
    %%%%%:21745-block 13
call    0 never executed
        -:21746:}
        -:21747:
function _ZL22DebugNodeDockNodeFlagsPiPKcb called 0 returned 0% blocks executed 0%
    #####:21748:static void DebugNodeDockNodeFlags(ImGuiDockNodeFlags* p_flags, const char* label, bool enabled)
        -:21749:{
        -:21750:    using namespace ImGui;
    #####:21751:    PushID(label);
    %%%%%:21751-block 2
call    0 never executed
    #####:21752:    PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0.0f, 0.0f));
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####:21753:    Text("%s:", label);
    %%%%%:21753-block 5
call    0 never executed
    #####:21754:    if (!enabled)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:21755:        BeginDisabled();
    %%%%%:21755-block 7
call    0 never executed
    #####:21756:    CheckboxFlags("NoResize", p_flags, ImGuiDockNodeFlags_NoResize);
    %%%%%:21756-block 8
call    0 never executed
    #####:21757:    CheckboxFlags("NoResizeX", p_flags, ImGuiDockNodeFlags_NoResizeX);
call    0 never executed
    #####:21758:    CheckboxFlags("NoResizeY",p_flags, ImGuiDockNodeFlags_NoResizeY);
call    0 never executed
    #####:21759:    CheckboxFlags("NoTabBar", p_flags, ImGuiDockNodeFlags_NoTabBar);
call    0 never executed
    #####:21760:    CheckboxFlags("HiddenTabBar", p_flags, ImGuiDockNodeFlags_HiddenTabBar);
call    0 never executed
    #####:21761:    CheckboxFlags("NoWindowMenuButton", p_flags, ImGuiDockNodeFlags_NoWindowMenuButton);
call    0 never executed
    #####:21762:    CheckboxFlags("NoCloseButton", p_flags, ImGuiDockNodeFlags_NoCloseButton);
call    0 never executed
    #####:21763:    CheckboxFlags("DockedWindowsInFocusRoute", p_flags, ImGuiDockNodeFlags_DockedWindowsInFocusRoute);
call    0 never executed
    #####:21764:    CheckboxFlags("NoDocking", p_flags, ImGuiDockNodeFlags_NoDocking); // Multiple flags
call    0 never executed
    #####:21765:    CheckboxFlags("NoDockingSplit", p_flags, ImGuiDockNodeFlags_NoDockingSplit);
call    0 never executed
    #####:21766:    CheckboxFlags("NoDockingSplitOther", p_flags, ImGuiDockNodeFlags_NoDockingSplitOther);
call    0 never executed
    #####:21767:    CheckboxFlags("NoDockingOver", p_flags, ImGuiDockNodeFlags_NoDockingOverMe);
call    0 never executed
    #####:21768:    CheckboxFlags("NoDockingOverOther", p_flags, ImGuiDockNodeFlags_NoDockingOverOther);
call    0 never executed
    #####:21769:    CheckboxFlags("NoDockingOverEmpty", p_flags, ImGuiDockNodeFlags_NoDockingOverEmpty);
call    0 never executed
    #####:21770:    CheckboxFlags("NoUndocking", p_flags, ImGuiDockNodeFlags_NoUndocking);
call    0 never executed
    #####:21771:    if (!enabled)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:21772:        EndDisabled();
    %%%%%:21772-block 24
call    0 never executed
    #####:21773:    PopStyleVar();
    %%%%%:21773-block 25
call    0 never executed
    #####:21774:    PopID();
call    0 never executed
    #####:21775:}
        -:21776:
        -:21777:// [DEBUG] Display contents of ImDockNode
function _ZN5ImGui17DebugNodeDockNodeEP13ImGuiDockNodePKc called 0 returned 0% blocks executed 0%
    #####:21778:void ImGui::DebugNodeDockNode(ImGuiDockNode* node, const char* label)
        -:21779:{
    #####:21780:    ImGuiContext& g = *GImGui;
    #####:21781:    const bool is_alive = (g.FrameCount - node->LastFrameAlive < 2);    // Submitted with ImGuiDockNodeFlags_KeepAliveOnly
    #####:21782:    const bool is_active = (g.FrameCount - node->LastFrameActive < 2);  // Submitted
    #####:21783:    if (!is_alive) { PushStyleColor(ImGuiCol_Text, GetStyleColorVec4(ImGuiCol_TextDisabled)); }
    %%%%%:21783-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21783-block 3
call    2 never executed
call    3 never executed
        -:21784:    bool open;
    #####:21785:    ImGuiTreeNodeFlags tree_node_flags = node->IsFocused ? ImGuiTreeNodeFlags_Selected : ImGuiTreeNodeFlags_None;
    %%%%%:21785-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21785-block 6
    %%%%%:21785-block 7
    #####:21786:    if (node->Windows.Size > 0)
    %%%%%:21786-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:21787:        open = TreeNodeEx((void*)(intptr_t)node->ID, tree_node_flags, "%s 0x%04X%s: %d windows (vis: '%s')", label, node->ID, node->IsVisible ? "" : " (hidden)", node->Windows.Size, node->VisibleWindow ? node->VisibleWindow->Name : "NULL");
    %%%%%:21787-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21787-block 10
    %%%%%:21787-block 11
    %%%%%:21787-block 12
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:21787-block 13
    %%%%%:21787-block 14
    %%%%%:21787-block 15
call    4 never executed
        -:21788:    else
    #####:21789:        open = TreeNodeEx((void*)(intptr_t)node->ID, tree_node_flags, "%s 0x%04X%s: %s (vis: '%s')", label, node->ID, node->IsVisible ? "" : " (hidden)", (node->SplitAxis == ImGuiAxis_X) ? "horizontal split" : (node->SplitAxis == ImGuiAxis_Y) ? "vertical split" : "empty", node->VisibleWindow ? node->VisibleWindow->Name : "NULL");
    %%%%%:21789-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21789-block 18
    %%%%%:21789-block 19
    %%%%%:21789-block 20
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:21789-block 21
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:21789-block 22
    %%%%%:21789-block 23
    %%%%%:21789-block 24
    %%%%%:21789-block 25
    %%%%%:21789-block 26
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%:21789-block 27
    %%%%%:21789-block 28
    %%%%%:21789-block 29
call    8 never executed
    #####:21790:    if (!is_alive) { PopStyleColor(); }
    %%%%%:21790-block 31
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21790-block 32
call    2 never executed
    #####:21791:    if (is_active && IsItemHovered())
    %%%%%:21791-block 33
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21791-block 34
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:21791-block 36
    %%%%%:21791-block 37
    %%%%%:21791-block 38
branch  5 never executed (fallthrough)
branch  6 never executed
    #####:21792:        if (ImGuiWindow* window = node->HostWindow ? node->HostWindow : node->VisibleWindow)
    %%%%%:21792-block 39
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21792-block 40
    %%%%%:21792-block 41
    %%%%%:21792-block 42
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:21793:            GetForegroundDrawList(window)->AddRect(node->Pos, node->Pos + node->Size, IM_COL32(255, 255, 0, 255));
    %%%%%:21793-block 43
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%:21793-block 46
    $$$$$:21793-block 108
call    5 never executed
    #####:21794:    if (open)
    %%%%%:21794-block 47
branch  0 never executed (fallthrough)
branch  1 never executed
        -:21795:    {
    #####:21796:        IM_ASSERT(node->ChildNodes[0] == NULL || node->ChildNodes[0]->ParentNode == node);
    %%%%%:21796-block 48
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21796-block 49
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:21796-block 50
call    4 never executed
    #####:21797:        IM_ASSERT(node->ChildNodes[1] == NULL || node->ChildNodes[1]->ParentNode == node);
    %%%%%:21797-block 51
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21797-block 52
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:21797-block 53
call    4 never executed
    #####:21798:        BulletText("Pos (%.0f,%.0f), Size (%.0f, %.0f) Ref (%.0f, %.0f)",
    #####:21799:            node->Pos.x, node->Pos.y, node->Size.x, node->Size.y, node->SizeRef.x, node->SizeRef.y);
    %%%%%:21799-block 54
call    0 never executed
    #####:21800:        DebugNodeWindow(node->HostWindow, "HostWindow");
call    0 never executed
    #####:21801:        DebugNodeWindow(node->VisibleWindow, "VisibleWindow");
call    0 never executed
    #####:21802:        BulletText("SelectedTabID: 0x%08X, LastFocusedNodeID: 0x%08X", node->SelectedTabId, node->LastFocusedNodeId);
call    0 never executed
    #####:21803:        BulletText("Misc:%s%s%s%s%s%s%s",
    %%%%%:21803-block 59
    %%%%%:21803-block 60
    %%%%%:21803-block 62
    %%%%%:21803-block 63
    %%%%%:21803-block 65
    %%%%%:21803-block 66
    %%%%%:21803-block 67
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21803-block 68
    %%%%%:21803-block 69
    %%%%%:21803-block 70
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:21803-block 71
    %%%%%:21803-block 72
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:21803-block 75
    %%%%%:21803-block 76
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%:21803-block 79
    %%%%%:21803-block 80
    %%%%%:21803-block 81
call    8 never executed
    #####:21804:            node->IsDockSpace() ? " IsDockSpace" : "",
    %%%%%:21804-block 77
call    0 never executed
    #####:21805:            node->IsCentralNode() ? " IsCentralNode" : "",
    %%%%%:21805-block 73
call    0 never executed
    #####:21806:            is_alive ? " IsAlive" : "", is_active ? " IsActive" : "", node->IsFocused ? " IsFocused" : "",
    %%%%%:21806-block 64
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:21807:            node->WantLockSizeOnce ? " WantLockSizeOnce" : "",
    %%%%%:21807-block 61
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:21808:            node->HasCentralNodeChild ? " HasCentralNodeChild" : "");
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:21809:        if (TreeNode("flags", "Flags Merged: 0x%04X, Local: 0x%04X, InWindows: 0x%04X, Shared: 0x%04X", node->MergedFlags, node->LocalFlags, node->LocalFlagsInWindows, node->SharedFlags))
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -:21810:        {
    #####:21811:            if (BeginTable("flags", 4))
    %%%%%:21811-block 84
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:21811-block 86
branch  4 never executed (fallthrough)
branch  5 never executed
        -:21812:            {
    #####:21813:                TableNextColumn(); DebugNodeDockNodeFlags(&node->MergedFlags, "MergedFlags", false);
    %%%%%:21813-block 87
call    0 never executed
call    1 never executed
    #####:21814:                TableNextColumn(); DebugNodeDockNodeFlags(&node->LocalFlags, "LocalFlags", true);
call    0 never executed
call    1 never executed
    #####:21815:                TableNextColumn(); DebugNodeDockNodeFlags(&node->LocalFlagsInWindows, "LocalFlagsInWindows", false);
call    0 never executed
call    1 never executed
    #####:21816:                TableNextColumn(); DebugNodeDockNodeFlags(&node->SharedFlags, "SharedFlags", true);
call    0 never executed
call    1 never executed
    #####:21817:                EndTable();
call    0 never executed
        -:21818:            }
    #####:21819:            TreePop();
    %%%%%:21819-block 96
call    0 never executed
        -:21820:        }
    #####:21821:        if (node->ParentNode)
    %%%%%:21821-block 97
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:21822:            DebugNodeDockNode(node->ParentNode, "ParentNode");
    %%%%%:21822-block 98
call    0 never executed
    #####:21823:        if (node->ChildNodes[0])
    %%%%%:21823-block 99
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:21824:            DebugNodeDockNode(node->ChildNodes[0], "Child[0]");
    %%%%%:21824-block 100
call    0 never executed
    #####:21825:        if (node->ChildNodes[1])
    %%%%%:21825-block 101
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:21826:            DebugNodeDockNode(node->ChildNodes[1], "Child[1]");
    %%%%%:21826-block 102
call    0 never executed
    #####:21827:        if (node->TabBar)
    %%%%%:21827-block 103
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:21828:            DebugNodeTabBar(node->TabBar, "TabBar");
    %%%%%:21828-block 104
call    0 never executed
    #####:21829:        DebugNodeWindowsList(&node->Windows, "Windows");
    %%%%%:21829-block 105
call    0 never executed
        -:21830:
    #####:21831:        TreePop();
call    0 never executed
        -:21832:    }
    #####:21833:}
    %%%%%:21833-block 107
        -:21834:
function _ZL30FormatTextureIDForDebugDisplayPciy called 0 returned 0% blocks executed 0%
    #####:21835:static void FormatTextureIDForDebugDisplay(char* buf, int buf_size, ImTextureID tex_id)
        -:21836:{
        -:21837:    union { void* ptr; int integer; } tex_id_opaque;
    #####:21838:    memcpy(&tex_id_opaque, &tex_id, ImMin(sizeof(void*), sizeof(tex_id)));
    %%%%%:21838-block 2
call    0 never executed
        -:21839:    if (sizeof(tex_id) >= sizeof(void*))
    #####:21840:        ImFormatString(buf, buf_size, "0x%p", tex_id_opaque.ptr);
    %%%%%:21840-block 4
call    0 never executed
        -:21841:    else
        -:21842:        ImFormatString(buf, buf_size, "0x%04X", tex_id_opaque.integer);
    #####:21843:}
        -:21844:
        -:21845:// [DEBUG] Display contents of ImDrawList
        -:21846:// Note that both 'window' and 'viewport' may be NULL here. Viewport is generally null of destroyed popups which previously owned a viewport.
function _ZN5ImGui17DebugNodeDrawListEP11ImGuiWindowP14ImGuiViewportPPK10ImDrawListPKc called 0 returned 0% blocks executed 0%
    #####:21847:void ImGui::DebugNodeDrawList(ImGuiWindow* window, ImGuiViewportP* viewport, const ImDrawList* draw_list, const char* label)
        -:21848:{
    #####:21849:    ImGuiContext& g = *GImGui;
    #####:21850:    ImGuiMetricsConfig* cfg = &g.DebugMetricsConfig;
    #####:21851:    int cmd_count = draw_list->CmdBuffer.Size;
    #####:21852:    if (cmd_count > 0 && draw_list->CmdBuffer.back().ElemCount == 0 && draw_list->CmdBuffer.back().UserCallback == NULL)
    %%%%%:21852-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21852-block 3
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:21852-block 5
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%:21852-block 7
    %%%%%:21852-block 8
    %%%%%:21852-block 9
branch  8 never executed (fallthrough)
branch  9 never executed
    #####:21853:        cmd_count--;
    %%%%%:21853-block 10
    #####:21854:    bool node_open = TreeNode(draw_list, "%s: '%s' %d vtx, %d indices, %d cmds", label, draw_list->_OwnerName ? draw_list->_OwnerName : "", draw_list->VtxBuffer.Size, draw_list->IdxBuffer.Size, cmd_count);
    %%%%%:21854-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21854-block 12
    %%%%%:21854-block 13
    %%%%%:21854-block 14
call    2 never executed
    #####:21855:    if (draw_list == GetWindowDrawList())
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -:21856:    {
    #####:21857:        SameLine();
    %%%%%:21857-block 17
call    0 never executed
    #####:21858:        TextColored(ImVec4(1.0f, 0.4f, 0.4f, 1.0f), "CURRENTLY APPENDING"); // Can't display stats for active draw list! (we don't have the data double-buffered)
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$:21858-block 120
call    4 never executed
    #####:21859:        if (node_open)
    %%%%%:21859-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:21860:            TreePop();
    %%%%%:21860-block 21
call    0 never executed
    #####:21861:        return;
    %%%%%:21861-block 22
        -:21862:    }
        -:21863:
    #####:21864:    ImDrawList* fg_draw_list = viewport ? GetForegroundDrawList(viewport) : NULL; // Render additional visuals into the top-most draw list
    %%%%%:21864-block 23
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21864-block 24
call    2 never executed
    %%%%%:21864-block 26
    #####:21865:    if (window && IsItemHovered() && fg_draw_list)
    %%%%%:21865-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21865-block 28
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:21865-block 30
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:21865-block 31
    %%%%%:21865-block 32
    %%%%%:21865-block 33
branch  7 never executed (fallthrough)
branch  8 never executed
    #####:21866:        fg_draw_list->AddRect(window->Pos, window->Pos + window->Size, IM_COL32(255, 255, 0, 255));
    %%%%%:21866-block 34
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:21866-block 36
    $$$$$:21866-block 121
call    4 never executed
    #####:21867:    if (!node_open)
    %%%%%:21867-block 37
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:21868:        return;
    %%%%%:21868-block 38
        -:21869:
    #####:21870:    if (window && !window->WasActive)
    %%%%%:21870-block 39
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21870-block 40
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:21871:        TextDisabled("Warning: owning Window is inactive. This DrawList is not being rendered!");
    %%%%%:21871-block 41
call    0 never executed
        -:21872:
    #####:21873:    for (const ImDrawCmd* pcmd = draw_list->CmdBuffer.Data; pcmd < draw_list->CmdBuffer.Data + cmd_count; pcmd++)
    %%%%%:21873-block 42
    %%%%%:21873-block 116
    %%%%%:21873-block 117
branch  0 never executed
branch  1 never executed (fallthrough)
        -:21874:    {
    #####:21875:        if (pcmd->UserCallback)
    %%%%%:21875-block 43
branch  0 never executed (fallthrough)
branch  1 never executed
        -:21876:        {
    #####:21877:            BulletText("Callback %p, user_data %p", pcmd->UserCallback, pcmd->UserCallbackData);
    %%%%%:21877-block 44
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21878:            continue;
    %%%%%:21878-block 45
    %%%%%:21878-block 115
        -:21879:        }
        -:21880:
        -:21881:        char texid_desc[20];
    #####:21882:        FormatTextureIDForDebugDisplay(texid_desc, IM_ARRAYSIZE(texid_desc), pcmd->TextureId);
    %%%%%:21882-block 46
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21883:        char buf[300];
    #####:21884:        ImFormatString(buf, IM_ARRAYSIZE(buf), "DrawCmd:%5d tris, Tex %s, ClipRect (%4.0f,%4.0f)-(%4.0f,%4.0f)",
    #####:21885:            pcmd->ElemCount / 3, texid_desc, pcmd->ClipRect.x, pcmd->ClipRect.y, pcmd->ClipRect.z, pcmd->ClipRect.w);
    %%%%%:21885-block 47
call    0 never executed
    #####:21886:        bool pcmd_node_open = TreeNode((void*)(pcmd - draw_list->CmdBuffer.begin()), "%s", buf);
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####:21887:        if (IsItemHovered() && (cfg->ShowDrawCmdMesh || cfg->ShowDrawCmdBoundingBoxes) && fg_draw_list)
    %%%%%:21887-block 50
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21887-block 51
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:21887-block 52
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:21887-block 53
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%:21887-block 54
branch  9 never executed (fallthrough)
branch 10 never executed
    %%%%%:21887-block 55
    %%%%%:21887-block 56
    %%%%%:21887-block 57
branch 11 never executed (fallthrough)
branch 12 never executed
    #####:21888:            DebugNodeDrawCmdShowMeshAndBoundingBox(fg_draw_list, draw_list, pcmd, cfg->ShowDrawCmdMesh, cfg->ShowDrawCmdBoundingBoxes);
    %%%%%:21888-block 58
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21889:        if (!pcmd_node_open)
    %%%%%:21889-block 59
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:21890:            continue;
    %%%%%:21890-block 60
        -:21891:
        -:21892:        // Calculate approximate coverage area (touched pixel count)
        -:21893:        // This will be in pixels squared as long there's no post-scaling happening to the renderer output.
    #####:21894:        const ImDrawIdx* idx_buffer = (draw_list->IdxBuffer.Size > 0) ? draw_list->IdxBuffer.Data : NULL;
    %%%%%:21894-block 61
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21894-block 62
    %%%%%:21894-block 63
    #####:21895:        const ImDrawVert* vtx_buffer = draw_list->VtxBuffer.Data + pcmd->VtxOffset;
    #####:21896:        float total_area = 0.0f;
    #####:21897:        for (unsigned int idx_n = pcmd->IdxOffset; idx_n < pcmd->IdxOffset + pcmd->ElemCount; )
    %%%%%:21897-block 64
    %%%%%:21897-block 73
branch  0 never executed
branch  1 never executed (fallthrough)
        -:21898:        {
    #####:21899:            ImVec2 triangle[3];
    #####:21900:            for (int n = 0; n < 3; n++, idx_n++)
    %%%%%:21900-block 65
    %%%%%:21900-block 70
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:21901:                triangle[n] = vtx_buffer[idx_buffer ? idx_buffer[idx_n] : idx_n].pos;
    %%%%%:21901-block 66
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21901-block 67
    %%%%%:21901-block 68
    %%%%%:21901-block 69
    #####:21902:            total_area += ImTriangleArea(triangle[0], triangle[1], triangle[2]);
    %%%%%:21902-block 71
call    0 never executed
        -:21903:        }
        -:21904:
        -:21905:        // Display vertex information summary. Hover to get all triangles drawn in wire-frame
    #####:21906:        ImFormatString(buf, IM_ARRAYSIZE(buf), "Mesh: ElemCount: %d, VtxOffset: +%d, IdxOffset: +%d, Area: ~%0.f px", pcmd->ElemCount, pcmd->VtxOffset, pcmd->IdxOffset, total_area);
    %%%%%:21906-block 74
call    0 never executed
    #####:21907:        Selectable(buf);
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$:21907-block 122
    #####:21908:        if (IsItemHovered() && fg_draw_list)
    %%%%%:21908-block 77
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21908-block 78
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:21908-block 79
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:21908-block 80
    %%%%%:21908-block 81
    %%%%%:21908-block 82
branch  7 never executed (fallthrough)
branch  8 never executed
    #####:21909:            DebugNodeDrawCmdShowMeshAndBoundingBox(fg_draw_list, draw_list, pcmd, true, false);
    %%%%%:21909-block 83
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21910:
        -:21911:        // Display individual triangles/vertices. Hover on to get the corresponding triangle highlighted.
    #####:21912:        ImGuiListClipper clipper;
    %%%%%:21912-block 84
call    0 never executed
    #####:21913:        clipper.Begin(pcmd->ElemCount / 3); // Manually coarse clip our print out of individual vertices to save CPU, only items that may be visible.
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21914:        while (clipper.Step())
    %%%%%:21914-block 86
    %%%%%:21914-block 110
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21914-block 111
branch  3 never executed
branch  4 never executed (fallthrough)
    #####:21915:            for (int prim = clipper.DisplayStart, idx_i = pcmd->IdxOffset + clipper.DisplayStart * 3; prim < clipper.DisplayEnd; prim++)
    %%%%%:21915-block 87
    %%%%%:21915-block 108
    %%%%%:21915-block 109
branch  0 never executed
branch  1 never executed (fallthrough)
        -:21916:            {
    #####:21917:                char* buf_p = buf, * buf_end = buf + IM_ARRAYSIZE(buf);
    #####:21918:                ImVec2 triangle[3];
    #####:21919:                for (int n = 0; n < 3; n++, idx_i++)
    %%%%%:21919-block 88
    %%%%%:21919-block 97
branch  0 never executed
branch  1 never executed (fallthrough)
        -:21920:                {
    #####:21921:                    const ImDrawVert& v = vtx_buffer[idx_buffer ? idx_buffer[idx_i] : idx_i];
    %%%%%:21921-block 89
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21921-block 90
    %%%%%:21921-block 91
    #####:21922:                    triangle[n] = v.pos;
    #####:21923:                    buf_p += ImFormatString(buf_p, buf_end - buf_p, "%s %04d: pos (%8.2f,%8.2f), uv (%.6f,%.6f), col %08X\n",
    %%%%%:21923-block 93
    %%%%%:21923-block 94
    %%%%%:21923-block 95
call    0 never executed
    #####:21924:                        (n == 0) ? "Vert:" : "     ", idx_i, v.pos.x, v.pos.y, v.uv.x, v.uv.y, v.col);
    %%%%%:21924-block 92
branch  0 never executed (fallthrough)
branch  1 never executed
        -:21925:                }
        -:21926:
    #####:21927:                Selectable(buf, false);
    %%%%%:21927-block 98
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$:21927-block 123
    #####:21928:                if (fg_draw_list && IsItemHovered())
    %%%%%:21928-block 100
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21928-block 101
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%:21928-block 102
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:21928-block 103
    %%%%%:21928-block 104
    %%%%%:21928-block 105
branch  7 never executed (fallthrough)
branch  8 never executed
        -:21929:                {
    #####:21930:                    ImDrawListFlags backup_flags = fg_draw_list->Flags;
    #####:21931:                    fg_draw_list->Flags &= ~ImDrawListFlags_AntiAliasedLines; // Disable AA on triangle outlines is more readable for very large and thin triangles.
    #####:21932:                    fg_draw_list->AddPolyline(triangle, 3, IM_COL32(255, 255, 0, 255), ImDrawFlags_Closed, 1.0f);
    %%%%%:21932-block 106
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21933:                    fg_draw_list->Flags = backup_flags;
    %%%%%:21933-block 107
        -:21934:                }
        -:21935:            }
    #####:21936:        TreePop();
    %%%%%:21936-block 112
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21937:    }
    %%%%%:21937-block 113
call    0 never executed
    $$$$$:21937-block 125
call    1 never executed
    #####:21938:    TreePop();
    %%%%%:21938-block 118
call    0 never executed
        -:21939:}
        -:21940:
        -:21941:// [DEBUG] Display mesh/aabb of a ImDrawCmd
function _ZN5ImGui38DebugNodeDrawCmdShowMeshAndBoundingBoxEP10ImDrawListPKS0_PK9ImDrawCmdbb called 0 returned 0% blocks executed 0%
    #####:21942:void ImGui::DebugNodeDrawCmdShowMeshAndBoundingBox(ImDrawList* out_draw_list, const ImDrawList* draw_list, const ImDrawCmd* draw_cmd, bool show_mesh, bool show_aabb)
        -:21943:{
    #####:21944:    IM_ASSERT(show_mesh || show_aabb);
    %%%%%:21944-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21944-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:21944-block 4
call    4 never executed
        -:21945:
        -:21946:    // Draw wire-frame version of all triangles
    #####:21947:    ImRect clip_rect = draw_cmd->ClipRect;
    %%%%%:21947-block 5
call    0 never executed
    #####:21948:    ImRect vtxs_rect(FLT_MAX, FLT_MAX, -FLT_MAX, -FLT_MAX);
    #####:21949:    ImDrawListFlags backup_flags = out_draw_list->Flags;
    #####:21950:    out_draw_list->Flags &= ~ImDrawListFlags_AntiAliasedLines; // Disable AA on triangle outlines is more readable for very large and thin triangles.
    #####:21951:    for (unsigned int idx_n = draw_cmd->IdxOffset, idx_end = draw_cmd->IdxOffset + draw_cmd->ElemCount; idx_n < idx_end; )
    %%%%%:21951-block 20
branch  0 never executed
branch  1 never executed (fallthrough)
        -:21952:    {
    #####:21953:        ImDrawIdx* idx_buffer = (draw_list->IdxBuffer.Size > 0) ? draw_list->IdxBuffer.Data : NULL; // We don't hold on those pointers past iterations as ->AddPolyline() may invalidate them if out_draw_list==draw_list
    %%%%%:21953-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21953-block 8
    %%%%%:21953-block 9
    #####:21954:        ImDrawVert* vtx_buffer = draw_list->VtxBuffer.Data + draw_cmd->VtxOffset;
        -:21955:
    #####:21956:        ImVec2 triangle[3];
    #####:21957:        for (int n = 0; n < 3; n++, idx_n++)
    %%%%%:21957-block 10
    %%%%%:21957-block 16
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:21958:            vtxs_rect.Add((triangle[n] = vtx_buffer[idx_buffer ? idx_buffer[idx_n] : idx_n].pos));
    %%%%%:21958-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21958-block 12
    %%%%%:21958-block 13
    %%%%%:21958-block 14
call    2 never executed
    #####:21959:        if (show_mesh)
    %%%%%:21959-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:21960:            out_draw_list->AddPolyline(triangle, 3, IM_COL32(255, 255, 0, 255), ImDrawFlags_Closed, 1.0f); // In yellow: mesh triangles
    %%%%%:21960-block 18
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21961:    }
        -:21962:    // Draw bounding boxes
    #####:21963:    if (show_aabb)
    %%%%%:21963-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
        -:21964:    {
    #####:21965:        out_draw_list->AddRect(ImTrunc(clip_rect.Min), ImTrunc(clip_rect.Max), IM_COL32(255, 0, 255, 255)); // In pink: clipping rectangle submitted to GPU
    %%%%%:21965-block 22
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    $$$$$:21965-block 31
    $$$$$:21965-block 32
    #####:21966:        out_draw_list->AddRect(ImTrunc(vtxs_rect.Min), ImTrunc(vtxs_rect.Max), IM_COL32(0, 255, 255, 255)); // In cyan: bounding box of triangles
    %%%%%:21966-block 25
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%:21966-block 28
    $$$$$:21966-block 33
    $$$$$:21966-block 34
        -:21967:    }
    #####:21968:    out_draw_list->Flags = backup_flags;
    #####:21969:}
    %%%%%:21969-block 29
        -:21970:
        -:21971:// [DEBUG] Display details for a single font, called by ShowStyleEditor().
function _ZN5ImGui13DebugNodeFontEP6ImFont called 0 returned 0% blocks executed 0%
    #####:21972:void ImGui::DebugNodeFont(ImFont* font)
        -:21973:{
    #####:21974:    bool opened = TreeNode(font, "Font: \"%s\"\n%.2f px, %d glyphs, %d file(s)",
    %%%%%:21974-block 4
    %%%%%:21974-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21975:        font->ConfigData ? font->ConfigData[0].Name : "", font->FontSize, font->Glyphs.Size, font->ConfigDataCount);
    %%%%%:21975-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:21975-block 3
    #####:21976:    SameLine();
    %%%%%:21976-block 6
call    0 never executed
    #####:21977:    if (SmallButton("Set as default"))
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:21977-block 8
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:21978:        GetIO().FontDefault = font;
    %%%%%:21978-block 9
call    0 never executed
    #####:21979:    if (!opened)
    %%%%%:21979-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:21980:        return;
    %%%%%:21980-block 12
        -:21981:
        -:21982:    // Display preview text
    #####:21983:    PushFont(font);
    %%%%%:21983-block 13
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21984:    Text("The quick brown fox jumps over the lazy dog");
    %%%%%:21984-block 14
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21985:    PopFont();
    %%%%%:21985-block 15
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21986:
        -:21987:    // Display details
    #####:21988:    SetNextItemWidth(GetFontSize() * 8);
    %%%%%:21988-block 16
call    0 never executed
call    1 never executed
    #####:21989:    DragFloat("Font scale", &font->Scale, 0.005f, 0.3f, 2.0f, "%.1f");
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:21990:    SameLine(); MetricsHelpMarker(
    %%%%%:21990-block 19
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
        -:21991:        "Note that the default embedded font is NOT meant to be scaled.\n\n"
        -:21992:        "Font are currently rendered into bitmaps at a given size at the time of building the atlas. "
        -:21993:        "You may oversample them to get some flexibility with scaling. "
        -:21994:        "You can also render at multiple sizes and select which one to use at runtime.\n\n"
        -:21995:        "(Glimmer of hope: the atlas system will be rewritten in the future to make scaling more flexible.)");
    #####:21996:    Text("Ascent: %f, Descent: %f, Height: %f", font->Ascent, font->Descent, font->Ascent - font->Descent);
    %%%%%:21996-block 21
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:21997:    char c_str[5];
    #####:21998:    Text("Fallback character: '%s' (U+%04X)", ImTextCharToUtf8(c_str, font->FallbackChar), font->FallbackChar);
    %%%%%:21998-block 22
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####:21999:    Text("Ellipsis character: '%s' (U+%04X)", ImTextCharToUtf8(c_str, font->EllipsisChar), font->EllipsisChar);
    %%%%%:21999-block 24
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####:22000:    const int surface_sqrt = (int)ImSqrt((float)font->MetricsTotalSurface);
    #####:22001:    Text("Texture Area: about %d px ~%dx%d px", font->MetricsTotalSurface, surface_sqrt, surface_sqrt);
    %%%%%:22001-block 26
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:22002:    for (int config_i = 0; config_i < font->ConfigDataCount; config_i++)
    %%%%%:22002-block 27
    %%%%%:22002-block 31
    %%%%%:22002-block 32
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:22003:        if (font->ConfigData)
    %%%%%:22003-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:22004:            if (const ImFontConfig* cfg = &font->ConfigData[config_i])
    %%%%%:22004-block 29
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:22005:                BulletText("Input %d: \'%s\', Oversample: (%d,%d), PixelSnapH: %d, Offset: (%.1f,%.1f)",
    #####:22006:                    config_i, cfg->Name, cfg->OversampleH, cfg->OversampleV, cfg->PixelSnapH, cfg->GlyphOffset.x, cfg->GlyphOffset.y);
    %%%%%:22006-block 30
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:22007:
        -:22008:    // Display all glyphs of the fonts in separate pages of 256 characters
    #####:22009:    if (TreeNode("Glyphs", "Glyphs (%d)", font->Glyphs.Size))
    %%%%%:22009-block 33
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:22009-block 34
branch  3 never executed (fallthrough)
branch  4 never executed
        -:22010:    {
    #####:22011:        ImDrawList* draw_list = GetWindowDrawList();
    %%%%%:22011-block 35
call    0 never executed
    #####:22012:        const ImU32 glyph_col = GetColorU32(ImGuiCol_Text);
call    0 never executed
    #####:22013:        const float cell_size = font->FontSize * 1;
    #####:22014:        const float cell_spacing = GetStyle().ItemSpacing.y;
call    0 never executed
    #####:22015:        for (unsigned int base = 0; base <= IM_UNICODE_CODEPOINT_MAX; base += 256)
    %%%%%:22015-block 89
    %%%%%:22015-block 90
branch  0 never executed
branch  1 never executed (fallthrough)
        -:22016:        {
        -:22017:            // Skip ahead if a large bunch of glyphs are not present in the font (test in chunks of 4k)
        -:22018:            // This is only a small optimization to reduce the number of iterations when IM_UNICODE_MAX_CODEPOINT
        -:22019:            // is large // (if ImWchar==ImWchar32 we will do at least about 272 queries here)
    #####:22020:            if (!(base & 4095) && font->IsGlyphRangeUnused(base, base + 4095))
    %%%%%:22020-block 39
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22020-block 40
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%:22020-block 41
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:22020-block 42
    %%%%%:22020-block 43
    %%%%%:22020-block 44
branch  7 never executed (fallthrough)
branch  8 never executed
        -:22021:            {
    #####:22022:                base += 4096 - 256;
    #####:22023:                continue;
    %%%%%:22023-block 45
    %%%%%:22023-block 88
        -:22024:            }
        -:22025:
    #####:22026:            int count = 0;
    #####:22027:            for (unsigned int n = 0; n < 256; n++)
    %%%%%:22027-block 46
    %%%%%:22027-block 50
    %%%%%:22027-block 51
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:22028:                if (font->FindGlyphNoFallback((ImWchar)(base + n)))
    %%%%%:22028-block 47
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:22028-block 48
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:22029:                    count++;
    %%%%%:22029-block 49
    #####:22030:            if (count <= 0)
    %%%%%:22030-block 52
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:22031:                continue;
    %%%%%:22031-block 53
    #####:22032:            if (!TreeNode((void*)(intptr_t)base, "U+%04X..U+%04X (%d %s)", base, base + 255, count, count > 1 ? "glyphs" : "glyph"))
    %%%%%:22032-block 54
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22032-block 55
    %%%%%:22032-block 56
    %%%%%:22032-block 57
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%:22032-block 58
branch  5 never executed (fallthrough)
branch  6 never executed
    #####:22033:                continue;
    %%%%%:22033-block 59
        -:22034:
        -:22035:            // Draw a 16x16 grid of glyphs
    #####:22036:            ImVec2 base_pos = GetCursorScreenPos();
    %%%%%:22036-block 60
call    0 never executed
    #####:22037:            for (unsigned int n = 0; n < 256; n++)
    %%%%%:22037-block 82
    %%%%%:22037-block 83
branch  0 never executed
branch  1 never executed (fallthrough)
        -:22038:            {
        -:22039:                // We use ImFont::RenderChar as a shortcut because we don't have UTF-8 conversion functions
        -:22040:                // available here and thus cannot easily generate a zero-terminated UTF-8 encoded string.
    #####:22041:                ImVec2 cell_p1(base_pos.x + (n % 16) * (cell_size + cell_spacing), base_pos.y + (n / 16) * (cell_size + cell_spacing));
    %%%%%:22041-block 62
call    0 never executed
    #####:22042:                ImVec2 cell_p2(cell_p1.x + cell_size, cell_p1.y + cell_size);
call    0 never executed
    #####:22043:                const ImFontGlyph* glyph = font->FindGlyphNoFallback((ImWchar)(base + n));
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:22044:                draw_list->AddRect(cell_p1, cell_p2, glyph ? IM_COL32(255, 255, 255, 100) : IM_COL32(255, 255, 255, 50));
    %%%%%:22044-block 65
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22044-block 66
    %%%%%:22044-block 67
    %%%%%:22044-block 68
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####:22045:                if (!glyph)
    %%%%%:22045-block 69
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:22046:                    continue;
    %%%%%:22046-block 70
    #####:22047:                font->RenderChar(draw_list, cell_size, cell_p1, glyph_col, (ImWchar)(base + n));
    %%%%%:22047-block 71
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:22048:                if (IsMouseHoveringRect(cell_p1, cell_p2) && BeginTooltip())
    %%%%%:22048-block 72
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:22048-block 74
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    %%%%%:22048-block 75
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%:22048-block 76
    %%%%%:22048-block 77
    %%%%%:22048-block 78
branch  8 never executed (fallthrough)
branch  9 never executed
        -:22049:                {
    #####:22050:                    DebugNodeFontGlyph(font, glyph);
    %%%%%:22050-block 79
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:22051:                    EndTooltip();
    %%%%%:22051-block 80
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:22052:                }
        -:22053:            }
    #####:22054:            Dummy(ImVec2((cell_size + cell_spacing) * 16, (cell_size + cell_spacing) * 16));
    %%%%%:22054-block 84
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$:22054-block 96
    #####:22055:            TreePop();
    %%%%%:22055-block 86
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:22056:        }
    #####:22057:        TreePop();
    %%%%%:22057-block 91
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:22058:    }
    #####:22059:    TreePop();
    %%%%%:22059-block 92
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:22060:}
        -:22061:
function _ZN5ImGui18DebugNodeFontGlyphEP6ImFontPK11ImFontGlyph called 0 returned 0% blocks executed 0%
    #####:22062:void ImGui::DebugNodeFontGlyph(ImFont*, const ImFontGlyph* glyph)
        -:22063:{
    #####:22064:    Text("Codepoint: U+%04X", glyph->Codepoint);
    %%%%%:22064-block 2
call    0 never executed
    #####:22065:    Separator();
call    0 never executed
    #####:22066:    Text("Visible: %d", glyph->Visible);
call    0 never executed
    #####:22067:    Text("AdvanceX: %.1f", glyph->AdvanceX);
call    0 never executed
    #####:22068:    Text("Pos: (%.2f,%.2f)->(%.2f,%.2f)", glyph->X0, glyph->Y0, glyph->X1, glyph->Y1);
call    0 never executed
    #####:22069:    Text("UV: (%.3f,%.3f)->(%.3f,%.3f)", glyph->U0, glyph->V0, glyph->U1, glyph->V1);
call    0 never executed
    #####:22070:}
        -:22071:
        -:22072:// [DEBUG] Display contents of ImGuiStorage
function _ZN5ImGui16DebugNodeStorageEP12ImGuiStoragePKc called 0 returned 0% blocks executed 0%
    #####:22073:void ImGui::DebugNodeStorage(ImGuiStorage* storage, const char* label)
        -:22074:{
    #####:22075:    if (!TreeNode(label, "%s: %d entries, %d bytes", label, storage->Data.Size, storage->Data.size_in_bytes()))
    %%%%%:22075-block 2
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:22076:        return;
    %%%%%:22076-block 5
    #####:22077:    for (const ImGuiStoragePair& p : storage->Data)
    %%%%%:22077-block 6
call    0 never executed
call    1 never executed
    %%%%%:22077-block 11
branch  2 never executed
branch  3 never executed (fallthrough)
        -:22078:    {
    #####:22079:        BulletText("Key 0x%08X Value { i: %d }", p.key, p.val_i); // Important: we currently don't store a type, real value may not be integer.
    %%%%%:22079-block 8
call    0 never executed
    #####:22080:        DebugLocateItemOnHover(p.key);
call    0 never executed
        -:22081:    }
    #####:22082:    TreePop();
    %%%%%:22082-block 12
call    0 never executed
        -:22083:}
        -:22084:
        -:22085:// [DEBUG] Display contents of ImGuiTabBar
function _ZN5ImGui15DebugNodeTabBarEP11ImGuiTabBarPKc called 0 returned 0% blocks executed 0%
    #####:22086:void ImGui::DebugNodeTabBar(ImGuiTabBar* tab_bar, const char* label)
        -:22087:{
        -:22088:    // Standalone tab bars (not associated to docking/windows functionality) currently hold no discernible strings.
        -:22089:    char buf[256];
    #####:22090:    char* p = buf;
    #####:22091:    const char* buf_end = buf + IM_ARRAYSIZE(buf);
    #####:22092:    const bool is_active = (tab_bar->PrevFrameVisible >= GetFrameCount() - 2);
    %%%%%:22092-block 2
call    0 never executed
    #####:22093:    p += ImFormatString(p, buf_end - p, "%s 0x%08X (%d tabs)%s  {", label, tab_bar->ID, tab_bar->Tabs.Size, is_active ? "" : " *Inactive*");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22093-block 4
    %%%%%:22093-block 5
    %%%%%:22093-block 6
call    2 never executed
    #####:22094:    for (int tab_n = 0; tab_n < ImMin(tab_bar->Tabs.Size, 3); tab_n++)
    %%%%%:22094-block 15
call    0 never executed
branch  1 never executed
branch  2 never executed (fallthrough)
        -:22095:    {
    #####:22096:        ImGuiTabItem* tab = &tab_bar->Tabs[tab_n];
    %%%%%:22096-block 8
call    0 never executed
    #####:22097:        p += ImFormatString(p, buf_end - p, "%s'%s'", tab_n > 0 ? ", " : "", TabBarGetTabName(tab_bar, tab));
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:22097-block 10
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:22097-block 11
    %%%%%:22097-block 12
    %%%%%:22097-block 13
call    5 never executed
        -:22098:    }
    #####:22099:    p += ImFormatString(p, buf_end - p, (tab_bar->Tabs.Size > 3) ? " ... }" : " } ");
    %%%%%:22099-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22099-block 18
    %%%%%:22099-block 19
    %%%%%:22099-block 20
call    2 never executed
    #####:22100:    if (!is_active) { PushStyleColor(ImGuiCol_Text, GetStyleColorVec4(ImGuiCol_TextDisabled)); }
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22100-block 22
call    2 never executed
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    #####:22101:    bool open = TreeNode(label, "%s", buf);
    %%%%%:22101-block 24
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:22102:    if (!is_active) { PopStyleColor(); }
    %%%%%:22102-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22102-block 26
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####:22103:    if (is_active && IsItemHovered())
    %%%%%:22103-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22103-block 28
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%:22103-block 29
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:22103-block 30
    %%%%%:22103-block 31
    %%%%%:22103-block 32
branch  7 never executed (fallthrough)
branch  8 never executed
        -:22104:    {
    #####:22105:        ImDrawList* draw_list = GetForegroundDrawList();
    %%%%%:22105-block 33
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:22106:        draw_list->AddRect(tab_bar->BarRect.Min, tab_bar->BarRect.Max, IM_COL32(255, 255, 0, 255));
    %%%%%:22106-block 34
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:22107:        draw_list->AddLine(ImVec2(tab_bar->ScrollingRectMinX, tab_bar->BarRect.Min.y), ImVec2(tab_bar->ScrollingRectMinX, tab_bar->BarRect.Max.y), IM_COL32(0, 255, 0, 255));
    %%%%%:22107-block 35
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    $$$$$:22107-block 64
    $$$$$:22107-block 65
    #####:22108:        draw_list->AddLine(ImVec2(tab_bar->ScrollingRectMaxX, tab_bar->BarRect.Min.y), ImVec2(tab_bar->ScrollingRectMaxX, tab_bar->BarRect.Max.y), IM_COL32(0, 255, 0, 255));
    %%%%%:22108-block 38
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%:22108-block 41
    $$$$$:22108-block 66
    $$$$$:22108-block 67
        -:22109:    }
    #####:22110:    if (open)
    %%%%%:22110-block 42
branch  0 never executed (fallthrough)
branch  1 never executed
        -:22111:    {
    #####:22112:        for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)
    %%%%%:22112-block 43
    %%%%%:22112-block 60
    %%%%%:22112-block 61
branch  0 never executed
branch  1 never executed (fallthrough)
        -:22113:        {
    #####:22114:            ImGuiTabItem* tab = &tab_bar->Tabs[tab_n];
    %%%%%:22114-block 44
call    0 never executed
    #####:22115:            PushID(tab);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:22116:            if (SmallButton("<")) { TabBarQueueReorder(tab_bar, tab, -1); } SameLine(0, 2);
    %%%%%:22116-block 46
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:22116-block 47
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:22116-block 48
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
    %%%%%:22116-block 49
call    8 never executed
    #####:22117:            if (SmallButton(">")) { TabBarQueueReorder(tab_bar, tab, +1); } SameLine();
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:22117-block 51
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:22117-block 52
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
    %%%%%:22117-block 53
call    8 never executed
    #####:22118:            Text("%02d%c Tab 0x%08X '%s' Offset: %.2f, Width: %.2f/%.2f",
    %%%%%:22118-block 56
    %%%%%:22118-block 57
    %%%%%:22118-block 58
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:22119:                tab_n, (tab->ID == tab_bar->SelectedTabId) ? '*' : ' ', tab->ID, TabBarGetTabName(tab_bar, tab), tab->Offset, tab->Width, tab->ContentWidth);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:22119-block 55
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:22120:            PopID();
    %%%%%:22120-block 59
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:22121:        }
    #####:22122:        TreePop();
    %%%%%:22122-block 62
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:22123:    }
    #####:22124:}
    %%%%%:22124-block 63
        -:22125:
function _ZN5ImGui17DebugNodeViewportEP14ImGuiViewportP called 0 returned 0% blocks executed 0%
    #####:22126:void ImGui::DebugNodeViewport(ImGuiViewportP* viewport)
        -:22127:{
    #####:22128:    ImGuiContext& g = *GImGui;
    #####:22129:    SetNextItemOpen(true, ImGuiCond_Once);
    %%%%%:22129-block 2
call    0 never executed
    #####:22130:    bool open = TreeNode((void*)(intptr_t)viewport->ID, "Viewport #%d, ID: 0x%08X, Parent: 0x%08X, Window: \"%s\"", viewport->Idx, viewport->ID, viewport->ParentViewportId, viewport->Window ? viewport->Window->Name : "N/A");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22130-block 4
    %%%%%:22130-block 5
    %%%%%:22130-block 6
call    2 never executed
    #####:22131:    if (IsItemHovered())
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:22132:        g.DebugMetricsConfig.HighlightViewportID = viewport->ID;
    %%%%%:22132-block 9
    #####:22133:    if (open)
    %%%%%:22133-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
        -:22134:    {
    #####:22135:        ImGuiWindowFlags flags = viewport->Flags;
    #####:22136:        BulletText("Main Pos: (%.0f,%.0f), Size: (%.0f,%.0f)\nWorkArea Inset Left: %.0f Top: %.0f, Right: %.0f, Bottom: %.0f\nMonitor: %d, DpiScale: %.0f%%",
    #####:22137:            viewport->Pos.x, viewport->Pos.y, viewport->Size.x, viewport->Size.y,
    #####:22138:            viewport->WorkInsetMin.x, viewport->WorkInsetMin.y, viewport->WorkInsetMax.x, viewport->WorkInsetMax.y,
    #####:22139:            viewport->PlatformMonitor, viewport->DpiScale * 100.0f);
    %%%%%:22139-block 11
call    0 never executed
    #####:22140:        if (viewport->Idx > 0) { SameLine(); if (SmallButton("Reset Pos")) { viewport->Pos = ImVec2(200, 200); viewport->UpdateWorkRect(); if (viewport->Window) viewport->Window->Pos = viewport->Pos; } }
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22140-block 13
call    2 never executed
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:22140-block 16
call    6 never executed
call    7 never executed
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%:22140-block 19
    #####:22141:        BulletText("Flags: 0x%04X =%s%s%s%s%s%s%s%s%s%s%s%s%s", viewport->Flags,
    %%%%%:22141-block 21
    %%%%%:22141-block 22
    %%%%%:22141-block 24
    %%%%%:22141-block 25
    %%%%%:22141-block 27
    %%%%%:22141-block 28
    %%%%%:22141-block 30
    %%%%%:22141-block 31
    %%%%%:22141-block 33
    %%%%%:22141-block 34
    %%%%%:22141-block 36
    %%%%%:22141-block 37
    %%%%%:22141-block 39
    %%%%%:22141-block 40
    %%%%%:22141-block 42
    %%%%%:22141-block 43
    %%%%%:22141-block 45
    %%%%%:22141-block 46
    %%%%%:22141-block 48
    %%%%%:22141-block 49
    %%%%%:22141-block 51
    %%%%%:22141-block 52
    %%%%%:22141-block 54
    %%%%%:22141-block 55
    %%%%%:22141-block 57
    %%%%%:22141-block 58
    %%%%%:22141-block 59
call    0 never executed
        -:22142:            //(flags & ImGuiViewportFlags_IsPlatformWindow) ? " IsPlatformWindow" : "", // Omitting because it is the standard
    #####:22143:            (flags & ImGuiViewportFlags_IsPlatformMonitor) ? " IsPlatformMonitor" : "",
    %%%%%:22143-block 56
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:22144:            (flags & ImGuiViewportFlags_IsMinimized) ? " IsMinimized" : "",
    %%%%%:22144-block 53
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:22145:            (flags & ImGuiViewportFlags_IsFocused) ? " IsFocused" : "",
    %%%%%:22145-block 50
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:22146:            (flags & ImGuiViewportFlags_OwnedByApp) ? " OwnedByApp" : "",
    %%%%%:22146-block 47
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:22147:            (flags & ImGuiViewportFlags_NoDecoration) ? " NoDecoration" : "",
    %%%%%:22147-block 44
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:22148:            (flags & ImGuiViewportFlags_NoTaskBarIcon) ? " NoTaskBarIcon" : "",
    %%%%%:22148-block 41
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:22149:            (flags & ImGuiViewportFlags_NoFocusOnAppearing) ? " NoFocusOnAppearing" : "",
    %%%%%:22149-block 38
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:22150:            (flags & ImGuiViewportFlags_NoFocusOnClick) ? " NoFocusOnClick" : "",
    %%%%%:22150-block 35
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:22151:            (flags & ImGuiViewportFlags_NoInputs) ? " NoInputs" : "",
    %%%%%:22151-block 32
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:22152:            (flags & ImGuiViewportFlags_NoRendererClear) ? " NoRendererClear" : "",
    %%%%%:22152-block 29
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:22153:            (flags & ImGuiViewportFlags_NoAutoMerge) ? " NoAutoMerge" : "",
    %%%%%:22153-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:22154:            (flags & ImGuiViewportFlags_TopMost) ? " TopMost" : "",
    %%%%%:22154-block 23
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:22155:            (flags & ImGuiViewportFlags_CanHostOtherWindows) ? " CanHostOtherWindows" : "");
    %%%%%:22155-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:22156:        for (ImDrawList* draw_list : viewport->DrawDataP.CmdLists)
call    0 never executed
call    1 never executed
    %%%%%:22156-block 64
branch  2 never executed
branch  3 never executed (fallthrough)
    #####:22157:            DebugNodeDrawList(NULL, viewport, draw_list, "DrawList");
    %%%%%:22157-block 62
call    0 never executed
    #####:22158:        TreePop();
    %%%%%:22158-block 65
call    0 never executed
        -:22159:    }
    #####:22160:}
        -:22161:
function _ZN5ImGui24DebugNodePlatformMonitorEP20ImGuiPlatformMonitorPKci called 0 returned 0% blocks executed 0%
    #####:22162:void ImGui::DebugNodePlatformMonitor(ImGuiPlatformMonitor* monitor, const char* label, int idx)
        -:22163:{
    #####:22164:    BulletText("%s %d: DPI %.0f%%\n MainMin (%.0f,%.0f), MainMax (%.0f,%.0f), MainSize (%.0f,%.0f)\n WorkMin (%.0f,%.0f), WorkMax (%.0f,%.0f), WorkSize (%.0f,%.0f)",
    #####:22165:        label, idx, monitor->DpiScale * 100.0f,
    #####:22166:        monitor->MainPos.x, monitor->MainPos.y, monitor->MainPos.x + monitor->MainSize.x, monitor->MainPos.y + monitor->MainSize.y, monitor->MainSize.x, monitor->MainSize.y,
    #####:22167:        monitor->WorkPos.x, monitor->WorkPos.y, monitor->WorkPos.x + monitor->WorkSize.x, monitor->WorkPos.y + monitor->WorkSize.y, monitor->WorkSize.x, monitor->WorkSize.y);
    %%%%%:22167-block 2
call    0 never executed
    #####:22168:}
        -:22169:
function _ZN5ImGui15DebugNodeWindowEP11ImGuiWindowPKc called 0 returned 0% blocks executed 0%
    #####:22170:void ImGui::DebugNodeWindow(ImGuiWindow* window, const char* label)
        -:22171:{
    #####:22172:    if (window == NULL)
    %%%%%:22172-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -:22173:    {
    #####:22174:        BulletText("%s: NULL", label);
    %%%%%:22174-block 3
call    0 never executed
    #####:22175:        return;
        -:22176:    }
        -:22177:
    #####:22178:    ImGuiContext& g = *GImGui;
    #####:22179:    const bool is_active = window->WasActive;
    #####:22180:    ImGuiTreeNodeFlags tree_node_flags = (window == g.NavWindow) ? ImGuiTreeNodeFlags_Selected : ImGuiTreeNodeFlags_None;
    %%%%%:22180-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22180-block 6
    %%%%%:22180-block 7
    #####:22181:    if (!is_active) { PushStyleColor(ImGuiCol_Text, GetStyleColorVec4(ImGuiCol_TextDisabled)); }
    %%%%%:22181-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22181-block 9
call    2 never executed
call    3 never executed
    #####:22182:    const bool open = TreeNodeEx(label, tree_node_flags, "%s '%s'%s", label, window->Name, is_active ? "" : " *Inactive*");
    %%%%%:22182-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22182-block 12
    %%%%%:22182-block 13
    %%%%%:22182-block 14
call    2 never executed
    #####:22183:    if (!is_active) { PopStyleColor(); }
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22183-block 16
call    2 never executed
    #####:22184:    if (IsItemHovered() && is_active)
    %%%%%:22184-block 17
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:22184-block 19
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:22184-block 20
    %%%%%:22184-block 21
    %%%%%:22184-block 22
branch  5 never executed (fallthrough)
branch  6 never executed
    #####:22185:        GetForegroundDrawList(window)->AddRect(window->Pos, window->Pos + window->Size, IM_COL32(255, 255, 0, 255));
    %%%%%:22185-block 23
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%:22185-block 26
    $$$$$:22185-block 165
call    5 never executed
    #####:22186:    if (!open)
    %%%%%:22186-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:22187:        return;
    %%%%%:22187-block 28
        -:22188:
    #####:22189:    if (window->MemoryCompacted)
    %%%%%:22189-block 29
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:22190:        TextDisabled("Note: some memory buffers have been compacted/freed.");
    %%%%%:22190-block 30
call    0 never executed
        -:22191:
    #####:22192:    if (g.IO.ConfigDebugIsDebuggerPresent && DebugBreakButton("**DebugBreak**", "in Begin()"))
    %%%%%:22192-block 31
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22192-block 32
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:22192-block 34
    %%%%%:22192-block 35
    %%%%%:22192-block 36
branch  5 never executed (fallthrough)
branch  6 never executed
    #####:22193:        g.DebugBreakInWindow = window->ID;
    %%%%%:22193-block 37
        -:22194:
    #####:22195:    ImGuiWindowFlags flags = window->Flags;
    #####:22196:    DebugNodeDrawList(window, window->Viewport, window->DrawList, "DrawList");
    %%%%%:22196-block 38
call    0 never executed
    #####:22197:    BulletText("Pos: (%.1f,%.1f), Size: (%.1f,%.1f), ContentSize (%.1f,%.1f) Ideal (%.1f,%.1f)", window->Pos.x, window->Pos.y, window->Size.x, window->Size.y, window->ContentSize.x, window->ContentSize.y, window->ContentSizeIdeal.x, window->ContentSizeIdeal.y);
call    0 never executed
    #####:22198:    BulletText("Flags: 0x%08X (%s%s%s%s%s%s%s%s%s..)", flags,
    %%%%%:22198-block 41
    %%%%%:22198-block 42
    %%%%%:22198-block 44
    %%%%%:22198-block 45
    %%%%%:22198-block 47
    %%%%%:22198-block 48
    %%%%%:22198-block 50
    %%%%%:22198-block 51
    %%%%%:22198-block 53
    %%%%%:22198-block 54
    %%%%%:22198-block 56
    %%%%%:22198-block 57
    %%%%%:22198-block 59
    %%%%%:22198-block 60
    %%%%%:22198-block 62
    %%%%%:22198-block 63
    %%%%%:22198-block 65
    %%%%%:22198-block 66
    %%%%%:22198-block 67
call    0 never executed
    #####:22199:        (flags & ImGuiWindowFlags_ChildWindow)  ? "Child " : "",      (flags & ImGuiWindowFlags_Tooltip)     ? "Tooltip "   : "",  (flags & ImGuiWindowFlags_Popup) ? "Popup " : "",
    %%%%%:22199-block 58
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22199-block 61
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:22199-block 64
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:22200:        (flags & ImGuiWindowFlags_Modal)        ? "Modal " : "",      (flags & ImGuiWindowFlags_ChildMenu)   ? "ChildMenu " : "",  (flags & ImGuiWindowFlags_NoSavedSettings) ? "NoSavedSettings " : "",
    %%%%%:22200-block 49
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22200-block 52
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:22200-block 55
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:22201:        (flags & ImGuiWindowFlags_NoMouseInputs)? "NoMouseInputs":"", (flags & ImGuiWindowFlags_NoNavInputs) ? "NoNavInputs" : "", (flags & ImGuiWindowFlags_AlwaysAutoResize) ? "AlwaysAutoResize" : "");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22201-block 43
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:22201-block 46
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:22202:    if (flags & ImGuiWindowFlags_ChildWindow)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:22203:        BulletText("ChildFlags: 0x%08X (%s%s%s%s..)", window->ChildFlags,
    %%%%%:22203-block 70
    %%%%%:22203-block 71
    %%%%%:22203-block 73
    %%%%%:22203-block 74
    %%%%%:22203-block 76
    %%%%%:22203-block 77
    %%%%%:22203-block 79
    %%%%%:22203-block 80
    %%%%%:22203-block 81
call    0 never executed
    #####:22204:            (window->ChildFlags & ImGuiChildFlags_Borders) ? "Borders " : "",
    %%%%%:22204-block 78
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:22205:            (window->ChildFlags & ImGuiChildFlags_ResizeX) ? "ResizeX " : "",
    %%%%%:22205-block 75
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:22206:            (window->ChildFlags & ImGuiChildFlags_ResizeY) ? "ResizeY " : "",
    %%%%%:22206-block 72
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:22207:            (window->ChildFlags & ImGuiChildFlags_NavFlattened) ? "NavFlattened " : "");
    %%%%%:22207-block 69
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:22208:    BulletText("WindowClassId: 0x%08X", window->WindowClass.ClassId);
    %%%%%:22208-block 82
call    0 never executed
    #####:22209:    BulletText("Scroll: (%.2f/%.2f,%.2f/%.2f) Scrollbar:%s%s", window->Scroll.x, window->ScrollMax.x, window->Scroll.y, window->ScrollMax.y, window->ScrollbarX ? "X" : "", window->ScrollbarY ? "Y" : "");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22209-block 84
    %%%%%:22209-block 85
    %%%%%:22209-block 86
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:22209-block 87
    %%%%%:22209-block 88
    %%%%%:22209-block 89
call    4 never executed
    #####:22210:    BulletText("Active: %d/%d, WriteAccessed: %d, BeginOrderWithinContext: %d", window->Active, window->WasActive, window->WriteAccessed, (window->Active || window->WasActive) ? window->BeginOrderWithinContext : -1);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22210-block 91
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:22210-block 92
    %%%%%:22210-block 93
    %%%%%:22210-block 94
call    4 never executed
    #####:22211:    BulletText("Appearing: %d, Hidden: %d (CanSkip %d Cannot %d), SkipItems: %d", window->Appearing, window->Hidden, window->HiddenFramesCanSkipItems, window->HiddenFramesCannotSkipItems, window->SkipItems);
call    0 never executed
    #####:22212:    for (int layer = 0; layer < ImGuiNavLayer_COUNT; layer++)
    %%%%%:22212-block 103
    %%%%%:22212-block 104
branch  0 never executed
branch  1 never executed (fallthrough)
        -:22213:    {
    #####:22214:        ImRect r = window->NavRectRel[layer];
    #####:22215:        if (r.Min.x >= r.Max.y && r.Min.y >= r.Max.y)
    %%%%%:22215-block 97
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22215-block 98
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:22216:            BulletText("NavLastIds[%d]: 0x%08X", layer, window->NavLastIds[layer]);
    %%%%%:22216-block 99
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:22217:        else
    #####:22218:            BulletText("NavLastIds[%d]: 0x%08X at +(%.1f,%.1f)(%.1f,%.1f)", layer, window->NavLastIds[layer], r.Min.x, r.Min.y, r.Max.x, r.Max.y);
    %%%%%:22218-block 101
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:22219:        DebugLocateItemOnHover(window->NavLastIds[layer]);
    %%%%%:22219-block 102
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:22220:    }
    #####:22221:    const ImVec2* pr = window->NavPreferredScoringPosRel;
    #####:22222:    for (int layer = 0; layer < ImGuiNavLayer_COUNT; layer++)
    %%%%%:22222-block 105
    %%%%%:22222-block 114
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:22223:        BulletText("NavPreferredScoringPosRel[%d] = {%.1f,%.1f)", layer, (pr[layer].x == FLT_MAX ? -99999.0f : pr[layer].x), (pr[layer].y == FLT_MAX ? -99999.0f : pr[layer].y)); // Display as 99999.0f so it looks neater.
    %%%%%:22223-block 106
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22223-block 107
    %%%%%:22223-block 108
    %%%%%:22223-block 109
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:22223-block 110
    %%%%%:22223-block 111
    %%%%%:22223-block 112
call    4 never executed
    #####:22224:    BulletText("NavLayersActiveMask: %X, NavLastChildNavWindow: %s", window->DC.NavLayersActiveMask, window->NavLastChildNavWindow ? window->NavLastChildNavWindow->Name : "NULL");
    %%%%%:22224-block 115
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22224-block 116
    %%%%%:22224-block 117
    %%%%%:22224-block 118
call    2 never executed
        -:22225:
    #####:22226:    BulletText("Viewport: %d%s, ViewportId: 0x%08X, ViewportPos: (%.1f,%.1f)", window->Viewport ? window->Viewport->Idx : -1, window->ViewportOwned ? " (Owned)" : "", window->ViewportId, window->ViewportPos.x, window->ViewportPos.y);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22226-block 120
    %%%%%:22226-block 121
    %%%%%:22226-block 122
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:22226-block 123
    %%%%%:22226-block 124
    %%%%%:22226-block 125
call    4 never executed
    #####:22227:    BulletText("ViewportMonitor: %d", window->Viewport ? window->Viewport->PlatformMonitor : -1);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22227-block 127
    %%%%%:22227-block 128
    %%%%%:22227-block 129
call    2 never executed
    #####:22228:    BulletText("DockId: 0x%04X, DockOrder: %d, Act: %d, Vis: %d", window->DockId, window->DockOrder, window->DockIsActive, window->DockTabIsVisible);
call    0 never executed
    #####:22229:    if (window->DockNode || window->DockNodeAsHost)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22229-block 132
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:22230:        DebugNodeDockNode(window->DockNodeAsHost ? window->DockNodeAsHost : window->DockNode, window->DockNodeAsHost ? "DockNodeAsHost" : "DockNode");
    %%%%%:22230-block 133
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22230-block 134
    %%%%%:22230-block 135
    %%%%%:22230-block 136
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:22230-block 137
    %%%%%:22230-block 138
    %%%%%:22230-block 139
call    4 never executed
        -:22231:
    #####:22232:    if (window->RootWindow != window)               { DebugNodeWindow(window->RootWindow, "RootWindow"); }
    %%%%%:22232-block 140
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22232-block 141
call    2 never executed
    #####:22233:    if (window->RootWindowDockTree != window->RootWindow) { DebugNodeWindow(window->RootWindowDockTree, "RootWindowDockTree"); }
    %%%%%:22233-block 142
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22233-block 143
call    2 never executed
    #####:22234:    if (window->ParentWindow != NULL)               { DebugNodeWindow(window->ParentWindow, "ParentWindow"); }
    %%%%%:22234-block 144
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22234-block 145
call    2 never executed
    #####:22235:    if (window->ParentWindowForFocusRoute != NULL)  { DebugNodeWindow(window->ParentWindowForFocusRoute, "ParentWindowForFocusRoute"); }
    %%%%%:22235-block 146
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22235-block 147
call    2 never executed
    #####:22236:    if (window->DC.ChildWindows.Size > 0)           { DebugNodeWindowsList(&window->DC.ChildWindows, "ChildWindows"); }
    %%%%%:22236-block 148
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22236-block 149
call    2 never executed
    #####:22237:    if (window->ColumnsStorage.Size > 0 && TreeNode("Columns", "Columns sets (%d)", window->ColumnsStorage.Size))
    %%%%%:22237-block 150
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22237-block 151
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:22237-block 153
    %%%%%:22237-block 154
    %%%%%:22237-block 155
branch  5 never executed (fallthrough)
branch  6 never executed
        -:22238:    {
    #####:22239:        for (ImGuiOldColumns& columns : window->ColumnsStorage)
    %%%%%:22239-block 156
call    0 never executed
call    1 never executed
    %%%%%:22239-block 160
branch  2 never executed
branch  3 never executed (fallthrough)
    #####:22240:            DebugNodeColumns(&columns);
    %%%%%:22240-block 158
call    0 never executed
    #####:22241:        TreePop();
    %%%%%:22241-block 161
call    0 never executed
        -:22242:    }
    #####:22243:    DebugNodeStorage(&window->StateStorage, "Storage");
    %%%%%:22243-block 162
call    0 never executed
    #####:22244:    TreePop();
call    0 never executed
        -:22245:}
        -:22246:
function _ZN5ImGui23DebugNodeWindowSettingsEP19ImGuiWindowSettings called 0 returned 0% blocks executed 0%
    #####:22247:void ImGui::DebugNodeWindowSettings(ImGuiWindowSettings* settings)
        -:22248:{
    #####:22249:    if (settings->WantDelete)
    %%%%%:22249-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:22250:        BeginDisabled();
    %%%%%:22250-block 3
call    0 never executed
    #####:22251:    Text("0x%08X \"%s\" Pos (%d,%d) Size (%d,%d) Collapsed=%d",
call    0 never executed
    #####:22252:        settings->ID, settings->GetName(), settings->Pos.x, settings->Pos.y, settings->Size.x, settings->Size.y, settings->Collapsed);
    %%%%%:22252-block 4
call    0 never executed
    #####:22253:    if (settings->WantDelete)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:22254:        EndDisabled();
    %%%%%:22254-block 7
call    0 never executed
    #####:22255:}
        -:22256:
function _ZN5ImGui20DebugNodeWindowsListEP8ImVectorIP11ImGuiWindowEPKc called 0 returned 0% blocks executed 0%
    #####:22257:void ImGui::DebugNodeWindowsList(ImVector<ImGuiWindow*>* windows, const char* label)
        -:22258:{
    #####:22259:    if (!TreeNode(label, "%s (%d)", label, windows->Size))
    %%%%%:22259-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:22260:        return;
    %%%%%:22260-block 4
    #####:22261:    for (int i = windows->Size - 1; i >= 0; i--) // Iterate front to back
    %%%%%:22261-block 5
    %%%%%:22261-block 12
branch  0 never executed
branch  1 never executed (fallthrough)
        -:22262:    {
    #####:22263:        PushID((*windows)[i]);
    %%%%%:22263-block 6
call    0 never executed
call    1 never executed
    #####:22264:        DebugNodeWindow((*windows)[i], "Window");
call    0 never executed
call    1 never executed
    #####:22265:        PopID();
call    0 never executed
        -:22266:    }
    #####:22267:    TreePop();
    %%%%%:22267-block 13
call    0 never executed
        -:22268:}
        -:22269:
        -:22270:// FIXME-OPT: This is technically suboptimal, but it is simpler this way.
function _ZN5ImGui38DebugNodeWindowsListByBeginStackParentEPP11ImGuiWindowiS1_ called 0 returned 0% blocks executed 0%
    #####:22271:void ImGui::DebugNodeWindowsListByBeginStackParent(ImGuiWindow** windows, int windows_size, ImGuiWindow* parent_in_begin_stack)
        -:22272:{
    #####:22273:    for (int i = 0; i < windows_size; i++)
    %%%%%:22273-block 2
    %%%%%:22273-block 11
    %%%%%:22273-block 12
branch  0 never executed
branch  1 never executed (fallthrough)
        -:22274:    {
    #####:22275:        ImGuiWindow* window = windows[i];
    #####:22276:        if (window->ParentWindowInBeginStack != parent_in_begin_stack)
    %%%%%:22276-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:22277:            continue;
    %%%%%:22277-block 4
        -:22278:        char buf[20];
    #####:22279:        ImFormatString(buf, IM_ARRAYSIZE(buf), "[%04d] Window", window->BeginOrderWithinContext);
    %%%%%:22279-block 5
call    0 never executed
        -:22280:        //BulletText("[%04d] Window '%s'", window->BeginOrderWithinContext, window->Name);
    #####:22281:        DebugNodeWindow(window, buf);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:22282:        Indent();
    %%%%%:22282-block 7
call    0 never executed
    #####:22283:        DebugNodeWindowsListByBeginStackParent(windows + i + 1, windows_size - i - 1, window);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:22284:        Unindent();
    %%%%%:22284-block 9
call    0 never executed
        -:22285:    }
    #####:22286:}
    %%%%%:22286-block 13
        -:22287:
        -:22288://-----------------------------------------------------------------------------
        -:22289:// [SECTION] DEBUG LOG WINDOW
        -:22290://-----------------------------------------------------------------------------
        -:22291:
function _ZN5ImGui8DebugLogEPKcz called 0 returned 0% blocks executed 0%
    #####:22292:void ImGui::DebugLog(const char* fmt, ...)
        -:22293:{
        -:22294:    va_list args;
    #####:22295:    va_start(args, fmt);
    #####:22296:    DebugLogV(fmt, args);
    %%%%%:22296-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:22297:    va_end(args);
    #####:22298:}
    %%%%%:22298-block 3
        -:22299:
function _ZN5ImGui9DebugLogVEPKcP13__va_list_tag called 0 returned 0% blocks executed 0%
    #####:22300:void ImGui::DebugLogV(const char* fmt, va_list args)
        -:22301:{
    #####:22302:    ImGuiContext& g = *GImGui;
    #####:22303:    const int old_size = g.DebugLogBuf.size();
    %%%%%:22303-block 2
call    0 never executed
    #####:22304:    if (g.ContextName[0] != 0)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:22305:        g.DebugLogBuf.appendf("[%s] [%05d] ", g.ContextName, g.FrameCount);
    %%%%%:22305-block 4
call    0 never executed
        -:22306:    else
    #####:22307:        g.DebugLogBuf.appendf("[%05d] ", g.FrameCount);
    %%%%%:22307-block 5
call    0 never executed
    #####:22308:    g.DebugLogBuf.appendfv(fmt, args);
    %%%%%:22308-block 6
call    0 never executed
    #####:22309:    g.DebugLogIndex.append(g.DebugLogBuf.c_str(), old_size, g.DebugLogBuf.size());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:22310:    if (g.DebugLogFlags & ImGuiDebugLogFlags_OutputToTTY)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:22311:        IMGUI_DEBUG_PRINTF("%s", g.DebugLogBuf.begin() + old_size);
    %%%%%:22311-block 11
call    0 never executed
call    1 never executed
        -:22312:#ifdef IMGUI_ENABLE_TEST_ENGINE
        -:22313:    // IMGUI_TEST_ENGINE_LOG() adds a trailing \n automatically
        -:22314:    const int new_size = g.DebugLogBuf.size();
        -:22315:    const bool trailing_carriage_return = (g.DebugLogBuf[new_size - 1] == '\n');
        -:22316:    if (g.DebugLogFlags & ImGuiDebugLogFlags_OutputToTestEngine)
        -:22317:        IMGUI_TEST_ENGINE_LOG("%.*s", new_size - old_size - (trailing_carriage_return ? 1 : 0), g.DebugLogBuf.begin() + old_size);
        -:22318:#endif
    #####:22319:}
        -:22320:
        -:22321:// FIXME-LAYOUT: To be done automatically via layout mode once we rework ItemSize/ItemAdd into ItemLayout.
function _ZL14SameLineOrWrapRK6ImVec2 called 0 returned 0% blocks executed 0%
    #####:22322:static void SameLineOrWrap(const ImVec2& size)
        -:22323:{
    #####:22324:    ImGuiContext& g = *GImGui;
    #####:22325:    ImGuiWindow* window = g.CurrentWindow;
    #####:22326:    ImVec2 pos(window->DC.CursorPosPrevLine.x + g.Style.ItemSpacing.x, window->DC.CursorPosPrevLine.y);
    %%%%%:22326-block 2
call    0 never executed
    #####:22327:    if (window->WorkRect.Contains(ImRect(pos, pos + size)))
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:22328:        ImGui::SameLine();
    %%%%%:22328-block 7
call    0 never executed
    #####:22329:}
        -:22330:
function _ZL16ShowDebugLogFlagPKci called 0 returned 0% blocks executed 0%
    #####:22331:static void ShowDebugLogFlag(const char* name, ImGuiDebugLogFlags flags)
        -:22332:{
    #####:22333:    ImGuiContext& g = *GImGui;
    #####:22334:    ImVec2 size(ImGui::GetFrameHeight() + g.Style.ItemInnerSpacing.x + ImGui::CalcTextSize(name).x, ImGui::GetFrameHeight());
    %%%%%:22334-block 2
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%:22334-block 5
call    5 never executed
    #####:22335:    SameLineOrWrap(size); // FIXME-LAYOUT: To be done automatically once we rework ItemSize/ItemAdd into ItemLayout.
call    0 never executed
        -:22336:
    #####:22337:    bool highlight_errors = (flags == ImGuiDebugLogFlags_EventError && g.DebugLogSkippedErrors > 0);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22337-block 8
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:22337-block 9
    %%%%%:22337-block 10
    #####:22338:    if (highlight_errors)
    %%%%%:22338-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:22339:        ImGui::PushStyleColor(ImGuiCol_Text, ImLerp(g.Style.Colors[ImGuiCol_Text], ImVec4(1.0f, 0.0f, 0.0f, 1.0f), 0.30f));
    %%%%%:22339-block 12
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%:22339-block 15
    $$$$$:22339-block 29
    $$$$$:22339-block 30
    #####:22340:    if (ImGui::CheckboxFlags(name, &g.DebugLogFlags, flags) && g.IO.KeyShift && (g.DebugLogFlags & flags) != 0)
    %%%%%:22340-block 16
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:22340-block 17
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:22340-block 18
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:22340-block 19
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%:22340-block 20
    %%%%%:22340-block 21
    %%%%%:22340-block 22
branch  9 never executed (fallthrough)
branch 10 never executed
        -:22341:    {
    #####:22342:        g.DebugLogAutoDisableFrames = 2;
    #####:22343:        g.DebugLogAutoDisableFlags |= flags;
    %%%%%:22343-block 23
        -:22344:    }
    #####:22345:    if (highlight_errors)
    %%%%%:22345-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
        -:22346:    {
    #####:22347:        ImGui::PopStyleColor();
    %%%%%:22347-block 25
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:22348:        ImGui::SetItemTooltip("%d past errors skipped.", g.DebugLogSkippedErrors);
    %%%%%:22348-block 26
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:22349:    }
        -:22350:    else
        -:22351:    {
    #####:22352:        ImGui::SetItemTooltip("Hold SHIFT when clicking to enable for 2 frames only (useful for spammy log entries)");
    %%%%%:22352-block 27
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:22353:    }
    #####:22354:}
    %%%%%:22354-block 28
        -:22355:
function _ZN5ImGui18ShowDebugLogWindowEPb called 0 returned 0% blocks executed 0%
    #####:22356:void ImGui::ShowDebugLogWindow(bool* p_open)
        -:22357:{
    #####:22358:    ImGuiContext& g = *GImGui;
    #####:22359:    if ((g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSize) == 0)
    %%%%%:22359-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:22360:        SetNextWindowSize(ImVec2(0.0f, GetFontSize() * 12.0f), ImGuiCond_FirstUseEver);
    %%%%%:22360-block 3
call    0 never executed
call    1 never executed
call    2 never executed
    #####:22361:    if (!Begin("Dear ImGui Debug Log", p_open) || GetCurrentWindow()->BeginCount > 1)
    %%%%%:22361-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:22361-block 8
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:22361-block 9
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%:22361-block 11
    %%%%%:22361-block 12
    %%%%%:22361-block 13
branch  8 never executed (fallthrough)
branch  9 never executed
        -:22362:    {
    #####:22363:        End();
    %%%%%:22363-block 14
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:22364:        return;
    %%%%%:22364-block 15
        -:22365:    }
        -:22366:
    #####:22367:    ImGuiDebugLogFlags all_enable_flags = ImGuiDebugLogFlags_EventMask_ & ~ImGuiDebugLogFlags_EventInputRouting;
    #####:22368:    CheckboxFlags("All", &g.DebugLogFlags, all_enable_flags);
    %%%%%:22368-block 16
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:22369:    SetItemTooltip("(except InputRouting which is spammy)");
    %%%%%:22369-block 17
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:22370:
    #####:22371:    ShowDebugLogFlag("Errors", ImGuiDebugLogFlags_EventError);
    %%%%%:22371-block 18
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:22372:    ShowDebugLogFlag("ActiveId", ImGuiDebugLogFlags_EventActiveId);
    %%%%%:22372-block 19
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:22373:    ShowDebugLogFlag("Clipper", ImGuiDebugLogFlags_EventClipper);
    %%%%%:22373-block 20
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:22374:    ShowDebugLogFlag("Docking", ImGuiDebugLogFlags_EventDocking);
    %%%%%:22374-block 21
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:22375:    ShowDebugLogFlag("Focus", ImGuiDebugLogFlags_EventFocus);
    %%%%%:22375-block 22
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:22376:    ShowDebugLogFlag("IO", ImGuiDebugLogFlags_EventIO);
    %%%%%:22376-block 23
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:22377:    ShowDebugLogFlag("Nav", ImGuiDebugLogFlags_EventNav);
    %%%%%:22377-block 24
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:22378:    ShowDebugLogFlag("Popup", ImGuiDebugLogFlags_EventPopup);
    %%%%%:22378-block 25
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:22379:    ShowDebugLogFlag("Selection", ImGuiDebugLogFlags_EventSelection);
    %%%%%:22379-block 26
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:22380:    ShowDebugLogFlag("Viewport", ImGuiDebugLogFlags_EventViewport);
    %%%%%:22380-block 27
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:22381:    ShowDebugLogFlag("InputRouting", ImGuiDebugLogFlags_EventInputRouting);
    %%%%%:22381-block 28
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:22382:
    #####:22383:    if (SmallButton("Clear"))
    %%%%%:22383-block 29
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:22383-block 30
branch  3 never executed (fallthrough)
branch  4 never executed
        -:22384:    {
    #####:22385:        g.DebugLogBuf.clear();
    %%%%%:22385-block 31
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:22386:        g.DebugLogIndex.clear();
    %%%%%:22386-block 32
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:22387:        g.DebugLogSkippedErrors = 0;
    %%%%%:22387-block 33
        -:22388:    }
    #####:22389:    SameLine();
    %%%%%:22389-block 34
call    0 never executed
    #####:22390:    if (SmallButton("Copy"))
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:22390-block 36
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:22391:        SetClipboardText(g.DebugLogBuf.c_str());
    %%%%%:22391-block 37
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####:22392:    SameLine();
    %%%%%:22392-block 39
call    0 never executed
    #####:22393:    if (SmallButton("Configure Outputs.."))
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:22393-block 41
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:22394:        OpenPopup("Outputs");
    %%%%%:22394-block 42
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:22395:    if (BeginPopup("Outputs"))
    %%%%%:22395-block 43
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:22395-block 44
branch  3 never executed (fallthrough)
branch  4 never executed
        -:22396:    {
    #####:22397:        CheckboxFlags("OutputToTTY", &g.DebugLogFlags, ImGuiDebugLogFlags_OutputToTTY);
    %%%%%:22397-block 45
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:22398:#ifndef IMGUI_ENABLE_TEST_ENGINE
    #####:22399:        BeginDisabled();
    %%%%%:22399-block 46
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:22400:#endif
    #####:22401:        CheckboxFlags("OutputToTestEngine", &g.DebugLogFlags, ImGuiDebugLogFlags_OutputToTestEngine);
    %%%%%:22401-block 47
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:22402:#ifndef IMGUI_ENABLE_TEST_ENGINE
    #####:22403:        EndDisabled();
    %%%%%:22403-block 48
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:22404:#endif
    #####:22405:        EndPopup();
    %%%%%:22405-block 49
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:22406:    }
        -:22407:
    #####:22408:    BeginChild("##log", ImVec2(0.0f, 0.0f), ImGuiChildFlags_Borders, ImGuiWindowFlags_AlwaysVerticalScrollbar | ImGuiWindowFlags_AlwaysHorizontalScrollbar);
    %%%%%:22408-block 50
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$:22408-block 75
        -:22409:
    #####:22410:    const ImGuiDebugLogFlags backup_log_flags = g.DebugLogFlags;
    #####:22411:    g.DebugLogFlags &= ~ImGuiDebugLogFlags_EventClipper;
        -:22412:
    #####:22413:    ImGuiListClipper clipper;
    %%%%%:22413-block 52
call    0 never executed
    #####:22414:    clipper.Begin(g.DebugLogIndex.size());
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####:22415:    while (clipper.Step())
    %%%%%:22415-block 55
    %%%%%:22415-block 64
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:22415-block 65
branch  3 never executed
branch  4 never executed (fallthrough)
    #####:22416:        for (int line_no = clipper.DisplayStart; line_no < clipper.DisplayEnd; line_no++)
    %%%%%:22416-block 56
    %%%%%:22416-block 62
    %%%%%:22416-block 63
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:22417:            DebugTextUnformattedWithLocateItem(g.DebugLogIndex.get_line_begin(g.DebugLogBuf.c_str(), line_no), g.DebugLogIndex.get_line_end(g.DebugLogBuf.c_str(), line_no));
    %%%%%:22417-block 57
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:22417-block 59
call    4 never executed
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
    %%%%%:22417-block 61
call    8 never executed
branch  9 never executed (fallthrough)
branch 10 never executed (throw)
    #####:22418:    g.DebugLogFlags = backup_log_flags;
    #####:22419:    if (GetScrollY() >= GetScrollMaxY())
    %%%%%:22419-block 66
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:22420:        SetScrollHereY(1.0f);
    %%%%%:22420-block 69
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:22421:    EndChild();
    %%%%%:22421-block 70
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:22422:
    #####:22423:    End();
    %%%%%:22423-block 71
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:22424:}
    %%%%%:22424-block 72
call    0 never executed
    $$$$$:22424-block 76
call    1 never executed
        -:22425:
        -:22426:// Display line, search for 0xXXXXXXXX identifiers and call DebugLocateItemOnHover() when hovered.
function _ZN5ImGui34DebugTextUnformattedWithLocateItemEPKcS1_ called 0 returned 0% blocks executed 0%
    #####:22427:void ImGui::DebugTextUnformattedWithLocateItem(const char* line_begin, const char* line_end)
        -:22428:{
    #####:22429:    TextUnformatted(line_begin, line_end);
    %%%%%:22429-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:22430:    if (!IsItemHovered())
    %%%%%:22430-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:22430-block 4
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:22431:        return;
    %%%%%:22431-block 5
    #####:22432:    ImGuiContext& g = *GImGui;
    #####:22433:    ImRect text_rect = g.LastItemData.Rect;
    #####:22434:    for (const char* p = line_begin; p <= line_end - 10; p++)
    %%%%%:22434-block 6
    %%%%%:22434-block 28
    %%%%%:22434-block 29
branch  0 never executed
branch  1 never executed (fallthrough)
        -:22435:    {
    #####:22436:        ImGuiID id = 0;
    #####:22437:        if (p[0] != '0' || (p[1] != 'x' && p[1] != 'X') || sscanf(p + 2, "%X", &id) != 1 || ImCharIsXdigitA(p[10]))
    %%%%%:22437-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22437-block 8
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:22437-block 9
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:22437-block 10
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%:22437-block 11
call    8 never executed
branch  9 never executed (fallthrough)
branch 10 never executed
    %%%%%:22437-block 13
    %%%%%:22437-block 14
    %%%%%:22437-block 15
branch 11 never executed (fallthrough)
branch 12 never executed
    #####:22438:            continue;
    %%%%%:22438-block 16
    #####:22439:        ImVec2 p0 = CalcTextSize(line_begin, p);
    %%%%%:22439-block 17
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:22440:        ImVec2 p1 = CalcTextSize(p, p + 10);
    %%%%%:22440-block 18
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:22441:        g.LastItemData.Rect = ImRect(text_rect.Min + ImVec2(p0.x, 0.0f), text_rect.Min + ImVec2(p0.x + p1.x, p1.y));
    %%%%%:22441-block 19
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:22442:        if (IsMouseHoveringRect(g.LastItemData.Rect.Min, g.LastItemData.Rect.Max, true))
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:22443:            DebugLocateItemOnHover(id);
    %%%%%:22443-block 26
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:22444:        p += 10;
    %%%%%:22444-block 27
        -:22445:    }
        -:22446:}
        -:22447:
        -:22448://-----------------------------------------------------------------------------
        -:22449:// [SECTION] OTHER DEBUG TOOLS (ITEM PICKER, ID STACK TOOL)
        -:22450://-----------------------------------------------------------------------------
        -:22451:
        -:22452:// Draw a small cross at current CursorPos in current window's DrawList
function _ZN5ImGui18DebugDrawCursorPosEj called 0 returned 0% blocks executed 0%
    #####:22453:void ImGui::DebugDrawCursorPos(ImU32 col)
        -:22454:{
    #####:22455:    ImGuiContext& g = *GImGui;
    #####:22456:    ImGuiWindow* window = g.CurrentWindow;
    #####:22457:    ImVec2 pos = window->DC.CursorPos;
    #####:22458:    window->DrawList->AddLine(ImVec2(pos.x, pos.y - 3.0f), ImVec2(pos.x, pos.y + 4.0f), col, 1.0f);
    %%%%%:22458-block 2
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    $$$$$:22458-block 9
    $$$$$:22458-block 10
    #####:22459:    window->DrawList->AddLine(ImVec2(pos.x - 3.0f, pos.y), ImVec2(pos.x + 4.0f, pos.y), col, 1.0f);
    %%%%%:22459-block 5
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    $$$$$:22459-block 11
    $$$$$:22459-block 12
    #####:22460:}
    %%%%%:22460-block 8
        -:22461:
        -:22462:// Draw a 10px wide rectangle around CurposPos.x using Line Y1/Y2 in current window's DrawList
function _ZN5ImGui20DebugDrawLineExtentsEj called 0 returned 0% blocks executed 0%
    #####:22463:void ImGui::DebugDrawLineExtents(ImU32 col)
        -:22464:{
    #####:22465:    ImGuiContext& g = *GImGui;
    #####:22466:    ImGuiWindow* window = g.CurrentWindow;
    #####:22467:    float curr_x = window->DC.CursorPos.x;
    #####:22468:    float line_y1 = (window->DC.IsSameLine ? window->DC.CursorPosPrevLine.y : window->DC.CursorPos.y);
    %%%%%:22468-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22468-block 3
    %%%%%:22468-block 4
    #####:22469:    float line_y2 = line_y1 + (window->DC.IsSameLine ? window->DC.PrevLineSize.y : window->DC.CurrLineSize.y);
    %%%%%:22469-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22469-block 6
    %%%%%:22469-block 7
    #####:22470:    window->DrawList->AddLine(ImVec2(curr_x - 5.0f, line_y1), ImVec2(curr_x + 5.0f, line_y1), col, 1.0f);
    %%%%%:22470-block 8
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    $$$$$:22470-block 18
    $$$$$:22470-block 19
call    5 never executed
    #####:22471:    window->DrawList->AddLine(ImVec2(curr_x - 0.5f, line_y1), ImVec2(curr_x - 0.5f, line_y2), col, 1.0f);
    %%%%%:22471-block 11
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    $$$$$:22471-block 20
    $$$$$:22471-block 21
call    5 never executed
    #####:22472:    window->DrawList->AddLine(ImVec2(curr_x - 5.0f, line_y2), ImVec2(curr_x + 5.0f, line_y2), col, 1.0f);
    %%%%%:22472-block 14
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    $$$$$:22472-block 22
    #####:22473:}
    %%%%%:22473-block 17
        -:22474:
        -:22475:// Draw last item rect in ForegroundDrawList (so it is always visible)
function _ZN5ImGui17DebugDrawItemRectEj called 0 returned 0% blocks executed 0%
    #####:22476:void ImGui::DebugDrawItemRect(ImU32 col)
        -:22477:{
    #####:22478:    ImGuiContext& g = *GImGui;
    #####:22479:    ImGuiWindow* window = g.CurrentWindow;
    #####:22480:    GetForegroundDrawList(window)->AddRect(g.LastItemData.Rect.Min, g.LastItemData.Rect.Max, col);
    %%%%%:22480-block 2
call    0 never executed
call    1 never executed
    #####:22481:}
        -:22482:
        -:22483:// [DEBUG] Locate item position/rectangle given an ID.
        -:22484:static const ImU32 DEBUG_LOCATE_ITEM_COLOR = IM_COL32(0, 255, 0, 255);  // Green
        -:22485:
function _ZN5ImGui15DebugLocateItemEj called 0 returned 0% blocks executed 0%
    #####:22486:void ImGui::DebugLocateItem(ImGuiID target_id)
        -:22487:{
    #####:22488:    ImGuiContext& g = *GImGui;
    #####:22489:    g.DebugLocateId = target_id;
    #####:22490:    g.DebugLocateFrames = 2;
    #####:22491:    g.DebugBreakInLocateId = false;
    #####:22492:}
        -:22493:
        -:22494:// FIXME: Doesn't work over through a modal window, because they clear HoveredWindow.
function _ZN5ImGui22DebugLocateItemOnHoverEj called 0 returned 0% blocks executed 0%
    #####:22495:void ImGui::DebugLocateItemOnHover(ImGuiID target_id)
        -:22496:{
    #####:22497:    if (target_id == 0 || !IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem | ImGuiHoveredFlags_AllowWhenBlockedByPopup))
    %%%%%:22497-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22497-block 3
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:22497-block 5
    %%%%%:22497-block 6
    %%%%%:22497-block 7
branch  5 never executed (fallthrough)
branch  6 never executed
    #####:22498:        return;
    %%%%%:22498-block 8
    #####:22499:    ImGuiContext& g = *GImGui;
    #####:22500:    DebugLocateItem(target_id);
    %%%%%:22500-block 9
call    0 never executed
    #####:22501:    GetForegroundDrawList(g.CurrentWindow)->AddRect(g.LastItemData.Rect.Min - ImVec2(3.0f, 3.0f), g.LastItemData.Rect.Max + ImVec2(3.0f, 3.0f), DEBUG_LOCATE_ITEM_COLOR);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
    $$$$$:22501-block 23
    $$$$$:22501-block 24
    $$$$$:22501-block 25
        -:22502:
        -:22503:    // Can't easily use a context menu here because it will mess with focus, active id etc.
    #####:22504:    if (g.IO.ConfigDebugIsDebuggerPresent && g.MouseStationaryTimer > 1.0f)
    %%%%%:22504-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22504-block 17
branch  2 never executed (fallthrough)
branch  3 never executed
        -:22505:    {
    #####:22506:        DebugBreakButtonTooltip(false, "in ItemAdd()");
    %%%%%:22506-block 18
call    0 never executed
    #####:22507:        if (IsKeyChordPressed(g.DebugBreakKeyChord))
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:22508:            g.DebugBreakInLocateId = true;
    %%%%%:22508-block 21
        -:22509:    }
        -:22510:}
        -:22511:
function _ZN5ImGui34DebugLocateItemResolveWithLastItemEv called 0 returned 0% blocks executed 0%
    #####:22512:void ImGui::DebugLocateItemResolveWithLastItem()
        -:22513:{
    #####:22514:    ImGuiContext& g = *GImGui;
        -:22515:
        -:22516:    // [DEBUG] Debug break requested by user
    #####:22517:    if (g.DebugBreakInLocateId)
    %%%%%:22517-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:22518:        IM_DEBUG_BREAK();
    %%%%%:22518-block 3
call    0 never executed
        -:22519:
    #####:22520:    ImGuiLastItemData item_data = g.LastItemData;
    #####:22521:    g.DebugLocateId = 0;
    #####:22522:    ImDrawList* draw_list = GetForegroundDrawList(g.CurrentWindow);
    %%%%%:22522-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:22523:    ImRect r = item_data.Rect;
    #####:22524:    r.Expand(3.0f);
    %%%%%:22524-block 5
call    0 never executed
    #####:22525:    ImVec2 p1 = g.IO.MousePos;
    #####:22526:    ImVec2 p2 = ImVec2((p1.x < r.Min.x) ? r.Min.x : (p1.x > r.Max.x) ? r.Max.x : p1.x, (p1.y < r.Min.y) ? r.Min.y : (p1.y > r.Max.y) ? r.Max.y : p1.y);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22526-block 7
    %%%%%:22526-block 8
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:22526-block 9
    %%%%%:22526-block 10
    %%%%%:22526-block 11
    %%%%%:22526-block 12
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:22526-block 13
    %%%%%:22526-block 14
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%:22526-block 15
    %%%%%:22526-block 16
    %%%%%:22526-block 17
    %%%%%:22526-block 18
call    8 never executed
    #####:22527:    draw_list->AddRect(r.Min, r.Max, DEBUG_LOCATE_ITEM_COLOR);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:22528:    draw_list->AddLine(p1, p2, DEBUG_LOCATE_ITEM_COLOR);
    %%%%%:22528-block 20
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:22529:}
    %%%%%:22529-block 21
        -:22530:
function _ZN5ImGui20DebugStartItemPickerEv called 0 returned 0% blocks executed 0%
    #####:22531:void ImGui::DebugStartItemPicker()
        -:22532:{
    #####:22533:    ImGuiContext& g = *GImGui;
    #####:22534:    g.DebugItemPickerActive = true;
    #####:22535:}
        -:22536:
        -:22537:// [DEBUG] Item picker tool - start with DebugStartItemPicker() - useful to visually select an item and break into its call-stack.
function _ZN5ImGuiL25UpdateDebugToolItemPickerEv called 1077 returned 100% blocks executed 13%
     1077:22538:void ImGui::UpdateDebugToolItemPicker()
        -:22539:{
     1077:22540:    ImGuiContext& g = *GImGui;
     1077:22541:    g.DebugItemPickerBreakId = 0;
     1077:22542:    if (!g.DebugItemPickerActive)
     1077:22542-block 2
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:22543:        return;
     1077:22543-block 3
     1077:22543-block 38
        -:22544:
    #####:22545:    const ImGuiID hovered_id = g.HoveredIdPreviousFrame;
    #####:22546:    SetMouseCursor(ImGuiMouseCursor_Hand);
    %%%%%:22546-block 4
call    0 never executed
    #####:22547:    if (IsKeyPressed(ImGuiKey_Escape))
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:22547-block 6
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:22548:        g.DebugItemPickerActive = false;
    %%%%%:22548-block 7
    #####:22549:    const bool change_mapping = g.IO.KeyMods == (ImGuiMod_Ctrl | ImGuiMod_Shift);
    #####:22550:    if (!change_mapping && IsMouseClicked(g.DebugItemPickerMouseButton) && hovered_id)
    %%%%%:22550-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22550-block 9
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%:22550-block 10
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:22550-block 11
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%:22550-block 12
    %%%%%:22550-block 13
    %%%%%:22550-block 14
branch  9 never executed (fallthrough)
branch 10 never executed
        -:22551:    {
    #####:22552:        g.DebugItemPickerBreakId = hovered_id;
    #####:22553:        g.DebugItemPickerActive = false;
    %%%%%:22553-block 15
        -:22554:    }
    #####:22555:    for (int mouse_button = 0; mouse_button < 3; mouse_button++)
    %%%%%:22555-block 16
    %%%%%:22555-block 24
    %%%%%:22555-block 25
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:22556:        if (change_mapping && IsMouseClicked(mouse_button))
    %%%%%:22556-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22556-block 18
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%:22556-block 19
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:22556-block 20
    %%%%%:22556-block 21
    %%%%%:22556-block 22
branch  7 never executed (fallthrough)
branch  8 never executed
    #####:22557:            g.DebugItemPickerMouseButton = (ImU8)mouse_button;
    %%%%%:22557-block 23
    #####:22558:    SetNextWindowBgAlpha(0.70f);
    %%%%%:22558-block 26
call    0 never executed
    #####:22559:    if (!BeginTooltip())
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:22559-block 28
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:22560:        return;
    %%%%%:22560-block 29
    #####:22561:    Text("HoveredId: 0x%08X", hovered_id);
    %%%%%:22561-block 30
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:22562:    Text("Press ESC to abort picking.");
    %%%%%:22562-block 31
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:22563:    const char* mouse_button_names[] = { "Left", "Right", "Middle" };
    #####:22564:    if (change_mapping)
    %%%%%:22564-block 32
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:22565:        Text("Remap w/ Ctrl+Shift: click anywhere to select new mouse button.");
    %%%%%:22565-block 33
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:22566:    else
    #####:22567:        TextColored(GetStyleColorVec4(hovered_id ? ImGuiCol_Text : ImGuiCol_TextDisabled), "Click %s Button to break in debugger! (remap w/ Ctrl+Shift)", mouse_button_names[g.DebugItemPickerMouseButton]);
    %%%%%:22567-block 34
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####:22568:    EndTooltip();
    %%%%%:22568-block 36
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:22569:}
        -:22570:
        -:22571:// [DEBUG] ID Stack Tool: update queries. Called by NewFrame()
function _ZN5ImGuiL27UpdateDebugToolStackQueriesEv called 1077 returned 100% blocks executed 30%
     1077:22572:void ImGui::UpdateDebugToolStackQueries()
        -:22573:{
     1077:22574:    ImGuiContext& g = *GImGui;
     1077:22575:    ImGuiIDStackTool* tool = &g.DebugIDStackTool;
        -:22576:
        -:22577:    // Clear hook when id stack tool is not visible
     1077:22578:    g.DebugHookIdInfo = 0;
     1077:22579:    if (g.FrameCount != tool->LastActiveFrame + 1)
     1077:22579-block 2
branch  0 taken 1076 (fallthrough)
branch  1 taken 1
     1076:22580:        return;
     1076:22580-block 3
        -:22581:
        -:22582:    // Update queries. The steps are: -1: query Stack, >= 0: query each stack item
        -:22583:    // We can only perform 1 ID Info query every frame. This is designed so the GetID() tests are cheap and constant-time
       1*:22584:    const ImGuiID query_id = g.HoveredIdPreviousFrame ? g.HoveredIdPreviousFrame : g.ActiveId;
        1:22584-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%:22584-block 5
        1:22584-block 6
        1:22585:    if (tool->QueryId != query_id)
        1:22585-block 7
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:22586:    {
    #####:22587:        tool->QueryId = query_id;
    #####:22588:        tool->StackLevel = -1;
    #####:22589:        tool->Results.resize(0);
    %%%%%:22589-block 8
call    0 never executed
        -:22590:    }
        1:22591:    if (query_id == 0)
        1:22591-block 9
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:22592:        return;
        1:22592-block 10
        -:22593:
        -:22594:    // Advance to next stack level when we got our result, or after 2 frames (in case we never get a result)
    #####:22595:    int stack_level = tool->StackLevel;
    #####:22596:    if (stack_level >= 0 && stack_level < tool->Results.Size)
    %%%%%:22596-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22596-block 12
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:22597:        if (tool->Results[stack_level].QuerySuccess || tool->Results[stack_level].QueryFrameCount > 2)
    %%%%%:22597-block 13
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:22597-block 15
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:22597-block 17
    %%%%%:22597-block 18
    %%%%%:22597-block 19
branch  6 never executed (fallthrough)
branch  7 never executed
    #####:22598:            tool->StackLevel++;
    %%%%%:22598-block 20
        -:22599:
        -:22600:    // Update hook
    #####:22601:    stack_level = tool->StackLevel;
    #####:22602:    if (stack_level == -1)
    %%%%%:22602-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:22603:        g.DebugHookIdInfo = query_id;
    %%%%%:22603-block 22
    #####:22604:    if (stack_level >= 0 && stack_level < tool->Results.Size)
    %%%%%:22604-block 23
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22604-block 24
branch  2 never executed (fallthrough)
branch  3 never executed
        -:22605:    {
    #####:22606:        g.DebugHookIdInfo = tool->Results[stack_level].ID;
    %%%%%:22606-block 25
call    0 never executed
    #####:22607:        tool->Results[stack_level].QueryFrameCount++;
call    0 never executed
        -:22608:    }
        -:22609:}
        -:22610:
        -:22611:// [DEBUG] ID Stack tool: hooks called by GetID() family functions
function _ZN5ImGui15DebugHookIdInfoEjiPKvS1_ called 0 returned 0% blocks executed 0%
    #####:22612:void ImGui::DebugHookIdInfo(ImGuiID id, ImGuiDataType data_type, const void* data_id, const void* data_id_end)
        -:22613:{
    #####:22614:    ImGuiContext& g = *GImGui;
    #####:22615:    ImGuiWindow* window = g.CurrentWindow;
    #####:22616:    ImGuiIDStackTool* tool = &g.DebugIDStackTool;
        -:22617:
        -:22618:    // Step 0: stack query
        -:22619:    // This assumes that the ID was computed with the current ID stack, which tends to be the case for our widget.
    #####:22620:    if (tool->StackLevel == -1)
    %%%%%:22620-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -:22621:    {
    #####:22622:        tool->StackLevel++;
    #####:22623:        tool->Results.resize(window->IDStack.Size + 1, ImGuiStackLevelInfo());
    %%%%%:22623-block 3
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####:22624:        for (int n = 0; n < window->IDStack.Size + 1; n++)
    %%%%%:22624-block 5
    %%%%%:22624-block 12
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:22625:            tool->Results[n].ID = (n < window->IDStack.Size) ? window->IDStack[n] : id;
    %%%%%:22625-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22625-block 7
call    2 never executed
    %%%%%:22625-block 9
    %%%%%:22625-block 10
call    3 never executed
    #####:22626:        return;
    %%%%%:22626-block 13
        -:22627:    }
        -:22628:
        -:22629:    // Step 1+: query for individual level
    #####:22630:    IM_ASSERT(tool->StackLevel >= 0);
    %%%%%:22630-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22630-block 15
call    2 never executed
    #####:22631:    if (tool->StackLevel != window->IDStack.Size)
    %%%%%:22631-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:22632:        return;
    %%%%%:22632-block 17
    #####:22633:    ImGuiStackLevelInfo* info = &tool->Results[tool->StackLevel];
    %%%%%:22633-block 18
call    0 never executed
    #####:22634:    IM_ASSERT(info->ID == id && info->QueryFrameCount > 0);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22634-block 20
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:22634-block 21
    %%%%%:22634-block 22
call    4 never executed
        -:22635:
    #####:22636:    switch (data_type)
    %%%%%:22636-block 23
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:22637:    {
    #####:22638:    case ImGuiDataType_S32:
    #####:22639:        ImFormatString(info->Desc, IM_ARRAYSIZE(info->Desc), "%d", (int)(intptr_t)data_id);
    %%%%%:22639-block 24
call    0 never executed
    #####:22640:        break;
    #####:22641:    case ImGuiDataType_String:
    #####:22642:        ImFormatString(info->Desc, IM_ARRAYSIZE(info->Desc), "%.*s", data_id_end ? (int)((const char*)data_id_end - (const char*)data_id) : (int)strlen((const char*)data_id), (const char*)data_id);
    %%%%%:22642-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22642-block 26
    %%%%%:22642-block 27
    %%%%%:22642-block 28
call    2 never executed
    #####:22643:        break;
    #####:22644:    case ImGuiDataType_Pointer:
    #####:22645:        ImFormatString(info->Desc, IM_ARRAYSIZE(info->Desc), "(void*)0x%p", data_id);
    %%%%%:22645-block 30
call    0 never executed
    #####:22646:        break;
    #####:22647:    case ImGuiDataType_ID:
    #####:22648:        if (info->Desc[0] != 0) // PushOverrideID() is often used to avoid hashing twice, which would lead to 2 calls to DebugHookIdInfo(). We prioritize the first one.
    %%%%%:22648-block 32
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:22649:            return;
    %%%%%:22649-block 33
    #####:22650:        ImFormatString(info->Desc, IM_ARRAYSIZE(info->Desc), "0x%08X [override]", id);
    %%%%%:22650-block 34
call    0 never executed
    #####:22651:        break;
    #####:22652:    default:
    #####:22653:        IM_ASSERT(0);
    %%%%%:22653-block 36
call    0 never executed
        -:22654:    }
    #####:22655:    info->QuerySuccess = true;
    #####:22656:    info->DataType = data_type;
    %%%%%:22656-block 38
        -:22657:}
        -:22658:
function _ZL24StackToolFormatLevelInfoP16ImGuiIDStackToolibPcm called 0 returned 0% blocks executed 0%
    #####:22659:static int StackToolFormatLevelInfo(ImGuiIDStackTool* tool, int n, bool format_for_ui, char* buf, size_t buf_size)
        -:22660:{
    #####:22661:    ImGuiStackLevelInfo* info = &tool->Results[n];
    %%%%%:22661-block 2
call    0 never executed
    #####:22662:    ImGuiWindow* window = (info->Desc[0] == 0 && n == 0) ? ImGui::FindWindowByID(info->ID) : NULL;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22662-block 4
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:22662-block 5
call    4 never executed
    %%%%%:22662-block 6
    #####:22663:    if (window)                                                                 // Source: window name (because the root ID don't call GetID() and so doesn't get hooked)
    %%%%%:22663-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:22664:        return ImFormatString(buf, buf_size, format_for_ui ? "\"%s\" [window]" : "%s", window->Name);
    %%%%%:22664-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22664-block 9
    %%%%%:22664-block 10
    %%%%%:22664-block 11
call    2 never executed
    #####:22665:    if (info->QuerySuccess)                                                     // Source: GetID() hooks (prioritize over ItemInfo() because we frequently use patterns like: PushID(str), Button("") where they both have same id)
    %%%%%:22665-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:22666:        return ImFormatString(buf, buf_size, (format_for_ui && info->DataType == ImGuiDataType_String) ? "\"%s\"" : "%s", info->Desc);
    %%%%%:22666-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22666-block 14
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:22666-block 15
    %%%%%:22666-block 16
    %%%%%:22666-block 17
call    4 never executed
    #####:22667:    if (tool->StackLevel < tool->Results.Size)                                  // Only start using fallback below when all queries are done, so during queries we don't flickering ??? markers.
    %%%%%:22667-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:22668:        return (*buf = 0);
    %%%%%:22668-block 19
        -:22669:#ifdef IMGUI_ENABLE_TEST_ENGINE
        -:22670:    if (const char* label = ImGuiTestEngine_FindItemDebugLabel(GImGui, info->ID))   // Source: ImGuiTestEngine's ItemInfo()
        -:22671:        return ImFormatString(buf, buf_size, format_for_ui ? "??? \"%s\"" : "%s", label);
        -:22672:#endif
    #####:22673:    return ImFormatString(buf, buf_size, "???");
    %%%%%:22673-block 20
call    0 never executed
        -:22674:}
        -:22675:
        -:22676:// ID Stack Tool: Display UI
function _ZN5ImGui21ShowIDStackToolWindowEPb called 0 returned 0% blocks executed 0%
    #####:22677:void ImGui::ShowIDStackToolWindow(bool* p_open)
        -:22678:{
    #####:22679:    ImGuiContext& g = *GImGui;
    #####:22680:    if ((g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSize) == 0)
    %%%%%:22680-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:22681:        SetNextWindowSize(ImVec2(0.0f, GetFontSize() * 8.0f), ImGuiCond_FirstUseEver);
    %%%%%:22681-block 3
call    0 never executed
call    1 never executed
call    2 never executed
    #####:22682:    if (!Begin("Dear ImGui ID Stack Tool", p_open) || GetCurrentWindow()->BeginCount > 1)
    %%%%%:22682-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:22682-block 9
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:22682-block 11
    %%%%%:22682-block 12
    %%%%%:22682-block 13
branch  6 never executed (fallthrough)
branch  7 never executed
        -:22683:    {
    #####:22684:        End();
    %%%%%:22684-block 14
call    0 never executed
    #####:22685:        return;
        -:22686:    }
        -:22687:
        -:22688:    // Display hovered/active status
    #####:22689:    ImGuiIDStackTool* tool = &g.DebugIDStackTool;
    #####:22690:    const ImGuiID hovered_id = g.HoveredIdPreviousFrame;
    #####:22691:    const ImGuiID active_id = g.ActiveId;
        -:22692:#ifdef IMGUI_ENABLE_TEST_ENGINE
        -:22693:    Text("HoveredId: 0x%08X (\"%s\"), ActiveId:  0x%08X (\"%s\")", hovered_id, hovered_id ? ImGuiTestEngine_FindItemDebugLabel(&g, hovered_id) : "", active_id, active_id ? ImGuiTestEngine_FindItemDebugLabel(&g, active_id) : "");
        -:22694:#else
    #####:22695:    Text("HoveredId: 0x%08X, ActiveId:  0x%08X", hovered_id, active_id);
    %%%%%:22695-block 16
call    0 never executed
        -:22696:#endif
    #####:22697:    SameLine();
call    0 never executed
    #####:22698:    MetricsHelpMarker("Hover an item with the mouse to display elements of the ID Stack leading to the item's final ID.\nEach level of the stack correspond to a PushID() call.\nAll levels of the stack are hashed together to make the final ID of a widget (ID displayed at the bottom level of the stack).\nRead FAQ entry about the ID stack for details.");
call    0 never executed
        -:22699:
        -:22700:    // CTRL+C to copy path
    #####:22701:    const float time_since_copy = (float)g.Time - tool->CopyToClipboardLastTime;
    #####:22702:    Checkbox("Ctrl+C: copy path to clipboard", &tool->CopyToClipboardOnCtrlC);
call    0 never executed
    #####:22703:    SameLine();
call    0 never executed
    #####:22704:    TextColored((time_since_copy >= 0.0f && time_since_copy < 0.75f && ImFmod(time_since_copy, 0.25f) < 0.25f * 0.5f) ? ImVec4(1.f, 1.f, 0.3f, 1.f) : ImVec4(), "*COPIED*");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22704-block 22
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:22704-block 23
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:22704-block 24
call    6 never executed
    %%%%%:22704-block 25
call    7 never executed
    %%%%%:22704-block 26
call    8 never executed
branch  9 never executed (fallthrough)
branch 10 never executed (throw)
    $$$$$:22704-block 78
call   11 never executed
    #####:22705:    if (tool->CopyToClipboardOnCtrlC && Shortcut(ImGuiMod_Ctrl | ImGuiKey_C, ImGuiInputFlags_RouteGlobal | ImGuiInputFlags_RouteOverFocused))
    %%%%%:22705-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22705-block 28
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:22705-block 30
    %%%%%:22705-block 31
    %%%%%:22705-block 32
branch  5 never executed (fallthrough)
branch  6 never executed
        -:22706:    {
    #####:22707:        tool->CopyToClipboardLastTime = (float)g.Time;
    #####:22708:        char* p = g.TempBuffer.Data;
    #####:22709:        char* p_end = p + g.TempBuffer.Size;
    #####:22710:        for (int stack_n = 0; stack_n < tool->Results.Size && p + 3 < p_end; stack_n++)
    %%%%%:22710-block 33
    %%%%%:22710-block 41
    %%%%%:22710-block 42
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22710-block 43
branch  2 never executed
branch  3 never executed (fallthrough)
        -:22711:        {
    #####:22712:            *p++ = '/';
        -:22713:            char level_desc[256];
    #####:22714:            StackToolFormatLevelInfo(tool, stack_n, false, level_desc, IM_ARRAYSIZE(level_desc));
    %%%%%:22714-block 34
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:22715:            for (int n = 0; level_desc[n] && p + 2 < p_end; n++)
    %%%%%:22715-block 35
    %%%%%:22715-block 39
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22715-block 40
branch  2 never executed
branch  3 never executed (fallthrough)
        -:22716:            {
    #####:22717:                if (level_desc[n] == '/')
    %%%%%:22717-block 36
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:22718:                    *p++ = '\\';
    %%%%%:22718-block 37
    #####:22719:                *p++ = level_desc[n];
    %%%%%:22719-block 38
        -:22720:            }
        -:22721:        }
    #####:22722:        *p = '\0';
    #####:22723:        SetClipboardText(g.TempBuffer.Data);
    %%%%%:22723-block 44
call    0 never executed
        -:22724:    }
        -:22725:
        -:22726:    // Display decorated stack
    #####:22727:    tool->LastActiveFrame = g.FrameCount;
    #####:22728:    if (tool->Results.Size > 0 && BeginTable("##table", 3, ImGuiTableFlags_Borders))
    %%%%%:22728-block 45
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22728-block 46
call    2 never executed
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    %%%%%:22728-block 48
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%:22728-block 49
    %%%%%:22728-block 50
    %%%%%:22728-block 51
branch  8 never executed (fallthrough)
branch  9 never executed
        -:22729:    {
    #####:22730:        const float id_width = CalcTextSize("0xDDDDDDDD").x;
    %%%%%:22730-block 52
call    0 never executed
    #####:22731:        TableSetupColumn("Seed", ImGuiTableColumnFlags_WidthFixed, id_width);
call    0 never executed
    #####:22732:        TableSetupColumn("PushID", ImGuiTableColumnFlags_WidthStretch);
call    0 never executed
    #####:22733:        TableSetupColumn("Result", ImGuiTableColumnFlags_WidthFixed, id_width);
call    0 never executed
    #####:22734:        TableHeadersRow();
call    0 never executed
    #####:22735:        for (int n = 0; n < tool->Results.Size; n++)
    %%%%%:22735-block 73
    %%%%%:22735-block 74
branch  0 never executed
branch  1 never executed (fallthrough)
        -:22736:        {
    #####:22737:            ImGuiStackLevelInfo* info = &tool->Results[n];
    %%%%%:22737-block 58
call    0 never executed
    #####:22738:            TableNextColumn();
call    0 never executed
    #####:22739:            Text("0x%08X", (n > 0) ? tool->Results[n - 1].ID : 0);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:22739-block 61
call    2 never executed
    %%%%%:22739-block 63
    %%%%%:22739-block 64
call    3 never executed
    #####:22740:            TableNextColumn();
call    0 never executed
    #####:22741:            StackToolFormatLevelInfo(tool, n, true, g.TempBuffer.Data, g.TempBuffer.Size);
call    0 never executed
    #####:22742:            TextUnformatted(g.TempBuffer.Data);
call    0 never executed
    #####:22743:            TableNextColumn();
call    0 never executed
    #####:22744:            Text("0x%08X", info->ID);
call    0 never executed
    #####:22745:            if (n == tool->Results.Size - 1)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:22746:                TableSetBgColor(ImGuiTableBgTarget_CellBg, GetColorU32(ImGuiCol_Header));
    %%%%%:22746-block 71
call    0 never executed
call    1 never executed
        -:22747:        }
    #####:22748:        EndTable();
    %%%%%:22748-block 75
call    0 never executed
        -:22749:    }
    #####:22750:    End();
    %%%%%:22750-block 76
call    0 never executed
        -:22751:}
        -:22752:
        -:22753:#else
        -:22754:
        -:22755:void ImGui::ShowMetricsWindow(bool*) {}
        -:22756:void ImGui::ShowFontAtlas(ImFontAtlas*) {}
        -:22757:void ImGui::DebugNodeColumns(ImGuiOldColumns*) {}
        -:22758:void ImGui::DebugNodeDrawList(ImGuiWindow*, ImGuiViewportP*, const ImDrawList*, const char*) {}
        -:22759:void ImGui::DebugNodeDrawCmdShowMeshAndBoundingBox(ImDrawList*, const ImDrawList*, const ImDrawCmd*, bool, bool) {}
        -:22760:void ImGui::DebugNodeFont(ImFont*) {}
        -:22761:void ImGui::DebugNodeStorage(ImGuiStorage*, const char*) {}
        -:22762:void ImGui::DebugNodeTabBar(ImGuiTabBar*, const char*) {}
        -:22763:void ImGui::DebugNodeWindow(ImGuiWindow*, const char*) {}
        -:22764:void ImGui::DebugNodeWindowSettings(ImGuiWindowSettings*) {}
        -:22765:void ImGui::DebugNodeWindowsList(ImVector<ImGuiWindow*>*, const char*) {}
        -:22766:void ImGui::DebugNodeViewport(ImGuiViewportP*) {}
        -:22767:
        -:22768:void ImGui::ShowDebugLogWindow(bool*) {}
        -:22769:void ImGui::ShowIDStackToolWindow(bool*) {}
        -:22770:void ImGui::DebugStartItemPicker() {}
        -:22771:void ImGui::DebugHookIdInfo(ImGuiID, ImGuiDataType, const void*, const void*) {}
        -:22772:
        -:22773:#endif // #ifndef IMGUI_DISABLE_DEBUG_TOOLS
        -:22774:
        -:22775://-----------------------------------------------------------------------------
        -:22776:
        -:22777:// Include imgui_user.inl at the end of imgui.cpp to access private data/functions that aren't exposed.
        -:22778:// Prefer just including imgui_internal.h from your code rather than using this define. If a declaration is missing from imgui_internal.h add it or request it on the github.
        -:22779:#ifdef IMGUI_INCLUDE_IMGUI_USER_INL
        -:22780:#include "imgui_user.inl"
        -:22781:#endif
        -:22782:
        -:22783://-----------------------------------------------------------------------------
        -:22784:
        -:22785:#endif // #ifndef IMGUI_DISABLE
