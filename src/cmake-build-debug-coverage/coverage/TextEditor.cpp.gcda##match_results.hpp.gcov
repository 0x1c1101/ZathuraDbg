        -:    0:Source:/home/rc/ZathuraDbg/vendor/ImGuiColorTextEdit/vendor/regex/include/boost/regex/v5/match_results.hpp
        -:    0:Graph:/home/rc/ZathuraDbg/src/cmake-build-debug-coverage/CMakeFiles/Zathura.dir/home/rc/ZathuraDbg/vendor/ImGuiColorTextEdit/TextEditor.cpp.gcno
        -:    0:Data:/home/rc/ZathuraDbg/src/cmake-build-debug-coverage/CMakeFiles/Zathura.dir/home/rc/ZathuraDbg/vendor/ImGuiColorTextEdit/TextEditor.cpp.gcda
        -:    0:Runs:1
        -:    1:/*
        -:    2: *
        -:    3: * Copyright (c) 1998-2009
        -:    4: * John Maddock
        -:    5: *
        -:    6: * Use, modification and distribution are subject to the 
        -:    7: * Boost Software License, Version 1.0. (See accompanying file 
        -:    8: * LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
        -:    9: *
        -:   10: */
        -:   11:
        -:   12: /*
        -:   13:  *   LOCATION:    see http://www.boost.org for most recent version.
        -:   14:  *   FILE         match_results.cpp
        -:   15:  *   VERSION      see <boost/version.hpp>
        -:   16:  *   DESCRIPTION: Declares template class match_results.
        -:   17:  */
        -:   18:
        -:   19:#ifndef BOOST_REGEX_V5_MATCH_RESULTS_HPP
        -:   20:#define BOOST_REGEX_V5_MATCH_RESULTS_HPP
        -:   21:
        -:   22:namespace boost{
        -:   23:#ifdef BOOST_REGEX_MSVC
        -:   24:#pragma warning(push)
        -:   25:#pragma warning(disable : 4251 4459)
        -:   26:#if BOOST_REGEX_MSVC < 1700
        -:   27:#     pragma warning(disable : 4231)
        -:   28:#endif
        -:   29:#  if BOOST_REGEX_MSVC < 1600
        -:   30:#     pragma warning(disable : 4660)
        -:   31:#  endif
        -:   32:#endif
        -:   33:
        -:   34:namespace BOOST_REGEX_DETAIL_NS{
        -:   35:
        -:   36:class named_subexpressions;
        -:   37:
        -:   38:}
        -:   39:
        -:   40:template <class BidiIterator, class Allocator>
        -:   41:class match_results
        -:   42:{ 
        -:   43:private:
        -:   44:   typedef          std::vector<sub_match<BidiIterator>, Allocator> vector_type;
        -:   45:public: 
        -:   46:   typedef          sub_match<BidiIterator>                         value_type;
        -:   47:   typedef typename std::allocator_traits<Allocator>::value_type const &    const_reference;
        -:   48:   typedef          const_reference                                         reference;
        -:   49:   typedef typename vector_type::const_iterator                             const_iterator;
        -:   50:   typedef          const_iterator                                          iterator;
        -:   51:   typedef typename std::iterator_traits<
        -:   52:                                    BidiIterator>::difference_type          difference_type;
        -:   53:   typedef typename std::allocator_traits<Allocator>::size_type             size_type;
        -:   54:   typedef          Allocator                                               allocator_type;
        -:   55:   typedef typename std::iterator_traits<
        -:   56:                                    BidiIterator>::value_type               char_type;
        -:   57:   typedef          std::basic_string<char_type>                            string_type;
        -:   58:   typedef          BOOST_REGEX_DETAIL_NS::named_subexpressions             named_sub_type;
        -:   59:
        -:   60:   // construct/copy/destroy:
function _ZN5boost13match_resultsIPKcSaINS_9sub_matchIS2_EEEEC2ERKS5_ called 1 returned 100% blocks executed 83%
        1:   61:   explicit match_results(const Allocator& a = Allocator())
        1:   62:      : m_subs(a), m_base(), m_null(), m_last_closed_paren(0), m_is_singular(true) {}
        1:   62-block 2
call    0 returned 1
call    1 returned 1
branch  2 taken 1 (fallthrough)
branch  3 taken 0 (throw)
        1:   62-block 4
call    4 returned 1
    $$$$$:   62-block 6
call    5 never executed
        -:   63:   //
        -:   64:   // IMPORTANT: in the code below, the crazy looking checks around m_is_singular are
        -:   65:   // all required because it is illegal to copy a singular iterator.
        -:   66:   // See https://svn.boost.org/trac/boost/ticket/3632.
        -:   67:   //
function _ZN5boost13match_resultsIPKcSaINS_9sub_matchIS2_EEEEC2ERKS6_ called 0 returned 0% blocks executed 0%
    #####:   68:   match_results(const match_results& m)
    #####:   69:      : m_subs(m.m_subs), m_base(), m_null(), m_named_subs(m.m_named_subs), m_last_closed_paren(m.m_last_closed_paren), m_is_singular(m.m_is_singular)
    %%%%%:   69-block 2
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:   69-block 4
call    4 never executed
        -:   70:   {
    #####:   71:      if(!m_is_singular)
branch  0 never executed (fallthrough)
branch  1 never executed
        -:   72:      {
    #####:   73:         m_base = m.m_base;
    #####:   74:         m_null = m.m_null;
    %%%%%:   74-block 6
call    0 never executed
        -:   75:      }
    #####:   76:   }
    %%%%%:   76-block 7
    $$$$$:   76-block 8
call    0 never executed
function _ZN5boost13match_resultsIPKcSaINS_9sub_matchIS2_EEEEaSERKS6_ called 0 returned 0% blocks executed 0%
    #####:   77:   match_results& operator=(const match_results& m)
        -:   78:   {
    #####:   79:      m_subs = m.m_subs;
    %%%%%:   79-block 2
call    0 never executed
    #####:   80:      m_named_subs = m.m_named_subs;
call    0 never executed
    #####:   81:      m_last_closed_paren = m.m_last_closed_paren;
    #####:   82:      m_is_singular = m.m_is_singular;
    #####:   83:      if(!m_is_singular)
branch  0 never executed (fallthrough)
branch  1 never executed
        -:   84:      {
    #####:   85:         m_base = m.m_base;
    #####:   86:         m_null = m.m_null;
    %%%%%:   86-block 5
call    0 never executed
        -:   87:      }
    #####:   88:      return *this;
    %%%%%:   88-block 6
        -:   89:   }
function _ZN5boost13match_resultsIPKcSaINS_9sub_matchIS2_EEEED2Ev called 1 returned 100% blocks executed 100%
        1:   90:   ~match_results(){}
        1:   90-block 2
call    0 returned 1
call    1 returned 1
        -:   91:
        -:   92:   // size:
function _ZNK5boost13match_resultsIPKcSaINS_9sub_matchIS2_EEEE4sizeEv called 0 returned 0% blocks executed 0%
    #####:   93:   size_type size() const
    #####:   94:   { return empty() ? 0 : m_subs.size() - 2; }
    %%%%%:   94-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:   94-block 4
    %%%%%:   94-block 5
call    3 never executed
    %%%%%:   94-block 7
        -:   95:   size_type max_size() const
        -:   96:   { return m_subs.max_size(); }
function _ZNK5boost13match_resultsIPKcSaINS_9sub_matchIS2_EEEE5emptyEv called 0 returned 0% blocks executed 0%
    #####:   97:   bool empty() const
    #####:   98:   { return m_subs.size() < 2; }
    %%%%%:   98-block 2
call    0 never executed
        -:   99:   // element access:
function _ZNK5boost13match_resultsIPKcSaINS_9sub_matchIS2_EEEE6lengthEi called 0 returned 0% blocks executed 0%
    #####:  100:   difference_type length(int sub = 0) const
        -:  101:   {
    #####:  102:      if(m_is_singular)
    %%%%%:  102-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  103:         raise_logic_error();
    %%%%%:  103-block 3
call    0 never executed
    #####:  104:      sub += 2;
    #####:  105:      if((sub < (int)m_subs.size()) && (sub > 0))
    %%%%%:  105-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:  105-block 6
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:  105-block 7
    %%%%%:  105-block 8
    %%%%%:  105-block 9
branch  5 never executed (fallthrough)
branch  6 never executed
    #####:  106:         return m_subs[sub].length();
    %%%%%:  106-block 10
call    0 never executed
call    1 never executed
    #####:  107:      return 0;
    %%%%%:  107-block 13
        -:  108:   }
        -:  109:   difference_type length(const char_type* sub) const
        -:  110:   {
        -:  111:      if(m_is_singular)
        -:  112:         raise_logic_error();
        -:  113:      const char_type* sub_end = sub;
        -:  114:      while(*sub_end) ++sub_end;
        -:  115:      return length(named_subexpression_index(sub, sub_end));
        -:  116:   }
        -:  117:   template <class charT>
        -:  118:   difference_type length(const charT* sub) const
        -:  119:   {
        -:  120:      if(m_is_singular)
        -:  121:         raise_logic_error();
        -:  122:      const charT* sub_end = sub;
        -:  123:      while(*sub_end) ++sub_end;
        -:  124:      return length(named_subexpression_index(sub, sub_end));
        -:  125:   }
        -:  126:   template <class charT, class Traits, class A>
        -:  127:   difference_type length(const std::basic_string<charT, Traits, A>& sub) const
        -:  128:   {
        -:  129:      return length(sub.c_str());
        -:  130:   }
        -:  131:   difference_type position(size_type sub = 0) const
        -:  132:   {
        -:  133:      if(m_is_singular)
        -:  134:         raise_logic_error();
        -:  135:      sub += 2;
        -:  136:      if(sub < m_subs.size())
        -:  137:      {
        -:  138:         const sub_match<BidiIterator>& s = m_subs[sub];
        -:  139:         if(s.matched || (sub == 2))
        -:  140:         {
        -:  141:            return std::distance((BidiIterator)(m_base), (BidiIterator)(s.first));
        -:  142:         }
        -:  143:      }
        -:  144:      return ~static_cast<difference_type>(0);
        -:  145:   }
        -:  146:   difference_type position(const char_type* sub) const
        -:  147:   {
        -:  148:      const char_type* sub_end = sub;
        -:  149:      while(*sub_end) ++sub_end;
        -:  150:      return position(named_subexpression_index(sub, sub_end));
        -:  151:   }
        -:  152:   template <class charT>
        -:  153:   difference_type position(const charT* sub) const
        -:  154:   {
        -:  155:      const charT* sub_end = sub;
        -:  156:      while(*sub_end) ++sub_end;
        -:  157:      return position(named_subexpression_index(sub, sub_end));
        -:  158:   }
        -:  159:   template <class charT, class Traits, class A>
        -:  160:   difference_type position(const std::basic_string<charT, Traits, A>& sub) const
        -:  161:   {
        -:  162:      return position(sub.c_str());
        -:  163:   }
        -:  164:   string_type str(int sub = 0) const
        -:  165:   {
        -:  166:      if(m_is_singular)
        -:  167:         raise_logic_error();
        -:  168:      sub += 2;
        -:  169:      string_type result;
        -:  170:      if(sub < (int)m_subs.size() && (sub > 0))
        -:  171:      {
        -:  172:         const sub_match<BidiIterator>& s = m_subs[sub];
        -:  173:         if(s.matched)
        -:  174:         {
        -:  175:            result = s.str();
        -:  176:         }
        -:  177:      }
        -:  178:      return result;
        -:  179:   }
        -:  180:   string_type str(const char_type* sub) const
        -:  181:   {
        -:  182:      return (*this)[sub].str();
        -:  183:   }
        -:  184:   template <class Traits, class A>
        -:  185:   string_type str(const std::basic_string<char_type, Traits, A>& sub) const
        -:  186:   {
        -:  187:      return (*this)[sub].str();
        -:  188:   }
        -:  189:   template <class charT>
        -:  190:   string_type str(const charT* sub) const
        -:  191:   {
        -:  192:      return (*this)[sub].str();
        -:  193:   }
        -:  194:   template <class charT, class Traits, class A>
        -:  195:   string_type str(const std::basic_string<charT, Traits, A>& sub) const
        -:  196:   {
        -:  197:      return (*this)[sub].str();
        -:  198:   }
function _ZNK5boost13match_resultsIPKcSaINS_9sub_matchIS2_EEEEixEi called 0 returned 0% blocks executed 0%
    #####:  199:   const_reference operator[](int sub) const
        -:  200:   {
    #####:  201:      if(m_is_singular && m_subs.empty())
    %%%%%:  201-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  201-block 3
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:  201-block 5
    %%%%%:  201-block 6
    %%%%%:  201-block 7
branch  5 never executed (fallthrough)
branch  6 never executed
    #####:  202:         raise_logic_error();
    %%%%%:  202-block 8
call    0 never executed
    #####:  203:      sub += 2;
    #####:  204:      if(sub < (int)m_subs.size() && (sub >= 0))
    %%%%%:  204-block 9
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:  204-block 11
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:  204-block 12
    %%%%%:  204-block 13
    %%%%%:  204-block 14
branch  5 never executed (fallthrough)
branch  6 never executed
        -:  205:      {
    #####:  206:         return m_subs[sub];
    %%%%%:  206-block 15
call    0 never executed
        -:  207:      }
    #####:  208:      return m_null;
    %%%%%:  208-block 16
        -:  209:   }
        -:  210:   //
        -:  211:   // Named sub-expressions:
        -:  212:   //
        -:  213:   const_reference named_subexpression(const char_type* i, const char_type* j) const
        -:  214:   {
        -:  215:      //
        -:  216:      // Scan for the leftmost *matched* subexpression with the specified named:
        -:  217:      //
        -:  218:      if(m_is_singular)
        -:  219:         raise_logic_error();
        -:  220:      BOOST_REGEX_DETAIL_NS::named_subexpressions::range_type r = m_named_subs->equal_range(i, j);
        -:  221:      while((r.first != r.second) && ((*this)[r.first->index].matched == false))
        -:  222:         ++r.first;
        -:  223:      return r.first != r.second ? (*this)[r.first->index] : m_null;
        -:  224:   }
        -:  225:   template <class charT>
        -:  226:   const_reference named_subexpression(const charT* i, const charT* j) const
        -:  227:   {
        -:  228:      static_assert(sizeof(charT) <= sizeof(char_type), "Failed internal logic");
        -:  229:      if(i == j)
        -:  230:         return m_null;
        -:  231:      std::vector<char_type> s;
        -:  232:      while(i != j)
        -:  233:         s.insert(s.end(), *i++);
        -:  234:      return named_subexpression(&*s.begin(), &*s.begin() + s.size());
        -:  235:   }
        -:  236:   int named_subexpression_index(const char_type* i, const char_type* j) const
        -:  237:   {
        -:  238:      //
        -:  239:      // Scan for the leftmost *matched* subexpression with the specified named.
        -:  240:      // If none found then return the leftmost expression with that name,
        -:  241:      // otherwise an invalid index:
        -:  242:      //
        -:  243:      if(m_is_singular)
        -:  244:         raise_logic_error();
        -:  245:      BOOST_REGEX_DETAIL_NS::named_subexpressions::range_type s, r;
        -:  246:      s = r = m_named_subs->equal_range(i, j);
        -:  247:      while((r.first != r.second) && ((*this)[r.first->index].matched == false))
        -:  248:         ++r.first;
        -:  249:      if(r.first == r.second)
        -:  250:         r = s;
        -:  251:      return r.first != r.second ? r.first->index : -20;
        -:  252:   }
        -:  253:   template <class charT>
        -:  254:   int named_subexpression_index(const charT* i, const charT* j) const
        -:  255:   {
        -:  256:      static_assert(sizeof(charT) <= sizeof(char_type), "Failed internal logic");
        -:  257:      if(i == j)
        -:  258:         return -20;
        -:  259:      std::vector<char_type> s;
        -:  260:      while(i != j)
        -:  261:         s.insert(s.end(), *i++);
        -:  262:      return named_subexpression_index(&*s.begin(), &*s.begin() + s.size());
        -:  263:   }
        -:  264:   template <class Traits, class A>
        -:  265:   const_reference operator[](const std::basic_string<char_type, Traits, A>& s) const
        -:  266:   {
        -:  267:      return named_subexpression(s.c_str(), s.c_str() + s.size());
        -:  268:   }
        -:  269:   const_reference operator[](const char_type* p) const
        -:  270:   {
        -:  271:      const char_type* e = p;
        -:  272:      while(*e) ++e;
        -:  273:      return named_subexpression(p, e);
        -:  274:   }
        -:  275:
        -:  276:   template <class charT>
        -:  277:   const_reference operator[](const charT* p) const
        -:  278:   {
        -:  279:      static_assert(sizeof(charT) <= sizeof(char_type), "Failed internal logic");
        -:  280:      if(*p == 0)
        -:  281:         return m_null;
        -:  282:      std::vector<char_type> s;
        -:  283:      while(*p)
        -:  284:         s.insert(s.end(), *p++);
        -:  285:      return named_subexpression(&*s.begin(), &*s.begin() + s.size());
        -:  286:   }
        -:  287:   template <class charT, class Traits, class A>
        -:  288:   const_reference operator[](const std::basic_string<charT, Traits, A>& ns) const
        -:  289:   {
        -:  290:      static_assert(sizeof(charT) <= sizeof(char_type), "Failed internal logic");
        -:  291:      if(ns.empty())
        -:  292:         return m_null;
        -:  293:      std::vector<char_type> s;
        -:  294:      for(unsigned i = 0; i < ns.size(); ++i)
        -:  295:         s.insert(s.end(), ns[i]);
        -:  296:      return named_subexpression(&*s.begin(), &*s.begin() + s.size());
        -:  297:   }
        -:  298:
function _ZNK5boost13match_resultsIPKcSaINS_9sub_matchIS2_EEEE6prefixEv called 0 returned 0% blocks executed 0%
    #####:  299:   const_reference prefix() const
        -:  300:   {
    #####:  301:      if(m_is_singular)
    %%%%%:  301-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  302:         raise_logic_error();
    %%%%%:  302-block 3
call    0 never executed
    #####:  303:      return (*this)[-1];
    %%%%%:  303-block 4
call    0 never executed
        -:  304:   }
        -:  305:
function _ZNK5boost13match_resultsIPKcSaINS_9sub_matchIS2_EEEE6suffixEv called 0 returned 0% blocks executed 0%
    #####:  306:   const_reference suffix() const
        -:  307:   {
    #####:  308:      if(m_is_singular)
    %%%%%:  308-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  309:         raise_logic_error();
    %%%%%:  309-block 3
call    0 never executed
    #####:  310:      return (*this)[-2];
    %%%%%:  310-block 4
call    0 never executed
        -:  311:   }
function _ZNK5boost13match_resultsIPKcSaINS_9sub_matchIS2_EEEE5beginEv called 0 returned 0% blocks executed 0%
    #####:  312:   const_iterator begin() const
        -:  313:   {
    #####:  314:      return (m_subs.size() > 2) ? (m_subs.begin() + 2) : m_subs.end();
    %%%%%:  314-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:  314-block 4
call    3 never executed
call    4 never executed
    %%%%%:  314-block 6
call    5 never executed
    %%%%%:  314-block 7
    %%%%%:  314-block 8
        -:  315:   }
        -:  316:   const_iterator end() const
        -:  317:   {
        -:  318:      return m_subs.end();
        -:  319:   }
        -:  320:   // format:
        -:  321:   template <class OutputIterator, class Functor>
        -:  322:   OutputIterator format(OutputIterator out,
        -:  323:                         Functor fmt,
        -:  324:                         match_flag_type flags = format_default) const
        -:  325:   {
        -:  326:      if(m_is_singular)
        -:  327:         raise_logic_error();
        -:  328:      typedef typename BOOST_REGEX_DETAIL_NS::compute_functor_type<Functor, match_results<BidiIterator, Allocator>, OutputIterator>::type F;
        -:  329:      F func(fmt);
        -:  330:      return func(*this, out, flags);
        -:  331:   }
        -:  332:   template <class Functor>
        -:  333:   string_type format(Functor fmt, match_flag_type flags = format_default) const
        -:  334:   {
        -:  335:      if(m_is_singular)
        -:  336:         raise_logic_error();
        -:  337:      std::basic_string<char_type> result;
        -:  338:      BOOST_REGEX_DETAIL_NS::string_out_iterator<std::basic_string<char_type> > i(result);
        -:  339:
        -:  340:      typedef typename BOOST_REGEX_DETAIL_NS::compute_functor_type<Functor, match_results<BidiIterator, Allocator>, BOOST_REGEX_DETAIL_NS::string_out_iterator<std::basic_string<char_type> > >::type F;
        -:  341:      F func(fmt);
        -:  342:
        -:  343:      func(*this, i, flags);
        -:  344:      return result;
        -:  345:   }
        -:  346:   // format with locale:
        -:  347:   template <class OutputIterator, class Functor, class RegexT>
        -:  348:   OutputIterator format(OutputIterator out,
        -:  349:                         Functor fmt,
        -:  350:                         match_flag_type flags,
        -:  351:                         const RegexT& re) const
        -:  352:   {
        -:  353:      if(m_is_singular)
        -:  354:         raise_logic_error();
        -:  355:      typedef ::boost::regex_traits_wrapper<typename RegexT::traits_type> traits_type;
        -:  356:      typedef typename BOOST_REGEX_DETAIL_NS::compute_functor_type<Functor, match_results<BidiIterator, Allocator>, OutputIterator, traits_type>::type F;
        -:  357:      F func(fmt);
        -:  358:      return func(*this, out, flags, re.get_traits());
        -:  359:   }
        -:  360:   template <class RegexT, class Functor>
        -:  361:   string_type format(Functor fmt,
        -:  362:                      match_flag_type flags,
        -:  363:                      const RegexT& re) const
        -:  364:   {
        -:  365:      if(m_is_singular)
        -:  366:         raise_logic_error();
        -:  367:      typedef ::boost::regex_traits_wrapper<typename RegexT::traits_type> traits_type;
        -:  368:      std::basic_string<char_type> result;
        -:  369:      BOOST_REGEX_DETAIL_NS::string_out_iterator<std::basic_string<char_type> > i(result);
        -:  370:
        -:  371:      typedef typename BOOST_REGEX_DETAIL_NS::compute_functor_type<Functor, match_results<BidiIterator, Allocator>, BOOST_REGEX_DETAIL_NS::string_out_iterator<std::basic_string<char_type> >, traits_type >::type F;
        -:  372:      F func(fmt);
        -:  373:
        -:  374:      func(*this, i, flags, re.get_traits());
        -:  375:      return result;
        -:  376:   }
        -:  377:
        -:  378:   const_reference get_last_closed_paren()const
        -:  379:   {
        -:  380:      if(m_is_singular)
        -:  381:         raise_logic_error();
        -:  382:      return m_last_closed_paren == 0 ? m_null : (*this)[m_last_closed_paren];
        -:  383:   }
        -:  384:
        -:  385:   allocator_type get_allocator() const
        -:  386:   {
        -:  387:      return m_subs.get_allocator();
        -:  388:   }
        -:  389:   void swap(match_results& that)
        -:  390:   {
        -:  391:      std::swap(m_subs, that.m_subs);
        -:  392:      std::swap(m_named_subs, that.m_named_subs);
        -:  393:      std::swap(m_last_closed_paren, that.m_last_closed_paren);
        -:  394:      if(m_is_singular)
        -:  395:      {
        -:  396:         if(!that.m_is_singular)
        -:  397:         {
        -:  398:            m_base = that.m_base;
        -:  399:            m_null = that.m_null;
        -:  400:         }
        -:  401:      }
        -:  402:      else if(that.m_is_singular)
        -:  403:      {
        -:  404:         that.m_base = m_base;
        -:  405:         that.m_null = m_null;
        -:  406:      }
        -:  407:      else
        -:  408:      {
        -:  409:         std::swap(m_base, that.m_base);
        -:  410:         std::swap(m_null, that.m_null);
        -:  411:      }
        -:  412:      std::swap(m_is_singular, that.m_is_singular);
        -:  413:   }
        -:  414:   bool operator==(const match_results& that)const
        -:  415:   {
        -:  416:      if(m_is_singular)
        -:  417:      {
        -:  418:         return that.m_is_singular;
        -:  419:      }
        -:  420:      else if(that.m_is_singular)
        -:  421:      {
        -:  422:         return false;
        -:  423:      }
        -:  424:      return (m_subs == that.m_subs) && (m_base == that.m_base) && (m_last_closed_paren == that.m_last_closed_paren);
        -:  425:   }
        -:  426:   bool operator!=(const match_results& that)const
        -:  427:   { return !(*this == that); }
        -:  428:
        -:  429:#ifdef BOOST_REGEX_MATCH_EXTRA
        -:  430:   typedef typename sub_match<BidiIterator>::capture_sequence_type capture_sequence_type;
        -:  431:
        -:  432:   const capture_sequence_type& captures(int i)const
        -:  433:   {
        -:  434:      if(m_is_singular)
        -:  435:         raise_logic_error();
        -:  436:      return (*this)[i].captures();
        -:  437:   }
        -:  438:#endif
        -:  439:
        -:  440:   //
        -:  441:   // private access functions:
function _ZN5boost13match_resultsIPKcSaINS_9sub_matchIS2_EEEE10set_secondES2_ called 0 returned 0% blocks executed 0%
    #####:  442:   void  set_second(BidiIterator i)
        -:  443:   {
    #####:  444:      BOOST_REGEX_ASSERT(m_subs.size() > 2);
    %%%%%:  444-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:  444-block 4
call    3 never executed
    #####:  445:      m_subs[2].second = i;
    %%%%%:  445-block 5
call    0 never executed
    #####:  446:      m_subs[2].matched = true;
call    0 never executed
    #####:  447:      m_subs[0].first = i;
call    0 never executed
    #####:  448:      m_subs[0].matched = (m_subs[0].first != m_subs[0].second);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  449:      m_null.first = i;
    #####:  450:      m_null.second = i;
    #####:  451:      m_null.matched = false;
    #####:  452:      m_is_singular = false;
    #####:  453:   }
        -:  454:
function _ZN5boost13match_resultsIPKcSaINS_9sub_matchIS2_EEEE10set_secondES2_mbb called 0 returned 0% blocks executed 0%
    #####:  455:   void  set_second(BidiIterator i, size_type pos, bool m = true, bool escape_k = false)
        -:  456:   {
    #####:  457:      if(pos)
    %%%%%:  457-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  458:         m_last_closed_paren = static_cast<int>(pos);
    %%%%%:  458-block 3
    #####:  459:      pos += 2;
    #####:  460:      BOOST_REGEX_ASSERT(m_subs.size() > pos);
    %%%%%:  460-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:  460-block 6
call    3 never executed
    #####:  461:      m_subs[pos].second = i;
    %%%%%:  461-block 7
call    0 never executed
    #####:  462:      m_subs[pos].matched = m;
call    0 never executed
    #####:  463:      if((pos == 2) && !escape_k)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  463-block 10
branch  2 never executed (fallthrough)
branch  3 never executed
        -:  464:      {
    #####:  465:         m_subs[0].first = i;
    %%%%%:  465-block 11
call    0 never executed
    #####:  466:         m_subs[0].matched = (m_subs[0].first != m_subs[0].second);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  467:         m_null.first = i;
    #####:  468:         m_null.second = i;
    #####:  469:         m_null.matched = false;
    #####:  470:         m_is_singular = false;
        -:  471:      }
    #####:  472:   }
function _ZN5boost13match_resultsIPKcSaINS_9sub_matchIS2_EEEE8set_sizeEmS2_S2_ called 0 returned 0% blocks executed 0%
    #####:  473:   void  set_size(size_type n, BidiIterator i, BidiIterator j)
        -:  474:   {
    #####:  475:      value_type v(j);
    %%%%%:  475-block 2
call    0 never executed
    #####:  476:      size_type len = m_subs.size();
call    0 never executed
    #####:  477:      if(len > n + 2)
branch  0 never executed (fallthrough)
branch  1 never executed
        -:  478:      {
    #####:  479:         m_subs.erase(m_subs.begin()+n+2, m_subs.end());
    %%%%%:  479-block 5
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed (throw)
    $$$$$:  479-block 25
    $$$$$:  479-block 26
    $$$$$:  479-block 27
    $$$$$:  479-block 28
    $$$$$:  479-block 29
    $$$$$:  479-block 30
    #####:  480:         std::fill(m_subs.begin(), m_subs.end(), v);
    %%%%%:  480-block 12
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
        -:  481:      }
        -:  482:      else
        -:  483:      {
    #####:  484:         std::fill(m_subs.begin(), m_subs.end(), v);
    %%%%%:  484-block 15
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####:  485:         if(n+2 != len)
    %%%%%:  485-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  486:            m_subs.insert(m_subs.end(), n+2-len, v);
    %%%%%:  486-block 19
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%:  486-block 22
    $$$$$:  486-block 31
    $$$$$:  486-block 32
        -:  487:      }
    #####:  488:      m_subs[1].first = i;
    %%%%%:  488-block 23
call    0 never executed
    #####:  489:      m_last_closed_paren = 0;
    #####:  490:   }
function _ZN5boost13match_resultsIPKcSaINS_9sub_matchIS2_EEEE8set_baseES2_ called 0 returned 0% blocks executed 0%
    #####:  491:   void  set_base(BidiIterator pos)
        -:  492:   {
    #####:  493:      m_base = pos;
    #####:  494:   }
        -:  495:   BidiIterator base()const
        -:  496:   {
        -:  497:      return m_base;
        -:  498:   }
function _ZN5boost13match_resultsIPKcSaINS_9sub_matchIS2_EEEE9set_firstES2_ called 0 returned 0% blocks executed 0%
    #####:  499:   void  set_first(BidiIterator i)
        -:  500:   {
    #####:  501:      BOOST_REGEX_ASSERT(m_subs.size() > 2);
    %%%%%:  501-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:  501-block 4
call    3 never executed
        -:  502:      // set up prefix:
    #####:  503:      m_subs[1].second = i;
    %%%%%:  503-block 5
call    0 never executed
    #####:  504:      m_subs[1].matched = (m_subs[1].first != i);
call    0 never executed
call    1 never executed
        -:  505:      // set up $0:
    #####:  506:      m_subs[2].first = i;
call    0 never executed
        -:  507:      // zero out everything else:
    #####:  508:      for(size_type n = 3; n < m_subs.size(); ++n)
    %%%%%:  508-block 15
call    0 never executed
branch  1 never executed
branch  2 never executed (fallthrough)
        -:  509:      {
    #####:  510:         m_subs[n].first = m_subs[n].second = m_subs[0].second;
    %%%%%:  510-block 10
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  511:         m_subs[n].matched = false;
call    0 never executed
        -:  512:      }
    #####:  513:   }
function _ZN5boost13match_resultsIPKcSaINS_9sub_matchIS2_EEEE9set_firstES2_mb called 0 returned 0% blocks executed 0%
    #####:  514:   void  set_first(BidiIterator i, size_type pos, bool escape_k = false)
        -:  515:   {
    #####:  516:      BOOST_REGEX_ASSERT(pos+2 < m_subs.size());
    %%%%%:  516-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:  516-block 4
call    3 never executed
    #####:  517:      if(pos || escape_k)
    %%%%%:  517-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  517-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
        -:  518:      {
    #####:  519:         m_subs[pos+2].first = i;
    %%%%%:  519-block 7
call    0 never executed
    #####:  520:         if(escape_k)
branch  0 never executed (fallthrough)
branch  1 never executed
        -:  521:         {
    #####:  522:            m_subs[1].second = i;
    %%%%%:  522-block 9
call    0 never executed
    #####:  523:            m_subs[1].matched = (m_subs[1].first != m_subs[1].second);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  524:         }
        -:  525:      }
        -:  526:      else
    #####:  527:         set_first(i);
    %%%%%:  527-block 15
call    0 never executed
    #####:  528:   }
        -:  529:   void  maybe_assign(const match_results<BidiIterator, Allocator>& m);
        -:  530:
function _ZN5boost13match_resultsIPKcSaINS_9sub_matchIS2_EEEE14set_named_subsESt10shared_ptrINS_13re_detail_50020named_subexpressionsEE called 0 returned 0% blocks executed 0%
    #####:  531:   void  set_named_subs(std::shared_ptr<named_sub_type> subs)
        -:  532:   {
    #####:  533:      m_named_subs = subs;
    %%%%%:  533-block 2
call    0 never executed
    #####:  534:   }
        -:  535:
        -:  536:private:
        -:  537:   //
        -:  538:   // Error handler called when an uninitialized match_results is accessed:
        -:  539:   //
function _ZN5boost13match_resultsIPKcSaINS_9sub_matchIS2_EEEE17raise_logic_errorEv called 0 returned 0% blocks executed 0%
    #####:  540:   static void raise_logic_error()
        -:  541:   {
    #####:  542:      std::logic_error e("Attempt to access an uninitialized boost::match_results<> class.");
    %%%%%:  542-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:  543:#ifndef BOOST_REGEX_STANDALONE
        -:  544:      boost::throw_exception(e);
        -:  545:#else
    #####:  546:      throw e;
    %%%%%:  546-block 3
call    0 never executed
call    1 never executed
call    2 never executed
        -:  547:#endif
    =====:  548:   }
    $$$$$:  548-block 6
call    0 never executed
        -:  549:
        -:  550:
        -:  551:   vector_type            m_subs;                      // subexpressions
        -:  552:   BidiIterator   m_base;                              // where the search started from
        -:  553:   sub_match<BidiIterator> m_null;                     // a null match
        -:  554:   std::shared_ptr<named_sub_type> m_named_subs;     // Shared copy of named subs in the regex object
        -:  555:   int m_last_closed_paren;                            // Last ) to be seen - used for formatting
        -:  556:   bool m_is_singular;                                 // True if our stored iterators are singular
        -:  557:};
        -:  558:
        -:  559:template <class BidiIterator, class Allocator>
function _ZN5boost13match_resultsIPKcSaINS_9sub_matchIS2_EEEE12maybe_assignERKS6_ called 0 returned 0% blocks executed 0%
    #####:  560:void  match_results<BidiIterator, Allocator>::maybe_assign(const match_results<BidiIterator, Allocator>& m)
        -:  561:{
    #####:  562:   if(m_is_singular)
    %%%%%:  562-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -:  563:   {
    #####:  564:      *this = m;
    %%%%%:  564-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  565:      return;
    %%%%%:  565-block 4
    %%%%%:  565-block 118
        -:  566:   }
    #####:  567:   const_iterator p1, p2;
    #####:  568:   p1 = begin();
    %%%%%:  568-block 5
call    0 never executed
    #####:  569:   p2 = m.begin();
call    0 never executed
        -:  570:   //
        -:  571:   // Distances are measured from the start of *this* match, unless this isn't
        -:  572:   // a valid match in which case we use the start of the whole sequence.  Note that
        -:  573:   // no subsequent match-candidate can ever be to the left of the first match found.
        -:  574:   // This ensures that when we are using bidirectional iterators, that distances 
        -:  575:   // measured are as short as possible, and therefore as efficient as possible
        -:  576:   // to compute.  Finally note that we don't use the "matched" data member to test
        -:  577:   // whether a sub-expression is a valid match, because partial matches set this
        -:  578:   // to false for sub-expression 0.
        -:  579:   //
    #####:  580:   BidiIterator l_end = this->suffix().second;
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  581:   BidiIterator l_base = (p1->first == l_end) ? this->prefix().first : (*this)[0].first;
    %%%%%:  581-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:  581-block 10
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    %%%%%:  581-block 11
    %%%%%:  581-block 12
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed (throw)
    %%%%%:  581-block 13
    #####:  582:   difference_type len1 = 0;
    #####:  583:   difference_type len2 = 0;
    #####:  584:   difference_type base1 = 0;
    #####:  585:   difference_type base2 = 0;
        -:  586:   std::size_t i;
    #####:  587:   for(i = 0; i < size(); ++i, ++p1, ++p2)
    %%%%%:  587-block 14
    %%%%%:  587-block 99
call    0 never executed
call    1 never executed
    %%%%%:  587-block 101
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%:  587-block 102
branch  5 never executed
branch  6 never executed (fallthrough)
        -:  588:   {
        -:  589:      //
        -:  590:      // Leftmost takes priority over longest; handle special cases
        -:  591:      // where distances need not be computed first (an optimisation
        -:  592:      // for bidirectional iterators: ensure that we don't accidently
        -:  593:      // compute the length of the whole sequence, as this can be really
        -:  594:      // expensive).
        -:  595:      //
    #####:  596:      if(p1->first == l_end)
    %%%%%:  596-block 15
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -:  597:      {
    #####:  598:         if(p2->first != l_end)
    %%%%%:  598-block 17
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -:  599:         {
        -:  600:            // p2 must be better than p1, and no need to calculate
        -:  601:            // actual distances:
    #####:  602:            base1 = 1;
    #####:  603:            base2 = 0;
    #####:  604:            break;
    %%%%%:  604-block 19
        -:  605:         }
        -:  606:         else
        -:  607:         {
        -:  608:            // *p1 and *p2 are either unmatched or match end-of sequence,
        -:  609:            // either way no need to calculate distances:
    #####:  610:            if((p1->matched == false) && (p2->matched == true))
    %%%%%:  610-block 20
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:  610-block 22
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:  610-block 24
    %%%%%:  610-block 25
    %%%%%:  610-block 26
branch  6 never executed (fallthrough)
branch  7 never executed
    #####:  611:               break;
    %%%%%:  611-block 27
    #####:  612:            if((p1->matched == true) && (p2->matched == false))
    %%%%%:  612-block 28
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:  612-block 30
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:  612-block 32
    %%%%%:  612-block 33
    %%%%%:  612-block 34
branch  6 never executed (fallthrough)
branch  7 never executed
    #####:  613:               return;
    %%%%%:  613-block 35
    #####:  614:            continue;
    %%%%%:  614-block 36
        -:  615:         }
        -:  616:      }
    #####:  617:      else if(p2->first == l_end)
    %%%%%:  617-block 37
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -:  618:      {
        -:  619:         // p1 better than p2, and no need to calculate distances:
    #####:  620:         return;
    %%%%%:  620-block 39
        -:  621:      }
    #####:  622:      base1 = std::distance(l_base, p1->first);
    %%%%%:  622-block 40
call    0 never executed
    #####:  623:      base2 = std::distance(l_base, p2->first);
    %%%%%:  623-block 47
call    0 never executed
    #####:  624:      BOOST_REGEX_ASSERT(base1 >= 0);
    %%%%%:  624-block 54
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  624-block 55
call    2 never executed
    #####:  625:      BOOST_REGEX_ASSERT(base2 >= 0);
    %%%%%:  625-block 56
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  625-block 57
call    2 never executed
    #####:  626:      if(base1 < base2) return;
    %%%%%:  626-block 58
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  626-block 59
    #####:  627:      if(base2 < base1) break;
    %%%%%:  627-block 60
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  627-block 61
        -:  628:
    #####:  629:      len1 = std::distance((BidiIterator)p1->first, (BidiIterator)p1->second);
    %%%%%:  629-block 62
call    0 never executed
call    1 never executed
    #####:  630:      len2 = std::distance((BidiIterator)p2->first, (BidiIterator)p2->second);
    %%%%%:  630-block 70
call    0 never executed
call    1 never executed
    #####:  631:      BOOST_REGEX_ASSERT(len1 >= 0);
    %%%%%:  631-block 78
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  631-block 79
call    2 never executed
    #####:  632:      BOOST_REGEX_ASSERT(len2 >= 0);
    %%%%%:  632-block 80
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  632-block 81
call    2 never executed
    #####:  633:      if((len1 != len2) || ((p1->matched == false) && (p2->matched == true)))
    %%%%%:  633-block 82
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  633-block 83
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:  633-block 85
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%:  633-block 87
    %%%%%:  633-block 88
    %%%%%:  633-block 89
branch  8 never executed (fallthrough)
branch  9 never executed
    #####:  634:         break;
    %%%%%:  634-block 90
    #####:  635:      if((p1->matched == true) && (p2->matched == false))
    %%%%%:  635-block 91
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:  635-block 93
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:  635-block 95
    %%%%%:  635-block 96
    %%%%%:  635-block 97
branch  6 never executed (fallthrough)
branch  7 never executed
    #####:  636:         return;
    %%%%%:  636-block 98
        -:  637:   }
    #####:  638:   if(i == size())
    %%%%%:  638-block 103
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:  638-block 104
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:  639:      return;
    %%%%%:  639-block 105
    #####:  640:   if(base2 < base1)
    %%%%%:  640-block 106
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  641:      *this = m;
    %%%%%:  641-block 107
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  642:   else if((len2 > len1) || ((p1->matched == false) && (p2->matched == true)) )
    %%%%%:  642-block 108
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  642-block 109
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:  642-block 111
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%:  642-block 113
    %%%%%:  642-block 114
    %%%%%:  642-block 115
branch  8 never executed (fallthrough)
branch  9 never executed
    #####:  643:      *this = m;
    %%%%%:  643-block 116
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:  644:}
        -:  645:
        -:  646:template <class BidiIterator, class Allocator>
        -:  647:void swap(match_results<BidiIterator, Allocator>& a, match_results<BidiIterator, Allocator>& b)
        -:  648:{
        -:  649:   a.swap(b);
        -:  650:}
        -:  651:
        -:  652:template <class charT, class traits, class BidiIterator, class Allocator>
        -:  653:std::basic_ostream<charT, traits>&
        -:  654:   operator << (std::basic_ostream<charT, traits>& os,
        -:  655:                const match_results<BidiIterator, Allocator>& s)
        -:  656:{
        -:  657:   return (os << s.str());
        -:  658:}
        -:  659:
        -:  660:#ifdef BOOST_REGEX_MSVC
        -:  661:#pragma warning(pop)
        -:  662:#endif
        -:  663:} // namespace boost
        -:  664:
        -:  665:#endif
        -:  666:
        -:  667:
