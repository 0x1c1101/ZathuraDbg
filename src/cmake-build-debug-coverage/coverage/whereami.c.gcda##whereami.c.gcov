        -:    0:Source:/home/rc/ZathuraDbg/vendor/whereami/src/whereami.c
        -:    0:Graph:/home/rc/ZathuraDbg/src/cmake-build-debug-coverage/CMakeFiles/Zathura.dir/home/rc/ZathuraDbg/vendor/whereami/src/whereami.c.gcno
        -:    0:Data:/home/rc/ZathuraDbg/src/cmake-build-debug-coverage/CMakeFiles/Zathura.dir/home/rc/ZathuraDbg/vendor/whereami/src/whereami.c.gcda
        -:    0:Runs:1
        -:    1:// (‑●‑●)> dual licensed under the WTFPL v2 and MIT licenses
        -:    2://   without any warranty.
        -:    3://   by Gregory Pakosz (@gpakosz)
        -:    4:// https://github.com/gpakosz/whereami
        -:    5:
        -:    6:// in case you want to #include "whereami.c" in a larger compilation unit
        -:    7:#if !defined(WHEREAMI_H)
        -:    8:#include <whereami.h>
        -:    9:#endif
        -:   10:
        -:   11:#ifdef __cplusplus
        -:   12:extern "C" {
        -:   13:#endif
        -:   14:
        -:   15:#if defined(__linux__) || defined(__CYGWIN__)
        -:   16:#undef _DEFAULT_SOURCE
        -:   17:#define _DEFAULT_SOURCE
        -:   18:#elif defined(__APPLE__)
        -:   19:#undef _DARWIN_C_SOURCE
        -:   20:#define _DARWIN_C_SOURCE
        -:   21:#define _DARWIN_BETTER_REALPATH
        -:   22:#endif
        -:   23:
        -:   24:#if !defined(WAI_MALLOC) || !defined(WAI_FREE) || !defined(WAI_REALLOC)
        -:   25:#include <stdlib.h>
        -:   26:#endif
        -:   27:
        -:   28:#if !defined(WAI_MALLOC)
        -:   29:#define WAI_MALLOC(size) malloc(size)
        -:   30:#endif
        -:   31:
        -:   32:#if !defined(WAI_FREE)
        -:   33:#define WAI_FREE(p) free(p)
        -:   34:#endif
        -:   35:
        -:   36:#if !defined(WAI_REALLOC)
        -:   37:#define WAI_REALLOC(p, size) realloc(p, size)
        -:   38:#endif
        -:   39:
        -:   40:#ifndef WAI_NOINLINE
        -:   41:#if defined(_MSC_VER)
        -:   42:#define WAI_NOINLINE __declspec(noinline)
        -:   43:#elif defined(__GNUC__)
        -:   44:#define WAI_NOINLINE __attribute__((noinline))
        -:   45:#else
        -:   46:#error unsupported compiler
        -:   47:#endif
        -:   48:#endif
        -:   49:
        -:   50:#if defined(_MSC_VER)
        -:   51:#define WAI_RETURN_ADDRESS() _ReturnAddress()
        -:   52:#elif defined(__GNUC__)
        -:   53:#define WAI_RETURN_ADDRESS() __builtin_extract_return_addr(__builtin_return_address(0))
        -:   54:#else
        -:   55:#error unsupported compiler
        -:   56:#endif
        -:   57:
        -:   58:#if defined(_WIN32)
        -:   59:
        -:   60:#ifndef WIN32_LEAN_AND_MEAN
        -:   61:#define WIN32_LEAN_AND_MEAN
        -:   62:#endif
        -:   63:#if defined(_MSC_VER)
        -:   64:#pragma warning(push, 3)
        -:   65:#endif
        -:   66:#include <windows.h>
        -:   67:#include <intrin.h>
        -:   68:#if defined(_MSC_VER)
        -:   69:#pragma warning(pop)
        -:   70:#endif
        -:   71:#if (_MSC_VER >= 1900)
        -:   72:#include <stdbool.h>
        -:   73:#else
        -:   74:#define bool int
        -:   75:#define false 0
        -:   76:#define true 1
        -:   77:#endif
        -:   78:
        -:   79:static int WAI_PREFIX(getModulePath_)(HMODULE module, char* out, int capacity, int* dirname_length)
        -:   80:{
        -:   81:  wchar_t buffer1[MAX_PATH];
        -:   82:  wchar_t buffer2[MAX_PATH];
        -:   83:  wchar_t* path = NULL;
        -:   84:  int length = -1;
        -:   85:  bool ok;
        -:   86:
        -:   87:  for (ok = false; !ok; ok = true)
        -:   88:  {
        -:   89:    DWORD size;
        -:   90:    int length_, length__;
        -:   91:
        -:   92:    size = GetModuleFileNameW(module, buffer1, sizeof(buffer1) / sizeof(buffer1[0]));
        -:   93:
        -:   94:    if (size == 0)
        -:   95:      break;
        -:   96:    else if (size == (DWORD)(sizeof(buffer1) / sizeof(buffer1[0])))
        -:   97:    {
        -:   98:      DWORD size_ = size;
        -:   99:      do
        -:  100:      {
        -:  101:        wchar_t* path_;
        -:  102:
        -:  103:        path_ = (wchar_t*)WAI_REALLOC(path, sizeof(wchar_t) * size_ * 2);
        -:  104:        if (!path_)
        -:  105:          break;
        -:  106:        size_ *= 2;
        -:  107:        path = path_;
        -:  108:        size = GetModuleFileNameW(module, path, size_);
        -:  109:      }
        -:  110:      while (size == size_);
        -:  111:
        -:  112:      if (size == size_)
        -:  113:        break;
        -:  114:    }
        -:  115:    else
        -:  116:      path = buffer1;
        -:  117:
        -:  118:    if (!_wfullpath(buffer2, path, MAX_PATH))
        -:  119:      break;
        -:  120:    length_ = (int)wcslen(buffer2);
        -:  121:    length__ = WideCharToMultiByte(CP_UTF8, 0, buffer2, length_ , out, capacity, NULL, NULL);
        -:  122:
        -:  123:    if (length__ == 0)
        -:  124:      length__ = WideCharToMultiByte(CP_UTF8, 0, buffer2, length_, NULL, 0, NULL, NULL);
        -:  125:    if (length__ == 0)
        -:  126:      break;
        -:  127:
        -:  128:    if (length__ <= capacity && dirname_length)
        -:  129:    {
        -:  130:      int i;
        -:  131:
        -:  132:      for (i = length__ - 1; i >= 0; --i)
        -:  133:      {
        -:  134:        if (out[i] == '\\')
        -:  135:        {
        -:  136:          *dirname_length = i;
        -:  137:          break;
        -:  138:        }
        -:  139:      }
        -:  140:    }
        -:  141:
        -:  142:    length = length__;
        -:  143:  }
        -:  144:
        -:  145:  if (path != buffer1)
        -:  146:    WAI_FREE(path);
        -:  147:
        -:  148:  return ok ? length : -1;
        -:  149:}
        -:  150:
        -:  151:WAI_NOINLINE WAI_FUNCSPEC
        -:  152:int WAI_PREFIX(getExecutablePath)(char* out, int capacity, int* dirname_length)
        -:  153:{
        -:  154:  return WAI_PREFIX(getModulePath_)(NULL, out, capacity, dirname_length);
        -:  155:}
        -:  156:
        -:  157:WAI_NOINLINE WAI_FUNCSPEC
        -:  158:int WAI_PREFIX(getModulePath)(char* out, int capacity, int* dirname_length)
        -:  159:{
        -:  160:  HMODULE module;
        -:  161:  int length = -1;
        -:  162:
        -:  163:#if defined(_MSC_VER)
        -:  164:#pragma warning(push)
        -:  165:#pragma warning(disable: 4054)
        -:  166:#endif
        -:  167:  if (GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, (LPCTSTR)WAI_RETURN_ADDRESS(), &module))
        -:  168:#if defined(_MSC_VER)
        -:  169:#pragma warning(pop)
        -:  170:#endif
        -:  171:  {
        -:  172:    length = WAI_PREFIX(getModulePath_)(module, out, capacity, dirname_length);
        -:  173:  }
        -:  174:
        -:  175:  return length;
        -:  176:}
        -:  177:
        -:  178:#elif defined(__linux__) || defined(__CYGWIN__) || defined(__sun) || defined(WAI_USE_PROC_SELF_EXE)
        -:  179:
        -:  180:#include <stdio.h>
        -:  181:#include <stdlib.h>
        -:  182:#include <string.h>
        -:  183:#if defined(__linux__)
        -:  184:#include <linux/limits.h>
        -:  185:#else
        -:  186:#include <limits.h>
        -:  187:#endif
        -:  188:#ifndef __STDC_FORMAT_MACROS
        -:  189:#define __STDC_FORMAT_MACROS
        -:  190:#endif
        -:  191:#include <inttypes.h>
        -:  192:#include <stdbool.h>
        -:  193:
        -:  194:#if !defined(WAI_PROC_SELF_EXE)
        -:  195:#if defined(__sun)
        -:  196:#define WAI_PROC_SELF_EXE "/proc/self/path/a.out"
        -:  197:#else
        -:  198:#define WAI_PROC_SELF_EXE "/proc/self/exe"
        -:  199:#endif
        -:  200:#endif
        -:  201:
        -:  202:WAI_FUNCSPEC
function wai_getExecutablePath called 2 returned 100% blocks executed 89%
        2:  203:int WAI_PREFIX(getExecutablePath)(char* out, int capacity, int* dirname_length)
        -:  204:{
        -:  205:  char buffer[PATH_MAX];
        2:  206:  char* resolved = NULL;
        2:  207:  int length = -1;
        -:  208:  bool ok;
        -:  209:
        4:  210:  for (ok = false; !ok; ok = true)
        2:  210-block 2
        2:  210-block 13
        4:  210-block 14
branch  0 taken 2
branch  1 taken 2 (fallthrough)
        -:  211:  {
        2:  212:    resolved = realpath(WAI_PROC_SELF_EXE, buffer);
        2:  212-block 3
call    0 returned 2
        2:  213:    if (!resolved)
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  214:      break;
    %%%%%:  214-block 5
        -:  215:
        2:  216:    length = (int)strlen(resolved);
        2:  217:    if (length <= capacity)
        2:  217-block 6
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        -:  218:    {
        1:  219:      memcpy(out, resolved, length);
        -:  220:
        1:  221:      if (dirname_length)
        1:  221-block 7
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -:  222:      {
        -:  223:        int i;
        -:  224:
        8:  225:        for (i = length - 1; i >= 0; --i)
        1:  225-block 8
        7:  225-block 11
        8:  225-block 12
branch  0 taken 8
branch  1 taken 0 (fallthrough)
        -:  226:        {
        8:  227:          if (out[i] == '/')
        8:  227-block 9
branch  0 taken 1 (fallthrough)
branch  1 taken 7
        -:  228:          {
        1:  229:            *dirname_length = i;
        1:  230:            break;
        1:  230-block 10
        -:  231:          }
        -:  232:        }
        -:  233:      }
        -:  234:    }
        -:  235:  }
        -:  236:
       2*:  237:  return ok ? length : -1;
        2:  237-block 15
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2:  237-block 16
    %%%%%:  237-block 17
        2:  237-block 18
        -:  238:}
        -:  239:
        -:  240:#if !defined(WAI_PROC_SELF_MAPS_RETRY)
        -:  241:#define WAI_PROC_SELF_MAPS_RETRY 5
        -:  242:#endif
        -:  243:
        -:  244:#if !defined(WAI_PROC_SELF_MAPS)
        -:  245:#if defined(__sun)
        -:  246:#define WAI_PROC_SELF_MAPS "/proc/self/map"
        -:  247:#else
        -:  248:#define WAI_PROC_SELF_MAPS "/proc/self/maps"
        -:  249:#endif
        -:  250:#endif
        -:  251:
        -:  252:#if !defined(WAI_STRINGIZE)
        -:  253:#define WAI_STRINGIZE(s)
        -:  254:#define WAI_STRINGIZE_(s) #s
        -:  255:#endif
        -:  256:
        -:  257:#if defined(__ANDROID__) || defined(ANDROID)
        -:  258:#include <fcntl.h>
        -:  259:#include <sys/mman.h>
        -:  260:#include <unistd.h>
        -:  261:#endif
        -:  262:#include <stdbool.h>
        -:  263:
        -:  264:WAI_NOINLINE WAI_FUNCSPEC
function wai_getModulePath called 0 returned 0% blocks executed 0%
    #####:  265:int WAI_PREFIX(getModulePath)(char* out, int capacity, int* dirname_length)
        -:  266:{
    #####:  267:  int length = -1;
    #####:  268:  FILE* maps = NULL;
        -:  269:
    #####:  270:  for (int r = 0; r < WAI_PROC_SELF_MAPS_RETRY; ++r)
    %%%%%:  270-block 2
    %%%%%:  270-block 29
    %%%%%:  270-block 30
branch  0 never executed
branch  1 never executed (fallthrough)
        -:  271:  {
    #####:  272:    maps = fopen(WAI_PROC_SELF_MAPS, "r");
    %%%%%:  272-block 3
call    0 never executed
    #####:  273:    if (!maps)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  274:      break;
    %%%%%:  274-block 5
        -:  275:
        -:  276:    for (;;)
    #####:  277:    {
    %%%%%:  277-block 25
        -:  278:      char buffer[128 + PATH_MAX];
        -:  279:      uintptr_t low, high;
        -:  280:      char perms[5];
        -:  281:      uint64_t offset;
        -:  282:      uint32_t major, minor, inode;
        -:  283:      char path[PATH_MAX + 1];
        -:  284:
    #####:  285:      if (!fgets(buffer, sizeof(buffer), maps))
    %%%%%:  285-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:  286:        break;
    %%%%%:  286-block 8
        -:  287:
    #####:  288:      if (sscanf(buffer, "%" SCNxPTR "-%" SCNxPTR " %s %" SCNx64 " %x:%x %u %" WAI_STRINGIZE(PATH_MAX) "[^\n]\n", &low, &high, perms, &offset, &major, &minor, &inode, path) == 8)
    %%%%%:  288-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
        -:  289:      {
    #####:  290:        void* _addr = WAI_RETURN_ADDRESS();
    %%%%%:  290-block 10
call    0 never executed
call    1 never executed
    #####:  291:        uintptr_t addr = (uintptr_t)_addr;
    #####:  292:        if (low <= addr && addr <= high)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  292-block 13
branch  2 never executed (fallthrough)
branch  3 never executed
        -:  293:        {
        -:  294:          char* resolved;
        -:  295:
    #####:  296:          resolved = realpath(path, buffer);
    %%%%%:  296-block 14
call    0 never executed
    #####:  297:          if (!resolved)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  298:            break;
    %%%%%:  298-block 16
        -:  299:
    #####:  300:          length = (int)strlen(resolved);
        -:  301:#if defined(__ANDROID__) || defined(ANDROID)
        -:  302:          if (length > 4
        -:  303:              &&buffer[length - 1] == 'k'
        -:  304:              &&buffer[length - 2] == 'p'
        -:  305:              &&buffer[length - 3] == 'a'
        -:  306:              &&buffer[length - 4] == '.')
        -:  307:          {
        -:  308:            int fd = open(path, O_RDONLY);
        -:  309:            if (fd == -1)
        -:  310:            {
        -:  311:              length = -1; // retry
        -:  312:              break;
        -:  313:            }
        -:  314:
        -:  315:            char* begin = (char*)mmap(0, offset, PROT_READ, MAP_SHARED, fd, 0);
        -:  316:            if (begin == MAP_FAILED)
        -:  317:            {
        -:  318:              close(fd);
        -:  319:              length = -1; // retry
        -:  320:              break;
        -:  321:            }
        -:  322:
        -:  323:            char* p = begin + offset - 30; // minimum size of local file header
        -:  324:            while (p >= begin) // scan backwards
        -:  325:            {
        -:  326:              if (*((uint32_t*)p) == 0x04034b50UL) // local file header signature found
        -:  327:              {
        -:  328:                uint16_t length_ = *((uint16_t*)(p + 26));
        -:  329:
        -:  330:                if (length + 2 + length_ < (int)sizeof(buffer))
        -:  331:                {
        -:  332:                  memcpy(&buffer[length], "!/", 2);
        -:  333:                  memcpy(&buffer[length + 2], p + 30, length_);
        -:  334:                  length += 2 + length_;
        -:  335:                }
        -:  336:
        -:  337:                break;
        -:  338:              }
        -:  339:
        -:  340:              --p;
        -:  341:            }
        -:  342:
        -:  343:            munmap(begin, offset);
        -:  344:            close(fd);
        -:  345:          }
        -:  346:#endif
    #####:  347:          if (length <= capacity)
    %%%%%:  347-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
        -:  348:          {
    #####:  349:            memcpy(out, resolved, length);
        -:  350:
    #####:  351:            if (dirname_length)
    %%%%%:  351-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
        -:  352:            {
        -:  353:              int i;
        -:  354:
    #####:  355:              for (i = length - 1; i >= 0; --i)
    %%%%%:  355-block 19
    %%%%%:  355-block 22
    %%%%%:  355-block 23
branch  0 never executed
branch  1 never executed (fallthrough)
        -:  356:              {
    #####:  357:                if (out[i] == '/')
    %%%%%:  357-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
        -:  358:                {
    #####:  359:                  *dirname_length = i;
    #####:  360:                  break;
    %%%%%:  360-block 21
        -:  361:                }
        -:  362:              }
        -:  363:            }
        -:  364:          }
        -:  365:
    #####:  366:          break;
    %%%%%:  366-block 24
        -:  367:        }
        -:  368:      }
        -:  369:    }
        -:  370:
    #####:  371:    fclose(maps);
    %%%%%:  371-block 26
call    0 never executed
    #####:  372:    maps = NULL;
        -:  373:
    #####:  374:    if (length != -1)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  375:      break;
    %%%%%:  375-block 28
        -:  376:  }
        -:  377:
    #####:  378:  return length;
    %%%%%:  378-block 31
        -:  379:}
        -:  380:
        -:  381:#elif defined(__APPLE__)
        -:  382:
        -:  383:#include <mach-o/dyld.h>
        -:  384:#include <limits.h>
        -:  385:#include <stdlib.h>
        -:  386:#include <string.h>
        -:  387:#include <dlfcn.h>
        -:  388:#include <stdbool.h>
        -:  389:
        -:  390:WAI_FUNCSPEC
        -:  391:int WAI_PREFIX(getExecutablePath)(char* out, int capacity, int* dirname_length)
        -:  392:{
        -:  393:  char buffer1[PATH_MAX];
        -:  394:  char buffer2[PATH_MAX];
        -:  395:  char* path = buffer1;
        -:  396:  char* resolved = NULL;
        -:  397:  int length = -1;
        -:  398:  bool ok;
        -:  399:
        -:  400:  for (ok = false; !ok; ok = true)
        -:  401:  {
        -:  402:    uint32_t size = (uint32_t)sizeof(buffer1);
        -:  403:    if (_NSGetExecutablePath(path, &size) == -1)
        -:  404:    {
        -:  405:      path = (char*)WAI_MALLOC(size);
        -:  406:      if (!_NSGetExecutablePath(path, &size))
        -:  407:        break;
        -:  408:    }
        -:  409:
        -:  410:    resolved = realpath(path, buffer2);
        -:  411:    if (!resolved)
        -:  412:      break;
        -:  413:
        -:  414:    length = (int)strlen(resolved);
        -:  415:    if (length <= capacity)
        -:  416:    {
        -:  417:      memcpy(out, resolved, length);
        -:  418:
        -:  419:      if (dirname_length)
        -:  420:      {
        -:  421:        int i;
        -:  422:
        -:  423:        for (i = length - 1; i >= 0; --i)
        -:  424:        {
        -:  425:          if (out[i] == '/')
        -:  426:          {
        -:  427:            *dirname_length = i;
        -:  428:            break;
        -:  429:          }
        -:  430:        }
        -:  431:      }
        -:  432:    }
        -:  433:  }
        -:  434:
        -:  435:  if (path != buffer1)
        -:  436:    WAI_FREE(path);
        -:  437:
        -:  438:  return ok ? length : -1;
        -:  439:}
        -:  440:
        -:  441:WAI_NOINLINE WAI_FUNCSPEC
        -:  442:int WAI_PREFIX(getModulePath)(char* out, int capacity, int* dirname_length)
        -:  443:{
        -:  444:  char buffer[PATH_MAX];
        -:  445:  char* resolved = NULL;
        -:  446:  int length = -1;
        -:  447:
        -:  448:  for(;;)
        -:  449:  {
        -:  450:    Dl_info info;
        -:  451:
        -:  452:    if (dladdr(WAI_RETURN_ADDRESS(), &info))
        -:  453:    {
        -:  454:      resolved = realpath(info.dli_fname, buffer);
        -:  455:      if (!resolved)
        -:  456:        break;
        -:  457:
        -:  458:      length = (int)strlen(resolved);
        -:  459:      if (length <= capacity)
        -:  460:      {
        -:  461:        memcpy(out, resolved, length);
        -:  462:
        -:  463:        if (dirname_length)
        -:  464:        {
        -:  465:          int i;
        -:  466:
        -:  467:          for (i = length - 1; i >= 0; --i)
        -:  468:          {
        -:  469:            if (out[i] == '/')
        -:  470:            {
        -:  471:              *dirname_length = i;
        -:  472:              break;
        -:  473:            }
        -:  474:          }
        -:  475:        }
        -:  476:      }
        -:  477:    }
        -:  478:
        -:  479:    break;
        -:  480:  }
        -:  481:
        -:  482:  return length;
        -:  483:}
        -:  484:
        -:  485:#elif defined(__QNXNTO__)
        -:  486:
        -:  487:#include <limits.h>
        -:  488:#include <stdio.h>
        -:  489:#include <stdlib.h>
        -:  490:#include <string.h>
        -:  491:#include <dlfcn.h>
        -:  492:#include <stdbool.h>
        -:  493:
        -:  494:#if !defined(WAI_PROC_SELF_EXE)
        -:  495:#define WAI_PROC_SELF_EXE "/proc/self/exefile"
        -:  496:#endif
        -:  497:
        -:  498:WAI_FUNCSPEC
        -:  499:int WAI_PREFIX(getExecutablePath)(char* out, int capacity, int* dirname_length)
        -:  500:{
        -:  501:  char buffer1[PATH_MAX];
        -:  502:  char buffer2[PATH_MAX];
        -:  503:  char* resolved = NULL;
        -:  504:  FILE* self_exe = NULL;
        -:  505:  int length = -1;
        -:  506:  bool ok;
        -:  507:
        -:  508:  for (ok = false; !ok; ok = true)
        -:  509:  {
        -:  510:    self_exe = fopen(WAI_PROC_SELF_EXE, "r");
        -:  511:    if (!self_exe)
        -:  512:      break;
        -:  513:
        -:  514:    if (!fgets(buffer1, sizeof(buffer1), self_exe))
        -:  515:      break;
        -:  516:
        -:  517:    resolved = realpath(buffer1, buffer2);
        -:  518:    if (!resolved)
        -:  519:      break;
        -:  520:
        -:  521:    length = (int)strlen(resolved);
        -:  522:    if (length <= capacity)
        -:  523:    {
        -:  524:      memcpy(out, resolved, length);
        -:  525:
        -:  526:      if (dirname_length)
        -:  527:      {
        -:  528:        int i;
        -:  529:
        -:  530:        for (i = length - 1; i >= 0; --i)
        -:  531:        {
        -:  532:          if (out[i] == '/')
        -:  533:          {
        -:  534:            *dirname_length = i;
        -:  535:            break;
        -:  536:          }
        -:  537:        }
        -:  538:      }
        -:  539:    }
        -:  540:  }
        -:  541:
        -:  542:  fclose(self_exe);
        -:  543:
        -:  544:  return ok ? length : -1;
        -:  545:}
        -:  546:
        -:  547:WAI_FUNCSPEC
        -:  548:int WAI_PREFIX(getModulePath)(char* out, int capacity, int* dirname_length)
        -:  549:{
        -:  550:  char buffer[PATH_MAX];
        -:  551:  char* resolved = NULL;
        -:  552:  int length = -1;
        -:  553:
        -:  554:  for(;;)
        -:  555:  {
        -:  556:    Dl_info info;
        -:  557:
        -:  558:    if (dladdr(WAI_RETURN_ADDRESS(), &info))
        -:  559:    {
        -:  560:      resolved = realpath(info.dli_fname, buffer);
        -:  561:      if (!resolved)
        -:  562:        break;
        -:  563:
        -:  564:      length = (int)strlen(resolved);
        -:  565:      if (length <= capacity)
        -:  566:      {
        -:  567:        memcpy(out, resolved, length);
        -:  568:
        -:  569:        if (dirname_length)
        -:  570:        {
        -:  571:          int i;
        -:  572:
        -:  573:          for (i = length - 1; i >= 0; --i)
        -:  574:          {
        -:  575:            if (out[i] == '/')
        -:  576:            {
        -:  577:              *dirname_length = i;
        -:  578:              break;
        -:  579:            }
        -:  580:          }
        -:  581:        }
        -:  582:      }
        -:  583:    }
        -:  584:
        -:  585:    break;
        -:  586:  }
        -:  587:
        -:  588:  return length;
        -:  589:}
        -:  590:
        -:  591:#elif defined(__DragonFly__) || defined(__FreeBSD__) || \
        -:  592:      defined(__FreeBSD_kernel__) || defined(__NetBSD__) || defined(__OpenBSD__)
        -:  593:
        -:  594:#include <limits.h>
        -:  595:#include <stdlib.h>
        -:  596:#include <string.h>
        -:  597:#include <sys/types.h>
        -:  598:#include <sys/sysctl.h>
        -:  599:#include <dlfcn.h>
        -:  600:#include <stdbool.h>
        -:  601:
        -:  602:#if defined(__OpenBSD__)
        -:  603:
        -:  604:#include <unistd.h>
        -:  605:
        -:  606:WAI_FUNCSPEC
        -:  607:int WAI_PREFIX(getExecutablePath)(char* out, int capacity, int* dirname_length)
        -:  608:{
        -:  609:  char buffer1[4096];
        -:  610:  char buffer2[PATH_MAX];
        -:  611:  char buffer3[PATH_MAX];
        -:  612:  char** argv = (char**)buffer1;
        -:  613:  char* resolved = NULL;
        -:  614:  int length = -1;
        -:  615:  bool ok;
        -:  616:
        -:  617:  for (ok = false; !ok; ok = true)
        -:  618:  {
        -:  619:    int mib[4] = { CTL_KERN, KERN_PROC_ARGS, getpid(), KERN_PROC_ARGV };
        -:  620:    size_t size;
        -:  621:
        -:  622:    if (sysctl(mib, 4, NULL, &size, NULL, 0) != 0)
        -:  623:        break;
        -:  624:
        -:  625:    if (size > sizeof(buffer1))
        -:  626:    {
        -:  627:      argv = (char**)WAI_MALLOC(size);
        -:  628:      if (!argv)
        -:  629:        break;
        -:  630:    }
        -:  631:
        -:  632:    if (sysctl(mib, 4, argv, &size, NULL, 0) != 0)
        -:  633:        break;
        -:  634:
        -:  635:    if (strchr(argv[0], '/'))
        -:  636:    {
        -:  637:      resolved = realpath(argv[0], buffer2);
        -:  638:      if (!resolved)
        -:  639:        break;
        -:  640:    }
        -:  641:    else
        -:  642:    {
        -:  643:      const char* PATH = getenv("PATH");
        -:  644:      if (!PATH)
        -:  645:        break;
        -:  646:
        -:  647:      size_t argv0_length = strlen(argv[0]);
        -:  648:
        -:  649:      const char* begin = PATH;
        -:  650:      while (1)
        -:  651:      {
        -:  652:        const char* separator = strchr(begin, ':');
        -:  653:        const char* end = separator ? separator : begin + strlen(begin);
        -:  654:
        -:  655:        if (end - begin > 0)
        -:  656:        {
        -:  657:          if (*(end -1) == '/')
        -:  658:            --end;
        -:  659:
        -:  660:          if (((end - begin) + 1 + argv0_length + 1) <= sizeof(buffer2))
        -:  661:          {
        -:  662:            memcpy(buffer2, begin, end - begin);
        -:  663:            buffer2[end - begin] = '/';
        -:  664:            memcpy(buffer2 + (end - begin) + 1, argv[0], argv0_length + 1);
        -:  665:
        -:  666:            resolved = realpath(buffer2, buffer3);
        -:  667:            if (resolved)
        -:  668:              break;
        -:  669:          }
        -:  670:        }
        -:  671:
        -:  672:        if (!separator)
        -:  673:          break;
        -:  674:
        -:  675:        begin = ++separator;
        -:  676:      }
        -:  677:
        -:  678:      if (!resolved)
        -:  679:        break;
        -:  680:    }
        -:  681:
        -:  682:    length = (int)strlen(resolved);
        -:  683:    if (length <= capacity)
        -:  684:    {
        -:  685:      memcpy(out, resolved, length);
        -:  686:
        -:  687:      if (dirname_length)
        -:  688:      {
        -:  689:        int i;
        -:  690:
        -:  691:        for (i = length - 1; i >= 0; --i)
        -:  692:        {
        -:  693:          if (out[i] == '/')
        -:  694:          {
        -:  695:            *dirname_length = i;
        -:  696:            break;
        -:  697:          }
        -:  698:        }
        -:  699:      }
        -:  700:    }
        -:  701:  }
        -:  702:
        -:  703:  if (argv != (char**)buffer1)
        -:  704:    WAI_FREE(argv);
        -:  705:
        -:  706:  return ok ? length : -1;
        -:  707:}
        -:  708:
        -:  709:#else
        -:  710:
        -:  711:WAI_FUNCSPEC
        -:  712:int WAI_PREFIX(getExecutablePath)(char* out, int capacity, int* dirname_length)
        -:  713:{
        -:  714:  char buffer1[PATH_MAX];
        -:  715:  char buffer2[PATH_MAX];
        -:  716:  char* path = buffer1;
        -:  717:  char* resolved = NULL;
        -:  718:  int length = -1;
        -:  719:  bool ok;
        -:  720:
        -:  721:  for (ok = false; !ok; ok = true)
        -:  722:  {
        -:  723:#if defined(__NetBSD__)
        -:  724:    int mib[4] = { CTL_KERN, KERN_PROC_ARGS, -1, KERN_PROC_PATHNAME };
        -:  725:#else
        -:  726:    int mib[4] = { CTL_KERN, KERN_PROC, KERN_PROC_PATHNAME, -1 };
        -:  727:#endif
        -:  728:    size_t size = sizeof(buffer1);
        -:  729:
        -:  730:    if (sysctl(mib, 4, path, &size, NULL, 0) != 0)
        -:  731:        break;
        -:  732:
        -:  733:    resolved = realpath(path, buffer2);
        -:  734:    if (!resolved)
        -:  735:      break;
        -:  736:
        -:  737:    length = (int)strlen(resolved);
        -:  738:    if (length <= capacity)
        -:  739:    {
        -:  740:      memcpy(out, resolved, length);
        -:  741:
        -:  742:      if (dirname_length)
        -:  743:      {
        -:  744:        int i;
        -:  745:
        -:  746:        for (i = length - 1; i >= 0; --i)
        -:  747:        {
        -:  748:          if (out[i] == '/')
        -:  749:          {
        -:  750:            *dirname_length = i;
        -:  751:            break;
        -:  752:          }
        -:  753:        }
        -:  754:      }
        -:  755:    }
        -:  756:  }
        -:  757:
        -:  758:  return ok ? length : -1;
        -:  759:}
        -:  760:
        -:  761:#endif
        -:  762:
        -:  763:WAI_NOINLINE WAI_FUNCSPEC
        -:  764:int WAI_PREFIX(getModulePath)(char* out, int capacity, int* dirname_length)
        -:  765:{
        -:  766:  char buffer[PATH_MAX];
        -:  767:  char* resolved = NULL;
        -:  768:  int length = -1;
        -:  769:
        -:  770:  for(;;)
        -:  771:  {
        -:  772:    Dl_info info;
        -:  773:
        -:  774:    if (dladdr(WAI_RETURN_ADDRESS(), &info))
        -:  775:    {
        -:  776:      resolved = realpath(info.dli_fname, buffer);
        -:  777:      if (!resolved)
        -:  778:        break;
        -:  779:
        -:  780:      length = (int)strlen(resolved);
        -:  781:      if (length <= capacity)
        -:  782:      {
        -:  783:        memcpy(out, resolved, length);
        -:  784:
        -:  785:        if (dirname_length)
        -:  786:        {
        -:  787:          int i;
        -:  788:
        -:  789:          for (i = length - 1; i >= 0; --i)
        -:  790:          {
        -:  791:            if (out[i] == '/')
        -:  792:            {
        -:  793:              *dirname_length = i;
        -:  794:              break;
        -:  795:            }
        -:  796:          }
        -:  797:        }
        -:  798:      }
        -:  799:    }
        -:  800:
        -:  801:    break;
        -:  802:  }
        -:  803:
        -:  804:  return length;
        -:  805:}
        -:  806:
        -:  807:#else
        -:  808:
        -:  809:#error unsupported platform
        -:  810:
        -:  811:#endif
        -:  812:
        -:  813:#ifdef __cplusplus
        -:  814:}
        -:  815:#endif
