        -:    0:Source:/home/rc/ZathuraDbg/src/utils/stb_image.h
        -:    0:Graph:/home/rc/ZathuraDbg/src/cmake-build-debug-coverage/CMakeFiles/Zathura.dir/main.cpp.gcno
        -:    0:Data:/home/rc/ZathuraDbg/src/cmake-build-debug-coverage/CMakeFiles/Zathura.dir/main.cpp.gcda
        -:    0:Runs:1
        -:    1:#ifndef ZATHURA_STB_IMAGE_H
        -:    2:#define ZATHURA_STB_IMAGE_H
        -:    3:
        -:    4:/* stb_image - v2.30 - public domain image loader - http://nothings.org/stb
        -:    5:                                  no warranty implied; use at your own risk
        -:    6:
        -:    7:   Do this:
        -:    8:      #define STB_IMAGE_IMPLEMENTATION
        -:    9:   before you include this file in *one* C or C++ file to create the implementation.
        -:   10:
        -:   11:   // i.e. it should look like this:
        -:   12:   #include ...
        -:   13:   #include ...
        -:   14:   #include ...
        -:   15:   #define STB_IMAGE_IMPLEMENTATION
        -:   16:   #include "stb_image.h"
        -:   17:
        -:   18:   You can #define STBI_ASSERT(x) before the #include to avoid using assert.h.
        -:   19:   And #define STBI_MALLOC, STBI_REALLOC, and STBI_FREE to avoid using malloc,realloc,free
        -:   20:
        -:   21:
        -:   22:   QUICK NOTES:
        -:   23:      Primarily of interest to game developers and other people who can
        -:   24:          avoid problematic images and only need the trivial interface
        -:   25:
        -:   26:      JPEG baseline & progressive (12 bpc/arithmetic not supported, same as stock IJG lib)
        -:   27:      PNG 1/2/4/8/16-bit-per-channel
        -:   28:
        -:   29:      TGA (not sure what subset, if a subset)
        -:   30:      BMP non-1bpp, non-RLE
        -:   31:      PSD (composited view only, no extra channels, 8/16 bit-per-channel)
        -:   32:
        -:   33:      GIF (*comp always reports as 4-channel)
        -:   34:      HDR (radiance rgbE format)
        -:   35:      PIC (Softimage PIC)
        -:   36:      PNM (PPM and PGM binary only)
        -:   37:
        -:   38:      Animated GIF still needs a proper API, but here's one way to do it:
        -:   39:          http://gist.github.com/urraka/685d9a6340b26b830d49
        -:   40:
        -:   41:      - decode from memory or through FILE (define STBI_NO_STDIO to remove code)
        -:   42:      - decode from arbitrary I/O callbacks
        -:   43:      - SIMD acceleration on x86/x64 (SSE2) and ARM (NEON)
        -:   44:
        -:   45:   Full documentation under "DOCUMENTATION" below.
        -:   46:
        -:   47:
        -:   48:LICENSE
        -:   49:
        -:   50:  See end of file for license information.
        -:   51:
        -:   52:RECENT REVISION HISTORY:
        -:   53:
        -:   54:      2.30  (2024-05-31) avoid erroneous gcc warning
        -:   55:      2.29  (2023-05-xx) optimizations
        -:   56:      2.28  (2023-01-29) many error fixes, security errors, just tons of stuff
        -:   57:      2.27  (2021-07-11) document stbi_info better, 16-bit PNM support, bug fixes
        -:   58:      2.26  (2020-07-13) many minor fixes
        -:   59:      2.25  (2020-02-02) fix warnings
        -:   60:      2.24  (2020-02-02) fix warnings; thread-local failure_reason and flip_vertically
        -:   61:      2.23  (2019-08-11) fix clang static analysis warning
        -:   62:      2.22  (2019-03-04) gif fixes, fix warnings
        -:   63:      2.21  (2019-02-25) fix typo in comment
        -:   64:      2.20  (2019-02-07) support utf8 filenames in Windows; fix warnings and platform ifdefs
        -:   65:      2.19  (2018-02-11) fix warning
        -:   66:      2.18  (2018-01-30) fix warnings
        -:   67:      2.17  (2018-01-29) bugfix, 1-bit BMP, 16-bitness query, fix warnings
        -:   68:      2.16  (2017-07-23) all functions have 16-bit variants; optimizations; bugfixes
        -:   69:      2.15  (2017-03-18) fix png-1,2,4; all Imagenet JPGs; no runtime SSE detection on GCC
        -:   70:      2.14  (2017-03-03) remove deprecated STBI_JPEG_OLD; fixes for Imagenet JPGs
        -:   71:      2.13  (2016-12-04) experimental 16-bit API, only for PNG so far; fixes
        -:   72:      2.12  (2016-04-02) fix typo in 2.11 PSD fix that caused crashes
        -:   73:      2.11  (2016-04-02) 16-bit PNGS; enable SSE2 in non-gcc x64
        -:   74:                         RGB-format JPEG; remove white matting in PSD;
        -:   75:                         allocate large structures on the stack;
        -:   76:                         correct channel count for PNG & BMP
        -:   77:      2.10  (2016-01-22) avoid warning introduced in 2.09
        -:   78:      2.09  (2016-01-16) 16-bit TGA; comments in PNM files; STBI_REALLOC_SIZED
        -:   79:
        -:   80:   See end of file for full revision history.
        -:   81:
        -:   82:
        -:   83: ============================    Contributors    =========================
        -:   84:
        -:   85: Image formats                          Extensions, features
        -:   86:    Sean Barrett (jpeg, png, bmp)          Jetro Lauha (stbi_info)
        -:   87:    Nicolas Schulz (hdr, psd)              Martin "SpartanJ" Golini (stbi_info)
        -:   88:    Jonathan Dummer (tga)                  James "moose2000" Brown (iPhone PNG)
        -:   89:    Jean-Marc Lienher (gif)                Ben "Disch" Wenger (io callbacks)
        -:   90:    Tom Seddon (pic)                       Omar Cornut (1/2/4-bit PNG)
        -:   91:    Thatcher Ulrich (psd)                  Nicolas Guillemot (vertical flip)
        -:   92:    Ken Miller (pgm, ppm)                  Richard Mitton (16-bit PSD)
        -:   93:    github:urraka (animated gif)           Junggon Kim (PNM comments)
        -:   94:    Christopher Forseth (animated gif)     Daniel Gibson (16-bit TGA)
        -:   95:                                           socks-the-fox (16-bit PNG)
        -:   96:                                           Jeremy Sawicki (handle all ImageNet JPGs)
        -:   97: Optimizations & bugfixes                  Mikhail Morozov (1-bit BMP)
        -:   98:    Fabian "ryg" Giesen                    Anael Seghezzi (is-16-bit query)
        -:   99:    Arseny Kapoulkine                      Simon Breuss (16-bit PNM)
        -:  100:    John-Mark Allen
        -:  101:    Carmelo J Fdez-Aguera
        -:  102:
        -:  103: Bug & warning fixes
        -:  104:    Marc LeBlanc            David Woo          Guillaume George     Martins Mozeiko
        -:  105:    Christpher Lloyd        Jerry Jansson      Joseph Thomson       Blazej Dariusz Roszkowski
        -:  106:    Phil Jordan                                Dave Moore           Roy Eltham
        -:  107:    Hayaki Saito            Nathan Reed        Won Chun
        -:  108:    Luke Graham             Johan Duparc       Nick Verigakis       the Horde3D community
        -:  109:    Thomas Ruf              Ronny Chevalier                         github:rlyeh
        -:  110:    Janez Zemva             John Bartholomew   Michal Cichon        github:romigrou
        -:  111:    Jonathan Blow           Ken Hamada         Tero Hanninen        github:svdijk
        -:  112:    Eugene Golushkov        Laurent Gomila     Cort Stratton        github:snagar
        -:  113:    Aruelien Pocheville     Sergio Gonzalez    Thibault Reuille     github:Zelex
        -:  114:    Cass Everitt            Ryamond Barbiero                        github:grim210
        -:  115:    Paul Du Bois            Engin Manap        Aldo Culquicondor    github:sammyhw
        -:  116:    Philipp Wiesemann       Dale Weiler        Oriol Ferrer Mesia   github:phprus
        -:  117:    Josh Tobin              Neil Bickford      Matthew Gregan       github:poppolopoppo
        -:  118:    Julian Raschke          Gregory Mullen     Christian Floisand   github:darealshinji
        -:  119:    Baldur Karlsson         Kevin Schmidt      JR Smith             github:Michaelangel007
        -:  120:                            Brad Weinberger    Matvey Cherevko      github:mosra
        -:  121:    Luca Sas                Alexander Veselov  Zack Middleton       [reserved]
        -:  122:    Ryan C. Gordon          [reserved]                              [reserved]
        -:  123:                     DO NOT ADD YOUR NAME HERE
        -:  124:
        -:  125:                     Jacko Dirks
        -:  126:
        -:  127:  To add your name to the credits, pick a random blank space in the middle and fill it.
        -:  128:  80% of merge conflicts on stb PRs are due to people adding their name at the end
        -:  129:  of the credits.
        -:  130:*/
        -:  131:
        -:  132:#ifndef STBI_INCLUDE_STB_IMAGE_H
        -:  133:#define STBI_INCLUDE_STB_IMAGE_H
        -:  134:
        -:  135:// DOCUMENTATION
        -:  136://
        -:  137:// Limitations:
        -:  138://    - no 12-bit-per-channel JPEG
        -:  139://    - no JPEGs with arithmetic coding
        -:  140://    - GIF always returns *comp=4
        -:  141://
        -:  142:// Basic usage (see HDR discussion below for HDR usage):
        -:  143://    int x,y,n;
        -:  144://    unsigned char *data = stbi_load(filename, &x, &y, &n, 0);
        -:  145://    // ... process data if not NULL ...
        -:  146://    // ... x = width, y = height, n = # 8-bit components per pixel ...
        -:  147://    // ... replace '0' with '1'..'4' to force that many components per pixel
        -:  148://    // ... but 'n' will always be the number that it would have been if you said 0
        -:  149://    stbi_image_free(data);
        -:  150://
        -:  151:// Standard parameters:
        -:  152://    int *x                 -- outputs image width in pixels
        -:  153://    int *y                 -- outputs image height in pixels
        -:  154://    int *channels_in_file  -- outputs # of image components in image file
        -:  155://    int desired_channels   -- if non-zero, # of image components requested in result
        -:  156://
        -:  157:// The return value from an image loader is an 'unsigned char *' which points
        -:  158:// to the pixel data, or NULL on an allocation failure or if the image is
        -:  159:// corrupt or invalid. The pixel data consists of *y scanlines of *x pixels,
        -:  160:// with each pixel consisting of N interleaved 8-bit components; the first
        -:  161:// pixel pointed to is top-left-most in the image. There is no padding between
        -:  162:// image scanlines or between pixels, regardless of format. The number of
        -:  163:// components N is 'desired_channels' if desired_channels is non-zero, or
        -:  164:// *channels_in_file otherwise. If desired_channels is non-zero,
        -:  165:// *channels_in_file has the number of components that _would_ have been
        -:  166:// output otherwise. E.g. if you set desired_channels to 4, you will always
        -:  167:// get RGBA output, but you can check *channels_in_file to see if it's trivially
        -:  168:// opaque because e.g. there were only 3 channels in the source image.
        -:  169://
        -:  170:// An output image with N components has the following components interleaved
        -:  171:// in this order in each pixel:
        -:  172://
        -:  173://     N=#comp     components
        -:  174://       1           grey
        -:  175://       2           grey, alpha
        -:  176://       3           red, green, blue
        -:  177://       4           red, green, blue, alpha
        -:  178://
        -:  179:// If image loading fails for any reason, the return value will be NULL,
        -:  180:// and *x, *y, *channels_in_file will be unchanged. The function
        -:  181:// stbi_failure_reason() can be queried for an extremely brief, end-user
        -:  182:// unfriendly explanation of why the load failed. Define STBI_NO_FAILURE_STRINGS
        -:  183:// to avoid compiling these strings at all, and STBI_FAILURE_USERMSG to get slightly
        -:  184:// more user-friendly ones.
        -:  185://
        -:  186:// Paletted PNG, BMP, GIF, and PIC images are automatically depalettized.
        -:  187://
        -:  188:// To query the width, height and component count of an image without having to
        -:  189:// decode the full file, you can use the stbi_info family of functions:
        -:  190://
        -:  191://   int x,y,n,ok;
        -:  192://   ok = stbi_info(filename, &x, &y, &n);
        -:  193://   // returns ok=1 and sets x, y, n if image is a supported format,
        -:  194://   // 0 otherwise.
        -:  195://
        -:  196:// Note that stb_image pervasively uses ints in its public API for sizes,
        -:  197:// including sizes of memory buffers. This is now part of the API and thus
        -:  198:// hard to change without causing breakage. As a result, the various image
        -:  199:// loaders all have certain limits on image size; these differ somewhat
        -:  200:// by format but generally boil down to either just under 2GB or just under
        -:  201:// 1GB. When the decoded image would be larger than this, stb_image decoding
        -:  202:// will fail.
        -:  203://
        -:  204:// Additionally, stb_image will reject image files that have any of their
        -:  205:// dimensions set to a larger value than the configurable STBI_MAX_DIMENSIONS,
        -:  206:// which defaults to 2**24 = 16777216 pixels. Due to the above memory limit,
        -:  207:// the only way to have an image with such dimensions load correctly
        -:  208:// is for it to have a rather extreme aspect ratio. Either way, the
        -:  209:// assumption here is that such larger images are likely to be malformed
        -:  210:// or malicious. If you do need to load an image with individual dimensions
        -:  211:// larger than that, and it still fits in the overall size limit, you can
        -:  212:// #define STBI_MAX_DIMENSIONS on your own to be something larger.
        -:  213://
        -:  214:// ===========================================================================
        -:  215://
        -:  216:// UNICODE:
        -:  217://
        -:  218://   If compiling for Windows and you wish to use Unicode filenames, compile
        -:  219://   with
        -:  220://       #define STBI_WINDOWS_UTF8
        -:  221://   and pass utf8-encoded filenames. Call stbi_convert_wchar_to_utf8 to convert
        -:  222://   Windows wchar_t filenames to utf8.
        -:  223://
        -:  224:// ===========================================================================
        -:  225://
        -:  226:// Philosophy
        -:  227://
        -:  228:// stb libraries are designed with the following priorities:
        -:  229://
        -:  230://    1. easy to use
        -:  231://    2. easy to maintain
        -:  232://    3. good performance
        -:  233://
        -:  234:// Sometimes I let "good performance" creep up in priority over "easy to maintain",
        -:  235:// and for best performance I may provide less-easy-to-use APIs that give higher
        -:  236:// performance, in addition to the easy-to-use ones. Nevertheless, it's important
        -:  237:// to keep in mind that from the standpoint of you, a client of this library,
        -:  238:// all you care about is #1 and #3, and stb libraries DO NOT emphasize #3 above all.
        -:  239://
        -:  240:// Some secondary priorities arise directly from the first two, some of which
        -:  241:// provide more explicit reasons why performance can't be emphasized.
        -:  242://
        -:  243://    - Portable ("ease of use")
        -:  244://    - Small source code footprint ("easy to maintain")
        -:  245://    - No dependencies ("ease of use")
        -:  246://
        -:  247:// ===========================================================================
        -:  248://
        -:  249:// I/O callbacks
        -:  250://
        -:  251:// I/O callbacks allow you to read from arbitrary sources, like packaged
        -:  252:// files or some other source. Data read from callbacks are processed
        -:  253:// through a small internal buffer (currently 128 bytes) to try to reduce
        -:  254:// overhead.
        -:  255://
        -:  256:// The three functions you must define are "read" (reads some bytes of data),
        -:  257:// "skip" (skips some bytes of data), "eof" (reports if the stream is at the end).
        -:  258://
        -:  259:// ===========================================================================
        -:  260://
        -:  261:// SIMD support
        -:  262://
        -:  263:// The JPEG decoder will try to automatically use SIMD kernels on x86 when
        -:  264:// supported by the compiler. For ARM Neon support, you must explicitly
        -:  265:// request it.
        -:  266://
        -:  267:// (The old do-it-yourself SIMD API is no longer supported in the current
        -:  268:// code.)
        -:  269://
        -:  270:// On x86, SSE2 will automatically be used when available based on a run-time
        -:  271:// test; if not, the generic C versions are used as a fall-back. On ARM targets,
        -:  272:// the typical path is to have separate builds for NEON and non-NEON devices
        -:  273:// (at least this is true for iOS and Android). Therefore, the NEON support is
        -:  274:// toggled by a build flag: define STBI_NEON to get NEON loops.
        -:  275://
        -:  276:// If for some reason you do not want to use any of SIMD code, or if
        -:  277:// you have issues compiling it, you can disable it entirely by
        -:  278:// defining STBI_NO_SIMD.
        -:  279://
        -:  280:// ===========================================================================
        -:  281://
        -:  282:// HDR image support   (disable by defining STBI_NO_HDR)
        -:  283://
        -:  284:// stb_image supports loading HDR images in general, and currently the Radiance
        -:  285:// .HDR file format specifically. You can still load any file through the existing
        -:  286:// interface; if you attempt to load an HDR file, it will be automatically remapped
        -:  287:// to LDR, assuming gamma 2.2 and an arbitrary scale factor defaulting to 1;
        -:  288:// both of these constants can be reconfigured through this interface:
        -:  289://
        -:  290://     stbi_hdr_to_ldr_gamma(2.2f);
        -:  291://     stbi_hdr_to_ldr_scale(1.0f);
        -:  292://
        -:  293:// (note, do not use _inverse_ constants; stbi_image will invert them
        -:  294:// appropriately).
        -:  295://
        -:  296:// Additionally, there is a new, parallel interface for loading files as
        -:  297:// (linear) floats to preserve the full dynamic range:
        -:  298://
        -:  299://    float *data = stbi_loadf(filename, &x, &y, &n, 0);
        -:  300://
        -:  301:// If you load LDR images through this interface, those images will
        -:  302:// be promoted to floating point values, run through the inverse of
        -:  303:// constants corresponding to the above:
        -:  304://
        -:  305://     stbi_ldr_to_hdr_scale(1.0f);
        -:  306://     stbi_ldr_to_hdr_gamma(2.2f);
        -:  307://
        -:  308:// Finally, given a filename (or an open file or memory block--see header
        -:  309:// file for details) containing image data, you can query for the "most
        -:  310:// appropriate" interface to use (that is, whether the image is HDR or
        -:  311:// not), using:
        -:  312://
        -:  313://     stbi_is_hdr(char *filename);
        -:  314://
        -:  315:// ===========================================================================
        -:  316://
        -:  317:// iPhone PNG support:
        -:  318://
        -:  319:// We optionally support converting iPhone-formatted PNGs (which store
        -:  320:// premultiplied BGRA) back to RGB, even though they're internally encoded
        -:  321:// differently. To enable this conversion, call
        -:  322:// stbi_convert_iphone_png_to_rgb(1).
        -:  323://
        -:  324:// Call stbi_set_unpremultiply_on_load(1) as well to force a divide per
        -:  325:// pixel to remove any premultiplied alpha *only* if the image file explicitly
        -:  326:// says there's premultiplied data (currently only happens in iPhone images,
        -:  327:// and only if iPhone convert-to-rgb processing is on).
        -:  328://
        -:  329:// ===========================================================================
        -:  330://
        -:  331:// ADDITIONAL CONFIGURATION
        -:  332://
        -:  333://  - You can suppress implementation of any of the decoders to reduce
        -:  334://    your code footprint by #defining one or more of the following
        -:  335://    symbols before creating the implementation.
        -:  336://
        -:  337://        STBI_NO_JPEG
        -:  338://        STBI_NO_PNG
        -:  339://        STBI_NO_BMP
        -:  340://        STBI_NO_PSD
        -:  341://        STBI_NO_TGA
        -:  342://        STBI_NO_GIF
        -:  343://        STBI_NO_HDR
        -:  344://        STBI_NO_PIC
        -:  345://        STBI_NO_PNM   (.ppm and .pgm)
        -:  346://
        -:  347://  - You can request *only* certain decoders and suppress all other ones
        -:  348://    (this will be more forward-compatible, as addition of new decoders
        -:  349://    doesn't require you to disable them explicitly):
        -:  350://
        -:  351://        STBI_ONLY_JPEG
        -:  352://        STBI_ONLY_PNG
        -:  353://        STBI_ONLY_BMP
        -:  354://        STBI_ONLY_PSD
        -:  355://        STBI_ONLY_TGA
        -:  356://        STBI_ONLY_GIF
        -:  357://        STBI_ONLY_HDR
        -:  358://        STBI_ONLY_PIC
        -:  359://        STBI_ONLY_PNM   (.ppm and .pgm)
        -:  360://
        -:  361://   - If you use STBI_NO_PNG (or _ONLY_ without PNG), and you still
        -:  362://     want the zlib decoder to be available, #define STBI_SUPPORT_ZLIB
        -:  363://
        -:  364://  - If you define STBI_MAX_DIMENSIONS, stb_image will reject images greater
        -:  365://    than that size (in either width or height) without further processing.
        -:  366://    This is to let programs in the wild set an upper bound to prevent
        -:  367://    denial-of-service attacks on untrusted data, as one could generate a
        -:  368://    valid image of gigantic dimensions and force stb_image to allocate a
        -:  369://    huge block of memory and spend disproportionate time decoding it. By
        -:  370://    default this is set to (1 << 24), which is 16777216, but that's still
        -:  371://    very big.
        -:  372:
        -:  373:#ifndef STBI_NO_STDIO
        -:  374:#include <stdio.h>
        -:  375:#endif // STBI_NO_STDIO
        -:  376:
        -:  377:#define STBI_VERSION 1
        -:  378:
        -:  379:enum
        -:  380:{
        -:  381:    STBI_default = 0, // only used for desired_channels
        -:  382:
        -:  383:    STBI_grey       = 1,
        -:  384:    STBI_grey_alpha = 2,
        -:  385:    STBI_rgb        = 3,
        -:  386:    STBI_rgb_alpha  = 4
        -:  387:};
        -:  388:
        -:  389:#include <stdlib.h>
        -:  390:typedef unsigned char stbi_uc;
        -:  391:typedef unsigned short stbi_us;
        -:  392:
        -:  393:#ifdef __cplusplus
        -:  394:extern "C" {
        -:  395:#endif
        -:  396:
        -:  397:#ifndef STBIDEF
        -:  398:#ifdef STB_IMAGE_STATIC
        -:  399:#define STBIDEF static
        -:  400:#else
        -:  401:#define STBIDEF extern
        -:  402:#endif
        -:  403:#endif
        -:  404:
        -:  405://////////////////////////////////////////////////////////////////////////////
        -:  406://
        -:  407:// PRIMARY API - works on images of any type
        -:  408://
        -:  409:
        -:  410://
        -:  411:// load image by filename, open file, or memory buffer
        -:  412://
        -:  413:
        -:  414:typedef struct
        -:  415:{
        -:  416:    int      (*read)  (void *user,char *data,int size);   // fill 'data' with 'size' bytes.  return number of bytes actually read
        -:  417:    void     (*skip)  (void *user,int n);                 // skip the next 'n' bytes, or 'unget' the last -n bytes if negative
        -:  418:    int      (*eof)   (void *user);                       // returns nonzero if we are at end of file/data
        -:  419:} stbi_io_callbacks;
        -:  420:
        -:  421:////////////////////////////////////
        -:  422://
        -:  423:// 8-bits-per-channel interface
        -:  424://
        -:  425:
        -:  426:STBIDEF stbi_uc *stbi_load_from_memory   (stbi_uc           const *buffer, int len   , int *x, int *y, int *channels_in_file, int desired_channels);
        -:  427:STBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk  , void *user, int *x, int *y, int *channels_in_file, int desired_channels);
        -:  428:
        -:  429:#ifndef STBI_NO_STDIO
        -:  430:STBIDEF stbi_uc *stbi_load            (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);
        -:  431:STBIDEF stbi_uc *stbi_load_from_file  (FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);
        -:  432:// for stbi_load_from_file, file pointer is left pointing immediately after image
        -:  433:#endif
        -:  434:
        -:  435:#ifndef STBI_NO_GIF
        -:  436:STBIDEF stbi_uc *stbi_load_gif_from_memory(stbi_uc const *buffer, int len, int **delays, int *x, int *y, int *z, int *comp, int req_comp);
        -:  437:#endif
        -:  438:
        -:  439:#ifdef STBI_WINDOWS_UTF8
        -:  440:STBIDEF int stbi_convert_wchar_to_utf8(char *buffer, size_t bufferlen, const wchar_t* input);
        -:  441:#endif
        -:  442:
        -:  443:////////////////////////////////////
        -:  444://
        -:  445:// 16-bits-per-channel interface
        -:  446://
        -:  447:
        -:  448:STBIDEF stbi_us *stbi_load_16_from_memory   (stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels);
        -:  449:STBIDEF stbi_us *stbi_load_16_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels);
        -:  450:
        -:  451:#ifndef STBI_NO_STDIO
        -:  452:STBIDEF stbi_us *stbi_load_16          (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);
        -:  453:STBIDEF stbi_us *stbi_load_from_file_16(FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);
        -:  454:#endif
        -:  455:
        -:  456:////////////////////////////////////
        -:  457://
        -:  458:// float-per-channel interface
        -:  459://
        -:  460:#ifndef STBI_NO_LINEAR
        -:  461:STBIDEF float *stbi_loadf_from_memory     (stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels);
        -:  462:STBIDEF float *stbi_loadf_from_callbacks  (stbi_io_callbacks const *clbk, void *user, int *x, int *y,  int *channels_in_file, int desired_channels);
        -:  463:
        -:  464:#ifndef STBI_NO_STDIO
        -:  465:STBIDEF float *stbi_loadf            (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);
        -:  466:STBIDEF float *stbi_loadf_from_file  (FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);
        -:  467:#endif
        -:  468:#endif
        -:  469:
        -:  470:#ifndef STBI_NO_HDR
        -:  471:STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma);
        -:  472:STBIDEF void   stbi_hdr_to_ldr_scale(float scale);
        -:  473:#endif // STBI_NO_HDR
        -:  474:
        -:  475:#ifndef STBI_NO_LINEAR
        -:  476:STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma);
        -:  477:STBIDEF void   stbi_ldr_to_hdr_scale(float scale);
        -:  478:#endif // STBI_NO_LINEAR
        -:  479:
        -:  480:// stbi_is_hdr is always defined, but always returns false if STBI_NO_HDR
        -:  481:STBIDEF int    stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user);
        -:  482:STBIDEF int    stbi_is_hdr_from_memory(stbi_uc const *buffer, int len);
        -:  483:#ifndef STBI_NO_STDIO
        -:  484:STBIDEF int      stbi_is_hdr          (char const *filename);
        -:  485:STBIDEF int      stbi_is_hdr_from_file(FILE *f);
        -:  486:#endif // STBI_NO_STDIO
        -:  487:
        -:  488:
        -:  489:// get a VERY brief reason for failure
        -:  490:// on most compilers (and ALL modern mainstream compilers) this is threadsafe
        -:  491:STBIDEF const char *stbi_failure_reason  (void);
        -:  492:
        -:  493:// free the loaded image -- this is just free()
        -:  494:STBIDEF void     stbi_image_free      (void *retval_from_stbi_load);
        -:  495:
        -:  496:// get image dimensions & components without fully decoding
        -:  497:STBIDEF int      stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp);
        -:  498:STBIDEF int      stbi_info_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp);
        -:  499:STBIDEF int      stbi_is_16_bit_from_memory(stbi_uc const *buffer, int len);
        -:  500:STBIDEF int      stbi_is_16_bit_from_callbacks(stbi_io_callbacks const *clbk, void *user);
        -:  501:
        -:  502:#ifndef STBI_NO_STDIO
        -:  503:STBIDEF int      stbi_info               (char const *filename,     int *x, int *y, int *comp);
        -:  504:STBIDEF int      stbi_info_from_file     (FILE *f,                  int *x, int *y, int *comp);
        -:  505:STBIDEF int      stbi_is_16_bit          (char const *filename);
        -:  506:STBIDEF int      stbi_is_16_bit_from_file(FILE *f);
        -:  507:#endif
        -:  508:
        -:  509:
        -:  510:
        -:  511:// for image formats that explicitly notate that they have premultiplied alpha,
        -:  512:// we just return the colors as stored in the file. set this flag to force
        -:  513:// unpremultiplication. results are undefined if the unpremultiply overflow.
        -:  514:STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply);
        -:  515:
        -:  516:// indicate whether we should process iphone images back to canonical format,
        -:  517:// or just pass them through "as-is"
        -:  518:STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert);
        -:  519:
        -:  520:// flip the image vertically, so the first pixel in the output array is the bottom left
        -:  521:STBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip);
        -:  522:
        -:  523:// as above, but only applies to images loaded on the thread that calls the function
        -:  524:// this function is only available if your compiler supports thread-local variables;
        -:  525:// calling it will fail to link if your compiler doesn't
        -:  526:STBIDEF void stbi_set_unpremultiply_on_load_thread(int flag_true_if_should_unpremultiply);
        -:  527:STBIDEF void stbi_convert_iphone_png_to_rgb_thread(int flag_true_if_should_convert);
        -:  528:STBIDEF void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip);
        -:  529:
        -:  530:// ZLIB client - used by PNG, available for other purposes
        -:  531:
        -:  532:STBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen);
        -:  533:STBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header);
        -:  534:STBIDEF char *stbi_zlib_decode_malloc(const char *buffer, int len, int *outlen);
        -:  535:STBIDEF int   stbi_zlib_decode_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);
        -:  536:
        -:  537:STBIDEF char *stbi_zlib_decode_noheader_malloc(const char *buffer, int len, int *outlen);
        -:  538:STBIDEF int   stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);
        -:  539:
        -:  540:
        -:  541:#ifdef __cplusplus
        -:  542:}
        -:  543:#endif
        -:  544:
        -:  545://
        -:  546://
        -:  547:////   end header file   /////////////////////////////////////////////////////
        -:  548:#endif // STBI_INCLUDE_STB_IMAGE_H
        -:  549:
        -:  550:#ifdef STB_IMAGE_IMPLEMENTATION
        -:  551:
        -:  552:#if defined(STBI_ONLY_JPEG) || defined(STBI_ONLY_PNG) || defined(STBI_ONLY_BMP) \
        -:  553:  || defined(STBI_ONLY_TGA) || defined(STBI_ONLY_GIF) || defined(STBI_ONLY_PSD) \
        -:  554:  || defined(STBI_ONLY_HDR) || defined(STBI_ONLY_PIC) || defined(STBI_ONLY_PNM) \
        -:  555:  || defined(STBI_ONLY_ZLIB)
        -:  556:   #ifndef STBI_ONLY_JPEG
        -:  557:   #define STBI_NO_JPEG
        -:  558:   #endif
        -:  559:   #ifndef STBI_ONLY_PNG
        -:  560:   #define STBI_NO_PNG
        -:  561:   #endif
        -:  562:   #ifndef STBI_ONLY_BMP
        -:  563:   #define STBI_NO_BMP
        -:  564:   #endif
        -:  565:   #ifndef STBI_ONLY_PSD
        -:  566:   #define STBI_NO_PSD
        -:  567:   #endif
        -:  568:   #ifndef STBI_ONLY_TGA
        -:  569:   #define STBI_NO_TGA
        -:  570:   #endif
        -:  571:   #ifndef STBI_ONLY_GIF
        -:  572:   #define STBI_NO_GIF
        -:  573:   #endif
        -:  574:   #ifndef STBI_ONLY_HDR
        -:  575:   #define STBI_NO_HDR
        -:  576:   #endif
        -:  577:   #ifndef STBI_ONLY_PIC
        -:  578:   #define STBI_NO_PIC
        -:  579:   #endif
        -:  580:   #ifndef STBI_ONLY_PNM
        -:  581:   #define STBI_NO_PNM
        -:  582:   #endif
        -:  583:#endif
        -:  584:
        -:  585:#if defined(STBI_NO_PNG) && !defined(STBI_SUPPORT_ZLIB) && !defined(STBI_NO_ZLIB)
        -:  586:#define STBI_NO_ZLIB
        -:  587:#endif
        -:  588:
        -:  589:
        -:  590:#include <stdarg.h>
        -:  591:#include <stddef.h> // ptrdiff_t on osx
        -:  592:#include <stdlib.h>
        -:  593:#include <string.h>
        -:  594:#include <limits.h>
        -:  595:
        -:  596:#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR)
        -:  597:#include <math.h>  // ldexp, pow
        -:  598:#endif
        -:  599:
        -:  600:#ifndef STBI_NO_STDIO
        -:  601:#include <stdio.h>
        -:  602:#endif
        -:  603:
        -:  604:#ifndef STBI_ASSERT
        -:  605:#include <assert.h>
        -:  606:#define STBI_ASSERT(x) assert(x)
        -:  607:#endif
        -:  608:
        -:  609:#ifdef __cplusplus
        -:  610:#define STBI_EXTERN extern "C"
        -:  611:#else
        -:  612:#define STBI_EXTERN extern
        -:  613:#endif
        -:  614:
        -:  615:
        -:  616:#ifndef _MSC_VER
        -:  617:   #ifdef __cplusplus
        -:  618:   #define stbi_inline inline
        -:  619:   #else
        -:  620:   #define stbi_inline
        -:  621:   #endif
        -:  622:#else
        -:  623:   #define stbi_inline __forceinline
        -:  624:#endif
        -:  625:
        -:  626:#ifndef STBI_NO_THREAD_LOCALS
        -:  627:   #if defined(__cplusplus) &&  __cplusplus >= 201103L
        -:  628:      #define STBI_THREAD_LOCAL       thread_local
        -:  629:   #elif defined(__GNUC__) && __GNUC__ < 5
        -:  630:      #define STBI_THREAD_LOCAL       __thread
        -:  631:   #elif defined(_MSC_VER)
        -:  632:      #define STBI_THREAD_LOCAL       __declspec(thread)
        -:  633:   #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 201112L && !defined(__STDC_NO_THREADS__)
        -:  634:      #define STBI_THREAD_LOCAL       _Thread_local
        -:  635:   #endif
        -:  636:
        -:  637:   #ifndef STBI_THREAD_LOCAL
        -:  638:      #if defined(__GNUC__)
        -:  639:        #define STBI_THREAD_LOCAL       __thread
        -:  640:      #endif
        -:  641:   #endif
        -:  642:#endif
        -:  643:
        -:  644:#if defined(_MSC_VER) || defined(__SYMBIAN32__)
        -:  645:typedef unsigned short stbi__uint16;
        -:  646:typedef   signed short stbi__int16;
        -:  647:typedef unsigned int   stbi__uint32;
        -:  648:typedef   signed int   stbi__int32;
        -:  649:#else
        -:  650:#include <stdint.h>
        -:  651:typedef uint16_t stbi__uint16;
        -:  652:typedef int16_t  stbi__int16;
        -:  653:typedef uint32_t stbi__uint32;
        -:  654:typedef int32_t  stbi__int32;
        -:  655:#endif
        -:  656:
        -:  657:// should produce compiler error if size is wrong
        -:  658:typedef unsigned char validate_uint32[sizeof(stbi__uint32)==4 ? 1 : -1];
        -:  659:
        -:  660:#ifdef _MSC_VER
        -:  661:#define STBI_NOTUSED(v)  (void)(v)
        -:  662:#else
        -:  663:#define STBI_NOTUSED(v)  (void)sizeof(v)
        -:  664:#endif
        -:  665:
        -:  666:#ifdef _MSC_VER
        -:  667:#define STBI_HAS_LROTL
        -:  668:#endif
        -:  669:
        -:  670:#ifdef STBI_HAS_LROTL
        -:  671:   #define stbi_lrot(x,y)  _lrotl(x,y)
        -:  672:#else
        -:  673:   #define stbi_lrot(x,y)  (((x) << (y)) | ((x) >> (-(y) & 31)))
        -:  674:#endif
        -:  675:
        -:  676:#if defined(STBI_MALLOC) && defined(STBI_FREE) && (defined(STBI_REALLOC) || defined(STBI_REALLOC_SIZED))
        -:  677:// ok
        -:  678:#elif !defined(STBI_MALLOC) && !defined(STBI_FREE) && !defined(STBI_REALLOC) && !defined(STBI_REALLOC_SIZED)
        -:  679:// ok
        -:  680:#else
        -:  681:#error "Must define all or none of STBI_MALLOC, STBI_FREE, and STBI_REALLOC (or STBI_REALLOC_SIZED)."
        -:  682:#endif
        -:  683:
        -:  684:#ifndef STBI_MALLOC
        -:  685:#define STBI_MALLOC(sz)           malloc(sz)
        -:  686:#define STBI_REALLOC(p,newsz)     realloc(p,newsz)
        -:  687:#define STBI_FREE(p)              free(p)
        -:  688:#endif
        -:  689:
        -:  690:#ifndef STBI_REALLOC_SIZED
        -:  691:#define STBI_REALLOC_SIZED(p,oldsz,newsz) STBI_REALLOC(p,newsz)
        -:  692:#endif
        -:  693:
        -:  694:// x86/x64 detection
        -:  695:#if defined(__x86_64__) || defined(_M_X64)
        -:  696:#define STBI__X64_TARGET
        -:  697:#elif defined(__i386) || defined(_M_IX86)
        -:  698:#define STBI__X86_TARGET
        -:  699:#endif
        -:  700:
        -:  701:#if defined(__GNUC__) && defined(STBI__X86_TARGET) && !defined(__SSE2__) && !defined(STBI_NO_SIMD)
        -:  702:// gcc doesn't support sse2 intrinsics unless you compile with -msse2,
        -:  703:// which in turn means it gets to use SSE2 everywhere. This is unfortunate,
        -:  704:// but previous attempts to provide the SSE2 functions with runtime
        -:  705:// detection caused numerous issues. The way architecture extensions are
        -:  706:// exposed in GCC/Clang is, sadly, not really suited for one-file libs.
        -:  707:// New behavior: if compiled with -msse2, we use SSE2 without any
        -:  708:// detection; if not, we don't use it at all.
        -:  709:#define STBI_NO_SIMD
        -:  710:#endif
        -:  711:
        -:  712:#if defined(__MINGW32__) && defined(STBI__X86_TARGET) && !defined(STBI_MINGW_ENABLE_SSE2) && !defined(STBI_NO_SIMD)
        -:  713:// Note that __MINGW32__ doesn't actually mean 32-bit, so we have to avoid STBI__X64_TARGET
        -:  714://
        -:  715:// 32-bit MinGW wants ESP to be 16-byte aligned, but this is not in the
        -:  716:// Windows ABI and VC++ as well as Windows DLLs don't maintain that invariant.
        -:  717:// As a result, enabling SSE2 on 32-bit MinGW is dangerous when not
        -:  718:// simultaneously enabling "-mstackrealign".
        -:  719://
        -:  720:// See https://github.com/nothings/stb/issues/81 for more information.
        -:  721://
        -:  722:// So default to no SSE2 on 32-bit MinGW. If you've read this far and added
        -:  723:// -mstackrealign to your build settings, feel free to #define STBI_MINGW_ENABLE_SSE2.
        -:  724:#define STBI_NO_SIMD
        -:  725:#endif
        -:  726:
        -:  727:#if !defined(STBI_NO_SIMD) && (defined(STBI__X86_TARGET) || defined(STBI__X64_TARGET))
        -:  728:#define STBI_SSE2
        -:  729:#include <emmintrin.h>
        -:  730:
        -:  731:#ifdef _MSC_VER
        -:  732:
        -:  733:#if _MSC_VER >= 1400  // not VC6
        -:  734:#include <intrin.h> // __cpuid
        -:  735:static int stbi__cpuid3(void)
        -:  736:{
        -:  737:   int info[4];
        -:  738:   __cpuid(info,1);
        -:  739:   return info[3];
        -:  740:}
        -:  741:#else
        -:  742:static int stbi__cpuid3(void)
        -:  743:{
        -:  744:   int res;
        -:  745:   __asm {
        -:  746:      mov  eax,1
        -:  747:      cpuid
        -:  748:      mov  res,edx
        -:  749:   }
        -:  750:   return res;
        -:  751:}
        -:  752:#endif
        -:  753:
        -:  754:#define STBI_SIMD_ALIGN(type, name) __declspec(align(16)) type name
        -:  755:
        -:  756:#if !defined(STBI_NO_JPEG) && defined(STBI_SSE2)
        -:  757:static int stbi__sse2_available(void)
        -:  758:{
        -:  759:   int info3 = stbi__cpuid3();
        -:  760:   return ((info3 >> 26) & 1) != 0;
        -:  761:}
        -:  762:#endif
        -:  763:
        -:  764:#else // assume GCC-style if not VC++
        -:  765:#define STBI_SIMD_ALIGN(type, name) type name __attribute__((aligned(16)))
        -:  766:
        -:  767:#if !defined(STBI_NO_JPEG) && defined(STBI_SSE2)
function _ZL20stbi__sse2_availablev called 0 returned 0% blocks executed 0%
    #####:  768:static int stbi__sse2_available(void)
        -:  769:{
        -:  770:   // If we're even attempting to compile this on GCC/Clang, that means
        -:  771:   // -msse2 is on, which means the compiler is allowed to use SSE2
        -:  772:   // instructions at will, and so are we.
    #####:  773:   return 1;
    %%%%%:  773-block 2
        -:  774:}
        -:  775:#endif
        -:  776:
        -:  777:#endif
        -:  778:#endif
        -:  779:
        -:  780:// ARM NEON
        -:  781:#if defined(STBI_NO_SIMD) && defined(STBI_NEON)
        -:  782:#undef STBI_NEON
        -:  783:#endif
        -:  784:
        -:  785:#ifdef STBI_NEON
        -:  786:#include <arm_neon.h>
        -:  787:#ifdef _MSC_VER
        -:  788:#define STBI_SIMD_ALIGN(type, name) __declspec(align(16)) type name
        -:  789:#else
        -:  790:#define STBI_SIMD_ALIGN(type, name) type name __attribute__((aligned(16)))
        -:  791:#endif
        -:  792:#endif
        -:  793:
        -:  794:#ifndef STBI_SIMD_ALIGN
        -:  795:#define STBI_SIMD_ALIGN(type, name) type name
        -:  796:#endif
        -:  797:
        -:  798:#ifndef STBI_MAX_DIMENSIONS
        -:  799:#define STBI_MAX_DIMENSIONS (1 << 24)
        -:  800:#endif
        -:  801:
        -:  802:///////////////////////////////////////////////
        -:  803://
        -:  804://  stbi__context struct and start_xxx functions
        -:  805:
        -:  806:// stbi__context structure is our basic context used by all images, so it
        -:  807:// contains all the IO context, plus some basic image information
        -:  808:typedef struct
        -:  809:{
        -:  810:   stbi__uint32 img_x, img_y;
        -:  811:   int img_n, img_out_n;
        -:  812:
        -:  813:   stbi_io_callbacks io;
        -:  814:   void *io_user_data;
        -:  815:
        -:  816:   int read_from_callbacks;
        -:  817:   int buflen;
        -:  818:   stbi_uc buffer_start[128];
        -:  819:   int callback_already_read;
        -:  820:
        -:  821:   stbi_uc *img_buffer, *img_buffer_end;
        -:  822:   stbi_uc *img_buffer_original, *img_buffer_original_end;
        -:  823:} stbi__context;
        -:  824:
        -:  825:
        -:  826:static void stbi__refill_buffer(stbi__context *s);
        -:  827:
        -:  828:// initialize a memory-decode context
function _ZL15stbi__start_memP13stbi__contextPKhi called 0 returned 0% blocks executed 0%
    #####:  829:static void stbi__start_mem(stbi__context *s, stbi_uc const *buffer, int len)
        -:  830:{
    #####:  831:   s->io.read = NULL;
    #####:  832:   s->read_from_callbacks = 0;
    #####:  833:   s->callback_already_read = 0;
    #####:  834:   s->img_buffer = s->img_buffer_original = (stbi_uc *) buffer;
    #####:  835:   s->img_buffer_end = s->img_buffer_original_end = (stbi_uc *) buffer+len;
    #####:  836:}
        -:  837:
        -:  838:// initialize a callback-based context
function _ZL21stbi__start_callbacksP13stbi__contextP17stbi_io_callbacksPv called 1 returned 100% blocks executed 100%
        1:  839:static void stbi__start_callbacks(stbi__context *s, stbi_io_callbacks *c, void *user)
        -:  840:{
        1:  841:   s->io = *c;
        1:  842:   s->io_user_data = user;
        1:  843:   s->buflen = sizeof(s->buffer_start);
        1:  844:   s->read_from_callbacks = 1;
        1:  845:   s->callback_already_read = 0;
        1:  846:   s->img_buffer = s->img_buffer_original = s->buffer_start;
        1:  847:   stbi__refill_buffer(s);
        1:  847-block 2
call    0 returned 1
        1:  848:   s->img_buffer_original_end = s->img_buffer_end;
        1:  849:}
        -:  850:
        -:  851:#ifndef STBI_NO_STDIO
        -:  852:
function _ZL16stbi__stdio_readPvPci called 4 returned 100% blocks executed 100%
        4:  853:static int stbi__stdio_read(void *user, char *data, int size)
        -:  854:{
        4:  855:   return (int) fread(data,1,size,(FILE*) user);
        4:  855-block 2
call    0 returned 4
        -:  856:}
        -:  857:
function _ZL16stbi__stdio_skipPvi called 1 returned 100% blocks executed 100%
        1:  858:static void stbi__stdio_skip(void *user, int n)
        -:  859:{
        -:  860:   int ch;
        1:  861:   fseek((FILE*) user, n, SEEK_CUR);
        1:  861-block 2
call    0 returned 1
        1:  862:   ch = fgetc((FILE*) user);  /* have to read a byte to reset feof()'s flag */
call    0 returned 1
        1:  863:   if (ch != EOF) {
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  864:      ungetc(ch, (FILE *) user);  /* push byte back onto stream if valid. */
        1:  864-block 5
call    0 returned 1
        -:  865:   }
        1:  866:}
        -:  867:
function _ZL15stbi__stdio_eofPv called 0 returned 0% blocks executed 0%
    #####:  868:static int stbi__stdio_eof(void *user)
        -:  869:{
    #####:  870:   return feof((FILE*) user) || ferror((FILE *) user);
    %%%%%:  870-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:  870-block 4
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:  870-block 6
    %%%%%:  870-block 7
    %%%%%:  870-block 8
        -:  871:}
        -:  872:
        -:  873:static stbi_io_callbacks stbi__stdio_callbacks =
        -:  874:{
        -:  875:   stbi__stdio_read,
        -:  876:   stbi__stdio_skip,
        -:  877:   stbi__stdio_eof,
        -:  878:};
        -:  879:
function _ZL16stbi__start_fileP13stbi__contextP8_IO_FILE called 1 returned 100% blocks executed 100%
        1:  880:static void stbi__start_file(stbi__context *s, FILE *f)
        -:  881:{
        1:  882:   stbi__start_callbacks(s, &stbi__stdio_callbacks, (void *) f);
        1:  882-block 2
call    0 returned 1
        1:  883:}
        -:  884:
        -:  885://static void stop_file(stbi__context *s) { }
        -:  886:
        -:  887:#endif // !STBI_NO_STDIO
        -:  888:
function _ZL12stbi__rewindP13stbi__context called 1 returned 100% blocks executed 100%
        1:  889:static void stbi__rewind(stbi__context *s)
        -:  890:{
        -:  891:   // conceptually rewind SHOULD rewind to the beginning of the stream,
        -:  892:   // but we just rewind to the beginning of the initial buffer, because
        -:  893:   // we only use it after doing 'test', which only ever looks at at most 92 bytes
        1:  894:   s->img_buffer = s->img_buffer_original;
        1:  895:   s->img_buffer_end = s->img_buffer_original_end;
        1:  896:}
        -:  897:
        -:  898:enum
        -:  899:{
        -:  900:   STBI_ORDER_RGB,
        -:  901:   STBI_ORDER_BGR
        -:  902:};
        -:  903:
        -:  904:typedef struct
        -:  905:{
        -:  906:   int bits_per_channel;
        -:  907:   int num_channels;
        -:  908:   int channel_order;
        -:  909:} stbi__result_info;
        -:  910:
        -:  911:#ifndef STBI_NO_JPEG
        -:  912:static int      stbi__jpeg_test(stbi__context *s);
        -:  913:static void    *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
        -:  914:static int      stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp);
        -:  915:#endif
        -:  916:
        -:  917:#ifndef STBI_NO_PNG
        -:  918:static int      stbi__png_test(stbi__context *s);
        -:  919:static void    *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
        -:  920:static int      stbi__png_info(stbi__context *s, int *x, int *y, int *comp);
        -:  921:static int      stbi__png_is16(stbi__context *s);
        -:  922:#endif
        -:  923:
        -:  924:#ifndef STBI_NO_BMP
        -:  925:static int      stbi__bmp_test(stbi__context *s);
        -:  926:static void    *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
        -:  927:static int      stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp);
        -:  928:#endif
        -:  929:
        -:  930:#ifndef STBI_NO_TGA
        -:  931:static int      stbi__tga_test(stbi__context *s);
        -:  932:static void    *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
        -:  933:static int      stbi__tga_info(stbi__context *s, int *x, int *y, int *comp);
        -:  934:#endif
        -:  935:
        -:  936:#ifndef STBI_NO_PSD
        -:  937:static int      stbi__psd_test(stbi__context *s);
        -:  938:static void    *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc);
        -:  939:static int      stbi__psd_info(stbi__context *s, int *x, int *y, int *comp);
        -:  940:static int      stbi__psd_is16(stbi__context *s);
        -:  941:#endif
        -:  942:
        -:  943:#ifndef STBI_NO_HDR
        -:  944:static int      stbi__hdr_test(stbi__context *s);
        -:  945:static float   *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
        -:  946:static int      stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp);
        -:  947:#endif
        -:  948:
        -:  949:#ifndef STBI_NO_PIC
        -:  950:static int      stbi__pic_test(stbi__context *s);
        -:  951:static void    *stbi__pic_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
        -:  952:static int      stbi__pic_info(stbi__context *s, int *x, int *y, int *comp);
        -:  953:#endif
        -:  954:
        -:  955:#ifndef STBI_NO_GIF
        -:  956:static int      stbi__gif_test(stbi__context *s);
        -:  957:static void    *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
        -:  958:static void    *stbi__load_gif_main(stbi__context *s, int **delays, int *x, int *y, int *z, int *comp, int req_comp);
        -:  959:static int      stbi__gif_info(stbi__context *s, int *x, int *y, int *comp);
        -:  960:#endif
        -:  961:
        -:  962:#ifndef STBI_NO_PNM
        -:  963:static int      stbi__pnm_test(stbi__context *s);
        -:  964:static void    *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
        -:  965:static int      stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp);
        -:  966:static int      stbi__pnm_is16(stbi__context *s);
        -:  967:#endif
        -:  968:
        -:  969:static
        -:  970:#ifdef STBI_THREAD_LOCAL
        -:  971:STBI_THREAD_LOCAL
        -:  972:#endif
        -:  973:const char *stbi__g_failure_reason;
        -:  974:
function stbi_failure_reason called 0 returned 0% blocks executed 0%
    #####:  975:STBIDEF const char *stbi_failure_reason(void)
        -:  976:{
    #####:  977:   return stbi__g_failure_reason;
    %%%%%:  977-block 2
        -:  978:}
        -:  979:
        -:  980:#ifndef STBI_NO_FAILURE_STRINGS
function _ZL9stbi__errPKc called 0 returned 0% blocks executed 0%
    #####:  981:static int stbi__err(const char *str)
        -:  982:{
    #####:  983:   stbi__g_failure_reason = str;
    #####:  984:   return 0;
    %%%%%:  984-block 2
        -:  985:}
        -:  986:#endif
        -:  987:
function _ZL12stbi__mallocm called 3 returned 100% blocks executed 100%
        3:  988:static void *stbi__malloc(size_t size)
        -:  989:{
        3:  990:    return STBI_MALLOC(size);
        3:  990-block 2
        -:  991:}
        -:  992:
        -:  993:// stb_image uses ints pervasively, including for offset calculations.
        -:  994:// therefore the largest decoded image size we can support with the
        -:  995:// current code, even on 64-bit targets, is INT_MAX. this is not a
        -:  996:// significant limitation for the intended use case.
        -:  997://
        -:  998:// we do, however, need to make sure our size calculations don't
        -:  999:// overflow. hence a few helper functions for size calculations that
        -: 1000:// multiply integers together, making sure that they're non-negative
        -: 1001:// and no overflow occurs.
        -: 1002:
        -: 1003:// return 1 if the sum is valid, 0 on overflow.
        -: 1004:// negative terms are considered invalid.
function _ZL20stbi__addsizes_validii called 4 returned 100% blocks executed 75%
        4: 1005:static int stbi__addsizes_valid(int a, int b)
        -: 1006:{
       4*: 1007:   if (b < 0) return 0;
        4: 1007-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 4
    %%%%%: 1007-block 3
        -: 1008:   // now 0 <= b <= INT_MAX, hence also
        -: 1009:   // 0 <= INT_MAX - b <= INTMAX.
        -: 1010:   // And "a + b <= INT_MAX" (which might overflow) is the
        -: 1011:   // same as a <= INT_MAX - b (no overflow)
        4: 1012:   return a <= INT_MAX - b;
        4: 1012-block 4
        -: 1013:}
        -: 1014:
        -: 1015:// returns 1 if the product is valid, 0 on overflow.
        -: 1016:// negative factors are considered invalid.
function _ZL21stbi__mul2sizes_validii called 6 returned 100% blocks executed 71%
        6: 1017:static int stbi__mul2sizes_valid(int a, int b)
        -: 1018:{
       6*: 1019:   if (a < 0 || b < 0) return 0;
        6: 1019-block 2
branch  0 taken 6 (fallthrough)
branch  1 taken 0
        6: 1019-block 3
branch  2 taken 0 (fallthrough)
branch  3 taken 6
    %%%%%: 1019-block 4
       6*: 1020:   if (b == 0) return 1; // mul-by-0 is always safe
        6: 1020-block 5
branch  0 taken 0 (fallthrough)
branch  1 taken 6
    %%%%%: 1020-block 6
        -: 1021:   // portable way to check for no overflows in a*b
        6: 1022:   return a <= INT_MAX/b;
        6: 1022-block 7
        -: 1023:}
        -: 1024:
        -: 1025:#if !defined(STBI_NO_JPEG) || !defined(STBI_NO_PNG) || !defined(STBI_NO_TGA) || !defined(STBI_NO_HDR)
        -: 1026:// returns 1 if "a*b + add" has no negative terms/factors and doesn't overflow
function _ZL21stbi__mad2sizes_validiii called 2 returned 100% blocks executed 88%
        2: 1027:static int stbi__mad2sizes_valid(int a, int b, int add)
        -: 1028:{
       2*: 1029:   return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a*b, add);
        2: 1029-block 2
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0
        2: 1029-block 4
call    3 returned 2
branch  4 taken 2 (fallthrough)
branch  5 taken 0
        2: 1029-block 6
    %%%%%: 1029-block 7
        2: 1029-block 8
        -: 1030:}
        -: 1031:#endif
        -: 1032:
        -: 1033:// returns 1 if "a*b*c + add" has no negative terms/factors and doesn't overflow
function _ZL21stbi__mad3sizes_validiiii called 2 returned 100% blocks executed 90%
        2: 1034:static int stbi__mad3sizes_valid(int a, int b, int c, int add)
        -: 1035:{
       4*: 1036:   return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&
        2: 1036-block 2
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0
        2: 1036-block 4
call    3 returned 2
branch  4 taken 2 (fallthrough)
branch  5 taken 0
branch  6 taken 2 (fallthrough)
branch  7 taken 0
        2: 1036-block 8
    %%%%%: 1036-block 9
        4: 1037:      stbi__addsizes_valid(a*b*c, add);
        2: 1037-block 6
call    0 returned 2
        2: 1037-block 10
        -: 1038:}
        -: 1039:
        -: 1040:// returns 1 if "a*b*c*d + add" has no negative terms/factors and doesn't overflow
        -: 1041:#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR) || !defined(STBI_NO_PNM)
function _ZL21stbi__mad4sizes_validiiiii called 0 returned 0% blocks executed 0%
    #####: 1042:static int stbi__mad4sizes_valid(int a, int b, int c, int d, int add)
        -: 1043:{
    #####: 1044:   return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&
    %%%%%: 1044-block 2
call    0 never executed
    %%%%%: 1044-block 4
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 1045:      stbi__mul2sizes_valid(a*b*c, d) && stbi__addsizes_valid(a*b*c*d, add);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1045-block 6
call    2 never executed
    %%%%%: 1045-block 8
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 1045-block 10
    %%%%%: 1045-block 11
    %%%%%: 1045-block 12
        -: 1046:}
        -: 1047:#endif
        -: 1048:
        -: 1049:#if !defined(STBI_NO_JPEG) || !defined(STBI_NO_PNG) || !defined(STBI_NO_TGA) || !defined(STBI_NO_HDR)
        -: 1050:// mallocs with size overflow checking
function _ZL17stbi__malloc_mad2iii called 1 returned 100% blocks executed 80%
        1: 1051:static void *stbi__malloc_mad2(int a, int b, int add)
        -: 1052:{
       1*: 1053:   if (!stbi__mad2sizes_valid(a, b, add)) return NULL;
        1: 1053-block 2
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    %%%%%: 1053-block 4
        1: 1054:   return stbi__malloc(a*b + add);
        1: 1054-block 5
call    0 returned 1
        -: 1055:}
        -: 1056:#endif
        -: 1057:
function _ZL17stbi__malloc_mad3iiii called 1 returned 100% blocks executed 80%
        1: 1058:static void *stbi__malloc_mad3(int a, int b, int c, int add)
        -: 1059:{
       1*: 1060:   if (!stbi__mad3sizes_valid(a, b, c, add)) return NULL;
        1: 1060-block 2
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    %%%%%: 1060-block 4
        1: 1061:   return stbi__malloc(a*b*c + add);
        1: 1061-block 5
call    0 returned 1
        -: 1062:}
        -: 1063:
        -: 1064:#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR) || !defined(STBI_NO_PNM)
function _ZL17stbi__malloc_mad4iiiii called 0 returned 0% blocks executed 0%
    #####: 1065:static void *stbi__malloc_mad4(int a, int b, int c, int d, int add)
        -: 1066:{
    #####: 1067:   if (!stbi__mad4sizes_valid(a, b, c, d, add)) return NULL;
    %%%%%: 1067-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 1067-block 4
    #####: 1068:   return stbi__malloc(a*b*c*d + add);
    %%%%%: 1068-block 5
call    0 never executed
        -: 1069:}
        -: 1070:#endif
        -: 1071:
        -: 1072:// returns 1 if the sum of two signed ints is valid (between -2^31 and 2^31-1 inclusive), 0 on overflow.
function _ZL19stbi__addints_validii called 0 returned 0% blocks executed 0%
    #####: 1073:static int stbi__addints_valid(int a, int b)
        -: 1074:{
    #####: 1075:   if ((a >= 0) != (b >= 0)) return 1; // a and b have different signs, so no overflow
    %%%%%: 1075-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1075-block 3
    #####: 1076:   if (a < 0 && b < 0) return a >= INT_MIN - b; // same as a + b >= INT_MIN; INT_MIN - b cannot overflow since b < 0.
    %%%%%: 1076-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1076-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1076-block 6
    #####: 1077:   return a <= INT_MAX - b;
    %%%%%: 1077-block 7
        -: 1078:}
        -: 1079:
        -: 1080:// returns 1 if the product of two ints fits in a signed short, 0 on overflow.
function _ZL22stbi__mul2shorts_validii called 0 returned 0% blocks executed 0%
    #####: 1081:static int stbi__mul2shorts_valid(int a, int b)
        -: 1082:{
    #####: 1083:   if (b == 0 || b == -1) return 1; // multiplication by 0 is always 0; check for -1 so SHRT_MIN/b doesn't overflow
    %%%%%: 1083-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1083-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1083-block 4
    #####: 1084:   if ((a >= 0) == (b >= 0)) return a <= SHRT_MAX/b; // product is positive, so similar to mul2sizes_valid
    %%%%%: 1084-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1084-block 6
    #####: 1085:   if (b < 0) return a <= SHRT_MIN / b; // same as a * b >= SHRT_MIN
    %%%%%: 1085-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1085-block 8
    #####: 1086:   return a >= SHRT_MIN / b;
    %%%%%: 1086-block 9
        -: 1087:}
        -: 1088:
        -: 1089:// stbi__err - error
        -: 1090:// stbi__errpf - error returning pointer to float
        -: 1091:// stbi__errpuc - error returning pointer to unsigned char
        -: 1092:
        -: 1093:#ifdef STBI_NO_FAILURE_STRINGS
        -: 1094:   #define stbi__err(x,y)  0
        -: 1095:#elif defined(STBI_FAILURE_USERMSG)
        -: 1096:   #define stbi__err(x,y)  stbi__err(y)
        -: 1097:#else
        -: 1098:   #define stbi__err(x,y)  stbi__err(x)
        -: 1099:#endif
        -: 1100:
        -: 1101:#define stbi__errpf(x,y)   ((float *)(size_t) (stbi__err(x,y)?NULL:NULL))
        -: 1102:#define stbi__errpuc(x,y)  ((unsigned char *)(size_t) (stbi__err(x,y)?NULL:NULL))
        -: 1103:
function stbi_image_free called 1 returned 100% blocks executed 100%
        1: 1104:STBIDEF void stbi_image_free(void *retval_from_stbi_load)
        -: 1105:{
        1: 1106:   STBI_FREE(retval_from_stbi_load);
        1: 1107:}
        -: 1108:
        -: 1109:#ifndef STBI_NO_LINEAR
        -: 1110:static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp);
        -: 1111:#endif
        -: 1112:
        -: 1113:#ifndef STBI_NO_HDR
        -: 1114:static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp);
        -: 1115:#endif
        -: 1116:
        -: 1117:static int stbi__vertically_flip_on_load_global = 0;
        -: 1118:
function stbi_set_flip_vertically_on_load called 0 returned 0% blocks executed 0%
    #####: 1119:STBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip)
        -: 1120:{
    #####: 1121:   stbi__vertically_flip_on_load_global = flag_true_if_should_flip;
    #####: 1122:}
        -: 1123:
        -: 1124:#ifndef STBI_THREAD_LOCAL
        -: 1125:#define stbi__vertically_flip_on_load  stbi__vertically_flip_on_load_global
        -: 1126:#else
        -: 1127:static STBI_THREAD_LOCAL int stbi__vertically_flip_on_load_local, stbi__vertically_flip_on_load_set;
        -: 1128:
function stbi_set_flip_vertically_on_load_thread called 0 returned 0% blocks executed 0%
    #####: 1129:STBIDEF void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip)
        -: 1130:{
    #####: 1131:   stbi__vertically_flip_on_load_local = flag_true_if_should_flip;
    #####: 1132:   stbi__vertically_flip_on_load_set = 1;
    #####: 1133:}
        -: 1134:
        -: 1135:#define stbi__vertically_flip_on_load  (stbi__vertically_flip_on_load_set       \
        -: 1136:                                         ? stbi__vertically_flip_on_load_local  \
        -: 1137:                                         : stbi__vertically_flip_on_load_global)
        -: 1138:#endif // STBI_THREAD_LOCAL
        -: 1139:
function _ZL15stbi__load_mainP13stbi__contextPiS1_S1_iP17stbi__result_infoi called 1 returned 100% blocks executed 12%
        1: 1140:static void *stbi__load_main(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
        -: 1141:{
        1: 1142:   memset(ri, 0, sizeof(*ri)); // make sure it's initialized if we add new fields
        1: 1143:   ri->bits_per_channel = 8; // default is 8 so most paths don't have to be changed
        1: 1144:   ri->channel_order = STBI_ORDER_RGB; // all current input & output are this, but this is here so we can add BGR order
        1: 1145:   ri->num_channels = 0;
        -: 1146:
        -: 1147:   // test the formats with a very explicit header first (at least a FOURCC
        -: 1148:   // or distinctive magic number first)
        -: 1149:   #ifndef STBI_NO_PNG
        1: 1150:   if (stbi__png_test(s))  return stbi__png_load(s,x,y,comp,req_comp, ri);
        1: 1150-block 2
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0
        1: 1150-block 4
call    3 returned 1
        -: 1151:   #endif
        -: 1152:   #ifndef STBI_NO_BMP
    #####: 1153:   if (stbi__bmp_test(s))  return stbi__bmp_load(s,x,y,comp,req_comp, ri);
    %%%%%: 1153-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 1153-block 8
call    3 never executed
        -: 1154:   #endif
        -: 1155:   #ifndef STBI_NO_GIF
    #####: 1156:   if (stbi__gif_test(s))  return stbi__gif_load(s,x,y,comp,req_comp, ri);
    %%%%%: 1156-block 10
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 1156-block 12
call    3 never executed
        -: 1157:   #endif
        -: 1158:   #ifndef STBI_NO_PSD
    #####: 1159:   if (stbi__psd_test(s))  return stbi__psd_load(s,x,y,comp,req_comp, ri, bpc);
    %%%%%: 1159-block 14
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 1159-block 16
call    3 never executed
        -: 1160:   #else
        -: 1161:   STBI_NOTUSED(bpc);
        -: 1162:   #endif
        -: 1163:   #ifndef STBI_NO_PIC
    #####: 1164:   if (stbi__pic_test(s))  return stbi__pic_load(s,x,y,comp,req_comp, ri);
    %%%%%: 1164-block 18
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 1164-block 20
call    3 never executed
        -: 1165:   #endif
        -: 1166:
        -: 1167:   // then the formats that can end up attempting to load with just 1 or 2
        -: 1168:   // bytes matching expectations; these are prone to false positives, so
        -: 1169:   // try them later
        -: 1170:   #ifndef STBI_NO_JPEG
    #####: 1171:   if (stbi__jpeg_test(s)) return stbi__jpeg_load(s,x,y,comp,req_comp, ri);
    %%%%%: 1171-block 22
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 1171-block 24
call    3 never executed
        -: 1172:   #endif
        -: 1173:   #ifndef STBI_NO_PNM
    #####: 1174:   if (stbi__pnm_test(s))  return stbi__pnm_load(s,x,y,comp,req_comp, ri);
    %%%%%: 1174-block 26
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 1174-block 28
call    3 never executed
        -: 1175:   #endif
        -: 1176:
        -: 1177:   #ifndef STBI_NO_HDR
    #####: 1178:   if (stbi__hdr_test(s)) {
    %%%%%: 1178-block 30
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 1179:      float *hdr = stbi__hdr_load(s, x,y,comp,req_comp, ri);
    %%%%%: 1179-block 32
call    0 never executed
    #####: 1180:      return stbi__hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1180-block 34
    %%%%%: 1180-block 35
    %%%%%: 1180-block 36
call    2 never executed
        -: 1181:   }
        -: 1182:   #endif
        -: 1183:
        -: 1184:   #ifndef STBI_NO_TGA
        -: 1185:   // test tga last because it's a crappy test!
    #####: 1186:   if (stbi__tga_test(s))
    %%%%%: 1186-block 37
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 1187:      return stbi__tga_load(s,x,y,comp,req_comp, ri);
    %%%%%: 1187-block 39
call    0 never executed
        -: 1188:   #endif
        -: 1189:
    #####: 1190:   return stbi__errpuc("unknown image type", "Image not of any known type, or corrupt");
    %%%%%: 1190-block 41
call    0 never executed
        -: 1191:}
        -: 1192:
function _ZL21stbi__convert_16_to_8Ptiii called 0 returned 0% blocks executed 0%
    #####: 1193:static stbi_uc *stbi__convert_16_to_8(stbi__uint16 *orig, int w, int h, int channels)
        -: 1194:{
        -: 1195:   int i;
    #####: 1196:   int img_len = w * h * channels;
        -: 1197:   stbi_uc *reduced;
        -: 1198:
    #####: 1199:   reduced = (stbi_uc *) stbi__malloc(img_len);
    %%%%%: 1199-block 2
call    0 never executed
    #####: 1200:   if (reduced == NULL) return stbi__errpuc("outofmem", "Out of memory");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1200-block 4
call    2 never executed
        -: 1201:
    #####: 1202:   for (i = 0; i < img_len; ++i)
    %%%%%: 1202-block 6
    %%%%%: 1202-block 8
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 1203:      reduced[i] = (stbi_uc)((orig[i] >> 8) & 0xFF); // top half of each byte is sufficient approx of 16->8 bit scaling
    %%%%%: 1203-block 7
        -: 1204:
    #####: 1205:   STBI_FREE(orig);
    #####: 1206:   return reduced;
    %%%%%: 1206-block 9
        -: 1207:}
        -: 1208:
function _ZL21stbi__convert_8_to_16Phiii called 0 returned 0% blocks executed 0%
    #####: 1209:static stbi__uint16 *stbi__convert_8_to_16(stbi_uc *orig, int w, int h, int channels)
        -: 1210:{
        -: 1211:   int i;
    #####: 1212:   int img_len = w * h * channels;
        -: 1213:   stbi__uint16 *enlarged;
        -: 1214:
    #####: 1215:   enlarged = (stbi__uint16 *) stbi__malloc(img_len*2);
    %%%%%: 1215-block 2
call    0 never executed
    #####: 1216:   if (enlarged == NULL) return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1216-block 4
call    2 never executed
        -: 1217:
    #####: 1218:   for (i = 0; i < img_len; ++i)
    %%%%%: 1218-block 6
    %%%%%: 1218-block 8
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 1219:      enlarged[i] = (stbi__uint16)((orig[i] << 8) + orig[i]); // replicate to high and low byte, maps 0->0, 255->0xffff
    %%%%%: 1219-block 7
        -: 1220:
    #####: 1221:   STBI_FREE(orig);
    #####: 1222:   return enlarged;
    %%%%%: 1222-block 9
        -: 1223:}
        -: 1224:
function _ZL19stbi__vertical_flipPviii called 0 returned 0% blocks executed 0%
    #####: 1225:static void stbi__vertical_flip(void *image, int w, int h, int bytes_per_pixel)
        -: 1226:{
        -: 1227:   int row;
    #####: 1228:   size_t bytes_per_row = (size_t)w * bytes_per_pixel;
        -: 1229:   stbi_uc temp[2048];
    #####: 1230:   stbi_uc *bytes = (stbi_uc *)image;
        -: 1231:
    #####: 1232:   for (row = 0; row < (h>>1); row++) {
    %%%%%: 1232-block 2
    %%%%%: 1232-block 6
    %%%%%: 1232-block 7
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 1233:      stbi_uc *row0 = bytes + row*bytes_per_row;
    #####: 1234:      stbi_uc *row1 = bytes + (h - row - 1)*bytes_per_row;
        -: 1235:      // swap row0 with row1
    #####: 1236:      size_t bytes_left = bytes_per_row;
    #####: 1237:      while (bytes_left) {
    %%%%%: 1237-block 3
    %%%%%: 1237-block 5
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 1238:         size_t bytes_copy = (bytes_left < sizeof(temp)) ? bytes_left : sizeof(temp);
    #####: 1239:         memcpy(temp, row0, bytes_copy);
    #####: 1240:         memcpy(row0, row1, bytes_copy);
    #####: 1241:         memcpy(row1, temp, bytes_copy);
    #####: 1242:         row0 += bytes_copy;
    #####: 1243:         row1 += bytes_copy;
    #####: 1244:         bytes_left -= bytes_copy;
    %%%%%: 1244-block 4
        -: 1245:      }
        -: 1246:   }
    #####: 1247:}
        -: 1248:
        -: 1249:#ifndef STBI_NO_GIF
function _ZL26stbi__vertical_flip_slicesPviiii called 0 returned 0% blocks executed 0%
    #####: 1250:static void stbi__vertical_flip_slices(void *image, int w, int h, int z, int bytes_per_pixel)
        -: 1251:{
        -: 1252:   int slice;
    #####: 1253:   int slice_size = w * h * bytes_per_pixel;
        -: 1254:
    #####: 1255:   stbi_uc *bytes = (stbi_uc *)image;
    #####: 1256:   for (slice = 0; slice < z; ++slice) {
    %%%%%: 1256-block 2
    %%%%%: 1256-block 5
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 1257:      stbi__vertical_flip(bytes, w, h, bytes_per_pixel);
    %%%%%: 1257-block 3
call    0 never executed
    #####: 1258:      bytes += slice_size;
        -: 1259:   }
    #####: 1260:}
        -: 1261:#endif
        -: 1262:
function _ZL31stbi__load_and_postprocess_8bitP13stbi__contextPiS1_S1_i called 1 returned 100% blocks executed 46%
        1: 1263:static unsigned char *stbi__load_and_postprocess_8bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
        -: 1264:{
        -: 1265:   stbi__result_info ri;
        1: 1266:   void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 8);
        1: 1266-block 2
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -: 1267:
        1: 1268:   if (result == NULL)
        1: 1268-block 3
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 1269:      return NULL;
    %%%%%: 1269-block 4
        -: 1270:
        -: 1271:   // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
       1*: 1272:   STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);
        1: 1272-block 5
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 1272-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1272-block 7
call    4 never executed
        -: 1273:
        1: 1274:   if (ri.bits_per_channel != 8) {
        1: 1274-block 8
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 1275:      result = stbi__convert_16_to_8((stbi__uint16 *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
    %%%%%: 1275-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1275-block 10
    %%%%%: 1275-block 11
    %%%%%: 1275-block 12
call    2 never executed
    #####: 1276:      ri.bits_per_channel = 8;
        -: 1277:   }
        -: 1278:
        -: 1279:   // @TODO: move stbi__convert_format to here
        -: 1280:
       1*: 1281:   if (stbi__vertically_flip_on_load) {
        1: 1281-block 14
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 1281-block 15
        1: 1281-block 16
        1: 1281-block 17
branch  2 taken 0 (fallthrough)
branch  3 taken 1
    #####: 1282:      int channels = req_comp ? req_comp : *comp;
    %%%%%: 1282-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1282-block 19
    %%%%%: 1282-block 20
    #####: 1283:      stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi_uc));
    %%%%%: 1283-block 21
call    0 never executed
        -: 1284:   }
        -: 1285:
        1: 1286:   return (unsigned char *) result;
        1: 1286-block 22
        -: 1287:}
        -: 1288:
function _ZL32stbi__load_and_postprocess_16bitP13stbi__contextPiS1_S1_i called 0 returned 0% blocks executed 0%
    #####: 1289:static stbi__uint16 *stbi__load_and_postprocess_16bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
        -: 1290:{
        -: 1291:   stbi__result_info ri;
    #####: 1292:   void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 16);
    %%%%%: 1292-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 1293:
    #####: 1294:   if (result == NULL)
    %%%%%: 1294-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1295:      return NULL;
    %%%%%: 1295-block 4
        -: 1296:
        -: 1297:   // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
    #####: 1298:   STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);
    %%%%%: 1298-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1298-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1298-block 7
call    4 never executed
        -: 1299:
    #####: 1300:   if (ri.bits_per_channel != 16) {
    %%%%%: 1300-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1301:      result = stbi__convert_8_to_16((stbi_uc *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
    %%%%%: 1301-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1301-block 10
    %%%%%: 1301-block 11
    %%%%%: 1301-block 12
call    2 never executed
    #####: 1302:      ri.bits_per_channel = 16;
        -: 1303:   }
        -: 1304:
        -: 1305:   // @TODO: move stbi__convert_format16 to here
        -: 1306:   // @TODO: special case RGB-to-Y (and RGBA-to-YA) for 8-bit-to-16-bit case to keep more precision
        -: 1307:
    #####: 1308:   if (stbi__vertically_flip_on_load) {
    %%%%%: 1308-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1308-block 15
    %%%%%: 1308-block 16
    %%%%%: 1308-block 17
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 1309:      int channels = req_comp ? req_comp : *comp;
    %%%%%: 1309-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1309-block 19
    %%%%%: 1309-block 20
    #####: 1310:      stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi__uint16));
    %%%%%: 1310-block 21
call    0 never executed
        -: 1311:   }
        -: 1312:
    #####: 1313:   return (stbi__uint16 *) result;
    %%%%%: 1313-block 22
        -: 1314:}
        -: 1315:
        -: 1316:#if !defined(STBI_NO_HDR) && !defined(STBI_NO_LINEAR)
function _ZL23stbi__float_postprocessPfPiS0_S0_i called 0 returned 0% blocks executed 0%
    #####: 1317:static void stbi__float_postprocess(float *result, int *x, int *y, int *comp, int req_comp)
        -: 1318:{
    #####: 1319:   if (stbi__vertically_flip_on_load && result != NULL) {
    %%%%%: 1319-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1319-block 3
    %%%%%: 1319-block 4
    %%%%%: 1319-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1319-block 6
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 1320:      int channels = req_comp ? req_comp : *comp;
    %%%%%: 1320-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1320-block 8
    %%%%%: 1320-block 9
    #####: 1321:      stbi__vertical_flip(result, *x, *y, channels * sizeof(float));
    %%%%%: 1321-block 10
call    0 never executed
        -: 1322:   }
    #####: 1323:}
        -: 1324:#endif
        -: 1325:
        -: 1326:#ifndef STBI_NO_STDIO
        -: 1327:
        -: 1328:#if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
        -: 1329:STBI_EXTERN __declspec(dllimport) int __stdcall MultiByteToWideChar(unsigned int cp, unsigned long flags, const char *str, int cbmb, wchar_t *widestr, int cchwide);
        -: 1330:STBI_EXTERN __declspec(dllimport) int __stdcall WideCharToMultiByte(unsigned int cp, unsigned long flags, const wchar_t *widestr, int cchwide, char *str, int cbmb, const char *defchar, int *used_default);
        -: 1331:#endif
        -: 1332:
        -: 1333:#if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
        -: 1334:STBIDEF int stbi_convert_wchar_to_utf8(char *buffer, size_t bufferlen, const wchar_t* input)
        -: 1335:{
        -: 1336:	return WideCharToMultiByte(65001 /* UTF8 */, 0, input, -1, buffer, (int) bufferlen, NULL, NULL);
        -: 1337:}
        -: 1338:#endif
        -: 1339:
function _ZL11stbi__fopenPKcS0_ called 1 returned 100% blocks executed 100%
        1: 1340:static FILE *stbi__fopen(char const *filename, char const *mode)
        -: 1341:{
        -: 1342:   FILE *f;
        -: 1343:#if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
        -: 1344:   wchar_t wMode[64];
        -: 1345:   wchar_t wFilename[1024];
        -: 1346:	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, filename, -1, wFilename, sizeof(wFilename)/sizeof(*wFilename)))
        -: 1347:      return 0;
        -: 1348:
        -: 1349:	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, mode, -1, wMode, sizeof(wMode)/sizeof(*wMode)))
        -: 1350:      return 0;
        -: 1351:
        -: 1352:#if defined(_MSC_VER) && _MSC_VER >= 1400
        -: 1353:	if (0 != _wfopen_s(&f, wFilename, wMode))
        -: 1354:		f = 0;
        -: 1355:#else
        -: 1356:   f = _wfopen(wFilename, wMode);
        -: 1357:#endif
        -: 1358:
        -: 1359:#elif defined(_MSC_VER) && _MSC_VER >= 1400
        -: 1360:   if (0 != fopen_s(&f, filename, mode))
        -: 1361:      f=0;
        -: 1362:#else
        1: 1363:   f = fopen(filename, mode);
        1: 1363-block 2
call    0 returned 1
        -: 1364:#endif
        1: 1365:   return f;
        -: 1366:}
        -: 1367:
        -: 1368:
function stbi_load called 1 returned 100% blocks executed 75%
        1: 1369:STBIDEF stbi_uc *stbi_load(char const *filename, int *x, int *y, int *comp, int req_comp)
        -: 1370:{
        1: 1371:   FILE *f = stbi__fopen(filename, "rb");
        1: 1371-block 2
call    0 returned 1
        -: 1372:   unsigned char *result;
       1*: 1373:   if (!f) return stbi__errpuc("can't fopen", "Unable to open file");
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 1373-block 4
call    2 never executed
        1: 1374:   result = stbi_load_from_file(f,x,y,comp,req_comp);
        1: 1374-block 6
call    0 returned 1
        1: 1375:   fclose(f);
call    0 returned 1
        1: 1376:   return result;
        -: 1377:}
        -: 1378:
function stbi_load_from_file called 1 returned 100% blocks executed 100%
        1: 1379:STBIDEF stbi_uc *stbi_load_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
        -: 1380:{
        -: 1381:   unsigned char *result;
        -: 1382:   stbi__context s;
        1: 1383:   stbi__start_file(&s,f);
        1: 1383-block 2
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 1384:   result = stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
        1: 1384-block 3
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 1385:   if (result) {
        1: 1385-block 4
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 1386:      // need to 'unget' all the characters in the IO buffer
        1: 1387:      fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);
        1: 1387-block 5
call    0 returned 1
        -: 1388:   }
        1: 1389:   return result;
        1: 1389-block 6
        1: 1389-block 7
        -: 1390:}
        -: 1391:
function stbi_load_from_file_16 called 0 returned 0% blocks executed 0%
    #####: 1392:STBIDEF stbi__uint16 *stbi_load_from_file_16(FILE *f, int *x, int *y, int *comp, int req_comp)
        -: 1393:{
        -: 1394:   stbi__uint16 *result;
        -: 1395:   stbi__context s;
    #####: 1396:   stbi__start_file(&s,f);
    %%%%%: 1396-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1397:   result = stbi__load_and_postprocess_16bit(&s,x,y,comp,req_comp);
    %%%%%: 1397-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1398:   if (result) {
    %%%%%: 1398-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1399:      // need to 'unget' all the characters in the IO buffer
    #####: 1400:      fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);
    %%%%%: 1400-block 5
call    0 never executed
        -: 1401:   }
    #####: 1402:   return result;
    %%%%%: 1402-block 6
    %%%%%: 1402-block 7
        -: 1403:}
        -: 1404:
function stbi_load_16 called 0 returned 0% blocks executed 0%
    #####: 1405:STBIDEF stbi_us *stbi_load_16(char const *filename, int *x, int *y, int *comp, int req_comp)
        -: 1406:{
    #####: 1407:   FILE *f = stbi__fopen(filename, "rb");
    %%%%%: 1407-block 2
call    0 never executed
        -: 1408:   stbi__uint16 *result;
    #####: 1409:   if (!f) return (stbi_us *) stbi__errpuc("can't fopen", "Unable to open file");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1409-block 4
call    2 never executed
    #####: 1410:   result = stbi_load_from_file_16(f,x,y,comp,req_comp);
    %%%%%: 1410-block 6
call    0 never executed
    #####: 1411:   fclose(f);
call    0 never executed
    #####: 1412:   return result;
        -: 1413:}
        -: 1414:
        -: 1415:
        -: 1416:#endif //!STBI_NO_STDIO
        -: 1417:
function stbi_load_16_from_memory called 0 returned 0% blocks executed 0%
    #####: 1418:STBIDEF stbi_us *stbi_load_16_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels)
        -: 1419:{
        -: 1420:   stbi__context s;
    #####: 1421:   stbi__start_mem(&s,buffer,len);
    %%%%%: 1421-block 2
call    0 never executed
    #####: 1422:   return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1422-block 4
    %%%%%: 1422-block 6
        -: 1423:}
        -: 1424:
function stbi_load_16_from_callbacks called 0 returned 0% blocks executed 0%
    #####: 1425:STBIDEF stbi_us *stbi_load_16_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels)
        -: 1426:{
        -: 1427:   stbi__context s;
    #####: 1428:   stbi__start_callbacks(&s, (stbi_io_callbacks *)clbk, user);
    %%%%%: 1428-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1429:   return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);
    %%%%%: 1429-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1429-block 4
    %%%%%: 1429-block 6
        -: 1430:}
        -: 1431:
function stbi_load_from_memory called 0 returned 0% blocks executed 0%
    #####: 1432:STBIDEF stbi_uc *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
        -: 1433:{
        -: 1434:   stbi__context s;
    #####: 1435:   stbi__start_mem(&s,buffer,len);
    %%%%%: 1435-block 2
call    0 never executed
    #####: 1436:   return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1436-block 4
    %%%%%: 1436-block 6
        -: 1437:}
        -: 1438:
function stbi_load_from_callbacks called 0 returned 0% blocks executed 0%
    #####: 1439:STBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
        -: 1440:{
        -: 1441:   stbi__context s;
    #####: 1442:   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
    %%%%%: 1442-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1443:   return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
    %%%%%: 1443-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1443-block 4
    %%%%%: 1443-block 6
        -: 1444:}
        -: 1445:
        -: 1446:#ifndef STBI_NO_GIF
function stbi_load_gif_from_memory called 0 returned 0% blocks executed 0%
    #####: 1447:STBIDEF stbi_uc *stbi_load_gif_from_memory(stbi_uc const *buffer, int len, int **delays, int *x, int *y, int *z, int *comp, int req_comp)
        -: 1448:{
        -: 1449:   unsigned char *result;
        -: 1450:   stbi__context s;
    #####: 1451:   stbi__start_mem(&s,buffer,len);
    %%%%%: 1451-block 2
call    0 never executed
        -: 1452:
    #####: 1453:   result = (unsigned char*) stbi__load_gif_main(&s, delays, x, y, z, comp, req_comp);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1454:   if (stbi__vertically_flip_on_load) {
    %%%%%: 1454-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1454-block 5
    %%%%%: 1454-block 6
    %%%%%: 1454-block 7
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 1455:      stbi__vertical_flip_slices( result, *x, *y, *z, *comp );
    %%%%%: 1455-block 8
call    0 never executed
        -: 1456:   }
        -: 1457:
    #####: 1458:   return result;
    %%%%%: 1458-block 9
    %%%%%: 1458-block 10
        -: 1459:}
        -: 1460:#endif
        -: 1461:
        -: 1462:#ifndef STBI_NO_LINEAR
function _ZL16stbi__loadf_mainP13stbi__contextPiS1_S1_i called 0 returned 0% blocks executed 0%
    #####: 1463:static float *stbi__loadf_main(stbi__context *s, int *x, int *y, int *comp, int req_comp)
        -: 1464:{
        -: 1465:   unsigned char *data;
        -: 1466:   #ifndef STBI_NO_HDR
    #####: 1467:   if (stbi__hdr_test(s)) {
    %%%%%: 1467-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -: 1468:      stbi__result_info ri;
    #####: 1469:      float *hdr_data = stbi__hdr_load(s,x,y,comp,req_comp, &ri);
    %%%%%: 1469-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1470:      if (hdr_data)
    %%%%%: 1470-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1471:         stbi__float_postprocess(hdr_data,x,y,comp,req_comp);
    %%%%%: 1471-block 6
call    0 never executed
    #####: 1472:      return hdr_data;
    %%%%%: 1472-block 7
        -: 1473:   }
        -: 1474:   #endif
    #####: 1475:   data = stbi__load_and_postprocess_8bit(s, x, y, comp, req_comp);
    %%%%%: 1475-block 8
call    0 never executed
    #####: 1476:   if (data)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1477:      return stbi__ldr_to_hdr(data, *x, *y, req_comp ? req_comp : *comp);
    %%%%%: 1477-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1477-block 11
    %%%%%: 1477-block 12
    %%%%%: 1477-block 13
call    2 never executed
    #####: 1478:   return stbi__errpf("unknown image type", "Image not of any known type, or corrupt");
    %%%%%: 1478-block 14
call    0 never executed
        -: 1479:}
        -: 1480:
function stbi_loadf_from_memory called 0 returned 0% blocks executed 0%
    #####: 1481:STBIDEF float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
        -: 1482:{
        -: 1483:   stbi__context s;
    #####: 1484:   stbi__start_mem(&s,buffer,len);
    %%%%%: 1484-block 2
call    0 never executed
    #####: 1485:   return stbi__loadf_main(&s,x,y,comp,req_comp);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1485-block 4
    %%%%%: 1485-block 6
        -: 1486:}
        -: 1487:
function stbi_loadf_from_callbacks called 0 returned 0% blocks executed 0%
    #####: 1488:STBIDEF float *stbi_loadf_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
        -: 1489:{
        -: 1490:   stbi__context s;
    #####: 1491:   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
    %%%%%: 1491-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1492:   return stbi__loadf_main(&s,x,y,comp,req_comp);
    %%%%%: 1492-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1492-block 4
    %%%%%: 1492-block 6
        -: 1493:}
        -: 1494:
        -: 1495:#ifndef STBI_NO_STDIO
function stbi_loadf called 0 returned 0% blocks executed 0%
    #####: 1496:STBIDEF float *stbi_loadf(char const *filename, int *x, int *y, int *comp, int req_comp)
        -: 1497:{
        -: 1498:   float *result;
    #####: 1499:   FILE *f = stbi__fopen(filename, "rb");
    %%%%%: 1499-block 2
call    0 never executed
    #####: 1500:   if (!f) return stbi__errpf("can't fopen", "Unable to open file");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1500-block 4
call    2 never executed
    #####: 1501:   result = stbi_loadf_from_file(f,x,y,comp,req_comp);
    %%%%%: 1501-block 6
call    0 never executed
    #####: 1502:   fclose(f);
call    0 never executed
    #####: 1503:   return result;
        -: 1504:}
        -: 1505:
function stbi_loadf_from_file called 0 returned 0% blocks executed 0%
    #####: 1506:STBIDEF float *stbi_loadf_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
        -: 1507:{
        -: 1508:   stbi__context s;
    #####: 1509:   stbi__start_file(&s,f);
    %%%%%: 1509-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1510:   return stbi__loadf_main(&s,x,y,comp,req_comp);
    %%%%%: 1510-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1510-block 4
    %%%%%: 1510-block 6
        -: 1511:}
        -: 1512:#endif // !STBI_NO_STDIO
        -: 1513:
        -: 1514:#endif // !STBI_NO_LINEAR
        -: 1515:
        -: 1516:// these is-hdr-or-not is defined independent of whether STBI_NO_LINEAR is
        -: 1517:// defined, for API simplicity; if STBI_NO_LINEAR is defined, it always
        -: 1518:// reports false!
        -: 1519:
function stbi_is_hdr_from_memory called 0 returned 0% blocks executed 0%
    #####: 1520:STBIDEF int stbi_is_hdr_from_memory(stbi_uc const *buffer, int len)
        -: 1521:{
        -: 1522:   #ifndef STBI_NO_HDR
        -: 1523:   stbi__context s;
    #####: 1524:   stbi__start_mem(&s,buffer,len);
    %%%%%: 1524-block 2
call    0 never executed
    #####: 1525:   return stbi__hdr_test(&s);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1525-block 4
    %%%%%: 1525-block 6
        -: 1526:   #else
        -: 1527:   STBI_NOTUSED(buffer);
        -: 1528:   STBI_NOTUSED(len);
        -: 1529:   return 0;
        -: 1530:   #endif
        -: 1531:}
        -: 1532:
        -: 1533:#ifndef STBI_NO_STDIO
function stbi_is_hdr called 0 returned 0% blocks executed 0%
    #####: 1534:STBIDEF int      stbi_is_hdr          (char const *filename)
        -: 1535:{
    #####: 1536:   FILE *f = stbi__fopen(filename, "rb");
    %%%%%: 1536-block 2
call    0 never executed
    #####: 1537:   int result=0;
    #####: 1538:   if (f) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1539:      result = stbi_is_hdr_from_file(f);
    %%%%%: 1539-block 4
call    0 never executed
    #####: 1540:      fclose(f);
call    0 never executed
        -: 1541:   }
    #####: 1542:   return result;
    %%%%%: 1542-block 6
        -: 1543:}
        -: 1544:
function stbi_is_hdr_from_file called 0 returned 0% blocks executed 0%
    #####: 1545:STBIDEF int stbi_is_hdr_from_file(FILE *f)
        -: 1546:{
        -: 1547:   #ifndef STBI_NO_HDR
    #####: 1548:   long pos = ftell(f);
    %%%%%: 1548-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 1549:   int res;
        -: 1550:   stbi__context s;
    #####: 1551:   stbi__start_file(&s,f);
    %%%%%: 1551-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1552:   res = stbi__hdr_test(&s);
    %%%%%: 1552-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1553:   fseek(f, pos, SEEK_SET);
    %%%%%: 1553-block 5
call    0 never executed
    #####: 1554:   return res;
    %%%%%: 1554-block 7
        -: 1555:   #else
        -: 1556:   STBI_NOTUSED(f);
        -: 1557:   return 0;
        -: 1558:   #endif
        -: 1559:}
        -: 1560:#endif // !STBI_NO_STDIO
        -: 1561:
function stbi_is_hdr_from_callbacks called 0 returned 0% blocks executed 0%
    #####: 1562:STBIDEF int      stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user)
        -: 1563:{
        -: 1564:   #ifndef STBI_NO_HDR
        -: 1565:   stbi__context s;
    #####: 1566:   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
    %%%%%: 1566-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1567:   return stbi__hdr_test(&s);
    %%%%%: 1567-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1567-block 4
    %%%%%: 1567-block 6
        -: 1568:   #else
        -: 1569:   STBI_NOTUSED(clbk);
        -: 1570:   STBI_NOTUSED(user);
        -: 1571:   return 0;
        -: 1572:   #endif
        -: 1573:}
        -: 1574:
        -: 1575:#ifndef STBI_NO_LINEAR
        -: 1576:static float stbi__l2h_gamma=2.2f, stbi__l2h_scale=1.0f;
        -: 1577:
function stbi_ldr_to_hdr_gamma called 0 returned 0% blocks executed 0%
    #####: 1578:STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma) { stbi__l2h_gamma = gamma; }
function stbi_ldr_to_hdr_scale called 0 returned 0% blocks executed 0%
    #####: 1579:STBIDEF void   stbi_ldr_to_hdr_scale(float scale) { stbi__l2h_scale = scale; }
        -: 1580:#endif
        -: 1581:
        -: 1582:static float stbi__h2l_gamma_i=1.0f/2.2f, stbi__h2l_scale_i=1.0f;
        -: 1583:
function stbi_hdr_to_ldr_gamma called 0 returned 0% blocks executed 0%
    #####: 1584:STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma) { stbi__h2l_gamma_i = 1/gamma; }
function stbi_hdr_to_ldr_scale called 0 returned 0% blocks executed 0%
    #####: 1585:STBIDEF void   stbi_hdr_to_ldr_scale(float scale) { stbi__h2l_scale_i = 1/scale; }
        -: 1586:
        -: 1587:
        -: 1588://////////////////////////////////////////////////////////////////////////////
        -: 1589://
        -: 1590:// Common code used by all image loaders
        -: 1591://
        -: 1592:
        -: 1593:enum
        -: 1594:{
        -: 1595:   STBI__SCAN_load=0,
        -: 1596:   STBI__SCAN_type,
        -: 1597:   STBI__SCAN_header
        -: 1598:};
        -: 1599:
function _ZL19stbi__refill_bufferP13stbi__context called 3 returned 100% blocks executed 80%
        3: 1600:static void stbi__refill_buffer(stbi__context *s)
        -: 1601:{
        3: 1602:   int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);
        3: 1602-block 2
call    0 returned 3
        3: 1603:   s->callback_already_read += (int) (s->img_buffer - s->img_buffer_original);
        3: 1604:   if (n == 0) {
branch  0 taken 0 (fallthrough)
branch  1 taken 3
        -: 1605:      // at end of file, treat same as if from memory, but need to handle case
        -: 1606:      // where s->img_buffer isn't pointing to safe memory, e.g. 0-byte file
    #####: 1607:      s->read_from_callbacks = 0;
    #####: 1608:      s->img_buffer = s->buffer_start;
    #####: 1609:      s->img_buffer_end = s->buffer_start+1;
    #####: 1610:      *s->img_buffer = 0;
    %%%%%: 1610-block 4
        -: 1611:   } else {
        3: 1612:      s->img_buffer = s->buffer_start;
        3: 1613:      s->img_buffer_end = s->buffer_start + n;
        3: 1613-block 5
        -: 1614:   }
        3: 1615:}
        -: 1616:
function _ZL10stbi__get8P13stbi__context called 113 returned 100% blocks executed 86%
      113: 1617:stbi_inline static stbi_uc stbi__get8(stbi__context *s)
        -: 1618:{
      113: 1619:   if (s->img_buffer < s->img_buffer_end)
      113: 1619-block 2
branch  0 taken 111 (fallthrough)
branch  1 taken 2
      111: 1620:      return *s->img_buffer++;
      111: 1620-block 3
        2: 1621:   if (s->read_from_callbacks) {
        2: 1621-block 4
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2: 1622:      stbi__refill_buffer(s);
        2: 1622-block 5
call    0 returned 2
        2: 1623:      return *s->img_buffer++;
        -: 1624:   }
    #####: 1625:   return 0;
    %%%%%: 1625-block 7
        -: 1626:}
        -: 1627:
        -: 1628:#if defined(STBI_NO_JPEG) && defined(STBI_NO_HDR) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
        -: 1629:// nothing
        -: 1630:#else
function _ZL12stbi__at_eofP13stbi__context called 0 returned 0% blocks executed 0%
    #####: 1631:stbi_inline static int stbi__at_eof(stbi__context *s)
        -: 1632:{
    #####: 1633:   if (s->io.read) {
    %%%%%: 1633-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1634:      if (!(s->io.eof)(s->io_user_data)) return 0;
    %%%%%: 1634-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 1634-block 5
        -: 1635:      // if feof() is true, check if buffer = end
        -: 1636:      // special case: we've only got the special 0 character at the end
    #####: 1637:      if (s->read_from_callbacks == 0) return 1;
    %%%%%: 1637-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1637-block 7
        -: 1638:   }
        -: 1639:
    #####: 1640:   return s->img_buffer >= s->img_buffer_end;
    %%%%%: 1640-block 8
        -: 1641:}
        -: 1642:#endif
        -: 1643:
        -: 1644:#if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC)
        -: 1645:// nothing
        -: 1646:#else
function _ZL10stbi__skipP13stbi__contexti called 4 returned 100% blocks executed 80%
        4: 1647:static void stbi__skip(stbi__context *s, int n)
        -: 1648:{
       4*: 1649:   if (n == 0) return;  // already there!
        4: 1649-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 4
    %%%%%: 1649-block 3
        4: 1650:   if (n < 0) {
        4: 1650-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 4
    #####: 1651:      s->img_buffer = s->img_buffer_end;
    #####: 1652:      return;
    %%%%%: 1652-block 5
        -: 1653:   }
        4: 1654:   if (s->io.read) {
        4: 1654-block 6
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4: 1655:      int blen = (int) (s->img_buffer_end - s->img_buffer);
        4: 1656:      if (blen < n) {
        4: 1656-block 7
branch  0 taken 1 (fallthrough)
branch  1 taken 3
        1: 1657:         s->img_buffer = s->img_buffer_end;
        1: 1658:         (s->io.skip)(s->io_user_data, n - blen);
        1: 1658-block 8
call    0 returned 1
        1: 1659:         return;
        -: 1660:      }
        -: 1661:   }
        3: 1662:   s->img_buffer += n;
        3: 1662-block 10
        -: 1663:}
        -: 1664:#endif
        -: 1665:
        -: 1666:#if defined(STBI_NO_PNG) && defined(STBI_NO_TGA) && defined(STBI_NO_HDR) && defined(STBI_NO_PNM)
        -: 1667:// nothing
        -: 1668:#else
function _ZL10stbi__getnP13stbi__contextPhi called 1 returned 100% blocks executed 62%
        1: 1669:static int stbi__getn(stbi__context *s, stbi_uc *buffer, int n)
        -: 1670:{
        1: 1671:   if (s->io.read) {
        1: 1671-block 2
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 1672:      int blen = (int) (s->img_buffer_end - s->img_buffer);
        1: 1673:      if (blen < n) {
        1: 1673-block 3
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 1674:         int res, count;
        -: 1675:
        1: 1676:         memcpy(buffer, s->img_buffer, blen);
        -: 1677:
        1: 1678:         count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);
        1: 1678-block 4
call    0 returned 1
        1: 1679:         res = (count == (n-blen));
        1: 1680:         s->img_buffer = s->img_buffer_end;
        1: 1681:         return res;
        -: 1682:      }
        -: 1683:   }
        -: 1684:
    #####: 1685:   if (s->img_buffer+n <= s->img_buffer_end) {
    %%%%%: 1685-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1686:      memcpy(buffer, s->img_buffer, n);
    #####: 1687:      s->img_buffer += n;
    #####: 1688:      return 1;
    %%%%%: 1688-block 7
        -: 1689:   } else
    #####: 1690:      return 0;
    %%%%%: 1690-block 8
        -: 1691:}
        -: 1692:#endif
        -: 1693:
        -: 1694:#if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
        -: 1695:// nothing
        -: 1696:#else
function _ZL13stbi__get16beP13stbi__context called 46 returned 100% blocks executed 100%
       46: 1697:static int stbi__get16be(stbi__context *s)
        -: 1698:{
       46: 1699:   int z = stbi__get8(s);
       46: 1699-block 2
call    0 returned 46
       46: 1700:   return (z << 8) + stbi__get8(s);
call    0 returned 46
        -: 1701:}
        -: 1702:#endif
        -: 1703:
        -: 1704:#if defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
        -: 1705:// nothing
        -: 1706:#else
function _ZL13stbi__get32beP13stbi__context called 23 returned 100% blocks executed 100%
       23: 1707:static stbi__uint32 stbi__get32be(stbi__context *s)
        -: 1708:{
       23: 1709:   stbi__uint32 z = stbi__get16be(s);
       23: 1709-block 2
call    0 returned 23
       23: 1710:   return (z << 16) + stbi__get16be(s);
call    0 returned 23
        -: 1711:}
        -: 1712:#endif
        -: 1713:
        -: 1714:#if defined(STBI_NO_BMP) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF)
        -: 1715:// nothing
        -: 1716:#else
function _ZL13stbi__get16leP13stbi__context called 0 returned 0% blocks executed 0%
    #####: 1717:static int stbi__get16le(stbi__context *s)
        -: 1718:{
    #####: 1719:   int z = stbi__get8(s);
    %%%%%: 1719-block 2
call    0 never executed
    #####: 1720:   return z + (stbi__get8(s) << 8);
call    0 never executed
        -: 1721:}
        -: 1722:#endif
        -: 1723:
        -: 1724:#ifndef STBI_NO_BMP
function _ZL13stbi__get32leP13stbi__context called 0 returned 0% blocks executed 0%
    #####: 1725:static stbi__uint32 stbi__get32le(stbi__context *s)
        -: 1726:{
    #####: 1727:   stbi__uint32 z = stbi__get16le(s);
    %%%%%: 1727-block 2
call    0 never executed
    #####: 1728:   z += (stbi__uint32)stbi__get16le(s) << 16;
call    0 never executed
    #####: 1729:   return z;
        -: 1730:}
        -: 1731:#endif
        -: 1732:
        -: 1733:#define STBI__BYTECAST(x)  ((stbi_uc) ((x) & 255))  // truncate int to byte without warnings
        -: 1734:
        -: 1735:#if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
        -: 1736:// nothing
        -: 1737:#else
        -: 1738://////////////////////////////////////////////////////////////////////////////
        -: 1739://
        -: 1740://  generic converter from built-in img_n to req_comp
        -: 1741://    individual types do this automatically as much as possible (e.g. jpeg
        -: 1742://    does all cases internally since it needs to colorspace convert anyway,
        -: 1743://    and it never has alpha, so very few cases ). png can automatically
        -: 1744://    interleave an alpha=255 channel, but falls back to this for other cases
        -: 1745://
        -: 1746://  assume data buffer is malloced, so malloc a new one and free that one
        -: 1747://  only failure mode is malloc failing
        -: 1748:
function _ZL15stbi__compute_yiii called 0 returned 0% blocks executed 0%
    #####: 1749:static stbi_uc stbi__compute_y(int r, int g, int b)
        -: 1750:{
    #####: 1751:   return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);
    %%%%%: 1751-block 2
        -: 1752:}
        -: 1753:#endif
        -: 1754:
        -: 1755:#if defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
        -: 1756:// nothing
        -: 1757:#else
function _ZL20stbi__convert_formatPhiijj called 0 returned 0% blocks executed 0%
    #####: 1758:static unsigned char *stbi__convert_format(unsigned char *data, int img_n, int req_comp, unsigned int x, unsigned int y)
        -: 1759:{
        -: 1760:   int i,j;
        -: 1761:   unsigned char *good;
        -: 1762:
    #####: 1763:   if (req_comp == img_n) return data;
    %%%%%: 1763-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1763-block 3
    #####: 1764:   STBI_ASSERT(req_comp >= 1 && req_comp <= 4);
    %%%%%: 1764-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1764-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1764-block 6
    %%%%%: 1764-block 7
call    4 never executed
        -: 1765:
    #####: 1766:   good = (unsigned char *) stbi__malloc_mad3(req_comp, x, y, 0);
    %%%%%: 1766-block 8
call    0 never executed
    #####: 1767:   if (good == NULL) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1768:      STBI_FREE(data);
    #####: 1769:      return stbi__errpuc("outofmem", "Out of memory");
    %%%%%: 1769-block 10
call    0 never executed
        -: 1770:   }
        -: 1771:
    #####: 1772:   for (j=0; j < (int) y; ++j) {
    %%%%%: 1772-block 12
    %%%%%: 1772-block 67
    %%%%%: 1772-block 68
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 1773:      unsigned char *src  = data + j * x * img_n   ;
    #####: 1774:      unsigned char *dest = good + j * x * req_comp;
        -: 1775:
        -: 1776:      #define STBI__COMBO(a,b)  ((a)*8+(b))
        -: 1777:      #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
        -: 1778:      // convert source image with img_n components to one with req_comp components;
        -: 1779:      // avoid switch per pixel, so use switch per scanline and massive macros
    #####: 1780:      switch (STBI__COMBO(img_n, req_comp)) {
    %%%%%: 1780-block 13
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
    #####: 1781:         STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=255;                                     } break;
    %%%%%: 1781-block 14
    %%%%%: 1781-block 15
    %%%%%: 1781-block 16
branch  0 never executed
branch  1 never executed (fallthrough)
    %%%%%: 1781-block 17
    #####: 1782:         STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
    %%%%%: 1782-block 18
    %%%%%: 1782-block 19
    %%%%%: 1782-block 20
branch  0 never executed
branch  1 never executed (fallthrough)
    %%%%%: 1782-block 21
    #####: 1783:         STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=255;                     } break;
    %%%%%: 1783-block 22
    %%%%%: 1783-block 23
    %%%%%: 1783-block 24
branch  0 never executed
branch  1 never executed (fallthrough)
    %%%%%: 1783-block 25
    #####: 1784:         STBI__CASE(2,1) { dest[0]=src[0];                                                  } break;
    %%%%%: 1784-block 26
    %%%%%: 1784-block 27
    %%%%%: 1784-block 28
branch  0 never executed
branch  1 never executed (fallthrough)
    %%%%%: 1784-block 29
    #####: 1785:         STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
    %%%%%: 1785-block 30
    %%%%%: 1785-block 31
    %%%%%: 1785-block 32
branch  0 never executed
branch  1 never executed (fallthrough)
    %%%%%: 1785-block 33
    #####: 1786:         STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                  } break;
    %%%%%: 1786-block 34
    %%%%%: 1786-block 35
    %%%%%: 1786-block 36
branch  0 never executed
branch  1 never executed (fallthrough)
    %%%%%: 1786-block 37
    #####: 1787:         STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=255;        } break;
    %%%%%: 1787-block 38
    %%%%%: 1787-block 39
    %%%%%: 1787-block 40
branch  0 never executed
branch  1 never executed (fallthrough)
    %%%%%: 1787-block 41
    #####: 1788:         STBI__CASE(3,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
    %%%%%: 1788-block 42
    %%%%%: 1788-block 43
call    0 never executed
    %%%%%: 1788-block 45
branch  1 never executed
branch  2 never executed (fallthrough)
    %%%%%: 1788-block 46
    #####: 1789:         STBI__CASE(3,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = 255;    } break;
    %%%%%: 1789-block 47
    %%%%%: 1789-block 48
call    0 never executed
    %%%%%: 1789-block 50
branch  1 never executed
branch  2 never executed (fallthrough)
    %%%%%: 1789-block 51
    #####: 1790:         STBI__CASE(4,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
    %%%%%: 1790-block 52
    %%%%%: 1790-block 53
call    0 never executed
    %%%%%: 1790-block 55
branch  1 never executed
branch  2 never executed (fallthrough)
    %%%%%: 1790-block 56
    #####: 1791:         STBI__CASE(4,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = src[3]; } break;
    %%%%%: 1791-block 57
    %%%%%: 1791-block 58
call    0 never executed
    %%%%%: 1791-block 60
branch  1 never executed
branch  2 never executed (fallthrough)
    %%%%%: 1791-block 61
    #####: 1792:         STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                    } break;
    %%%%%: 1792-block 62
    %%%%%: 1792-block 63
    %%%%%: 1792-block 64
branch  0 never executed
branch  1 never executed (fallthrough)
    %%%%%: 1792-block 65
    #####: 1793:         default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return stbi__errpuc("unsupported", "Unsupported format conversion");
    %%%%%: 1793-block 66
call    0 never executed
        -: 1794:      }
        -: 1795:      #undef STBI__CASE
        -: 1796:   }
        -: 1797:
    #####: 1798:   STBI_FREE(data);
    #####: 1799:   return good;
    %%%%%: 1799-block 69
        -: 1800:}
        -: 1801:#endif
        -: 1802:
        -: 1803:#if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
        -: 1804:// nothing
        -: 1805:#else
function _ZL18stbi__compute_y_16iii called 0 returned 0% blocks executed 0%
    #####: 1806:static stbi__uint16 stbi__compute_y_16(int r, int g, int b)
        -: 1807:{
    #####: 1808:   return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);
    %%%%%: 1808-block 2
        -: 1809:}
        -: 1810:#endif
        -: 1811:
        -: 1812:#if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
        -: 1813:// nothing
        -: 1814:#else
function _ZL22stbi__convert_format16Ptiijj called 0 returned 0% blocks executed 0%
    #####: 1815:static stbi__uint16 *stbi__convert_format16(stbi__uint16 *data, int img_n, int req_comp, unsigned int x, unsigned int y)
        -: 1816:{
        -: 1817:   int i,j;
        -: 1818:   stbi__uint16 *good;
        -: 1819:
    #####: 1820:   if (req_comp == img_n) return data;
    %%%%%: 1820-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1820-block 3
    #####: 1821:   STBI_ASSERT(req_comp >= 1 && req_comp <= 4);
    %%%%%: 1821-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1821-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1821-block 6
    %%%%%: 1821-block 7
call    4 never executed
        -: 1822:
    #####: 1823:   good = (stbi__uint16 *) stbi__malloc(req_comp * x * y * 2);
    %%%%%: 1823-block 8
call    0 never executed
    #####: 1824:   if (good == NULL) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1825:      STBI_FREE(data);
    #####: 1826:      return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");
    %%%%%: 1826-block 10
call    0 never executed
        -: 1827:   }
        -: 1828:
    #####: 1829:   for (j=0; j < (int) y; ++j) {
    %%%%%: 1829-block 12
    %%%%%: 1829-block 67
    %%%%%: 1829-block 68
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 1830:      stbi__uint16 *src  = data + j * x * img_n   ;
    #####: 1831:      stbi__uint16 *dest = good + j * x * req_comp;
        -: 1832:
        -: 1833:      #define STBI__COMBO(a,b)  ((a)*8+(b))
        -: 1834:      #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
        -: 1835:      // convert source image with img_n components to one with req_comp components;
        -: 1836:      // avoid switch per pixel, so use switch per scanline and massive macros
    #####: 1837:      switch (STBI__COMBO(img_n, req_comp)) {
    %%%%%: 1837-block 13
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
    #####: 1838:         STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=0xffff;                                     } break;
    %%%%%: 1838-block 14
    %%%%%: 1838-block 15
    %%%%%: 1838-block 16
branch  0 never executed
branch  1 never executed (fallthrough)
    %%%%%: 1838-block 17
    #####: 1839:         STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
    %%%%%: 1839-block 18
    %%%%%: 1839-block 19
    %%%%%: 1839-block 20
branch  0 never executed
branch  1 never executed (fallthrough)
    %%%%%: 1839-block 21
    #####: 1840:         STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=0xffff;                     } break;
    %%%%%: 1840-block 22
    %%%%%: 1840-block 23
    %%%%%: 1840-block 24
branch  0 never executed
branch  1 never executed (fallthrough)
    %%%%%: 1840-block 25
    #####: 1841:         STBI__CASE(2,1) { dest[0]=src[0];                                                     } break;
    %%%%%: 1841-block 26
    %%%%%: 1841-block 27
    %%%%%: 1841-block 28
branch  0 never executed
branch  1 never executed (fallthrough)
    %%%%%: 1841-block 29
    #####: 1842:         STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
    %%%%%: 1842-block 30
    %%%%%: 1842-block 31
    %%%%%: 1842-block 32
branch  0 never executed
branch  1 never executed (fallthrough)
    %%%%%: 1842-block 33
    #####: 1843:         STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                     } break;
    %%%%%: 1843-block 34
    %%%%%: 1843-block 35
    %%%%%: 1843-block 36
branch  0 never executed
branch  1 never executed (fallthrough)
    %%%%%: 1843-block 37
    #####: 1844:         STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=0xffff;        } break;
    %%%%%: 1844-block 38
    %%%%%: 1844-block 39
    %%%%%: 1844-block 40
branch  0 never executed
branch  1 never executed (fallthrough)
    %%%%%: 1844-block 41
    #####: 1845:         STBI__CASE(3,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
    %%%%%: 1845-block 42
    %%%%%: 1845-block 43
call    0 never executed
    %%%%%: 1845-block 45
branch  1 never executed
branch  2 never executed (fallthrough)
    %%%%%: 1845-block 46
    #####: 1846:         STBI__CASE(3,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = 0xffff; } break;
    %%%%%: 1846-block 47
    %%%%%: 1846-block 48
call    0 never executed
    %%%%%: 1846-block 50
branch  1 never executed
branch  2 never executed (fallthrough)
    %%%%%: 1846-block 51
    #####: 1847:         STBI__CASE(4,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
    %%%%%: 1847-block 52
    %%%%%: 1847-block 53
call    0 never executed
    %%%%%: 1847-block 55
branch  1 never executed
branch  2 never executed (fallthrough)
    %%%%%: 1847-block 56
    #####: 1848:         STBI__CASE(4,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = src[3]; } break;
    %%%%%: 1848-block 57
    %%%%%: 1848-block 58
call    0 never executed
    %%%%%: 1848-block 60
branch  1 never executed
branch  2 never executed (fallthrough)
    %%%%%: 1848-block 61
    #####: 1849:         STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                       } break;
    %%%%%: 1849-block 62
    %%%%%: 1849-block 63
    %%%%%: 1849-block 64
branch  0 never executed
branch  1 never executed (fallthrough)
    %%%%%: 1849-block 65
    #####: 1850:         default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return (stbi__uint16*) stbi__errpuc("unsupported", "Unsupported format conversion");
    %%%%%: 1850-block 66
call    0 never executed
        -: 1851:      }
        -: 1852:      #undef STBI__CASE
        -: 1853:   }
        -: 1854:
    #####: 1855:   STBI_FREE(data);
    #####: 1856:   return good;
    %%%%%: 1856-block 69
        -: 1857:}
        -: 1858:#endif
        -: 1859:
        -: 1860:#ifndef STBI_NO_LINEAR
function _ZL16stbi__ldr_to_hdrPhiii called 0 returned 0% blocks executed 0%
    #####: 1861:static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp)
        -: 1862:{
        -: 1863:   int i,k,n;
        -: 1864:   float *output;
    #####: 1865:   if (!data) return NULL;
    %%%%%: 1865-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1865-block 3
    #####: 1866:   output = (float *) stbi__malloc_mad4(x, y, comp, sizeof(float), 0);
    %%%%%: 1866-block 4
call    0 never executed
    #####: 1867:   if (output == NULL) { STBI_FREE(data); return stbi__errpf("outofmem", "Out of memory"); }
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1867-block 6
call    2 never executed
        -: 1868:   // compute number of non-alpha components
    #####: 1869:   if (comp & 1) n = comp; else n = comp-1;
    %%%%%: 1869-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1869-block 9
    %%%%%: 1869-block 10
    #####: 1870:   for (i=0; i < x*y; ++i) {
    %%%%%: 1870-block 11
    %%%%%: 1870-block 16
    %%%%%: 1870-block 17
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 1871:      for (k=0; k < n; ++k) {
    %%%%%: 1871-block 12
    %%%%%: 1871-block 15
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 1872:         output[i*comp + k] = (float) (pow(data[i*comp+k]/255.0f, stbi__l2h_gamma) * stbi__l2h_scale);
    %%%%%: 1872-block 13
call    0 never executed
        -: 1873:      }
        -: 1874:   }
    #####: 1875:   if (n < comp) {
    %%%%%: 1875-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1876:      for (i=0; i < x*y; ++i) {
    %%%%%: 1876-block 19
    %%%%%: 1876-block 21
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 1877:         output[i*comp + n] = data[i*comp + n]/255.0f;
    %%%%%: 1877-block 20
        -: 1878:      }
        -: 1879:   }
    #####: 1880:   STBI_FREE(data);
    #####: 1881:   return output;
    %%%%%: 1881-block 22
        -: 1882:}
        -: 1883:#endif
        -: 1884:
        -: 1885:#ifndef STBI_NO_HDR
        -: 1886:#define stbi__float2int(x)   ((int) (x))
function _ZL16stbi__hdr_to_ldrPfiii called 0 returned 0% blocks executed 0%
    #####: 1887:static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp)
        -: 1888:{
        -: 1889:   int i,k,n;
        -: 1890:   stbi_uc *output;
    #####: 1891:   if (!data) return NULL;
    %%%%%: 1891-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1891-block 3
    #####: 1892:   output = (stbi_uc *) stbi__malloc_mad3(x, y, comp, 0);
    %%%%%: 1892-block 4
call    0 never executed
    #####: 1893:   if (output == NULL) { STBI_FREE(data); return stbi__errpuc("outofmem", "Out of memory"); }
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1893-block 6
call    2 never executed
        -: 1894:   // compute number of non-alpha components
    #####: 1895:   if (comp & 1) n = comp; else n = comp-1;
    %%%%%: 1895-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1895-block 9
    %%%%%: 1895-block 10
    #####: 1896:   for (i=0; i < x*y; ++i) {
    %%%%%: 1896-block 11
    %%%%%: 1896-block 26
    %%%%%: 1896-block 27
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 1897:      for (k=0; k < n; ++k) {
    %%%%%: 1897-block 12
    %%%%%: 1897-block 19
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 1898:         float z = (float) pow(data[i*comp+k]*stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;
    %%%%%: 1898-block 13
call    0 never executed
    #####: 1899:         if (z < 0) z = 0;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1899-block 15
    #####: 1900:         if (z > 255) z = 255;
    %%%%%: 1900-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1900-block 17
    #####: 1901:         output[i*comp + k] = (stbi_uc) stbi__float2int(z);
    %%%%%: 1901-block 18
        -: 1902:      }
    #####: 1903:      if (k < comp) {
    %%%%%: 1903-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1904:         float z = data[i*comp+k] * 255 + 0.5f;
    #####: 1905:         if (z < 0) z = 0;
    %%%%%: 1905-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1905-block 22
    #####: 1906:         if (z > 255) z = 255;
    %%%%%: 1906-block 23
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1906-block 24
    #####: 1907:         output[i*comp + k] = (stbi_uc) stbi__float2int(z);
    %%%%%: 1907-block 25
        -: 1908:      }
        -: 1909:   }
    #####: 1910:   STBI_FREE(data);
    #####: 1911:   return output;
    %%%%%: 1911-block 28
        -: 1912:}
        -: 1913:#endif
        -: 1914:
        -: 1915://////////////////////////////////////////////////////////////////////////////
        -: 1916://
        -: 1917://  "baseline" JPEG/JFIF decoder
        -: 1918://
        -: 1919://    simple implementation
        -: 1920://      - doesn't support delayed output of y-dimension
        -: 1921://      - simple interface (only one output format: 8-bit interleaved RGB)
        -: 1922://      - doesn't try to recover corrupt jpegs
        -: 1923://      - doesn't allow partial loading, loading multiple at once
        -: 1924://      - still fast on x86 (copying globals into locals doesn't help x86)
        -: 1925://      - allocates lots of intermediate memory (full size of all components)
        -: 1926://        - non-interleaved case requires this anyway
        -: 1927://        - allows good upsampling (see next)
        -: 1928://    high-quality
        -: 1929://      - upsampled channels are bilinearly interpolated, even across blocks
        -: 1930://      - quality integer IDCT derived from IJG's 'slow'
        -: 1931://    performance
        -: 1932://      - fast huffman; reasonable integer IDCT
        -: 1933://      - some SIMD kernels for common paths on targets with SSE2/NEON
        -: 1934://      - uses a lot of intermediate memory, could cache poorly
        -: 1935:
        -: 1936:#ifndef STBI_NO_JPEG
        -: 1937:
        -: 1938:// huffman decoding acceleration
        -: 1939:#define FAST_BITS   9  // larger handles more cases; smaller stomps less cache
        -: 1940:
        -: 1941:typedef struct
        -: 1942:{
        -: 1943:   stbi_uc  fast[1 << FAST_BITS];
        -: 1944:   // weirdly, repacking this into AoS is a 10% speed loss, instead of a win
        -: 1945:   stbi__uint16 code[256];
        -: 1946:   stbi_uc  values[256];
        -: 1947:   stbi_uc  size[257];
        -: 1948:   unsigned int maxcode[18];
        -: 1949:   int    delta[17];   // old 'firstsymbol' - old 'firstcode'
        -: 1950:} stbi__huffman;
        -: 1951:
        -: 1952:typedef struct
        -: 1953:{
        -: 1954:   stbi__context *s;
        -: 1955:   stbi__huffman huff_dc[4];
        -: 1956:   stbi__huffman huff_ac[4];
        -: 1957:   stbi__uint16 dequant[4][64];
        -: 1958:   stbi__int16 fast_ac[4][1 << FAST_BITS];
        -: 1959:
        -: 1960:// sizes for components, interleaved MCUs
        -: 1961:   int img_h_max, img_v_max;
        -: 1962:   int img_mcu_x, img_mcu_y;
        -: 1963:   int img_mcu_w, img_mcu_h;
        -: 1964:
        -: 1965:// definition of jpeg image component
        -: 1966:   struct
        -: 1967:   {
        -: 1968:      int id;
        -: 1969:      int h,v;
        -: 1970:      int tq;
        -: 1971:      int hd,ha;
        -: 1972:      int dc_pred;
        -: 1973:
        -: 1974:      int x,y,w2,h2;
        -: 1975:      stbi_uc *data;
        -: 1976:      void *raw_data, *raw_coeff;
        -: 1977:      stbi_uc *linebuf;
        -: 1978:      short   *coeff;   // progressive only
        -: 1979:      int      coeff_w, coeff_h; // number of 8x8 coefficient blocks
        -: 1980:   } img_comp[4];
        -: 1981:
        -: 1982:   stbi__uint32   code_buffer; // jpeg entropy-coded buffer
        -: 1983:   int            code_bits;   // number of valid bits
        -: 1984:   unsigned char  marker;      // marker seen while filling entropy buffer
        -: 1985:   int            nomore;      // flag if we saw a marker so must stop
        -: 1986:
        -: 1987:   int            progressive;
        -: 1988:   int            spec_start;
        -: 1989:   int            spec_end;
        -: 1990:   int            succ_high;
        -: 1991:   int            succ_low;
        -: 1992:   int            eob_run;
        -: 1993:   int            jfif;
        -: 1994:   int            app14_color_transform; // Adobe APP14 tag
        -: 1995:   int            rgb;
        -: 1996:
        -: 1997:   int scan_n, order[4];
        -: 1998:   int restart_interval, todo;
        -: 1999:
        -: 2000:// kernels
        -: 2001:   void (*idct_block_kernel)(stbi_uc *out, int out_stride, short data[64]);
        -: 2002:   void (*YCbCr_to_RGB_kernel)(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step);
        -: 2003:   stbi_uc *(*resample_row_hv_2_kernel)(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs);
        -: 2004:} stbi__jpeg;
        -: 2005:
function _ZL19stbi__build_huffmanP13stbi__huffmanPi called 0 returned 0% blocks executed 0%
    #####: 2006:static int stbi__build_huffman(stbi__huffman *h, int *count)
        -: 2007:{
    #####: 2008:   int i,j,k=0;
        -: 2009:   unsigned int code;
        -: 2010:   // build size list for each symbol (from JPEG spec)
    #####: 2011:   for (i=0; i < 16; ++i) {
    %%%%%: 2011-block 2
    %%%%%: 2011-block 8
    %%%%%: 2011-block 9
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2012:      for (j=0; j < count[i]; ++j) {
    %%%%%: 2012-block 3
    %%%%%: 2012-block 6
    %%%%%: 2012-block 7
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2013:         h->size[k++] = (stbi_uc) (i+1);
    #####: 2014:         if(k >= 257) return stbi__err("bad size list","Corrupt JPEG");
    %%%%%: 2014-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2014-block 5
call    2 never executed
        -: 2015:      }
        -: 2016:   }
    #####: 2017:   h->size[k] = 0;
        -: 2018:
        -: 2019:   // compute actual symbols (from jpeg spec)
    #####: 2020:   code = 0;
    #####: 2021:   k = 0;
    #####: 2022:   for(j=1; j <= 16; ++j) {
    %%%%%: 2022-block 10
    %%%%%: 2022-block 18
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 2023:      // compute delta to add to code to compute symbol id
    #####: 2024:      h->delta[j] = k - code;
    #####: 2025:      if (h->size[k] == j) {
    %%%%%: 2025-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2026:         while (h->size[k] == j)
    %%%%%: 2026-block 12
    %%%%%: 2026-block 14
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2027:            h->code[k++] = (stbi__uint16) (code++);
    %%%%%: 2027-block 13
    #####: 2028:         if (code-1 >= (1u << j)) return stbi__err("bad code lengths","Corrupt JPEG");
    %%%%%: 2028-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2028-block 16
call    2 never executed
        -: 2029:      }
        -: 2030:      // compute largest code + 1 for this size, preshifted as needed later
    #####: 2031:      h->maxcode[j] = code << (16-j);
    #####: 2032:      code <<= 1;
    %%%%%: 2032-block 17
        -: 2033:   }
    #####: 2034:   h->maxcode[j] = 0xffffffff;
        -: 2035:
        -: 2036:   // build non-spec acceleration table; 255 is flag for not-accelerated
    #####: 2037:   memset(h->fast, 255, 1 << FAST_BITS);
    #####: 2038:   for (i=0; i < k; ++i) {
    %%%%%: 2038-block 19
    %%%%%: 2038-block 24
    %%%%%: 2038-block 25
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2039:      int s = h->size[i];
    #####: 2040:      if (s <= FAST_BITS) {
    %%%%%: 2040-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2041:         int c = h->code[i] << (FAST_BITS-s);
    #####: 2042:         int m = 1 << (FAST_BITS-s);
    #####: 2043:         for (j=0; j < m; ++j) {
    %%%%%: 2043-block 21
    %%%%%: 2043-block 23
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2044:            h->fast[c+j] = (stbi_uc) i;
    %%%%%: 2044-block 22
        -: 2045:         }
        -: 2046:      }
        -: 2047:   }
    #####: 2048:   return 1;
    %%%%%: 2048-block 26
        -: 2049:}
        -: 2050:
        -: 2051:// build a table that decodes both magnitude and value of small ACs in
        -: 2052:// one go.
function _ZL19stbi__build_fast_acPsP13stbi__huffman called 0 returned 0% blocks executed 0%
    #####: 2053:static void stbi__build_fast_ac(stbi__int16 *fast_ac, stbi__huffman *h)
        -: 2054:{
        -: 2055:   int i;
    #####: 2056:   for (i=0; i < (1 << FAST_BITS); ++i) {
    %%%%%: 2056-block 2
    %%%%%: 2056-block 11
    %%%%%: 2056-block 12
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2057:      stbi_uc fast = h->fast[i];
    #####: 2058:      fast_ac[i] = 0;
    #####: 2059:      if (fast < 255) {
    %%%%%: 2059-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2060:         int rs = h->values[fast];
    #####: 2061:         int run = (rs >> 4) & 15;
    #####: 2062:         int magbits = rs & 15;
    #####: 2063:         int len = h->size[fast];
        -: 2064:
    #####: 2065:         if (magbits && len + magbits <= FAST_BITS) {
    %%%%%: 2065-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2065-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 2066:            // magnitude code followed by receive_extend code
    #####: 2067:            int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);
    #####: 2068:            int m = 1 << (magbits - 1);
    #####: 2069:            if (k < m) k += (~0U << magbits) + 1;
    %%%%%: 2069-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2069-block 7
        -: 2070:            // if the result is small enough, we can fit it in fast_ac table
    #####: 2071:            if (k >= -128 && k <= 127)
    %%%%%: 2071-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2071-block 9
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2072:               fast_ac[i] = (stbi__int16) ((k * 256) + (run * 16) + (len + magbits));
    %%%%%: 2072-block 10
        -: 2073:         }
        -: 2074:      }
        -: 2075:   }
    #####: 2076:}
        -: 2077:
function _ZL24stbi__grow_buffer_unsafeP10stbi__jpeg called 0 returned 0% blocks executed 0%
    #####: 2078:static void stbi__grow_buffer_unsafe(stbi__jpeg *j)
        -: 2079:{
        -: 2080:   do {
    #####: 2081:      unsigned int b = j->nomore ? 0 : stbi__get8(j->s);
    %%%%%: 2081-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2081-block 3
call    2 never executed
    %%%%%: 2081-block 5
    #####: 2082:      if (b == 0xff) {
    %%%%%: 2082-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2083:         int c = stbi__get8(j->s);
    %%%%%: 2083-block 7
call    0 never executed
    #####: 2084:         while (c == 0xff) c = stbi__get8(j->s); // consume fill bytes
    %%%%%: 2084-block 9
call    0 never executed
    %%%%%: 2084-block 11
branch  1 never executed
branch  2 never executed (fallthrough)
    #####: 2085:         if (c != 0) {
    %%%%%: 2085-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2086:            j->marker = (unsigned char) c;
    #####: 2087:            j->nomore = 1;
    #####: 2088:            return;
    %%%%%: 2088-block 13
        -: 2089:         }
        -: 2090:      }
    #####: 2091:      j->code_buffer |= b << (24 - j->code_bits);
    #####: 2092:      j->code_bits += 8;
    #####: 2093:   } while (j->code_bits <= 24);
    %%%%%: 2093-block 14
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 2094:}
        -: 2095:
        -: 2096:// (1 << n) - 1
        -: 2097:static const stbi__uint32 stbi__bmask[17]={0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535};
        -: 2098:
        -: 2099:// decode a jpeg huffman value from the bitstream
function _ZL22stbi__jpeg_huff_decodeP10stbi__jpegP13stbi__huffman called 0 returned 0% blocks executed 0%
    #####: 2100:stbi_inline static int stbi__jpeg_huff_decode(stbi__jpeg *j, stbi__huffman *h)
        -: 2101:{
        -: 2102:   unsigned int temp;
        -: 2103:   int c,k;
        -: 2104:
    #####: 2105:   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
    %%%%%: 2105-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2105-block 3
call    2 never executed
        -: 2106:
        -: 2107:   // look at the top FAST_BITS and determine what symbol ID it is,
        -: 2108:   // if the code is <= FAST_BITS
    #####: 2109:   c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
    #####: 2110:   k = h->fast[c];
    #####: 2111:   if (k < 255) {
    %%%%%: 2111-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2112:      int s = h->size[k];
    #####: 2113:      if (s > j->code_bits)
    %%%%%: 2113-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2114:         return -1;
    %%%%%: 2114-block 6
    #####: 2115:      j->code_buffer <<= s;
    #####: 2116:      j->code_bits -= s;
    #####: 2117:      return h->values[k];
    %%%%%: 2117-block 7
        -: 2118:   }
        -: 2119:
        -: 2120:   // naive test is to shift the code_buffer down so k bits are
        -: 2121:   // valid, then test against maxcode. To speed this up, we've
        -: 2122:   // preshifted maxcode left so that it has (16-k) 0s at the
        -: 2123:   // end; in other words, regardless of the number of bits, it
        -: 2124:   // wants to be compared against something shifted to have 16;
        -: 2125:   // that way we don't need to shift inside the loop.
    #####: 2126:   temp = j->code_buffer >> 16;
    #####: 2127:   for (k=FAST_BITS+1 ; ; ++k)
    %%%%%: 2127-block 8
    %%%%%: 2127-block 11
    #####: 2128:      if (temp < h->maxcode[k])
    %%%%%: 2128-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2129:         break;
    %%%%%: 2129-block 10
    #####: 2130:   if (k == 17) {
    %%%%%: 2130-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2131:      // error! code not found
    #####: 2132:      j->code_bits -= 16;
    #####: 2133:      return -1;
    %%%%%: 2133-block 13
        -: 2134:   }
        -: 2135:
    #####: 2136:   if (k > j->code_bits)
    %%%%%: 2136-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2137:      return -1;
    %%%%%: 2137-block 15
        -: 2138:
        -: 2139:   // convert the huffman code to the symbol id
    #####: 2140:   c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];
    #####: 2141:   if(c < 0 || c >= 256) // symbol id out of bounds!
    %%%%%: 2141-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2141-block 17
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2142:       return -1;
    %%%%%: 2142-block 18
    #####: 2143:   STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);
    %%%%%: 2143-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2143-block 20
call    2 never executed
        -: 2144:
        -: 2145:   // convert the id to a symbol
    #####: 2146:   j->code_bits -= k;
    #####: 2147:   j->code_buffer <<= k;
    #####: 2148:   return h->values[c];
    %%%%%: 2148-block 21
        -: 2149:}
        -: 2150:
        -: 2151:// bias[n] = (-1<<n) + 1
        -: 2152:static const int stbi__jbias[16] = {0,-1,-3,-7,-15,-31,-63,-127,-255,-511,-1023,-2047,-4095,-8191,-16383,-32767};
        -: 2153:
        -: 2154:// combined JPEG 'receive' and JPEG 'extend', since baseline
        -: 2155:// always extends everything it receives.
function _ZL20stbi__extend_receiveP10stbi__jpegi called 0 returned 0% blocks executed 0%
    #####: 2156:stbi_inline static int stbi__extend_receive(stbi__jpeg *j, int n)
        -: 2157:{
        -: 2158:   unsigned int k;
        -: 2159:   int sgn;
    #####: 2160:   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
    %%%%%: 2160-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2160-block 3
call    2 never executed
    #####: 2161:   if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing
    %%%%%: 2161-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2161-block 5
        -: 2162:
    #####: 2163:   sgn = j->code_buffer >> 31; // sign bit always in MSB; 0 if MSB clear (positive), 1 if MSB set (negative)
    #####: 2164:   k = stbi_lrot(j->code_buffer, n);
    #####: 2165:   j->code_buffer = k & ~stbi__bmask[n];
    #####: 2166:   k &= stbi__bmask[n];
    #####: 2167:   j->code_bits -= n;
    #####: 2168:   return k + (stbi__jbias[n] & (sgn - 1));
    %%%%%: 2168-block 6
        -: 2169:}
        -: 2170:
        -: 2171:// get some unsigned bits
function _ZL19stbi__jpeg_get_bitsP10stbi__jpegi called 0 returned 0% blocks executed 0%
    #####: 2172:stbi_inline static int stbi__jpeg_get_bits(stbi__jpeg *j, int n)
        -: 2173:{
        -: 2174:   unsigned int k;
    #####: 2175:   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
    %%%%%: 2175-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2175-block 3
call    2 never executed
    #####: 2176:   if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing
    %%%%%: 2176-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2176-block 5
    #####: 2177:   k = stbi_lrot(j->code_buffer, n);
    #####: 2178:   j->code_buffer = k & ~stbi__bmask[n];
    #####: 2179:   k &= stbi__bmask[n];
    #####: 2180:   j->code_bits -= n;
    #####: 2181:   return k;
    %%%%%: 2181-block 6
        -: 2182:}
        -: 2183:
function _ZL18stbi__jpeg_get_bitP10stbi__jpeg called 0 returned 0% blocks executed 0%
    #####: 2184:stbi_inline static int stbi__jpeg_get_bit(stbi__jpeg *j)
        -: 2185:{
        -: 2186:   unsigned int k;
    #####: 2187:   if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);
    %%%%%: 2187-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2187-block 3
call    2 never executed
    #####: 2188:   if (j->code_bits < 1) return 0; // ran out of bits from stream, return 0s intead of continuing
    %%%%%: 2188-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2188-block 5
    #####: 2189:   k = j->code_buffer;
    #####: 2190:   j->code_buffer <<= 1;
    #####: 2191:   --j->code_bits;
    #####: 2192:   return k & 0x80000000;
    %%%%%: 2192-block 6
        -: 2193:}
        -: 2194:
        -: 2195:// given a value that's at position X in the zigzag stream,
        -: 2196:// where does it appear in the 8x8 matrix coded as row-major?
        -: 2197:static const stbi_uc stbi__jpeg_dezigzag[64+15] =
        -: 2198:{
        -: 2199:    0,  1,  8, 16,  9,  2,  3, 10,
        -: 2200:   17, 24, 32, 25, 18, 11,  4,  5,
        -: 2201:   12, 19, 26, 33, 40, 48, 41, 34,
        -: 2202:   27, 20, 13,  6,  7, 14, 21, 28,
        -: 2203:   35, 42, 49, 56, 57, 50, 43, 36,
        -: 2204:   29, 22, 15, 23, 30, 37, 44, 51,
        -: 2205:   58, 59, 52, 45, 38, 31, 39, 46,
        -: 2206:   53, 60, 61, 54, 47, 55, 62, 63,
        -: 2207:   // let corrupt input sample past end
        -: 2208:   63, 63, 63, 63, 63, 63, 63, 63,
        -: 2209:   63, 63, 63, 63, 63, 63, 63
        -: 2210:};
        -: 2211:
        -: 2212:// decode one 64-entry block--
function _ZL23stbi__jpeg_decode_blockP10stbi__jpegPsP13stbi__huffmanS3_S1_iPt called 0 returned 0% blocks executed 0%
    #####: 2213:static int stbi__jpeg_decode_block(stbi__jpeg *j, short data[64], stbi__huffman *hdc, stbi__huffman *hac, stbi__int16 *fac, int b, stbi__uint16 *dequant)
        -: 2214:{
        -: 2215:   int diff,dc,k;
        -: 2216:   int t;
        -: 2217:
    #####: 2218:   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
    %%%%%: 2218-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2218-block 3
call    2 never executed
    #####: 2219:   t = stbi__jpeg_huff_decode(j, hdc);
    %%%%%: 2219-block 4
call    0 never executed
    #####: 2220:   if (t < 0 || t > 15) return stbi__err("bad huffman code","Corrupt JPEG");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2220-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2220-block 7
call    4 never executed
        -: 2221:
        -: 2222:   // 0 all the ac values now so we can do it 32-bits at a time
    #####: 2223:   memset(data,0,64*sizeof(data[0]));
        -: 2224:
    #####: 2225:   diff = t ? stbi__extend_receive(j, t) : 0;
    %%%%%: 2225-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2225-block 9
call    2 never executed
    %%%%%: 2225-block 11
    #####: 2226:   if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err("bad delta","Corrupt JPEG");
    %%%%%: 2226-block 12
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 2226-block 14
call    3 never executed
    #####: 2227:   dc = j->img_comp[b].dc_pred + diff;
    #####: 2228:   j->img_comp[b].dc_pred = dc;
    #####: 2229:   if (!stbi__mul2shorts_valid(dc, dequant[0])) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
    %%%%%: 2229-block 15
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 2229-block 17
call    3 never executed
    #####: 2230:   data[0] = (short) (dc * dequant[0]);
        -: 2231:
        -: 2232:   // decode AC components, see JPEG spec
    #####: 2233:   k = 1;
    %%%%%: 2233-block 18
        -: 2234:   do {
        -: 2235:      unsigned int zig;
        -: 2236:      int c,r,s;
    #####: 2237:      if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
    %%%%%: 2237-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2237-block 20
call    2 never executed
    #####: 2238:      c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
    #####: 2239:      r = fac[c];
    #####: 2240:      if (r) { // fast-AC path
    %%%%%: 2240-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2241:         k += (r >> 4) & 15; // run
    #####: 2242:         s = r & 15; // combined length
    #####: 2243:         if (s > j->code_bits) return stbi__err("bad huffman code", "Combined length longer than code bits available");
    %%%%%: 2243-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2243-block 23
call    2 never executed
    #####: 2244:         j->code_buffer <<= s;
    #####: 2245:         j->code_bits -= s;
        -: 2246:         // decode into unzigzag'd location
    #####: 2247:         zig = stbi__jpeg_dezigzag[k++];
    #####: 2248:         data[zig] = (short) ((r >> 8) * dequant[zig]);
    %%%%%: 2248-block 24
        -: 2249:      } else {
    #####: 2250:         int rs = stbi__jpeg_huff_decode(j, hac);
    %%%%%: 2250-block 25
call    0 never executed
    #####: 2251:         if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2251-block 27
call    2 never executed
    #####: 2252:         s = rs & 15;
    #####: 2253:         r = rs >> 4;
    #####: 2254:         if (s == 0) {
    %%%%%: 2254-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2255:            if (rs != 0xf0) break; // end block
    %%%%%: 2255-block 29
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2255-block 30
    #####: 2256:            k += 16;
    %%%%%: 2256-block 31
        -: 2257:         } else {
    #####: 2258:            k += r;
        -: 2259:            // decode into unzigzag'd location
    #####: 2260:            zig = stbi__jpeg_dezigzag[k++];
    #####: 2261:            data[zig] = (short) (stbi__extend_receive(j,s) * dequant[zig]);
    %%%%%: 2261-block 32
call    0 never executed
        -: 2262:         }
        -: 2263:      }
    #####: 2264:   } while (k < 64);
    %%%%%: 2264-block 34
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2265:   return 1;
    %%%%%: 2265-block 35
        -: 2266:}
        -: 2267:
function _ZL31stbi__jpeg_decode_block_prog_dcP10stbi__jpegPsP13stbi__huffmani called 0 returned 0% blocks executed 0%
    #####: 2268:static int stbi__jpeg_decode_block_prog_dc(stbi__jpeg *j, short data[64], stbi__huffman *hdc, int b)
        -: 2269:{
        -: 2270:   int diff,dc;
        -: 2271:   int t;
    #####: 2272:   if (j->spec_end != 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
    %%%%%: 2272-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2272-block 3
call    2 never executed
        -: 2273:
    #####: 2274:   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
    %%%%%: 2274-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2274-block 5
call    2 never executed
        -: 2275:
    #####: 2276:   if (j->succ_high == 0) {
    %%%%%: 2276-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2277:      // first scan for DC coefficient, must be first
    #####: 2278:      memset(data,0,64*sizeof(data[0])); // 0 all the ac values now
    #####: 2279:      t = stbi__jpeg_huff_decode(j, hdc);
    %%%%%: 2279-block 7
call    0 never executed
    #####: 2280:      if (t < 0 || t > 15) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2280-block 9
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2280-block 10
call    4 never executed
    #####: 2281:      diff = t ? stbi__extend_receive(j, t) : 0;
    %%%%%: 2281-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2281-block 12
call    2 never executed
    %%%%%: 2281-block 14
        -: 2282:
    #####: 2283:      if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err("bad delta", "Corrupt JPEG");
    %%%%%: 2283-block 15
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 2283-block 17
call    3 never executed
    #####: 2284:      dc = j->img_comp[b].dc_pred + diff;
    #####: 2285:      j->img_comp[b].dc_pred = dc;
    #####: 2286:      if (!stbi__mul2shorts_valid(dc, 1 << j->succ_low)) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
    %%%%%: 2286-block 18
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 2286-block 20
call    3 never executed
    #####: 2287:      data[0] = (short) (dc * (1 << j->succ_low));
    %%%%%: 2287-block 21
        -: 2288:   } else {
        -: 2289:      // refinement scan for DC coefficient
    #####: 2290:      if (stbi__jpeg_get_bit(j))
    %%%%%: 2290-block 22
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 2291:         data[0] += (short) (1 << j->succ_low);
    %%%%%: 2291-block 24
        -: 2292:   }
    #####: 2293:   return 1;
    %%%%%: 2293-block 25
        -: 2294:}
        -: 2295:
        -: 2296:// @OPTIMIZE: store non-zigzagged during the decode passes,
        -: 2297:// and only de-zigzag when dequantizing
function _ZL31stbi__jpeg_decode_block_prog_acP10stbi__jpegPsP13stbi__huffmanS1_ called 0 returned 0% blocks executed 0%
    #####: 2298:static int stbi__jpeg_decode_block_prog_ac(stbi__jpeg *j, short data[64], stbi__huffman *hac, stbi__int16 *fac)
        -: 2299:{
        -: 2300:   int k;
    #####: 2301:   if (j->spec_start == 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
    %%%%%: 2301-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2301-block 3
call    2 never executed
        -: 2302:
    #####: 2303:   if (j->succ_high == 0) {
    %%%%%: 2303-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2304:      int shift = j->succ_low;
        -: 2305:
    #####: 2306:      if (j->eob_run) {
    %%%%%: 2306-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2307:         --j->eob_run;
    #####: 2308:         return 1;
    %%%%%: 2308-block 6
        -: 2309:      }
        -: 2310:
    #####: 2311:      k = j->spec_start;
    %%%%%: 2311-block 7
        -: 2312:      do {
        -: 2313:         unsigned int zig;
        -: 2314:         int c,r,s;
    #####: 2315:         if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
    %%%%%: 2315-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2315-block 9
call    2 never executed
    #####: 2316:         c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
    #####: 2317:         r = fac[c];
    #####: 2318:         if (r) { // fast-AC path
    %%%%%: 2318-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2319:            k += (r >> 4) & 15; // run
    #####: 2320:            s = r & 15; // combined length
    #####: 2321:            if (s > j->code_bits) return stbi__err("bad huffman code", "Combined length longer than code bits available");
    %%%%%: 2321-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2321-block 12
call    2 never executed
    #####: 2322:            j->code_buffer <<= s;
    #####: 2323:            j->code_bits -= s;
    #####: 2324:            zig = stbi__jpeg_dezigzag[k++];
    #####: 2325:            data[zig] = (short) ((r >> 8) * (1 << shift));
    %%%%%: 2325-block 13
        -: 2326:         } else {
    #####: 2327:            int rs = stbi__jpeg_huff_decode(j, hac);
    %%%%%: 2327-block 14
call    0 never executed
    #####: 2328:            if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2328-block 16
call    2 never executed
    #####: 2329:            s = rs & 15;
    #####: 2330:            r = rs >> 4;
    #####: 2331:            if (s == 0) {
    %%%%%: 2331-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2332:               if (r < 15) {
    %%%%%: 2332-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2333:                  j->eob_run = (1 << r);
    #####: 2334:                  if (r)
    %%%%%: 2334-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2335:                     j->eob_run += stbi__jpeg_get_bits(j, r);
    %%%%%: 2335-block 20
call    0 never executed
    #####: 2336:                  --j->eob_run;
    #####: 2337:                  break;
    %%%%%: 2337-block 22
        -: 2338:               }
    #####: 2339:               k += 16;
    %%%%%: 2339-block 23
        -: 2340:            } else {
    #####: 2341:               k += r;
    #####: 2342:               zig = stbi__jpeg_dezigzag[k++];
    #####: 2343:               data[zig] = (short) (stbi__extend_receive(j,s) * (1 << shift));
    %%%%%: 2343-block 24
call    0 never executed
        -: 2344:            }
        -: 2345:         }
    #####: 2346:      } while (k <= j->spec_end);
    %%%%%: 2346-block 26
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 2347:   } else {
        -: 2348:      // refinement scan for these AC coefficients
        -: 2349:
    #####: 2350:      short bit = (short) (1 << j->succ_low);
        -: 2351:
    #####: 2352:      if (j->eob_run) {
    %%%%%: 2352-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2353:         --j->eob_run;
    #####: 2354:         for (k = j->spec_start; k <= j->spec_end; ++k) {
    %%%%%: 2354-block 29
    %%%%%: 2354-block 37
    %%%%%: 2354-block 38
branch  0 never executed
branch  1 never executed
    #####: 2355:            short *p = &data[stbi__jpeg_dezigzag[k]];
    #####: 2356:            if (*p != 0)
    %%%%%: 2356-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2357:               if (stbi__jpeg_get_bit(j))
    %%%%%: 2357-block 31
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 2358:                  if ((*p & bit)==0) {
    %%%%%: 2358-block 33
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2359:                     if (*p > 0)
    %%%%%: 2359-block 34
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2360:                        *p += bit;
    %%%%%: 2360-block 35
        -: 2361:                     else
    #####: 2362:                        *p -= bit;
    %%%%%: 2362-block 36
        -: 2363:                  }
        -: 2364:         }
        -: 2365:      } else {
    #####: 2366:         k = j->spec_start;
    %%%%%: 2366-block 39
        -: 2367:         do {
        -: 2368:            int r,s;
    #####: 2369:            int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh
    %%%%%: 2369-block 40
call    0 never executed
    #####: 2370:            if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2370-block 42
call    2 never executed
    #####: 2371:            s = rs & 15;
    #####: 2372:            r = rs >> 4;
    #####: 2373:            if (s == 0) {
    %%%%%: 2373-block 43
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2374:               if (r < 15) {
    %%%%%: 2374-block 44
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2375:                  j->eob_run = (1 << r) - 1;
    #####: 2376:                  if (r)
    %%%%%: 2376-block 45
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2377:                     j->eob_run += stbi__jpeg_get_bits(j, r);
    %%%%%: 2377-block 46
call    0 never executed
    #####: 2378:                  r = 64; // force end of block
    %%%%%: 2378-block 48
        -: 2379:               } else {
        -: 2380:                  // r=15 s=0 should write 16 0s, so we just do
        -: 2381:                  // a run of 15 0s and then write s (which is 0),
        -: 2382:                  // so we don't have to do anything special here
        -: 2383:               }
        -: 2384:            } else {
    #####: 2385:               if (s != 1) return stbi__err("bad huffman code", "Corrupt JPEG");
    %%%%%: 2385-block 49
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2385-block 50
call    2 never executed
        -: 2386:               // sign bit
    #####: 2387:               if (stbi__jpeg_get_bit(j))
    %%%%%: 2387-block 51
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 2388:                  s = bit;
    %%%%%: 2388-block 53
        -: 2389:               else
    #####: 2390:                  s = -bit;
    %%%%%: 2390-block 54
        -: 2391:            }
        -: 2392:
        -: 2393:            // advance by r
    #####: 2394:            while (k <= j->spec_end) {
    %%%%%: 2394-block 55
    %%%%%: 2394-block 66
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2395:               short *p = &data[stbi__jpeg_dezigzag[k++]];
    #####: 2396:               if (*p != 0) {
    %%%%%: 2396-block 56
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2397:                  if (stbi__jpeg_get_bit(j))
    %%%%%: 2397-block 57
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 2398:                     if ((*p & bit)==0) {
    %%%%%: 2398-block 59
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2399:                        if (*p > 0)
    %%%%%: 2399-block 60
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2400:                           *p += bit;
    %%%%%: 2400-block 61
        -: 2401:                        else
    #####: 2402:                           *p -= bit;
    %%%%%: 2402-block 62
        -: 2403:                     }
        -: 2404:               } else {
    #####: 2405:                  if (r == 0) {
    %%%%%: 2405-block 63
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2406:                     *p = (short) s;
    #####: 2407:                     break;
    %%%%%: 2407-block 64
        -: 2408:                  }
    #####: 2409:                  --r;
    %%%%%: 2409-block 65
        -: 2410:               }
        -: 2411:            }
    #####: 2412:         } while (k <= j->spec_end);
    %%%%%: 2412-block 67
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 2413:      }
        -: 2414:   }
    #####: 2415:   return 1;
    %%%%%: 2415-block 68
        -: 2416:}
        -: 2417:
        -: 2418:// take a -128..127 value and stbi__clamp it and convert to 0..255
function _ZL11stbi__clampi called 0 returned 0% blocks executed 0%
    #####: 2419:stbi_inline static stbi_uc stbi__clamp(int x)
        -: 2420:{
        -: 2421:   // trick to use a single test to catch both cases
    #####: 2422:   if ((unsigned int) x > 255) {
    %%%%%: 2422-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2423:      if (x < 0) return 0;
    %%%%%: 2423-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2423-block 4
    #####: 2424:      if (x > 255) return 255;
    %%%%%: 2424-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2424-block 6
        -: 2425:   }
    #####: 2426:   return (stbi_uc) x;
    %%%%%: 2426-block 7
        -: 2427:}
        -: 2428:
        -: 2429:#define stbi__f2f(x)  ((int) (((x) * 4096 + 0.5)))
        -: 2430:#define stbi__fsh(x)  ((x) * 4096)
        -: 2431:
        -: 2432:// derived from jidctint -- DCT_ISLOW
        -: 2433:#define STBI__IDCT_1D(s0,s1,s2,s3,s4,s5,s6,s7) \
        -: 2434:   int t0,t1,t2,t3,p1,p2,p3,p4,p5,x0,x1,x2,x3; \
        -: 2435:   p2 = s2;                                    \
        -: 2436:   p3 = s6;                                    \
        -: 2437:   p1 = (p2+p3) * stbi__f2f(0.5411961f);       \
        -: 2438:   t2 = p1 + p3*stbi__f2f(-1.847759065f);      \
        -: 2439:   t3 = p1 + p2*stbi__f2f( 0.765366865f);      \
        -: 2440:   p2 = s0;                                    \
        -: 2441:   p3 = s4;                                    \
        -: 2442:   t0 = stbi__fsh(p2+p3);                      \
        -: 2443:   t1 = stbi__fsh(p2-p3);                      \
        -: 2444:   x0 = t0+t3;                                 \
        -: 2445:   x3 = t0-t3;                                 \
        -: 2446:   x1 = t1+t2;                                 \
        -: 2447:   x2 = t1-t2;                                 \
        -: 2448:   t0 = s7;                                    \
        -: 2449:   t1 = s5;                                    \
        -: 2450:   t2 = s3;                                    \
        -: 2451:   t3 = s1;                                    \
        -: 2452:   p3 = t0+t2;                                 \
        -: 2453:   p4 = t1+t3;                                 \
        -: 2454:   p1 = t0+t3;                                 \
        -: 2455:   p2 = t1+t2;                                 \
        -: 2456:   p5 = (p3+p4)*stbi__f2f( 1.175875602f);      \
        -: 2457:   t0 = t0*stbi__f2f( 0.298631336f);           \
        -: 2458:   t1 = t1*stbi__f2f( 2.053119869f);           \
        -: 2459:   t2 = t2*stbi__f2f( 3.072711026f);           \
        -: 2460:   t3 = t3*stbi__f2f( 1.501321110f);           \
        -: 2461:   p1 = p5 + p1*stbi__f2f(-0.899976223f);      \
        -: 2462:   p2 = p5 + p2*stbi__f2f(-2.562915447f);      \
        -: 2463:   p3 = p3*stbi__f2f(-1.961570560f);           \
        -: 2464:   p4 = p4*stbi__f2f(-0.390180644f);           \
        -: 2465:   t3 += p1+p4;                                \
        -: 2466:   t2 += p2+p3;                                \
        -: 2467:   t1 += p2+p4;                                \
        -: 2468:   t0 += p1+p3;
        -: 2469:
function _ZL16stbi__idct_blockPhiPs called 0 returned 0% blocks executed 0%
    #####: 2470:static void stbi__idct_block(stbi_uc *out, int out_stride, short data[64])
        -: 2471:{
    #####: 2472:   int i,val[64],*v=val;
        -: 2473:   stbi_uc *o;
    #####: 2474:   short *d = data;
        -: 2475:
        -: 2476:   // columns
    #####: 2477:   for (i=0; i < 8; ++i,++d, ++v) {
    %%%%%: 2477-block 2
    %%%%%: 2477-block 12
    %%%%%: 2477-block 13
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 2478:      // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
    #####: 2479:      if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0
    %%%%%: 2479-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2479-block 4
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2479-block 5
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 2479-block 6
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 2480:           && d[40]==0 && d[48]==0 && d[56]==0) {
    %%%%%: 2480-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2480-block 8
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2480-block 9
branch  4 never executed (fallthrough)
branch  5 never executed
        -: 2481:         //    no shortcut                 0     seconds
        -: 2482:         //    (1|2|3|4|5|6|7)==0          0     seconds
        -: 2483:         //    all separate               -0.047 seconds
        -: 2484:         //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
    #####: 2485:         int dcterm = d[0]*4;
    #####: 2486:         v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;
    #####: 2487:      } else {
    %%%%%: 2487-block 10
    #####: 2488:         STBI__IDCT_1D(d[ 0],d[ 8],d[16],d[24],d[32],d[40],d[48],d[56])
        -: 2489:         // constants scaled things up by 1<<12; let's bring them back
        -: 2490:         // down, but keep 2 extra bits of precision
    #####: 2491:         x0 += 512; x1 += 512; x2 += 512; x3 += 512;
    #####: 2492:         v[ 0] = (x0+t3) >> 10;
    #####: 2493:         v[56] = (x0-t3) >> 10;
    #####: 2494:         v[ 8] = (x1+t2) >> 10;
    #####: 2495:         v[48] = (x1-t2) >> 10;
    #####: 2496:         v[16] = (x2+t1) >> 10;
    #####: 2497:         v[40] = (x2-t1) >> 10;
    #####: 2498:         v[24] = (x3+t0) >> 10;
    #####: 2499:         v[32] = (x3-t0) >> 10;
    %%%%%: 2499-block 11
        -: 2500:      }
        -: 2501:   }
        -: 2502:
    #####: 2503:   for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {
    %%%%%: 2503-block 14
    %%%%%: 2503-block 24
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 2504:      // no fast case since the first 1D IDCT spread components out
    #####: 2505:      STBI__IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])
        -: 2506:      // constants scaled things up by 1<<12, plus we had 1<<2 from first
        -: 2507:      // loop, plus horizontal and vertical each scale by sqrt(8) so together
        -: 2508:      // we've got an extra 1<<3, so 1<<17 total we need to remove.
        -: 2509:      // so we want to round that, which means adding 0.5 * 1<<17,
        -: 2510:      // aka 65536. Also, we'll end up with -128 to 127 that we want
        -: 2511:      // to encode as 0..255 by adding 128, so we'll add that before the shift
    #####: 2512:      x0 += 65536 + (128<<17);
    #####: 2513:      x1 += 65536 + (128<<17);
    #####: 2514:      x2 += 65536 + (128<<17);
    #####: 2515:      x3 += 65536 + (128<<17);
        -: 2516:      // tried computing the shifts into temps, or'ing the temps to see
        -: 2517:      // if any were out of range, but that was slower
    #####: 2518:      o[0] = stbi__clamp((x0+t3) >> 17);
    %%%%%: 2518-block 15
call    0 never executed
    #####: 2519:      o[7] = stbi__clamp((x0-t3) >> 17);
call    0 never executed
    #####: 2520:      o[1] = stbi__clamp((x1+t2) >> 17);
call    0 never executed
    #####: 2521:      o[6] = stbi__clamp((x1-t2) >> 17);
call    0 never executed
    #####: 2522:      o[2] = stbi__clamp((x2+t1) >> 17);
call    0 never executed
    #####: 2523:      o[5] = stbi__clamp((x2-t1) >> 17);
call    0 never executed
    #####: 2524:      o[3] = stbi__clamp((x3+t0) >> 17);
call    0 never executed
    #####: 2525:      o[4] = stbi__clamp((x3-t0) >> 17);
call    0 never executed
        -: 2526:   }
    #####: 2527:}
        -: 2528:
        -: 2529:#ifdef STBI_SSE2
        -: 2530:// sse2 integer IDCT. not the fastest possible implementation but it
        -: 2531:// produces bit-identical results to the generic C version so it's
        -: 2532:// fully "transparent".
function _ZL15stbi__idct_simdPhiPs called 0 returned 0% blocks executed 0%
    #####: 2533:static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
    %%%%%: 2533-block 2
        -: 2534:{
        -: 2535:   // This is constructed to match our regular (generic) integer IDCT exactly.
        -: 2536:   __m128i row0, row1, row2, row3, row4, row5, row6, row7;
        -: 2537:   __m128i tmp;
        -: 2538:
        -: 2539:   // dot product constant: even elems=x, odd elems=y
        -: 2540:   #define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))
        -: 2541:
        -: 2542:   // out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)
        -: 2543:   // out(1) = c1[even]*x + c1[odd]*y
        -: 2544:   #define dct_rot(out0,out1, x,y,c0,c1) \
        -: 2545:      __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \
        -: 2546:      __m128i c0##hi = _mm_unpackhi_epi16((x),(y)); \
        -: 2547:      __m128i out0##_l = _mm_madd_epi16(c0##lo, c0); \
        -: 2548:      __m128i out0##_h = _mm_madd_epi16(c0##hi, c0); \
        -: 2549:      __m128i out1##_l = _mm_madd_epi16(c0##lo, c1); \
        -: 2550:      __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)
        -: 2551:
        -: 2552:   // out = in << 12  (in 16-bit, out 32-bit)
        -: 2553:   #define dct_widen(out, in) \
        -: 2554:      __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \
        -: 2555:      __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)
        -: 2556:
        -: 2557:   // wide add
        -: 2558:   #define dct_wadd(out, a, b) \
        -: 2559:      __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \
        -: 2560:      __m128i out##_h = _mm_add_epi32(a##_h, b##_h)
        -: 2561:
        -: 2562:   // wide sub
        -: 2563:   #define dct_wsub(out, a, b) \
        -: 2564:      __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \
        -: 2565:      __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)
        -: 2566:
        -: 2567:   // butterfly a/b, add bias, then shift by "s" and pack
        -: 2568:   #define dct_bfly32o(out0, out1, a,b,bias,s) \
        -: 2569:      { \
        -: 2570:         __m128i abiased_l = _mm_add_epi32(a##_l, bias); \
        -: 2571:         __m128i abiased_h = _mm_add_epi32(a##_h, bias); \
        -: 2572:         dct_wadd(sum, abiased, b); \
        -: 2573:         dct_wsub(dif, abiased, b); \
        -: 2574:         out0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, s), _mm_srai_epi32(sum_h, s)); \
        -: 2575:         out1 = _mm_packs_epi32(_mm_srai_epi32(dif_l, s), _mm_srai_epi32(dif_h, s)); \
        -: 2576:      }
        -: 2577:
        -: 2578:   // 8-bit interleave step (for transposes)
        -: 2579:   #define dct_interleave8(a, b) \
        -: 2580:      tmp = a; \
        -: 2581:      a = _mm_unpacklo_epi8(a, b); \
        -: 2582:      b = _mm_unpackhi_epi8(tmp, b)
        -: 2583:
        -: 2584:   // 16-bit interleave step (for transposes)
        -: 2585:   #define dct_interleave16(a, b) \
        -: 2586:      tmp = a; \
        -: 2587:      a = _mm_unpacklo_epi16(a, b); \
        -: 2588:      b = _mm_unpackhi_epi16(tmp, b)
        -: 2589:
        -: 2590:   #define dct_pass(bias,shift) \
        -: 2591:      { \
        -: 2592:         /* even part */ \
        -: 2593:         dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \
        -: 2594:         __m128i sum04 = _mm_add_epi16(row0, row4); \
        -: 2595:         __m128i dif04 = _mm_sub_epi16(row0, row4); \
        -: 2596:         dct_widen(t0e, sum04); \
        -: 2597:         dct_widen(t1e, dif04); \
        -: 2598:         dct_wadd(x0, t0e, t3e); \
        -: 2599:         dct_wsub(x3, t0e, t3e); \
        -: 2600:         dct_wadd(x1, t1e, t2e); \
        -: 2601:         dct_wsub(x2, t1e, t2e); \
        -: 2602:         /* odd part */ \
        -: 2603:         dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \
        -: 2604:         dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \
        -: 2605:         __m128i sum17 = _mm_add_epi16(row1, row7); \
        -: 2606:         __m128i sum35 = _mm_add_epi16(row3, row5); \
        -: 2607:         dct_rot(y4o,y5o, sum17,sum35, rot1_0,rot1_1); \
        -: 2608:         dct_wadd(x4, y0o, y4o); \
        -: 2609:         dct_wadd(x5, y1o, y5o); \
        -: 2610:         dct_wadd(x6, y2o, y5o); \
        -: 2611:         dct_wadd(x7, y3o, y4o); \
        -: 2612:         dct_bfly32o(row0,row7, x0,x7,bias,shift); \
        -: 2613:         dct_bfly32o(row1,row6, x1,x6,bias,shift); \
        -: 2614:         dct_bfly32o(row2,row5, x2,x5,bias,shift); \
        -: 2615:         dct_bfly32o(row3,row4, x3,x4,bias,shift); \
        -: 2616:      }
        -: 2617:
    #####: 2618:   __m128i rot0_0 = dct_const(stbi__f2f(0.5411961f), stbi__f2f(0.5411961f) + stbi__f2f(-1.847759065f));
    %%%%%: 2618-block 6
    #####: 2619:   __m128i rot0_1 = dct_const(stbi__f2f(0.5411961f) + stbi__f2f( 0.765366865f), stbi__f2f(0.5411961f));
    %%%%%: 2619-block 10
    #####: 2620:   __m128i rot1_0 = dct_const(stbi__f2f(1.175875602f) + stbi__f2f(-0.899976223f), stbi__f2f(1.175875602f));
    %%%%%: 2620-block 14
    #####: 2621:   __m128i rot1_1 = dct_const(stbi__f2f(1.175875602f), stbi__f2f(1.175875602f) + stbi__f2f(-2.562915447f));
    %%%%%: 2621-block 18
    #####: 2622:   __m128i rot2_0 = dct_const(stbi__f2f(-1.961570560f) + stbi__f2f( 0.298631336f), stbi__f2f(-1.961570560f));
    %%%%%: 2622-block 22
    #####: 2623:   __m128i rot2_1 = dct_const(stbi__f2f(-1.961570560f), stbi__f2f(-1.961570560f) + stbi__f2f( 3.072711026f));
    %%%%%: 2623-block 26
    #####: 2624:   __m128i rot3_0 = dct_const(stbi__f2f(-0.390180644f) + stbi__f2f( 2.053119869f), stbi__f2f(-0.390180644f));
    %%%%%: 2624-block 30
    #####: 2625:   __m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f( 1.501321110f));
    %%%%%: 2625-block 34
        -: 2626:
        -: 2627:   // rounding biases in column/row passes, see stbi__idct_block for explanation.
    #####: 2628:   __m128i bias_0 = _mm_set1_epi32(512);
    %%%%%: 2628-block 38
    #####: 2629:   __m128i bias_1 = _mm_set1_epi32(65536 + (128<<17));
    %%%%%: 2629-block 42
        -: 2630:
        -: 2631:   // load
    #####: 2632:   row0 = _mm_load_si128((const __m128i *) (data + 0*8));
    #####: 2633:   row1 = _mm_load_si128((const __m128i *) (data + 1*8));
    %%%%%: 2633-block 44
    #####: 2634:   row2 = _mm_load_si128((const __m128i *) (data + 2*8));
    %%%%%: 2634-block 46
    #####: 2635:   row3 = _mm_load_si128((const __m128i *) (data + 3*8));
    %%%%%: 2635-block 48
    #####: 2636:   row4 = _mm_load_si128((const __m128i *) (data + 4*8));
    %%%%%: 2636-block 50
    #####: 2637:   row5 = _mm_load_si128((const __m128i *) (data + 5*8));
    %%%%%: 2637-block 52
    #####: 2638:   row6 = _mm_load_si128((const __m128i *) (data + 6*8));
    %%%%%: 2638-block 54
    #####: 2639:   row7 = _mm_load_si128((const __m128i *) (data + 7*8));
    %%%%%: 2639-block 56
    %%%%%: 2639-block 58
        -: 2640:
        -: 2641:   // column pass
    #####: 2642:   dct_pass(bias_0, 10);
    %%%%%: 2642-block 60
    %%%%%: 2642-block 62
    %%%%%: 2642-block 64
    %%%%%: 2642-block 66
    %%%%%: 2642-block 68
    %%%%%: 2642-block 70
    %%%%%: 2642-block 72
    %%%%%: 2642-block 74
    %%%%%: 2642-block 76
    %%%%%: 2642-block 78
    %%%%%: 2642-block 80
    %%%%%: 2642-block 82
    %%%%%: 2642-block 84
    %%%%%: 2642-block 86
    %%%%%: 2642-block 88
    %%%%%: 2642-block 90
    %%%%%: 2642-block 92
    %%%%%: 2642-block 94
    %%%%%: 2642-block 96
    %%%%%: 2642-block 98
    %%%%%: 2642-block 100
    %%%%%: 2642-block 102
    %%%%%: 2642-block 104
    %%%%%: 2642-block 106
    %%%%%: 2642-block 108
    %%%%%: 2642-block 110
    %%%%%: 2642-block 112
    %%%%%: 2642-block 114
    %%%%%: 2642-block 116
    %%%%%: 2642-block 118
    %%%%%: 2642-block 120
    %%%%%: 2642-block 122
    %%%%%: 2642-block 124
    %%%%%: 2642-block 126
    %%%%%: 2642-block 128
    %%%%%: 2642-block 130
    %%%%%: 2642-block 132
    %%%%%: 2642-block 134
    %%%%%: 2642-block 136
    %%%%%: 2642-block 138
    %%%%%: 2642-block 140
    %%%%%: 2642-block 142
    %%%%%: 2642-block 144
    %%%%%: 2642-block 146
    %%%%%: 2642-block 148
    %%%%%: 2642-block 150
    %%%%%: 2642-block 152
    %%%%%: 2642-block 154
    %%%%%: 2642-block 156
    %%%%%: 2642-block 158
    %%%%%: 2642-block 160
    %%%%%: 2642-block 162
    %%%%%: 2642-block 164
    %%%%%: 2642-block 166
    %%%%%: 2642-block 168
    %%%%%: 2642-block 170
    %%%%%: 2642-block 172
    %%%%%: 2642-block 174
    %%%%%: 2642-block 176
    %%%%%: 2642-block 178
    %%%%%: 2642-block 180
    %%%%%: 2642-block 182
    %%%%%: 2642-block 184
    %%%%%: 2642-block 186
    %%%%%: 2642-block 188
    %%%%%: 2642-block 190
    %%%%%: 2642-block 192
    %%%%%: 2642-block 194
    %%%%%: 2642-block 196
    %%%%%: 2642-block 198
    %%%%%: 2642-block 200
    %%%%%: 2642-block 202
    %%%%%: 2642-block 204
    %%%%%: 2642-block 206
    %%%%%: 2642-block 208
    %%%%%: 2642-block 210
    %%%%%: 2642-block 212
    %%%%%: 2642-block 214
    %%%%%: 2642-block 216
    %%%%%: 2642-block 218
    %%%%%: 2642-block 220
    %%%%%: 2642-block 222
    %%%%%: 2642-block 224
    %%%%%: 2642-block 226
    %%%%%: 2642-block 228
    %%%%%: 2642-block 230
    %%%%%: 2642-block 232
    %%%%%: 2642-block 234
    %%%%%: 2642-block 236
    %%%%%: 2642-block 238
    %%%%%: 2642-block 240
    %%%%%: 2642-block 242
    %%%%%: 2642-block 244
    %%%%%: 2642-block 246
    %%%%%: 2642-block 248
    %%%%%: 2642-block 250
    %%%%%: 2642-block 252
    %%%%%: 2642-block 254
    %%%%%: 2642-block 256
    %%%%%: 2642-block 258
    %%%%%: 2642-block 260
    %%%%%: 2642-block 262
    %%%%%: 2642-block 264
        -: 2643:
        -: 2644:   {
        -: 2645:      // 16bit 8x8 transpose pass 1
    #####: 2646:      dct_interleave16(row0, row4);
    %%%%%: 2646-block 266
    %%%%%: 2646-block 268
    #####: 2647:      dct_interleave16(row1, row5);
    %%%%%: 2647-block 270
    %%%%%: 2647-block 272
    #####: 2648:      dct_interleave16(row2, row6);
    %%%%%: 2648-block 274
    %%%%%: 2648-block 276
    #####: 2649:      dct_interleave16(row3, row7);
    %%%%%: 2649-block 278
    %%%%%: 2649-block 280
        -: 2650:
        -: 2651:      // transpose pass 2
    #####: 2652:      dct_interleave16(row0, row2);
    %%%%%: 2652-block 282
    %%%%%: 2652-block 284
    #####: 2653:      dct_interleave16(row1, row3);
    %%%%%: 2653-block 286
    %%%%%: 2653-block 288
    #####: 2654:      dct_interleave16(row4, row6);
    %%%%%: 2654-block 290
    %%%%%: 2654-block 292
    #####: 2655:      dct_interleave16(row5, row7);
    %%%%%: 2655-block 294
    %%%%%: 2655-block 296
        -: 2656:
        -: 2657:      // transpose pass 3
    #####: 2658:      dct_interleave16(row0, row1);
    %%%%%: 2658-block 298
    %%%%%: 2658-block 300
    #####: 2659:      dct_interleave16(row2, row3);
    %%%%%: 2659-block 302
    %%%%%: 2659-block 304
    #####: 2660:      dct_interleave16(row4, row5);
    %%%%%: 2660-block 306
    %%%%%: 2660-block 308
    #####: 2661:      dct_interleave16(row6, row7);
    %%%%%: 2661-block 310
    %%%%%: 2661-block 312
    %%%%%: 2661-block 314
        -: 2662:   }
        -: 2663:
        -: 2664:   // row pass
    #####: 2665:   dct_pass(bias_1, 17);
    %%%%%: 2665-block 316
    %%%%%: 2665-block 318
    %%%%%: 2665-block 320
    %%%%%: 2665-block 322
    %%%%%: 2665-block 324
    %%%%%: 2665-block 326
    %%%%%: 2665-block 328
    %%%%%: 2665-block 330
    %%%%%: 2665-block 332
    %%%%%: 2665-block 334
    %%%%%: 2665-block 336
    %%%%%: 2665-block 338
    %%%%%: 2665-block 340
    %%%%%: 2665-block 342
    %%%%%: 2665-block 344
    %%%%%: 2665-block 346
    %%%%%: 2665-block 348
    %%%%%: 2665-block 350
    %%%%%: 2665-block 352
    %%%%%: 2665-block 354
    %%%%%: 2665-block 356
    %%%%%: 2665-block 358
    %%%%%: 2665-block 360
    %%%%%: 2665-block 362
    %%%%%: 2665-block 364
    %%%%%: 2665-block 366
    %%%%%: 2665-block 368
    %%%%%: 2665-block 370
    %%%%%: 2665-block 372
    %%%%%: 2665-block 374
    %%%%%: 2665-block 376
    %%%%%: 2665-block 378
    %%%%%: 2665-block 380
    %%%%%: 2665-block 382
    %%%%%: 2665-block 384
    %%%%%: 2665-block 386
    %%%%%: 2665-block 388
    %%%%%: 2665-block 390
    %%%%%: 2665-block 392
    %%%%%: 2665-block 394
    %%%%%: 2665-block 396
    %%%%%: 2665-block 398
    %%%%%: 2665-block 400
    %%%%%: 2665-block 402
    %%%%%: 2665-block 404
    %%%%%: 2665-block 406
    %%%%%: 2665-block 408
    %%%%%: 2665-block 410
    %%%%%: 2665-block 412
    %%%%%: 2665-block 414
    %%%%%: 2665-block 416
    %%%%%: 2665-block 418
    %%%%%: 2665-block 420
    %%%%%: 2665-block 422
    %%%%%: 2665-block 424
    %%%%%: 2665-block 426
    %%%%%: 2665-block 428
    %%%%%: 2665-block 430
    %%%%%: 2665-block 432
    %%%%%: 2665-block 434
    %%%%%: 2665-block 436
    %%%%%: 2665-block 438
    %%%%%: 2665-block 440
    %%%%%: 2665-block 442
    %%%%%: 2665-block 444
    %%%%%: 2665-block 446
    %%%%%: 2665-block 448
    %%%%%: 2665-block 450
    %%%%%: 2665-block 452
    %%%%%: 2665-block 454
    %%%%%: 2665-block 456
    %%%%%: 2665-block 458
    %%%%%: 2665-block 460
    %%%%%: 2665-block 462
    %%%%%: 2665-block 464
    %%%%%: 2665-block 466
    %%%%%: 2665-block 468
    %%%%%: 2665-block 470
    %%%%%: 2665-block 472
    %%%%%: 2665-block 474
    %%%%%: 2665-block 476
    %%%%%: 2665-block 478
    %%%%%: 2665-block 480
    %%%%%: 2665-block 482
    %%%%%: 2665-block 484
    %%%%%: 2665-block 486
    %%%%%: 2665-block 488
    %%%%%: 2665-block 490
    %%%%%: 2665-block 492
    %%%%%: 2665-block 494
    %%%%%: 2665-block 496
    %%%%%: 2665-block 498
    %%%%%: 2665-block 500
    %%%%%: 2665-block 502
    %%%%%: 2665-block 504
    %%%%%: 2665-block 506
    %%%%%: 2665-block 508
    %%%%%: 2665-block 510
    %%%%%: 2665-block 512
    %%%%%: 2665-block 514
    %%%%%: 2665-block 516
    %%%%%: 2665-block 518
    %%%%%: 2665-block 520
    %%%%%: 2665-block 522
        -: 2666:
        -: 2667:   {
        -: 2668:      // pack
    #####: 2669:      __m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7
    %%%%%: 2669-block 524
    #####: 2670:      __m128i p1 = _mm_packus_epi16(row2, row3);
    %%%%%: 2670-block 526
    #####: 2671:      __m128i p2 = _mm_packus_epi16(row4, row5);
    %%%%%: 2671-block 528
    #####: 2672:      __m128i p3 = _mm_packus_epi16(row6, row7);
        -: 2673:
        -: 2674:      // 8bit 8x8 transpose pass 1
    #####: 2675:      dct_interleave8(p0, p2); // a0e0a1e1...
    %%%%%: 2675-block 530
    %%%%%: 2675-block 532
    #####: 2676:      dct_interleave8(p1, p3); // c0g0c1g1...
    %%%%%: 2676-block 534
    %%%%%: 2676-block 536
        -: 2677:
        -: 2678:      // transpose pass 2
    #####: 2679:      dct_interleave8(p0, p1); // a0c0e0g0...
    %%%%%: 2679-block 538
    %%%%%: 2679-block 540
    #####: 2680:      dct_interleave8(p2, p3); // b0d0f0h0...
    %%%%%: 2680-block 542
    %%%%%: 2680-block 544
        -: 2681:
        -: 2682:      // transpose pass 3
    #####: 2683:      dct_interleave8(p0, p2); // a0b0c0d0...
    %%%%%: 2683-block 546
    %%%%%: 2683-block 548
    #####: 2684:      dct_interleave8(p1, p3); // a4b4c4d4...
    %%%%%: 2684-block 550
    %%%%%: 2684-block 552
    %%%%%: 2684-block 554
        -: 2685:
        -: 2686:      // store
    #####: 2687:      _mm_storel_epi64((__m128i *) out, p0); out += out_stride;
    #####: 2688:      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;
    %%%%%: 2688-block 555
    %%%%%: 2688-block 556
    #####: 2689:      _mm_storel_epi64((__m128i *) out, p2); out += out_stride;
    #####: 2690:      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p2, 0x4e)); out += out_stride;
    %%%%%: 2690-block 557
    %%%%%: 2690-block 558
    #####: 2691:      _mm_storel_epi64((__m128i *) out, p1); out += out_stride;
    #####: 2692:      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p1, 0x4e)); out += out_stride;
    %%%%%: 2692-block 559
    %%%%%: 2692-block 560
    #####: 2693:      _mm_storel_epi64((__m128i *) out, p3); out += out_stride;
    #####: 2694:      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p3, 0x4e));
    %%%%%: 2694-block 561
        -: 2695:   }
        -: 2696:
        -: 2697:#undef dct_const
        -: 2698:#undef dct_rot
        -: 2699:#undef dct_widen
        -: 2700:#undef dct_wadd
        -: 2701:#undef dct_wsub
        -: 2702:#undef dct_bfly32o
        -: 2703:#undef dct_interleave8
        -: 2704:#undef dct_interleave16
        -: 2705:#undef dct_pass
    #####: 2706:}
        -: 2707:
        -: 2708:#endif // STBI_SSE2
        -: 2709:
        -: 2710:#ifdef STBI_NEON
        -: 2711:
        -: 2712:// NEON integer IDCT. should produce bit-identical
        -: 2713:// results to the generic C version.
        -: 2714:static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
        -: 2715:{
        -: 2716:   int16x8_t row0, row1, row2, row3, row4, row5, row6, row7;
        -: 2717:
        -: 2718:   int16x4_t rot0_0 = vdup_n_s16(stbi__f2f(0.5411961f));
        -: 2719:   int16x4_t rot0_1 = vdup_n_s16(stbi__f2f(-1.847759065f));
        -: 2720:   int16x4_t rot0_2 = vdup_n_s16(stbi__f2f( 0.765366865f));
        -: 2721:   int16x4_t rot1_0 = vdup_n_s16(stbi__f2f( 1.175875602f));
        -: 2722:   int16x4_t rot1_1 = vdup_n_s16(stbi__f2f(-0.899976223f));
        -: 2723:   int16x4_t rot1_2 = vdup_n_s16(stbi__f2f(-2.562915447f));
        -: 2724:   int16x4_t rot2_0 = vdup_n_s16(stbi__f2f(-1.961570560f));
        -: 2725:   int16x4_t rot2_1 = vdup_n_s16(stbi__f2f(-0.390180644f));
        -: 2726:   int16x4_t rot3_0 = vdup_n_s16(stbi__f2f( 0.298631336f));
        -: 2727:   int16x4_t rot3_1 = vdup_n_s16(stbi__f2f( 2.053119869f));
        -: 2728:   int16x4_t rot3_2 = vdup_n_s16(stbi__f2f( 3.072711026f));
        -: 2729:   int16x4_t rot3_3 = vdup_n_s16(stbi__f2f( 1.501321110f));
        -: 2730:
        -: 2731:#define dct_long_mul(out, inq, coeff) \
        -: 2732:   int32x4_t out##_l = vmull_s16(vget_low_s16(inq), coeff); \
        -: 2733:   int32x4_t out##_h = vmull_s16(vget_high_s16(inq), coeff)
        -: 2734:
        -: 2735:#define dct_long_mac(out, acc, inq, coeff) \
        -: 2736:   int32x4_t out##_l = vmlal_s16(acc##_l, vget_low_s16(inq), coeff); \
        -: 2737:   int32x4_t out##_h = vmlal_s16(acc##_h, vget_high_s16(inq), coeff)
        -: 2738:
        -: 2739:#define dct_widen(out, inq) \
        -: 2740:   int32x4_t out##_l = vshll_n_s16(vget_low_s16(inq), 12); \
        -: 2741:   int32x4_t out##_h = vshll_n_s16(vget_high_s16(inq), 12)
        -: 2742:
        -: 2743:// wide add
        -: 2744:#define dct_wadd(out, a, b) \
        -: 2745:   int32x4_t out##_l = vaddq_s32(a##_l, b##_l); \
        -: 2746:   int32x4_t out##_h = vaddq_s32(a##_h, b##_h)
        -: 2747:
        -: 2748:// wide sub
        -: 2749:#define dct_wsub(out, a, b) \
        -: 2750:   int32x4_t out##_l = vsubq_s32(a##_l, b##_l); \
        -: 2751:   int32x4_t out##_h = vsubq_s32(a##_h, b##_h)
        -: 2752:
        -: 2753:// butterfly a/b, then shift using "shiftop" by "s" and pack
        -: 2754:#define dct_bfly32o(out0,out1, a,b,shiftop,s) \
        -: 2755:   { \
        -: 2756:      dct_wadd(sum, a, b); \
        -: 2757:      dct_wsub(dif, a, b); \
        -: 2758:      out0 = vcombine_s16(shiftop(sum_l, s), shiftop(sum_h, s)); \
        -: 2759:      out1 = vcombine_s16(shiftop(dif_l, s), shiftop(dif_h, s)); \
        -: 2760:   }
        -: 2761:
        -: 2762:#define dct_pass(shiftop, shift) \
        -: 2763:   { \
        -: 2764:      /* even part */ \
        -: 2765:      int16x8_t sum26 = vaddq_s16(row2, row6); \
        -: 2766:      dct_long_mul(p1e, sum26, rot0_0); \
        -: 2767:      dct_long_mac(t2e, p1e, row6, rot0_1); \
        -: 2768:      dct_long_mac(t3e, p1e, row2, rot0_2); \
        -: 2769:      int16x8_t sum04 = vaddq_s16(row0, row4); \
        -: 2770:      int16x8_t dif04 = vsubq_s16(row0, row4); \
        -: 2771:      dct_widen(t0e, sum04); \
        -: 2772:      dct_widen(t1e, dif04); \
        -: 2773:      dct_wadd(x0, t0e, t3e); \
        -: 2774:      dct_wsub(x3, t0e, t3e); \
        -: 2775:      dct_wadd(x1, t1e, t2e); \
        -: 2776:      dct_wsub(x2, t1e, t2e); \
        -: 2777:      /* odd part */ \
        -: 2778:      int16x8_t sum15 = vaddq_s16(row1, row5); \
        -: 2779:      int16x8_t sum17 = vaddq_s16(row1, row7); \
        -: 2780:      int16x8_t sum35 = vaddq_s16(row3, row5); \
        -: 2781:      int16x8_t sum37 = vaddq_s16(row3, row7); \
        -: 2782:      int16x8_t sumodd = vaddq_s16(sum17, sum35); \
        -: 2783:      dct_long_mul(p5o, sumodd, rot1_0); \
        -: 2784:      dct_long_mac(p1o, p5o, sum17, rot1_1); \
        -: 2785:      dct_long_mac(p2o, p5o, sum35, rot1_2); \
        -: 2786:      dct_long_mul(p3o, sum37, rot2_0); \
        -: 2787:      dct_long_mul(p4o, sum15, rot2_1); \
        -: 2788:      dct_wadd(sump13o, p1o, p3o); \
        -: 2789:      dct_wadd(sump24o, p2o, p4o); \
        -: 2790:      dct_wadd(sump23o, p2o, p3o); \
        -: 2791:      dct_wadd(sump14o, p1o, p4o); \
        -: 2792:      dct_long_mac(x4, sump13o, row7, rot3_0); \
        -: 2793:      dct_long_mac(x5, sump24o, row5, rot3_1); \
        -: 2794:      dct_long_mac(x6, sump23o, row3, rot3_2); \
        -: 2795:      dct_long_mac(x7, sump14o, row1, rot3_3); \
        -: 2796:      dct_bfly32o(row0,row7, x0,x7,shiftop,shift); \
        -: 2797:      dct_bfly32o(row1,row6, x1,x6,shiftop,shift); \
        -: 2798:      dct_bfly32o(row2,row5, x2,x5,shiftop,shift); \
        -: 2799:      dct_bfly32o(row3,row4, x3,x4,shiftop,shift); \
        -: 2800:   }
        -: 2801:
        -: 2802:   // load
        -: 2803:   row0 = vld1q_s16(data + 0*8);
        -: 2804:   row1 = vld1q_s16(data + 1*8);
        -: 2805:   row2 = vld1q_s16(data + 2*8);
        -: 2806:   row3 = vld1q_s16(data + 3*8);
        -: 2807:   row4 = vld1q_s16(data + 4*8);
        -: 2808:   row5 = vld1q_s16(data + 5*8);
        -: 2809:   row6 = vld1q_s16(data + 6*8);
        -: 2810:   row7 = vld1q_s16(data + 7*8);
        -: 2811:
        -: 2812:   // add DC bias
        -: 2813:   row0 = vaddq_s16(row0, vsetq_lane_s16(1024, vdupq_n_s16(0), 0));
        -: 2814:
        -: 2815:   // column pass
        -: 2816:   dct_pass(vrshrn_n_s32, 10);
        -: 2817:
        -: 2818:   // 16bit 8x8 transpose
        -: 2819:   {
        -: 2820:// these three map to a single VTRN.16, VTRN.32, and VSWP, respectively.
        -: 2821:// whether compilers actually get this is another story, sadly.
        -: 2822:#define dct_trn16(x, y) { int16x8x2_t t = vtrnq_s16(x, y); x = t.val[0]; y = t.val[1]; }
        -: 2823:#define dct_trn32(x, y) { int32x4x2_t t = vtrnq_s32(vreinterpretq_s32_s16(x), vreinterpretq_s32_s16(y)); x = vreinterpretq_s16_s32(t.val[0]); y = vreinterpretq_s16_s32(t.val[1]); }
        -: 2824:#define dct_trn64(x, y) { int16x8_t x0 = x; int16x8_t y0 = y; x = vcombine_s16(vget_low_s16(x0), vget_low_s16(y0)); y = vcombine_s16(vget_high_s16(x0), vget_high_s16(y0)); }
        -: 2825:
        -: 2826:      // pass 1
        -: 2827:      dct_trn16(row0, row1); // a0b0a2b2a4b4a6b6
        -: 2828:      dct_trn16(row2, row3);
        -: 2829:      dct_trn16(row4, row5);
        -: 2830:      dct_trn16(row6, row7);
        -: 2831:
        -: 2832:      // pass 2
        -: 2833:      dct_trn32(row0, row2); // a0b0c0d0a4b4c4d4
        -: 2834:      dct_trn32(row1, row3);
        -: 2835:      dct_trn32(row4, row6);
        -: 2836:      dct_trn32(row5, row7);
        -: 2837:
        -: 2838:      // pass 3
        -: 2839:      dct_trn64(row0, row4); // a0b0c0d0e0f0g0h0
        -: 2840:      dct_trn64(row1, row5);
        -: 2841:      dct_trn64(row2, row6);
        -: 2842:      dct_trn64(row3, row7);
        -: 2843:
        -: 2844:#undef dct_trn16
        -: 2845:#undef dct_trn32
        -: 2846:#undef dct_trn64
        -: 2847:   }
        -: 2848:
        -: 2849:   // row pass
        -: 2850:   // vrshrn_n_s32 only supports shifts up to 16, we need
        -: 2851:   // 17. so do a non-rounding shift of 16 first then follow
        -: 2852:   // up with a rounding shift by 1.
        -: 2853:   dct_pass(vshrn_n_s32, 16);
        -: 2854:
        -: 2855:   {
        -: 2856:      // pack and round
        -: 2857:      uint8x8_t p0 = vqrshrun_n_s16(row0, 1);
        -: 2858:      uint8x8_t p1 = vqrshrun_n_s16(row1, 1);
        -: 2859:      uint8x8_t p2 = vqrshrun_n_s16(row2, 1);
        -: 2860:      uint8x8_t p3 = vqrshrun_n_s16(row3, 1);
        -: 2861:      uint8x8_t p4 = vqrshrun_n_s16(row4, 1);
        -: 2862:      uint8x8_t p5 = vqrshrun_n_s16(row5, 1);
        -: 2863:      uint8x8_t p6 = vqrshrun_n_s16(row6, 1);
        -: 2864:      uint8x8_t p7 = vqrshrun_n_s16(row7, 1);
        -: 2865:
        -: 2866:      // again, these can translate into one instruction, but often don't.
        -: 2867:#define dct_trn8_8(x, y) { uint8x8x2_t t = vtrn_u8(x, y); x = t.val[0]; y = t.val[1]; }
        -: 2868:#define dct_trn8_16(x, y) { uint16x4x2_t t = vtrn_u16(vreinterpret_u16_u8(x), vreinterpret_u16_u8(y)); x = vreinterpret_u8_u16(t.val[0]); y = vreinterpret_u8_u16(t.val[1]); }
        -: 2869:#define dct_trn8_32(x, y) { uint32x2x2_t t = vtrn_u32(vreinterpret_u32_u8(x), vreinterpret_u32_u8(y)); x = vreinterpret_u8_u32(t.val[0]); y = vreinterpret_u8_u32(t.val[1]); }
        -: 2870:
        -: 2871:      // sadly can't use interleaved stores here since we only write
        -: 2872:      // 8 bytes to each scan line!
        -: 2873:
        -: 2874:      // 8x8 8-bit transpose pass 1
        -: 2875:      dct_trn8_8(p0, p1);
        -: 2876:      dct_trn8_8(p2, p3);
        -: 2877:      dct_trn8_8(p4, p5);
        -: 2878:      dct_trn8_8(p6, p7);
        -: 2879:
        -: 2880:      // pass 2
        -: 2881:      dct_trn8_16(p0, p2);
        -: 2882:      dct_trn8_16(p1, p3);
        -: 2883:      dct_trn8_16(p4, p6);
        -: 2884:      dct_trn8_16(p5, p7);
        -: 2885:
        -: 2886:      // pass 3
        -: 2887:      dct_trn8_32(p0, p4);
        -: 2888:      dct_trn8_32(p1, p5);
        -: 2889:      dct_trn8_32(p2, p6);
        -: 2890:      dct_trn8_32(p3, p7);
        -: 2891:
        -: 2892:      // store
        -: 2893:      vst1_u8(out, p0); out += out_stride;
        -: 2894:      vst1_u8(out, p1); out += out_stride;
        -: 2895:      vst1_u8(out, p2); out += out_stride;
        -: 2896:      vst1_u8(out, p3); out += out_stride;
        -: 2897:      vst1_u8(out, p4); out += out_stride;
        -: 2898:      vst1_u8(out, p5); out += out_stride;
        -: 2899:      vst1_u8(out, p6); out += out_stride;
        -: 2900:      vst1_u8(out, p7);
        -: 2901:
        -: 2902:#undef dct_trn8_8
        -: 2903:#undef dct_trn8_16
        -: 2904:#undef dct_trn8_32
        -: 2905:   }
        -: 2906:
        -: 2907:#undef dct_long_mul
        -: 2908:#undef dct_long_mac
        -: 2909:#undef dct_widen
        -: 2910:#undef dct_wadd
        -: 2911:#undef dct_wsub
        -: 2912:#undef dct_bfly32o
        -: 2913:#undef dct_pass
        -: 2914:}
        -: 2915:
        -: 2916:#endif // STBI_NEON
        -: 2917:
        -: 2918:#define STBI__MARKER_none  0xff
        -: 2919:// if there's a pending marker from the entropy stream, return that
        -: 2920:// otherwise, fetch from the stream and get a marker. if there's no
        -: 2921:// marker, return 0xff, which is never a valid marker value
function _ZL16stbi__get_markerP10stbi__jpeg called 0 returned 0% blocks executed 0%
    #####: 2922:static stbi_uc stbi__get_marker(stbi__jpeg *j)
        -: 2923:{
        -: 2924:   stbi_uc x;
    #####: 2925:   if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }
    %%%%%: 2925-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2925-block 3
    #####: 2926:   x = stbi__get8(j->s);
    %%%%%: 2926-block 4
call    0 never executed
    #####: 2927:   if (x != 0xff) return STBI__MARKER_none;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2927-block 6
    #####: 2928:   while (x == 0xff)
    %%%%%: 2928-block 7
    %%%%%: 2928-block 10
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2929:      x = stbi__get8(j->s); // consume repeated 0xff fill bytes
    %%%%%: 2929-block 8
call    0 never executed
    #####: 2930:   return x;
    %%%%%: 2930-block 11
        -: 2931:}
        -: 2932:
        -: 2933:// in each scan, we'll have scan_n components, and the order
        -: 2934:// of the components is specified by order[]
        -: 2935:#define STBI__RESTART(x)     ((x) >= 0xd0 && (x) <= 0xd7)
        -: 2936:
        -: 2937:// after a restart interval, stbi__jpeg_reset the entropy decoder and
        -: 2938:// the dc prediction
function _ZL16stbi__jpeg_resetP10stbi__jpeg called 0 returned 0% blocks executed 0%
    #####: 2939:static void stbi__jpeg_reset(stbi__jpeg *j)
        -: 2940:{
    #####: 2941:   j->code_bits = 0;
    #####: 2942:   j->code_buffer = 0;
    #####: 2943:   j->nomore = 0;
    #####: 2944:   j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;
    #####: 2945:   j->marker = STBI__MARKER_none;
    #####: 2946:   j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;
    %%%%%: 2946-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2946-block 3
    %%%%%: 2946-block 4
    #####: 2947:   j->eob_run = 0;
        -: 2948:   // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,
        -: 2949:   // since we don't even allow 1<<30 pixels
    #####: 2950:}
        -: 2951:
function _ZL30stbi__parse_entropy_coded_dataP10stbi__jpeg called 0 returned 0% blocks executed 0%
    #####: 2952:static int stbi__parse_entropy_coded_data(stbi__jpeg *z)
        -: 2953:{
    #####: 2954:   stbi__jpeg_reset(z);
    %%%%%: 2954-block 2
call    0 never executed
    #####: 2955:   if (!z->progressive) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2956:      if (z->scan_n == 1) {
    %%%%%: 2956-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2957:         int i,j;
        -: 2958:         STBI_SIMD_ALIGN(short, data[64]);
    #####: 2959:         int n = z->order[0];
        -: 2960:         // non-interleaved data, we just need to process one block at a time,
        -: 2961:         // in trivial scanline order
        -: 2962:         // number of blocks to do just depends on how many actual "pixels" this
        -: 2963:         // component has, independent of interleaved MCU blocking and such
    #####: 2964:         int w = (z->img_comp[n].x+7) >> 3;
    #####: 2965:         int h = (z->img_comp[n].y+7) >> 3;
    #####: 2966:         for (j=0; j < h; ++j) {
    %%%%%: 2966-block 5
    %%%%%: 2966-block 20
    %%%%%: 2966-block 21
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2967:            for (i=0; i < w; ++i) {
    %%%%%: 2967-block 6
    %%%%%: 2967-block 18
    %%%%%: 2967-block 19
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2968:               int ha = z->img_comp[n].ha;
    #####: 2969:               if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
    %%%%%: 2969-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 2969-block 8
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 2969-block 9
    #####: 2970:               z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
    %%%%%: 2970-block 10
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 2971:               // every data block is an MCU, so countdown the restart interval
    #####: 2972:               if (--z->todo <= 0) {
    %%%%%: 2972-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2973:                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
    %%%%%: 2973-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2973-block 13
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
        -: 2974:                  // if it's NOT a restart, then just bail, so we get corrupt data
        -: 2975:                  // rather than no data
    #####: 2976:                  if (!STBI__RESTART(z->marker)) return 1;
    %%%%%: 2976-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2976-block 15
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2976-block 16
    #####: 2977:                  stbi__jpeg_reset(z);
    %%%%%: 2977-block 17
call    0 never executed
        -: 2978:               }
        -: 2979:            }
        -: 2980:         }
    #####: 2981:         return 1;
    %%%%%: 2981-block 22
        -: 2982:      } else { // interleaved
        -: 2983:         int i,j,k,x,y;
        -: 2984:         STBI_SIMD_ALIGN(short, data[64]);
    #####: 2985:         for (j=0; j < z->img_mcu_y; ++j) {
    %%%%%: 2985-block 24
    %%%%%: 2985-block 48
    %%%%%: 2985-block 49
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2986:            for (i=0; i < z->img_mcu_x; ++i) {
    %%%%%: 2986-block 25
    %%%%%: 2986-block 46
    %%%%%: 2986-block 47
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 2987:               // scan an interleaved mcu... process scan_n components in order
    #####: 2988:               for (k=0; k < z->scan_n; ++k) {
    %%%%%: 2988-block 26
    %%%%%: 2988-block 37
    %%%%%: 2988-block 38
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2989:                  int n = z->order[k];
        -: 2990:                  // scan out an mcu's worth of this component; that's just determined
        -: 2991:                  // by the basic H and V specified for the component
    #####: 2992:                  for (y=0; y < z->img_comp[n].v; ++y) {
    %%%%%: 2992-block 27
    %%%%%: 2992-block 35
    %%%%%: 2992-block 36
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2993:                     for (x=0; x < z->img_comp[n].h; ++x) {
    %%%%%: 2993-block 28
    %%%%%: 2993-block 33
    %%%%%: 2993-block 34
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2994:                        int x2 = (i*z->img_comp[n].h + x)*8;
    #####: 2995:                        int y2 = (j*z->img_comp[n].v + y)*8;
    #####: 2996:                        int ha = z->img_comp[n].ha;
    #####: 2997:                        if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
    %%%%%: 2997-block 29
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 2997-block 30
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 2997-block 31
    #####: 2998:                        z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data);
    %%%%%: 2998-block 32
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 2999:                     }
        -: 3000:                  }
        -: 3001:               }
        -: 3002:               // after all interleaved components, that's an interleaved MCU,
        -: 3003:               // so now count down the restart interval
    #####: 3004:               if (--z->todo <= 0) {
    %%%%%: 3004-block 39
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3005:                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
    %%%%%: 3005-block 40
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3005-block 41
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####: 3006:                  if (!STBI__RESTART(z->marker)) return 1;
    %%%%%: 3006-block 42
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3006-block 43
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3006-block 44
    #####: 3007:                  stbi__jpeg_reset(z);
    %%%%%: 3007-block 45
call    0 never executed
        -: 3008:               }
        -: 3009:            }
        -: 3010:         }
    #####: 3011:         return 1;
    %%%%%: 3011-block 50
        -: 3012:      }
        -: 3013:   } else {
    #####: 3014:      if (z->scan_n == 1) {
    %%%%%: 3014-block 52
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3015:         int i,j;
    #####: 3016:         int n = z->order[0];
        -: 3017:         // non-interleaved data, we just need to process one block at a time,
        -: 3018:         // in trivial scanline order
        -: 3019:         // number of blocks to do just depends on how many actual "pixels" this
        -: 3020:         // component has, independent of interleaved MCU blocking and such
    #####: 3021:         int w = (z->img_comp[n].x+7) >> 3;
    #####: 3022:         int h = (z->img_comp[n].y+7) >> 3;
    #####: 3023:         for (j=0; j < h; ++j) {
    %%%%%: 3023-block 53
    %%%%%: 3023-block 71
    %%%%%: 3023-block 72
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3024:            for (i=0; i < w; ++i) {
    %%%%%: 3024-block 54
    %%%%%: 3024-block 69
    %%%%%: 3024-block 70
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3025:               short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
    #####: 3026:               if (z->spec_start == 0) {
    %%%%%: 3026-block 55
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3027:                  if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
    %%%%%: 3027-block 56
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 3028:                     return 0;
    %%%%%: 3028-block 58
        -: 3029:               } else {
    #####: 3030:                  int ha = z->img_comp[n].ha;
    #####: 3031:                  if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))
    %%%%%: 3031-block 59
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 3032:                     return 0;
    %%%%%: 3032-block 61
        -: 3033:               }
        -: 3034:               // every data block is an MCU, so countdown the restart interval
    #####: 3035:               if (--z->todo <= 0) {
    %%%%%: 3035-block 62
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3036:                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
    %%%%%: 3036-block 63
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3036-block 64
call    2 never executed
    #####: 3037:                  if (!STBI__RESTART(z->marker)) return 1;
    %%%%%: 3037-block 65
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3037-block 66
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3037-block 67
    #####: 3038:                  stbi__jpeg_reset(z);
    %%%%%: 3038-block 68
call    0 never executed
        -: 3039:               }
        -: 3040:            }
        -: 3041:         }
    #####: 3042:         return 1;
    %%%%%: 3042-block 73
        -: 3043:      } else { // interleaved
        -: 3044:         int i,j,k,x,y;
    #####: 3045:         for (j=0; j < z->img_mcu_y; ++j) {
    %%%%%: 3045-block 74
    %%%%%: 3045-block 97
    %%%%%: 3045-block 98
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3046:            for (i=0; i < z->img_mcu_x; ++i) {
    %%%%%: 3046-block 75
    %%%%%: 3046-block 95
    %%%%%: 3046-block 96
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 3047:               // scan an interleaved mcu... process scan_n components in order
    #####: 3048:               for (k=0; k < z->scan_n; ++k) {
    %%%%%: 3048-block 76
    %%%%%: 3048-block 86
    %%%%%: 3048-block 87
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3049:                  int n = z->order[k];
        -: 3050:                  // scan out an mcu's worth of this component; that's just determined
        -: 3051:                  // by the basic H and V specified for the component
    #####: 3052:                  for (y=0; y < z->img_comp[n].v; ++y) {
    %%%%%: 3052-block 77
    %%%%%: 3052-block 84
    %%%%%: 3052-block 85
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3053:                     for (x=0; x < z->img_comp[n].h; ++x) {
    %%%%%: 3053-block 78
    %%%%%: 3053-block 82
    %%%%%: 3053-block 83
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3054:                        int x2 = (i*z->img_comp[n].h + x);
    #####: 3055:                        int y2 = (j*z->img_comp[n].v + y);
    #####: 3056:                        short *data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);
    #####: 3057:                        if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
    %%%%%: 3057-block 79
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 3058:                           return 0;
    %%%%%: 3058-block 81
        -: 3059:                     }
        -: 3060:                  }
        -: 3061:               }
        -: 3062:               // after all interleaved components, that's an interleaved MCU,
        -: 3063:               // so now count down the restart interval
    #####: 3064:               if (--z->todo <= 0) {
    %%%%%: 3064-block 88
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3065:                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
    %%%%%: 3065-block 89
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3065-block 90
call    2 never executed
    #####: 3066:                  if (!STBI__RESTART(z->marker)) return 1;
    %%%%%: 3066-block 91
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3066-block 92
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3066-block 93
    #####: 3067:                  stbi__jpeg_reset(z);
    %%%%%: 3067-block 94
call    0 never executed
        -: 3068:               }
        -: 3069:            }
        -: 3070:         }
    #####: 3071:         return 1;
    %%%%%: 3071-block 99
        -: 3072:      }
        -: 3073:   }
        -: 3074:}
        -: 3075:
function _ZL21stbi__jpeg_dequantizePsPt called 0 returned 0% blocks executed 0%
    #####: 3076:static void stbi__jpeg_dequantize(short *data, stbi__uint16 *dequant)
        -: 3077:{
        -: 3078:   int i;
    #####: 3079:   for (i=0; i < 64; ++i)
    %%%%%: 3079-block 2
    %%%%%: 3079-block 4
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3080:      data[i] *= dequant[i];
    %%%%%: 3080-block 3
    #####: 3081:}
        -: 3082:
function _ZL17stbi__jpeg_finishP10stbi__jpeg called 0 returned 0% blocks executed 0%
    #####: 3083:static void stbi__jpeg_finish(stbi__jpeg *z)
        -: 3084:{
    #####: 3085:   if (z->progressive) {
    %%%%%: 3085-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3086:      // dequantize and idct the data
        -: 3087:      int i,j,n;
    #####: 3088:      for (n=0; n < z->s->img_n; ++n) {
    %%%%%: 3088-block 3
    %%%%%: 3088-block 12
    %%%%%: 3088-block 13
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3089:         int w = (z->img_comp[n].x+7) >> 3;
    #####: 3090:         int h = (z->img_comp[n].y+7) >> 3;
    #####: 3091:         for (j=0; j < h; ++j) {
    %%%%%: 3091-block 4
    %%%%%: 3091-block 10
    %%%%%: 3091-block 11
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3092:            for (i=0; i < w; ++i) {
    %%%%%: 3092-block 5
    %%%%%: 3092-block 9
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3093:               short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
    #####: 3094:               stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);
    %%%%%: 3094-block 6
call    0 never executed
    #####: 3095:               z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
call    0 never executed
        -: 3096:            }
        -: 3097:         }
        -: 3098:      }
        -: 3099:   }
    #####: 3100:}
        -: 3101:
function _ZL20stbi__process_markerP10stbi__jpegi called 0 returned 0% blocks executed 0%
    #####: 3102:static int stbi__process_marker(stbi__jpeg *z, int m)
        -: 3103:{
        -: 3104:   int L;
    #####: 3105:   switch (m) {
    %%%%%: 3105-block 2
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3106:      case STBI__MARKER_none: // no marker found
    #####: 3107:         return stbi__err("expected marker","Corrupt JPEG");
    %%%%%: 3107-block 3
call    0 never executed
        -: 3108:
    #####: 3109:      case 0xDD: // DRI - specify restart interval
    #####: 3110:         if (stbi__get16be(z->s) != 4) return stbi__err("bad DRI len","Corrupt JPEG");
    %%%%%: 3110-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3110-block 6
call    3 never executed
    #####: 3111:         z->restart_interval = stbi__get16be(z->s);
    %%%%%: 3111-block 7
call    0 never executed
    #####: 3112:         return 1;
        -: 3113:
    #####: 3114:      case 0xDB: // DQT - define quantization table
    #####: 3115:         L = stbi__get16be(z->s)-2;
    %%%%%: 3115-block 9
call    0 never executed
    #####: 3116:         while (L > 0) {
    %%%%%: 3116-block 29
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3117:            int q = stbi__get8(z->s);
    %%%%%: 3117-block 11
call    0 never executed
    #####: 3118:            int p = q >> 4, sixteen = (p != 0);
    #####: 3119:            int t = q & 15,i;
    #####: 3120:            if (p != 0 && p != 1) return stbi__err("bad DQT type","Corrupt JPEG");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3120-block 13
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3120-block 14
call    4 never executed
    #####: 3121:            if (t > 3) return stbi__err("bad DQT table","Corrupt JPEG");
    %%%%%: 3121-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3121-block 16
call    2 never executed
        -: 3122:
    #####: 3123:            for (i=0; i < 64; ++i)
    %%%%%: 3123-block 17
    %%%%%: 3123-block 24
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3124:               z->dequant[t][stbi__jpeg_dezigzag[i]] = (stbi__uint16)(sixteen ? stbi__get16be(z->s) : stbi__get8(z->s));
    %%%%%: 3124-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3124-block 19
call    2 never executed
    %%%%%: 3124-block 21
call    3 never executed
    %%%%%: 3124-block 23
    #####: 3125:            L -= (sixteen ? 129 : 65);
    %%%%%: 3125-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3125-block 26
    %%%%%: 3125-block 27
    %%%%%: 3125-block 28
        -: 3126:         }
    #####: 3127:         return L==0;
    %%%%%: 3127-block 30
        -: 3128:
    #####: 3129:      case 0xC4: // DHT - define huffman table
    #####: 3130:         L = stbi__get16be(z->s)-2;
    %%%%%: 3130-block 31
call    0 never executed
    #####: 3131:         while (L > 0) {
    %%%%%: 3131-block 60
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 3132:            stbi_uc *v;
    #####: 3133:            int sizes[16],i,n=0;
    #####: 3134:            int q = stbi__get8(z->s);
    %%%%%: 3134-block 33
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3135:            int tc = q >> 4;
    #####: 3136:            int th = q & 15;
    #####: 3137:            if (tc > 1 || th > 3) return stbi__err("bad DHT header","Corrupt JPEG");
    %%%%%: 3137-block 34
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3137-block 35
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3137-block 36
call    4 never executed
    %%%%%: 3137-block 59
    #####: 3138:            for (i=0; i < 16; ++i) {
    %%%%%: 3138-block 37
    %%%%%: 3138-block 40
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3139:               sizes[i] = stbi__get8(z->s);
    %%%%%: 3139-block 38
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3140:               n += sizes[i];
    %%%%%: 3140-block 39
        -: 3141:            }
    #####: 3142:            if(n > 256) return stbi__err("bad DHT header","Corrupt JPEG"); // Loop over i < n would write past end of values!
    %%%%%: 3142-block 41
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3142-block 42
call    2 never executed
    #####: 3143:            L -= 17;
    #####: 3144:            if (tc == 0) {
    %%%%%: 3144-block 43
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3145:               if (!stbi__build_huffman(z->huff_dc+th, sizes)) return 0;
    %%%%%: 3145-block 44
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3145-block 46
    #####: 3146:               v = z->huff_dc[th].values;
    %%%%%: 3146-block 47
        -: 3147:            } else {
    #####: 3148:               if (!stbi__build_huffman(z->huff_ac+th, sizes)) return 0;
    %%%%%: 3148-block 48
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3148-block 50
    #####: 3149:               v = z->huff_ac[th].values;
    %%%%%: 3149-block 51
        -: 3150:            }
    #####: 3151:            for (i=0; i < n; ++i)
    %%%%%: 3151-block 52
    %%%%%: 3151-block 55
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3152:               v[i] = stbi__get8(z->s);
    %%%%%: 3152-block 53
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 3152-block 54
    #####: 3153:            if (tc != 0)
    %%%%%: 3153-block 56
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3154:               stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);
    %%%%%: 3154-block 57
call    0 never executed
    #####: 3155:            L -= n;
    %%%%%: 3155-block 58
        -: 3156:         }
    #####: 3157:         return L==0;
    %%%%%: 3157-block 61
        -: 3158:   }
        -: 3159:
        -: 3160:   // check for comment block or APP blocks
    #####: 3161:   if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {
    %%%%%: 3161-block 62
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3161-block 63
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3161-block 64
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 3162:      L = stbi__get16be(z->s);
    %%%%%: 3162-block 65
call    0 never executed
    #####: 3163:      if (L < 2) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3164:         if (m == 0xFE)
    %%%%%: 3164-block 67
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3165:            return stbi__err("bad COM len","Corrupt JPEG");
    %%%%%: 3165-block 68
call    0 never executed
        -: 3166:         else
    #####: 3167:            return stbi__err("bad APP len","Corrupt JPEG");
    %%%%%: 3167-block 69
call    0 never executed
        -: 3168:      }
    #####: 3169:      L -= 2;
        -: 3170:
    #####: 3171:      if (m == 0xE0 && L >= 5) { // JFIF APP0 segment
    %%%%%: 3171-block 70
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3171-block 71
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 3172:         static const unsigned char tag[5] = {'J','F','I','F','\0'};
    #####: 3173:         int ok = 1;
        -: 3174:         int i;
    #####: 3175:         for (i=0; i < 5; ++i)
    %%%%%: 3175-block 72
    %%%%%: 3175-block 76
    %%%%%: 3175-block 77
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3176:            if (stbi__get8(z->s) != tag[i])
    %%%%%: 3176-block 73
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 3177:               ok = 0;
    %%%%%: 3177-block 75
    #####: 3178:         L -= 5;
    #####: 3179:         if (ok)
    %%%%%: 3179-block 78
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3180:            z->jfif = 1;
    %%%%%: 3180-block 79
    #####: 3181:      } else if (m == 0xEE && L >= 12) { // Adobe APP14 segment
    %%%%%: 3181-block 80
    %%%%%: 3181-block 81
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3181-block 82
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 3182:         static const unsigned char tag[6] = {'A','d','o','b','e','\0'};
    #####: 3183:         int ok = 1;
        -: 3184:         int i;
    #####: 3185:         for (i=0; i < 6; ++i)
    %%%%%: 3185-block 83
    %%%%%: 3185-block 87
    %%%%%: 3185-block 88
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3186:            if (stbi__get8(z->s) != tag[i])
    %%%%%: 3186-block 84
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 3187:               ok = 0;
    %%%%%: 3187-block 86
    #####: 3188:         L -= 6;
    #####: 3189:         if (ok) {
    %%%%%: 3189-block 89
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3190:            stbi__get8(z->s); // version
    %%%%%: 3190-block 90
call    0 never executed
    #####: 3191:            stbi__get16be(z->s); // flags0
call    0 never executed
    #####: 3192:            stbi__get16be(z->s); // flags1
call    0 never executed
    #####: 3193:            z->app14_color_transform = stbi__get8(z->s); // color transform
call    0 never executed
    #####: 3194:            L -= 6;
        -: 3195:         }
        -: 3196:      }
        -: 3197:
    #####: 3198:      stbi__skip(z->s, L);
    %%%%%: 3198-block 95
call    0 never executed
    #####: 3199:      return 1;
        -: 3200:   }
        -: 3201:
    #####: 3202:   return stbi__err("unknown marker","Corrupt JPEG");
    %%%%%: 3202-block 97
call    0 never executed
        -: 3203:}
        -: 3204:
        -: 3205:// after we see SOS
function _ZL25stbi__process_scan_headerP10stbi__jpeg called 0 returned 0% blocks executed 0%
    #####: 3206:static int stbi__process_scan_header(stbi__jpeg *z)
        -: 3207:{
        -: 3208:   int i;
    #####: 3209:   int Ls = stbi__get16be(z->s);
    %%%%%: 3209-block 2
call    0 never executed
    #####: 3210:   z->scan_n = stbi__get8(z->s);
call    0 never executed
    #####: 3211:   if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return stbi__err("bad SOS component count","Corrupt JPEG");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3211-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3211-block 6
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 3211-block 7
call    6 never executed
    #####: 3212:   if (Ls != 6+2*z->scan_n) return stbi__err("bad SOS len","Corrupt JPEG");
    %%%%%: 3212-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3212-block 9
call    2 never executed
    #####: 3213:   for (i=0; i < z->scan_n; ++i) {
    %%%%%: 3213-block 10
    %%%%%: 3213-block 25
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3214:      int id = stbi__get8(z->s), which;
    %%%%%: 3214-block 11
call    0 never executed
    #####: 3215:      int q = stbi__get8(z->s);
call    0 never executed
    #####: 3216:      for (which = 0; which < z->s->img_n; ++which)
    %%%%%: 3216-block 16
    %%%%%: 3216-block 17
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3217:         if (z->img_comp[which].id == id)
    %%%%%: 3217-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3218:            break;
    %%%%%: 3218-block 15
    #####: 3219:      if (which == z->s->img_n) return 0; // no match
    %%%%%: 3219-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3219-block 19
    #####: 3220:      z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err("bad DC huff","Corrupt JPEG");
    %%%%%: 3220-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3220-block 21
call    2 never executed
    #####: 3221:      z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err("bad AC huff","Corrupt JPEG");
    %%%%%: 3221-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3221-block 23
call    2 never executed
    #####: 3222:      z->order[i] = which;
    %%%%%: 3222-block 24
        -: 3223:   }
        -: 3224:
        -: 3225:   {
        -: 3226:      int aa;
    #####: 3227:      z->spec_start = stbi__get8(z->s);
    %%%%%: 3227-block 26
call    0 never executed
    #####: 3228:      z->spec_end   = stbi__get8(z->s); // should be 63, but might be 0
call    0 never executed
    #####: 3229:      aa = stbi__get8(z->s);
call    0 never executed
    #####: 3230:      z->succ_high = (aa >> 4);
    #####: 3231:      z->succ_low  = (aa & 15);
    #####: 3232:      if (z->progressive) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3233:         if (z->spec_start > 63 || z->spec_end > 63  || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)
    %%%%%: 3233-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3233-block 31
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3233-block 32
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 3233-block 33
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 3233-block 34
branch  8 never executed (fallthrough)
branch  9 never executed
    #####: 3234:            return stbi__err("bad SOS", "Corrupt JPEG");
    %%%%%: 3234-block 35
call    0 never executed
        -: 3235:      } else {
    #####: 3236:         if (z->spec_start != 0) return stbi__err("bad SOS","Corrupt JPEG");
    %%%%%: 3236-block 36
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3236-block 37
call    2 never executed
    #####: 3237:         if (z->succ_high != 0 || z->succ_low != 0) return stbi__err("bad SOS","Corrupt JPEG");
    %%%%%: 3237-block 38
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3237-block 39
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3237-block 40
call    4 never executed
    #####: 3238:         z->spec_end = 63;
    %%%%%: 3238-block 41
        -: 3239:      }
        -: 3240:   }
        -: 3241:
    #####: 3242:   return 1;
    %%%%%: 3242-block 42
        -: 3243:}
        -: 3244:
function _ZL26stbi__free_jpeg_componentsP10stbi__jpegii called 0 returned 0% blocks executed 0%
    #####: 3245:static int stbi__free_jpeg_components(stbi__jpeg *z, int ncomp, int why)
        -: 3246:{
        -: 3247:   int i;
    #####: 3248:   for (i=0; i < ncomp; ++i) {
    %%%%%: 3248-block 2
    %%%%%: 3248-block 9
    %%%%%: 3248-block 10
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3249:      if (z->img_comp[i].raw_data) {
    %%%%%: 3249-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3250:         STBI_FREE(z->img_comp[i].raw_data);
    #####: 3251:         z->img_comp[i].raw_data = NULL;
    #####: 3252:         z->img_comp[i].data = NULL;
    %%%%%: 3252-block 4
        -: 3253:      }
    #####: 3254:      if (z->img_comp[i].raw_coeff) {
    %%%%%: 3254-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3255:         STBI_FREE(z->img_comp[i].raw_coeff);
    #####: 3256:         z->img_comp[i].raw_coeff = 0;
    #####: 3257:         z->img_comp[i].coeff = 0;
    %%%%%: 3257-block 6
        -: 3258:      }
    #####: 3259:      if (z->img_comp[i].linebuf) {
    %%%%%: 3259-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3260:         STBI_FREE(z->img_comp[i].linebuf);
    #####: 3261:         z->img_comp[i].linebuf = NULL;
    %%%%%: 3261-block 8
        -: 3262:      }
        -: 3263:   }
    #####: 3264:   return why;
    %%%%%: 3264-block 11
        -: 3265:}
        -: 3266:
function _ZL26stbi__process_frame_headerP10stbi__jpegi called 0 returned 0% blocks executed 0%
    #####: 3267:static int stbi__process_frame_header(stbi__jpeg *z, int scan)
        -: 3268:{
    #####: 3269:   stbi__context *s = z->s;
    #####: 3270:   int Lf,p,i,q, h_max=1,v_max=1,c;
    #####: 3271:   Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err("bad SOF len","Corrupt JPEG"); // JPEG
    %%%%%: 3271-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3271-block 4
call    3 never executed
    #####: 3272:   p  = stbi__get8(s);            if (p != 8) return stbi__err("only 8-bit","JPEG format not supported: 8-bit only"); // JPEG baseline
    %%%%%: 3272-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3272-block 7
call    3 never executed
    #####: 3273:   s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err("no header height", "JPEG format not supported: delayed height"); // Legal, but we don't handle it--but neither does IJG
    %%%%%: 3273-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3273-block 10
call    3 never executed
    #####: 3274:   s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err("0 width","Corrupt JPEG"); // JPEG requires
    %%%%%: 3274-block 11
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3274-block 13
call    3 never executed
    #####: 3275:   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
    %%%%%: 3275-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3275-block 15
call    2 never executed
    #####: 3276:   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
    %%%%%: 3276-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3276-block 17
call    2 never executed
    #####: 3277:   c = stbi__get8(s);
    %%%%%: 3277-block 18
call    0 never executed
    #####: 3278:   if (c != 3 && c != 1 && c != 4) return stbi__err("bad component count","Corrupt JPEG");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3278-block 20
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3278-block 21
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 3278-block 22
call    6 never executed
    #####: 3279:   s->img_n = c;
    #####: 3280:   for (i=0; i < c; ++i) {
    %%%%%: 3280-block 23
    %%%%%: 3280-block 25
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3281:      z->img_comp[i].data = NULL;
    #####: 3282:      z->img_comp[i].linebuf = NULL;
    %%%%%: 3282-block 24
        -: 3283:   }
        -: 3284:
    #####: 3285:   if (Lf != 8+3*s->img_n) return stbi__err("bad SOF len","Corrupt JPEG");
    %%%%%: 3285-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3285-block 27
call    2 never executed
        -: 3286:
    #####: 3287:   z->rgb = 0;
    #####: 3288:   for (i=0; i < s->img_n; ++i) {
    %%%%%: 3288-block 28
    %%%%%: 3288-block 43
    %%%%%: 3288-block 44
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 3289:      static const unsigned char rgb[3] = { 'R', 'G', 'B' };
    #####: 3290:      z->img_comp[i].id = stbi__get8(s);
    %%%%%: 3290-block 29
call    0 never executed
    #####: 3291:      if (s->img_n == 3 && z->img_comp[i].id == rgb[i])
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3291-block 31
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3292:         ++z->rgb;
    %%%%%: 3292-block 32
    #####: 3293:      q = stbi__get8(s);
    %%%%%: 3293-block 33
call    0 never executed
    #####: 3294:      z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err("bad H","Corrupt JPEG");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3294-block 35
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3294-block 36
call    4 never executed
    #####: 3295:      z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err("bad V","Corrupt JPEG");
    %%%%%: 3295-block 37
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3295-block 38
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3295-block 39
call    4 never executed
    #####: 3296:      z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err("bad TQ","Corrupt JPEG");
    %%%%%: 3296-block 40
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3296-block 42
call    3 never executed
        -: 3297:   }
        -: 3298:
    #####: 3299:   if (scan != STBI__SCAN_load) return 1;
    %%%%%: 3299-block 45
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3299-block 46
        -: 3300:
    #####: 3301:   if (!stbi__mad3sizes_valid(s->img_x, s->img_y, s->img_n, 0)) return stbi__err("too large", "Image too large to decode");
    %%%%%: 3301-block 47
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3301-block 49
call    3 never executed
        -: 3302:
    #####: 3303:   for (i=0; i < s->img_n; ++i) {
    %%%%%: 3303-block 50
    %%%%%: 3303-block 55
    %%%%%: 3303-block 56
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3304:      if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;
    %%%%%: 3304-block 51
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3304-block 52
    #####: 3305:      if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;
    %%%%%: 3305-block 53
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3305-block 54
        -: 3306:   }
        -: 3307:
        -: 3308:   // check that plane subsampling factors are integer ratios; our resamplers can't deal with fractional ratios
        -: 3309:   // and I've never seen a non-corrupted JPEG file actually use them
    #####: 3310:   for (i=0; i < s->img_n; ++i) {
    %%%%%: 3310-block 57
    %%%%%: 3310-block 62
    %%%%%: 3310-block 63
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3311:      if (h_max % z->img_comp[i].h != 0) return stbi__err("bad H","Corrupt JPEG");
    %%%%%: 3311-block 58
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3311-block 59
call    2 never executed
    #####: 3312:      if (v_max % z->img_comp[i].v != 0) return stbi__err("bad V","Corrupt JPEG");
    %%%%%: 3312-block 60
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3312-block 61
call    2 never executed
        -: 3313:   }
        -: 3314:
        -: 3315:   // compute interleaved mcu info
    #####: 3316:   z->img_h_max = h_max;
    #####: 3317:   z->img_v_max = v_max;
    #####: 3318:   z->img_mcu_w = h_max * 8;
    #####: 3319:   z->img_mcu_h = v_max * 8;
        -: 3320:   // these sizes can't be more than 17 bits
    #####: 3321:   z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w;
    #####: 3322:   z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h;
        -: 3323:
    #####: 3324:   for (i=0; i < s->img_n; ++i) {
    %%%%%: 3324-block 64
    %%%%%: 3324-block 75
    %%%%%: 3324-block 76
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 3325:      // number of effective pixels (e.g. for non-interleaved MCU)
    #####: 3326:      z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;
    #####: 3327:      z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;
        -: 3328:      // to simplify generation, we'll allocate enough memory to decode
        -: 3329:      // the bogus oversized data from using interleaved MCUs and their
        -: 3330:      // big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't
        -: 3331:      // discard the extra data until colorspace conversion
        -: 3332:      //
        -: 3333:      // img_mcu_x, img_mcu_y: <=17 bits; comp[i].h and .v are <=4 (checked earlier)
        -: 3334:      // so these muls can't overflow with 32-bit ints (which we require)
    #####: 3335:      z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;
    #####: 3336:      z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;
    #####: 3337:      z->img_comp[i].coeff = 0;
    #####: 3338:      z->img_comp[i].raw_coeff = 0;
    #####: 3339:      z->img_comp[i].linebuf = NULL;
    #####: 3340:      z->img_comp[i].raw_data = stbi__malloc_mad2(z->img_comp[i].w2, z->img_comp[i].h2, 15);
    %%%%%: 3340-block 65
call    0 never executed
    #####: 3341:      if (z->img_comp[i].raw_data == NULL)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3342:         return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem", "Out of memory"));
    %%%%%: 3342-block 67
call    0 never executed
call    1 never executed
        -: 3343:      // align blocks for idct using mmx/sse
    #####: 3344:      z->img_comp[i].data = (stbi_uc*) (((size_t) z->img_comp[i].raw_data + 15) & ~15);
    #####: 3345:      if (z->progressive) {
    %%%%%: 3345-block 69
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3346:         // w2, h2 are multiples of 8 (see above)
    #####: 3347:         z->img_comp[i].coeff_w = z->img_comp[i].w2 / 8;
    #####: 3348:         z->img_comp[i].coeff_h = z->img_comp[i].h2 / 8;
    #####: 3349:         z->img_comp[i].raw_coeff = stbi__malloc_mad3(z->img_comp[i].w2, z->img_comp[i].h2, sizeof(short), 15);
    %%%%%: 3349-block 70
call    0 never executed
    #####: 3350:         if (z->img_comp[i].raw_coeff == NULL)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3351:            return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem", "Out of memory"));
    %%%%%: 3351-block 72
call    0 never executed
call    1 never executed
    #####: 3352:         z->img_comp[i].coeff = (short*) (((size_t) z->img_comp[i].raw_coeff + 15) & ~15);
    %%%%%: 3352-block 74
        -: 3353:      }
        -: 3354:   }
        -: 3355:
    #####: 3356:   return 1;
    %%%%%: 3356-block 77
        -: 3357:}
        -: 3358:
        -: 3359:// use comparisons since in some cases we handle more than one case (e.g. SOF)
        -: 3360:#define stbi__DNL(x)         ((x) == 0xdc)
        -: 3361:#define stbi__SOI(x)         ((x) == 0xd8)
        -: 3362:#define stbi__EOI(x)         ((x) == 0xd9)
        -: 3363:#define stbi__SOF(x)         ((x) == 0xc0 || (x) == 0xc1 || (x) == 0xc2)
        -: 3364:#define stbi__SOS(x)         ((x) == 0xda)
        -: 3365:
        -: 3366:#define stbi__SOF_progressive(x)   ((x) == 0xc2)
        -: 3367:
function _ZL24stbi__decode_jpeg_headerP10stbi__jpegi called 0 returned 0% blocks executed 0%
    #####: 3368:static int stbi__decode_jpeg_header(stbi__jpeg *z, int scan)
        -: 3369:{
        -: 3370:   int m;
    #####: 3371:   z->jfif = 0;
    #####: 3372:   z->app14_color_transform = -1; // valid values are 0,1,2
    #####: 3373:   z->marker = STBI__MARKER_none; // initialize cached marker to empty
    #####: 3374:   m = stbi__get_marker(z);
    %%%%%: 3374-block 2
call    0 never executed
    #####: 3375:   if (!stbi__SOI(m)) return stbi__err("no SOI","Corrupt JPEG");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3375-block 4
call    2 never executed
    #####: 3376:   if (scan == STBI__SCAN_type) return 1;
    %%%%%: 3376-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3376-block 6
    #####: 3377:   m = stbi__get_marker(z);
    %%%%%: 3377-block 7
call    0 never executed
    #####: 3378:   while (!stbi__SOF(m)) {
    %%%%%: 3378-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3378-block 21
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3378-block 22
branch  4 never executed
branch  5 never executed (fallthrough)
    #####: 3379:      if (!stbi__process_marker(z,m)) return 0;
    %%%%%: 3379-block 9
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3379-block 11
    #####: 3380:      m = stbi__get_marker(z);
    %%%%%: 3380-block 12
call    0 never executed
    #####: 3381:      while (m == STBI__MARKER_none) {
    %%%%%: 3381-block 19
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 3382:         // some files have extra padding after their blocks, so ok, we'll scan
    #####: 3383:         if (stbi__at_eof(z->s)) return stbi__err("no SOF", "Corrupt JPEG");
    %%%%%: 3383-block 14
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3383-block 16
call    3 never executed
    #####: 3384:         m = stbi__get_marker(z);
    %%%%%: 3384-block 17
call    0 never executed
        -: 3385:      }
        -: 3386:   }
    #####: 3387:   z->progressive = stbi__SOF_progressive(m);
    #####: 3388:   if (!stbi__process_frame_header(z, scan)) return 0;
    %%%%%: 3388-block 23
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3388-block 25
    #####: 3389:   return 1;
    %%%%%: 3389-block 26
        -: 3390:}
        -: 3391:
function _ZL27stbi__skip_jpeg_junk_at_endP10stbi__jpeg called 0 returned 0% blocks executed 0%
    #####: 3392:static stbi_uc stbi__skip_jpeg_junk_at_end(stbi__jpeg *j)
        -: 3393:{
        -: 3394:   // some JPEGs have junk at end, skip over it but if we find what looks
        -: 3395:   // like a valid marker, resume there
    #####: 3396:   while (!stbi__at_eof(j->s)) {
    %%%%%: 3396-block 2
    %%%%%: 3396-block 13
call    0 never executed
branch  1 never executed
branch  2 never executed (fallthrough)
    #####: 3397:      stbi_uc x = stbi__get8(j->s);
    %%%%%: 3397-block 3
call    0 never executed
    #####: 3398:      while (x == 0xff) { // might be a marker
    %%%%%: 3398-block 12
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3399:         if (stbi__at_eof(j->s)) return STBI__MARKER_none;
    %%%%%: 3399-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3399-block 7
    #####: 3400:         x = stbi__get8(j->s);
    %%%%%: 3400-block 8
call    0 never executed
    #####: 3401:         if (x != 0x00 && x != 0xff) {
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3401-block 10
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 3402:            // not a stuffed zero or lead-in to another marker, looks
        -: 3403:            // like an actual marker, return it
    #####: 3404:            return x;
    %%%%%: 3404-block 11
        -: 3405:         }
        -: 3406:         // stuffed zero has x=0 now which ends the loop, meaning we go
        -: 3407:         // back to regular scan loop.
        -: 3408:         // repeated 0xff keeps trying to read the next byte of the marker.
        -: 3409:      }
        -: 3410:   }
    #####: 3411:   return STBI__MARKER_none;
    %%%%%: 3411-block 15
        -: 3412:}
        -: 3413:
        -: 3414:// decode image to YCbCr format
function _ZL23stbi__decode_jpeg_imageP10stbi__jpeg called 0 returned 0% blocks executed 0%
    #####: 3415:static int stbi__decode_jpeg_image(stbi__jpeg *j)
        -: 3416:{
        -: 3417:   int m;
    #####: 3418:   for (m = 0; m < 4; m++) {
    %%%%%: 3418-block 2
    %%%%%: 3418-block 4
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3419:      j->img_comp[m].raw_data = NULL;
    #####: 3420:      j->img_comp[m].raw_coeff = NULL;
    %%%%%: 3420-block 3
        -: 3421:   }
    #####: 3422:   j->restart_interval = 0;
    #####: 3423:   if (!stbi__decode_jpeg_header(j, STBI__SCAN_load)) return 0;
    %%%%%: 3423-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3423-block 7
    #####: 3424:   m = stbi__get_marker(j);
    %%%%%: 3424-block 8
call    0 never executed
    #####: 3425:   while (!stbi__EOI(m)) {
    %%%%%: 3425-block 39
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3426:      if (stbi__SOS(m)) {
    %%%%%: 3426-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3427:         if (!stbi__process_scan_header(j)) return 0;
    %%%%%: 3427-block 11
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3427-block 13
    #####: 3428:         if (!stbi__parse_entropy_coded_data(j)) return 0;
    %%%%%: 3428-block 14
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3428-block 16
    #####: 3429:         if (j->marker == STBI__MARKER_none ) {
    %%%%%: 3429-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3430:         j->marker = stbi__skip_jpeg_junk_at_end(j);
    %%%%%: 3430-block 18
call    0 never executed
        -: 3431:            // if we reach eof without hitting a marker, stbi__get_marker() below will fail and we'll eventually return 0
        -: 3432:         }
    #####: 3433:         m = stbi__get_marker(j);
    %%%%%: 3433-block 20
call    0 never executed
    #####: 3434:         if (STBI__RESTART(m))
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3434-block 22
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3435:            m = stbi__get_marker(j);
    %%%%%: 3435-block 23
call    0 never executed
    #####: 3436:      } else if (stbi__DNL(m)) {
    %%%%%: 3436-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3437:         int Ld = stbi__get16be(j->s);
    %%%%%: 3437-block 26
call    0 never executed
    #####: 3438:         stbi__uint32 NL = stbi__get16be(j->s);
call    0 never executed
    #####: 3439:         if (Ld != 4) return stbi__err("bad DNL len", "Corrupt JPEG");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3439-block 29
call    2 never executed
    #####: 3440:         if (NL != j->s->img_y) return stbi__err("bad DNL height", "Corrupt JPEG");
    %%%%%: 3440-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3440-block 31
call    2 never executed
    #####: 3441:         m = stbi__get_marker(j);
    %%%%%: 3441-block 32
call    0 never executed
        -: 3442:      } else {
    #####: 3443:         if (!stbi__process_marker(j, m)) return 1;
    %%%%%: 3443-block 34
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3443-block 36
    #####: 3444:         m = stbi__get_marker(j);
    %%%%%: 3444-block 37
call    0 never executed
        -: 3445:      }
        -: 3446:   }
    #####: 3447:   if (j->progressive)
    %%%%%: 3447-block 40
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3448:      stbi__jpeg_finish(j);
    %%%%%: 3448-block 41
call    0 never executed
    #####: 3449:   return 1;
    %%%%%: 3449-block 42
        -: 3450:}
        -: 3451:
        -: 3452:// static jfif-centered resampling (across block boundaries)
        -: 3453:
        -: 3454:typedef stbi_uc *(*resample_row_func)(stbi_uc *out, stbi_uc *in0, stbi_uc *in1,
        -: 3455:                                    int w, int hs);
        -: 3456:
        -: 3457:#define stbi__div4(x) ((stbi_uc) ((x) >> 2))
        -: 3458:
function _ZL14resample_row_1PhS_S_ii called 0 returned 0% blocks executed 0%
    #####: 3459:static stbi_uc *resample_row_1(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
        -: 3460:{
        -: 3461:   STBI_NOTUSED(out);
        -: 3462:   STBI_NOTUSED(in_far);
        -: 3463:   STBI_NOTUSED(w);
        -: 3464:   STBI_NOTUSED(hs);
    #####: 3465:   return in_near;
    %%%%%: 3465-block 2
        -: 3466:}
        -: 3467:
function _ZL22stbi__resample_row_v_2PhS_S_ii called 0 returned 0% blocks executed 0%
    #####: 3468:static stbi_uc* stbi__resample_row_v_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
        -: 3469:{
        -: 3470:   // need to generate two samples vertically for every one in input
        -: 3471:   int i;
        -: 3472:   STBI_NOTUSED(hs);
    #####: 3473:   for (i=0; i < w; ++i)
    %%%%%: 3473-block 2
    %%%%%: 3473-block 4
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3474:      out[i] = stbi__div4(3*in_near[i] + in_far[i] + 2);
    %%%%%: 3474-block 3
    #####: 3475:   return out;
    %%%%%: 3475-block 5
        -: 3476:}
        -: 3477:
function _ZL22stbi__resample_row_h_2PhS_S_ii called 0 returned 0% blocks executed 0%
    #####: 3478:static stbi_uc*  stbi__resample_row_h_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
        -: 3479:{
        -: 3480:   // need to generate two samples horizontally for every one in input
        -: 3481:   int i;
    #####: 3482:   stbi_uc *input = in_near;
        -: 3483:
    #####: 3484:   if (w == 1) {
    %%%%%: 3484-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3485:      // if only one sample, can't do any interpolation
    #####: 3486:      out[0] = out[1] = input[0];
    #####: 3487:      return out;
    %%%%%: 3487-block 3
        -: 3488:   }
        -: 3489:
    #####: 3490:   out[0] = input[0];
    #####: 3491:   out[1] = stbi__div4(input[0]*3 + input[1] + 2);
    #####: 3492:   for (i=1; i < w-1; ++i) {
    %%%%%: 3492-block 4
    %%%%%: 3492-block 6
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3493:      int n = 3*input[i]+2;
    #####: 3494:      out[i*2+0] = stbi__div4(n+input[i-1]);
    #####: 3495:      out[i*2+1] = stbi__div4(n+input[i+1]);
    %%%%%: 3495-block 5
        -: 3496:   }
    #####: 3497:   out[i*2+0] = stbi__div4(input[w-2]*3 + input[w-1] + 2);
    #####: 3498:   out[i*2+1] = input[w-1];
        -: 3499:
        -: 3500:   STBI_NOTUSED(in_far);
        -: 3501:   STBI_NOTUSED(hs);
        -: 3502:
    #####: 3503:   return out;
    %%%%%: 3503-block 7
        -: 3504:}
        -: 3505:
        -: 3506:#define stbi__div16(x) ((stbi_uc) ((x) >> 4))
        -: 3507:
function _ZL23stbi__resample_row_hv_2PhS_S_ii called 0 returned 0% blocks executed 0%
    #####: 3508:static stbi_uc *stbi__resample_row_hv_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
        -: 3509:{
        -: 3510:   // need to generate 2x2 samples for every one in input
        -: 3511:   int i,t0,t1;
    #####: 3512:   if (w == 1) {
    %%%%%: 3512-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3513:      out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);
    #####: 3514:      return out;
    %%%%%: 3514-block 3
        -: 3515:   }
        -: 3516:
    #####: 3517:   t1 = 3*in_near[0] + in_far[0];
    #####: 3518:   out[0] = stbi__div4(t1+2);
    #####: 3519:   for (i=1; i < w; ++i) {
    %%%%%: 3519-block 4
    %%%%%: 3519-block 6
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3520:      t0 = t1;
    #####: 3521:      t1 = 3*in_near[i]+in_far[i];
    #####: 3522:      out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
    #####: 3523:      out[i*2  ] = stbi__div16(3*t1 + t0 + 8);
    %%%%%: 3523-block 5
        -: 3524:   }
    #####: 3525:   out[w*2-1] = stbi__div4(t1+2);
        -: 3526:
        -: 3527:   STBI_NOTUSED(hs);
        -: 3528:
    #####: 3529:   return out;
    %%%%%: 3529-block 7
        -: 3530:}
        -: 3531:
        -: 3532:#if defined(STBI_SSE2) || defined(STBI_NEON)
function _ZL28stbi__resample_row_hv_2_simdPhS_S_ii called 0 returned 0% blocks executed 0%
    #####: 3533:static stbi_uc *stbi__resample_row_hv_2_simd(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
        -: 3534:{
        -: 3535:   // need to generate 2x2 samples for every one in input
    #####: 3536:   int i=0,t0,t1;
        -: 3537:
    #####: 3538:   if (w == 1) {
    %%%%%: 3538-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3539:      out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);
    #####: 3540:      return out;
    %%%%%: 3540-block 3
        -: 3541:   }
        -: 3542:
    #####: 3543:   t1 = 3*in_near[0] + in_far[0];
        -: 3544:   // process groups of 8 pixels for as long as we can.
        -: 3545:   // note we can't handle the last pixel in a row in this loop
        -: 3546:   // because we need to handle the filter boundary conditions.
    #####: 3547:   for (; i < ((w-1) & ~7); i += 8) {
    %%%%%: 3547-block 4
    %%%%%: 3547-block 57
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 3548:#if defined(STBI_SSE2)
        -: 3549:      // load and perform the vertical filtering pass
        -: 3550:      // this uses 3*x + y = 4*x + (y - x)
    #####: 3551:      __m128i zero  = _mm_setzero_si128();
    #####: 3552:      __m128i farb  = _mm_loadl_epi64((__m128i *) (in_far + i));
    %%%%%: 3552-block 7
    #####: 3553:      __m128i nearb = _mm_loadl_epi64((__m128i *) (in_near + i));
    %%%%%: 3553-block 13
    %%%%%: 3553-block 19
    #####: 3554:      __m128i farw  = _mm_unpacklo_epi8(farb, zero);
    %%%%%: 3554-block 21
    #####: 3555:      __m128i nearw = _mm_unpacklo_epi8(nearb, zero);
    %%%%%: 3555-block 23
    #####: 3556:      __m128i diff  = _mm_sub_epi16(farw, nearw);
    %%%%%: 3556-block 25
    #####: 3557:      __m128i nears = _mm_slli_epi16(nearw, 2);
    %%%%%: 3557-block 27
    #####: 3558:      __m128i curr  = _mm_add_epi16(nears, diff); // current row
        -: 3559:
        -: 3560:      // horizontal filter works the same based on shifted vers of current
        -: 3561:      // row. "prev" is current row shifted right by 1 pixel; we need to
        -: 3562:      // insert the previous pixel value (from t1).
        -: 3563:      // "next" is current row shifted left by 1 pixel, with first pixel
        -: 3564:      // of next block of 8 pixels added in.
    #####: 3565:      __m128i prv0 = _mm_slli_si128(curr, 2);
    #####: 3566:      __m128i nxt0 = _mm_srli_si128(curr, 2);
    #####: 3567:      __m128i prev = _mm_insert_epi16(prv0, t1, 0);
    #####: 3568:      __m128i next = _mm_insert_epi16(nxt0, 3*in_near[i+8] + in_far[i+8], 7);
    %%%%%: 3568-block 29
        -: 3569:
        -: 3570:      // horizontal filter, polyphase implementation since it's convenient:
        -: 3571:      // even pixels = 3*cur + prev = cur*4 + (prev - cur)
        -: 3572:      // odd  pixels = 3*cur + next = cur*4 + (next - cur)
        -: 3573:      // note the shared term.
    #####: 3574:      __m128i bias  = _mm_set1_epi16(8);
    %%%%%: 3574-block 33
    #####: 3575:      __m128i curs = _mm_slli_epi16(curr, 2);
    %%%%%: 3575-block 35
    #####: 3576:      __m128i prvd = _mm_sub_epi16(prev, curr);
    %%%%%: 3576-block 37
    #####: 3577:      __m128i nxtd = _mm_sub_epi16(next, curr);
    %%%%%: 3577-block 39
    #####: 3578:      __m128i curb = _mm_add_epi16(curs, bias);
    %%%%%: 3578-block 41
    #####: 3579:      __m128i even = _mm_add_epi16(prvd, curb);
    %%%%%: 3579-block 43
    #####: 3580:      __m128i odd  = _mm_add_epi16(nxtd, curb);
    %%%%%: 3580-block 45
        -: 3581:
        -: 3582:      // interleave even and odd pixels, then undo scaling.
    #####: 3583:      __m128i int0 = _mm_unpacklo_epi16(even, odd);
    %%%%%: 3583-block 47
    #####: 3584:      __m128i int1 = _mm_unpackhi_epi16(even, odd);
    %%%%%: 3584-block 49
    #####: 3585:      __m128i de0  = _mm_srli_epi16(int0, 4);
    %%%%%: 3585-block 51
    #####: 3586:      __m128i de1  = _mm_srli_epi16(int1, 4);
    %%%%%: 3586-block 53
        -: 3587:
        -: 3588:      // pack and write output
    #####: 3589:      __m128i outv = _mm_packus_epi16(de0, de1);
    #####: 3590:      _mm_storeu_si128((__m128i *) (out + i*2), outv);
    %%%%%: 3590-block 55
        -: 3591:#elif defined(STBI_NEON)
        -: 3592:      // load and perform the vertical filtering pass
        -: 3593:      // this uses 3*x + y = 4*x + (y - x)
        -: 3594:      uint8x8_t farb  = vld1_u8(in_far + i);
        -: 3595:      uint8x8_t nearb = vld1_u8(in_near + i);
        -: 3596:      int16x8_t diff  = vreinterpretq_s16_u16(vsubl_u8(farb, nearb));
        -: 3597:      int16x8_t nears = vreinterpretq_s16_u16(vshll_n_u8(nearb, 2));
        -: 3598:      int16x8_t curr  = vaddq_s16(nears, diff); // current row
        -: 3599:
        -: 3600:      // horizontal filter works the same based on shifted vers of current
        -: 3601:      // row. "prev" is current row shifted right by 1 pixel; we need to
        -: 3602:      // insert the previous pixel value (from t1).
        -: 3603:      // "next" is current row shifted left by 1 pixel, with first pixel
        -: 3604:      // of next block of 8 pixels added in.
        -: 3605:      int16x8_t prv0 = vextq_s16(curr, curr, 7);
        -: 3606:      int16x8_t nxt0 = vextq_s16(curr, curr, 1);
        -: 3607:      int16x8_t prev = vsetq_lane_s16(t1, prv0, 0);
        -: 3608:      int16x8_t next = vsetq_lane_s16(3*in_near[i+8] + in_far[i+8], nxt0, 7);
        -: 3609:
        -: 3610:      // horizontal filter, polyphase implementation since it's convenient:
        -: 3611:      // even pixels = 3*cur + prev = cur*4 + (prev - cur)
        -: 3612:      // odd  pixels = 3*cur + next = cur*4 + (next - cur)
        -: 3613:      // note the shared term.
        -: 3614:      int16x8_t curs = vshlq_n_s16(curr, 2);
        -: 3615:      int16x8_t prvd = vsubq_s16(prev, curr);
        -: 3616:      int16x8_t nxtd = vsubq_s16(next, curr);
        -: 3617:      int16x8_t even = vaddq_s16(curs, prvd);
        -: 3618:      int16x8_t odd  = vaddq_s16(curs, nxtd);
        -: 3619:
        -: 3620:      // undo scaling and round, then store with even/odd phases interleaved
        -: 3621:      uint8x8x2_t o;
        -: 3622:      o.val[0] = vqrshrun_n_s16(even, 4);
        -: 3623:      o.val[1] = vqrshrun_n_s16(odd,  4);
        -: 3624:      vst2_u8(out + i*2, o);
        -: 3625:#endif
        -: 3626:
        -: 3627:      // "previous" value for next iter
    #####: 3628:      t1 = 3*in_near[i+7] + in_far[i+7];
    %%%%%: 3628-block 56
        -: 3629:   }
        -: 3630:
    #####: 3631:   t0 = t1;
    #####: 3632:   t1 = 3*in_near[i] + in_far[i];
    #####: 3633:   out[i*2] = stbi__div16(3*t1 + t0 + 8);
        -: 3634:
    #####: 3635:   for (++i; i < w; ++i) {
    %%%%%: 3635-block 58
    %%%%%: 3635-block 60
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3636:      t0 = t1;
    #####: 3637:      t1 = 3*in_near[i]+in_far[i];
    #####: 3638:      out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
    #####: 3639:      out[i*2  ] = stbi__div16(3*t1 + t0 + 8);
    %%%%%: 3639-block 59
        -: 3640:   }
    #####: 3641:   out[w*2-1] = stbi__div4(t1+2);
        -: 3642:
        -: 3643:   STBI_NOTUSED(hs);
        -: 3644:
    #####: 3645:   return out;
    %%%%%: 3645-block 61
        -: 3646:}
        -: 3647:#endif
        -: 3648:
function _ZL26stbi__resample_row_genericPhS_S_ii called 0 returned 0% blocks executed 0%
    #####: 3649:static stbi_uc *stbi__resample_row_generic(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
        -: 3650:{
        -: 3651:   // resample with nearest-neighbor
        -: 3652:   int i,j;
        -: 3653:   STBI_NOTUSED(in_far);
    #####: 3654:   for (i=0; i < w; ++i)
    %%%%%: 3654-block 2
    %%%%%: 3654-block 6
    %%%%%: 3654-block 7
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3655:      for (j=0; j < hs; ++j)
    %%%%%: 3655-block 3
    %%%%%: 3655-block 5
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3656:         out[i*hs+j] = in_near[i];
    %%%%%: 3656-block 4
    #####: 3657:   return out;
    %%%%%: 3657-block 8
        -: 3658:}
        -: 3659:
        -: 3660:// this is a reduced-precision calculation of YCbCr-to-RGB introduced
        -: 3661:// to make sure the code produces the same results in both SIMD and scalar
        -: 3662:#define stbi__float2fixed(x)  (((int) ((x) * 4096.0f + 0.5f)) << 8)
function _ZL22stbi__YCbCr_to_RGB_rowPhPKhS1_S1_ii called 0 returned 0% blocks executed 0%
    #####: 3663:static void stbi__YCbCr_to_RGB_row(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step)
        -: 3664:{
        -: 3665:   int i;
    #####: 3666:   for (i=0; i < count; ++i) {
    %%%%%: 3666-block 2
    %%%%%: 3666-block 16
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3667:      int y_fixed = (y[i] << 20) + (1<<19); // rounding
        -: 3668:      int r,g,b;
    #####: 3669:      int cr = pcr[i] - 128;
    #####: 3670:      int cb = pcb[i] - 128;
    #####: 3671:      r = y_fixed +  cr* stbi__float2fixed(1.40200f);
    #####: 3672:      g = y_fixed + (cr*-stbi__float2fixed(0.71414f)) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
    #####: 3673:      b = y_fixed                                     +   cb* stbi__float2fixed(1.77200f);
    #####: 3674:      r >>= 20;
    #####: 3675:      g >>= 20;
    #####: 3676:      b >>= 20;
    #####: 3677:      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
    %%%%%: 3677-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3677-block 4
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3677-block 5
    %%%%%: 3677-block 6
    #####: 3678:      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
    %%%%%: 3678-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3678-block 8
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3678-block 9
    %%%%%: 3678-block 10
    #####: 3679:      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
    %%%%%: 3679-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3679-block 12
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3679-block 13
    %%%%%: 3679-block 14
    #####: 3680:      out[0] = (stbi_uc)r;
    #####: 3681:      out[1] = (stbi_uc)g;
    #####: 3682:      out[2] = (stbi_uc)b;
    #####: 3683:      out[3] = 255;
    #####: 3684:      out += step;
    %%%%%: 3684-block 15
        -: 3685:   }
    #####: 3686:}
        -: 3687:
        -: 3688:#if defined(STBI_SSE2) || defined(STBI_NEON)
function _ZL23stbi__YCbCr_to_RGB_simdPhPKhS1_S1_ii called 0 returned 0% blocks executed 0%
    #####: 3689:static void stbi__YCbCr_to_RGB_simd(stbi_uc *out, stbi_uc const *y, stbi_uc const *pcb, stbi_uc const *pcr, int count, int step)
        -: 3690:{
    #####: 3691:   int i = 0;
        -: 3692:
        -: 3693:#ifdef STBI_SSE2
        -: 3694:   // step == 3 is pretty ugly on the final interleave, and i'm not convinced
        -: 3695:   // it's useful in practice (you wouldn't use it for textures, for example).
        -: 3696:   // so just accelerate step == 4 case.
    #####: 3697:   if (step == 4) {
    %%%%%: 3697-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3698:      // this is a fairly straightforward implementation and not super-optimized.
    #####: 3699:      __m128i signflip  = _mm_set1_epi8(-0x80);
    %%%%%: 3699-block 7
    #####: 3700:      __m128i cr_const0 = _mm_set1_epi16(   (short) ( 1.40200f*4096.0f+0.5f));
    %%%%%: 3700-block 11
    #####: 3701:      __m128i cr_const1 = _mm_set1_epi16( - (short) ( 0.71414f*4096.0f+0.5f));
    %%%%%: 3701-block 15
    #####: 3702:      __m128i cb_const0 = _mm_set1_epi16( - (short) ( 0.34414f*4096.0f+0.5f));
    %%%%%: 3702-block 19
    #####: 3703:      __m128i cb_const1 = _mm_set1_epi16(   (short) ( 1.77200f*4096.0f+0.5f));
    %%%%%: 3703-block 23
    #####: 3704:      __m128i y_bias = _mm_set1_epi8((char) (unsigned char) 128);
    %%%%%: 3704-block 27
    #####: 3705:      __m128i xw = _mm_set1_epi16(255); // alpha channel
        -: 3706:
    #####: 3707:      for (; i+7 < count; i += 8) {
    %%%%%: 3707-block 31
    %%%%%: 3707-block 103
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 3708:         // load
    #####: 3709:         __m128i y_bytes = _mm_loadl_epi64((__m128i *) (y+i));
    %%%%%: 3709-block 32
    #####: 3710:         __m128i cr_bytes = _mm_loadl_epi64((__m128i *) (pcr+i));
    %%%%%: 3710-block 38
    #####: 3711:         __m128i cb_bytes = _mm_loadl_epi64((__m128i *) (pcb+i));
    %%%%%: 3711-block 44
    %%%%%: 3711-block 50
    #####: 3712:         __m128i cr_biased = _mm_xor_si128(cr_bytes, signflip); // -128
    %%%%%: 3712-block 52
    #####: 3713:         __m128i cb_biased = _mm_xor_si128(cb_bytes, signflip); // -128
    %%%%%: 3713-block 54
        -: 3714:
        -: 3715:         // unpack to short (and left-shift cr, cb by 8)
    #####: 3716:         __m128i yw  = _mm_unpacklo_epi8(y_bias, y_bytes);
    %%%%%: 3716-block 56
    #####: 3717:         __m128i crw = _mm_unpacklo_epi8(_mm_setzero_si128(), cr_biased);
    %%%%%: 3717-block 58
    %%%%%: 3717-block 60
    #####: 3718:         __m128i cbw = _mm_unpacklo_epi8(_mm_setzero_si128(), cb_biased);
    %%%%%: 3718-block 62
    %%%%%: 3718-block 64
        -: 3719:
        -: 3720:         // color transform
    #####: 3721:         __m128i yws = _mm_srli_epi16(yw, 4);
    %%%%%: 3721-block 66
    #####: 3722:         __m128i cr0 = _mm_mulhi_epi16(cr_const0, crw);
    %%%%%: 3722-block 68
    #####: 3723:         __m128i cb0 = _mm_mulhi_epi16(cb_const0, cbw);
    %%%%%: 3723-block 70
    #####: 3724:         __m128i cb1 = _mm_mulhi_epi16(cbw, cb_const1);
    %%%%%: 3724-block 72
    #####: 3725:         __m128i cr1 = _mm_mulhi_epi16(crw, cr_const1);
    %%%%%: 3725-block 74
    #####: 3726:         __m128i rws = _mm_add_epi16(cr0, yws);
    %%%%%: 3726-block 76
    #####: 3727:         __m128i gwt = _mm_add_epi16(cb0, yws);
    %%%%%: 3727-block 78
    #####: 3728:         __m128i bws = _mm_add_epi16(yws, cb1);
    %%%%%: 3728-block 80
    #####: 3729:         __m128i gws = _mm_add_epi16(gwt, cr1);
    %%%%%: 3729-block 82
        -: 3730:
        -: 3731:         // descale
    #####: 3732:         __m128i rw = _mm_srai_epi16(rws, 4);
    %%%%%: 3732-block 84
    #####: 3733:         __m128i bw = _mm_srai_epi16(bws, 4);
    %%%%%: 3733-block 86
    #####: 3734:         __m128i gw = _mm_srai_epi16(gws, 4);
    %%%%%: 3734-block 88
        -: 3735:
        -: 3736:         // back to byte, set up for transpose
    #####: 3737:         __m128i brb = _mm_packus_epi16(rw, bw);
    %%%%%: 3737-block 90
    #####: 3738:         __m128i gxb = _mm_packus_epi16(gw, xw);
    %%%%%: 3738-block 92
        -: 3739:
        -: 3740:         // transpose to interleave channels
    #####: 3741:         __m128i t0 = _mm_unpacklo_epi8(brb, gxb);
    %%%%%: 3741-block 94
    #####: 3742:         __m128i t1 = _mm_unpackhi_epi8(brb, gxb);
    %%%%%: 3742-block 96
    #####: 3743:         __m128i o0 = _mm_unpacklo_epi16(t0, t1);
    %%%%%: 3743-block 98
    #####: 3744:         __m128i o1 = _mm_unpackhi_epi16(t0, t1);
    %%%%%: 3744-block 100
        -: 3745:
        -: 3746:         // store
        -: 3747:         _mm_storeu_si128((__m128i *) (out + 0), o0);
    #####: 3748:         _mm_storeu_si128((__m128i *) (out + 16), o1);
    %%%%%: 3748-block 101
    #####: 3749:         out += 32;
    %%%%%: 3749-block 102
        -: 3750:      }
        -: 3751:   }
        -: 3752:#endif
        -: 3753:
        -: 3754:#ifdef STBI_NEON
        -: 3755:   // in this version, step=3 support would be easy to add. but is there demand?
        -: 3756:   if (step == 4) {
        -: 3757:      // this is a fairly straightforward implementation and not super-optimized.
        -: 3758:      uint8x8_t signflip = vdup_n_u8(0x80);
        -: 3759:      int16x8_t cr_const0 = vdupq_n_s16(   (short) ( 1.40200f*4096.0f+0.5f));
        -: 3760:      int16x8_t cr_const1 = vdupq_n_s16( - (short) ( 0.71414f*4096.0f+0.5f));
        -: 3761:      int16x8_t cb_const0 = vdupq_n_s16( - (short) ( 0.34414f*4096.0f+0.5f));
        -: 3762:      int16x8_t cb_const1 = vdupq_n_s16(   (short) ( 1.77200f*4096.0f+0.5f));
        -: 3763:
        -: 3764:      for (; i+7 < count; i += 8) {
        -: 3765:         // load
        -: 3766:         uint8x8_t y_bytes  = vld1_u8(y + i);
        -: 3767:         uint8x8_t cr_bytes = vld1_u8(pcr + i);
        -: 3768:         uint8x8_t cb_bytes = vld1_u8(pcb + i);
        -: 3769:         int8x8_t cr_biased = vreinterpret_s8_u8(vsub_u8(cr_bytes, signflip));
        -: 3770:         int8x8_t cb_biased = vreinterpret_s8_u8(vsub_u8(cb_bytes, signflip));
        -: 3771:
        -: 3772:         // expand to s16
        -: 3773:         int16x8_t yws = vreinterpretq_s16_u16(vshll_n_u8(y_bytes, 4));
        -: 3774:         int16x8_t crw = vshll_n_s8(cr_biased, 7);
        -: 3775:         int16x8_t cbw = vshll_n_s8(cb_biased, 7);
        -: 3776:
        -: 3777:         // color transform
        -: 3778:         int16x8_t cr0 = vqdmulhq_s16(crw, cr_const0);
        -: 3779:         int16x8_t cb0 = vqdmulhq_s16(cbw, cb_const0);
        -: 3780:         int16x8_t cr1 = vqdmulhq_s16(crw, cr_const1);
        -: 3781:         int16x8_t cb1 = vqdmulhq_s16(cbw, cb_const1);
        -: 3782:         int16x8_t rws = vaddq_s16(yws, cr0);
        -: 3783:         int16x8_t gws = vaddq_s16(vaddq_s16(yws, cb0), cr1);
        -: 3784:         int16x8_t bws = vaddq_s16(yws, cb1);
        -: 3785:
        -: 3786:         // undo scaling, round, convert to byte
        -: 3787:         uint8x8x4_t o;
        -: 3788:         o.val[0] = vqrshrun_n_s16(rws, 4);
        -: 3789:         o.val[1] = vqrshrun_n_s16(gws, 4);
        -: 3790:         o.val[2] = vqrshrun_n_s16(bws, 4);
        -: 3791:         o.val[3] = vdup_n_u8(255);
        -: 3792:
        -: 3793:         // store, interleaving r/g/b/a
        -: 3794:         vst4_u8(out, o);
        -: 3795:         out += 8*4;
        -: 3796:      }
        -: 3797:   }
        -: 3798:#endif
        -: 3799:
    #####: 3800:   for (; i < count; ++i) {
    %%%%%: 3800-block 104
    %%%%%: 3800-block 118
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3801:      int y_fixed = (y[i] << 20) + (1<<19); // rounding
        -: 3802:      int r,g,b;
    #####: 3803:      int cr = pcr[i] - 128;
    #####: 3804:      int cb = pcb[i] - 128;
    #####: 3805:      r = y_fixed + cr* stbi__float2fixed(1.40200f);
    #####: 3806:      g = y_fixed + cr*-stbi__float2fixed(0.71414f) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
    #####: 3807:      b = y_fixed                                   +   cb* stbi__float2fixed(1.77200f);
    #####: 3808:      r >>= 20;
    #####: 3809:      g >>= 20;
    #####: 3810:      b >>= 20;
    #####: 3811:      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
    %%%%%: 3811-block 105
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3811-block 106
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3811-block 107
    %%%%%: 3811-block 108
    #####: 3812:      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
    %%%%%: 3812-block 109
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3812-block 110
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3812-block 111
    %%%%%: 3812-block 112
    #####: 3813:      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
    %%%%%: 3813-block 113
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3813-block 114
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3813-block 115
    %%%%%: 3813-block 116
    #####: 3814:      out[0] = (stbi_uc)r;
    #####: 3815:      out[1] = (stbi_uc)g;
    #####: 3816:      out[2] = (stbi_uc)b;
    #####: 3817:      out[3] = 255;
    #####: 3818:      out += step;
    %%%%%: 3818-block 117
        -: 3819:   }
    #####: 3820:}
        -: 3821:#endif
        -: 3822:
        -: 3823:// set up the kernels
function _ZL16stbi__setup_jpegP10stbi__jpeg called 0 returned 0% blocks executed 0%
    #####: 3824:static void stbi__setup_jpeg(stbi__jpeg *j)
        -: 3825:{
    #####: 3826:   j->idct_block_kernel = stbi__idct_block;
    #####: 3827:   j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_row;
    #####: 3828:   j->resample_row_hv_2_kernel = stbi__resample_row_hv_2;
        -: 3829:
        -: 3830:#ifdef STBI_SSE2
    #####: 3831:   if (stbi__sse2_available()) {
    %%%%%: 3831-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 3832:      j->idct_block_kernel = stbi__idct_simd;
    #####: 3833:      j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
    #####: 3834:      j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
    %%%%%: 3834-block 4
        -: 3835:   }
        -: 3836:#endif
        -: 3837:
        -: 3838:#ifdef STBI_NEON
        -: 3839:   j->idct_block_kernel = stbi__idct_simd;
        -: 3840:   j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
        -: 3841:   j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
        -: 3842:#endif
    #####: 3843:}
        -: 3844:
        -: 3845:// clean up the temporary component buffers
function _ZL18stbi__cleanup_jpegP10stbi__jpeg called 0 returned 0% blocks executed 0%
    #####: 3846:static void stbi__cleanup_jpeg(stbi__jpeg *j)
        -: 3847:{
    #####: 3848:   stbi__free_jpeg_components(j, j->s->img_n, 0);
    %%%%%: 3848-block 2
call    0 never executed
    #####: 3849:}
        -: 3850:
        -: 3851:typedef struct
        -: 3852:{
        -: 3853:   resample_row_func resample;
        -: 3854:   stbi_uc *line0,*line1;
        -: 3855:   int hs,vs;   // expansion factor in each axis
        -: 3856:   int w_lores; // horizontal pixels pre-expansion
        -: 3857:   int ystep;   // how far through vertical expansion we are
        -: 3858:   int ypos;    // which pre-expansion row we're on
        -: 3859:} stbi__resample;
        -: 3860:
        -: 3861:// fast 0..255 * 0..255 => 0..255 rounded multiplication
function _ZL15stbi__blinn_8x8hh called 0 returned 0% blocks executed 0%
    #####: 3862:static stbi_uc stbi__blinn_8x8(stbi_uc x, stbi_uc y)
        -: 3863:{
    #####: 3864:   unsigned int t = x*y + 128;
    #####: 3865:   return (stbi_uc) ((t + (t >>8)) >> 8);
    %%%%%: 3865-block 2
        -: 3866:}
        -: 3867:
function _ZL15load_jpeg_imageP10stbi__jpegPiS1_S1_i called 0 returned 0% blocks executed 0%
    #####: 3868:static stbi_uc *load_jpeg_image(stbi__jpeg *z, int *out_x, int *out_y, int *comp, int req_comp)
        -: 3869:{
        -: 3870:   int n, decode_n, is_rgb;
    #####: 3871:   z->s->img_n = 0; // make stbi__cleanup_jpeg safe
        -: 3872:
        -: 3873:   // validate req_comp
    #####: 3874:   if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");
    %%%%%: 3874-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3874-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3874-block 4
call    4 never executed
        -: 3875:
        -: 3876:   // load a jpeg image from whichever source, but leave in YCbCr format
    #####: 3877:   if (!stbi__decode_jpeg_image(z)) { stbi__cleanup_jpeg(z); return NULL; }
    %%%%%: 3877-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3877-block 8
call    3 never executed
        -: 3878:
        -: 3879:   // determine actual number of components to generate
    #####: 3880:   n = req_comp ? req_comp : z->s->img_n >= 3 ? 3 : 1;
    %%%%%: 3880-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3880-block 11
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3880-block 12
    %%%%%: 3880-block 13
    %%%%%: 3880-block 14
    %%%%%: 3880-block 15
        -: 3881:
    #####: 3882:   is_rgb = z->s->img_n == 3 && (z->rgb == 3 || (z->app14_color_transform == 0 && !z->jfif));
    %%%%%: 3882-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3882-block 17
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3882-block 18
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 3882-block 19
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 3882-block 20
    %%%%%: 3882-block 21
        -: 3883:
    #####: 3884:   if (z->s->img_n == 3 && n < 3 && !is_rgb)
    %%%%%: 3884-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3884-block 23
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3884-block 24
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 3885:      decode_n = 1;
    %%%%%: 3885-block 25
        -: 3886:   else
    #####: 3887:      decode_n = z->s->img_n;
    %%%%%: 3887-block 26
        -: 3888:
        -: 3889:   // nothing to do if no components requested; check this now to avoid
        -: 3890:   // accessing uninitialized coutput[0] later
    #####: 3891:   if (decode_n <= 0) { stbi__cleanup_jpeg(z); return NULL; }
    %%%%%: 3891-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3891-block 28
call    2 never executed
        -: 3892:
        -: 3893:   // resample and color-convert
        -: 3894:   {
        -: 3895:      int k;
        -: 3896:      unsigned int i,j;
        -: 3897:      stbi_uc *output;
    #####: 3898:      stbi_uc *coutput[4] = { NULL, NULL, NULL, NULL };
        -: 3899:
        -: 3900:      stbi__resample res_comp[4];
        -: 3901:
    #####: 3902:      for (k=0; k < decode_n; ++k) {
    %%%%%: 3902-block 30
    %%%%%: 3902-block 49
    %%%%%: 3902-block 50
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3903:         stbi__resample *r = &res_comp[k];
        -: 3904:
        -: 3905:         // allocate line buffer big enough for upsampling off the edges
        -: 3906:         // with upsample factor of 4
    #####: 3907:         z->img_comp[k].linebuf = (stbi_uc *) stbi__malloc(z->s->img_x + 3);
    %%%%%: 3907-block 31
call    0 never executed
    #####: 3908:         if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3908-block 33
call    2 never executed
call    3 never executed
        -: 3909:
    #####: 3910:         r->hs      = z->img_h_max / z->img_comp[k].h;
    #####: 3911:         r->vs      = z->img_v_max / z->img_comp[k].v;
    #####: 3912:         r->ystep   = r->vs >> 1;
    #####: 3913:         r->w_lores = (z->s->img_x + r->hs-1) / r->hs;
    #####: 3914:         r->ypos    = 0;
    #####: 3915:         r->line0   = r->line1 = z->img_comp[k].data;
        -: 3916:
    #####: 3917:         if      (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;
    %%%%%: 3917-block 36
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3917-block 37
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3917-block 38
    #####: 3918:         else if (r->hs == 1 && r->vs == 2) r->resample = stbi__resample_row_v_2;
    %%%%%: 3918-block 39
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3918-block 40
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3918-block 41
    #####: 3919:         else if (r->hs == 2 && r->vs == 1) r->resample = stbi__resample_row_h_2;
    %%%%%: 3919-block 42
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3919-block 43
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3919-block 44
    #####: 3920:         else if (r->hs == 2 && r->vs == 2) r->resample = z->resample_row_hv_2_kernel;
    %%%%%: 3920-block 45
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3920-block 46
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3920-block 47
    #####: 3921:         else                               r->resample = stbi__resample_row_generic;
    %%%%%: 3921-block 48
        -: 3922:      }
        -: 3923:
        -: 3924:      // can't error after this so, this is safe
    #####: 3925:      output = (stbi_uc *) stbi__malloc_mad3(n, z->s->img_x, z->s->img_y, 1);
    %%%%%: 3925-block 51
call    0 never executed
    #####: 3926:      if (!output) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3926-block 53
call    2 never executed
call    3 never executed
        -: 3927:
        -: 3928:      // now go ahead and resample
    #####: 3929:      for (j=0; j < z->s->img_y; ++j) {
    %%%%%: 3929-block 56
    %%%%%: 3929-block 131
    %%%%%: 3929-block 132
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3930:         stbi_uc *out = output + n * z->s->img_x * j;
    #####: 3931:         for (k=0; k < decode_n; ++k) {
    %%%%%: 3931-block 57
    %%%%%: 3931-block 68
    %%%%%: 3931-block 69
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3932:            stbi__resample *r = &res_comp[k];
    #####: 3933:            int y_bot = r->ystep >= (r->vs >> 1);
    #####: 3934:            coutput[k] = r->resample(z->img_comp[k].linebuf,
    %%%%%: 3934-block 58
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3934-block 59
    %%%%%: 3934-block 60
    %%%%%: 3934-block 61
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3934-block 62
    %%%%%: 3934-block 63
    %%%%%: 3934-block 64
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
        -: 3935:                                     y_bot ? r->line1 : r->line0,
        -: 3936:                                     y_bot ? r->line0 : r->line1,
        -: 3937:                                     r->w_lores, r->hs);
    #####: 3938:            if (++r->ystep >= r->vs) {
    %%%%%: 3938-block 65
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3939:               r->ystep = 0;
    #####: 3940:               r->line0 = r->line1;
    #####: 3941:               if (++r->ypos < z->img_comp[k].y)
    %%%%%: 3941-block 66
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3942:                  r->line1 += z->img_comp[k].w2;
    %%%%%: 3942-block 67
        -: 3943:            }
        -: 3944:         }
    #####: 3945:         if (n >= 3) {
    %%%%%: 3945-block 70
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3946:            stbi_uc *y = coutput[0];
    #####: 3947:            if (z->s->img_n == 3) {
    %%%%%: 3947-block 71
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3948:               if (is_rgb) {
    %%%%%: 3948-block 72
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3949:                  for (i=0; i < z->s->img_x; ++i) {
    %%%%%: 3949-block 73
    %%%%%: 3949-block 75
branch  0 never executed
branch  1 never executed
    #####: 3950:                     out[0] = y[i];
    #####: 3951:                     out[1] = coutput[1][i];
    #####: 3952:                     out[2] = coutput[2][i];
    #####: 3953:                     out[3] = 255;
    #####: 3954:                     out += n;
    %%%%%: 3954-block 74
        -: 3955:                  }
        -: 3956:               } else {
    #####: 3957:                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
    %%%%%: 3957-block 76
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 3958:               }
    #####: 3959:            } else if (z->s->img_n == 4) {
    %%%%%: 3959-block 77
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3960:               if (z->app14_color_transform == 0) { // CMYK
    %%%%%: 3960-block 78
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3961:                  for (i=0; i < z->s->img_x; ++i) {
    %%%%%: 3961-block 79
    %%%%%: 3961-block 84
branch  0 never executed
branch  1 never executed
    #####: 3962:                     stbi_uc m = coutput[3][i];
    #####: 3963:                     out[0] = stbi__blinn_8x8(coutput[0][i], m);
    %%%%%: 3963-block 80
call    0 never executed
    #####: 3964:                     out[1] = stbi__blinn_8x8(coutput[1][i], m);
call    0 never executed
    #####: 3965:                     out[2] = stbi__blinn_8x8(coutput[2][i], m);
call    0 never executed
    #####: 3966:                     out[3] = 255;
    #####: 3967:                     out += n;
        -: 3968:                  }
    #####: 3969:               } else if (z->app14_color_transform == 2) { // YCCK
    %%%%%: 3969-block 85
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3970:                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
    %%%%%: 3970-block 86
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3971:                  for (i=0; i < z->s->img_x; ++i) {
    %%%%%: 3971-block 87
    %%%%%: 3971-block 92
branch  0 never executed
branch  1 never executed
    #####: 3972:                     stbi_uc m = coutput[3][i];
    #####: 3973:                     out[0] = stbi__blinn_8x8(255 - out[0], m);
    %%%%%: 3973-block 88
call    0 never executed
    #####: 3974:                     out[1] = stbi__blinn_8x8(255 - out[1], m);
call    0 never executed
    #####: 3975:                     out[2] = stbi__blinn_8x8(255 - out[2], m);
call    0 never executed
    #####: 3976:                     out += n;
        -: 3977:                  }
        -: 3978:               } else { // YCbCr + alpha?  Ignore the fourth channel for now
    #####: 3979:                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
    %%%%%: 3979-block 93
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 3980:               }
        -: 3981:            } else
    #####: 3982:               for (i=0; i < z->s->img_x; ++i) {
    %%%%%: 3982-block 94
    %%%%%: 3982-block 96
branch  0 never executed
branch  1 never executed
    #####: 3983:                  out[0] = out[1] = out[2] = y[i];
    #####: 3984:                  out[3] = 255; // not used if n==3
    #####: 3985:                  out += n;
    %%%%%: 3985-block 95
        -: 3986:               }
        -: 3987:         } else {
    #####: 3988:            if (is_rgb) {
    %%%%%: 3988-block 97
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3989:               if (n == 1)
    %%%%%: 3989-block 98
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3990:                  for (i=0; i < z->s->img_x; ++i)
    %%%%%: 3990-block 99
    %%%%%: 3990-block 102
branch  0 never executed
branch  1 never executed
    #####: 3991:                     *out++ = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
    %%%%%: 3991-block 100
call    0 never executed
        -: 3992:               else {
    #####: 3993:                  for (i=0; i < z->s->img_x; ++i, out += 2) {
    %%%%%: 3993-block 103
    %%%%%: 3993-block 106
branch  0 never executed
branch  1 never executed
    #####: 3994:                     out[0] = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
    %%%%%: 3994-block 104
call    0 never executed
    #####: 3995:                     out[1] = 255;
        -: 3996:                  }
        -: 3997:               }
    #####: 3998:            } else if (z->s->img_n == 4 && z->app14_color_transform == 0) {
    %%%%%: 3998-block 107
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3998-block 108
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3999:               for (i=0; i < z->s->img_x; ++i) {
    %%%%%: 3999-block 109
    %%%%%: 3999-block 115
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4000:                  stbi_uc m = coutput[3][i];
    #####: 4001:                  stbi_uc r = stbi__blinn_8x8(coutput[0][i], m);
    %%%%%: 4001-block 110
call    0 never executed
    #####: 4002:                  stbi_uc g = stbi__blinn_8x8(coutput[1][i], m);
call    0 never executed
    #####: 4003:                  stbi_uc b = stbi__blinn_8x8(coutput[2][i], m);
call    0 never executed
    #####: 4004:                  out[0] = stbi__compute_y(r, g, b);
call    0 never executed
    #####: 4005:                  out[1] = 255;
    #####: 4006:                  out += n;
        -: 4007:               }
    #####: 4008:            } else if (z->s->img_n == 4 && z->app14_color_transform == 2) {
    %%%%%: 4008-block 116
    %%%%%: 4008-block 117
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4008-block 118
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4009:               for (i=0; i < z->s->img_x; ++i) {
    %%%%%: 4009-block 119
    %%%%%: 4009-block 122
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4010:                  out[0] = stbi__blinn_8x8(255 - coutput[0][i], coutput[3][i]);
    %%%%%: 4010-block 120
call    0 never executed
    #####: 4011:                  out[1] = 255;
    #####: 4012:                  out += n;
        -: 4013:               }
        -: 4014:            } else {
    #####: 4015:               stbi_uc *y = coutput[0];
    #####: 4016:               if (n == 1)
    %%%%%: 4016-block 124
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4017:                  for (i=0; i < z->s->img_x; ++i) out[i] = y[i];
    %%%%%: 4017-block 125
    %%%%%: 4017-block 126
    %%%%%: 4017-block 127
branch  0 never executed
branch  1 never executed
        -: 4018:               else
    #####: 4019:                  for (i=0; i < z->s->img_x; ++i) { *out++ = y[i]; *out++ = 255; }
    %%%%%: 4019-block 128
    %%%%%: 4019-block 129
    %%%%%: 4019-block 130
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 4020:            }
        -: 4021:         }
        -: 4022:      }
    #####: 4023:      stbi__cleanup_jpeg(z);
    %%%%%: 4023-block 133
call    0 never executed
    #####: 4024:      *out_x = z->s->img_x;
    #####: 4025:      *out_y = z->s->img_y;
    #####: 4026:      if (comp) *comp = z->s->img_n >= 3 ? 3 : 1; // report original components, not output
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4026-block 135
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4026-block 136
    %%%%%: 4026-block 137
    %%%%%: 4026-block 138
    #####: 4027:      return output;
    %%%%%: 4027-block 139
        -: 4028:   }
        -: 4029:}
        -: 4030:
function _ZL15stbi__jpeg_loadP13stbi__contextPiS1_S1_iP17stbi__result_info called 0 returned 0% blocks executed 0%
    #####: 4031:static void *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
        -: 4032:{
        -: 4033:   unsigned char* result;
    #####: 4034:   stbi__jpeg* j = (stbi__jpeg*) stbi__malloc(sizeof(stbi__jpeg));
    %%%%%: 4034-block 2
call    0 never executed
    #####: 4035:   if (!j) return stbi__errpuc("outofmem", "Out of memory");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4035-block 4
call    2 never executed
    #####: 4036:   memset(j, 0, sizeof(stbi__jpeg));
        -: 4037:   STBI_NOTUSED(ri);
    #####: 4038:   j->s = s;
    #####: 4039:   stbi__setup_jpeg(j);
    %%%%%: 4039-block 6
call    0 never executed
    #####: 4040:   result = load_jpeg_image(j, x,y,comp,req_comp);
call    0 never executed
    #####: 4041:   STBI_FREE(j);
    #####: 4042:   return result;
        -: 4043:}
        -: 4044:
function _ZL15stbi__jpeg_testP13stbi__context called 0 returned 0% blocks executed 0%
    #####: 4045:static int stbi__jpeg_test(stbi__context *s)
        -: 4046:{
        -: 4047:   int r;
    #####: 4048:   stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));
    %%%%%: 4048-block 2
call    0 never executed
    #####: 4049:   if (!j) return stbi__err("outofmem", "Out of memory");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4049-block 4
call    2 never executed
    #####: 4050:   memset(j, 0, sizeof(stbi__jpeg));
    #####: 4051:   j->s = s;
    #####: 4052:   stbi__setup_jpeg(j);
    %%%%%: 4052-block 5
call    0 never executed
    #####: 4053:   r = stbi__decode_jpeg_header(j, STBI__SCAN_type);
call    0 never executed
    #####: 4054:   stbi__rewind(s);
call    0 never executed
    #####: 4055:   STBI_FREE(j);
    #####: 4056:   return r;
        -: 4057:}
        -: 4058:
function _ZL19stbi__jpeg_info_rawP10stbi__jpegPiS1_S1_ called 0 returned 0% blocks executed 0%
    #####: 4059:static int stbi__jpeg_info_raw(stbi__jpeg *j, int *x, int *y, int *comp)
        -: 4060:{
    #####: 4061:   if (!stbi__decode_jpeg_header(j, STBI__SCAN_header)) {
    %%%%%: 4061-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 4062:      stbi__rewind( j->s );
    %%%%%: 4062-block 4
call    0 never executed
    #####: 4063:      return 0;
        -: 4064:   }
    #####: 4065:   if (x) *x = j->s->img_x;
    %%%%%: 4065-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4065-block 7
    #####: 4066:   if (y) *y = j->s->img_y;
    %%%%%: 4066-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4066-block 9
    #####: 4067:   if (comp) *comp = j->s->img_n >= 3 ? 3 : 1;
    %%%%%: 4067-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4067-block 11
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4067-block 12
    %%%%%: 4067-block 13
    %%%%%: 4067-block 14
    #####: 4068:   return 1;
    %%%%%: 4068-block 15
        -: 4069:}
        -: 4070:
function _ZL15stbi__jpeg_infoP13stbi__contextPiS1_S1_ called 0 returned 0% blocks executed 0%
    #####: 4071:static int stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp)
        -: 4072:{
        -: 4073:   int result;
    #####: 4074:   stbi__jpeg* j = (stbi__jpeg*) (stbi__malloc(sizeof(stbi__jpeg)));
    %%%%%: 4074-block 2
call    0 never executed
    #####: 4075:   if (!j) return stbi__err("outofmem", "Out of memory");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4075-block 4
call    2 never executed
    #####: 4076:   memset(j, 0, sizeof(stbi__jpeg));
    #####: 4077:   j->s = s;
    #####: 4078:   result = stbi__jpeg_info_raw(j, x, y, comp);
    %%%%%: 4078-block 5
call    0 never executed
    #####: 4079:   STBI_FREE(j);
    #####: 4080:   return result;
        -: 4081:}
        -: 4082:#endif
        -: 4083:
        -: 4084:// public domain zlib decode    v0.2  Sean Barrett 2006-11-18
        -: 4085://    simple implementation
        -: 4086://      - all input must be provided in an upfront buffer
        -: 4087://      - all output is written to a single output buffer (can malloc/realloc)
        -: 4088://    performance
        -: 4089://      - fast huffman
        -: 4090:
        -: 4091:#ifndef STBI_NO_ZLIB
        -: 4092:
        -: 4093:// fast-way is faster to check than jpeg huffman, but slow way is slower
        -: 4094:#define STBI__ZFAST_BITS  9 // accelerate all cases in default tables
        -: 4095:#define STBI__ZFAST_MASK  ((1 << STBI__ZFAST_BITS) - 1)
        -: 4096:#define STBI__ZNSYMS 288 // number of symbols in literal/length alphabet
        -: 4097:
        -: 4098:// zlib-style huffman encoding
        -: 4099:// (jpegs packs from left, zlib from right, so can't share code)
        -: 4100:typedef struct
        -: 4101:{
        -: 4102:   stbi__uint16 fast[1 << STBI__ZFAST_BITS];
        -: 4103:   stbi__uint16 firstcode[16];
        -: 4104:   int maxcode[17];
        -: 4105:   stbi__uint16 firstsymbol[16];
        -: 4106:   stbi_uc  size[STBI__ZNSYMS];
        -: 4107:   stbi__uint16 value[STBI__ZNSYMS];
        -: 4108:} stbi__zhuffman;
        -: 4109:
function _ZL18stbi__bitreverse16i called 20476 returned 100% blocks executed 100%
    20476: 4110:stbi_inline static int stbi__bitreverse16(int n)
        -: 4111:{
    20476: 4112:  n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);
    20476: 4113:  n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);
    20476: 4114:  n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);
    20476: 4115:  n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);
    20476: 4116:  return n;
    20476: 4116-block 2
        -: 4117:}
        -: 4118:
function _ZL17stbi__bit_reverseii called 20476 returned 100% blocks executed 80%
    20476: 4119:stbi_inline static int stbi__bit_reverse(int v, int bits)
        -: 4120:{
   20476*: 4121:   STBI_ASSERT(bits <= 16);
    20476: 4121-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 20476
    %%%%%: 4121-block 3
call    2 never executed
        -: 4122:   // to bit reverse n bits, reverse 16 and shift
        -: 4123:   // e.g. 11 bits, bit reverse and shift away 5
    20476: 4124:   return stbi__bitreverse16(v) >> (16-bits);
    20476: 4124-block 4
call    0 returned 20476
        -: 4125:}
        -: 4126:
function _ZL20stbi__zbuild_huffmanP14stbi__zhuffmanPKhi called 60 returned 100% blocks executed 93%
       60: 4127:static int stbi__zbuild_huffman(stbi__zhuffman *z, const stbi_uc *sizelist, int num)
        -: 4128:{
       60: 4129:   int i,k=0;
        -: 4130:   int code, next_code[16], sizes[17];
        -: 4131:
        -: 4132:   // DEFLATE spec for generating codes
       60: 4133:   memset(sizes, 0, sizeof(sizes));
       60: 4134:   memset(z->fast, 0, sizeof(z->fast));
     6760: 4135:   for (i=0; i < num; ++i)
       60: 4135-block 2
     6760: 4135-block 4
branch  0 taken 6700
branch  1 taken 60 (fallthrough)
     6700: 4136:      ++sizes[sizelist[i]];
     6700: 4136-block 3
       60: 4137:   sizes[0] = 0;
      960: 4138:   for (i=1; i < 16; ++i)
       60: 4138-block 5
      900: 4138-block 8
      960: 4138-block 9
branch  0 taken 900
branch  1 taken 60 (fallthrough)
      900: 4139:      if (sizes[i] > (1 << i))
      900: 4139-block 6
branch  0 taken 0 (fallthrough)
branch  1 taken 900
    #####: 4140:         return stbi__err("bad sizes", "Corrupt PNG");
    %%%%%: 4140-block 7
call    0 never executed
       60: 4141:   code = 0;
      960: 4142:   for (i=1; i < 16; ++i) {
       60: 4142-block 10
      960: 4142-block 15
branch  0 taken 900
branch  1 taken 60 (fallthrough)
      900: 4143:      next_code[i] = code;
      900: 4144:      z->firstcode[i] = (stbi__uint16) code;
      900: 4145:      z->firstsymbol[i] = (stbi__uint16) k;
      900: 4146:      code = (code + sizes[i]);
      900: 4147:      if (sizes[i])
      900: 4147-block 11
branch  0 taken 458 (fallthrough)
branch  1 taken 442
     458*: 4148:         if (code-1 >= (1 << i)) return stbi__err("bad codelengths","Corrupt PNG");
      458: 4148-block 12
branch  0 taken 0 (fallthrough)
branch  1 taken 458
    %%%%%: 4148-block 13
call    2 never executed
      900: 4149:      z->maxcode[i] = code << (16-i); // preshift for inner loop
      900: 4150:      code <<= 1;
      900: 4151:      k += sizes[i];
      900: 4151-block 14
        -: 4152:   }
       60: 4153:   z->maxcode[16] = 0x10000; // sentinel
     6760: 4154:   for (i=0; i < num; ++i) {
       60: 4154-block 16
     6700: 4154-block 24
     6760: 4154-block 25
branch  0 taken 6700
branch  1 taken 60 (fallthrough)
     6700: 4155:      int s = sizelist[i];
     6700: 4156:      if (s) {
     6700: 4156-block 17
branch  0 taken 5044 (fallthrough)
branch  1 taken 1656
     5044: 4157:         int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];
     5044: 4158:         stbi__uint16 fastv = (stbi__uint16) ((s << 9) | i);
     5044: 4159:         z->size [c] = (stbi_uc     ) s;
     5044: 4160:         z->value[c] = (stbi__uint16) i;
     5044: 4161:         if (s <= STBI__ZFAST_BITS) {
     5044: 4161-block 18
branch  0 taken 2610 (fallthrough)
branch  1 taken 2434
     2610: 4162:            int j = stbi__bit_reverse(next_code[s],s);
     2610: 4162-block 19
call    0 returned 2610
    32765: 4163:            while (j < (1 << STBI__ZFAST_BITS)) {
    32765: 4163-block 22
branch  0 taken 30155
branch  1 taken 2610 (fallthrough)
    30155: 4164:               z->fast[j] = fastv;
    30155: 4165:               j += (1 << s);
    30155: 4165-block 21
        -: 4166:            }
        -: 4167:         }
     5044: 4168:         ++next_code[s];
     5044: 4168-block 23
        -: 4169:      }
        -: 4170:   }
       60: 4171:   return 1;
       60: 4171-block 26
        -: 4172:}
        -: 4173:
        -: 4174:// zlib-from-memory implementation for PNG reading
        -: 4175://    because PNG allows splitting the zlib stream arbitrarily,
        -: 4176://    and it's annoying structurally to have PNG call ZLIB call PNG,
        -: 4177://    we require PNG read all the IDATs and combine them into a single
        -: 4178://    memory buffer
        -: 4179:
        -: 4180:typedef struct
        -: 4181:{
        -: 4182:   stbi_uc *zbuffer, *zbuffer_end;
        -: 4183:   int num_bits;
        -: 4184:   int hit_zeof_once;
        -: 4185:   stbi__uint32 code_buffer;
        -: 4186:
        -: 4187:   char *zout;
        -: 4188:   char *zout_start;
        -: 4189:   char *zout_end;
        -: 4190:   int   z_expandable;
        -: 4191:
        -: 4192:   stbi__zhuffman z_length, z_distance;
        -: 4193:} stbi__zbuf;
        -: 4194:
function _ZL10stbi__zeofP10stbi__zbuf called 455096 returned 100% blocks executed 100%
   455096: 4195:stbi_inline static int stbi__zeof(stbi__zbuf *z)
        -: 4196:{
   455096: 4197:   return (z->zbuffer >= z->zbuffer_end);
   455096: 4197-block 2
        -: 4198:}
        -: 4199:
function _ZL11stbi__zget8P10stbi__zbuf called 314418 returned 100% blocks executed 83%
   314418: 4200:stbi_inline static stbi_uc stbi__zget8(stbi__zbuf *z)
        -: 4201:{
  314418*: 4202:   return stbi__zeof(z) ? 0 : *z->zbuffer++;
   314418: 4202-block 2
call    0 returned 314418
branch  1 taken 314418 (fallthrough)
branch  2 taken 0
   314418: 4202-block 4
    %%%%%: 4202-block 5
   314418: 4202-block 6
        -: 4203:}
        -: 4204:
function _ZL15stbi__fill_bitsP10stbi__zbuf called 140868 returned 100% blocks executed 80%
   314416: 4205:static void stbi__fill_bits(stbi__zbuf *z)
        -: 4206:{
        -: 4207:   do {
   314416: 4208:      if (z->code_buffer >= (1U << z->num_bits)) {
   314416: 4208-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 314416
    #####: 4209:        z->zbuffer = z->zbuffer_end;  /* treat this as EOF so we fail. */
    #####: 4210:        return;
    %%%%%: 4210-block 3
        -: 4211:      }
   314416: 4212:      z->code_buffer |= (unsigned int) stbi__zget8(z) << z->num_bits;
   314416: 4212-block 4
call    0 returned 314416
   314416: 4213:      z->num_bits += 8;
   314416: 4214:   } while (z->num_bits <= 24);
branch  0 taken 173548
branch  1 taken 140868 (fallthrough)
        -: 4215:}
        -: 4216:
function _ZL14stbi__zreceiveP10stbi__zbufi called 67624 returned 100% blocks executed 100%
    67624: 4217:stbi_inline static unsigned int stbi__zreceive(stbi__zbuf *z, int n)
        -: 4218:{
        -: 4219:   unsigned int k;
    67624: 4220:   if (z->num_bits < n) stbi__fill_bits(z);
    67624: 4220-block 2
branch  0 taken 191 (fallthrough)
branch  1 taken 67433
      191: 4220-block 3
call    2 returned 191
    67624: 4221:   k = z->code_buffer & ((1 << n) - 1);
    67624: 4222:   z->code_buffer >>= n;
    67624: 4223:   z->num_bits -= n;
    67624: 4224:   return k;
    67624: 4224-block 4
        -: 4225:}
        -: 4226:
function _ZL30stbi__zhuffman_decode_slowpathP10stbi__zbufP14stbi__zhuffman called 17866 returned 100% blocks executed 77%
    17866: 4227:static int stbi__zhuffman_decode_slowpath(stbi__zbuf *a, stbi__zhuffman *z)
        -: 4228:{
        -: 4229:   int b,s,k;
        -: 4230:   // not resolved by fast table, so compute it the slow way
        -: 4231:   // use jpeg approach, which requires MSbits at top
    17866: 4232:   k = stbi__bit_reverse(a->code_buffer, 16);
    17866: 4232-block 2
call    0 returned 17866
    29397: 4233:   for (s=STBI__ZFAST_BITS+1; ; ++s)
    11531: 4233-block 6
    29397: 4234:      if (k < z->maxcode[s])
    29397: 4234-block 4
branch  0 taken 17866 (fallthrough)
branch  1 taken 11531
    17866: 4235:         break;
    17866: 4235-block 5
   17866*: 4236:   if (s >= 16) return -1; // invalid code!
    17866: 4236-block 7
branch  0 taken 0 (fallthrough)
branch  1 taken 17866
    %%%%%: 4236-block 8
        -: 4237:   // code size is s, so:
    17866: 4238:   b = (k >> (16-s)) - z->firstcode[s] + z->firstsymbol[s];
   17866*: 4239:   if (b >= STBI__ZNSYMS) return -1; // some data was corrupt somewhere!
    17866: 4239-block 9
branch  0 taken 0 (fallthrough)
branch  1 taken 17866
    %%%%%: 4239-block 10
   17866*: 4240:   if (z->size[b] != s) return -1;  // was originally an assert, but report failure instead.
    17866: 4240-block 11
branch  0 taken 0 (fallthrough)
branch  1 taken 17866
    %%%%%: 4240-block 12
    17866: 4241:   a->code_buffer >>= s;
    17866: 4242:   a->num_bits -= s;
    17866: 4243:   return z->value[b];
    17866: 4243-block 13
        -: 4244:}
        -: 4245:
function _ZL21stbi__zhuffman_decodeP10stbi__zbufP14stbi__zhuffman called 364194 returned 100% blocks executed 73%
   364194: 4246:stbi_inline static int stbi__zhuffman_decode(stbi__zbuf *a, stbi__zhuffman *z)
        -: 4247:{
        -: 4248:   int b,s;
   364194: 4249:   if (a->num_bits < 16) {
   364194: 4249-block 2
branch  0 taken 140677 (fallthrough)
branch  1 taken 223517
   140677: 4250:      if (stbi__zeof(a)) {
   140677: 4250-block 3
call    0 returned 140677
branch  1 taken 0 (fallthrough)
branch  2 taken 140677
    #####: 4251:         if (!a->hit_zeof_once) {
    %%%%%: 4251-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4252:            // This is the first time we hit eof, insert 16 extra padding btis
        -: 4253:            // to allow us to keep going; if we actually consume any of them
        -: 4254:            // though, that is invalid data. This is caught later.
    #####: 4255:            a->hit_zeof_once = 1;
    #####: 4256:            a->num_bits += 16; // add 16 implicit zero bits
    %%%%%: 4256-block 6
        -: 4257:         } else {
        -: 4258:            // We already inserted our extra 16 padding bits and are again
        -: 4259:            // out, this stream is actually prematurely terminated.
    #####: 4260:            return -1;
    %%%%%: 4260-block 7
        -: 4261:         }
        -: 4262:      } else {
   140677: 4263:         stbi__fill_bits(a);
   140677: 4263-block 8
call    0 returned 140677
        -: 4264:      }
        -: 4265:   }
   364194: 4266:   b = z->fast[a->code_buffer & STBI__ZFAST_MASK];
   364194: 4267:   if (b) {
   364194: 4267-block 9
branch  0 taken 346328 (fallthrough)
branch  1 taken 17866
   346328: 4268:      s = b >> 9;
   346328: 4269:      a->code_buffer >>= s;
   346328: 4270:      a->num_bits -= s;
   346328: 4271:      return b & 511;
   346328: 4271-block 10
        -: 4272:   }
    17866: 4273:   return stbi__zhuffman_decode_slowpath(a, z);
    17866: 4273-block 11
call    0 returned 17866
        -: 4274:}
        -: 4275:
function _ZL13stbi__zexpandP10stbi__zbufPci called 0 returned 0% blocks executed 0%
    #####: 4276:static int stbi__zexpand(stbi__zbuf *z, char *zout, int n)  // need to make room for n bytes
        -: 4277:{
        -: 4278:   char *q;
        -: 4279:   unsigned int cur, limit, old_limit;
    #####: 4280:   z->zout = zout;
    #####: 4281:   if (!z->z_expandable) return stbi__err("output buffer limit","Corrupt PNG");
    %%%%%: 4281-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4281-block 3
call    2 never executed
    #####: 4282:   cur   = (unsigned int) (z->zout - z->zout_start);
    #####: 4283:   limit = old_limit = (unsigned) (z->zout_end - z->zout_start);
    #####: 4284:   if (UINT_MAX - cur < (unsigned) n) return stbi__err("outofmem", "Out of memory");
    %%%%%: 4284-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4284-block 5
call    2 never executed
    #####: 4285:   while (cur + n > limit) {
    %%%%%: 4285-block 6
    %%%%%: 4285-block 10
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4286:      if(limit > UINT_MAX / 2) return stbi__err("outofmem", "Out of memory");
    %%%%%: 4286-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4286-block 8
call    2 never executed
    #####: 4287:      limit *= 2;
    %%%%%: 4287-block 9
        -: 4288:   }
    #####: 4289:   q = (char *) STBI_REALLOC_SIZED(z->zout_start, old_limit, limit);
        -: 4290:   STBI_NOTUSED(old_limit);
    #####: 4291:   if (q == NULL) return stbi__err("outofmem", "Out of memory");
    %%%%%: 4291-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4291-block 12
call    2 never executed
    #####: 4292:   z->zout_start = q;
    #####: 4293:   z->zout       = q + cur;
    #####: 4294:   z->zout_end   = q + limit;
    #####: 4295:   return 1;
    %%%%%: 4295-block 13
        -: 4296:}
        -: 4297:
        -: 4298:static const int stbi__zlength_base[31] = {
        -: 4299:   3,4,5,6,7,8,9,10,11,13,
        -: 4300:   15,17,19,23,27,31,35,43,51,59,
        -: 4301:   67,83,99,115,131,163,195,227,258,0,0 };
        -: 4302:
        -: 4303:static const int stbi__zlength_extra[31]=
        -: 4304:{ 0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0 };
        -: 4305:
        -: 4306:static const int stbi__zdist_base[32] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,
        -: 4307:257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0};
        -: 4308:
        -: 4309:static const int stbi__zdist_extra[32] =
        -: 4310:{ 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};
        -: 4311:
function _ZL25stbi__parse_huffman_blockP10stbi__zbuf called 20 returned 100% blocks executed 67%
       20: 4312:static int stbi__parse_huffman_block(stbi__zbuf *a)
        -: 4313:{
       20: 4314:   char *zout = a->zout;
       20: 4314-block 2
        -: 4315:   for(;;) {
   311864: 4316:      int z = stbi__zhuffman_decode(a, &a->z_length);
   311864: 4316-block 3
call    0 returned 311864
   311864: 4317:      if (z < 256) {
branch  0 taken 263543 (fallthrough)
branch  1 taken 48321
  263543*: 4318:         if (z < 0) return stbi__err("bad huffman code","Corrupt PNG"); // error in huffman codes
   263543: 4318-block 5
branch  0 taken 0 (fallthrough)
branch  1 taken 263543
    %%%%%: 4318-block 6
call    2 never executed
   263543: 4319:         if (zout >= a->zout_end) {
   263543: 4319-block 7
branch  0 taken 0 (fallthrough)
branch  1 taken 263543
    #####: 4320:            if (!stbi__zexpand(a, zout, 1)) return 0;
    %%%%%: 4320-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 4320-block 10
    #####: 4321:            zout = a->zout;
    %%%%%: 4321-block 11
        -: 4322:         }
   263543: 4323:         *zout++ = (char) z;
   263543: 4323-block 12
        -: 4324:      } else {
        -: 4325:         stbi_uc *p;
        -: 4326:         int len,dist;
    48321: 4327:         if (z == 256) {
    48321: 4327-block 13
branch  0 taken 20 (fallthrough)
branch  1 taken 48301
       20: 4328:            a->zout = zout;
      20*: 4329:            if (a->hit_zeof_once && a->num_bits < 16) {
       20: 4329-block 14
branch  0 taken 0 (fallthrough)
branch  1 taken 20
    %%%%%: 4329-block 15
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 4330:               // The first time we hit zeof, we inserted 16 extra zero bits into our bit
        -: 4331:               // buffer so the decoder can just do its speculative decoding. But if we
        -: 4332:               // actually consumed any of those bits (which is the case when num_bits < 16),
        -: 4333:               // the stream actually read past the end so it is malformed.
    #####: 4334:               return stbi__err("unexpected end","Corrupt PNG");
    %%%%%: 4334-block 16
call    0 never executed
        -: 4335:            }
       20: 4336:            return 1;
       20: 4336-block 17
        -: 4337:         }
   48301*: 4338:         if (z >= 286) return stbi__err("bad huffman code","Corrupt PNG"); // per DEFLATE, length codes 286 and 287 must not appear in compressed data
    48301: 4338-block 18
branch  0 taken 0 (fallthrough)
branch  1 taken 48301
    %%%%%: 4338-block 19
call    2 never executed
    48301: 4339:         z -= 257;
    48301: 4340:         len = stbi__zlength_base[z];
    48301: 4341:         if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);
    48301: 4341-block 20
branch  0 taken 24245 (fallthrough)
branch  1 taken 24056
    24245: 4341-block 21
call    2 returned 24245
    48301: 4342:         z = stbi__zhuffman_decode(a, &a->z_distance);
    48301: 4342-block 23
call    0 returned 48301
   48301*: 4343:         if (z < 0 || z >= 30) return stbi__err("bad huffman code","Corrupt PNG"); // per DEFLATE, distance codes 30 and 31 must not appear in compressed data
branch  0 taken 48301 (fallthrough)
branch  1 taken 0
    48301: 4343-block 25
branch  2 taken 0 (fallthrough)
branch  3 taken 48301
    %%%%%: 4343-block 26
call    4 never executed
    48301: 4344:         dist = stbi__zdist_base[z];
    48301: 4345:         if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);
    48301: 4345-block 27
branch  0 taken 42519 (fallthrough)
branch  1 taken 5782
    42519: 4345-block 28
call    2 returned 42519
   48301*: 4346:         if (zout - a->zout_start < dist) return stbi__err("bad dist","Corrupt PNG");
    48301: 4346-block 30
branch  0 taken 0 (fallthrough)
branch  1 taken 48301
    %%%%%: 4346-block 31
call    2 never executed
    48301: 4347:         if (len > a->zout_end - zout) {
    48301: 4347-block 32
branch  0 taken 0 (fallthrough)
branch  1 taken 48301
    #####: 4348:            if (!stbi__zexpand(a, zout, len)) return 0;
    %%%%%: 4348-block 33
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 4348-block 35
    #####: 4349:            zout = a->zout;
    %%%%%: 4349-block 36
        -: 4350:         }
    48301: 4351:         p = (stbi_uc *) (zout - dist);
    48301: 4352:         if (dist == 1) { // run of one byte; common in images.
    48301: 4352-block 37
branch  0 taken 5511 (fallthrough)
branch  1 taken 42790
     5511: 4353:            stbi_uc v = *p;
  1319918: 4354:            if (len) { do *zout++ = v; while (--len); }
     5511: 4354-block 38
branch  0 taken 5511 (fallthrough)
branch  1 taken 0
  1319918: 4354-block 39
branch  2 taken 1314407
branch  3 taken 5511
        -: 4355:         } else {
  1563291: 4356:            if (len) { do *zout++ = *p++; while (--len); }
    42790: 4356-block 40
branch  0 taken 42790 (fallthrough)
branch  1 taken 0
  1563291: 4356-block 41
branch  2 taken 1520501
branch  3 taken 42790 (fallthrough)
        -: 4357:         }
        -: 4358:      }
   311844: 4359:   }
   311844: 4359-block 42
        -: 4360:}
        -: 4361:
function _ZL27stbi__compute_huffman_codesP10stbi__zbuf called 20 returned 100% blocks executed 82%
       20: 4362:static int stbi__compute_huffman_codes(stbi__zbuf *a)
        -: 4363:{
        -: 4364:   static const stbi_uc length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
        -: 4365:   stbi__zhuffman z_codelength;
        -: 4366:   stbi_uc lencodes[286+32+137];//padding for maximum single op
        -: 4367:   stbi_uc codelength_sizes[19];
        -: 4368:   int i,n;
        -: 4369:
       20: 4370:   int hlit  = stbi__zreceive(a,5) + 257;
       20: 4370-block 2
call    0 returned 20
       20: 4371:   int hdist = stbi__zreceive(a,5) + 1;
call    0 returned 20
       20: 4372:   int hclen = stbi__zreceive(a,4) + 4;
call    0 returned 20
       20: 4373:   int ntot  = hlit + hdist;
        -: 4374:
       20: 4375:   memset(codelength_sizes, 0, sizeof(codelength_sizes));
      361: 4376:   for (i=0; i < hclen; ++i) {
      361: 4376-block 8
branch  0 taken 341
branch  1 taken 20 (fallthrough)
      341: 4377:      int s = stbi__zreceive(a,3);
      341: 4377-block 6
call    0 returned 341
      341: 4378:      codelength_sizes[length_dezigzag[i]] = (stbi_uc) s;
        -: 4379:   }
      20*: 4380:   if (!stbi__zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;
       20: 4380-block 9
call    0 returned 20
branch  1 taken 0 (fallthrough)
branch  2 taken 20
    %%%%%: 4380-block 11
        -: 4381:
       20: 4382:   n = 0;
     4049: 4383:   while (n < ntot) {
       20: 4383-block 12
     4049: 4383-block 34
branch  0 taken 4029
branch  1 taken 20 (fallthrough)
     4029: 4384:      int c = stbi__zhuffman_decode(a, &z_codelength);
     4029: 4384-block 13
call    0 returned 4029
    4029*: 4385:      if (c < 0 || c >= 19) return stbi__err("bad codelengths", "Corrupt PNG");
branch  0 taken 4029 (fallthrough)
branch  1 taken 0
     4029: 4385-block 15
branch  2 taken 0 (fallthrough)
branch  3 taken 4029
    %%%%%: 4385-block 16
call    4 never executed
     4029: 4386:      if (c < 16)
     4029: 4386-block 17
branch  0 taken 3610 (fallthrough)
branch  1 taken 419
     3610: 4387:         lencodes[n++] = (stbi_uc) c;
     3610: 4387-block 18
        -: 4388:      else {
      419: 4389:         stbi_uc fill = 0;
      419: 4390:         if (c == 16) {
      419: 4390-block 19
branch  0 taken 318 (fallthrough)
branch  1 taken 101
      318: 4391:            c = stbi__zreceive(a,2)+3;
      318: 4391-block 20
call    0 returned 318
     318*: 4392:            if (n == 0) return stbi__err("bad codelengths", "Corrupt PNG");
branch  0 taken 0 (fallthrough)
branch  1 taken 318
    %%%%%: 4392-block 22
call    2 never executed
      318: 4393:            fill = lencodes[n-1];
      318: 4393-block 23
      101: 4394:         } else if (c == 17) {
      101: 4394-block 24
branch  0 taken 86 (fallthrough)
branch  1 taken 15
       86: 4395:            c = stbi__zreceive(a,3)+3;
       86: 4395-block 25
call    0 returned 86
       15: 4396:         } else if (c == 18) {
       15: 4396-block 27
branch  0 taken 15 (fallthrough)
branch  1 taken 0
       15: 4397:            c = stbi__zreceive(a,7)+11;
       15: 4397-block 28
call    0 returned 15
        -: 4398:         } else {
    #####: 4399:            return stbi__err("bad codelengths", "Corrupt PNG");
    %%%%%: 4399-block 30
call    0 never executed
        -: 4400:         }
     419*: 4401:         if (ntot - n < c) return stbi__err("bad codelengths", "Corrupt PNG");
      419: 4401-block 31
branch  0 taken 0 (fallthrough)
branch  1 taken 419
    %%%%%: 4401-block 32
call    2 never executed
      419: 4402:         memset(lencodes+n, fill, c);
      419: 4403:         n += c;
      419: 4403-block 33
        -: 4404:      }
        -: 4405:   }
      20*: 4406:   if (n != ntot) return stbi__err("bad codelengths","Corrupt PNG");
       20: 4406-block 35
branch  0 taken 0 (fallthrough)
branch  1 taken 20
    %%%%%: 4406-block 36
call    2 never executed
      20*: 4407:   if (!stbi__zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;
       20: 4407-block 37
call    0 returned 20
branch  1 taken 0 (fallthrough)
branch  2 taken 20
    %%%%%: 4407-block 39
      20*: 4408:   if (!stbi__zbuild_huffman(&a->z_distance, lencodes+hlit, hdist)) return 0;
       20: 4408-block 40
call    0 returned 20
branch  1 taken 0 (fallthrough)
branch  2 taken 20
    %%%%%: 4408-block 42
       20: 4409:   return 1;
       20: 4409-block 43
        -: 4410:}
        -: 4411:
function _ZL30stbi__parse_uncompressed_blockP10stbi__zbuf called 0 returned 0% blocks executed 0%
    #####: 4412:static int stbi__parse_uncompressed_block(stbi__zbuf *a)
        -: 4413:{
        -: 4414:   stbi_uc header[4];
        -: 4415:   int len,nlen,k;
    #####: 4416:   if (a->num_bits & 7)
    %%%%%: 4416-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4417:      stbi__zreceive(a, a->num_bits & 7); // discard
    %%%%%: 4417-block 3
call    0 never executed
        -: 4418:   // drain the bit-packed data into header
    #####: 4419:   k = 0;
    #####: 4420:   while (a->num_bits > 0) {
    %%%%%: 4420-block 4
    %%%%%: 4420-block 6
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4421:      header[k++] = (stbi_uc) (a->code_buffer & 255); // suppress MSVC run-time check
    #####: 4422:      a->code_buffer >>= 8;
    #####: 4423:      a->num_bits -= 8;
    %%%%%: 4423-block 5
        -: 4424:   }
    #####: 4425:   if (a->num_bits < 0) return stbi__err("zlib corrupt","Corrupt PNG");
    %%%%%: 4425-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4425-block 8
call    2 never executed
        -: 4426:   // now fill header the normal way
    #####: 4427:   while (k < 4)
    %%%%%: 4427-block 9
    %%%%%: 4427-block 12
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4428:      header[k++] = stbi__zget8(a);
    %%%%%: 4428-block 10
call    0 never executed
    #####: 4429:   len  = header[1] * 256 + header[0];
    #####: 4430:   nlen = header[3] * 256 + header[2];
    #####: 4431:   if (nlen != (len ^ 0xffff)) return stbi__err("zlib corrupt","Corrupt PNG");
    %%%%%: 4431-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4431-block 14
call    2 never executed
    #####: 4432:   if (a->zbuffer + len > a->zbuffer_end) return stbi__err("read past buffer","Corrupt PNG");
    %%%%%: 4432-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4432-block 16
call    2 never executed
    #####: 4433:   if (a->zout + len > a->zout_end)
    %%%%%: 4433-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4434:      if (!stbi__zexpand(a, a->zout, len)) return 0;
    %%%%%: 4434-block 18
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 4434-block 20
    #####: 4435:   memcpy(a->zout, a->zbuffer, len);
    #####: 4436:   a->zbuffer += len;
    #####: 4437:   a->zout += len;
    #####: 4438:   return 1;
    %%%%%: 4438-block 21
        -: 4439:}
        -: 4440:
function _ZL23stbi__parse_zlib_headerP10stbi__zbuf called 1 returned 100% blocks executed 69%
        1: 4441:static int stbi__parse_zlib_header(stbi__zbuf *a)
        -: 4442:{
        1: 4443:   int cmf   = stbi__zget8(a);
        1: 4443-block 2
call    0 returned 1
        1: 4444:   int cm    = cmf & 15;
        -: 4445:   /* int cinfo = cmf >> 4; */
        1: 4446:   int flg   = stbi__zget8(a);
call    0 returned 1
       1*: 4447:   if (stbi__zeof(a)) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    %%%%%: 4447-block 6
call    3 never executed
       1*: 4448:   if ((cmf*256+flg) % 31 != 0) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec
        1: 4448-block 7
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 4448-block 8
call    2 never executed
       1*: 4449:   if (flg & 32) return stbi__err("no preset dict","Corrupt PNG"); // preset dictionary not allowed in png
        1: 4449-block 9
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 4449-block 10
call    2 never executed
       1*: 4450:   if (cm != 8) return stbi__err("bad compression","Corrupt PNG"); // DEFLATE required for png
        1: 4450-block 11
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 4450-block 12
call    2 never executed
        -: 4451:   // window = 1 << (8 + cinfo)... but who cares, we fully buffer output
        1: 4452:   return 1;
        1: 4452-block 13
        -: 4453:}
        -: 4454:
        -: 4455:static const stbi_uc stbi__zdefault_length[STBI__ZNSYMS] =
        -: 4456:{
        -: 4457:   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
        -: 4458:   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
        -: 4459:   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
        -: 4460:   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
        -: 4461:   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
        -: 4462:   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
        -: 4463:   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
        -: 4464:   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
        -: 4465:   7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, 7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8
        -: 4466:};
        -: 4467:static const stbi_uc stbi__zdefault_distance[32] =
        -: 4468:{
        -: 4469:   5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5
        -: 4470:};
        -: 4471:/*
        -: 4472:Init algorithm:
        -: 4473:{
        -: 4474:   int i;   // use <= to match clearly with spec
        -: 4475:   for (i=0; i <= 143; ++i)     stbi__zdefault_length[i]   = 8;
        -: 4476:   for (   ; i <= 255; ++i)     stbi__zdefault_length[i]   = 9;
        -: 4477:   for (   ; i <= 279; ++i)     stbi__zdefault_length[i]   = 7;
        -: 4478:   for (   ; i <= 287; ++i)     stbi__zdefault_length[i]   = 8;
        -: 4479:
        -: 4480:   for (i=0; i <=  31; ++i)     stbi__zdefault_distance[i] = 5;
        -: 4481:}
        -: 4482:*/
        -: 4483:
function _ZL16stbi__parse_zlibP10stbi__zbufi called 1 returned 100% blocks executed 55%
        1: 4484:static int stbi__parse_zlib(stbi__zbuf *a, int parse_header)
        -: 4485:{
        -: 4486:   int final, type;
        1: 4487:   if (parse_header)
        1: 4487-block 2
branch  0 taken 1 (fallthrough)
branch  1 taken 0
       1*: 4488:      if (!stbi__parse_zlib_header(a)) return 0;
        1: 4488-block 3
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    %%%%%: 4488-block 5
        1: 4489:   a->num_bits = 0;
        1: 4490:   a->code_buffer = 0;
        1: 4491:   a->hit_zeof_once = 0;
        1: 4491-block 6
        -: 4492:   do {
       20: 4493:      final = stbi__zreceive(a,1);
       20: 4493-block 7
call    0 returned 20
       20: 4494:      type = stbi__zreceive(a,2);
call    0 returned 20
       20: 4495:      if (type == 0) {
branch  0 taken 0 (fallthrough)
branch  1 taken 20
    #####: 4496:         if (!stbi__parse_uncompressed_block(a)) return 0;
    %%%%%: 4496-block 10
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 4496-block 12
       20: 4497:      } else if (type == 3) {
       20: 4497-block 13
branch  0 taken 0 (fallthrough)
branch  1 taken 20
    #####: 4498:         return 0;
    %%%%%: 4498-block 14
        -: 4499:      } else {
       20: 4500:         if (type == 1) {
       20: 4500-block 15
branch  0 taken 0 (fallthrough)
branch  1 taken 20
        -: 4501:            // use fixed code lengths
    #####: 4502:            if (!stbi__zbuild_huffman(&a->z_length  , stbi__zdefault_length  , STBI__ZNSYMS)) return 0;
    %%%%%: 4502-block 16
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 4502-block 18
    #####: 4503:            if (!stbi__zbuild_huffman(&a->z_distance, stbi__zdefault_distance,  32)) return 0;
    %%%%%: 4503-block 19
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 4503-block 21
        -: 4504:         } else {
      20*: 4505:            if (!stbi__compute_huffman_codes(a)) return 0;
       20: 4505-block 22
call    0 returned 20
branch  1 taken 0 (fallthrough)
branch  2 taken 20
    %%%%%: 4505-block 24
        -: 4506:         }
      20*: 4507:         if (!stbi__parse_huffman_block(a)) return 0;
       20: 4507-block 25
call    0 returned 20
branch  1 taken 0 (fallthrough)
branch  2 taken 20
    %%%%%: 4507-block 27
        -: 4508:      }
       20: 4509:   } while (!final);
       20: 4509-block 28
branch  0 taken 19
branch  1 taken 1 (fallthrough)
        1: 4510:   return 1;
        1: 4510-block 29
        -: 4511:}
        -: 4512:
function _ZL13stbi__do_zlibP10stbi__zbufPciii called 1 returned 100% blocks executed 100%
        1: 4513:static int stbi__do_zlib(stbi__zbuf *a, char *obuf, int olen, int exp, int parse_header)
        -: 4514:{
        1: 4515:   a->zout_start = obuf;
        1: 4516:   a->zout       = obuf;
        1: 4517:   a->zout_end   = obuf + olen;
        1: 4518:   a->z_expandable = exp;
        -: 4519:
        1: 4520:   return stbi__parse_zlib(a, parse_header);
        1: 4520-block 2
call    0 returned 1
        -: 4521:}
        -: 4522:
function stbi_zlib_decode_malloc_guesssize called 0 returned 0% blocks executed 0%
    #####: 4523:STBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen)
        -: 4524:{
        -: 4525:   stbi__zbuf a;
    #####: 4526:   char *p = (char *) stbi__malloc(initial_size);
    %%%%%: 4526-block 2
call    0 never executed
    #####: 4527:   if (p == NULL) return NULL;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4527-block 4
    #####: 4528:   a.zbuffer = (stbi_uc *) buffer;
    #####: 4529:   a.zbuffer_end = (stbi_uc *) buffer + len;
    #####: 4530:   if (stbi__do_zlib(&a, p, initial_size, 1, 1)) {
    %%%%%: 4530-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 4531:      if (outlen) *outlen = (int) (a.zout - a.zout_start);
    %%%%%: 4531-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4531-block 8
    #####: 4532:      return a.zout_start;
    %%%%%: 4532-block 9
        -: 4533:   } else {
    #####: 4534:      STBI_FREE(a.zout_start);
    #####: 4535:      return NULL;
    %%%%%: 4535-block 10
        -: 4536:   }
        -: 4537:}
        -: 4538:
function stbi_zlib_decode_malloc called 0 returned 0% blocks executed 0%
    #####: 4539:STBIDEF char *stbi_zlib_decode_malloc(char const *buffer, int len, int *outlen)
        -: 4540:{
    #####: 4541:   return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);
    %%%%%: 4541-block 2
call    0 never executed
        -: 4542:}
        -: 4543:
function stbi_zlib_decode_malloc_guesssize_headerflag called 1 returned 100% blocks executed 82%
        1: 4544:STBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header)
        -: 4545:{
        -: 4546:   stbi__zbuf a;
        1: 4547:   char *p = (char *) stbi__malloc(initial_size);
        1: 4547-block 2
call    0 returned 1
       1*: 4548:   if (p == NULL) return NULL;
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 4548-block 4
        1: 4549:   a.zbuffer = (stbi_uc *) buffer;
        1: 4550:   a.zbuffer_end = (stbi_uc *) buffer + len;
        1: 4551:   if (stbi__do_zlib(&a, p, initial_size, 1, parse_header)) {
        1: 4551-block 5
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0
        1: 4552:      if (outlen) *outlen = (int) (a.zout - a.zout_start);
        1: 4552-block 7
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 4552-block 8
        1: 4553:      return a.zout_start;
        1: 4553-block 9
        -: 4554:   } else {
    #####: 4555:      STBI_FREE(a.zout_start);
    #####: 4556:      return NULL;
    %%%%%: 4556-block 10
        -: 4557:   }
        -: 4558:}
        -: 4559:
function stbi_zlib_decode_buffer called 0 returned 0% blocks executed 0%
    #####: 4560:STBIDEF int stbi_zlib_decode_buffer(char *obuffer, int olen, char const *ibuffer, int ilen)
        -: 4561:{
        -: 4562:   stbi__zbuf a;
    #####: 4563:   a.zbuffer = (stbi_uc *) ibuffer;
    #####: 4564:   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
    #####: 4565:   if (stbi__do_zlib(&a, obuffer, olen, 0, 1))
    %%%%%: 4565-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 4566:      return (int) (a.zout - a.zout_start);
    %%%%%: 4566-block 4
        -: 4567:   else
    #####: 4568:      return -1;
    %%%%%: 4568-block 5
        -: 4569:}
        -: 4570:
function stbi_zlib_decode_noheader_malloc called 0 returned 0% blocks executed 0%
    #####: 4571:STBIDEF char *stbi_zlib_decode_noheader_malloc(char const *buffer, int len, int *outlen)
        -: 4572:{
        -: 4573:   stbi__zbuf a;
    #####: 4574:   char *p = (char *) stbi__malloc(16384);
    %%%%%: 4574-block 2
call    0 never executed
    #####: 4575:   if (p == NULL) return NULL;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4575-block 4
    #####: 4576:   a.zbuffer = (stbi_uc *) buffer;
    #####: 4577:   a.zbuffer_end = (stbi_uc *) buffer+len;
    #####: 4578:   if (stbi__do_zlib(&a, p, 16384, 1, 0)) {
    %%%%%: 4578-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 4579:      if (outlen) *outlen = (int) (a.zout - a.zout_start);
    %%%%%: 4579-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4579-block 8
    #####: 4580:      return a.zout_start;
    %%%%%: 4580-block 9
        -: 4581:   } else {
    #####: 4582:      STBI_FREE(a.zout_start);
    #####: 4583:      return NULL;
    %%%%%: 4583-block 10
        -: 4584:   }
        -: 4585:}
        -: 4586:
function stbi_zlib_decode_noheader_buffer called 0 returned 0% blocks executed 0%
    #####: 4587:STBIDEF int stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen)
        -: 4588:{
        -: 4589:   stbi__zbuf a;
    #####: 4590:   a.zbuffer = (stbi_uc *) ibuffer;
    #####: 4591:   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
    #####: 4592:   if (stbi__do_zlib(&a, obuffer, olen, 0, 0))
    %%%%%: 4592-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 4593:      return (int) (a.zout - a.zout_start);
    %%%%%: 4593-block 4
        -: 4594:   else
    #####: 4595:      return -1;
    %%%%%: 4595-block 5
        -: 4596:}
        -: 4597:#endif
        -: 4598:
        -: 4599:// public domain "baseline" PNG decoder   v0.10  Sean Barrett 2006-11-18
        -: 4600://    simple implementation
        -: 4601://      - only 8-bit samples
        -: 4602://      - no CRC checking
        -: 4603://      - allocates lots of intermediate memory
        -: 4604://        - avoids problem of streaming data between subsystems
        -: 4605://        - avoids explicit window management
        -: 4606://    performance
        -: 4607://      - uses stb_zlib, a PD zlib implementation with fast huffman decoding
        -: 4608:
        -: 4609:#ifndef STBI_NO_PNG
        -: 4610:typedef struct
        -: 4611:{
        -: 4612:   stbi__uint32 length;
        -: 4613:   stbi__uint32 type;
        -: 4614:} stbi__pngchunk;
        -: 4615:
function _ZL22stbi__get_chunk_headerP13stbi__context called 7 returned 100% blocks executed 100%
        7: 4616:static stbi__pngchunk stbi__get_chunk_header(stbi__context *s)
        -: 4617:{
        -: 4618:   stbi__pngchunk c;
        7: 4619:   c.length = stbi__get32be(s);
        7: 4619-block 2
call    0 returned 7
branch  1 taken 7 (fallthrough)
branch  2 taken 0 (throw)
        7: 4620:   c.type   = stbi__get32be(s);
        7: 4620-block 3
call    0 returned 7
branch  1 taken 7 (fallthrough)
branch  2 taken 0 (throw)
        7: 4621:   return c;
        7: 4621-block 4
        7: 4621-block 5
        -: 4622:}
        -: 4623:
function _ZL22stbi__check_png_headerP13stbi__context called 2 returned 100% blocks executed 88%
        2: 4624:static int stbi__check_png_header(stbi__context *s)
        -: 4625:{
        -: 4626:   static const stbi_uc png_sig[8] = { 137,80,78,71,13,10,26,10 };
        -: 4627:   int i;
       18: 4628:   for (i=0; i < 8; ++i)
        2: 4628-block 2
       16: 4628-block 6
       18: 4628-block 7
branch  0 taken 16
branch  1 taken 2 (fallthrough)
      16*: 4629:      if (stbi__get8(s) != png_sig[i]) return stbi__err("bad png sig","Not a PNG");
       16: 4629-block 3
call    0 returned 16
branch  1 taken 0 (fallthrough)
branch  2 taken 16
    %%%%%: 4629-block 5
call    3 never executed
        2: 4630:   return 1;
        2: 4630-block 8
        -: 4631:}
        -: 4632:
        -: 4633:typedef struct
        -: 4634:{
        -: 4635:   stbi__context *s;
        -: 4636:   stbi_uc *idata, *expanded, *out;
        -: 4637:   int depth;
        -: 4638:} stbi__png;
        -: 4639:
        -: 4640:
        -: 4641:enum {
        -: 4642:   STBI__F_none=0,
        -: 4643:   STBI__F_sub=1,
        -: 4644:   STBI__F_up=2,
        -: 4645:   STBI__F_avg=3,
        -: 4646:   STBI__F_paeth=4,
        -: 4647:   // synthetic filter used for first scanline to avoid needing a dummy row of 0s
        -: 4648:   STBI__F_avg_first
        -: 4649:};
        -: 4650:
        -: 4651:static stbi_uc first_row_filter[5] =
        -: 4652:{
        -: 4653:   STBI__F_none,
        -: 4654:   STBI__F_sub,
        -: 4655:   STBI__F_none,
        -: 4656:   STBI__F_avg_first,
        -: 4657:   STBI__F_sub // Paeth with b=c=0 turns out to be equivalent to sub
        -: 4658:};
        -: 4659:
function _ZL11stbi__paethiii called 1405602 returned 100% blocks executed 100%
  1405602: 4660:static int stbi__paeth(int a, int b, int c)
        -: 4661:{
        -: 4662:   // This formulation looks very different from the reference in the PNG spec, but is
        -: 4663:   // actually equivalent and has favorable data dependencies and admits straightforward
        -: 4664:   // generation of branch-free code, which helps performance significantly.
  1405602: 4665:   int thresh = c*3 - (a + b);
  1405602: 4666:   int lo = a < b ? a : b;
  1405602: 4666-block 2
branch  0 taken 174269 (fallthrough)
branch  1 taken 1231333
   174269: 4666-block 3
  1231333: 4666-block 4
  1405602: 4667:   int hi = a < b ? b : a;
  1405602: 4667-block 5
branch  0 taken 174269 (fallthrough)
branch  1 taken 1231333
   174269: 4667-block 6
  1231333: 4667-block 7
  1405602: 4668:   int t0 = (hi <= thresh) ? lo : c;
  1405602: 4668-block 8
branch  0 taken 1183372 (fallthrough)
branch  1 taken 222230
  1183372: 4668-block 9
   222230: 4668-block 10
  1405602: 4669:   int t1 = (thresh <= lo) ? hi : t0;
  1405602: 4669-block 11
branch  0 taken 1199918 (fallthrough)
branch  1 taken 205684
  1199918: 4669-block 12
   205684: 4669-block 13
  1405602: 4670:   return t1;
  1405602: 4670-block 14
        -: 4671:}
        -: 4672:
        -: 4673:static const stbi_uc stbi__depth_scale_table[9] = { 0, 0xff, 0x55, 0, 0x11, 0,0,0, 0x01 };
        -: 4674:
        -: 4675:// adds an extra all-255 alpha channel
        -: 4676:// dest == src is legal
        -: 4677:// img_n must be 1 or 3
function _ZL30stbi__create_png_alpha_expand8PhS_ji called 1024 returned 100% blocks executed 60%
     1024: 4678:static void stbi__create_png_alpha_expand8(stbi_uc *dest, stbi_uc *src, stbi__uint32 x, int img_n)
        -: 4679:{
        -: 4680:   int i;
        -: 4681:   // must process data backwards since we allow dest==src
     1024: 4682:   if (img_n == 1) {
     1024: 4682-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1024
    #####: 4683:      for (i=x-1; i >= 0; --i) {
    %%%%%: 4683-block 3
    %%%%%: 4683-block 5
branch  0 never executed
branch  1 never executed
    #####: 4684:         dest[i*2+1] = 255;
    #####: 4685:         dest[i*2+0] = src[i];
    %%%%%: 4685-block 4
        -: 4686:      }
        -: 4687:   } else {
    1024*: 4688:      STBI_ASSERT(img_n == 3);
     1024: 4688-block 6
branch  0 taken 0 (fallthrough)
branch  1 taken 1024
    %%%%%: 4688-block 7
call    2 never executed
  1049600: 4689:      for (i=x-1; i >= 0; --i) {
     1024: 4689-block 8
  1049600: 4689-block 10
branch  0 taken 1048576
branch  1 taken 1024 (fallthrough)
  1048576: 4690:         dest[i*4+3] = 255;
  1048576: 4691:         dest[i*4+2] = src[i*3+2];
  1048576: 4692:         dest[i*4+1] = src[i*3+1];
  1048576: 4693:         dest[i*4+0] = src[i*3+0];
  1048576: 4693-block 9
        -: 4694:      }
        -: 4695:   }
     1024: 4696:}
        -: 4697:
        -: 4698:// create the png data from post-deflated data
function _ZL26stbi__create_png_image_rawP9stbi__pngPhjijjii called 1 returned 100% blocks executed 47%
        1: 4699:static int stbi__create_png_image_raw(stbi__png *a, stbi_uc *raw, stbi__uint32 raw_len, int out_n, stbi__uint32 x, stbi__uint32 y, int depth, int color)
        -: 4700:{
       1*: 4701:   int bytes = (depth == 16 ? 2 : 1);
        1: 4701-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 4701-block 3
        1: 4701-block 4
        1: 4702:   stbi__context *s = a->s;
        1: 4703:   stbi__uint32 i,j,stride = x*out_n*bytes;
        -: 4704:   stbi__uint32 img_len, img_width_bytes;
        -: 4705:   stbi_uc *filter_buf;
        1: 4706:   int all_ok = 1;
        -: 4707:   int k;
        1: 4708:   int img_n = s->img_n; // copy it into a local for later
        -: 4709:
        1: 4710:   int output_bytes = out_n*bytes;
        1: 4711:   int filter_bytes = img_n*bytes;
        1: 4712:   int width = x;
        -: 4713:
       1*: 4714:   STBI_ASSERT(out_n == s->img_n || out_n == s->img_n+1);
        1: 4714-block 5
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 4714-block 6
branch  2 taken 0 (fallthrough)
branch  3 taken 1
    %%%%%: 4714-block 7
call    4 never executed
        1: 4715:   a->out = (stbi_uc *) stbi__malloc_mad3(x, y, output_bytes, 0); // extra bytes to write off the end into
        1: 4715-block 8
call    0 returned 1
       1*: 4716:   if (!a->out) return stbi__err("outofmem", "Out of memory");
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 4716-block 10
call    2 never executed
        -: 4717:
        -: 4718:   // note: error exits here don't need to clean up a->out individually,
        -: 4719:   // stbi__do_png always does on error.
       1*: 4720:   if (!stbi__mad3sizes_valid(img_n, x, depth, 7)) return stbi__err("too large", "Corrupt PNG");
        1: 4720-block 11
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    %%%%%: 4720-block 13
call    3 never executed
        1: 4721:   img_width_bytes = (((img_n * x * depth) + 7) >> 3);
       1*: 4722:   if (!stbi__mad2sizes_valid(img_width_bytes, y, img_width_bytes)) return stbi__err("too large", "Corrupt PNG");
        1: 4722-block 14
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    %%%%%: 4722-block 16
call    3 never executed
        1: 4723:   img_len = (img_width_bytes + 1) * y;
        -: 4724:
        -: 4725:   // we used to check for exact match between raw_len and img_len on non-interlaced PNGs,
        -: 4726:   // but issue #276 reported a PNG in the wild that had extra data at the end (all zeros),
        -: 4727:   // so just check for raw_len < img_len always.
       1*: 4728:   if (raw_len < img_len) return stbi__err("not enough pixels","Corrupt PNG");
        1: 4728-block 17
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 4728-block 18
call    2 never executed
        -: 4729:
        -: 4730:   // Allocate two scan lines worth of filter workspace buffer.
        1: 4731:   filter_buf = (stbi_uc *) stbi__malloc_mad2(img_width_bytes, 2, 0);
        1: 4731-block 19
call    0 returned 1
       1*: 4732:   if (!filter_buf) return stbi__err("outofmem", "Out of memory");
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 4732-block 21
call    2 never executed
        -: 4733:
        -: 4734:   // Filtering for low-bit-depth images
        1: 4735:   if (depth < 8) {
        1: 4735-block 22
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 4736:      filter_bytes = 1;
    #####: 4737:      width = img_width_bytes;
    %%%%%: 4737-block 23
        -: 4738:   }
        -: 4739:
     1025: 4740:   for (j=0; j < y; ++j) {
        1: 4740-block 24
     1024: 4740-block 104
     1025: 4740-block 105
branch  0 taken 1024
branch  1 taken 1 (fallthrough)
        -: 4741:      // cur/prior filter buffers alternate
     1024: 4742:      stbi_uc *cur = filter_buf + (j & 1)*img_width_bytes;
     1024: 4743:      stbi_uc *prior = filter_buf + (~j & 1)*img_width_bytes;
     1024: 4744:      stbi_uc *dest = a->out + stride*j;
     1024: 4745:      int nk = width * filter_bytes;
     1024: 4746:      int filter = *raw++;
        -: 4747:
        -: 4748:      // check filter type
     1024: 4749:      if (filter > 4) {
     1024: 4749-block 25
branch  0 taken 0 (fallthrough)
branch  1 taken 1024
    #####: 4750:         all_ok = stbi__err("invalid filter","Corrupt PNG");
    %%%%%: 4750-block 26
call    0 never executed
    #####: 4751:         break;
        -: 4752:      }
        -: 4753:
        -: 4754:      // if first row, use special filter that doesn't sample previous row
     1024: 4755:      if (j == 0) filter = first_row_filter[filter];
     1024: 4755-block 28
branch  0 taken 1 (fallthrough)
branch  1 taken 1023
        1: 4755-block 29
        -: 4756:
        -: 4757:      // perform actual filtering
     1024: 4758:      switch (filter) {
     1024: 4758-block 30
branch  0 taken 0
branch  1 taken 41
branch  2 taken 323
branch  3 taken 202
branch  4 taken 458
branch  5 taken 0
branch  6 taken 0
    #####: 4759:      case STBI__F_none:
    #####: 4760:         memcpy(cur, raw, nk);
    #####: 4761:         break;
    %%%%%: 4761-block 31
       41: 4762:      case STBI__F_sub:
       41: 4763:         memcpy(cur, raw, filter_bytes);
   125870: 4764:         for (k = filter_bytes; k < nk; ++k)
       41: 4764-block 32
   125870: 4764-block 34
branch  0 taken 125829
branch  1 taken 41 (fallthrough)
   125829: 4765:            cur[k] = STBI__BYTECAST(raw[k] + cur[k-filter_bytes]);
   125829: 4765-block 33
       41: 4766:         break;
       41: 4766-block 35
      323: 4767:      case STBI__F_up:
   992579: 4768:         for (k = 0; k < nk; ++k)
      323: 4768-block 36
   992579: 4768-block 38
branch  0 taken 992256
branch  1 taken 323 (fallthrough)
   992256: 4769:            cur[k] = STBI__BYTECAST(raw[k] + prior[k]);
   992256: 4769-block 37
      323: 4770:         break;
      323: 4770-block 39
      202: 4771:      case STBI__F_avg:
      808: 4772:         for (k = 0; k < filter_bytes; ++k)
      202: 4772-block 40
      808: 4772-block 42
branch  0 taken 606
branch  1 taken 202 (fallthrough)
      606: 4773:            cur[k] = STBI__BYTECAST(raw[k] + (prior[k]>>1));
      606: 4773-block 41
   620140: 4774:         for (k = filter_bytes; k < nk; ++k)
      202: 4774-block 43
   620140: 4774-block 45
branch  0 taken 619938
branch  1 taken 202 (fallthrough)
   619938: 4775:            cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k-filter_bytes])>>1));
   619938: 4775-block 44
      202: 4776:         break;
      202: 4776-block 46
      458: 4777:      case STBI__F_paeth:
     1832: 4778:         for (k = 0; k < filter_bytes; ++k)
      458: 4778-block 47
     1832: 4778-block 49
branch  0 taken 1374
branch  1 taken 458 (fallthrough)
     1374: 4779:            cur[k] = STBI__BYTECAST(raw[k] + prior[k]); // prior[k] == stbi__paeth(0,prior[k],0)
     1374: 4779-block 48
  1406060: 4780:         for (k = filter_bytes; k < nk; ++k)
      458: 4780-block 50
  1406060: 4780-block 53
branch  0 taken 1405602
branch  1 taken 458 (fallthrough)
  1405602: 4781:            cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes], prior[k], prior[k-filter_bytes]));
  1405602: 4781-block 51
call    0 returned 1405602
      458: 4782:         break;
      458: 4782-block 54
    #####: 4783:      case STBI__F_avg_first:
    #####: 4784:         memcpy(cur, raw, filter_bytes);
    #####: 4785:         for (k = filter_bytes; k < nk; ++k)
    %%%%%: 4785-block 55
    %%%%%: 4785-block 57
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4786:            cur[k] = STBI__BYTECAST(raw[k] + (cur[k-filter_bytes] >> 1));
    %%%%%: 4786-block 56
    #####: 4787:         break;
    %%%%%: 4787-block 58
        -: 4788:      }
        -: 4789:
     1024: 4790:      raw += nk;
        -: 4791:
        -: 4792:      // expand decoded bits in cur to dest, also adding an extra alpha channel if desired
     1024: 4793:      if (depth < 8) {
     1024: 4793-block 59
branch  0 taken 0 (fallthrough)
branch  1 taken 1024
    #####: 4794:         stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1; // scale grayscale values to 0..255 range
    %%%%%: 4794-block 60
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4794-block 61
    %%%%%: 4794-block 62
    #####: 4795:         stbi_uc *in = cur;
    #####: 4796:         stbi_uc *out = dest;
    #####: 4797:         stbi_uc inb = 0;
    #####: 4798:         stbi__uint32 nsmp = x*img_n;
        -: 4799:
        -: 4800:         // expand bits to bytes first
    #####: 4801:         if (depth == 4) {
    %%%%%: 4801-block 63
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4802:            for (i=0; i < nsmp; ++i) {
    %%%%%: 4802-block 64
    %%%%%: 4802-block 68
branch  0 never executed
branch  1 never executed
    #####: 4803:               if ((i & 1) == 0) inb = *in++;
    %%%%%: 4803-block 65
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4803-block 66
    #####: 4804:               *out++ = scale * (inb >> 4);
    #####: 4805:               inb <<= 4;
    %%%%%: 4805-block 67
        -: 4806:            }
    #####: 4807:         } else if (depth == 2) {
    %%%%%: 4807-block 69
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4808:            for (i=0; i < nsmp; ++i) {
    %%%%%: 4808-block 70
    %%%%%: 4808-block 74
branch  0 never executed
branch  1 never executed
    #####: 4809:               if ((i & 3) == 0) inb = *in++;
    %%%%%: 4809-block 71
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4809-block 72
    #####: 4810:               *out++ = scale * (inb >> 6);
    #####: 4811:               inb <<= 2;
    %%%%%: 4811-block 73
        -: 4812:            }
        -: 4813:         } else {
    #####: 4814:            STBI_ASSERT(depth == 1);
    %%%%%: 4814-block 75
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4814-block 76
call    2 never executed
    #####: 4815:            for (i=0; i < nsmp; ++i) {
    %%%%%: 4815-block 77
    %%%%%: 4815-block 81
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4816:               if ((i & 7) == 0) inb = *in++;
    %%%%%: 4816-block 78
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4816-block 79
    #####: 4817:               *out++ = scale * (inb >> 7);
    #####: 4818:               inb <<= 1;
    %%%%%: 4818-block 80
        -: 4819:            }
        -: 4820:         }
        -: 4821:
        -: 4822:         // insert alpha=255 values if desired
    #####: 4823:         if (img_n != out_n)
    %%%%%: 4823-block 82
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4824:            stbi__create_png_alpha_expand8(dest, dest, x, img_n);
    %%%%%: 4824-block 83
call    0 never executed
     1024: 4825:      } else if (depth == 8) {
     1024: 4825-block 84
branch  0 taken 1024 (fallthrough)
branch  1 taken 0
     1024: 4826:         if (img_n == out_n)
     1024: 4826-block 85
branch  0 taken 0 (fallthrough)
branch  1 taken 1024
    #####: 4827:            memcpy(dest, cur, x*img_n);
    %%%%%: 4827-block 86
        -: 4828:         else
     1024: 4829:            stbi__create_png_alpha_expand8(dest, cur, x, img_n);
     1024: 4829-block 87
call    0 returned 1024
    #####: 4830:      } else if (depth == 16) {
    %%%%%: 4830-block 88
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4831:         // convert the image data from big-endian to platform-native
    #####: 4832:         stbi__uint16 *dest16 = (stbi__uint16*)dest;
    #####: 4833:         stbi__uint32 nsmp = x*img_n;
        -: 4834:
    #####: 4835:         if (img_n == out_n) {
    %%%%%: 4835-block 89
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4836:            for (i = 0; i < nsmp; ++i, ++dest16, cur += 2)
    %%%%%: 4836-block 90
    %%%%%: 4836-block 92
branch  0 never executed
branch  1 never executed
    #####: 4837:               *dest16 = (cur[0] << 8) | cur[1];
    %%%%%: 4837-block 91
        -: 4838:         } else {
    #####: 4839:            STBI_ASSERT(img_n+1 == out_n);
    %%%%%: 4839-block 93
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4839-block 94
call    2 never executed
    #####: 4840:            if (img_n == 1) {
    %%%%%: 4840-block 95
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4841:               for (i = 0; i < x; ++i, dest16 += 2, cur += 2) {
    %%%%%: 4841-block 96
    %%%%%: 4841-block 98
branch  0 never executed
branch  1 never executed
    #####: 4842:                  dest16[0] = (cur[0] << 8) | cur[1];
    #####: 4843:                  dest16[1] = 0xffff;
    %%%%%: 4843-block 97
        -: 4844:               }
        -: 4845:            } else {
    #####: 4846:               STBI_ASSERT(img_n == 3);
    %%%%%: 4846-block 99
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4846-block 100
call    2 never executed
    #####: 4847:               for (i = 0; i < x; ++i, dest16 += 4, cur += 6) {
    %%%%%: 4847-block 101
    %%%%%: 4847-block 103
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4848:                  dest16[0] = (cur[0] << 8) | cur[1];
    #####: 4849:                  dest16[1] = (cur[2] << 8) | cur[3];
    #####: 4850:                  dest16[2] = (cur[4] << 8) | cur[5];
    #####: 4851:                  dest16[3] = 0xffff;
    %%%%%: 4851-block 102
        -: 4852:               }
        -: 4853:            }
        -: 4854:         }
        -: 4855:      }
        -: 4856:   }
        -: 4857:
        1: 4858:   STBI_FREE(filter_buf);
       1*: 4859:   if (!all_ok) return 0;
        1: 4859-block 106
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 4859-block 107
        -: 4860:
        1: 4861:   return 1;
        1: 4861-block 108
        -: 4862:}
        -: 4863:
function _ZL22stbi__create_png_imageP9stbi__pngPhjiiii called 1 returned 100% blocks executed 20%
        1: 4864:static int stbi__create_png_image(stbi__png *a, stbi_uc *image_data, stbi__uint32 image_data_len, int out_n, int depth, int color, int interlaced)
        -: 4865:{
       1*: 4866:   int bytes = (depth == 16 ? 2 : 1);
        1: 4866-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 4866-block 3
        1: 4866-block 4
        1: 4867:   int out_bytes = out_n * bytes;
        -: 4868:   stbi_uc *final;
        -: 4869:   int p;
        1: 4870:   if (!interlaced)
        1: 4870-block 5
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 4871:      return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);
        1: 4871-block 6
call    0 returned 1
        -: 4872:
        -: 4873:   // de-interlacing
    #####: 4874:   final = (stbi_uc *) stbi__malloc_mad3(a->s->img_x, a->s->img_y, out_bytes, 0);
    %%%%%: 4874-block 7
call    0 never executed
    #####: 4875:   if (!final) return stbi__err("outofmem", "Out of memory");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4875-block 9
call    2 never executed
    #####: 4876:   for (p=0; p < 7; ++p) {
    %%%%%: 4876-block 10
    %%%%%: 4876-block 23
    %%%%%: 4876-block 24
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4877:      int xorig[] = { 0,4,0,2,0,1,0 };
    #####: 4878:      int yorig[] = { 0,0,4,0,2,0,1 };
    #####: 4879:      int xspc[]  = { 8,8,4,4,2,2,1 };
    #####: 4880:      int yspc[]  = { 8,8,8,4,4,2,2 };
        -: 4881:      int i,j,x,y;
        -: 4882:      // pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1
    #####: 4883:      x = (a->s->img_x - xorig[p] + xspc[p]-1) / xspc[p];
    #####: 4884:      y = (a->s->img_y - yorig[p] + yspc[p]-1) / yspc[p];
    #####: 4885:      if (x && y) {
    %%%%%: 4885-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4885-block 12
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4886:         stbi__uint32 img_len = ((((a->s->img_n * x * depth) + 7) >> 3) + 1) * y;
    #####: 4887:         if (!stbi__create_png_image_raw(a, image_data, image_data_len, out_n, x, y, depth, color)) {
    %%%%%: 4887-block 13
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 4888:            STBI_FREE(final);
    #####: 4889:            return 0;
    %%%%%: 4889-block 15
        -: 4890:         }
    #####: 4891:         for (j=0; j < y; ++j) {
    %%%%%: 4891-block 16
    %%%%%: 4891-block 20
    %%%%%: 4891-block 21
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4892:            for (i=0; i < x; ++i) {
    %%%%%: 4892-block 17
    %%%%%: 4892-block 19
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4893:               int out_y = j*yspc[p]+yorig[p];
    #####: 4894:               int out_x = i*xspc[p]+xorig[p];
    #####: 4895:               memcpy(final + out_y*a->s->img_x*out_bytes + out_x*out_bytes,
    #####: 4896:                      a->out + (j*x+i)*out_bytes, out_bytes);
    %%%%%: 4896-block 18
        -: 4897:            }
        -: 4898:         }
    #####: 4899:         STBI_FREE(a->out);
    #####: 4900:         image_data += img_len;
    #####: 4901:         image_data_len -= img_len;
    %%%%%: 4901-block 22
        -: 4902:      }
        -: 4903:   }
    #####: 4904:   a->out = final;
        -: 4905:
    #####: 4906:   return 1;
    %%%%%: 4906-block 25
        -: 4907:}
        -: 4908:
function _ZL26stbi__compute_transparencyP9stbi__pngPhi called 0 returned 0% blocks executed 0%
    #####: 4909:static int stbi__compute_transparency(stbi__png *z, stbi_uc tc[3], int out_n)
        -: 4910:{
    #####: 4911:   stbi__context *s = z->s;
    #####: 4912:   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
    #####: 4913:   stbi_uc *p = z->out;
        -: 4914:
        -: 4915:   // compute color-based transparency, assuming we've
        -: 4916:   // already got 255 as the alpha value in the output
    #####: 4917:   STBI_ASSERT(out_n == 2 || out_n == 4);
    %%%%%: 4917-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4917-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4917-block 4
call    4 never executed
        -: 4918:
    #####: 4919:   if (out_n == 2) {
    %%%%%: 4919-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4920:      for (i=0; i < pixel_count; ++i) {
    %%%%%: 4920-block 6
    %%%%%: 4920-block 11
branch  0 never executed
branch  1 never executed
    #####: 4921:         p[1] = (p[0] == tc[0] ? 0 : 255);
    %%%%%: 4921-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4921-block 8
    %%%%%: 4921-block 9
    #####: 4922:         p += 2;
    %%%%%: 4922-block 10
        -: 4923:      }
        -: 4924:   } else {
    #####: 4925:      for (i=0; i < pixel_count; ++i) {
    %%%%%: 4925-block 12
    %%%%%: 4925-block 18
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4926:         if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
    %%%%%: 4926-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4926-block 14
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4926-block 15
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 4927:            p[3] = 0;
    %%%%%: 4927-block 16
    #####: 4928:         p += 4;
    %%%%%: 4928-block 17
        -: 4929:      }
        -: 4930:   }
    #####: 4931:   return 1;
    %%%%%: 4931-block 19
        -: 4932:}
        -: 4933:
function _ZL28stbi__compute_transparency16P9stbi__pngPti called 0 returned 0% blocks executed 0%
    #####: 4934:static int stbi__compute_transparency16(stbi__png *z, stbi__uint16 tc[3], int out_n)
        -: 4935:{
    #####: 4936:   stbi__context *s = z->s;
    #####: 4937:   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
    #####: 4938:   stbi__uint16 *p = (stbi__uint16*) z->out;
        -: 4939:
        -: 4940:   // compute color-based transparency, assuming we've
        -: 4941:   // already got 65535 as the alpha value in the output
    #####: 4942:   STBI_ASSERT(out_n == 2 || out_n == 4);
    %%%%%: 4942-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4942-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4942-block 4
call    4 never executed
        -: 4943:
    #####: 4944:   if (out_n == 2) {
    %%%%%: 4944-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4945:      for (i = 0; i < pixel_count; ++i) {
    %%%%%: 4945-block 6
    %%%%%: 4945-block 11
branch  0 never executed
branch  1 never executed
    #####: 4946:         p[1] = (p[0] == tc[0] ? 0 : 65535);
    %%%%%: 4946-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4946-block 8
    %%%%%: 4946-block 9
    #####: 4947:         p += 2;
    %%%%%: 4947-block 10
        -: 4948:      }
        -: 4949:   } else {
    #####: 4950:      for (i = 0; i < pixel_count; ++i) {
    %%%%%: 4950-block 12
    %%%%%: 4950-block 18
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4951:         if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
    %%%%%: 4951-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4951-block 14
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4951-block 15
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 4952:            p[3] = 0;
    %%%%%: 4952-block 16
    #####: 4953:         p += 4;
    %%%%%: 4953-block 17
        -: 4954:      }
        -: 4955:   }
    #####: 4956:   return 1;
    %%%%%: 4956-block 19
        -: 4957:}
        -: 4958:
function _ZL24stbi__expand_png_paletteP9stbi__pngPhii called 0 returned 0% blocks executed 0%
    #####: 4959:static int stbi__expand_png_palette(stbi__png *a, stbi_uc *palette, int len, int pal_img_n)
        -: 4960:{
    #####: 4961:   stbi__uint32 i, pixel_count = a->s->img_x * a->s->img_y;
    #####: 4962:   stbi_uc *p, *temp_out, *orig = a->out;
        -: 4963:
    #####: 4964:   p = (stbi_uc *) stbi__malloc_mad2(pixel_count, pal_img_n, 0);
    %%%%%: 4964-block 2
call    0 never executed
    #####: 4965:   if (p == NULL) return stbi__err("outofmem", "Out of memory");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4965-block 4
call    2 never executed
        -: 4966:
        -: 4967:   // between here and free(out) below, exitting would leak
    #####: 4968:   temp_out = p;
        -: 4969:
    #####: 4970:   if (pal_img_n == 3) {
    %%%%%: 4970-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4971:      for (i=0; i < pixel_count; ++i) {
    %%%%%: 4971-block 6
    %%%%%: 4971-block 8
branch  0 never executed
branch  1 never executed
    #####: 4972:         int n = orig[i]*4;
    #####: 4973:         p[0] = palette[n  ];
    #####: 4974:         p[1] = palette[n+1];
    #####: 4975:         p[2] = palette[n+2];
    #####: 4976:         p += 3;
    %%%%%: 4976-block 7
        -: 4977:      }
        -: 4978:   } else {
    #####: 4979:      for (i=0; i < pixel_count; ++i) {
    %%%%%: 4979-block 9
    %%%%%: 4979-block 11
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4980:         int n = orig[i]*4;
    #####: 4981:         p[0] = palette[n  ];
    #####: 4982:         p[1] = palette[n+1];
    #####: 4983:         p[2] = palette[n+2];
    #####: 4984:         p[3] = palette[n+3];
    #####: 4985:         p += 4;
    %%%%%: 4985-block 10
        -: 4986:      }
        -: 4987:   }
    #####: 4988:   STBI_FREE(a->out);
    #####: 4989:   a->out = temp_out;
        -: 4990:
        -: 4991:   STBI_NOTUSED(len);
        -: 4992:
    #####: 4993:   return 1;
    %%%%%: 4993-block 12
        -: 4994:}
        -: 4995:
        -: 4996:static int stbi__unpremultiply_on_load_global = 0;
        -: 4997:static int stbi__de_iphone_flag_global = 0;
        -: 4998:
function stbi_set_unpremultiply_on_load called 0 returned 0% blocks executed 0%
    #####: 4999:STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply)
        -: 5000:{
    #####: 5001:   stbi__unpremultiply_on_load_global = flag_true_if_should_unpremultiply;
    #####: 5002:}
        -: 5003:
function stbi_convert_iphone_png_to_rgb called 0 returned 0% blocks executed 0%
    #####: 5004:STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert)
        -: 5005:{
    #####: 5006:   stbi__de_iphone_flag_global = flag_true_if_should_convert;
    #####: 5007:}
        -: 5008:
        -: 5009:#ifndef STBI_THREAD_LOCAL
        -: 5010:#define stbi__unpremultiply_on_load  stbi__unpremultiply_on_load_global
        -: 5011:#define stbi__de_iphone_flag  stbi__de_iphone_flag_global
        -: 5012:#else
        -: 5013:static STBI_THREAD_LOCAL int stbi__unpremultiply_on_load_local, stbi__unpremultiply_on_load_set;
        -: 5014:static STBI_THREAD_LOCAL int stbi__de_iphone_flag_local, stbi__de_iphone_flag_set;
        -: 5015:
function stbi_set_unpremultiply_on_load_thread called 0 returned 0% blocks executed 0%
    #####: 5016:STBIDEF void stbi_set_unpremultiply_on_load_thread(int flag_true_if_should_unpremultiply)
        -: 5017:{
    #####: 5018:   stbi__unpremultiply_on_load_local = flag_true_if_should_unpremultiply;
    #####: 5019:   stbi__unpremultiply_on_load_set = 1;
    #####: 5020:}
        -: 5021:
function stbi_convert_iphone_png_to_rgb_thread called 0 returned 0% blocks executed 0%
    #####: 5022:STBIDEF void stbi_convert_iphone_png_to_rgb_thread(int flag_true_if_should_convert)
        -: 5023:{
    #####: 5024:   stbi__de_iphone_flag_local = flag_true_if_should_convert;
    #####: 5025:   stbi__de_iphone_flag_set = 1;
    #####: 5026:}
        -: 5027:
        -: 5028:#define stbi__unpremultiply_on_load  (stbi__unpremultiply_on_load_set           \
        -: 5029:                                       ? stbi__unpremultiply_on_load_local      \
        -: 5030:                                       : stbi__unpremultiply_on_load_global)
        -: 5031:#define stbi__de_iphone_flag  (stbi__de_iphone_flag_set                         \
        -: 5032:                                ? stbi__de_iphone_flag_local                    \
        -: 5033:                                : stbi__de_iphone_flag_global)
        -: 5034:#endif // STBI_THREAD_LOCAL
        -: 5035:
function _ZL15stbi__de_iphoneP9stbi__png called 0 returned 0% blocks executed 0%
    #####: 5036:static void stbi__de_iphone(stbi__png *z)
        -: 5037:{
    #####: 5038:   stbi__context *s = z->s;
    #####: 5039:   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
    #####: 5040:   stbi_uc *p = z->out;
        -: 5041:
    #####: 5042:   if (s->img_out_n == 3) {  // convert bgr to rgb
    %%%%%: 5042-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5043:      for (i=0; i < pixel_count; ++i) {
    %%%%%: 5043-block 3
    %%%%%: 5043-block 5
branch  0 never executed
branch  1 never executed
    #####: 5044:         stbi_uc t = p[0];
    #####: 5045:         p[0] = p[2];
    #####: 5046:         p[2] = t;
    #####: 5047:         p += 3;
    %%%%%: 5047-block 4
        -: 5048:      }
        -: 5049:   } else {
    #####: 5050:      STBI_ASSERT(s->img_out_n == 4);
    %%%%%: 5050-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5050-block 7
call    2 never executed
    #####: 5051:      if (stbi__unpremultiply_on_load) {
    %%%%%: 5051-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5051-block 9
    %%%%%: 5051-block 10
    %%%%%: 5051-block 11
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 5052:         // convert bgr to rgb and unpremultiply
    #####: 5053:         for (i=0; i < pixel_count; ++i) {
    %%%%%: 5053-block 12
    %%%%%: 5053-block 17
branch  0 never executed
branch  1 never executed
    #####: 5054:            stbi_uc a = p[3];
    #####: 5055:            stbi_uc t = p[0];
    #####: 5056:            if (a) {
    %%%%%: 5056-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5057:               stbi_uc half = a / 2;
    #####: 5058:               p[0] = (p[2] * 255 + half) / a;
    #####: 5059:               p[1] = (p[1] * 255 + half) / a;
    #####: 5060:               p[2] = ( t   * 255 + half) / a;
    %%%%%: 5060-block 14
        -: 5061:            } else {
    #####: 5062:               p[0] = p[2];
    #####: 5063:               p[2] = t;
    %%%%%: 5063-block 15
        -: 5064:            }
    #####: 5065:            p += 4;
    %%%%%: 5065-block 16
        -: 5066:         }
        -: 5067:      } else {
        -: 5068:         // convert bgr to rgb
    #####: 5069:         for (i=0; i < pixel_count; ++i) {
    %%%%%: 5069-block 18
    %%%%%: 5069-block 20
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 5070:            stbi_uc t = p[0];
    #####: 5071:            p[0] = p[2];
    #####: 5072:            p[2] = t;
    #####: 5073:            p += 4;
    %%%%%: 5073-block 19
        -: 5074:         }
        -: 5075:      }
        -: 5076:   }
    #####: 5077:}
        -: 5078:
        -: 5079:#define STBI__PNG_TYPE(a,b,c,d)  (((unsigned) (a) << 24) + ((unsigned) (b) << 16) + ((unsigned) (c) << 8) + (unsigned) (d))
        -: 5080:
function _ZL20stbi__parse_png_fileP9stbi__pngii called 1 returned 100% blocks executed 41%
        1: 5081:static int stbi__parse_png_file(stbi__png *z, int scan, int req_comp)
        -: 5082:{
        1: 5083:   stbi_uc palette[1024], pal_img_n=0;
        1: 5084:   stbi_uc has_trans=0, tc[3]={0};
        -: 5085:   stbi__uint16 tc16[3];
        1: 5086:   stbi__uint32 ioff=0, idata_limit=0, i, pal_len=0;
        1: 5087:   int first=1,k,interlace=0, color=0, is_iphone=0;
        1: 5088:   stbi__context *s = z->s;
        -: 5089:
        1: 5090:   z->expanded = NULL;
        1: 5091:   z->idata = NULL;
        1: 5092:   z->out = NULL;
        -: 5093:
       1*: 5094:   if (!stbi__check_png_header(s)) return 0;
        1: 5094-block 2
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 5094-block 3
branch  3 taken 0 (fallthrough)
branch  4 taken 1
    %%%%%: 5094-block 4
        -: 5095:
       1*: 5096:   if (scan == STBI__SCAN_type) return 1;
        1: 5096-block 5
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 5096-block 6
        -: 5097:
        -: 5098:   for (;;) {
        7: 5099:      stbi__pngchunk c = stbi__get_chunk_header(s);
        7: 5099-block 7
call    0 returned 7
branch  1 taken 7 (fallthrough)
branch  2 taken 0 (throw)
        7: 5100:      switch (c.type) {
        7: 5100-block 8
branch  0 taken 0
branch  1 taken 1
branch  2 taken 0
branch  3 taken 0
branch  4 taken 1
branch  5 taken 1
branch  6 taken 4
    #####: 5101:         case STBI__PNG_TYPE('C','g','B','I'):
    #####: 5102:            is_iphone = 1;
    #####: 5103:            stbi__skip(s, c.length);
    %%%%%: 5103-block 9
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5104:            break;
    %%%%%: 5104-block 10
        1: 5105:         case STBI__PNG_TYPE('I','H','D','R'): {
        -: 5106:            int comp,filter;
       2*: 5107:            if (!first) return stbi__err("multiple IHDR","Corrupt PNG");
        1: 5107-block 11
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 5107-block 12
call    2 never executed
        1: 5107-block 183
        1: 5108:            first = 0;
       1*: 5109:            if (c.length != 13) return stbi__err("bad IHDR len","Corrupt PNG");
        1: 5109-block 13
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 5109-block 14
call    2 never executed
        1: 5110:            s->img_x = stbi__get32be(s);
        1: 5110-block 15
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 5111:            s->img_y = stbi__get32be(s);
        1: 5111-block 16
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
       1*: 5112:            if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
        1: 5112-block 17
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 5112-block 18
call    2 never executed
       1*: 5113:            if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
        1: 5113-block 19
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 5113-block 20
call    2 never executed
       1*: 5114:            z->depth = stbi__get8(s);  if (z->depth != 1 && z->depth != 2 && z->depth != 4 && z->depth != 8 && z->depth != 16)  return stbi__err("1/2/4/8/16-bit only","PNG not supported: 1/2/4/8/16-bit only");
        1: 5114-block 21
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 5114-block 22
branch  3 taken 1 (fallthrough)
branch  4 taken 0
        1: 5114-block 23
branch  5 taken 1 (fallthrough)
branch  6 taken 0
        1: 5114-block 24
branch  7 taken 1 (fallthrough)
branch  8 taken 0
        1: 5114-block 25
branch  9 taken 0 (fallthrough)
branch 10 taken 1
    %%%%%: 5114-block 26
branch 11 never executed (fallthrough)
branch 12 never executed
    %%%%%: 5114-block 27
call   13 never executed
       1*: 5115:            color = stbi__get8(s);  if (color > 6)         return stbi__err("bad ctype","Corrupt PNG");
        1: 5115-block 28
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 5115-block 29
branch  3 taken 0 (fallthrough)
branch  4 taken 1
    %%%%%: 5115-block 30
call    5 never executed
       1*: 5116:            if (color == 3 && z->depth == 16)                  return stbi__err("bad ctype","Corrupt PNG");
        1: 5116-block 31
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 5116-block 32
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5116-block 33
call    4 never executed
       1*: 5117:            if (color == 3) pal_img_n = 3; else if (color & 1) return stbi__err("bad ctype","Corrupt PNG");
        1: 5117-block 34
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 5117-block 35
        1: 5117-block 36
branch  2 taken 0 (fallthrough)
branch  3 taken 1
    %%%%%: 5117-block 37
call    4 never executed
       1*: 5118:            comp  = stbi__get8(s);  if (comp) return stbi__err("bad comp method","Corrupt PNG");
        1: 5118-block 38
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 5118-block 39
branch  3 taken 0 (fallthrough)
branch  4 taken 1
    %%%%%: 5118-block 40
call    5 never executed
       1*: 5119:            filter= stbi__get8(s);  if (filter) return stbi__err("bad filter method","Corrupt PNG");
        1: 5119-block 41
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 5119-block 42
branch  3 taken 0 (fallthrough)
branch  4 taken 1
    %%%%%: 5119-block 43
call    5 never executed
       1*: 5120:            interlace = stbi__get8(s); if (interlace>1) return stbi__err("bad interlace method","Corrupt PNG");
        1: 5120-block 44
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 5120-block 45
branch  3 taken 0 (fallthrough)
branch  4 taken 1
    %%%%%: 5120-block 46
call    5 never executed
       1*: 5121:            if (!s->img_x || !s->img_y) return stbi__err("0-pixel image","Corrupt PNG");
        1: 5121-block 47
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 5121-block 48
branch  2 taken 0 (fallthrough)
branch  3 taken 1
    %%%%%: 5121-block 49
call    4 never executed
        1: 5122:            if (!pal_img_n) {
        1: 5122-block 50
branch  0 taken 1 (fallthrough)
branch  1 taken 0
       1*: 5123:               s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);
        1: 5123-block 51
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 5123-block 52
    %%%%%: 5123-block 53
       1*: 5124:               if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err("too large", "Image too large to decode");
        1: 5124-block 54
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 5124-block 55
call    2 never executed
        -: 5125:            } else {
        -: 5126:               // if paletted, then pal_n is our final components, and
        -: 5127:               // img_n is # components to decompress/filter.
    #####: 5128:               s->img_n = 1;
    #####: 5129:               if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err("too large","Corrupt PNG");
    %%%%%: 5129-block 56
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5129-block 57
call    2 never executed
        -: 5130:            }
        -: 5131:            // even with SCAN_header, have to scan to see if we have a tRNS
        1: 5132:            break;
        1: 5132-block 58
        -: 5133:         }
        -: 5134:
    #####: 5135:         case STBI__PNG_TYPE('P','L','T','E'):  {
    #####: 5136:            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
    %%%%%: 5136-block 59
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5136-block 60
call    2 never executed
    #####: 5137:            if (c.length > 256*3) return stbi__err("invalid PLTE","Corrupt PNG");
    %%%%%: 5137-block 61
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5137-block 62
call    2 never executed
    #####: 5138:            pal_len = c.length / 3;
    #####: 5139:            if (pal_len * 3 != c.length) return stbi__err("invalid PLTE","Corrupt PNG");
    %%%%%: 5139-block 63
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5139-block 64
call    2 never executed
    #####: 5140:            for (i=0; i < pal_len; ++i) {
    %%%%%: 5140-block 65
    %%%%%: 5140-block 70
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 5141:               palette[i*4+0] = stbi__get8(s);
    %%%%%: 5141-block 66
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5142:               palette[i*4+1] = stbi__get8(s);
    %%%%%: 5142-block 67
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5143:               palette[i*4+2] = stbi__get8(s);
    %%%%%: 5143-block 68
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5144:               palette[i*4+3] = 255;
    %%%%%: 5144-block 69
        -: 5145:            }
    #####: 5146:            break;
    %%%%%: 5146-block 71
        -: 5147:         }
        -: 5148:
    #####: 5149:         case STBI__PNG_TYPE('t','R','N','S'): {
    #####: 5150:            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
    %%%%%: 5150-block 72
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5150-block 73
call    2 never executed
    #####: 5151:            if (z->idata) return stbi__err("tRNS after IDAT","Corrupt PNG");
    %%%%%: 5151-block 74
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5151-block 75
call    2 never executed
    #####: 5152:            if (pal_img_n) {
    %%%%%: 5152-block 76
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5153:               if (scan == STBI__SCAN_header) { s->img_n = 4; return 1; }
    %%%%%: 5153-block 77
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5153-block 78
    #####: 5154:               if (pal_len == 0) return stbi__err("tRNS before PLTE","Corrupt PNG");
    %%%%%: 5154-block 79
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5154-block 80
call    2 never executed
    #####: 5155:               if (c.length > pal_len) return stbi__err("bad tRNS len","Corrupt PNG");
    %%%%%: 5155-block 81
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5155-block 82
call    2 never executed
    #####: 5156:               pal_img_n = 4;
    #####: 5157:               for (i=0; i < c.length; ++i)
    %%%%%: 5157-block 83
    %%%%%: 5157-block 86
branch  0 never executed
branch  1 never executed
    #####: 5158:                  palette[i*4+3] = stbi__get8(s);
    %%%%%: 5158-block 84
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 5158-block 85
        -: 5159:            } else {
    #####: 5160:               if (!(s->img_n & 1)) return stbi__err("tRNS with alpha","Corrupt PNG");
    %%%%%: 5160-block 87
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5160-block 88
call    2 never executed
    #####: 5161:               if (c.length != (stbi__uint32) s->img_n*2) return stbi__err("bad tRNS len","Corrupt PNG");
    %%%%%: 5161-block 89
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5161-block 90
call    2 never executed
    #####: 5162:               has_trans = 1;
        -: 5163:               // non-paletted with tRNS = constant alpha. if header-scanning, we can stop now.
    #####: 5164:               if (scan == STBI__SCAN_header) { ++s->img_n; return 1; }
    %%%%%: 5164-block 91
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5164-block 92
    #####: 5165:               if (z->depth == 16) {
    %%%%%: 5165-block 93
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5166:                  for (k = 0; k < s->img_n && k < 3; ++k) // extra loop test to suppress false GCC warning
    %%%%%: 5166-block 94
    %%%%%: 5166-block 97
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5166-block 98
branch  2 never executed
branch  3 never executed
    #####: 5167:                     tc16[k] = (stbi__uint16)stbi__get16be(s); // copy the values as-is
    %%%%%: 5167-block 95
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 5167-block 96
        -: 5168:               } else {
    #####: 5169:                  for (k = 0; k < s->img_n && k < 3; ++k)
    %%%%%: 5169-block 99
    %%%%%: 5169-block 102
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5169-block 103
branch  2 never executed
branch  3 never executed (fallthrough)
    #####: 5170:                     tc[k] = (stbi_uc)(stbi__get16be(s) & 255) * stbi__depth_scale_table[z->depth]; // non 8-bit images will be larger
    %%%%%: 5170-block 100
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 5170-block 101
        -: 5171:               }
        -: 5172:            }
    #####: 5173:            break;
    %%%%%: 5173-block 104
        -: 5174:         }
        -: 5175:
        1: 5176:         case STBI__PNG_TYPE('I','D','A','T'): {
       1*: 5177:            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
        1: 5177-block 105
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 5177-block 106
call    2 never executed
       1*: 5178:            if (pal_img_n && !pal_len) return stbi__err("no PLTE","Corrupt PNG");
        1: 5178-block 107
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 5178-block 108
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5178-block 109
call    4 never executed
        1: 5179:            if (scan == STBI__SCAN_header) {
        1: 5179-block 110
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 5180:               // header scan definitely stops at first IDAT
    #####: 5181:               if (pal_img_n)
    %%%%%: 5181-block 111
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5182:                  s->img_n = pal_img_n;
    %%%%%: 5182-block 112
    #####: 5183:               return 1;
    %%%%%: 5183-block 113
        -: 5184:            }
       1*: 5185:            if (c.length > (1u << 30)) return stbi__err("IDAT size limit", "IDAT section larger than 2^30 bytes");
        1: 5185-block 114
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 5185-block 115
call    2 never executed
       1*: 5186:            if ((int)(ioff + c.length) < (int)ioff) return 0;
        1: 5186-block 116
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 5186-block 117
        1: 5187:            if (ioff + c.length > idata_limit) {
        1: 5187-block 118
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 5188:               stbi__uint32 idata_limit_old = idata_limit;
        -: 5189:               stbi_uc *p;
        1: 5190:               if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;
        1: 5190-block 119
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 5190-block 120
        1: 5191:               while (ioff + c.length > idata_limit)
        1: 5191-block 121
        1: 5191-block 123
branch  0 taken 0
branch  1 taken 1 (fallthrough)
    #####: 5192:                  idata_limit *= 2;
    %%%%%: 5192-block 122
        -: 5193:               STBI_NOTUSED(idata_limit_old);
       1*: 5194:               p = (stbi_uc *) STBI_REALLOC_SIZED(z->idata, idata_limit_old, idata_limit); if (p == NULL) return stbi__err("outofmem", "Out of memory");
        1: 5194-block 124
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 5194-block 125
call    2 never executed
        1: 5195:               z->idata = p;
        1: 5195-block 126
        -: 5196:            }
       1*: 5197:            if (!stbi__getn(s, z->idata+ioff,c.length)) return stbi__err("outofdata","Corrupt PNG");
        1: 5197-block 127
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 5197-block 128
branch  3 taken 0 (fallthrough)
branch  4 taken 1
    %%%%%: 5197-block 129
call    5 never executed
        1: 5198:            ioff += c.length;
        1: 5199:            break;
        1: 5199-block 130
        -: 5200:         }
        -: 5201:
        1: 5202:         case STBI__PNG_TYPE('I','E','N','D'): {
        -: 5203:            stbi__uint32 raw_len, bpl;
       1*: 5204:            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
        1: 5204-block 131
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 5204-block 132
call    2 never executed
       1*: 5205:            if (scan != STBI__SCAN_load) return 1;
        1: 5205-block 133
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 5205-block 134
       1*: 5206:            if (z->idata == NULL) return stbi__err("no IDAT","Corrupt PNG");
        1: 5206-block 135
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 5206-block 136
call    2 never executed
        -: 5207:            // initial guess for decoded data size to avoid unnecessary reallocs
        1: 5208:            bpl = (s->img_x * z->depth + 7) / 8; // bytes per line, per component
        1: 5209:            raw_len = bpl * s->img_y * s->img_n /* pixels */ + s->img_y /* filter mode per row */;
        1: 5210:            z->expanded = (stbi_uc *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, raw_len, (int *) &raw_len, !is_iphone);
        1: 5210-block 137
call    0 returned 1
       1*: 5211:            if (z->expanded == NULL) return 0; // zlib should set error
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 5211-block 139
        1: 5212:            STBI_FREE(z->idata); z->idata = NULL;
       1*: 5213:            if ((req_comp == s->img_n+1 && req_comp != 3 && !pal_img_n) || has_trans)
        1: 5213-block 140
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 5213-block 141
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1: 5213-block 142
branch  4 taken 0 (fallthrough)
branch  5 taken 1
    %%%%%: 5213-block 143
branch  6 never executed (fallthrough)
branch  7 never executed
        1: 5214:               s->img_out_n = s->img_n+1;
        1: 5214-block 144
        -: 5215:            else
    #####: 5216:               s->img_out_n = s->img_n;
    %%%%%: 5216-block 145
       1*: 5217:            if (!stbi__create_png_image(z, z->expanded, raw_len, s->img_out_n, z->depth, color, interlace)) return 0;
        1: 5217-block 146
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    %%%%%: 5217-block 148
        1: 5218:            if (has_trans) {
        1: 5218-block 149
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 5219:               if (z->depth == 16) {
    %%%%%: 5219-block 150
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5220:                  if (!stbi__compute_transparency16(z, tc16, s->img_out_n)) return 0;
    %%%%%: 5220-block 151
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 5220-block 153
        -: 5221:               } else {
    #####: 5222:                  if (!stbi__compute_transparency(z, tc, s->img_out_n)) return 0;
    %%%%%: 5222-block 154
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 5222-block 156
        -: 5223:               }
        -: 5224:            }
       1*: 5225:            if (is_iphone && stbi__de_iphone_flag && s->img_out_n > 2)
        1: 5225-block 157
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 5225-block 158
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5225-block 159
    %%%%%: 5225-block 160
    %%%%%: 5225-block 161
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 5225-block 162
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 5226:               stbi__de_iphone(z);
    %%%%%: 5226-block 163
call    0 never executed
        1: 5227:            if (pal_img_n) {
        1: 5227-block 164
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 5228:               // pal_img_n == 3 or 4
    #####: 5229:               s->img_n = pal_img_n; // record the actual colors we had
    #####: 5230:               s->img_out_n = pal_img_n;
    #####: 5231:               if (req_comp >= 3) s->img_out_n = req_comp;
    %%%%%: 5231-block 165
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5231-block 166
    #####: 5232:               if (!stbi__expand_png_palette(z, palette, pal_len, s->img_out_n))
    %%%%%: 5232-block 167
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 5233:                  return 0;
    %%%%%: 5233-block 169
        1: 5234:            } else if (has_trans) {
        1: 5234-block 170
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 5235:               // non-paletted image with tRNS -> source image has (constant) alpha
    #####: 5236:               ++s->img_n;
    %%%%%: 5236-block 171
        -: 5237:            }
        1: 5238:            STBI_FREE(z->expanded); z->expanded = NULL;
        -: 5239:            // end of PNG chunk, read and skip CRC
        1: 5240:            stbi__get32be(s);
        1: 5240-block 172
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 5241:            return 1;
        1: 5241-block 173
        -: 5242:         }
        -: 5243:
        4: 5244:         default:
        -: 5245:            // if critical, fail
       4*: 5246:            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
        4: 5246-block 175
branch  0 taken 0 (fallthrough)
branch  1 taken 4
    %%%%%: 5246-block 176
call    2 never executed
        4: 5247:            if ((c.type & (1 << 29)) == 0) {
        4: 5247-block 177
branch  0 taken 0 (fallthrough)
branch  1 taken 4
        -: 5248:               #ifndef STBI_NO_FAILURE_STRINGS
        -: 5249:               // not threadsafe
        -: 5250:               static char invalid_chunk[] = "XXXX PNG chunk not known";
    #####: 5251:               invalid_chunk[0] = STBI__BYTECAST(c.type >> 24);
    #####: 5252:               invalid_chunk[1] = STBI__BYTECAST(c.type >> 16);
    #####: 5253:               invalid_chunk[2] = STBI__BYTECAST(c.type >>  8);
    #####: 5254:               invalid_chunk[3] = STBI__BYTECAST(c.type >>  0);
        -: 5255:               #endif
    #####: 5256:               return stbi__err(invalid_chunk, "PNG not supported: unknown PNG chunk type");
    %%%%%: 5256-block 178
call    0 never executed
        -: 5257:            }
        4: 5258:            stbi__skip(s, c.length);
        4: 5258-block 179
call    0 returned 4
branch  1 taken 4 (fallthrough)
branch  2 taken 0 (throw)
        4: 5259:            break;
        4: 5259-block 180
        -: 5260:      }
        -: 5261:      // end of PNG chunk, read and skip CRC
        6: 5262:      stbi__get32be(s);
        6: 5262-block 181
call    0 returned 6
branch  1 taken 6 (fallthrough)
branch  2 taken 0 (throw)
        6: 5263:   }
        6: 5263-block 182
        -: 5264:}
        -: 5265:
function _ZL12stbi__do_pngP9stbi__pngPiS1_S1_iP17stbi__result_info called 1 returned 100% blocks executed 48%
        1: 5266:static void *stbi__do_png(stbi__png *p, int *x, int *y, int *n, int req_comp, stbi__result_info *ri)
        -: 5267:{
        1: 5268:   void *result=NULL;
       1*: 5269:   if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");
        1: 5269-block 2
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 5269-block 3
branch  2 taken 0 (fallthrough)
branch  3 taken 1
    %%%%%: 5269-block 4
call    4 never executed
        1: 5270:   if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {
        1: 5270-block 6
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0
        1: 5271:      if (p->depth <= 8)
        1: 5271-block 8
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 5272:         ri->bits_per_channel = 8;
        1: 5272-block 9
    #####: 5273:      else if (p->depth == 16)
    %%%%%: 5273-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5274:         ri->bits_per_channel = 16;
    %%%%%: 5274-block 11
        -: 5275:      else
    #####: 5276:         return stbi__errpuc("bad bits_per_channel", "PNG not supported: unsupported color depth");
    %%%%%: 5276-block 12
call    0 never executed
        1: 5277:      result = p->out;
        1: 5278:      p->out = NULL;
        1: 5279:      if (req_comp && req_comp != p->s->img_out_n) {
        1: 5279-block 14
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 5279-block 15
branch  2 taken 0 (fallthrough)
branch  3 taken 1
    #####: 5280:         if (ri->bits_per_channel == 8)
    %%%%%: 5280-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5281:            result = stbi__convert_format((unsigned char *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
    %%%%%: 5281-block 17
call    0 never executed
        -: 5282:         else
    #####: 5283:            result = stbi__convert_format16((stbi__uint16 *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
    %%%%%: 5283-block 18
call    0 never executed
    #####: 5284:         p->s->img_out_n = req_comp;
    #####: 5285:         if (result == NULL) return result;
    %%%%%: 5285-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5285-block 20
        -: 5286:      }
        1: 5287:      *x = p->s->img_x;
        1: 5288:      *y = p->s->img_y;
       1*: 5289:      if (n) *n = p->s->img_n;
        1: 5289-block 21
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 5289-block 22
        -: 5290:   }
        1: 5291:   STBI_FREE(p->out);      p->out      = NULL;
        1: 5292:   STBI_FREE(p->expanded); p->expanded = NULL;
        1: 5293:   STBI_FREE(p->idata);    p->idata    = NULL;
        -: 5294:
        1: 5295:   return result;
        1: 5295-block 23
        -: 5296:}
        -: 5297:
function _ZL14stbi__png_loadP13stbi__contextPiS1_S1_iP17stbi__result_info called 1 returned 100% blocks executed 100%
        1: 5298:static void *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
        -: 5299:{
        -: 5300:   stbi__png p;
        1: 5301:   p.s = s;
        2: 5302:   return stbi__do_png(&p, x,y,comp,req_comp, ri);
        1: 5302-block 2
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 5302-block 3
        1: 5302-block 5
        -: 5303:}
        -: 5304:
function _ZL14stbi__png_testP13stbi__context called 1 returned 100% blocks executed 100%
        1: 5305:static int stbi__png_test(stbi__context *s)
        -: 5306:{
        -: 5307:   int r;
        1: 5308:   r = stbi__check_png_header(s);
        1: 5308-block 2
call    0 returned 1
        1: 5309:   stbi__rewind(s);
call    0 returned 1
        1: 5310:   return r;
        -: 5311:}
        -: 5312:
function _ZL18stbi__png_info_rawP9stbi__pngPiS1_S1_ called 0 returned 0% blocks executed 0%
    #####: 5313:static int stbi__png_info_raw(stbi__png *p, int *x, int *y, int *comp)
        -: 5314:{
    #####: 5315:   if (!stbi__parse_png_file(p, STBI__SCAN_header, 0)) {
    %%%%%: 5315-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 5316:      stbi__rewind( p->s );
    %%%%%: 5316-block 4
call    0 never executed
    #####: 5317:      return 0;
        -: 5318:   }
    #####: 5319:   if (x) *x = p->s->img_x;
    %%%%%: 5319-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5319-block 7
    #####: 5320:   if (y) *y = p->s->img_y;
    %%%%%: 5320-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5320-block 9
    #####: 5321:   if (comp) *comp = p->s->img_n;
    %%%%%: 5321-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5321-block 11
    #####: 5322:   return 1;
    %%%%%: 5322-block 12
        -: 5323:}
        -: 5324:
function _ZL14stbi__png_infoP13stbi__contextPiS1_S1_ called 0 returned 0% blocks executed 0%
    #####: 5325:static int stbi__png_info(stbi__context *s, int *x, int *y, int *comp)
        -: 5326:{
        -: 5327:   stbi__png p;
    #####: 5328:   p.s = s;
    #####: 5329:   return stbi__png_info_raw(&p, x, y, comp);
    %%%%%: 5329-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 5329-block 3
    %%%%%: 5329-block 5
        -: 5330:}
        -: 5331:
function _ZL14stbi__png_is16P13stbi__context called 0 returned 0% blocks executed 0%
    #####: 5332:static int stbi__png_is16(stbi__context *s)
        -: 5333:{
        -: 5334:   stbi__png p;
    #####: 5335:   p.s = s;
    #####: 5336:   if (!stbi__png_info_raw(&p, NULL, NULL, NULL))
    %%%%%: 5336-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 5336-block 3
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 5337:	   return 0;
    %%%%%: 5337-block 4
    #####: 5338:   if (p.depth != 16) {
    %%%%%: 5338-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5339:      stbi__rewind(p.s);
    %%%%%: 5339-block 6
call    0 never executed
    #####: 5340:      return 0;
        -: 5341:   }
    #####: 5342:   return 1;
    %%%%%: 5342-block 8
        -: 5343:}
        -: 5344:#endif
        -: 5345:
        -: 5346:// Microsoft/Windows BMP image
        -: 5347:
        -: 5348:#ifndef STBI_NO_BMP
function _ZL18stbi__bmp_test_rawP13stbi__context called 0 returned 0% blocks executed 0%
    #####: 5349:static int stbi__bmp_test_raw(stbi__context *s)
        -: 5350:{
        -: 5351:   int r;
        -: 5352:   int sz;
    #####: 5353:   if (stbi__get8(s) != 'B') return 0;
    %%%%%: 5353-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 5353-block 4
    #####: 5354:   if (stbi__get8(s) != 'M') return 0;
    %%%%%: 5354-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 5354-block 7
    #####: 5355:   stbi__get32le(s); // discard filesize
    %%%%%: 5355-block 8
call    0 never executed
    #####: 5356:   stbi__get16le(s); // discard reserved
call    0 never executed
    #####: 5357:   stbi__get16le(s); // discard reserved
call    0 never executed
    #####: 5358:   stbi__get32le(s); // discard data offset
call    0 never executed
    #####: 5359:   sz = stbi__get32le(s);
call    0 never executed
    #####: 5360:   r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5360-block 14
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5360-block 15
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 5360-block 16
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 5360-block 17
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%: 5360-block 18
    %%%%%: 5360-block 19
    #####: 5361:   return r;
    %%%%%: 5361-block 20
        -: 5362:}
        -: 5363:
function _ZL14stbi__bmp_testP13stbi__context called 0 returned 0% blocks executed 0%
    #####: 5364:static int stbi__bmp_test(stbi__context *s)
        -: 5365:{
    #####: 5366:   int r = stbi__bmp_test_raw(s);
    %%%%%: 5366-block 2
call    0 never executed
    #####: 5367:   stbi__rewind(s);
call    0 never executed
    #####: 5368:   return r;
        -: 5369:}
        -: 5370:
        -: 5371:
        -: 5372:// returns 0..31 for the highest set bit
function _ZL14stbi__high_bitj called 0 returned 0% blocks executed 0%
    #####: 5373:static int stbi__high_bit(unsigned int z)
        -: 5374:{
    #####: 5375:   int n=0;
    #####: 5376:   if (z == 0) return -1;
    %%%%%: 5376-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5376-block 3
    #####: 5377:   if (z >= 0x10000) { n += 16; z >>= 16; }
    %%%%%: 5377-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5377-block 5
    #####: 5378:   if (z >= 0x00100) { n +=  8; z >>=  8; }
    %%%%%: 5378-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5378-block 7
    #####: 5379:   if (z >= 0x00010) { n +=  4; z >>=  4; }
    %%%%%: 5379-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5379-block 9
    #####: 5380:   if (z >= 0x00004) { n +=  2; z >>=  2; }
    %%%%%: 5380-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5380-block 11
    #####: 5381:   if (z >= 0x00002) { n +=  1;/* >>=  1;*/ }
    %%%%%: 5381-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5381-block 13
    #####: 5382:   return n;
    %%%%%: 5382-block 14
        -: 5383:}
        -: 5384:
function _ZL14stbi__bitcountj called 0 returned 0% blocks executed 0%
    #####: 5385:static int stbi__bitcount(unsigned int a)
        -: 5386:{
    #####: 5387:   a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2
    #####: 5388:   a = (a & 0x33333333) + ((a >>  2) & 0x33333333); // max 4
    #####: 5389:   a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits
    #####: 5390:   a = (a + (a >> 8)); // max 16 per 8 bits
    #####: 5391:   a = (a + (a >> 16)); // max 32 per 8 bits
    #####: 5392:   return a & 0xff;
    %%%%%: 5392-block 2
        -: 5393:}
        -: 5394:
        -: 5395:// extract an arbitrarily-aligned N-bit value (N=bits)
        -: 5396:// from v, and then make it 8-bits long and fractionally
        -: 5397:// extend it to full full range.
function _ZL17stbi__shiftsignedjii called 0 returned 0% blocks executed 0%
    #####: 5398:static int stbi__shiftsigned(unsigned int v, int shift, int bits)
        -: 5399:{
        -: 5400:   static unsigned int mul_table[9] = {
        -: 5401:      0,
        -: 5402:      0xff/*0b11111111*/, 0x55/*0b01010101*/, 0x49/*0b01001001*/, 0x11/*0b00010001*/,
        -: 5403:      0x21/*0b00100001*/, 0x41/*0b01000001*/, 0x81/*0b10000001*/, 0x01/*0b00000001*/,
        -: 5404:   };
        -: 5405:   static unsigned int shift_table[9] = {
        -: 5406:      0, 0,0,1,0,2,4,6,0,
        -: 5407:   };
    #####: 5408:   if (shift < 0)
    %%%%%: 5408-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5409:      v <<= -shift;
    %%%%%: 5409-block 3
        -: 5410:   else
    #####: 5411:      v >>= shift;
    %%%%%: 5411-block 4
    #####: 5412:   STBI_ASSERT(v < 256);
    %%%%%: 5412-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5412-block 6
call    2 never executed
    #####: 5413:   v >>= (8-bits);
    #####: 5414:   STBI_ASSERT(bits >= 0 && bits <= 8);
    %%%%%: 5414-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5414-block 8
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5414-block 9
    %%%%%: 5414-block 10
call    4 never executed
    #####: 5415:   return (int) ((unsigned) v * mul_table[bits]) >> shift_table[bits];
    %%%%%: 5415-block 11
        -: 5416:}
        -: 5417:
        -: 5418:typedef struct
        -: 5419:{
        -: 5420:   int bpp, offset, hsz;
        -: 5421:   unsigned int mr,mg,mb,ma, all_a;
        -: 5422:   int extra_read;
        -: 5423:} stbi__bmp_data;
        -: 5424:
function _ZL27stbi__bmp_set_mask_defaultsP14stbi__bmp_datai called 0 returned 0% blocks executed 0%
    #####: 5425:static int stbi__bmp_set_mask_defaults(stbi__bmp_data *info, int compress)
        -: 5426:{
        -: 5427:   // BI_BITFIELDS specifies masks explicitly, don't override
    #####: 5428:   if (compress == 3)
    %%%%%: 5428-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5429:      return 1;
    %%%%%: 5429-block 3
        -: 5430:
    #####: 5431:   if (compress == 0) {
    %%%%%: 5431-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5432:      if (info->bpp == 16) {
    %%%%%: 5432-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5433:         info->mr = 31u << 10;
    #####: 5434:         info->mg = 31u <<  5;
    #####: 5435:         info->mb = 31u <<  0;
    %%%%%: 5435-block 6
    #####: 5436:      } else if (info->bpp == 32) {
    %%%%%: 5436-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5437:         info->mr = 0xffu << 16;
    #####: 5438:         info->mg = 0xffu <<  8;
    #####: 5439:         info->mb = 0xffu <<  0;
    #####: 5440:         info->ma = 0xffu << 24;
    #####: 5441:         info->all_a = 0; // if all_a is 0 at end, then we loaded alpha channel but it was all 0
    %%%%%: 5441-block 8
        -: 5442:      } else {
        -: 5443:         // otherwise, use defaults, which is all-0
    #####: 5444:         info->mr = info->mg = info->mb = info->ma = 0;
    %%%%%: 5444-block 9
        -: 5445:      }
    #####: 5446:      return 1;
    %%%%%: 5446-block 10
        -: 5447:   }
    #####: 5448:   return 0; // error
    %%%%%: 5448-block 11
        -: 5449:}
        -: 5450:
function _ZL22stbi__bmp_parse_headerP13stbi__contextP14stbi__bmp_data called 0 returned 0% blocks executed 0%
    #####: 5451:static void *stbi__bmp_parse_header(stbi__context *s, stbi__bmp_data *info)
        -: 5452:{
        -: 5453:   int hsz;
    #####: 5454:   if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc("not BMP", "Corrupt BMP");
    %%%%%: 5454-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 5454-block 4
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 5454-block 6
    %%%%%: 5454-block 7
    %%%%%: 5454-block 8
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 5454-block 9
call    8 never executed
    #####: 5455:   stbi__get32le(s); // discard filesize
    %%%%%: 5455-block 11
call    0 never executed
    #####: 5456:   stbi__get16le(s); // discard reserved
call    0 never executed
    #####: 5457:   stbi__get16le(s); // discard reserved
call    0 never executed
    #####: 5458:   info->offset = stbi__get32le(s);
call    0 never executed
    #####: 5459:   info->hsz = hsz = stbi__get32le(s);
call    0 never executed
    #####: 5460:   info->mr = info->mg = info->mb = info->ma = 0;
    #####: 5461:   info->extra_read = 14;
        -: 5462:
    #####: 5463:   if (info->offset < 0) return stbi__errpuc("bad BMP", "bad BMP");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5463-block 17
call    2 never executed
        -: 5464:
    #####: 5465:   if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) return stbi__errpuc("unknown BMP", "BMP type not supported: unknown");
    %%%%%: 5465-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5465-block 20
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5465-block 21
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 5465-block 22
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 5465-block 23
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%: 5465-block 24
call   10 never executed
    #####: 5466:   if (hsz == 12) {
    %%%%%: 5466-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5467:      s->img_x = stbi__get16le(s);
    %%%%%: 5467-block 27
call    0 never executed
    #####: 5468:      s->img_y = stbi__get16le(s);
call    0 never executed
        -: 5469:   } else {
    #####: 5470:      s->img_x = stbi__get32le(s);
    %%%%%: 5470-block 30
call    0 never executed
    #####: 5471:      s->img_y = stbi__get32le(s);
call    0 never executed
        -: 5472:   }
    #####: 5473:   if (stbi__get16le(s) != 1) return stbi__errpuc("bad BMP", "bad BMP");
    %%%%%: 5473-block 33
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 5473-block 35
call    3 never executed
    #####: 5474:   info->bpp = stbi__get16le(s);
    %%%%%: 5474-block 37
call    0 never executed
    #####: 5475:   if (hsz != 12) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5476:      int compress = stbi__get32le(s);
    %%%%%: 5476-block 39
call    0 never executed
    #####: 5477:      if (compress == 1 || compress == 2) return stbi__errpuc("BMP RLE", "BMP type not supported: RLE");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5477-block 41
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5477-block 42
call    4 never executed
    #####: 5478:      if (compress >= 4) return stbi__errpuc("BMP JPEG/PNG", "BMP type not supported: unsupported compression"); // this includes PNG/JPEG modes
    %%%%%: 5478-block 44
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5478-block 45
call    2 never executed
    #####: 5479:      if (compress == 3 && info->bpp != 16 && info->bpp != 32) return stbi__errpuc("bad BMP", "bad BMP"); // bitfields requires 16 or 32 bits/pixel
    %%%%%: 5479-block 47
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5479-block 48
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5479-block 49
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 5479-block 50
call    6 never executed
    #####: 5480:      stbi__get32le(s); // discard sizeof
    %%%%%: 5480-block 52
call    0 never executed
    #####: 5481:      stbi__get32le(s); // discard hres
call    0 never executed
    #####: 5482:      stbi__get32le(s); // discard vres
call    0 never executed
    #####: 5483:      stbi__get32le(s); // discard colorsused
call    0 never executed
    #####: 5484:      stbi__get32le(s); // discard max important
call    0 never executed
    #####: 5485:      if (hsz == 40 || hsz == 56) {
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5485-block 58
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 5486:         if (hsz == 56) {
    %%%%%: 5486-block 59
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5487:            stbi__get32le(s);
    %%%%%: 5487-block 60
call    0 never executed
    #####: 5488:            stbi__get32le(s);
call    0 never executed
    #####: 5489:            stbi__get32le(s);
call    0 never executed
    #####: 5490:            stbi__get32le(s);
call    0 never executed
        -: 5491:         }
    #####: 5492:         if (info->bpp == 16 || info->bpp == 32) {
    %%%%%: 5492-block 64
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5492-block 65
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 5493:            if (compress == 0) {
    %%%%%: 5493-block 66
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5494:               stbi__bmp_set_mask_defaults(info, compress);
    %%%%%: 5494-block 67
call    0 never executed
    #####: 5495:            } else if (compress == 3) {
    %%%%%: 5495-block 68
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5496:               info->mr = stbi__get32le(s);
    %%%%%: 5496-block 69
call    0 never executed
    #####: 5497:               info->mg = stbi__get32le(s);
call    0 never executed
    #####: 5498:               info->mb = stbi__get32le(s);
call    0 never executed
    #####: 5499:               info->extra_read += 12;
        -: 5500:               // not documented, but generated by photoshop and handled by mspaint
    #####: 5501:               if (info->mr == info->mg && info->mg == info->mb) {
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5501-block 73
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 5502:                  // ?!?!?
    #####: 5503:                  return stbi__errpuc("bad BMP", "bad BMP");
    %%%%%: 5503-block 74
call    0 never executed
        -: 5504:               }
        -: 5505:            } else
    #####: 5506:               return stbi__errpuc("bad BMP", "bad BMP");
    %%%%%: 5506-block 76
call    0 never executed
        -: 5507:         }
        -: 5508:      } else {
        -: 5509:         // V4/V5 header
        -: 5510:         int i;
    #####: 5511:         if (hsz != 108 && hsz != 124)
    %%%%%: 5511-block 79
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5511-block 80
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 5512:            return stbi__errpuc("bad BMP", "bad BMP");
    %%%%%: 5512-block 81
call    0 never executed
    #####: 5513:         info->mr = stbi__get32le(s);
    %%%%%: 5513-block 83
call    0 never executed
    #####: 5514:         info->mg = stbi__get32le(s);
call    0 never executed
    #####: 5515:         info->mb = stbi__get32le(s);
call    0 never executed
    #####: 5516:         info->ma = stbi__get32le(s);
call    0 never executed
    #####: 5517:         if (compress != 3) // override mr/mg/mb unless in BI_BITFIELDS mode, as per docs
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5518:            stbi__bmp_set_mask_defaults(info, compress);
    %%%%%: 5518-block 88
call    0 never executed
    #####: 5519:         stbi__get32le(s); // discard color space
    %%%%%: 5519-block 89
call    0 never executed
    #####: 5520:         for (i=0; i < 12; ++i)
    %%%%%: 5520-block 93
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 5521:            stbi__get32le(s); // discard color space parameters
    %%%%%: 5521-block 91
call    0 never executed
    #####: 5522:         if (hsz == 124) {
    %%%%%: 5522-block 94
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5523:            stbi__get32le(s); // discard rendering intent
    %%%%%: 5523-block 95
call    0 never executed
    #####: 5524:            stbi__get32le(s); // discard offset of profile data
call    0 never executed
    #####: 5525:            stbi__get32le(s); // discard size of profile data
call    0 never executed
    #####: 5526:            stbi__get32le(s); // discard reserved
call    0 never executed
        -: 5527:         }
        -: 5528:      }
        -: 5529:   }
    #####: 5530:   return (void *) 1;
    %%%%%: 5530-block 100
        -: 5531:}
        -: 5532:
        -: 5533:
function _ZL14stbi__bmp_loadP13stbi__contextPiS1_S1_iP17stbi__result_info called 0 returned 0% blocks executed 0%
    #####: 5534:static void *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
        -: 5535:{
        -: 5536:   stbi_uc *out;
    #####: 5537:   unsigned int mr=0,mg=0,mb=0,ma=0, all_a;
        -: 5538:   stbi_uc pal[256][4];
    #####: 5539:   int psize=0,i,j,width;
        -: 5540:   int flip_vertically, pad, target;
        -: 5541:   stbi__bmp_data info;
        -: 5542:   STBI_NOTUSED(ri);
        -: 5543:
    #####: 5544:   info.all_a = 255;
    #####: 5545:   if (stbi__bmp_parse_header(s, &info) == NULL)
    %%%%%: 5545-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 5545-block 3
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 5546:      return NULL; // error code already set
    %%%%%: 5546-block 4
        -: 5547:
    #####: 5548:   flip_vertically = ((int) s->img_y) > 0;
    #####: 5549:   s->img_y = abs((int) s->img_y);
        -: 5550:
    #####: 5551:   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
    %%%%%: 5551-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5551-block 6
call    2 never executed
    #####: 5552:   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
    %%%%%: 5552-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5552-block 9
call    2 never executed
        -: 5553:
    #####: 5554:   mr = info.mr;
    #####: 5555:   mg = info.mg;
    #####: 5556:   mb = info.mb;
    #####: 5557:   ma = info.ma;
    #####: 5558:   all_a = info.all_a;
        -: 5559:
    #####: 5560:   if (info.hsz == 12) {
    %%%%%: 5560-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5561:      if (info.bpp < 24)
    %%%%%: 5561-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5562:         psize = (info.offset - info.extra_read - 24) / 3;
    %%%%%: 5562-block 13
        -: 5563:   } else {
    #####: 5564:      if (info.bpp < 16)
    %%%%%: 5564-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5565:         psize = (info.offset - info.extra_read - info.hsz) >> 2;
    %%%%%: 5565-block 15
        -: 5566:   }
    #####: 5567:   if (psize == 0) {
    %%%%%: 5567-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5568:      // accept some number of extra bytes after the header, but if the offset points either to before
        -: 5569:      // the header ends or implies a large amount of extra data, reject the file as malformed
    #####: 5570:      int bytes_read_so_far = s->callback_already_read + (int)(s->img_buffer - s->img_buffer_original);
    #####: 5571:      int header_limit = 1024; // max we actually read is below 256 bytes currently.
    #####: 5572:      int extra_data_limit = 256*4; // what ordinarily goes here is a palette; 256 entries*4 bytes is its max size.
    #####: 5573:      if (bytes_read_so_far <= 0 || bytes_read_so_far > header_limit) {
    %%%%%: 5573-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5573-block 18
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 5574:         return stbi__errpuc("bad header", "Corrupt BMP");
    %%%%%: 5574-block 19
call    0 never executed
        -: 5575:      }
        -: 5576:      // we established that bytes_read_so_far is positive and sensible.
        -: 5577:      // the first half of this test rejects offsets that are either too small positives, or
        -: 5578:      // negative, and guarantees that info.offset >= bytes_read_so_far > 0. this in turn
        -: 5579:      // ensures the number computed in the second half of the test can't overflow.
    #####: 5580:      if (info.offset < bytes_read_so_far || info.offset - bytes_read_so_far > extra_data_limit) {
    %%%%%: 5580-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5580-block 22
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 5581:         return stbi__errpuc("bad offset", "Corrupt BMP");
    %%%%%: 5581-block 23
call    0 never executed
        -: 5582:      } else {
    #####: 5583:         stbi__skip(s, info.offset - bytes_read_so_far);
    %%%%%: 5583-block 25
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5584:      }
        -: 5585:   }
        -: 5586:
    #####: 5587:   if (info.bpp == 24 && ma == 0xff000000)
    %%%%%: 5587-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5587-block 27
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 5588:      s->img_n = 3;
    %%%%%: 5588-block 28
        -: 5589:   else
    #####: 5590:      s->img_n = ma ? 4 : 3;
    %%%%%: 5590-block 29
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5590-block 30
    %%%%%: 5590-block 31
    %%%%%: 5590-block 32
    #####: 5591:   if (req_comp && req_comp >= 3) // we can directly decode 3 or 4
    %%%%%: 5591-block 33
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5591-block 34
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 5592:      target = req_comp;
    %%%%%: 5592-block 35
        -: 5593:   else
    #####: 5594:      target = s->img_n; // if they want monochrome, we'll post-convert
    %%%%%: 5594-block 36
        -: 5595:
        -: 5596:   // sanity-check size
    #####: 5597:   if (!stbi__mad3sizes_valid(target, s->img_x, s->img_y, 0))
    %%%%%: 5597-block 37
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 5598:      return stbi__errpuc("too large", "Corrupt BMP");
    %%%%%: 5598-block 39
call    0 never executed
        -: 5599:
    #####: 5600:   out = (stbi_uc *) stbi__malloc_mad3(target, s->img_x, s->img_y, 0);
    %%%%%: 5600-block 41
call    0 never executed
    #####: 5601:   if (!out) return stbi__errpuc("outofmem", "Out of memory");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5601-block 43
call    2 never executed
    #####: 5602:   if (info.bpp < 16) {
    %%%%%: 5602-block 45
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5603:      int z=0;
    #####: 5604:      if (psize == 0 || psize > 256) { STBI_FREE(out); return stbi__errpuc("invalid", "Corrupt BMP"); }
    %%%%%: 5604-block 46
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5604-block 47
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5604-block 48
call    4 never executed
    #####: 5605:      for (i=0; i < psize; ++i) {
    %%%%%: 5605-block 50
    %%%%%: 5605-block 57
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 5606:         pal[i][2] = stbi__get8(s);
    %%%%%: 5606-block 51
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5607:         pal[i][1] = stbi__get8(s);
    %%%%%: 5607-block 52
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5608:         pal[i][0] = stbi__get8(s);
    %%%%%: 5608-block 53
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5609:         if (info.hsz != 12) stbi__get8(s);
    %%%%%: 5609-block 54
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5609-block 55
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####: 5610:         pal[i][3] = 255;
    %%%%%: 5610-block 56
        -: 5611:      }
    #####: 5612:      stbi__skip(s, info.offset - info.extra_read - info.hsz - psize * (info.hsz == 12 ? 3 : 4));
    %%%%%: 5612-block 58
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5612-block 59
    %%%%%: 5612-block 60
    %%%%%: 5612-block 61
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####: 5613:      if (info.bpp == 1) width = (s->img_x + 7) >> 3;
    %%%%%: 5613-block 62
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5613-block 63
    #####: 5614:      else if (info.bpp == 4) width = (s->img_x + 1) >> 1;
    %%%%%: 5614-block 64
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5614-block 65
    #####: 5615:      else if (info.bpp == 8) width = s->img_x;
    %%%%%: 5615-block 66
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5615-block 67
    #####: 5616:      else { STBI_FREE(out); return stbi__errpuc("bad bpp", "Corrupt BMP"); }
    %%%%%: 5616-block 68
call    0 never executed
    #####: 5617:      pad = (-width)&3;
    #####: 5618:      if (info.bpp == 1) {
    %%%%%: 5618-block 70
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5619:         for (j=0; j < (int) s->img_y; ++j) {
    %%%%%: 5619-block 71
    %%%%%: 5619-block 84
    %%%%%: 5619-block 85
branch  0 never executed
branch  1 never executed
    #####: 5620:            int bit_offset = 7, v = stbi__get8(s);
    %%%%%: 5620-block 72
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5621:            for (i=0; i < (int) s->img_x; ++i) {
    %%%%%: 5621-block 73
    %%%%%: 5621-block 81
    %%%%%: 5621-block 82
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 5622:               int color = (v>>bit_offset)&0x1;
    #####: 5623:               out[z++] = pal[color][0];
    #####: 5624:               out[z++] = pal[color][1];
    #####: 5625:               out[z++] = pal[color][2];
    #####: 5626:               if (target == 4) out[z++] = 255;
    %%%%%: 5626-block 74
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5626-block 75
    #####: 5627:               if (i+1 == (int) s->img_x) break;
    %%%%%: 5627-block 76
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5627-block 77
    #####: 5628:               if((--bit_offset) < 0) {
    %%%%%: 5628-block 78
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5629:                  bit_offset = 7;
    #####: 5630:                  v = stbi__get8(s);
    %%%%%: 5630-block 79
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 5630-block 80
        -: 5631:               }
        -: 5632:            }
    #####: 5633:            stbi__skip(s, pad);
    %%%%%: 5633-block 83
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5634:         }
        -: 5635:      } else {
    #####: 5636:         for (j=0; j < (int) s->img_y; ++j) {
    %%%%%: 5636-block 86
    %%%%%: 5636-block 104
    %%%%%: 5636-block 105
branch  0 never executed
branch  1 never executed
    #####: 5637:            for (i=0; i < (int) s->img_x; i += 2) {
    %%%%%: 5637-block 87
    %%%%%: 5637-block 101
    %%%%%: 5637-block 102
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 5638:               int v=stbi__get8(s),v2=0;
    %%%%%: 5638-block 88
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5639:               if (info.bpp == 4) {
    %%%%%: 5639-block 89
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5640:                  v2 = v & 15;
    #####: 5641:                  v >>= 4;
    %%%%%: 5641-block 90
        -: 5642:               }
    #####: 5643:               out[z++] = pal[v][0];
    #####: 5644:               out[z++] = pal[v][1];
    #####: 5645:               out[z++] = pal[v][2];
    #####: 5646:               if (target == 4) out[z++] = 255;
    %%%%%: 5646-block 91
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5646-block 92
    #####: 5647:               if (i+1 == (int) s->img_x) break;
    %%%%%: 5647-block 93
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5647-block 94
    #####: 5648:               v = (info.bpp == 8) ? stbi__get8(s) : v2;
    %%%%%: 5648-block 95
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5648-block 96
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 5648-block 97
    %%%%%: 5648-block 98
    #####: 5649:               out[z++] = pal[v][0];
    #####: 5650:               out[z++] = pal[v][1];
    #####: 5651:               out[z++] = pal[v][2];
    #####: 5652:               if (target == 4) out[z++] = 255;
    %%%%%: 5652-block 99
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5652-block 100
        -: 5653:            }
    #####: 5654:            stbi__skip(s, pad);
    %%%%%: 5654-block 103
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5655:         }
        -: 5656:      }
        -: 5657:   } else {
    #####: 5658:      int rshift=0,gshift=0,bshift=0,ashift=0,rcount=0,gcount=0,bcount=0,acount=0;
    #####: 5659:      int z = 0;
    #####: 5660:      int easy=0;
    #####: 5661:      stbi__skip(s, info.offset - info.extra_read - info.hsz);
    %%%%%: 5661-block 106
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5662:      if (info.bpp == 24) width = 3 * s->img_x;
    %%%%%: 5662-block 107
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5662-block 108
    #####: 5663:      else if (info.bpp == 16) width = 2*s->img_x;
    %%%%%: 5663-block 109
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5663-block 110
    #####: 5664:      else /* bpp = 32 and pad = 0 */ width=0;
    %%%%%: 5664-block 111
    #####: 5665:      pad = (-width) & 3;
    #####: 5666:      if (info.bpp == 24) {
    %%%%%: 5666-block 112
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5667:         easy = 1;
    %%%%%: 5667-block 113
    #####: 5668:      } else if (info.bpp == 32) {
    %%%%%: 5668-block 114
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5669:         if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)
    %%%%%: 5669-block 115
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5669-block 116
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5669-block 117
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 5669-block 118
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 5670:            easy = 2;
    %%%%%: 5670-block 119
        -: 5671:      }
    #####: 5672:      if (!easy) {
    %%%%%: 5672-block 120
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5673:         if (!mr || !mg || !mb) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }
    %%%%%: 5673-block 121
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5673-block 122
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5673-block 123
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 5673-block 124
call    6 never executed
        -: 5674:         // right shift amt to put high bit in position #7
    #####: 5675:         rshift = stbi__high_bit(mr)-7; rcount = stbi__bitcount(mr);
    %%%%%: 5675-block 126
call    0 never executed
call    1 never executed
    #####: 5676:         gshift = stbi__high_bit(mg)-7; gcount = stbi__bitcount(mg);
call    0 never executed
call    1 never executed
    #####: 5677:         bshift = stbi__high_bit(mb)-7; bcount = stbi__bitcount(mb);
call    0 never executed
call    1 never executed
    #####: 5678:         ashift = stbi__high_bit(ma)-7; acount = stbi__bitcount(ma);
call    0 never executed
call    1 never executed
    #####: 5679:         if (rcount > 8 || gcount > 8 || bcount > 8 || acount > 8) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5679-block 135
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5679-block 136
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 5679-block 137
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 5679-block 138
call    8 never executed
        -: 5680:      }
    #####: 5681:      for (j=0; j < (int) s->img_y; ++j) {
    %%%%%: 5681-block 140
    %%%%%: 5681-block 172
    %%%%%: 5681-block 173
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 5682:         if (easy) {
    %%%%%: 5682-block 141
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5683:            for (i=0; i < (int) s->img_x; ++i) {
    %%%%%: 5683-block 142
    %%%%%: 5683-block 152
    %%%%%: 5683-block 153
branch  0 never executed
branch  1 never executed
        -: 5684:               unsigned char a;
    #####: 5685:               out[z+2] = stbi__get8(s);
    %%%%%: 5685-block 143
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5686:               out[z+1] = stbi__get8(s);
    %%%%%: 5686-block 144
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5687:               out[z+0] = stbi__get8(s);
    %%%%%: 5687-block 145
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5688:               z += 3;
    #####: 5689:               a = (easy == 2 ? stbi__get8(s) : 255);
    %%%%%: 5689-block 146
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5689-block 147
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 5689-block 148
    %%%%%: 5689-block 149
    #####: 5690:               all_a |= a;
    #####: 5691:               if (target == 4) out[z++] = a;
    %%%%%: 5691-block 150
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5691-block 151
        -: 5692:            }
        -: 5693:         } else {
    #####: 5694:            int bpp = info.bpp;
    #####: 5695:            for (i=0; i < (int) s->img_x; ++i) {
    %%%%%: 5695-block 154
    %%%%%: 5695-block 169
    %%%%%: 5695-block 170
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 5696:               stbi__uint32 v = (bpp == 16 ? (stbi__uint32) stbi__get16le(s) : stbi__get32le(s));
    %%%%%: 5696-block 155
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5696-block 156
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 5696-block 157
    %%%%%: 5696-block 158
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
    %%%%%: 5696-block 159
        -: 5697:               unsigned int a;
    #####: 5698:               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mr, rshift, rcount));
    %%%%%: 5698-block 160
call    0 never executed
    #####: 5699:               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mg, gshift, gcount));
call    0 never executed
    #####: 5700:               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mb, bshift, bcount));
call    0 never executed
    #####: 5701:               a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5701-block 164
call    2 never executed
    %%%%%: 5701-block 166
    #####: 5702:               all_a |= a;
    #####: 5703:               if (target == 4) out[z++] = STBI__BYTECAST(a);
    %%%%%: 5703-block 167
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5703-block 168
        -: 5704:            }
        -: 5705:         }
    #####: 5706:         stbi__skip(s, pad);
    %%%%%: 5706-block 171
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5707:      }
        -: 5708:   }
        -: 5709:
        -: 5710:   // if alpha channel is all 0s, replace with all 255s
    #####: 5711:   if (target == 4 && all_a == 0)
    %%%%%: 5711-block 174
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5711-block 175
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 5712:      for (i=4*s->img_x*s->img_y-1; i >= 0; i -= 4)
    %%%%%: 5712-block 176
    %%%%%: 5712-block 178
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 5713:         out[i] = 255;
    %%%%%: 5713-block 177
        -: 5714:
    #####: 5715:   if (flip_vertically) {
    %%%%%: 5715-block 179
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5716:      stbi_uc t;
    #####: 5717:      for (j=0; j < (int) s->img_y>>1; ++j) {
    %%%%%: 5717-block 180
    %%%%%: 5717-block 184
    %%%%%: 5717-block 185
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 5718:         stbi_uc *p1 = out +      j     *s->img_x*target;
    #####: 5719:         stbi_uc *p2 = out + (s->img_y-1-j)*s->img_x*target;
    #####: 5720:         for (i=0; i < (int) s->img_x*target; ++i) {
    %%%%%: 5720-block 181
    %%%%%: 5720-block 183
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 5721:            t = p1[i]; p1[i] = p2[i]; p2[i] = t;
    %%%%%: 5721-block 182
        -: 5722:         }
        -: 5723:      }
        -: 5724:   }
        -: 5725:
    #####: 5726:   if (req_comp && req_comp != target) {
    %%%%%: 5726-block 186
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5726-block 187
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 5727:      out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);
    %%%%%: 5727-block 188
call    0 never executed
    #####: 5728:      if (out == NULL) return out; // stbi__convert_format frees input on failure
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5728-block 190
        -: 5729:   }
        -: 5730:
    #####: 5731:   *x = s->img_x;
    #####: 5732:   *y = s->img_y;
    #####: 5733:   if (comp) *comp = s->img_n;
    %%%%%: 5733-block 191
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5733-block 192
    #####: 5734:   return out;
    %%%%%: 5734-block 193
        -: 5735:}
        -: 5736:#endif
        -: 5737:
        -: 5738:// Targa Truevision - TGA
        -: 5739:// by Jonathan Dummer
        -: 5740:#ifndef STBI_NO_TGA
        -: 5741:// returns STBI_rgb or whatever, 0 on error
function _ZL18stbi__tga_get_compiiPi called 0 returned 0% blocks executed 0%
    #####: 5742:static int stbi__tga_get_comp(int bits_per_pixel, int is_grey, int* is_rgb16)
        -: 5743:{
        -: 5744:   // only RGB or RGBA (incl. 16bit) or grey allowed
    #####: 5745:   if (is_rgb16) *is_rgb16 = 0;
    %%%%%: 5745-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5745-block 3
    #####: 5746:   switch(bits_per_pixel) {
    %%%%%: 5746-block 4
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 5747:      case 8:  return STBI_grey;
    %%%%%: 5747-block 5
    #####: 5748:      case 16: if(is_grey) return STBI_grey_alpha;
    %%%%%: 5748-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5748-block 7
        -: 5749:               // fallthrough
    #####: 5750:      case 15: if(is_rgb16) *is_rgb16 = 1;
    %%%%%: 5750-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5750-block 9
    #####: 5751:               return STBI_rgb;
    %%%%%: 5751-block 10
    #####: 5752:      case 24: // fallthrough
    #####: 5753:      case 32: return bits_per_pixel/8;
    %%%%%: 5753-block 11
    #####: 5754:      default: return 0;
    %%%%%: 5754-block 12
        -: 5755:   }
        -: 5756:}
        -: 5757:
function _ZL14stbi__tga_infoP13stbi__contextPiS1_S1_ called 0 returned 0% blocks executed 0%
    #####: 5758:static int stbi__tga_info(stbi__context *s, int *x, int *y, int *comp)
        -: 5759:{
        -: 5760:    int tga_w, tga_h, tga_comp, tga_image_type, tga_bits_per_pixel, tga_colormap_bpp;
        -: 5761:    int sz, tga_colormap_type;
    #####: 5762:    stbi__get8(s);                   // discard Offset
    %%%%%: 5762-block 2
call    0 never executed
    #####: 5763:    tga_colormap_type = stbi__get8(s); // colormap type
call    0 never executed
    #####: 5764:    if( tga_colormap_type > 1 ) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5765:        stbi__rewind(s);
    %%%%%: 5765-block 5
call    0 never executed
    #####: 5766:        return 0;      // only RGB or indexed allowed
        -: 5767:    }
    #####: 5768:    tga_image_type = stbi__get8(s); // image type
    %%%%%: 5768-block 7
call    0 never executed
    #####: 5769:    if ( tga_colormap_type == 1 ) { // colormapped (paletted) image
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5770:        if (tga_image_type != 1 && tga_image_type != 9) {
    %%%%%: 5770-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5770-block 10
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 5771:            stbi__rewind(s);
    %%%%%: 5771-block 11
call    0 never executed
    #####: 5772:            return 0;
        -: 5773:        }
    #####: 5774:        stbi__skip(s,4);       // skip index of first colormap entry and number of entries
    %%%%%: 5774-block 13
call    0 never executed
    #####: 5775:        sz = stbi__get8(s);    //   check bits per palette color entry
call    0 never executed
    #####: 5776:        if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) {
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5776-block 16
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5776-block 17
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 5776-block 18
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 5776-block 19
branch  8 never executed (fallthrough)
branch  9 never executed
    #####: 5777:            stbi__rewind(s);
    %%%%%: 5777-block 20
call    0 never executed
    #####: 5778:            return 0;
        -: 5779:        }
    #####: 5780:        stbi__skip(s,4);       // skip image x and y origin
    %%%%%: 5780-block 22
call    0 never executed
    #####: 5781:        tga_colormap_bpp = sz;
        -: 5782:    } else { // "normal" image w/o colormap - only RGB or grey allowed, +/- RLE
    #####: 5783:        if ( (tga_image_type != 2) && (tga_image_type != 3) && (tga_image_type != 10) && (tga_image_type != 11) ) {
    %%%%%: 5783-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5783-block 25
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5783-block 26
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 5783-block 27
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 5784:            stbi__rewind(s);
    %%%%%: 5784-block 28
call    0 never executed
    #####: 5785:            return 0; // only RGB or grey allowed, +/- RLE
        -: 5786:        }
    #####: 5787:        stbi__skip(s,9); // skip colormap specification and image x/y origin
    %%%%%: 5787-block 30
call    0 never executed
    #####: 5788:        tga_colormap_bpp = 0;
        -: 5789:    }
    #####: 5790:    tga_w = stbi__get16le(s);
    %%%%%: 5790-block 32
call    0 never executed
    #####: 5791:    if( tga_w < 1 ) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5792:        stbi__rewind(s);
    %%%%%: 5792-block 34
call    0 never executed
    #####: 5793:        return 0;   // test width
        -: 5794:    }
    #####: 5795:    tga_h = stbi__get16le(s);
    %%%%%: 5795-block 36
call    0 never executed
    #####: 5796:    if( tga_h < 1 ) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5797:        stbi__rewind(s);
    %%%%%: 5797-block 38
call    0 never executed
    #####: 5798:        return 0;   // test height
        -: 5799:    }
    #####: 5800:    tga_bits_per_pixel = stbi__get8(s); // bits per pixel
    %%%%%: 5800-block 40
call    0 never executed
    #####: 5801:    stbi__get8(s); // ignore alpha bits
call    0 never executed
    #####: 5802:    if (tga_colormap_bpp != 0) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5803:        if((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16)) {
    %%%%%: 5803-block 43
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5803-block 44
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 5804:            // when using a colormap, tga_bits_per_pixel is the size of the indexes
        -: 5805:            // I don't think anything but 8 or 16bit indexes makes sense
    #####: 5806:            stbi__rewind(s);
    %%%%%: 5806-block 45
call    0 never executed
    #####: 5807:            return 0;
        -: 5808:        }
    #####: 5809:        tga_comp = stbi__tga_get_comp(tga_colormap_bpp, 0, NULL);
    %%%%%: 5809-block 47
call    0 never executed
        -: 5810:    } else {
    #####: 5811:        tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3) || (tga_image_type == 11), NULL);
    %%%%%: 5811-block 48
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5811-block 49
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5811-block 50
    %%%%%: 5811-block 51
    %%%%%: 5811-block 52
call    4 never executed
        -: 5812:    }
    #####: 5813:    if(!tga_comp) {
    %%%%%: 5813-block 53
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5814:      stbi__rewind(s);
    %%%%%: 5814-block 54
call    0 never executed
    #####: 5815:      return 0;
        -: 5816:    }
    #####: 5817:    if (x) *x = tga_w;
    %%%%%: 5817-block 56
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5817-block 57
    #####: 5818:    if (y) *y = tga_h;
    %%%%%: 5818-block 58
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5818-block 59
    #####: 5819:    if (comp) *comp = tga_comp;
    %%%%%: 5819-block 60
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5819-block 61
    #####: 5820:    return 1;                   // seems to have passed everything
    %%%%%: 5820-block 62
        -: 5821:}
        -: 5822:
function _ZL14stbi__tga_testP13stbi__context called 0 returned 0% blocks executed 0%
    #####: 5823:static int stbi__tga_test(stbi__context *s)
        -: 5824:{
    #####: 5825:   int res = 0;
        -: 5826:   int sz, tga_color_type;
    #####: 5827:   stbi__get8(s);      //   discard Offset
    %%%%%: 5827-block 2
call    0 never executed
    #####: 5828:   tga_color_type = stbi__get8(s);   //   color type
call    0 never executed
    #####: 5829:   if ( tga_color_type > 1 ) goto errorEnd;   //   only RGB or indexed allowed
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5829-block 5
    #####: 5830:   sz = stbi__get8(s);   //   image type
    %%%%%: 5830-block 6
call    0 never executed
    #####: 5831:   if ( tga_color_type == 1 ) { // colormapped (paletted) image
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5832:      if (sz != 1 && sz != 9) goto errorEnd; // colortype 1 demands image type 1 or 9
    %%%%%: 5832-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5832-block 9
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5832-block 10
    #####: 5833:      stbi__skip(s,4);       // skip index of first colormap entry and number of entries
    %%%%%: 5833-block 11
call    0 never executed
    #####: 5834:      sz = stbi__get8(s);    //   check bits per palette color entry
call    0 never executed
    #####: 5835:      if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5835-block 14
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5835-block 15
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 5835-block 16
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 5835-block 17
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%: 5835-block 18
    #####: 5836:      stbi__skip(s,4);       // skip image x and y origin
    %%%%%: 5836-block 19
call    0 never executed
        -: 5837:   } else { // "normal" image w/o colormap
    #####: 5838:      if ( (sz != 2) && (sz != 3) && (sz != 10) && (sz != 11) ) goto errorEnd; // only RGB or grey allowed, +/- RLE
    %%%%%: 5838-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5838-block 21
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5838-block 22
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 5838-block 23
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 5838-block 24
    #####: 5839:      stbi__skip(s,9); // skip colormap specification and image x/y origin
    %%%%%: 5839-block 25
call    0 never executed
        -: 5840:   }
    #####: 5841:   if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test width
    %%%%%: 5841-block 26
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 5841-block 28
    #####: 5842:   if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test height
    %%%%%: 5842-block 29
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 5842-block 31
    #####: 5843:   sz = stbi__get8(s);   //   bits per pixel
    %%%%%: 5843-block 32
call    0 never executed
    #####: 5844:   if ( (tga_color_type == 1) && (sz != 8) && (sz != 16) ) goto errorEnd; // for colormapped images, bpp is size of an index
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5844-block 34
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5844-block 35
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 5844-block 36
    #####: 5845:   if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;
    %%%%%: 5845-block 37
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5845-block 38
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5845-block 39
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 5845-block 40
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 5845-block 41
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%: 5845-block 42
        -: 5846:
    #####: 5847:   res = 1; // if we got this far, everything's good and we can return 1 instead of 0
    %%%%%: 5847-block 43
        -: 5848:
    #####: 5849:errorEnd:
    #####: 5850:   stbi__rewind(s);
    %%%%%: 5850-block 44
call    0 never executed
    #####: 5851:   return res;
        -: 5852:}
        -: 5853:
        -: 5854:// read 16bit value and convert to 24bit RGB
function _ZL20stbi__tga_read_rgb16P13stbi__contextPh called 0 returned 0% blocks executed 0%
    #####: 5855:static void stbi__tga_read_rgb16(stbi__context *s, stbi_uc* out)
        -: 5856:{
    #####: 5857:   stbi__uint16 px = (stbi__uint16)stbi__get16le(s);
    %%%%%: 5857-block 2
call    0 never executed
    #####: 5858:   stbi__uint16 fiveBitMask = 31;
        -: 5859:   // we have 3 channels with 5bits each
    #####: 5860:   int r = (px >> 10) & fiveBitMask;
    #####: 5861:   int g = (px >> 5) & fiveBitMask;
    #####: 5862:   int b = px & fiveBitMask;
        -: 5863:   // Note that this saves the data in RGB(A) order, so it doesn't need to be swapped later
    #####: 5864:   out[0] = (stbi_uc)((r * 255)/31);
    #####: 5865:   out[1] = (stbi_uc)((g * 255)/31);
    #####: 5866:   out[2] = (stbi_uc)((b * 255)/31);
        -: 5867:
        -: 5868:   // some people claim that the most significant bit might be used for alpha
        -: 5869:   // (possibly if an alpha-bit is set in the "image descriptor byte")
        -: 5870:   // but that only made 16bit test images completely translucent..
        -: 5871:   // so let's treat all 15 and 16bit TGAs as RGB with no alpha.
    #####: 5872:}
        -: 5873:
function _ZL14stbi__tga_loadP13stbi__contextPiS1_S1_iP17stbi__result_info called 0 returned 0% blocks executed 0%
    #####: 5874:static void *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
        -: 5875:{
        -: 5876:   //   read in the TGA header stuff
    #####: 5877:   int tga_offset = stbi__get8(s);
    %%%%%: 5877-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5878:   int tga_indexed = stbi__get8(s);
    %%%%%: 5878-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5879:   int tga_image_type = stbi__get8(s);
    %%%%%: 5879-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5880:   int tga_is_RLE = 0;
    #####: 5881:   int tga_palette_start = stbi__get16le(s);
    %%%%%: 5881-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5882:   int tga_palette_len = stbi__get16le(s);
    %%%%%: 5882-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5883:   int tga_palette_bits = stbi__get8(s);
    %%%%%: 5883-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5884:   int tga_x_origin = stbi__get16le(s);
    %%%%%: 5884-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5885:   int tga_y_origin = stbi__get16le(s);
    %%%%%: 5885-block 9
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5886:   int tga_width = stbi__get16le(s);
    %%%%%: 5886-block 10
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5887:   int tga_height = stbi__get16le(s);
    %%%%%: 5887-block 11
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5888:   int tga_bits_per_pixel = stbi__get8(s);
    %%%%%: 5888-block 12
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5889:   int tga_comp, tga_rgb16=0;
    #####: 5890:   int tga_inverted = stbi__get8(s);
    %%%%%: 5890-block 13
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5891:   // int tga_alpha_bits = tga_inverted & 15; // the 4 lowest bits - unused (useless?)
        -: 5892:   //   image data
        -: 5893:   unsigned char *tga_data;
    #####: 5894:   unsigned char *tga_palette = NULL;
        -: 5895:   int i, j;
    #####: 5896:   unsigned char raw_data[4] = {0};
    #####: 5897:   int RLE_count = 0;
    #####: 5898:   int RLE_repeating = 0;
    #####: 5899:   int read_next_pixel = 1;
        -: 5900:   STBI_NOTUSED(ri);
        -: 5901:   STBI_NOTUSED(tga_x_origin); // @TODO
        -: 5902:   STBI_NOTUSED(tga_y_origin); // @TODO
        -: 5903:
    #####: 5904:   if (tga_height > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
    %%%%%: 5904-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5904-block 15
call    2 never executed
    #####: 5905:   if (tga_width > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
    %%%%%: 5905-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5905-block 18
call    2 never executed
        -: 5906:
        -: 5907:   //   do a tiny bit of precessing
    #####: 5908:   if ( tga_image_type >= 8 )
    %%%%%: 5908-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5909:   {
    #####: 5910:      tga_image_type -= 8;
    #####: 5911:      tga_is_RLE = 1;
    %%%%%: 5911-block 21
        -: 5912:   }
    #####: 5913:   tga_inverted = 1 - ((tga_inverted >> 5) & 1);
        -: 5914:
        -: 5915:   //   If I'm paletted, then I'll use the number of bits from the palette
    #####: 5916:   if ( tga_indexed ) tga_comp = stbi__tga_get_comp(tga_palette_bits, 0, &tga_rgb16);
    %%%%%: 5916-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5916-block 23
call    2 never executed
    #####: 5917:   else tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3), &tga_rgb16);
    %%%%%: 5917-block 24
call    0 never executed
        -: 5918:
    #####: 5919:   if(!tga_comp) // shouldn't really happen, stbi__tga_test() should have ensured basic consistency
    %%%%%: 5919-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5920:      return stbi__errpuc("bad format", "Can't find out TGA pixelformat");
    %%%%%: 5920-block 26
call    0 never executed
        -: 5921:
        -: 5922:   //   tga info
    #####: 5923:   *x = tga_width;
    #####: 5924:   *y = tga_height;
    #####: 5925:   if (comp) *comp = tga_comp;
    %%%%%: 5925-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5925-block 29
        -: 5926:
    #####: 5927:   if (!stbi__mad3sizes_valid(tga_width, tga_height, tga_comp, 0))
    %%%%%: 5927-block 30
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 5928:      return stbi__errpuc("too large", "Corrupt TGA");
    %%%%%: 5928-block 32
call    0 never executed
        -: 5929:
    #####: 5930:   tga_data = (unsigned char*)stbi__malloc_mad3(tga_width, tga_height, tga_comp, 0);
    %%%%%: 5930-block 34
call    0 never executed
    #####: 5931:   if (!tga_data) return stbi__errpuc("outofmem", "Out of memory");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5931-block 36
call    2 never executed
        -: 5932:
        -: 5933:   // skip to the data's starting position (offset usually = 0)
    #####: 5934:   stbi__skip(s, tga_offset );
    %%%%%: 5934-block 38
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5935:
    #####: 5936:   if ( !tga_indexed && !tga_is_RLE && !tga_rgb16 ) {
    %%%%%: 5936-block 39
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5936-block 40
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5936-block 41
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 5937:      for (i=0; i < tga_height; ++i) {
    %%%%%: 5937-block 42
    %%%%%: 5937-block 47
    %%%%%: 5937-block 48
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 5938:         int row = tga_inverted ? tga_height -i - 1 : i;
    %%%%%: 5938-block 43
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5938-block 44
    %%%%%: 5938-block 45
    #####: 5939:         stbi_uc *tga_row = tga_data + row*tga_width*tga_comp;
    #####: 5940:         stbi__getn(s, tga_row, tga_width * tga_comp);
    %%%%%: 5940-block 46
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5941:      }
    #####: 5942:   } else  {
    %%%%%: 5942-block 49
        -: 5943:      //   do I need to load a palette?
    #####: 5944:      if ( tga_indexed)
    %%%%%: 5944-block 50
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5945:      {
    #####: 5946:         if (tga_palette_len == 0) {  /* you have to have at least one entry! */
    %%%%%: 5946-block 51
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5947:            STBI_FREE(tga_data);
    #####: 5948:            return stbi__errpuc("bad palette", "Corrupt TGA");
    %%%%%: 5948-block 52
call    0 never executed
        -: 5949:         }
        -: 5950:
        -: 5951:         //   any data to skip? (offset usually = 0)
    #####: 5952:         stbi__skip(s, tga_palette_start );
    %%%%%: 5952-block 54
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5953:         //   load the palette
    #####: 5954:         tga_palette = (unsigned char*)stbi__malloc_mad2(tga_palette_len, tga_comp, 0);
    %%%%%: 5954-block 55
call    0 never executed
    #####: 5955:         if (!tga_palette) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5956:            STBI_FREE(tga_data);
    #####: 5957:            return stbi__errpuc("outofmem", "Out of memory");
    %%%%%: 5957-block 57
call    0 never executed
        -: 5958:         }
    #####: 5959:         if (tga_rgb16) {
    %%%%%: 5959-block 59
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5960:            stbi_uc *pal_entry = tga_palette;
    #####: 5961:            STBI_ASSERT(tga_comp == STBI_rgb);
    %%%%%: 5961-block 60
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5961-block 61
call    2 never executed
    #####: 5962:            for (i=0; i < tga_palette_len; ++i) {
    %%%%%: 5962-block 62
    %%%%%: 5962-block 65
branch  0 never executed
branch  1 never executed
    #####: 5963:               stbi__tga_read_rgb16(s, pal_entry);
    %%%%%: 5963-block 63
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5964:               pal_entry += tga_comp;
    %%%%%: 5964-block 64
        -: 5965:            }
    #####: 5966:         } else if (!stbi__getn(s, tga_palette, tga_palette_len * tga_comp)) {
    %%%%%: 5966-block 66
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 5966-block 67
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 5967:               STBI_FREE(tga_data);
    #####: 5968:               STBI_FREE(tga_palette);
    #####: 5969:               return stbi__errpuc("bad palette", "Corrupt TGA");
    %%%%%: 5969-block 68
call    0 never executed
        -: 5970:         }
        -: 5971:      }
        -: 5972:      //   load the data
    #####: 5973:      for (i=0; i < tga_width * tga_height; ++i)
    %%%%%: 5973-block 70
    %%%%%: 5973-block 103
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 5974:      {
        -: 5975:         //   if I'm in RLE mode, do I need to get a RLE stbi__pngchunk?
    #####: 5976:         if ( tga_is_RLE )
    %%%%%: 5976-block 71
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5977:         {
    #####: 5978:            if ( RLE_count == 0 )
    %%%%%: 5978-block 72
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5979:            {
        -: 5980:               //   yep, get the next byte as a RLE command
    #####: 5981:               int RLE_cmd = stbi__get8(s);
    %%%%%: 5981-block 73
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5982:               RLE_count = 1 + (RLE_cmd & 127);
    #####: 5983:               RLE_repeating = RLE_cmd >> 7;
    #####: 5984:               read_next_pixel = 1;
    %%%%%: 5984-block 74
    #####: 5985:            } else if ( !RLE_repeating )
    %%%%%: 5985-block 75
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5986:            {
    #####: 5987:               read_next_pixel = 1;
    %%%%%: 5987-block 76
        -: 5988:            }
        -: 5989:         } else
        -: 5990:         {
    #####: 5991:            read_next_pixel = 1;
    %%%%%: 5991-block 77
        -: 5992:         }
        -: 5993:         //   OK, if I need to read a pixel, do it now
    #####: 5994:         if ( read_next_pixel )
    %%%%%: 5994-block 78
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5995:         {
        -: 5996:            //   load however much data we did have
    #####: 5997:            if ( tga_indexed )
    %%%%%: 5997-block 79
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5998:            {
        -: 5999:               // read in index, then perform the lookup
    #####: 6000:               int pal_idx = (tga_bits_per_pixel == 8) ? stbi__get8(s) : stbi__get16le(s);
    %%%%%: 6000-block 80
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6000-block 81
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 6000-block 82
    %%%%%: 6000-block 83
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
    %%%%%: 6000-block 84
    #####: 6001:               if ( pal_idx >= tga_palette_len ) {
    %%%%%: 6001-block 85
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6002:                  // invalid index
    #####: 6003:                  pal_idx = 0;
    %%%%%: 6003-block 86
        -: 6004:               }
    #####: 6005:               pal_idx *= tga_comp;
    #####: 6006:               for (j = 0; j < tga_comp; ++j) {
    %%%%%: 6006-block 87
    %%%%%: 6006-block 89
branch  0 never executed
branch  1 never executed
    #####: 6007:                  raw_data[j] = tga_palette[pal_idx+j];
    %%%%%: 6007-block 88
        -: 6008:               }
    #####: 6009:            } else if(tga_rgb16) {
    %%%%%: 6009-block 90
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6010:               STBI_ASSERT(tga_comp == STBI_rgb);
    %%%%%: 6010-block 91
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6010-block 92
call    2 never executed
    #####: 6011:               stbi__tga_read_rgb16(s, raw_data);
    %%%%%: 6011-block 93
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6012:            } else {
        -: 6013:               //   read in the data raw
    #####: 6014:               for (j = 0; j < tga_comp; ++j) {
    %%%%%: 6014-block 94
    %%%%%: 6014-block 97
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6015:                  raw_data[j] = stbi__get8(s);
    %%%%%: 6015-block 95
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 6015-block 96
        -: 6016:               }
        -: 6017:            }
        -: 6018:            //   clear the reading flag for the next pixel
    #####: 6019:            read_next_pixel = 0;
    %%%%%: 6019-block 98
        -: 6020:         } // end of reading a pixel
        -: 6021:
        -: 6022:         // copy data
    #####: 6023:         for (j = 0; j < tga_comp; ++j)
    %%%%%: 6023-block 99
    %%%%%: 6023-block 101
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6024:           tga_data[i*tga_comp+j] = raw_data[j];
    %%%%%: 6024-block 100
        -: 6025:
        -: 6026:         //   in case we're in RLE mode, keep counting down
    #####: 6027:         --RLE_count;
    %%%%%: 6027-block 102
        -: 6028:      }
        -: 6029:      //   do I need to invert the image?
    #####: 6030:      if ( tga_inverted )
    %%%%%: 6030-block 104
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6031:      {
    #####: 6032:         for (j = 0; j*2 < tga_height; ++j)
    %%%%%: 6032-block 105
    %%%%%: 6032-block 109
    %%%%%: 6032-block 110
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 6033:         {
    #####: 6034:            int index1 = j * tga_width * tga_comp;
    #####: 6035:            int index2 = (tga_height - 1 - j) * tga_width * tga_comp;
    #####: 6036:            for (i = tga_width * tga_comp; i > 0; --i)
    %%%%%: 6036-block 106
    %%%%%: 6036-block 108
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 6037:            {
    #####: 6038:               unsigned char temp = tga_data[index1];
    #####: 6039:               tga_data[index1] = tga_data[index2];
    #####: 6040:               tga_data[index2] = temp;
    #####: 6041:               ++index1;
    #####: 6042:               ++index2;
    %%%%%: 6042-block 107
        -: 6043:            }
        -: 6044:         }
        -: 6045:      }
        -: 6046:      //   clear my palette, if I had one
    #####: 6047:      if ( tga_palette != NULL )
    %%%%%: 6047-block 111
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6048:      {
    #####: 6049:         STBI_FREE( tga_palette );
    %%%%%: 6049-block 112
        -: 6050:      }
        -: 6051:   }
        -: 6052:
        -: 6053:   // swap RGB - if the source data was RGB16, it already is in the right order
    #####: 6054:   if (tga_comp >= 3 && !tga_rgb16)
    %%%%%: 6054-block 113
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6054-block 114
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 6055:   {
    #####: 6056:      unsigned char* tga_pixel = tga_data;
    #####: 6057:      for (i=0; i < tga_width * tga_height; ++i)
    %%%%%: 6057-block 115
    %%%%%: 6057-block 117
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 6058:      {
    #####: 6059:         unsigned char temp = tga_pixel[0];
    #####: 6060:         tga_pixel[0] = tga_pixel[2];
    #####: 6061:         tga_pixel[2] = temp;
    #####: 6062:         tga_pixel += tga_comp;
    %%%%%: 6062-block 116
        -: 6063:      }
        -: 6064:   }
        -: 6065:
        -: 6066:   // convert to target component count
    #####: 6067:   if (req_comp && req_comp != tga_comp)
    %%%%%: 6067-block 118
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6067-block 119
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 6068:      tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);
    %%%%%: 6068-block 120
call    0 never executed
        -: 6069:
        -: 6070:   //   the things I do to get rid of an error message, and yet keep
        -: 6071:   //   Microsoft's C compilers happy... [8^(
    #####: 6072:   tga_palette_start = tga_palette_len = tga_palette_bits =
    #####: 6073:         tga_x_origin = tga_y_origin = 0;
        -: 6074:   STBI_NOTUSED(tga_palette_start);
        -: 6075:   //   OK, done
    #####: 6076:   return tga_data;
    %%%%%: 6076-block 121
        -: 6077:}
        -: 6078:#endif
        -: 6079:
        -: 6080:// *************************************************************************************************
        -: 6081:// Photoshop PSD loader -- PD by Thatcher Ulrich, integration by Nicolas Schulz, tweaked by STB
        -: 6082:
        -: 6083:#ifndef STBI_NO_PSD
function _ZL14stbi__psd_testP13stbi__context called 0 returned 0% blocks executed 0%
    #####: 6084:static int stbi__psd_test(stbi__context *s)
        -: 6085:{
    #####: 6086:   int r = (stbi__get32be(s) == 0x38425053);
    %%%%%: 6086-block 2
call    0 never executed
    #####: 6087:   stbi__rewind(s);
call    0 never executed
    #####: 6088:   return r;
        -: 6089:}
        -: 6090:
function _ZL20stbi__psd_decode_rleP13stbi__contextPhi called 0 returned 0% blocks executed 0%
    #####: 6091:static int stbi__psd_decode_rle(stbi__context *s, stbi_uc *p, int pixelCount)
        -: 6092:{
        -: 6093:   int count, nleft, len;
        -: 6094:
    #####: 6095:   count = 0;
    #####: 6096:   while ((nleft = pixelCount - count) > 0) {
    %%%%%: 6096-block 2
    %%%%%: 6096-block 19
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6097:      len = stbi__get8(s);
    %%%%%: 6097-block 3
call    0 never executed
    #####: 6098:      if (len == 128) {
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6099:         // No-op.
    #####: 6100:      } else if (len < 128) {
    %%%%%: 6100-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6101:         // Copy next len+1 bytes literally.
    #####: 6102:         len++;
    #####: 6103:         if (len > nleft) return 0; // corrupt data
    %%%%%: 6103-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6103-block 7
    #####: 6104:         count += len;
    #####: 6105:         while (len) {
    %%%%%: 6105-block 8
    %%%%%: 6105-block 11
branch  0 never executed
branch  1 never executed
    #####: 6106:            *p = stbi__get8(s);
    %%%%%: 6106-block 9
call    0 never executed
    #####: 6107:            p += 4;
    #####: 6108:            len--;
        -: 6109:         }
    #####: 6110:      } else if (len > 128) {
    %%%%%: 6110-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6111:         stbi_uc   val;
        -: 6112:         // Next -len+1 bytes in the dest are replicated from next source byte.
        -: 6113:         // (Interpret len as a negative 8-bit int.)
    #####: 6114:         len = 257 - len;
    #####: 6115:         if (len > nleft) return 0; // corrupt data
    %%%%%: 6115-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6115-block 14
    #####: 6116:         val = stbi__get8(s);
    %%%%%: 6116-block 15
call    0 never executed
    #####: 6117:         count += len;
    #####: 6118:         while (len) {
    %%%%%: 6118-block 18
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6119:            *p = val;
    #####: 6120:            p += 4;
    #####: 6121:            len--;
    %%%%%: 6121-block 17
        -: 6122:         }
        -: 6123:      }
        -: 6124:   }
        -: 6125:
    #####: 6126:   return 1;
    %%%%%: 6126-block 20
        -: 6127:}
        -: 6128:
function _ZL14stbi__psd_loadP13stbi__contextPiS1_S1_iP17stbi__result_infoi called 0 returned 0% blocks executed 0%
    #####: 6129:static void *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
        -: 6130:{
        -: 6131:   int pixelCount;
        -: 6132:   int channelCount, compression;
        -: 6133:   int channel, i;
        -: 6134:   int bitdepth;
        -: 6135:   int w,h;
        -: 6136:   stbi_uc *out;
        -: 6137:   STBI_NOTUSED(ri);
        -: 6138:
        -: 6139:   // Check identifier
    #####: 6140:   if (stbi__get32be(s) != 0x38425053)   // "8BPS"
    %%%%%: 6140-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 6141:      return stbi__errpuc("not PSD", "Corrupt PSD image");
    %%%%%: 6141-block 4
call    0 never executed
        -: 6142:
        -: 6143:   // Check file type version.
    #####: 6144:   if (stbi__get16be(s) != 1)
    %%%%%: 6144-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 6145:      return stbi__errpuc("wrong version", "Unsupported version of PSD image");
    %%%%%: 6145-block 8
call    0 never executed
        -: 6146:
        -: 6147:   // Skip 6 reserved bytes.
    #####: 6148:   stbi__skip(s, 6 );
    %%%%%: 6148-block 10
call    0 never executed
        -: 6149:
        -: 6150:   // Read the number of channels (R, G, B, A, etc).
    #####: 6151:   channelCount = stbi__get16be(s);
call    0 never executed
    #####: 6152:   if (channelCount < 0 || channelCount > 16)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6152-block 13
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 6153:      return stbi__errpuc("wrong channel count", "Unsupported number of channels in PSD image");
    %%%%%: 6153-block 14
call    0 never executed
        -: 6154:
        -: 6155:   // Read the rows and columns of the image.
    #####: 6156:   h = stbi__get32be(s);
    %%%%%: 6156-block 16
call    0 never executed
    #####: 6157:   w = stbi__get32be(s);
call    0 never executed
        -: 6158:
    #####: 6159:   if (h > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6159-block 19
call    2 never executed
    #####: 6160:   if (w > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
    %%%%%: 6160-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6160-block 22
call    2 never executed
        -: 6161:
        -: 6162:   // Make sure the depth is 8 bits.
    #####: 6163:   bitdepth = stbi__get16be(s);
    %%%%%: 6163-block 24
call    0 never executed
    #####: 6164:   if (bitdepth != 8 && bitdepth != 16)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6164-block 26
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 6165:      return stbi__errpuc("unsupported bit depth", "PSD bit depth is not 8 or 16 bit");
    %%%%%: 6165-block 27
call    0 never executed
        -: 6166:
        -: 6167:   // Make sure the color mode is RGB.
        -: 6168:   // Valid options are:
        -: 6169:   //   0: Bitmap
        -: 6170:   //   1: Grayscale
        -: 6171:   //   2: Indexed color
        -: 6172:   //   3: RGB color
        -: 6173:   //   4: CMYK color
        -: 6174:   //   7: Multichannel
        -: 6175:   //   8: Duotone
        -: 6176:   //   9: Lab color
    #####: 6177:   if (stbi__get16be(s) != 3)
    %%%%%: 6177-block 29
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 6178:      return stbi__errpuc("wrong color format", "PSD is not in RGB color format");
    %%%%%: 6178-block 31
call    0 never executed
        -: 6179:
        -: 6180:   // Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)
    #####: 6181:   stbi__skip(s,stbi__get32be(s) );
    %%%%%: 6181-block 33
call    0 never executed
call    1 never executed
        -: 6182:
        -: 6183:   // Skip the image resources.  (resolution, pen tool paths, etc)
    #####: 6184:   stbi__skip(s, stbi__get32be(s) );
call    0 never executed
call    1 never executed
        -: 6185:
        -: 6186:   // Skip the reserved data.
    #####: 6187:   stbi__skip(s, stbi__get32be(s) );
call    0 never executed
call    1 never executed
        -: 6188:
        -: 6189:   // Find out if the data is compressed.
        -: 6190:   // Known values:
        -: 6191:   //   0: no compression
        -: 6192:   //   1: RLE compressed
    #####: 6193:   compression = stbi__get16be(s);
call    0 never executed
    #####: 6194:   if (compression > 1)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6195:      return stbi__errpuc("bad compression", "PSD has an unknown compression format");
    %%%%%: 6195-block 41
call    0 never executed
        -: 6196:
        -: 6197:   // Check size
    #####: 6198:   if (!stbi__mad3sizes_valid(4, w, h, 0))
    %%%%%: 6198-block 43
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 6199:      return stbi__errpuc("too large", "Corrupt PSD");
    %%%%%: 6199-block 45
call    0 never executed
        -: 6200:
        -: 6201:   // Create the destination image.
        -: 6202:
    #####: 6203:   if (!compression && bitdepth == 16 && bpc == 16) {
    %%%%%: 6203-block 47
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6203-block 48
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6203-block 49
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 6204:      out = (stbi_uc *) stbi__malloc_mad3(8, w, h, 0);
    %%%%%: 6204-block 50
call    0 never executed
    #####: 6205:      ri->bits_per_channel = 16;
        -: 6206:   } else
    #####: 6207:      out = (stbi_uc *) stbi__malloc(4 * w*h);
    %%%%%: 6207-block 52
call    0 never executed
        -: 6208:
    #####: 6209:   if (!out) return stbi__errpuc("outofmem", "Out of memory");
    %%%%%: 6209-block 53
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6209-block 54
call    2 never executed
    #####: 6210:   pixelCount = w*h;
        -: 6211:
        -: 6212:   // Initialize the data to zero.
        -: 6213:   //memset( out, 0, pixelCount * 4 );
        -: 6214:
        -: 6215:   // Finally, the image data.
    #####: 6216:   if (compression) {
    %%%%%: 6216-block 56
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6217:      // RLE as used by .PSD and .TIFF
        -: 6218:      // Loop until you get the number of unpacked bytes you are expecting:
        -: 6219:      //     Read the next source byte into n.
        -: 6220:      //     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.
        -: 6221:      //     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.
        -: 6222:      //     Else if n is 128, noop.
        -: 6223:      // Endloop
        -: 6224:
        -: 6225:      // The RLE-compressed data is preceded by a 2-byte data count for each row in the data,
        -: 6226:      // which we're going to just skip.
    #####: 6227:      stbi__skip(s, h * channelCount * 2 );
    %%%%%: 6227-block 57
call    0 never executed
        -: 6228:
        -: 6229:      // Read the RLE data by channel.
    #####: 6230:      for (channel = 0; channel < 4; channel++) {
    %%%%%: 6230-block 70
    %%%%%: 6230-block 71
branch  0 never executed
branch  1 never executed
        -: 6231:         stbi_uc *p;
        -: 6232:
    #####: 6233:         p = out+channel;
    #####: 6234:         if (channel >= channelCount) {
    %%%%%: 6234-block 59
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6235:            // Fill this channel with default data.
    #####: 6236:            for (i = 0; i < pixelCount; i++, p += 4)
    %%%%%: 6236-block 60
    %%%%%: 6236-block 65
branch  0 never executed
branch  1 never executed
    #####: 6237:               *p = (channel == 3 ? 255 : 0);
    %%%%%: 6237-block 61
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6237-block 62
    %%%%%: 6237-block 63
    %%%%%: 6237-block 64
        -: 6238:         } else {
        -: 6239:            // Read the RLE data.
    #####: 6240:            if (!stbi__psd_decode_rle(s, p, pixelCount)) {
    %%%%%: 6240-block 66
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 6241:               STBI_FREE(out);
    #####: 6242:               return stbi__errpuc("corrupt", "bad RLE data");
    %%%%%: 6242-block 68
call    0 never executed
        -: 6243:            }
        -: 6244:         }
        -: 6245:      }
        -: 6246:
        -: 6247:   } else {
        -: 6248:      // We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)
        -: 6249:      // where each channel consists of an 8-bit (or 16-bit) value for each pixel in the image.
        -: 6250:
        -: 6251:      // Read the data by channel.
    #####: 6252:      for (channel = 0; channel < 4; channel++) {
    %%%%%: 6252-block 72
    %%%%%: 6252-block 104
    %%%%%: 6252-block 105
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6253:         if (channel >= channelCount) {
    %%%%%: 6253-block 73
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6254:            // Fill this channel with default data.
    #####: 6255:            if (bitdepth == 16 && bpc == 16) {
    %%%%%: 6255-block 74
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6255-block 75
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 6256:               stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
    #####: 6257:               stbi__uint16 val = channel == 3 ? 65535 : 0;
    %%%%%: 6257-block 76
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6257-block 77
    %%%%%: 6257-block 78
    #####: 6258:               for (i = 0; i < pixelCount; i++, q += 4)
    %%%%%: 6258-block 79
    %%%%%: 6258-block 81
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6259:                  *q = val;
    %%%%%: 6259-block 80
    #####: 6260:            } else {
    %%%%%: 6260-block 82
    #####: 6261:               stbi_uc *p = out+channel;
    #####: 6262:               stbi_uc val = channel == 3 ? 255 : 0;
    %%%%%: 6262-block 83
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6262-block 84
    %%%%%: 6262-block 85
    #####: 6263:               for (i = 0; i < pixelCount; i++, p += 4)
    %%%%%: 6263-block 86
    %%%%%: 6263-block 88
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6264:                  *p = val;
    %%%%%: 6264-block 87
        -: 6265:            }
        -: 6266:         } else {
    #####: 6267:            if (ri->bits_per_channel == 16) {    // output bpc
    %%%%%: 6267-block 90
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6268:               stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
    #####: 6269:               for (i = 0; i < pixelCount; i++, q += 4)
    %%%%%: 6269-block 91
    %%%%%: 6269-block 94
branch  0 never executed
branch  1 never executed
    #####: 6270:                  *q = (stbi__uint16) stbi__get16be(s);
    %%%%%: 6270-block 92
call    0 never executed
        -: 6271:            } else {
    #####: 6272:               stbi_uc *p = out+channel;
    #####: 6273:               if (bitdepth == 16) {  // input bpc
    %%%%%: 6273-block 95
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6274:                  for (i = 0; i < pixelCount; i++, p += 4)
    %%%%%: 6274-block 96
    %%%%%: 6274-block 99
branch  0 never executed
branch  1 never executed
    #####: 6275:                     *p = (stbi_uc) (stbi__get16be(s) >> 8);
    %%%%%: 6275-block 97
call    0 never executed
        -: 6276:               } else {
    #####: 6277:                  for (i = 0; i < pixelCount; i++, p += 4)
    %%%%%: 6277-block 100
    %%%%%: 6277-block 103
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6278:                     *p = stbi__get8(s);
    %%%%%: 6278-block 101
call    0 never executed
        -: 6279:               }
        -: 6280:            }
        -: 6281:         }
        -: 6282:      }
        -: 6283:   }
        -: 6284:
        -: 6285:   // remove weird white matte from PSD
    #####: 6286:   if (channelCount >= 4) {
    %%%%%: 6286-block 106
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6287:      if (ri->bits_per_channel == 16) {
    %%%%%: 6287-block 107
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6288:         for (i=0; i < w*h; ++i) {
    %%%%%: 6288-block 108
    %%%%%: 6288-block 112
    %%%%%: 6288-block 113
branch  0 never executed
branch  1 never executed
    #####: 6289:            stbi__uint16 *pixel = (stbi__uint16 *) out + 4*i;
    #####: 6290:            if (pixel[3] != 0 && pixel[3] != 65535) {
    %%%%%: 6290-block 109
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6290-block 110
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 6291:               float a = pixel[3] / 65535.0f;
    #####: 6292:               float ra = 1.0f / a;
    #####: 6293:               float inv_a = 65535.0f * (1 - ra);
    #####: 6294:               pixel[0] = (stbi__uint16) (pixel[0]*ra + inv_a);
    #####: 6295:               pixel[1] = (stbi__uint16) (pixel[1]*ra + inv_a);
    #####: 6296:               pixel[2] = (stbi__uint16) (pixel[2]*ra + inv_a);
    %%%%%: 6296-block 111
        -: 6297:            }
        -: 6298:         }
        -: 6299:      } else {
    #####: 6300:         for (i=0; i < w*h; ++i) {
    %%%%%: 6300-block 114
    %%%%%: 6300-block 118
    %%%%%: 6300-block 119
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6301:            unsigned char *pixel = out + 4*i;
    #####: 6302:            if (pixel[3] != 0 && pixel[3] != 255) {
    %%%%%: 6302-block 115
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6302-block 116
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 6303:               float a = pixel[3] / 255.0f;
    #####: 6304:               float ra = 1.0f / a;
    #####: 6305:               float inv_a = 255.0f * (1 - ra);
    #####: 6306:               pixel[0] = (unsigned char) (pixel[0]*ra + inv_a);
    #####: 6307:               pixel[1] = (unsigned char) (pixel[1]*ra + inv_a);
    #####: 6308:               pixel[2] = (unsigned char) (pixel[2]*ra + inv_a);
    %%%%%: 6308-block 117
        -: 6309:            }
        -: 6310:         }
        -: 6311:      }
        -: 6312:   }
        -: 6313:
        -: 6314:   // convert to desired output format
    #####: 6315:   if (req_comp && req_comp != 4) {
    %%%%%: 6315-block 120
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6315-block 121
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 6316:      if (ri->bits_per_channel == 16)
    %%%%%: 6316-block 122
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6317:         out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, 4, req_comp, w, h);
    %%%%%: 6317-block 123
call    0 never executed
        -: 6318:      else
    #####: 6319:         out = stbi__convert_format(out, 4, req_comp, w, h);
    %%%%%: 6319-block 124
call    0 never executed
    #####: 6320:      if (out == NULL) return out; // stbi__convert_format frees input on failure
    %%%%%: 6320-block 125
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6320-block 126
        -: 6321:   }
        -: 6322:
    #####: 6323:   if (comp) *comp = 4;
    %%%%%: 6323-block 127
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6323-block 128
    #####: 6324:   *y = h;
    #####: 6325:   *x = w;
        -: 6326:
    #####: 6327:   return out;
    %%%%%: 6327-block 129
        -: 6328:}
        -: 6329:#endif
        -: 6330:
        -: 6331:// *************************************************************************************************
        -: 6332:// Softimage PIC loader
        -: 6333:// by Tom Seddon
        -: 6334://
        -: 6335:// See http://softimage.wiki.softimage.com/index.php/INFO:_PIC_file_format
        -: 6336:// See http://ozviz.wasp.uwa.edu.au/~pbourke/dataformats/softimagepic/
        -: 6337:
        -: 6338:#ifndef STBI_NO_PIC
function _ZL13stbi__pic_is4P13stbi__contextPKc called 0 returned 0% blocks executed 0%
    #####: 6339:static int stbi__pic_is4(stbi__context *s,const char *str)
        -: 6340:{
        -: 6341:   int i;
    #####: 6342:   for (i=0; i<4; ++i)
    %%%%%: 6342-block 2
    %%%%%: 6342-block 6
    %%%%%: 6342-block 7
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6343:      if (stbi__get8(s) != (stbi_uc)str[i])
    %%%%%: 6343-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 6344:         return 0;
    %%%%%: 6344-block 5
        -: 6345:
    #####: 6346:   return 1;
    %%%%%: 6346-block 8
        -: 6347:}
        -: 6348:
function _ZL19stbi__pic_test_coreP13stbi__context called 0 returned 0% blocks executed 0%
    #####: 6349:static int stbi__pic_test_core(stbi__context *s)
        -: 6350:{
        -: 6351:   int i;
        -: 6352:
    #####: 6353:   if (!stbi__pic_is4(s,"\x53\x80\xF6\x34"))
    %%%%%: 6353-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 6354:      return 0;
    %%%%%: 6354-block 4
        -: 6355:
    #####: 6356:   for(i=0;i<84;++i)
    %%%%%: 6356-block 5
    %%%%%: 6356-block 8
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6357:      stbi__get8(s);
    %%%%%: 6357-block 6
call    0 never executed
        -: 6358:
    #####: 6359:   if (!stbi__pic_is4(s,"PICT"))
    %%%%%: 6359-block 9
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 6360:      return 0;
    %%%%%: 6360-block 11
        -: 6361:
    #####: 6362:   return 1;
    %%%%%: 6362-block 12
        -: 6363:}
        -: 6364:
        -: 6365:typedef struct
        -: 6366:{
        -: 6367:   stbi_uc size,type,channel;
        -: 6368:} stbi__pic_packet;
        -: 6369:
function _ZL13stbi__readvalP13stbi__contextiPh called 0 returned 0% blocks executed 0%
    #####: 6370:static stbi_uc *stbi__readval(stbi__context *s, int channel, stbi_uc *dest)
        -: 6371:{
    #####: 6372:   int mask=0x80, i;
        -: 6373:
    #####: 6374:   for (i=0; i<4; ++i, mask>>=1) {
    %%%%%: 6374-block 2
    %%%%%: 6374-block 10
    %%%%%: 6374-block 11
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6375:      if (channel & mask) {
    %%%%%: 6375-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6376:         if (stbi__at_eof(s)) return stbi__errpuc("bad file","PIC file too short");
    %%%%%: 6376-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 6376-block 6
call    3 never executed
    #####: 6377:         dest[i]=stbi__get8(s);
    %%%%%: 6377-block 8
call    0 never executed
        -: 6378:      }
        -: 6379:   }
        -: 6380:
    #####: 6381:   return dest;
    %%%%%: 6381-block 12
        -: 6382:}
        -: 6383:
function _ZL13stbi__copyvaliPhPKh called 0 returned 0% blocks executed 0%
    #####: 6384:static void stbi__copyval(int channel,stbi_uc *dest,const stbi_uc *src)
        -: 6385:{
    #####: 6386:   int mask=0x80,i;
        -: 6387:
    #####: 6388:   for (i=0;i<4; ++i, mask>>=1)
    %%%%%: 6388-block 2
    %%%%%: 6388-block 5
    %%%%%: 6388-block 6
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6389:      if (channel&mask)
    %%%%%: 6389-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6390:         dest[i]=src[i];
    %%%%%: 6390-block 4
    #####: 6391:}
        -: 6392:
function _ZL19stbi__pic_load_coreP13stbi__contextiiPiPh called 0 returned 0% blocks executed 0%
    #####: 6393:static stbi_uc *stbi__pic_load_core(stbi__context *s,int width,int height,int *comp, stbi_uc *result)
        -: 6394:{
    #####: 6395:   int act_comp=0,num_packets=0,y,chained;
    %%%%%: 6395-block 2
        -: 6396:   stbi__pic_packet packets[10];
        -: 6397:
        -: 6398:   // this will (should...) cater for even some bizarre stuff like having data
        -: 6399:    // for the same channel in multiple packets.
        -: 6400:   do {
        -: 6401:      stbi__pic_packet *packet;
        -: 6402:
    #####: 6403:      if (num_packets==sizeof(packets)/sizeof(packets[0]))
    %%%%%: 6403-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6404:         return stbi__errpuc("bad format","too many packets");
    %%%%%: 6404-block 4
call    0 never executed
        -: 6405:
    #####: 6406:      packet = &packets[num_packets++];
        -: 6407:
    #####: 6408:      chained = stbi__get8(s);
    %%%%%: 6408-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6409:      packet->size    = stbi__get8(s);
    %%%%%: 6409-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6410:      packet->type    = stbi__get8(s);
    %%%%%: 6410-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6411:      packet->channel = stbi__get8(s);
    %%%%%: 6411-block 9
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6412:
    #####: 6413:      act_comp |= packet->channel;
        -: 6414:
    #####: 6415:      if (stbi__at_eof(s))          return stbi__errpuc("bad file","file too short (reading packets)");
    %%%%%: 6415-block 10
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 6415-block 11
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 6415-block 12
call    5 never executed
    #####: 6416:      if (packet->size != 8)  return stbi__errpuc("bad format","packet isn't 8bpp");
    %%%%%: 6416-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6416-block 15
call    2 never executed
    #####: 6417:   } while (chained);
    %%%%%: 6417-block 17
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 6418:
    #####: 6419:   *comp = (act_comp & 0x10 ? 4 : 3); // has alpha channel?
    %%%%%: 6419-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6419-block 19
    %%%%%: 6419-block 20
        -: 6420:
    #####: 6421:   for(y=0; y<height; ++y) {
    %%%%%: 6421-block 21
    %%%%%: 6421-block 89
    %%%%%: 6421-block 90
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 6422:      int packet_idx;
        -: 6423:
    #####: 6424:      for(packet_idx=0; packet_idx < num_packets; ++packet_idx) {
    %%%%%: 6424-block 22
    %%%%%: 6424-block 87
    %%%%%: 6424-block 88
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6425:         stbi__pic_packet *packet = &packets[packet_idx];
    #####: 6426:         stbi_uc *dest = result+y*width*4;
        -: 6427:
    #####: 6428:         switch (packet->type) {
    %%%%%: 6428-block 23
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6429:            default:
    #####: 6430:               return stbi__errpuc("bad format","packet has bad compression type");
    %%%%%: 6430-block 24
call    0 never executed
        -: 6431:
    #####: 6432:            case 0: {//uncompressed
        -: 6433:               int x;
        -: 6434:
    #####: 6435:               for(x=0;x<width;++x, dest+=4)
    %%%%%: 6435-block 26
    %%%%%: 6435-block 30
    %%%%%: 6435-block 31
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6436:                  if (!stbi__readval(s,packet->channel,dest))
    %%%%%: 6436-block 27
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 6436-block 28
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 6437:                     return 0;
    %%%%%: 6437-block 29
    #####: 6438:               break;
    %%%%%: 6438-block 32
        -: 6439:            }
        -: 6440:
    #####: 6441:            case 1://Pure RLE
        -: 6442:               {
    #####: 6443:                  int left=width, i;
        -: 6444:
    #####: 6445:                  while (left>0) {
    %%%%%: 6445-block 33
    %%%%%: 6445-block 50
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 6446:                     stbi_uc count,value[4];
        -: 6447:
    #####: 6448:                     count=stbi__get8(s);
    %%%%%: 6448-block 34
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6449:                     if (stbi__at_eof(s))   return stbi__errpuc("bad file","file too short (pure read count)");
    %%%%%: 6449-block 35
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 6449-block 36
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 6449-block 37
call    5 never executed
    %%%%%: 6449-block 49
        -: 6450:
    #####: 6451:                     if (count > left)
    %%%%%: 6451-block 39
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6452:                        count = (stbi_uc) left;
    %%%%%: 6452-block 40
        -: 6453:
    #####: 6454:                     if (!stbi__readval(s,packet->channel,value))  return 0;
    %%%%%: 6454-block 41
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 6454-block 42
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 6454-block 43
        -: 6455:
    #####: 6456:                     for(i=0; i<count; ++i,dest+=4)
    %%%%%: 6456-block 44
    %%%%%: 6456-block 47
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6457:                        stbi__copyval(packet->channel,dest,value);
    %%%%%: 6457-block 45
call    0 never executed
    #####: 6458:                     left -= count;
    %%%%%: 6458-block 48
        -: 6459:                  }
        -: 6460:               }
    #####: 6461:               break;
    %%%%%: 6461-block 51
        -: 6462:
    #####: 6463:            case 2: {//Mixed RLE
    #####: 6464:               int left=width;
    #####: 6465:               while (left>0) {
    %%%%%: 6465-block 52
    %%%%%: 6465-block 85
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6466:                  int count = stbi__get8(s), i;
    %%%%%: 6466-block 53
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6467:                  if (stbi__at_eof(s))  return stbi__errpuc("bad file","file too short (mixed read count)");
    %%%%%: 6467-block 54
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 6467-block 55
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 6467-block 56
call    5 never executed
        -: 6468:
    #####: 6469:                  if (count >= 128) { // Repeated
    %%%%%: 6469-block 58
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6470:                     stbi_uc value[4];
        -: 6471:
    #####: 6472:                     if (count==128)
    %%%%%: 6472-block 59
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6473:                        count = stbi__get16be(s);
    %%%%%: 6473-block 60
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 6473-block 61
        -: 6474:                     else
    #####: 6475:                        count -= 127;
    %%%%%: 6475-block 62
    #####: 6476:                     if (count > left)
    %%%%%: 6476-block 63
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6477:                        return stbi__errpuc("bad file","scanline overrun");
    %%%%%: 6477-block 64
call    0 never executed
    %%%%%: 6477-block 74
        -: 6478:
    #####: 6479:                     if (!stbi__readval(s,packet->channel,value))
    %%%%%: 6479-block 66
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 6479-block 67
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 6480:                        return 0;
    %%%%%: 6480-block 68
        -: 6481:
    #####: 6482:                     for(i=0;i<count;++i, dest += 4)
    %%%%%: 6482-block 69
    %%%%%: 6482-block 72
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6483:                        stbi__copyval(packet->channel,dest,value);
    %%%%%: 6483-block 70
call    0 never executed
        -: 6484:                  } else { // Raw
    #####: 6485:                     ++count;
    #####: 6486:                     if (count>left) return stbi__errpuc("bad file","scanline overrun");
    %%%%%: 6486-block 75
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6486-block 76
call    2 never executed
        -: 6487:
    #####: 6488:                     for(i=0;i<count;++i, dest+=4)
    %%%%%: 6488-block 78
    %%%%%: 6488-block 82
    %%%%%: 6488-block 83
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6489:                        if (!stbi__readval(s,packet->channel,dest))
    %%%%%: 6489-block 79
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 6489-block 80
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 6490:                           return 0;
    %%%%%: 6490-block 81
        -: 6491:                  }
    #####: 6492:                  left-=count;
    %%%%%: 6492-block 84
        -: 6493:               }
    #####: 6494:               break;
    %%%%%: 6494-block 86
        -: 6495:            }
        -: 6496:         }
        -: 6497:      }
        -: 6498:   }
        -: 6499:
    #####: 6500:   return result;
    %%%%%: 6500-block 91
        -: 6501:}
        -: 6502:
function _ZL14stbi__pic_loadP13stbi__contextPiS1_S1_iP17stbi__result_info called 0 returned 0% blocks executed 0%
    #####: 6503:static void *stbi__pic_load(stbi__context *s,int *px,int *py,int *comp,int req_comp, stbi__result_info *ri)
        -: 6504:{
        -: 6505:   stbi_uc *result;
        -: 6506:   int i, x,y, internal_comp;
        -: 6507:   STBI_NOTUSED(ri);
        -: 6508:
    #####: 6509:   if (!comp) comp = &internal_comp;
    %%%%%: 6509-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6509-block 3
        -: 6510:
    #####: 6511:   for (i=0; i<92; ++i)
    %%%%%: 6511-block 4
    %%%%%: 6511-block 6
    %%%%%: 6511-block 7
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6512:      stbi__get8(s);
    %%%%%: 6512-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6513:
    #####: 6514:   x = stbi__get16be(s);
    %%%%%: 6514-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6515:   y = stbi__get16be(s);
    %%%%%: 6515-block 9
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6516:
    #####: 6517:   if (y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
    %%%%%: 6517-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6517-block 11
call    2 never executed
    #####: 6518:   if (x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
    %%%%%: 6518-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6518-block 14
call    2 never executed
        -: 6519:
    #####: 6520:   if (stbi__at_eof(s))  return stbi__errpuc("bad file","file too short (pic header)");
    %%%%%: 6520-block 16
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 6520-block 17
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 6520-block 18
call    5 never executed
    #####: 6521:   if (!stbi__mad3sizes_valid(x, y, 4, 0)) return stbi__errpuc("too large", "PIC image too large to decode");
    %%%%%: 6521-block 20
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 6521-block 22
call    3 never executed
        -: 6522:
    #####: 6523:   stbi__get32be(s); //skip `ratio'
    %%%%%: 6523-block 24
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6524:   stbi__get16be(s); //skip `fields'
    %%%%%: 6524-block 25
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6525:   stbi__get16be(s); //skip `pad'
    %%%%%: 6525-block 26
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6526:
        -: 6527:   // intermediate buffer is RGBA
    #####: 6528:   result = (stbi_uc *) stbi__malloc_mad3(x, y, 4, 0);
    %%%%%: 6528-block 27
call    0 never executed
    #####: 6529:   if (!result) return stbi__errpuc("outofmem", "Out of memory");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6529-block 29
call    2 never executed
    #####: 6530:   memset(result, 0xff, x*y*4);
        -: 6531:
    #####: 6532:   if (!stbi__pic_load_core(s,x,y,comp, result)) {
    %%%%%: 6532-block 31
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 6532-block 32
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 6533:      STBI_FREE(result);
    #####: 6534:      result=0;
    %%%%%: 6534-block 33
        -: 6535:   }
    #####: 6536:   *px = x;
    #####: 6537:   *py = y;
    #####: 6538:   if (req_comp == 0) req_comp = *comp;
    %%%%%: 6538-block 34
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6538-block 35
    #####: 6539:   result=stbi__convert_format(result,4,req_comp,x,y);
    %%%%%: 6539-block 36
call    0 never executed
        -: 6540:
    #####: 6541:   return result;
        -: 6542:}
        -: 6543:
function _ZL14stbi__pic_testP13stbi__context called 0 returned 0% blocks executed 0%
    #####: 6544:static int stbi__pic_test(stbi__context *s)
        -: 6545:{
    #####: 6546:   int r = stbi__pic_test_core(s);
    %%%%%: 6546-block 2
call    0 never executed
    #####: 6547:   stbi__rewind(s);
call    0 never executed
    #####: 6548:   return r;
        -: 6549:}
        -: 6550:#endif
        -: 6551:
        -: 6552:// *************************************************************************************************
        -: 6553:// GIF loader -- public domain by Jean-Marc Lienher -- simplified/shrunk by stb
        -: 6554:
        -: 6555:#ifndef STBI_NO_GIF
        -: 6556:typedef struct
        -: 6557:{
        -: 6558:   stbi__int16 prefix;
        -: 6559:   stbi_uc first;
        -: 6560:   stbi_uc suffix;
        -: 6561:} stbi__gif_lzw;
        -: 6562:
        -: 6563:typedef struct
        -: 6564:{
        -: 6565:   int w,h;
        -: 6566:   stbi_uc *out;                 // output buffer (always 4 components)
        -: 6567:   stbi_uc *background;          // The current "background" as far as a gif is concerned
        -: 6568:   stbi_uc *history;
        -: 6569:   int flags, bgindex, ratio, transparent, eflags;
        -: 6570:   stbi_uc  pal[256][4];
        -: 6571:   stbi_uc lpal[256][4];
        -: 6572:   stbi__gif_lzw codes[8192];
        -: 6573:   stbi_uc *color_table;
        -: 6574:   int parse, step;
        -: 6575:   int lflags;
        -: 6576:   int start_x, start_y;
        -: 6577:   int max_x, max_y;
        -: 6578:   int cur_x, cur_y;
        -: 6579:   int line_size;
        -: 6580:   int delay;
        -: 6581:} stbi__gif;
        -: 6582:
function _ZL18stbi__gif_test_rawP13stbi__context called 0 returned 0% blocks executed 0%
    #####: 6583:static int stbi__gif_test_raw(stbi__context *s)
        -: 6584:{
        -: 6585:   int sz;
    #####: 6586:   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8') return 0;
    %%%%%: 6586-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 6586-block 4
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 6586-block 6
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 6586-block 8
call    9 never executed
branch 10 never executed (fallthrough)
branch 11 never executed
    %%%%%: 6586-block 10
    %%%%%: 6586-block 11
    %%%%%: 6586-block 12
branch 12 never executed (fallthrough)
branch 13 never executed
    %%%%%: 6586-block 13
    #####: 6587:   sz = stbi__get8(s);
    %%%%%: 6587-block 14
call    0 never executed
    #####: 6588:   if (sz != '9' && sz != '7') return 0;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6588-block 16
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6588-block 17
    #####: 6589:   if (stbi__get8(s) != 'a') return 0;
    %%%%%: 6589-block 18
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 6589-block 20
    #####: 6590:   return 1;
    %%%%%: 6590-block 21
        -: 6591:}
        -: 6592:
function _ZL14stbi__gif_testP13stbi__context called 0 returned 0% blocks executed 0%
    #####: 6593:static int stbi__gif_test(stbi__context *s)
        -: 6594:{
    #####: 6595:   int r = stbi__gif_test_raw(s);
    %%%%%: 6595-block 2
call    0 never executed
    #####: 6596:   stbi__rewind(s);
call    0 never executed
    #####: 6597:   return r;
        -: 6598:}
        -: 6599:
function _ZL26stbi__gif_parse_colortableP13stbi__contextPA4_hii called 0 returned 0% blocks executed 0%
    #####: 6600:static void stbi__gif_parse_colortable(stbi__context *s, stbi_uc pal[256][4], int num_entries, int transp)
        -: 6601:{
        -: 6602:   int i;
    #####: 6603:   for (i=0; i < num_entries; ++i) {
    %%%%%: 6603-block 2
    %%%%%: 6603-block 10
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6604:      pal[i][2] = stbi__get8(s);
    %%%%%: 6604-block 3
call    0 never executed
    #####: 6605:      pal[i][1] = stbi__get8(s);
call    0 never executed
    #####: 6606:      pal[i][0] = stbi__get8(s);
call    0 never executed
    #####: 6607:      pal[i][3] = transp == i ? 0 : 255;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6607-block 7
    %%%%%: 6607-block 8
    %%%%%: 6607-block 9
        -: 6608:   }
    #####: 6609:}
        -: 6610:
function _ZL16stbi__gif_headerP13stbi__contextP9stbi__gifPii called 0 returned 0% blocks executed 0%
    #####: 6611:static int stbi__gif_header(stbi__context *s, stbi__gif *g, int *comp, int is_info)
        -: 6612:{
        -: 6613:   stbi_uc version;
    #####: 6614:   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8')
    %%%%%: 6614-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 6614-block 4
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 6614-block 6
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 6614-block 8
call    9 never executed
branch 10 never executed (fallthrough)
branch 11 never executed
    %%%%%: 6614-block 10
    %%%%%: 6614-block 11
    %%%%%: 6614-block 12
branch 12 never executed (fallthrough)
branch 13 never executed
    #####: 6615:      return stbi__err("not GIF", "Corrupt GIF");
    %%%%%: 6615-block 13
call    0 never executed
        -: 6616:
    #####: 6617:   version = stbi__get8(s);
    %%%%%: 6617-block 14
call    0 never executed
    #####: 6618:   if (version != '7' && version != '9')    return stbi__err("not GIF", "Corrupt GIF");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6618-block 16
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6618-block 17
call    4 never executed
    #####: 6619:   if (stbi__get8(s) != 'a')                return stbi__err("not GIF", "Corrupt GIF");
    %%%%%: 6619-block 18
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 6619-block 20
call    3 never executed
        -: 6620:
    #####: 6621:   stbi__g_failure_reason = "";
    #####: 6622:   g->w = stbi__get16le(s);
    %%%%%: 6622-block 21
call    0 never executed
    #####: 6623:   g->h = stbi__get16le(s);
call    0 never executed
    #####: 6624:   g->flags = stbi__get8(s);
call    0 never executed
    #####: 6625:   g->bgindex = stbi__get8(s);
call    0 never executed
    #####: 6626:   g->ratio = stbi__get8(s);
call    0 never executed
    #####: 6627:   g->transparent = -1;
        -: 6628:
    #####: 6629:   if (g->w > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6629-block 27
call    2 never executed
    #####: 6630:   if (g->h > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
    %%%%%: 6630-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6630-block 29
call    2 never executed
        -: 6631:
    #####: 6632:   if (comp != 0) *comp = 4;  // can't actually tell whether it's 3 or 4 until we parse the comments
    %%%%%: 6632-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6632-block 31
        -: 6633:
    #####: 6634:   if (is_info) return 1;
    %%%%%: 6634-block 32
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6634-block 33
        -: 6635:
    #####: 6636:   if (g->flags & 0x80)
    %%%%%: 6636-block 34
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6637:      stbi__gif_parse_colortable(s,g->pal, 2 << (g->flags & 7), -1);
    %%%%%: 6637-block 35
call    0 never executed
        -: 6638:
    #####: 6639:   return 1;
    %%%%%: 6639-block 36
        -: 6640:}
        -: 6641:
function _ZL18stbi__gif_info_rawP13stbi__contextPiS1_S1_ called 0 returned 0% blocks executed 0%
    #####: 6642:static int stbi__gif_info_raw(stbi__context *s, int *x, int *y, int *comp)
        -: 6643:{
    #####: 6644:   stbi__gif* g = (stbi__gif*) stbi__malloc(sizeof(stbi__gif));
    %%%%%: 6644-block 2
call    0 never executed
    #####: 6645:   if (!g) return stbi__err("outofmem", "Out of memory");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6645-block 4
call    2 never executed
    #####: 6646:   if (!stbi__gif_header(s, g, comp, 1)) {
    %%%%%: 6646-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 6647:      STBI_FREE(g);
    #####: 6648:      stbi__rewind( s );
    %%%%%: 6648-block 7
call    0 never executed
    #####: 6649:      return 0;
        -: 6650:   }
    #####: 6651:   if (x) *x = g->w;
    %%%%%: 6651-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6651-block 10
    #####: 6652:   if (y) *y = g->h;
    %%%%%: 6652-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6652-block 12
    #####: 6653:   STBI_FREE(g);
    #####: 6654:   return 1;
    %%%%%: 6654-block 13
        -: 6655:}
        -: 6656:
function _ZL18stbi__out_gif_codeP9stbi__gift called 0 returned 0% blocks executed 0%
    #####: 6657:static void stbi__out_gif_code(stbi__gif *g, stbi__uint16 code)
        -: 6658:{
        -: 6659:   stbi_uc *p, *c;
        -: 6660:   int idx;
        -: 6661:
        -: 6662:   // recurse to decode the prefixes, since the linked-list is backwards,
        -: 6663:   // and working backwards through an interleaved image would be nasty
    #####: 6664:   if (g->codes[code].prefix >= 0)
    %%%%%: 6664-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6665:      stbi__out_gif_code(g, g->codes[code].prefix);
    %%%%%: 6665-block 3
call    0 never executed
        -: 6666:
    #####: 6667:   if (g->cur_y >= g->max_y) return;
    %%%%%: 6667-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6667-block 5
        -: 6668:
    #####: 6669:   idx = g->cur_x + g->cur_y;
    #####: 6670:   p = &g->out[idx];
    #####: 6671:   g->history[idx / 4] = 1;
        -: 6672:
    #####: 6673:   c = &g->color_table[g->codes[code].suffix * 4];
    #####: 6674:   if (c[3] > 128) { // don't render transparent pixels;
    %%%%%: 6674-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6675:      p[0] = c[2];
    #####: 6676:      p[1] = c[1];
    #####: 6677:      p[2] = c[0];
    #####: 6678:      p[3] = c[3];
    %%%%%: 6678-block 7
        -: 6679:   }
    #####: 6680:   g->cur_x += 4;
        -: 6681:
    #####: 6682:   if (g->cur_x >= g->max_x) {
    %%%%%: 6682-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6683:      g->cur_x = g->start_x;
    #####: 6684:      g->cur_y += g->step;
        -: 6685:
    #####: 6686:      while (g->cur_y >= g->max_y && g->parse > 0) {
    %%%%%: 6686-block 9
    %%%%%: 6686-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6686-block 12
branch  2 never executed
branch  3 never executed (fallthrough)
    #####: 6687:         g->step = (1 << g->parse) * g->line_size;
    #####: 6688:         g->cur_y = g->start_y + (g->step >> 1);
    #####: 6689:         --g->parse;
    %%%%%: 6689-block 10
        -: 6690:      }
        -: 6691:   }
        -: 6692:}
        -: 6693:
function _ZL24stbi__process_gif_rasterP13stbi__contextP9stbi__gif called 0 returned 0% blocks executed 0%
    #####: 6694:static stbi_uc *stbi__process_gif_raster(stbi__context *s, stbi__gif *g)
        -: 6695:{
        -: 6696:   stbi_uc lzw_cs;
        -: 6697:   stbi__int32 len, init_code;
        -: 6698:   stbi__uint32 first;
        -: 6699:   stbi__int32 codesize, codemask, avail, oldcode, bits, valid_bits, clear;
        -: 6700:   stbi__gif_lzw *p;
        -: 6701:
    #####: 6702:   lzw_cs = stbi__get8(s);
    %%%%%: 6702-block 2
call    0 never executed
    #####: 6703:   if (lzw_cs > 12) return NULL;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6703-block 4
    #####: 6704:   clear = 1 << lzw_cs;
    #####: 6705:   first = 1;
    #####: 6706:   codesize = lzw_cs + 1;
    #####: 6707:   codemask = (1 << codesize) - 1;
    #####: 6708:   bits = 0;
    #####: 6709:   valid_bits = 0;
    #####: 6710:   for (init_code = 0; init_code < clear; init_code++) {
    %%%%%: 6710-block 5
    %%%%%: 6710-block 7
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6711:      g->codes[init_code].prefix = -1;
    #####: 6712:      g->codes[init_code].first = (stbi_uc) init_code;
    #####: 6713:      g->codes[init_code].suffix = (stbi_uc) init_code;
    %%%%%: 6713-block 6
        -: 6714:   }
        -: 6715:
        -: 6716:   // support no starting clear code
    #####: 6717:   avail = clear+2;
    #####: 6718:   oldcode = -1;
        -: 6719:
    #####: 6720:   len = 0;
    %%%%%: 6720-block 8
        -: 6721:   for(;;) {
    #####: 6722:      if (valid_bits < codesize) {
    %%%%%: 6722-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6723:         if (len == 0) {
    %%%%%: 6723-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6724:            len = stbi__get8(s); // start new block
    %%%%%: 6724-block 11
call    0 never executed
    #####: 6725:            if (len == 0)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6726:               return g->out;
    %%%%%: 6726-block 13
        -: 6727:         }
    #####: 6728:         --len;
    #####: 6729:         bits |= (stbi__int32) stbi__get8(s) << valid_bits;
    %%%%%: 6729-block 14
call    0 never executed
    #####: 6730:         valid_bits += 8;
        -: 6731:      } else {
    #####: 6732:         stbi__int32 code = bits & codemask;
    #####: 6733:         bits >>= codesize;
    #####: 6734:         valid_bits -= codesize;
        -: 6735:         // @OPTIMIZE: is there some way we can accelerate the non-clear path?
    #####: 6736:         if (code == clear) {  // clear code
    %%%%%: 6736-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6737:            codesize = lzw_cs + 1;
    #####: 6738:            codemask = (1 << codesize) - 1;
    #####: 6739:            avail = clear + 2;
    #####: 6740:            oldcode = -1;
    #####: 6741:            first = 0;
    %%%%%: 6741-block 17
    #####: 6742:         } else if (code == clear + 1) { // end of stream code
    %%%%%: 6742-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6743:            stbi__skip(s, len);
    %%%%%: 6743-block 19
call    0 never executed
    #####: 6744:            while ((len = stbi__get8(s)) > 0)
    %%%%%: 6744-block 22
call    0 never executed
branch  1 never executed
branch  2 never executed (fallthrough)
    #####: 6745:               stbi__skip(s,len);
    %%%%%: 6745-block 21
call    0 never executed
    #####: 6746:            return g->out;
    %%%%%: 6746-block 24
    #####: 6747:         } else if (code <= avail) {
    %%%%%: 6747-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6748:            if (first) {
    %%%%%: 6748-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6749:               return stbi__errpuc("no clear code", "Corrupt GIF");
    %%%%%: 6749-block 27
call    0 never executed
        -: 6750:            }
        -: 6751:
    #####: 6752:            if (oldcode >= 0) {
    %%%%%: 6752-block 29
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6753:               p = &g->codes[avail++];
    #####: 6754:               if (avail > 8192) {
    %%%%%: 6754-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6755:                  return stbi__errpuc("too many codes", "Corrupt GIF");
    %%%%%: 6755-block 31
call    0 never executed
        -: 6756:               }
        -: 6757:
    #####: 6758:               p->prefix = (stbi__int16) oldcode;
    #####: 6759:               p->first = g->codes[oldcode].first;
    #####: 6760:               p->suffix = (code == avail) ? p->first : g->codes[code].first;
    %%%%%: 6760-block 33
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6760-block 34
    %%%%%: 6760-block 35
    %%%%%: 6760-block 36
    #####: 6761:            } else if (code == avail)
    %%%%%: 6761-block 37
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6762:               return stbi__errpuc("illegal code in raster", "Corrupt GIF");
    %%%%%: 6762-block 38
call    0 never executed
        -: 6763:
    #####: 6764:            stbi__out_gif_code(g, (stbi__uint16) code);
    %%%%%: 6764-block 40
call    0 never executed
        -: 6765:
    #####: 6766:            if ((avail & codemask) == 0 && avail <= 0x0FFF) {
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6766-block 42
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 6767:               codesize++;
    #####: 6768:               codemask = (1 << codesize) - 1;
    %%%%%: 6768-block 43
        -: 6769:            }
        -: 6770:
    #####: 6771:            oldcode = code;
    %%%%%: 6771-block 44
        -: 6772:         } else {
    #####: 6773:            return stbi__errpuc("illegal code in raster", "Corrupt GIF");
    %%%%%: 6773-block 45
call    0 never executed
        -: 6774:         }
        -: 6775:      }
    #####: 6776:   }
    %%%%%: 6776-block 47
        -: 6777:}
        -: 6778:
        -: 6779:// this function is designed to support animated gifs, although stb_image doesn't support it
        -: 6780:// two back is the image from two frames ago, used for a very specific disposal format
function _ZL19stbi__gif_load_nextP13stbi__contextP9stbi__gifPiiPh called 0 returned 0% blocks executed 0%
    #####: 6781:static stbi_uc *stbi__gif_load_next(stbi__context *s, stbi__gif *g, int *comp, int req_comp, stbi_uc *two_back)
        -: 6782:{
        -: 6783:   int dispose;
        -: 6784:   int first_frame;
        -: 6785:   int pi;
        -: 6786:   int pcount;
        -: 6787:   STBI_NOTUSED(req_comp);
        -: 6788:
        -: 6789:   // on first frame, any non-written pixels get the background colour (non-transparent)
    #####: 6790:   first_frame = 0;
    #####: 6791:   if (g->out == 0) {
    %%%%%: 6791-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6792:      if (!stbi__gif_header(s, g, comp,0)) return 0; // stbi__g_failure_reason set by stbi__gif_header
    %%%%%: 6792-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 6792-block 5
    #####: 6793:      if (!stbi__mad3sizes_valid(4, g->w, g->h, 0))
    %%%%%: 6793-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 6794:         return stbi__errpuc("too large", "GIF image is too large");
    %%%%%: 6794-block 8
call    0 never executed
    #####: 6795:      pcount = g->w * g->h;
    #####: 6796:      g->out = (stbi_uc *) stbi__malloc(4 * pcount);
    %%%%%: 6796-block 10
call    0 never executed
    #####: 6797:      g->background = (stbi_uc *) stbi__malloc(4 * pcount);
call    0 never executed
    #####: 6798:      g->history = (stbi_uc *) stbi__malloc(pcount);
call    0 never executed
    #####: 6799:      if (!g->out || !g->background || !g->history)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6799-block 14
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6799-block 15
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 6800:         return stbi__errpuc("outofmem", "Out of memory");
    %%%%%: 6800-block 16
call    0 never executed
        -: 6801:
        -: 6802:      // image is treated as "transparent" at the start - ie, nothing overwrites the current background;
        -: 6803:      // background colour is only used for pixels that are not rendered first frame, after that "background"
        -: 6804:      // color refers to the color that was there the previous frame.
    #####: 6805:      memset(g->out, 0x00, 4 * pcount);
    #####: 6806:      memset(g->background, 0x00, 4 * pcount); // state of the background (starts transparent)
    #####: 6807:      memset(g->history, 0x00, pcount);        // pixels that were affected previous frame
    #####: 6808:      first_frame = 1;
    %%%%%: 6808-block 18
        -: 6809:   } else {
        -: 6810:      // second frame - how do we dispose of the previous one?
    #####: 6811:      dispose = (g->eflags & 0x1C) >> 2;
    #####: 6812:      pcount = g->w * g->h;
        -: 6813:
    #####: 6814:      if ((dispose == 3) && (two_back == 0)) {
    %%%%%: 6814-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6814-block 20
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 6815:         dispose = 2; // if I don't have an image to revert back to, default to the old background
    %%%%%: 6815-block 21
        -: 6816:      }
        -: 6817:
    #####: 6818:      if (dispose == 3) { // use previous graphic
    %%%%%: 6818-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6819:         for (pi = 0; pi < pcount; ++pi) {
    %%%%%: 6819-block 23
    %%%%%: 6819-block 26
    %%%%%: 6819-block 27
branch  0 never executed
branch  1 never executed
    #####: 6820:            if (g->history[pi]) {
    %%%%%: 6820-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6821:               memcpy( &g->out[pi * 4], &two_back[pi * 4], 4 );
    %%%%%: 6821-block 25
        -: 6822:            }
        -: 6823:         }
    #####: 6824:      } else if (dispose == 2) {
    %%%%%: 6824-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6825:         // restore what was changed last frame to background before that frame;
    #####: 6826:         for (pi = 0; pi < pcount; ++pi) {
    %%%%%: 6826-block 29
    %%%%%: 6826-block 32
    %%%%%: 6826-block 33
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6827:            if (g->history[pi]) {
    %%%%%: 6827-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6828:               memcpy( &g->out[pi * 4], &g->background[pi * 4], 4 );
    %%%%%: 6828-block 31
        -: 6829:            }
        -: 6830:         }
        -: 6831:      } else {
        -: 6832:         // This is a non-disposal case eithe way, so just
        -: 6833:         // leave the pixels as is, and they will become the new background
        -: 6834:         // 1: do not dispose
        -: 6835:         // 0:  not specified.
        -: 6836:      }
        -: 6837:
        -: 6838:      // background is what out is after the undoing of the previou frame;
    #####: 6839:      memcpy( g->background, g->out, 4 * g->w * g->h );
    %%%%%: 6839-block 34
        -: 6840:   }
        -: 6841:
        -: 6842:   // clear my history;
    #####: 6843:   memset( g->history, 0x00, g->w * g->h );        // pixels that were affected previous frame
    %%%%%: 6843-block 35
        -: 6844:
        -: 6845:   for (;;) {
    #####: 6846:      int tag = stbi__get8(s);
    %%%%%: 6846-block 36
call    0 never executed
    #####: 6847:      switch (tag) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6848:         case 0x2C: /* Image Descriptor */
        -: 6849:         {
        -: 6850:            stbi__int32 x, y, w, h;
        -: 6851:            stbi_uc *o;
        -: 6852:
    #####: 6853:            x = stbi__get16le(s);
    %%%%%: 6853-block 38
call    0 never executed
    #####: 6854:            y = stbi__get16le(s);
call    0 never executed
    #####: 6855:            w = stbi__get16le(s);
call    0 never executed
    #####: 6856:            h = stbi__get16le(s);
call    0 never executed
    #####: 6857:            if (((x + w) > (g->w)) || ((y + h) > (g->h)))
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6857-block 43
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 6858:               return stbi__errpuc("bad Image Descriptor", "Corrupt GIF");
    %%%%%: 6858-block 44
call    0 never executed
        -: 6859:
    #####: 6860:            g->line_size = g->w * 4;
    #####: 6861:            g->start_x = x * 4;
    #####: 6862:            g->start_y = y * g->line_size;
    #####: 6863:            g->max_x   = g->start_x + w * 4;
    #####: 6864:            g->max_y   = g->start_y + h * g->line_size;
    #####: 6865:            g->cur_x   = g->start_x;
    #####: 6866:            g->cur_y   = g->start_y;
        -: 6867:
        -: 6868:            // if the width of the specified rectangle is 0, that means
        -: 6869:            // we may not see *any* pixels or the image is malformed;
        -: 6870:            // to make sure this is caught, move the current y down to
        -: 6871:            // max_y (which is what out_gif_code checks).
    #####: 6872:            if (w == 0)
    %%%%%: 6872-block 46
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6873:               g->cur_y = g->max_y;
    %%%%%: 6873-block 47
        -: 6874:
    #####: 6875:            g->lflags = stbi__get8(s);
    %%%%%: 6875-block 48
call    0 never executed
        -: 6876:
    #####: 6877:            if (g->lflags & 0x40) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6878:               g->step = 8 * g->line_size; // first interlaced spacing
    #####: 6879:               g->parse = 3;
    %%%%%: 6879-block 50
        -: 6880:            } else {
    #####: 6881:               g->step = g->line_size;
    #####: 6882:               g->parse = 0;
    %%%%%: 6882-block 51
        -: 6883:            }
        -: 6884:
    #####: 6885:            if (g->lflags & 0x80) {
    %%%%%: 6885-block 52
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6886:               stbi__gif_parse_colortable(s,g->lpal, 2 << (g->lflags & 7), g->eflags & 0x01 ? g->transparent : -1);
    %%%%%: 6886-block 53
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6886-block 54
    %%%%%: 6886-block 55
    %%%%%: 6886-block 56
call    2 never executed
    #####: 6887:               g->color_table = (stbi_uc *) g->lpal;
    #####: 6888:            } else if (g->flags & 0x80) {
    %%%%%: 6888-block 58
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6889:               g->color_table = (stbi_uc *) g->pal;
    %%%%%: 6889-block 59
        -: 6890:            } else
    #####: 6891:               return stbi__errpuc("missing color table", "Corrupt GIF");
    %%%%%: 6891-block 60
call    0 never executed
        -: 6892:
    #####: 6893:            o = stbi__process_gif_raster(s, g);
    %%%%%: 6893-block 62
call    0 never executed
    #####: 6894:            if (!o) return NULL;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6894-block 64
        -: 6895:
        -: 6896:            // if this was the first frame,
    #####: 6897:            pcount = g->w * g->h;
    #####: 6898:            if (first_frame && (g->bgindex > 0)) {
    %%%%%: 6898-block 65
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6898-block 66
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 6899:               // if first frame, any pixel not drawn to gets the background color
    #####: 6900:               for (pi = 0; pi < pcount; ++pi) {
    %%%%%: 6900-block 67
    %%%%%: 6900-block 70
    %%%%%: 6900-block 71
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6901:                  if (g->history[pi] == 0) {
    %%%%%: 6901-block 68
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6902:                     g->pal[g->bgindex][3] = 255; // just in case it was made transparent, undo that; It will be reset next frame if need be;
    #####: 6903:                     memcpy( &g->out[pi * 4], &g->pal[g->bgindex], 4 );
    %%%%%: 6903-block 69
        -: 6904:                  }
        -: 6905:               }
        -: 6906:            }
        -: 6907:
    #####: 6908:            return o;
    %%%%%: 6908-block 72
        -: 6909:         }
        -: 6910:
    #####: 6911:         case 0x21: // Comment Extension.
        -: 6912:         {
        -: 6913:            int len;
    #####: 6914:            int ext = stbi__get8(s);
    %%%%%: 6914-block 73
call    0 never executed
    #####: 6915:            if (ext == 0xF9) { // Graphic Control Extension.
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6916:               len = stbi__get8(s);
    %%%%%: 6916-block 75
call    0 never executed
    #####: 6917:               if (len == 4) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6918:                  g->eflags = stbi__get8(s);
    %%%%%: 6918-block 77
call    0 never executed
    #####: 6919:                  g->delay = 10 * stbi__get16le(s); // delay - 1/100th of a second, saving as 1/1000ths.
call    0 never executed
        -: 6920:
        -: 6921:                  // unset old transparent
    #####: 6922:                  if (g->transparent >= 0) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6923:                     g->pal[g->transparent][3] = 255;
    %%%%%: 6923-block 80
        -: 6924:                  }
    #####: 6925:                  if (g->eflags & 0x01) {
    %%%%%: 6925-block 81
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6926:                     g->transparent = stbi__get8(s);
    %%%%%: 6926-block 82
call    0 never executed
    #####: 6927:                     if (g->transparent >= 0) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6928:                        g->pal[g->transparent][3] = 0;
    %%%%%: 6928-block 84
        -: 6929:                     }
        -: 6930:                  } else {
        -: 6931:                     // don't need transparent
    #####: 6932:                     stbi__skip(s, 1);
    %%%%%: 6932-block 85
call    0 never executed
    #####: 6933:                     g->transparent = -1;
        -: 6934:                  }
        -: 6935:               } else {
    #####: 6936:                  stbi__skip(s, len);
    %%%%%: 6936-block 87
call    0 never executed
    #####: 6937:                  break;
        -: 6938:               }
        -: 6939:            }
    #####: 6940:            while ((len = stbi__get8(s)) != 0) {
    %%%%%: 6940-block 88
    %%%%%: 6940-block 90
call    0 never executed
branch  1 never executed
branch  2 never executed (fallthrough)
    #####: 6941:               stbi__skip(s, len);
    %%%%%: 6941-block 89
call    0 never executed
        -: 6942:            }
    #####: 6943:            break;
    %%%%%: 6943-block 92
        -: 6944:         }
        -: 6945:
    #####: 6946:         case 0x3B: // gif stream termination code
    #####: 6947:            return (stbi_uc *) s; // using '1' causes warning on some compilers
    %%%%%: 6947-block 93
        -: 6948:
    #####: 6949:         default:
    #####: 6950:            return stbi__errpuc("unknown code", "Corrupt GIF");
    %%%%%: 6950-block 94
call    0 never executed
        -: 6951:      }
    #####: 6952:   }
    %%%%%: 6952-block 97
        -: 6953:}
        -: 6954:
function _ZL28stbi__load_gif_main_outofmemP9stbi__gifPhPPi called 0 returned 0% blocks executed 0%
    #####: 6955:static void *stbi__load_gif_main_outofmem(stbi__gif *g, stbi_uc *out, int **delays)
        -: 6956:{
    #####: 6957:   STBI_FREE(g->out);
    #####: 6958:   STBI_FREE(g->history);
    #####: 6959:   STBI_FREE(g->background);
        -: 6960:
    #####: 6961:   if (out) STBI_FREE(out);
    %%%%%: 6961-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6961-block 3
    #####: 6962:   if (delays && *delays) STBI_FREE(*delays);
    %%%%%: 6962-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6962-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6962-block 6
    #####: 6963:   return stbi__errpuc("outofmem", "Out of memory");
    %%%%%: 6963-block 7
call    0 never executed
        -: 6964:}
        -: 6965:
function _ZL19stbi__load_gif_mainP13stbi__contextPPiS1_S1_S1_S1_i called 0 returned 0% blocks executed 0%
    #####: 6966:static void *stbi__load_gif_main(stbi__context *s, int **delays, int *x, int *y, int *z, int *comp, int req_comp)
        -: 6967:{
    #####: 6968:   if (stbi__gif_test(s)) {
    %%%%%: 6968-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 6969:      int layers = 0;
    #####: 6970:      stbi_uc *u = 0;
    #####: 6971:      stbi_uc *out = 0;
    #####: 6972:      stbi_uc *two_back = 0;
        -: 6973:      stbi__gif g;
        -: 6974:      int stride;
    #####: 6975:      int out_size = 0;
    #####: 6976:      int delays_size = 0;
        -: 6977:
        -: 6978:      STBI_NOTUSED(out_size);
        -: 6979:      STBI_NOTUSED(delays_size);
        -: 6980:
    #####: 6981:      memset(&g, 0, sizeof(g));
    #####: 6982:      if (delays) {
    %%%%%: 6982-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6983:         *delays = 0;
    %%%%%: 6983-block 5
        -: 6984:      }
        -: 6985:
        -: 6986:      do {
    #####: 6987:         u = stbi__gif_load_next(s, &g, comp, req_comp, two_back);
    %%%%%: 6987-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6988:         if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker
    %%%%%: 6988-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6988-block 8
        -: 6989:
    #####: 6990:         if (u) {
    %%%%%: 6990-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6991:            *x = g.w;
    #####: 6992:            *y = g.h;
    #####: 6993:            ++layers;
    #####: 6994:            stride = g.w * g.h * 4;
        -: 6995:
    #####: 6996:            if (out) {
    %%%%%: 6996-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6997:               void *tmp = (stbi_uc*) STBI_REALLOC_SIZED( out, out_size, layers * stride );
    #####: 6998:               if (!tmp)
    %%%%%: 6998-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6999:                  return stbi__load_gif_main_outofmem(&g, out, delays);
    %%%%%: 6999-block 12
call    0 never executed
        -: 7000:               else {
    #####: 7001:                   out = (stbi_uc*) tmp;
    #####: 7002:                   out_size = layers * stride;
        -: 7003:               }
        -: 7004:
    #####: 7005:               if (delays) {
    %%%%%: 7005-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7006:                  int *new_delays = (int*) STBI_REALLOC_SIZED( *delays, delays_size, sizeof(int) * layers );
    #####: 7007:                  if (!new_delays)
    %%%%%: 7007-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7008:                     return stbi__load_gif_main_outofmem(&g, out, delays);
    %%%%%: 7008-block 15
call    0 never executed
    #####: 7009:                  *delays = new_delays;
    #####: 7010:                  delays_size = layers * sizeof(int);
    %%%%%: 7010-block 16
        -: 7011:               }
        -: 7012:            } else {
    #####: 7013:               out = (stbi_uc*)stbi__malloc( layers * stride );
    %%%%%: 7013-block 17
call    0 never executed
    #####: 7014:               if (!out)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7015:                  return stbi__load_gif_main_outofmem(&g, out, delays);
    %%%%%: 7015-block 19
call    0 never executed
    #####: 7016:               out_size = layers * stride;
    #####: 7017:               if (delays) {
    %%%%%: 7017-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7018:                  *delays = (int*) stbi__malloc( layers * sizeof(int) );
    %%%%%: 7018-block 21
call    0 never executed
    #####: 7019:                  if (!*delays)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7020:                     return stbi__load_gif_main_outofmem(&g, out, delays);
    %%%%%: 7020-block 23
call    0 never executed
    #####: 7021:                  delays_size = layers * sizeof(int);
    %%%%%: 7021-block 24
        -: 7022:               }
        -: 7023:            }
    #####: 7024:            memcpy( out + ((layers - 1) * stride), u, stride );
    #####: 7025:            if (layers >= 2) {
    %%%%%: 7025-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7026:               two_back = out - 2 * stride;
    %%%%%: 7026-block 26
        -: 7027:            }
        -: 7028:
    #####: 7029:            if (delays) {
    %%%%%: 7029-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7030:               (*delays)[layers - 1U] = g.delay;
    %%%%%: 7030-block 28
        -: 7031:            }
        -: 7032:         }
    #####: 7033:      } while (u != 0);
    %%%%%: 7033-block 29
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 7034:
        -: 7035:      // free temp buffer;
    #####: 7036:      STBI_FREE(g.out);
    #####: 7037:      STBI_FREE(g.history);
    #####: 7038:      STBI_FREE(g.background);
        -: 7039:
        -: 7040:      // do the final conversion after loading everything;
    #####: 7041:      if (req_comp && req_comp != 4)
    %%%%%: 7041-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7041-block 31
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 7042:         out = stbi__convert_format(out, 4, req_comp, layers * g.w, g.h);
    %%%%%: 7042-block 32
call    0 never executed
        -: 7043:
    #####: 7044:      *z = layers;
    #####: 7045:      return out;
    %%%%%: 7045-block 33
        -: 7046:   } else {
    #####: 7047:      return stbi__errpuc("not GIF", "Image was not as a gif type.");
    %%%%%: 7047-block 35
call    0 never executed
        -: 7048:   }
        -: 7049:}
        -: 7050:
function _ZL14stbi__gif_loadP13stbi__contextPiS1_S1_iP17stbi__result_info called 0 returned 0% blocks executed 0%
    #####: 7051:static void *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
        -: 7052:{
    #####: 7053:   stbi_uc *u = 0;
        -: 7054:   stbi__gif g;
    #####: 7055:   memset(&g, 0, sizeof(g));
        -: 7056:   STBI_NOTUSED(ri);
        -: 7057:
    #####: 7058:   u = stbi__gif_load_next(s, &g, comp, req_comp, 0);
    %%%%%: 7058-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7059:   if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker
    %%%%%: 7059-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7059-block 4
    #####: 7060:   if (u) {
    %%%%%: 7060-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7061:      *x = g.w;
    #####: 7062:      *y = g.h;
        -: 7063:
        -: 7064:      // moved conversion to after successful load so that the same
        -: 7065:      // can be done for multiple frames.
    #####: 7066:      if (req_comp && req_comp != 4)
    %%%%%: 7066-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7066-block 7
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 7067:         u = stbi__convert_format(u, 4, req_comp, g.w, g.h);
    %%%%%: 7067-block 8
call    0 never executed
    #####: 7068:   } else if (g.out) {
    %%%%%: 7068-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 7069:      // if there was an error and we allocated an image buffer, free it!
    #####: 7070:      STBI_FREE(g.out);
    %%%%%: 7070-block 10
        -: 7071:   }
        -: 7072:
        -: 7073:   // free buffers needed for multiple frame loading;
    #####: 7074:   STBI_FREE(g.history);
    #####: 7075:   STBI_FREE(g.background);
        -: 7076:
    #####: 7077:   return u;
    %%%%%: 7077-block 11
    %%%%%: 7077-block 12
        -: 7078:}
        -: 7079:
function _ZL14stbi__gif_infoP13stbi__contextPiS1_S1_ called 0 returned 0% blocks executed 0%
    #####: 7080:static int stbi__gif_info(stbi__context *s, int *x, int *y, int *comp)
        -: 7081:{
    #####: 7082:   return stbi__gif_info_raw(s,x,y,comp);
    %%%%%: 7082-block 2
call    0 never executed
        -: 7083:}
        -: 7084:#endif
        -: 7085:
        -: 7086:// *************************************************************************************************
        -: 7087:// Radiance RGBE HDR loader
        -: 7088:// originally by Nicolas Schulz
        -: 7089:#ifndef STBI_NO_HDR
function _ZL19stbi__hdr_test_coreP13stbi__contextPKc called 0 returned 0% blocks executed 0%
    #####: 7090:static int stbi__hdr_test_core(stbi__context *s, const char *signature)
        -: 7091:{
        -: 7092:   int i;
    #####: 7093:   for (i=0; signature[i]; ++i)
    %%%%%: 7093-block 2
    %%%%%: 7093-block 6
    %%%%%: 7093-block 7
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 7094:      if (stbi__get8(s) != signature[i])
    %%%%%: 7094-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 7095:          return 0;
    %%%%%: 7095-block 5
    #####: 7096:   stbi__rewind(s);
    %%%%%: 7096-block 8
call    0 never executed
    #####: 7097:   return 1;
        -: 7098:}
        -: 7099:
function _ZL14stbi__hdr_testP13stbi__context called 0 returned 0% blocks executed 0%
    #####: 7100:static int stbi__hdr_test(stbi__context* s)
        -: 7101:{
    #####: 7102:   int r = stbi__hdr_test_core(s, "#?RADIANCE\n");
    %%%%%: 7102-block 2
call    0 never executed
    #####: 7103:   stbi__rewind(s);
call    0 never executed
    #####: 7104:   if(!r) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7105:       r = stbi__hdr_test_core(s, "#?RGBE\n");
    %%%%%: 7105-block 5
call    0 never executed
    #####: 7106:       stbi__rewind(s);
call    0 never executed
        -: 7107:   }
    #####: 7108:   return r;
    %%%%%: 7108-block 7
        -: 7109:}
        -: 7110:
        -: 7111:#define STBI__HDR_BUFLEN  1024
function _ZL18stbi__hdr_gettokenP13stbi__contextPc called 0 returned 0% blocks executed 0%
    #####: 7112:static char *stbi__hdr_gettoken(stbi__context *z, char *buffer)
        -: 7113:{
    #####: 7114:   int len=0;
    #####: 7115:   char c = '\0';
        -: 7116:
    #####: 7117:   c = (char) stbi__get8(z);
    %%%%%: 7117-block 2
call    0 never executed
        -: 7118:
    #####: 7119:   while (!stbi__at_eof(z) && c != '\n') {
    %%%%%: 7119-block 16
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 7119-block 18
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 7119-block 19
    %%%%%: 7119-block 20
    %%%%%: 7119-block 21
branch  5 never executed
branch  6 never executed (fallthrough)
    #####: 7120:      buffer[len++] = c;
    #####: 7121:      if (len == STBI__HDR_BUFLEN-1) {
    %%%%%: 7121-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 7122:         // flush to end of line
    #####: 7123:         while (!stbi__at_eof(z) && stbi__get8(z) != '\n')
    %%%%%: 7123-block 5
    %%%%%: 7123-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 7123-block 8
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 7123-block 10
    %%%%%: 7123-block 11
    %%%%%: 7123-block 12
branch  6 never executed
branch  7 never executed (fallthrough)
        -: 7124:            ;
    #####: 7125:         break;
    %%%%%: 7125-block 13
        -: 7126:      }
    #####: 7127:      c = (char) stbi__get8(z);
    %%%%%: 7127-block 14
call    0 never executed
        -: 7128:   }
        -: 7129:
    #####: 7130:   buffer[len] = 0;
    #####: 7131:   return buffer;
    %%%%%: 7131-block 22
        -: 7132:}
        -: 7133:
function _ZL17stbi__hdr_convertPfPhi called 0 returned 0% blocks executed 0%
    #####: 7134:static void stbi__hdr_convert(float *output, stbi_uc *input, int req_comp)
        -: 7135:{
    #####: 7136:   if ( input[3] != 0 ) {
    %%%%%: 7136-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 7137:      float f1;
        -: 7138:      // Exponent
    #####: 7139:      f1 = (float) ldexp(1.0f, input[3] - (int)(128 + 8));
    %%%%%: 7139-block 3
call    0 never executed
    #####: 7140:      if (req_comp <= 2)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7141:         output[0] = (input[0] + input[1] + input[2]) * f1 / 3;
    %%%%%: 7141-block 5
        -: 7142:      else {
    #####: 7143:         output[0] = input[0] * f1;
    #####: 7144:         output[1] = input[1] * f1;
    #####: 7145:         output[2] = input[2] * f1;
    %%%%%: 7145-block 6
        -: 7146:      }
    #####: 7147:      if (req_comp == 2) output[1] = 1;
    %%%%%: 7147-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7147-block 8
    #####: 7148:      if (req_comp == 4) output[3] = 1;
    %%%%%: 7148-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7148-block 10
        -: 7149:   } else {
    #####: 7150:      switch (req_comp) {
    %%%%%: 7150-block 11
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 7151:         case 4: output[3] = 1; /* fallthrough */
    %%%%%: 7151-block 12
    #####: 7152:         case 3: output[0] = output[1] = output[2] = 0;
    #####: 7153:                 break;
    %%%%%: 7153-block 13
    #####: 7154:         case 2: output[1] = 1; /* fallthrough */
    %%%%%: 7154-block 14
    #####: 7155:         case 1: output[0] = 0;
    #####: 7156:                 break;
    %%%%%: 7156-block 15
        -: 7157:      }
        -: 7158:   }
    #####: 7159:}
        -: 7160:
function _ZL14stbi__hdr_loadP13stbi__contextPiS1_S1_iP17stbi__result_info called 0 returned 0% blocks executed 0%
    #####: 7161:static float *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
        -: 7162:{
        -: 7163:   char buffer[STBI__HDR_BUFLEN];
        -: 7164:   char *token;
    #####: 7165:   int valid = 0;
        -: 7166:   int width, height;
        -: 7167:   stbi_uc *scanline;
        -: 7168:   float *hdr_data;
        -: 7169:   int len;
        -: 7170:   unsigned char count, value;
        -: 7171:   int i, j, k, c1,c2, z;
        -: 7172:   const char *headerToken;
        -: 7173:   STBI_NOTUSED(ri);
        -: 7174:
        -: 7175:   // Check identifier
    #####: 7176:   headerToken = stbi__hdr_gettoken(s,buffer);
    %%%%%: 7176-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7177:   if (strcmp(headerToken, "#?RADIANCE") != 0 && strcmp(headerToken, "#?RGBE") != 0)
    %%%%%: 7177-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7177-block 4
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 7178:      return stbi__errpf("not HDR", "Corrupt HDR image");
    %%%%%: 7178-block 5
call    0 never executed
        -: 7179:
        -: 7180:   // Parse header
        -: 7181:   for(;;) {
    #####: 7182:      token = stbi__hdr_gettoken(s,buffer);
    %%%%%: 7182-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 7182-block 13
    #####: 7183:      if (token[0] == 0) break;
    %%%%%: 7183-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7183-block 10
    #####: 7184:      if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;
    %%%%%: 7184-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7184-block 12
        -: 7185:   }
        -: 7186:
    #####: 7187:   if (!valid)    return stbi__errpf("unsupported format", "Unsupported HDR format");
    %%%%%: 7187-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7187-block 15
call    2 never executed
        -: 7188:
        -: 7189:   // Parse width and height
        -: 7190:   // can't use sscanf() if we're not using stdio!
    #####: 7191:   token = stbi__hdr_gettoken(s,buffer);
    %%%%%: 7191-block 17
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7192:   if (strncmp(token, "-Y ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");
    %%%%%: 7192-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7192-block 19
call    2 never executed
    #####: 7193:   token += 3;
    #####: 7194:   height = (int) strtol(token, &token, 10);
    %%%%%: 7194-block 21
call    0 never executed
    #####: 7195:   while (*token == ' ') ++token;
    %%%%%: 7195-block 23
    %%%%%: 7195-block 24
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 7196:   if (strncmp(token, "+X ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");
    %%%%%: 7196-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7196-block 26
call    2 never executed
    #####: 7197:   token += 3;
    #####: 7198:   width = (int) strtol(token, NULL, 10);
    %%%%%: 7198-block 28
call    0 never executed
        -: 7199:
    #####: 7200:   if (height > STBI_MAX_DIMENSIONS) return stbi__errpf("too large","Very large image (corrupt?)");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7200-block 30
call    2 never executed
    #####: 7201:   if (width > STBI_MAX_DIMENSIONS) return stbi__errpf("too large","Very large image (corrupt?)");
    %%%%%: 7201-block 32
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7201-block 33
call    2 never executed
        -: 7202:
    #####: 7203:   *x = width;
    #####: 7204:   *y = height;
        -: 7205:
    #####: 7206:   if (comp) *comp = 3;
    %%%%%: 7206-block 35
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7206-block 36
    #####: 7207:   if (req_comp == 0) req_comp = 3;
    %%%%%: 7207-block 37
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7207-block 38
        -: 7208:
    #####: 7209:   if (!stbi__mad4sizes_valid(width, height, req_comp, sizeof(float), 0))
    %%%%%: 7209-block 39
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 7210:      return stbi__errpf("too large", "HDR image is too large");
    %%%%%: 7210-block 41
call    0 never executed
        -: 7211:
        -: 7212:   // Read data
    #####: 7213:   hdr_data = (float *) stbi__malloc_mad4(width, height, req_comp, sizeof(float), 0);
    %%%%%: 7213-block 43
call    0 never executed
    #####: 7214:   if (!hdr_data)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7215:      return stbi__errpf("outofmem", "Out of memory");
    %%%%%: 7215-block 45
call    0 never executed
        -: 7216:
        -: 7217:   // Load image data
        -: 7218:   // image data is stored as some number of sca
    #####: 7219:   if ( width < 8 || width >= 32768) {
    %%%%%: 7219-block 47
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7219-block 48
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 7220:      // Read flat data
    #####: 7221:      for (j=0; j < height; ++j) {
    %%%%%: 7221-block 49
    %%%%%: 7221-block 56
    %%%%%: 7221-block 57
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 7222:         for (i=0; i < width; ++i) {
    %%%%%: 7222-block 50
    %%%%%: 7222-block 55
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 7223:            stbi_uc rgbe[4];
    #####: 7224:           main_decode_loop:
    %%%%%: 7224-block 51
    #####: 7225:            stbi__getn(s, rgbe, 4);
    %%%%%: 7225-block 52
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7226:            stbi__hdr_convert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);
    %%%%%: 7226-block 53
call    0 never executed
        -: 7227:         }
        -: 7228:      }
    #####: 7229:   } else {
    %%%%%: 7229-block 58
        -: 7230:      // Read RLE-encoded data
    #####: 7231:      scanline = NULL;
        -: 7232:
    #####: 7233:      for (j = 0; j < height; ++j) {
    %%%%%: 7233-block 59
    %%%%%: 7233-block 105
    %%%%%: 7233-block 106
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 7234:         c1 = stbi__get8(s);
    %%%%%: 7234-block 60
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7235:         c2 = stbi__get8(s);
    %%%%%: 7235-block 61
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7236:         len = stbi__get8(s);
    %%%%%: 7236-block 62
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7237:         if (c1 != 2 || c2 != 2 || (len & 0x80)) {
    %%%%%: 7237-block 63
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7237-block 64
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7237-block 65
branch  4 never executed (fallthrough)
branch  5 never executed
        -: 7238:            // not run-length encoded, so we have to actually use THIS data as a decoded
        -: 7239:            // pixel (note this can't be a valid pixel--one of RGB must be >= 128)
        -: 7240:            stbi_uc rgbe[4];
    #####: 7241:            rgbe[0] = (stbi_uc) c1;
    #####: 7242:            rgbe[1] = (stbi_uc) c2;
    #####: 7243:            rgbe[2] = (stbi_uc) len;
    #####: 7244:            rgbe[3] = (stbi_uc) stbi__get8(s);
    %%%%%: 7244-block 66
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7245:            stbi__hdr_convert(hdr_data, rgbe, req_comp);
    %%%%%: 7245-block 67
call    0 never executed
    #####: 7246:            i = 1;
    #####: 7247:            j = 0;
    #####: 7248:            STBI_FREE(scanline);
    #####: 7249:            goto main_decode_loop; // yes, this makes no sense
        -: 7250:         }
    #####: 7251:         len <<= 8;
    #####: 7252:         len |= stbi__get8(s);
    %%%%%: 7252-block 69
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7253:         if (len != width) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("invalid decoded scanline length", "corrupt HDR"); }
    %%%%%: 7253-block 70
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7253-block 71
call    2 never executed
    #####: 7254:         if (scanline == NULL) {
    %%%%%: 7254-block 73
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7255:            scanline = (stbi_uc *) stbi__malloc_mad2(width, 4, 0);
    %%%%%: 7255-block 74
call    0 never executed
    #####: 7256:            if (!scanline) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7257:               STBI_FREE(hdr_data);
    #####: 7258:               return stbi__errpf("outofmem", "Out of memory");
    %%%%%: 7258-block 76
call    0 never executed
        -: 7259:            }
        -: 7260:         }
        -: 7261:
    #####: 7262:         for (k = 0; k < 4; ++k) {
    %%%%%: 7262-block 78
    %%%%%: 7262-block 99
    %%%%%: 7262-block 100
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 7263:            int nleft;
    #####: 7264:            i = 0;
    #####: 7265:            while ((nleft = width - i) > 0) {
    %%%%%: 7265-block 79
    %%%%%: 7265-block 98
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 7266:               count = stbi__get8(s);
    %%%%%: 7266-block 80
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7267:               if (count > 128) {
    %%%%%: 7267-block 81
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 7268:                  // Run
    #####: 7269:                  value = stbi__get8(s);
    %%%%%: 7269-block 82
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7270:                  count -= 128;
    #####: 7271:                  if ((count == 0) || (count > nleft)) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("corrupt", "bad RLE data in HDR"); }
    %%%%%: 7271-block 83
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7271-block 84
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7271-block 85
call    4 never executed
    #####: 7272:                  for (z = 0; z < count; ++z)
    %%%%%: 7272-block 87
    %%%%%: 7272-block 89
branch  0 never executed
branch  1 never executed
    #####: 7273:                     scanline[i++ * 4 + k] = value;
    %%%%%: 7273-block 88
        -: 7274:               } else {
        -: 7275:                  // Dump
    #####: 7276:                  if ((count == 0) || (count > nleft)) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("corrupt", "bad RLE data in HDR"); }
    %%%%%: 7276-block 90
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7276-block 91
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7276-block 92
call    4 never executed
    #####: 7277:                  for (z = 0; z < count; ++z)
    %%%%%: 7277-block 94
    %%%%%: 7277-block 97
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 7278:                     scanline[i++ * 4 + k] = stbi__get8(s);
    %%%%%: 7278-block 95
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 7278-block 96
        -: 7279:               }
        -: 7280:            }
        -: 7281:         }
    #####: 7282:         for (i=0; i < width; ++i)
    %%%%%: 7282-block 101
    %%%%%: 7282-block 104
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 7283:            stbi__hdr_convert(hdr_data+(j*width + i)*req_comp, scanline + i*4, req_comp);
    %%%%%: 7283-block 102
call    0 never executed
        -: 7284:      }
    #####: 7285:      if (scanline)
    %%%%%: 7285-block 107
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7286:         STBI_FREE(scanline);
    %%%%%: 7286-block 108
        -: 7287:   }
        -: 7288:
    #####: 7289:   return hdr_data;
    %%%%%: 7289-block 109
        -: 7290:}
        -: 7291:
function _ZL14stbi__hdr_infoP13stbi__contextPiS1_S1_ called 0 returned 0% blocks executed 0%
    #####: 7292:static int stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp)
        -: 7293:{
        -: 7294:   char buffer[STBI__HDR_BUFLEN];
        -: 7295:   char *token;
    #####: 7296:   int valid = 0;
        -: 7297:   int dummy;
        -: 7298:
    #####: 7299:   if (!x) x = &dummy;
    %%%%%: 7299-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7299-block 3
    #####: 7300:   if (!y) y = &dummy;
    %%%%%: 7300-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7300-block 5
    #####: 7301:   if (!comp) comp = &dummy;
    %%%%%: 7301-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7301-block 7
        -: 7302:
    #####: 7303:   if (stbi__hdr_test(s) == 0) {
    %%%%%: 7303-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 7303-block 9
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 7304:       stbi__rewind( s );
    %%%%%: 7304-block 10
call    0 never executed
    #####: 7305:       return 0;
        -: 7306:   }
        -: 7307:
        -: 7308:   for(;;) {
    #####: 7309:      token = stbi__hdr_gettoken(s,buffer);
    %%%%%: 7309-block 12
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 7309-block 17
    #####: 7310:      if (token[0] == 0) break;
    %%%%%: 7310-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7310-block 14
    #####: 7311:      if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;
    %%%%%: 7311-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7311-block 16
        -: 7312:   }
        -: 7313:
    #####: 7314:   if (!valid) {
    %%%%%: 7314-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7315:       stbi__rewind( s );
    %%%%%: 7315-block 19
call    0 never executed
    #####: 7316:       return 0;
        -: 7317:   }
    #####: 7318:   token = stbi__hdr_gettoken(s,buffer);
    %%%%%: 7318-block 21
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7319:   if (strncmp(token, "-Y ", 3)) {
    %%%%%: 7319-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7320:       stbi__rewind( s );
    %%%%%: 7320-block 23
call    0 never executed
    #####: 7321:       return 0;
        -: 7322:   }
    #####: 7323:   token += 3;
    #####: 7324:   *y = (int) strtol(token, &token, 10);
    %%%%%: 7324-block 25
call    0 never executed
    #####: 7325:   while (*token == ' ') ++token;
    %%%%%: 7325-block 27
    %%%%%: 7325-block 28
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 7326:   if (strncmp(token, "+X ", 3)) {
    %%%%%: 7326-block 29
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7327:       stbi__rewind( s );
    %%%%%: 7327-block 30
call    0 never executed
    #####: 7328:       return 0;
        -: 7329:   }
    #####: 7330:   token += 3;
    #####: 7331:   *x = (int) strtol(token, NULL, 10);
    %%%%%: 7331-block 32
call    0 never executed
    #####: 7332:   *comp = 3;
    #####: 7333:   return 1;
        -: 7334:}
        -: 7335:#endif // STBI_NO_HDR
        -: 7336:
        -: 7337:#ifndef STBI_NO_BMP
function _ZL14stbi__bmp_infoP13stbi__contextPiS1_S1_ called 0 returned 0% blocks executed 0%
    #####: 7338:static int stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp)
        -: 7339:{
        -: 7340:   void *p;
        -: 7341:   stbi__bmp_data info;
        -: 7342:
    #####: 7343:   info.all_a = 255;
    #####: 7344:   p = stbi__bmp_parse_header(s, &info);
    %%%%%: 7344-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7345:   if (p == NULL) {
    %%%%%: 7345-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7346:      stbi__rewind( s );
    %%%%%: 7346-block 4
call    0 never executed
    #####: 7347:      return 0;
        -: 7348:   }
    #####: 7349:   if (x) *x = s->img_x;
    %%%%%: 7349-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7349-block 7
    #####: 7350:   if (y) *y = s->img_y;
    %%%%%: 7350-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7350-block 9
    #####: 7351:   if (comp) {
    %%%%%: 7351-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7352:      if (info.bpp == 24 && info.ma == 0xff000000)
    %%%%%: 7352-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7352-block 12
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 7353:         *comp = 3;
    %%%%%: 7353-block 13
        -: 7354:      else
    #####: 7355:         *comp = info.ma ? 4 : 3;
    %%%%%: 7355-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7355-block 15
    %%%%%: 7355-block 16
    %%%%%: 7355-block 17
        -: 7356:   }
    #####: 7357:   return 1;
    %%%%%: 7357-block 19
        -: 7358:}
        -: 7359:#endif
        -: 7360:
        -: 7361:#ifndef STBI_NO_PSD
function _ZL14stbi__psd_infoP13stbi__contextPiS1_S1_ called 0 returned 0% blocks executed 0%
    #####: 7362:static int stbi__psd_info(stbi__context *s, int *x, int *y, int *comp)
        -: 7363:{
        -: 7364:   int channelCount, dummy, depth;
    #####: 7365:   if (!x) x = &dummy;
    %%%%%: 7365-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7365-block 3
    #####: 7366:   if (!y) y = &dummy;
    %%%%%: 7366-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7366-block 5
    #####: 7367:   if (!comp) comp = &dummy;
    %%%%%: 7367-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7367-block 7
    #####: 7368:   if (stbi__get32be(s) != 0x38425053) {
    %%%%%: 7368-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 7368-block 9
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 7369:       stbi__rewind( s );
    %%%%%: 7369-block 10
call    0 never executed
    #####: 7370:       return 0;
        -: 7371:   }
    #####: 7372:   if (stbi__get16be(s) != 1) {
    %%%%%: 7372-block 12
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 7372-block 13
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 7373:       stbi__rewind( s );
    %%%%%: 7373-block 14
call    0 never executed
    #####: 7374:       return 0;
        -: 7375:   }
    #####: 7376:   stbi__skip(s, 6);
    %%%%%: 7376-block 16
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7377:   channelCount = stbi__get16be(s);
    %%%%%: 7377-block 17
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7378:   if (channelCount < 0 || channelCount > 16) {
    %%%%%: 7378-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7378-block 19
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 7379:       stbi__rewind( s );
    %%%%%: 7379-block 20
call    0 never executed
    #####: 7380:       return 0;
        -: 7381:   }
    #####: 7382:   *y = stbi__get32be(s);
    %%%%%: 7382-block 22
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7383:   *x = stbi__get32be(s);
    %%%%%: 7383-block 23
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7384:   depth = stbi__get16be(s);
    %%%%%: 7384-block 24
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7385:   if (depth != 8 && depth != 16) {
    %%%%%: 7385-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7385-block 26
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 7386:       stbi__rewind( s );
    %%%%%: 7386-block 27
call    0 never executed
    #####: 7387:       return 0;
        -: 7388:   }
    #####: 7389:   if (stbi__get16be(s) != 3) {
    %%%%%: 7389-block 29
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 7389-block 30
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 7390:       stbi__rewind( s );
    %%%%%: 7390-block 31
call    0 never executed
    #####: 7391:       return 0;
        -: 7392:   }
    #####: 7393:   *comp = 4;
    #####: 7394:   return 1;
    %%%%%: 7394-block 33
        -: 7395:}
        -: 7396:
function _ZL14stbi__psd_is16P13stbi__context called 0 returned 0% blocks executed 0%
    #####: 7397:static int stbi__psd_is16(stbi__context *s)
        -: 7398:{
        -: 7399:   int channelCount, depth;
    #####: 7400:   if (stbi__get32be(s) != 0x38425053) {
    %%%%%: 7400-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 7401:       stbi__rewind( s );
    %%%%%: 7401-block 4
call    0 never executed
    #####: 7402:       return 0;
        -: 7403:   }
    #####: 7404:   if (stbi__get16be(s) != 1) {
    %%%%%: 7404-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 7405:       stbi__rewind( s );
    %%%%%: 7405-block 8
call    0 never executed
    #####: 7406:       return 0;
        -: 7407:   }
    #####: 7408:   stbi__skip(s, 6);
    %%%%%: 7408-block 10
call    0 never executed
    #####: 7409:   channelCount = stbi__get16be(s);
call    0 never executed
    #####: 7410:   if (channelCount < 0 || channelCount > 16) {
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7410-block 13
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 7411:       stbi__rewind( s );
    %%%%%: 7411-block 14
call    0 never executed
    #####: 7412:       return 0;
        -: 7413:   }
        -: 7414:   STBI_NOTUSED(stbi__get32be(s));
        -: 7415:   STBI_NOTUSED(stbi__get32be(s));
    #####: 7416:   depth = stbi__get16be(s);
    %%%%%: 7416-block 16
call    0 never executed
    #####: 7417:   if (depth != 16) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7418:       stbi__rewind( s );
    %%%%%: 7418-block 18
call    0 never executed
    #####: 7419:       return 0;
        -: 7420:   }
    #####: 7421:   return 1;
    %%%%%: 7421-block 20
        -: 7422:}
        -: 7423:#endif
        -: 7424:
        -: 7425:#ifndef STBI_NO_PIC
function _ZL14stbi__pic_infoP13stbi__contextPiS1_S1_ called 0 returned 0% blocks executed 0%
    #####: 7426:static int stbi__pic_info(stbi__context *s, int *x, int *y, int *comp)
        -: 7427:{
    #####: 7428:   int act_comp=0,num_packets=0,chained,dummy;
        -: 7429:   stbi__pic_packet packets[10];
        -: 7430:
    #####: 7431:   if (!x) x = &dummy;
    %%%%%: 7431-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7431-block 3
    #####: 7432:   if (!y) y = &dummy;
    %%%%%: 7432-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7432-block 5
    #####: 7433:   if (!comp) comp = &dummy;
    %%%%%: 7433-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7433-block 7
        -: 7434:
    #####: 7435:   if (!stbi__pic_is4(s,"\x53\x80\xF6\x34")) {
    %%%%%: 7435-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 7435-block 9
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 7436:      stbi__rewind(s);
    %%%%%: 7436-block 10
call    0 never executed
    #####: 7437:      return 0;
        -: 7438:   }
        -: 7439:
    #####: 7440:   stbi__skip(s, 88);
    %%%%%: 7440-block 12
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 7441:
    #####: 7442:   *x = stbi__get16be(s);
    %%%%%: 7442-block 13
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7443:   *y = stbi__get16be(s);
    %%%%%: 7443-block 14
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7444:   if (stbi__at_eof(s)) {
    %%%%%: 7444-block 15
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 7444-block 16
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 7445:      stbi__rewind( s);
    %%%%%: 7445-block 17
call    0 never executed
    #####: 7446:      return 0;
        -: 7447:   }
    #####: 7448:   if ( (*x) != 0 && (1 << 28) / (*x) < (*y)) {
    %%%%%: 7448-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7448-block 20
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 7449:      stbi__rewind( s );
    %%%%%: 7449-block 21
call    0 never executed
    #####: 7450:      return 0;
        -: 7451:   }
        -: 7452:
    #####: 7453:   stbi__skip(s, 8);
    %%%%%: 7453-block 23
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 7454:
        -: 7455:   do {
        -: 7456:      stbi__pic_packet *packet;
        -: 7457:
    #####: 7458:      if (num_packets==sizeof(packets)/sizeof(packets[0]))
    %%%%%: 7458-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7459:         return 0;
    %%%%%: 7459-block 25
        -: 7460:
    #####: 7461:      packet = &packets[num_packets++];
    #####: 7462:      chained = stbi__get8(s);
    %%%%%: 7462-block 26
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7463:      packet->size    = stbi__get8(s);
    %%%%%: 7463-block 27
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7464:      packet->type    = stbi__get8(s);
    %%%%%: 7464-block 28
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7465:      packet->channel = stbi__get8(s);
    %%%%%: 7465-block 29
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7466:      act_comp |= packet->channel;
        -: 7467:
    #####: 7468:      if (stbi__at_eof(s)) {
    %%%%%: 7468-block 30
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 7468-block 31
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 7469:          stbi__rewind( s );
    %%%%%: 7469-block 32
call    0 never executed
    #####: 7470:          return 0;
        -: 7471:      }
    #####: 7472:      if (packet->size != 8) {
    %%%%%: 7472-block 34
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7473:          stbi__rewind( s );
    %%%%%: 7473-block 35
call    0 never executed
    #####: 7474:          return 0;
        -: 7475:      }
    #####: 7476:   } while (chained);
    %%%%%: 7476-block 37
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 7477:
    #####: 7478:   *comp = (act_comp & 0x10 ? 4 : 3);
    %%%%%: 7478-block 38
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7478-block 39
    %%%%%: 7478-block 40
        -: 7479:
    #####: 7480:   return 1;
    %%%%%: 7480-block 41
        -: 7481:}
        -: 7482:#endif
        -: 7483:
        -: 7484:// *************************************************************************************************
        -: 7485:// Portable Gray Map and Portable Pixel Map loader
        -: 7486:// by Ken Miller
        -: 7487://
        -: 7488:// PGM: http://netpbm.sourceforge.net/doc/pgm.html
        -: 7489:// PPM: http://netpbm.sourceforge.net/doc/ppm.html
        -: 7490://
        -: 7491:// Known limitations:
        -: 7492://    Does not support comments in the header section
        -: 7493://    Does not support ASCII image data (formats P2 and P3)
        -: 7494:
        -: 7495:#ifndef STBI_NO_PNM
        -: 7496:
function _ZL14stbi__pnm_testP13stbi__context called 0 returned 0% blocks executed 0%
    #####: 7497:static int      stbi__pnm_test(stbi__context *s)
        -: 7498:{
        -: 7499:   char p, t;
    #####: 7500:   p = (char) stbi__get8(s);
    %%%%%: 7500-block 2
call    0 never executed
    #####: 7501:   t = (char) stbi__get8(s);
call    0 never executed
    #####: 7502:   if (p != 'P' || (t != '5' && t != '6')) {
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7502-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7502-block 6
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 7503:       stbi__rewind( s );
    %%%%%: 7503-block 7
call    0 never executed
    #####: 7504:       return 0;
        -: 7505:   }
    #####: 7506:   return 1;
    %%%%%: 7506-block 9
        -: 7507:}
        -: 7508:
function _ZL14stbi__pnm_loadP13stbi__contextPiS1_S1_iP17stbi__result_info called 0 returned 0% blocks executed 0%
    #####: 7509:static void *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
        -: 7510:{
        -: 7511:   stbi_uc *out;
        -: 7512:   STBI_NOTUSED(ri);
        -: 7513:
    #####: 7514:   ri->bits_per_channel = stbi__pnm_info(s, (int *)&s->img_x, (int *)&s->img_y, (int *)&s->img_n);
    %%%%%: 7514-block 2
call    0 never executed
    #####: 7515:   if (ri->bits_per_channel == 0)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7516:      return 0;
    %%%%%: 7516-block 4
        -: 7517:
    #####: 7518:   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
    %%%%%: 7518-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7518-block 6
call    2 never executed
    #####: 7519:   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
    %%%%%: 7519-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7519-block 9
call    2 never executed
        -: 7520:
    #####: 7521:   *x = s->img_x;
    #####: 7522:   *y = s->img_y;
    #####: 7523:   if (comp) *comp = s->img_n;
    %%%%%: 7523-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7523-block 12
        -: 7524:
    #####: 7525:   if (!stbi__mad4sizes_valid(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0))
    %%%%%: 7525-block 13
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 7526:      return stbi__errpuc("too large", "PNM too large");
    %%%%%: 7526-block 15
call    0 never executed
        -: 7527:
    #####: 7528:   out = (stbi_uc *) stbi__malloc_mad4(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0);
    %%%%%: 7528-block 17
call    0 never executed
    #####: 7529:   if (!out) return stbi__errpuc("outofmem", "Out of memory");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7529-block 19
call    2 never executed
    #####: 7530:   if (!stbi__getn(s, out, s->img_n * s->img_x * s->img_y * (ri->bits_per_channel / 8))) {
    %%%%%: 7530-block 21
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 7531:      STBI_FREE(out);
    #####: 7532:      return stbi__errpuc("bad PNM", "PNM file truncated");
    %%%%%: 7532-block 23
call    0 never executed
        -: 7533:   }
        -: 7534:
    #####: 7535:   if (req_comp && req_comp != s->img_n) {
    %%%%%: 7535-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7535-block 26
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 7536:      if (ri->bits_per_channel == 16) {
    %%%%%: 7536-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7537:         out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, s->img_n, req_comp, s->img_x, s->img_y);
    %%%%%: 7537-block 28
call    0 never executed
        -: 7538:      } else {
    #####: 7539:         out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);
    %%%%%: 7539-block 29
call    0 never executed
        -: 7540:      }
    #####: 7541:      if (out == NULL) return out; // stbi__convert_format frees input on failure
    %%%%%: 7541-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7541-block 31
        -: 7542:   }
    #####: 7543:   return out;
    %%%%%: 7543-block 32
        -: 7544:}
        -: 7545:
function _ZL17stbi__pnm_isspacec called 0 returned 0% blocks executed 0%
    #####: 7546:static int      stbi__pnm_isspace(char c)
        -: 7547:{
    #####: 7548:   return c == ' ' || c == '\t' || c == '\n' || c == '\v' || c == '\f' || c == '\r';
    %%%%%: 7548-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7548-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7548-block 4
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 7548-block 5
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 7548-block 6
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%: 7548-block 7
branch 10 never executed (fallthrough)
branch 11 never executed
    %%%%%: 7548-block 8
    %%%%%: 7548-block 9
    %%%%%: 7548-block 10
        -: 7549:}
        -: 7550:
function _ZL25stbi__pnm_skip_whitespaceP13stbi__contextPc called 0 returned 0% blocks executed 0%
    #####: 7551:static void     stbi__pnm_skip_whitespace(stbi__context *s, char *c)
        -: 7552:{
        -: 7553:   for (;;) {
    #####: 7554:      while (!stbi__at_eof(s) && stbi__pnm_isspace(*c))
    %%%%%: 7554-block 2
    %%%%%: 7554-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 7554-block 7
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 7554-block 9
    %%%%%: 7554-block 10
    %%%%%: 7554-block 11
branch  6 never executed
branch  7 never executed (fallthrough)
    %%%%%: 7554-block 29
    #####: 7555:         *c = (char) stbi__get8(s);
    %%%%%: 7555-block 3
call    0 never executed
        -: 7556:
    #####: 7557:      if (stbi__at_eof(s) || *c != '#')
    %%%%%: 7557-block 12
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 7557-block 14
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 7557-block 15
    %%%%%: 7557-block 16
    %%%%%: 7557-block 17
branch  5 never executed (fallthrough)
branch  6 never executed
    #####: 7558:         break;
    %%%%%: 7558-block 18
        -: 7559:
    #####: 7560:      while (!stbi__at_eof(s) && *c != '\n' && *c != '\r' )
    %%%%%: 7560-block 19
    %%%%%: 7560-block 22
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 7560-block 24
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 7560-block 25
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 7560-block 26
    %%%%%: 7560-block 27
    %%%%%: 7560-block 28
branch  7 never executed
branch  8 never executed (fallthrough)
    #####: 7561:         *c = (char) stbi__get8(s);
    %%%%%: 7561-block 20
call    0 never executed
        -: 7562:   }
    #####: 7563:}
        -: 7564:
function _ZL17stbi__pnm_isdigitc called 0 returned 0% blocks executed 0%
    #####: 7565:static int      stbi__pnm_isdigit(char c)
        -: 7566:{
    #####: 7567:   return c >= '0' && c <= '9';
    %%%%%: 7567-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7567-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7567-block 4
    %%%%%: 7567-block 5
    %%%%%: 7567-block 6
        -: 7568:}
        -: 7569:
function _ZL20stbi__pnm_getintegerP13stbi__contextPc called 0 returned 0% blocks executed 0%
    #####: 7570:static int      stbi__pnm_getinteger(stbi__context *s, char *c)
        -: 7571:{
    #####: 7572:   int value = 0;
        -: 7573:
    #####: 7574:   while (!stbi__at_eof(s) && stbi__pnm_isdigit(*c)) {
    %%%%%: 7574-block 2
    %%%%%: 7574-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 7574-block 10
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 7574-block 12
    %%%%%: 7574-block 13
    %%%%%: 7574-block 14
branch  6 never executed
branch  7 never executed (fallthrough)
    #####: 7575:      value = value*10 + (*c - '0');
    #####: 7576:      *c = (char) stbi__get8(s);
    %%%%%: 7576-block 3
call    0 never executed
    #####: 7577:      if((value > 214748364) || (value == 214748364 && *c > '7'))
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7577-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7577-block 6
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 7578:          return stbi__err("integer parse overflow", "Parsing an integer in the PPM header overflowed a 32-bit int");
    %%%%%: 7578-block 7
call    0 never executed
        -: 7579:   }
        -: 7580:
    #####: 7581:   return value;
    %%%%%: 7581-block 15
        -: 7582:}
        -: 7583:
function _ZL14stbi__pnm_infoP13stbi__contextPiS1_S1_ called 0 returned 0% blocks executed 0%
    #####: 7584:static int      stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp)
        -: 7585:{
        -: 7586:   int maxv, dummy;
        -: 7587:   char c, p, t;
        -: 7588:
    #####: 7589:   if (!x) x = &dummy;
    %%%%%: 7589-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7589-block 3
    #####: 7590:   if (!y) y = &dummy;
    %%%%%: 7590-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7590-block 5
    #####: 7591:   if (!comp) comp = &dummy;
    %%%%%: 7591-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7591-block 7
        -: 7592:
    #####: 7593:   stbi__rewind(s);
    %%%%%: 7593-block 8
call    0 never executed
        -: 7594:
        -: 7595:   // Get identifier
    #####: 7596:   p = (char) stbi__get8(s);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7597:   t = (char) stbi__get8(s);
    %%%%%: 7597-block 10
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7598:   if (p != 'P' || (t != '5' && t != '6')) {
    %%%%%: 7598-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7598-block 12
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7598-block 13
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 7599:       stbi__rewind(s);
    %%%%%: 7599-block 14
call    0 never executed
    #####: 7600:       return 0;
        -: 7601:   }
        -: 7602:
    #####: 7603:   *comp = (t == '6') ? 3 : 1;  // '5' is 1-component .pgm; '6' is 3-component .ppm
    %%%%%: 7603-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7603-block 17
    %%%%%: 7603-block 18
        -: 7604:
    #####: 7605:   c = (char) stbi__get8(s);
    %%%%%: 7605-block 19
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7606:   stbi__pnm_skip_whitespace(s, &c);
    %%%%%: 7606-block 20
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 7607:
    #####: 7608:   *x = stbi__pnm_getinteger(s, &c); // read width
    %%%%%: 7608-block 21
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7609:   if(*x == 0)
    %%%%%: 7609-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7610:       return stbi__err("invalid width", "PPM image header had zero or overflowing width");
    %%%%%: 7610-block 23
call    0 never executed
    #####: 7611:   stbi__pnm_skip_whitespace(s, &c);
    %%%%%: 7611-block 24
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 7612:
    #####: 7613:   *y = stbi__pnm_getinteger(s, &c); // read height
    %%%%%: 7613-block 25
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7614:   if (*y == 0)
    %%%%%: 7614-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7615:       return stbi__err("invalid width", "PPM image header had zero or overflowing width");
    %%%%%: 7615-block 27
call    0 never executed
    #####: 7616:   stbi__pnm_skip_whitespace(s, &c);
    %%%%%: 7616-block 28
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 7617:
    #####: 7618:   maxv = stbi__pnm_getinteger(s, &c);  // read max value
    %%%%%: 7618-block 29
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7619:   if (maxv > 65535)
    %%%%%: 7619-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7620:      return stbi__err("max value > 65535", "PPM image supports only 8-bit and 16-bit images");
    %%%%%: 7620-block 31
call    0 never executed
    #####: 7621:   else if (maxv > 255)
    %%%%%: 7621-block 32
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7622:      return 16;
    %%%%%: 7622-block 33
        -: 7623:   else
    #####: 7624:      return 8;
    %%%%%: 7624-block 34
        -: 7625:}
        -: 7626:
function _ZL14stbi__pnm_is16P13stbi__context called 0 returned 0% blocks executed 0%
    #####: 7627:static int stbi__pnm_is16(stbi__context *s)
        -: 7628:{
    #####: 7629:   if (stbi__pnm_info(s, NULL, NULL, NULL) == 16)
    %%%%%: 7629-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 7630:	   return 1;
    %%%%%: 7630-block 4
    #####: 7631:   return 0;
    %%%%%: 7631-block 5
        -: 7632:}
        -: 7633:#endif
        -: 7634:
function _ZL15stbi__info_mainP13stbi__contextPiS1_S1_ called 0 returned 0% blocks executed 0%
    #####: 7635:static int stbi__info_main(stbi__context *s, int *x, int *y, int *comp)
        -: 7636:{
        -: 7637:   #ifndef STBI_NO_JPEG
    #####: 7638:   if (stbi__jpeg_info(s, x, y, comp)) return 1;
    %%%%%: 7638-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 7638-block 4
        -: 7639:   #endif
        -: 7640:
        -: 7641:   #ifndef STBI_NO_PNG
    #####: 7642:   if (stbi__png_info(s, x, y, comp))  return 1;
    %%%%%: 7642-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 7642-block 7
        -: 7643:   #endif
        -: 7644:
        -: 7645:   #ifndef STBI_NO_GIF
    #####: 7646:   if (stbi__gif_info(s, x, y, comp))  return 1;
    %%%%%: 7646-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 7646-block 10
        -: 7647:   #endif
        -: 7648:
        -: 7649:   #ifndef STBI_NO_BMP
    #####: 7650:   if (stbi__bmp_info(s, x, y, comp))  return 1;
    %%%%%: 7650-block 11
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 7650-block 13
        -: 7651:   #endif
        -: 7652:
        -: 7653:   #ifndef STBI_NO_PSD
    #####: 7654:   if (stbi__psd_info(s, x, y, comp))  return 1;
    %%%%%: 7654-block 14
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 7654-block 16
        -: 7655:   #endif
        -: 7656:
        -: 7657:   #ifndef STBI_NO_PIC
    #####: 7658:   if (stbi__pic_info(s, x, y, comp))  return 1;
    %%%%%: 7658-block 17
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 7658-block 19
        -: 7659:   #endif
        -: 7660:
        -: 7661:   #ifndef STBI_NO_PNM
    #####: 7662:   if (stbi__pnm_info(s, x, y, comp))  return 1;
    %%%%%: 7662-block 20
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 7662-block 22
        -: 7663:   #endif
        -: 7664:
        -: 7665:   #ifndef STBI_NO_HDR
    #####: 7666:   if (stbi__hdr_info(s, x, y, comp))  return 1;
    %%%%%: 7666-block 23
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 7666-block 25
        -: 7667:   #endif
        -: 7668:
        -: 7669:   // test tga last because it's a crappy test!
        -: 7670:   #ifndef STBI_NO_TGA
    #####: 7671:   if (stbi__tga_info(s, x, y, comp))
    %%%%%: 7671-block 26
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 7672:       return 1;
    %%%%%: 7672-block 28
        -: 7673:   #endif
    #####: 7674:   return stbi__err("unknown image type", "Image not of any known type, or corrupt");
    %%%%%: 7674-block 29
call    0 never executed
        -: 7675:}
        -: 7676:
function _ZL16stbi__is_16_mainP13stbi__context called 0 returned 0% blocks executed 0%
    #####: 7677:static int stbi__is_16_main(stbi__context *s)
        -: 7678:{
        -: 7679:   #ifndef STBI_NO_PNG
    #####: 7680:   if (stbi__png_is16(s))  return 1;
    %%%%%: 7680-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 7680-block 4
        -: 7681:   #endif
        -: 7682:
        -: 7683:   #ifndef STBI_NO_PSD
    #####: 7684:   if (stbi__psd_is16(s))  return 1;
    %%%%%: 7684-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 7684-block 7
        -: 7685:   #endif
        -: 7686:
        -: 7687:   #ifndef STBI_NO_PNM
    #####: 7688:   if (stbi__pnm_is16(s))  return 1;
    %%%%%: 7688-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 7688-block 10
        -: 7689:   #endif
    #####: 7690:   return 0;
    %%%%%: 7690-block 11
        -: 7691:}
        -: 7692:
        -: 7693:#ifndef STBI_NO_STDIO
function stbi_info called 0 returned 0% blocks executed 0%
    #####: 7694:STBIDEF int stbi_info(char const *filename, int *x, int *y, int *comp)
        -: 7695:{
    #####: 7696:    FILE *f = stbi__fopen(filename, "rb");
    %%%%%: 7696-block 2
call    0 never executed
        -: 7697:    int result;
    #####: 7698:    if (!f) return stbi__err("can't fopen", "Unable to open file");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7698-block 4
call    2 never executed
    #####: 7699:    result = stbi_info_from_file(f, x, y, comp);
    %%%%%: 7699-block 5
call    0 never executed
    #####: 7700:    fclose(f);
call    0 never executed
    #####: 7701:    return result;
        -: 7702:}
        -: 7703:
function stbi_info_from_file called 0 returned 0% blocks executed 0%
    #####: 7704:STBIDEF int stbi_info_from_file(FILE *f, int *x, int *y, int *comp)
        -: 7705:{
        -: 7706:   int r;
        -: 7707:   stbi__context s;
    #####: 7708:   long pos = ftell(f);
    %%%%%: 7708-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7709:   stbi__start_file(&s, f);
    %%%%%: 7709-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7710:   r = stbi__info_main(&s,x,y,comp);
    %%%%%: 7710-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7711:   fseek(f,pos,SEEK_SET);
    %%%%%: 7711-block 5
call    0 never executed
    #####: 7712:   return r;
    %%%%%: 7712-block 7
        -: 7713:}
        -: 7714:
function stbi_is_16_bit called 0 returned 0% blocks executed 0%
    #####: 7715:STBIDEF int stbi_is_16_bit(char const *filename)
        -: 7716:{
    #####: 7717:    FILE *f = stbi__fopen(filename, "rb");
    %%%%%: 7717-block 2
call    0 never executed
        -: 7718:    int result;
    #####: 7719:    if (!f) return stbi__err("can't fopen", "Unable to open file");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7719-block 4
call    2 never executed
    #####: 7720:    result = stbi_is_16_bit_from_file(f);
    %%%%%: 7720-block 5
call    0 never executed
    #####: 7721:    fclose(f);
call    0 never executed
    #####: 7722:    return result;
        -: 7723:}
        -: 7724:
function stbi_is_16_bit_from_file called 0 returned 0% blocks executed 0%
    #####: 7725:STBIDEF int stbi_is_16_bit_from_file(FILE *f)
        -: 7726:{
        -: 7727:   int r;
        -: 7728:   stbi__context s;
    #####: 7729:   long pos = ftell(f);
    %%%%%: 7729-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7730:   stbi__start_file(&s, f);
    %%%%%: 7730-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7731:   r = stbi__is_16_main(&s);
    %%%%%: 7731-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7732:   fseek(f,pos,SEEK_SET);
    %%%%%: 7732-block 5
call    0 never executed
    #####: 7733:   return r;
    %%%%%: 7733-block 7
        -: 7734:}
        -: 7735:#endif // !STBI_NO_STDIO
        -: 7736:
function stbi_info_from_memory called 0 returned 0% blocks executed 0%
    #####: 7737:STBIDEF int stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp)
        -: 7738:{
        -: 7739:   stbi__context s;
    #####: 7740:   stbi__start_mem(&s,buffer,len);
    %%%%%: 7740-block 2
call    0 never executed
    #####: 7741:   return stbi__info_main(&s,x,y,comp);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 7741-block 4
    %%%%%: 7741-block 6
        -: 7742:}
        -: 7743:
function stbi_info_from_callbacks called 0 returned 0% blocks executed 0%
    #####: 7744:STBIDEF int stbi_info_from_callbacks(stbi_io_callbacks const *c, void *user, int *x, int *y, int *comp)
        -: 7745:{
        -: 7746:   stbi__context s;
    #####: 7747:   stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);
    %%%%%: 7747-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7748:   return stbi__info_main(&s,x,y,comp);
    %%%%%: 7748-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 7748-block 4
    %%%%%: 7748-block 6
        -: 7749:}
        -: 7750:
function stbi_is_16_bit_from_memory called 0 returned 0% blocks executed 0%
    #####: 7751:STBIDEF int stbi_is_16_bit_from_memory(stbi_uc const *buffer, int len)
        -: 7752:{
        -: 7753:   stbi__context s;
    #####: 7754:   stbi__start_mem(&s,buffer,len);
    %%%%%: 7754-block 2
call    0 never executed
    #####: 7755:   return stbi__is_16_main(&s);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 7755-block 4
    %%%%%: 7755-block 6
        -: 7756:}
        -: 7757:
function stbi_is_16_bit_from_callbacks called 0 returned 0% blocks executed 0%
    #####: 7758:STBIDEF int stbi_is_16_bit_from_callbacks(stbi_io_callbacks const *c, void *user)
        -: 7759:{
        -: 7760:   stbi__context s;
    #####: 7761:   stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);
    %%%%%: 7761-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7762:   return stbi__is_16_main(&s);
    %%%%%: 7762-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 7762-block 4
    %%%%%: 7762-block 6
        -: 7763:}
        -: 7764:
        -: 7765:#endif // STB_IMAGE_IMPLEMENTATION
        -: 7766:
        -: 7767:/*
        -: 7768:   revision history:
        -: 7769:      2.20  (2019-02-07) support utf8 filenames in Windows; fix warnings and platform ifdefs
        -: 7770:      2.19  (2018-02-11) fix warning
        -: 7771:      2.18  (2018-01-30) fix warnings
        -: 7772:      2.17  (2018-01-29) change sbti__shiftsigned to avoid clang -O2 bug
        -: 7773:                         1-bit BMP
        -: 7774:                         *_is_16_bit api
        -: 7775:                         avoid warnings
        -: 7776:      2.16  (2017-07-23) all functions have 16-bit variants;
        -: 7777:                         STBI_NO_STDIO works again;
        -: 7778:                         compilation fixes;
        -: 7779:                         fix rounding in unpremultiply;
        -: 7780:                         optimize vertical flip;
        -: 7781:                         disable raw_len validation;
        -: 7782:                         documentation fixes
        -: 7783:      2.15  (2017-03-18) fix png-1,2,4 bug; now all Imagenet JPGs decode;
        -: 7784:                         warning fixes; disable run-time SSE detection on gcc;
        -: 7785:                         uniform handling of optional "return" values;
        -: 7786:                         thread-safe initialization of zlib tables
        -: 7787:      2.14  (2017-03-03) remove deprecated STBI_JPEG_OLD; fixes for Imagenet JPGs
        -: 7788:      2.13  (2016-11-29) add 16-bit API, only supported for PNG right now
        -: 7789:      2.12  (2016-04-02) fix typo in 2.11 PSD fix that caused crashes
        -: 7790:      2.11  (2016-04-02) allocate large structures on the stack
        -: 7791:                         remove white matting for transparent PSD
        -: 7792:                         fix reported channel count for PNG & BMP
        -: 7793:                         re-enable SSE2 in non-gcc 64-bit
        -: 7794:                         support RGB-formatted JPEG
        -: 7795:                         read 16-bit PNGs (only as 8-bit)
        -: 7796:      2.10  (2016-01-22) avoid warning introduced in 2.09 by STBI_REALLOC_SIZED
        -: 7797:      2.09  (2016-01-16) allow comments in PNM files
        -: 7798:                         16-bit-per-pixel TGA (not bit-per-component)
        -: 7799:                         info() for TGA could break due to .hdr handling
        -: 7800:                         info() for BMP to shares code instead of sloppy parse
        -: 7801:                         can use STBI_REALLOC_SIZED if allocator doesn't support realloc
        -: 7802:                         code cleanup
        -: 7803:      2.08  (2015-09-13) fix to 2.07 cleanup, reading RGB PSD as RGBA
        -: 7804:      2.07  (2015-09-13) fix compiler warnings
        -: 7805:                         partial animated GIF support
        -: 7806:                         limited 16-bpc PSD support
        -: 7807:                         #ifdef unused functions
        -: 7808:                         bug with < 92 byte PIC,PNM,HDR,TGA
        -: 7809:      2.06  (2015-04-19) fix bug where PSD returns wrong '*comp' value
        -: 7810:      2.05  (2015-04-19) fix bug in progressive JPEG handling, fix warning
        -: 7811:      2.04  (2015-04-15) try to re-enable SIMD on MinGW 64-bit
        -: 7812:      2.03  (2015-04-12) extra corruption checking (mmozeiko)
        -: 7813:                         stbi_set_flip_vertically_on_load (nguillemot)
        -: 7814:                         fix NEON support; fix mingw support
        -: 7815:      2.02  (2015-01-19) fix incorrect assert, fix warning
        -: 7816:      2.01  (2015-01-17) fix various warnings; suppress SIMD on gcc 32-bit without -msse2
        -: 7817:      2.00b (2014-12-25) fix STBI_MALLOC in progressive JPEG
        -: 7818:      2.00  (2014-12-25) optimize JPG, including x86 SSE2 & NEON SIMD (ryg)
        -: 7819:                         progressive JPEG (stb)
        -: 7820:                         PGM/PPM support (Ken Miller)
        -: 7821:                         STBI_MALLOC,STBI_REALLOC,STBI_FREE
        -: 7822:                         GIF bugfix -- seemingly never worked
        -: 7823:                         STBI_NO_*, STBI_ONLY_*
        -: 7824:      1.48  (2014-12-14) fix incorrectly-named assert()
        -: 7825:      1.47  (2014-12-14) 1/2/4-bit PNG support, both direct and paletted (Omar Cornut & stb)
        -: 7826:                         optimize PNG (ryg)
        -: 7827:                         fix bug in interlaced PNG with user-specified channel count (stb)
        -: 7828:      1.46  (2014-08-26)
        -: 7829:              fix broken tRNS chunk (colorkey-style transparency) in non-paletted PNG
        -: 7830:      1.45  (2014-08-16)
        -: 7831:              fix MSVC-ARM internal compiler error by wrapping malloc
        -: 7832:      1.44  (2014-08-07)
        -: 7833:              various warning fixes from Ronny Chevalier
        -: 7834:      1.43  (2014-07-15)
        -: 7835:              fix MSVC-only compiler problem in code changed in 1.42
        -: 7836:      1.42  (2014-07-09)
        -: 7837:              don't define _CRT_SECURE_NO_WARNINGS (affects user code)
        -: 7838:              fixes to stbi__cleanup_jpeg path
        -: 7839:              added STBI_ASSERT to avoid requiring assert.h
        -: 7840:      1.41  (2014-06-25)
        -: 7841:              fix search&replace from 1.36 that messed up comments/error messages
        -: 7842:      1.40  (2014-06-22)
        -: 7843:              fix gcc struct-initialization warning
        -: 7844:      1.39  (2014-06-15)
        -: 7845:              fix to TGA optimization when req_comp != number of components in TGA;
        -: 7846:              fix to GIF loading because BMP wasn't rewinding (whoops, no GIFs in my test suite)
        -: 7847:              add support for BMP version 5 (more ignored fields)
        -: 7848:      1.38  (2014-06-06)
        -: 7849:              suppress MSVC warnings on integer casts truncating values
        -: 7850:              fix accidental rename of 'skip' field of I/O
        -: 7851:      1.37  (2014-06-04)
        -: 7852:              remove duplicate typedef
        -: 7853:      1.36  (2014-06-03)
        -: 7854:              convert to header file single-file library
        -: 7855:              if de-iphone isn't set, load iphone images color-swapped instead of returning NULL
        -: 7856:      1.35  (2014-05-27)
        -: 7857:              various warnings
        -: 7858:              fix broken STBI_SIMD path
        -: 7859:              fix bug where stbi_load_from_file no longer left file pointer in correct place
        -: 7860:              fix broken non-easy path for 32-bit BMP (possibly never used)
        -: 7861:              TGA optimization by Arseny Kapoulkine
        -: 7862:      1.34  (unknown)
        -: 7863:              use STBI_NOTUSED in stbi__resample_row_generic(), fix one more leak in tga failure case
        -: 7864:      1.33  (2011-07-14)
        -: 7865:              make stbi_is_hdr work in STBI_NO_HDR (as specified), minor compiler-friendly improvements
        -: 7866:      1.32  (2011-07-13)
        -: 7867:              support for "info" function for all supported filetypes (SpartanJ)
        -: 7868:      1.31  (2011-06-20)
        -: 7869:              a few more leak fixes, bug in PNG handling (SpartanJ)
        -: 7870:      1.30  (2011-06-11)
        -: 7871:              added ability to load files via callbacks to accomidate custom input streams (Ben Wenger)
        -: 7872:              removed deprecated format-specific test/load functions
        -: 7873:              removed support for installable file formats (stbi_loader) -- would have been broken for IO callbacks anyway
        -: 7874:              error cases in bmp and tga give messages and don't leak (Raymond Barbiero, grisha)
        -: 7875:              fix inefficiency in decoding 32-bit BMP (David Woo)
        -: 7876:      1.29  (2010-08-16)
        -: 7877:              various warning fixes from Aurelien Pocheville
        -: 7878:      1.28  (2010-08-01)
        -: 7879:              fix bug in GIF palette transparency (SpartanJ)
        -: 7880:      1.27  (2010-08-01)
        -: 7881:              cast-to-stbi_uc to fix warnings
        -: 7882:      1.26  (2010-07-24)
        -: 7883:              fix bug in file buffering for PNG reported by SpartanJ
        -: 7884:      1.25  (2010-07-17)
        -: 7885:              refix trans_data warning (Won Chun)
        -: 7886:      1.24  (2010-07-12)
        -: 7887:              perf improvements reading from files on platforms with lock-heavy fgetc()
        -: 7888:              minor perf improvements for jpeg
        -: 7889:              deprecated type-specific functions so we'll get feedback if they're needed
        -: 7890:              attempt to fix trans_data warning (Won Chun)
        -: 7891:      1.23    fixed bug in iPhone support
        -: 7892:      1.22  (2010-07-10)
        -: 7893:              removed image *writing* support
        -: 7894:              stbi_info support from Jetro Lauha
        -: 7895:              GIF support from Jean-Marc Lienher
        -: 7896:              iPhone PNG-extensions from James Brown
        -: 7897:              warning-fixes from Nicolas Schulz and Janez Zemva (i.stbi__err. Janez (U+017D)emva)
        -: 7898:      1.21    fix use of 'stbi_uc' in header (reported by jon blow)
        -: 7899:      1.20    added support for Softimage PIC, by Tom Seddon
        -: 7900:      1.19    bug in interlaced PNG corruption check (found by ryg)
        -: 7901:      1.18  (2008-08-02)
        -: 7902:              fix a threading bug (local mutable static)
        -: 7903:      1.17    support interlaced PNG
        -: 7904:      1.16    major bugfix - stbi__convert_format converted one too many pixels
        -: 7905:      1.15    initialize some fields for thread safety
        -: 7906:      1.14    fix threadsafe conversion bug
        -: 7907:              header-file-only version (#define STBI_HEADER_FILE_ONLY before including)
        -: 7908:      1.13    threadsafe
        -: 7909:      1.12    const qualifiers in the API
        -: 7910:      1.11    Support installable IDCT, colorspace conversion routines
        -: 7911:      1.10    Fixes for 64-bit (don't use "unsigned long")
        -: 7912:              optimized upsampling by Fabian "ryg" Giesen
        -: 7913:      1.09    Fix format-conversion for PSD code (bad global variables!)
        -: 7914:      1.08    Thatcher Ulrich's PSD code integrated by Nicolas Schulz
        -: 7915:      1.07    attempt to fix C++ warning/errors again
        -: 7916:      1.06    attempt to fix C++ warning/errors again
        -: 7917:      1.05    fix TGA loading to return correct *comp and use good luminance calc
        -: 7918:      1.04    default float alpha is 1, not 255; use 'void *' for stbi_image_free
        -: 7919:      1.03    bugfixes to STBI_NO_STDIO, STBI_NO_HDR
        -: 7920:      1.02    support for (subset of) HDR files, float interface for preferred access to them
        -: 7921:      1.01    fix bug: possible bug in handling right-side up bmps... not sure
        -: 7922:              fix bug: the stbi__bmp_load() and stbi__tga_load() functions didn't work at all
        -: 7923:      1.00    interface to zlib that skips zlib header
        -: 7924:      0.99    correct handling of alpha in palette
        -: 7925:      0.98    TGA loader by lonesock; dynamically add loaders (untested)
        -: 7926:      0.97    jpeg errors on too large a file; also catch another malloc failure
        -: 7927:      0.96    fix detection of invalid v value - particleman@mollyrocket forum
        -: 7928:      0.95    during header scan, seek to markers in case of padding
        -: 7929:      0.94    STBI_NO_STDIO to disable stdio usage; rename all #defines the same
        -: 7930:      0.93    handle jpegtran output; verbose errors
        -: 7931:      0.92    read 4,8,16,24,32-bit BMP files of several formats
        -: 7932:      0.91    output 24-bit Windows 3.0 BMP files
        -: 7933:      0.90    fix a few more warnings; bump version number to approach 1.0
        -: 7934:      0.61    bugfixes due to Marc LeBlanc, Christopher Lloyd
        -: 7935:      0.60    fix compiling as c++
        -: 7936:      0.59    fix warnings: merge Dave Moore's -Wall fixes
        -: 7937:      0.58    fix bug: zlib uncompressed mode len/nlen was wrong endian
        -: 7938:      0.57    fix bug: jpg last huffman symbol before marker was >9 bits but less than 16 available
        -: 7939:      0.56    fix bug: zlib uncompressed mode len vs. nlen
        -: 7940:      0.55    fix bug: restart_interval not initialized to 0
        -: 7941:      0.54    allow NULL for 'int *comp'
        -: 7942:      0.53    fix bug in png 3->4; speedup png decoding
        -: 7943:      0.52    png handles req_comp=3,4 directly; minor cleanup; jpeg comments
        -: 7944:      0.51    obey req_comp requests, 1-component jpegs return as 1-component,
        -: 7945:              on 'test' only check type, not whether we support this variant
        -: 7946:      0.50  (2006-11-19)
        -: 7947:              first released version
        -: 7948:*/
        -: 7949:
        -: 7950:
        -: 7951:/*
        -: 7952:------------------------------------------------------------------------------
        -: 7953:This software is available under 2 licenses -- choose whichever you prefer.
        -: 7954:------------------------------------------------------------------------------
        -: 7955:ALTERNATIVE A - MIT License
        -: 7956:Copyright (c) 2017 Sean Barrett
        -: 7957:Permission is hereby granted, free of charge, to any person obtaining a copy of
        -: 7958:this software and associated documentation files (the "Software"), to deal in
        -: 7959:the Software without restriction, including without limitation the rights to
        -: 7960:use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
        -: 7961:of the Software, and to permit persons to whom the Software is furnished to do
        -: 7962:so, subject to the following conditions:
        -: 7963:The above copyright notice and this permission notice shall be included in all
        -: 7964:copies or substantial portions of the Software.
        -: 7965:THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        -: 7966:IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        -: 7967:FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        -: 7968:AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        -: 7969:LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        -: 7970:OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
        -: 7971:SOFTWARE.
        -: 7972:------------------------------------------------------------------------------
        -: 7973:ALTERNATIVE B - Public Domain (www.unlicense.org)
        -: 7974:This is free and unencumbered software released into the public domain.
        -: 7975:Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
        -: 7976:software, either in source code form or as a compiled binary, for any purpose,
        -: 7977:commercial or non-commercial, and by any means.
        -: 7978:In jurisdictions that recognize copyright laws, the author or authors of this
        -: 7979:software dedicate any and all copyright interest in the software to the public
        -: 7980:domain. We make this dedication for the benefit of the public at large and to
        -: 7981:the detriment of our heirs and successors. We intend this dedication to be an
        -: 7982:overt act of relinquishment in perpetuity of all present and future rights to
        -: 7983:this software under copyright law.
        -: 7984:THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        -: 7985:IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        -: 7986:FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        -: 7987:AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
        -: 7988:ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
        -: 7989:WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
        -: 7990:------------------------------------------------------------------------------
        -: 7991:*/
        -: 7992:
        -: 7993:#endif //ZATHURA_STB_IMAGE_H
