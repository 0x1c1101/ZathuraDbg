        -:    0:Source:/home/rc/ZathuraDbg/vendor/ordered-map/include/tsl/ordered_hash.h
        -:    0:Graph:/home/rc/ZathuraDbg/src/cmake-build-debug-coverage/CMakeFiles/Zathura.dir/app/windows/consoleWindow.cpp.gcno
        -:    0:Data:/home/rc/ZathuraDbg/src/cmake-build-debug-coverage/CMakeFiles/Zathura.dir/app/windows/consoleWindow.cpp.gcda
        -:    0:Runs:1
        -:    1:/**
        -:    2: * MIT License
        -:    3: *
        -:    4: * Copyright (c) 2017 Thibaut Goetghebuer-Planchon <tessil@gmx.com>
        -:    5: *
        -:    6: * Permission is hereby granted, free of charge, to any person obtaining a copy
        -:    7: * of this software and associated documentation files (the "Software"), to deal
        -:    8: * in the Software without restriction, including without limitation the rights
        -:    9: * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        -:   10: * copies of the Software, and to permit persons to whom the Software is
        -:   11: * furnished to do so, subject to the following conditions:
        -:   12: *
        -:   13: * The above copyright notice and this permission notice shall be included in
        -:   14: * all copies or substantial portions of the Software.
        -:   15: *
        -:   16: * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        -:   17: * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        -:   18: * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        -:   19: * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        -:   20: * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        -:   21: * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
        -:   22: * SOFTWARE.
        -:   23: */
        -:   24:#ifndef TSL_ORDERED_HASH_H
        -:   25:#define TSL_ORDERED_HASH_H
        -:   26:
        -:   27:#include <algorithm>
        -:   28:#include <cassert>
        -:   29:#include <climits>
        -:   30:#include <cmath>
        -:   31:#include <cstddef>
        -:   32:#include <cstdint>
        -:   33:#include <exception>
        -:   34:#include <functional>
        -:   35:#include <iterator>
        -:   36:#include <limits>
        -:   37:#include <memory>
        -:   38:#include <stdexcept>
        -:   39:#include <tuple>
        -:   40:#include <type_traits>
        -:   41:#include <utility>
        -:   42:#include <vector>
        -:   43:
        -:   44:/**
        -:   45: * Macros for compatibility with GCC 4.8
        -:   46: */
        -:   47:#if (defined(__GNUC__) && (__GNUC__ == 4) && (__GNUC_MINOR__ < 9))
        -:   48:#define TSL_OH_NO_CONTAINER_ERASE_CONST_ITERATOR
        -:   49:#define TSL_OH_NO_CONTAINER_EMPLACE_CONST_ITERATOR
        -:   50:#endif
        -:   51:
        -:   52:/**
        -:   53: * Only activate tsl_oh_assert if TSL_DEBUG is defined.
        -:   54: * This way we avoid the performance hit when NDEBUG is not defined with assert
        -:   55: * as tsl_oh_assert is used a lot (people usually compile with "-O3" and not
        -:   56: * "-O3 -DNDEBUG").
        -:   57: */
        -:   58:#ifdef TSL_DEBUG
        -:   59:#define tsl_oh_assert(expr) assert(expr)
        -:   60:#else
        -:   61:#define tsl_oh_assert(expr) (static_cast<void>(0))
        -:   62:#endif
        -:   63:
        -:   64:/**
        -:   65: * If exceptions are enabled, throw the exception passed in parameter, otherwise
        -:   66: * call std::terminate.
        -:   67: */
        -:   68:#if (defined(__cpp_exceptions) || defined(__EXCEPTIONS) || \
        -:   69:     (defined(_MSC_VER) && defined(_CPPUNWIND))) &&        \
        -:   70:    !defined(TSL_NO_EXCEPTIONS)
        -:   71:#define TSL_OH_THROW_OR_TERMINATE(ex, msg) throw ex(msg)
        -:   72:#else
        -:   73:#define TSL_OH_NO_EXCEPTIONS
        -:   74:#ifdef TSL_DEBUG
        -:   75:#include <iostream>
        -:   76:#define TSL_OH_THROW_OR_TERMINATE(ex, msg) \
        -:   77:  do {                                     \
        -:   78:    std::cerr << msg << std::endl;         \
        -:   79:    std::terminate();                      \
        -:   80:  } while (0)
        -:   81:#else
        -:   82:#define TSL_OH_THROW_OR_TERMINATE(ex, msg) std::terminate()
        -:   83:#endif
        -:   84:#endif
        -:   85:
        -:   86:namespace tsl {
        -:   87:
        -:   88:namespace detail_ordered_hash {
        -:   89:
        -:   90:template <typename T>
        -:   91:struct make_void {
        -:   92:  using type = void;
        -:   93:};
        -:   94:
        -:   95:template <typename T, typename = void>
        -:   96:struct has_is_transparent : std::false_type {};
        -:   97:
        -:   98:template <typename T>
        -:   99:struct has_is_transparent<T,
        -:  100:                          typename make_void<typename T::is_transparent>::type>
        -:  101:    : std::true_type {};
        -:  102:
        -:  103:template <typename T, typename = void>
        -:  104:struct is_vector : std::false_type {};
        -:  105:
        -:  106:template <typename T>
        -:  107:struct is_vector<T,
        -:  108:                 typename std::enable_if<std::is_same<
        -:  109:                     T, std::vector<typename T::value_type,
        -:  110:                                    typename T::allocator_type>>::value>::type>
        -:  111:    : std::true_type {};
        -:  112:
        -:  113:// Only available in C++17, we need to be compatible with C++11
        -:  114:template <class T>
function _ZN3tsl19detail_ordered_hash5clampIfEERKT_S4_S4_S4_ called 0 returned 0% blocks executed 0%
    #####:  115:const T& clamp(const T& v, const T& lo, const T& hi) {
    #####:  116:  return std::min(hi, std::max(lo, v));
    %%%%%:  116-block 2
call    0 never executed
call    1 never executed
        -:  117:}
        -:  118:
        -:  119:template <typename T, typename U>
        -:  120:static T numeric_cast(U value,
        -:  121:                      const char* error_message = "numeric_cast() failed.") {
        -:  122:  T ret = static_cast<T>(value);
        -:  123:  if (static_cast<U>(ret) != value) {
        -:  124:    TSL_OH_THROW_OR_TERMINATE(std::runtime_error, error_message);
        -:  125:  }
        -:  126:
        -:  127:  const bool is_same_signedness =
        -:  128:      (std::is_unsigned<T>::value && std::is_unsigned<U>::value) ||
        -:  129:      (std::is_signed<T>::value && std::is_signed<U>::value);
        -:  130:  if (!is_same_signedness && (ret < T{}) != (value < U{})) {
        -:  131:    TSL_OH_THROW_OR_TERMINATE(std::runtime_error, error_message);
        -:  132:  }
        -:  133:
        -:  134:  return ret;
        -:  135:}
        -:  136:
        -:  137:/**
        -:  138: * Fixed size type used to represent size_type values on serialization. Need to
        -:  139: * be big enough to represent a std::size_t on 32 and 64 bits platforms, and
        -:  140: * must be the same size on both platforms.
        -:  141: */
        -:  142:using slz_size_type = std::uint64_t;
        -:  143:static_assert(std::numeric_limits<slz_size_type>::max() >=
        -:  144:                  std::numeric_limits<std::size_t>::max(),
        -:  145:              "slz_size_type must be >= std::size_t");
        -:  146:
        -:  147:template <class T, class Deserializer>
        -:  148:static T deserialize_value(Deserializer& deserializer) {
        -:  149:  // MSVC < 2017 is not conformant, circumvent the problem by removing the
        -:  150:  // template keyword
        -:  151:#if defined(_MSC_VER) && _MSC_VER < 1910
        -:  152:  return deserializer.Deserializer::operator()<T>();
        -:  153:#else
        -:  154:  return deserializer.Deserializer::template operator()<T>();
        -:  155:#endif
        -:  156:}
        -:  157:
        -:  158:/**
        -:  159: * Each bucket entry stores an index which is the index in m_values
        -:  160: * corresponding to the bucket's value and a hash (which may be truncated to 32
        -:  161: * bits depending on IndexType) corresponding to the hash of the value.
        -:  162: *
        -:  163: * The size of IndexType limits the size of the hash table to
        -:  164: * std::numeric_limits<IndexType>::max() - 1 elements (-1 due to a reserved
        -:  165: * value used to mark a bucket as empty).
        -:  166: */
        -:  167:template <class IndexType>
        -:  168:class bucket_entry {
        -:  169:  static_assert(std::is_unsigned<IndexType>::value,
        -:  170:                "IndexType must be an unsigned value.");
        -:  171:  static_assert(std::numeric_limits<IndexType>::max() <=
        -:  172:                    std::numeric_limits<std::size_t>::max(),
        -:  173:                "std::numeric_limits<IndexType>::max() must be <= "
        -:  174:                "std::numeric_limits<std::size_t>::max().");
        -:  175:
        -:  176: public:
        -:  177:  using index_type = IndexType;
        -:  178:  using truncated_hash_type = typename std::conditional<
        -:  179:      std::numeric_limits<IndexType>::max() <=
        -:  180:          std::numeric_limits<std::uint_least32_t>::max(),
        -:  181:      std::uint_least32_t, std::size_t>::type;
        -:  182:
function _ZN3tsl19detail_ordered_hash12bucket_entryIjEC2Ev called 0 returned 0% blocks executed 0%
    #####:  183:  bucket_entry() noexcept : m_index(EMPTY_MARKER_INDEX), m_hash(0) {}
        -:  184:
function _ZNK3tsl19detail_ordered_hash12bucket_entryIjE5emptyEv called 0 returned 0% blocks executed 0%
    #####:  185:  bool empty() const noexcept { return m_index == EMPTY_MARKER_INDEX; }
    %%%%%:  185-block 2
        -:  186:
        -:  187:  void clear() noexcept { m_index = EMPTY_MARKER_INDEX; }
        -:  188:
function _ZNK3tsl19detail_ordered_hash12bucket_entryIjE5indexEv called 0 returned 0% blocks executed 0%
    #####:  189:  index_type index() const noexcept {
        -:  190:    tsl_oh_assert(!empty());
    #####:  191:    return m_index;
    %%%%%:  191-block 2
        -:  192:  }
        -:  193:
function _ZN3tsl19detail_ordered_hash12bucket_entryIjE9index_refEv called 0 returned 0% blocks executed 0%
    #####:  194:  index_type& index_ref() noexcept {
        -:  195:    tsl_oh_assert(!empty());
    #####:  196:    return m_index;
    %%%%%:  196-block 2
        -:  197:  }
        -:  198:
function _ZN3tsl19detail_ordered_hash12bucket_entryIjE9set_indexEj called 0 returned 0% blocks executed 0%
    #####:  199:  void set_index(index_type index) noexcept {
        -:  200:    tsl_oh_assert(index <= max_size());
        -:  201:
    #####:  202:    m_index = index;
    #####:  203:  }
        -:  204:
function _ZNK3tsl19detail_ordered_hash12bucket_entryIjE14truncated_hashEv called 0 returned 0% blocks executed 0%
    #####:  205:  truncated_hash_type truncated_hash() const noexcept {
        -:  206:    tsl_oh_assert(!empty());
    #####:  207:    return m_hash;
    %%%%%:  207-block 2
        -:  208:  }
        -:  209:
function _ZN3tsl19detail_ordered_hash12bucket_entryIjE18truncated_hash_refEv called 0 returned 0% blocks executed 0%
    #####:  210:  truncated_hash_type& truncated_hash_ref() noexcept {
        -:  211:    tsl_oh_assert(!empty());
    #####:  212:    return m_hash;
    %%%%%:  212-block 2
        -:  213:  }
        -:  214:
function _ZN3tsl19detail_ordered_hash12bucket_entryIjE8set_hashEm called 0 returned 0% blocks executed 0%
    #####:  215:  void set_hash(std::size_t hash) noexcept { m_hash = truncate_hash(hash); }
    %%%%%:  215-block 2
call    0 never executed
        -:  216:
        -:  217:  template <class Serializer>
        -:  218:  void serialize(Serializer& serializer) const {
        -:  219:    const slz_size_type index = m_index;
        -:  220:    serializer(index);
        -:  221:
        -:  222:    const slz_size_type hash = m_hash;
        -:  223:    serializer(hash);
        -:  224:  }
        -:  225:
        -:  226:  template <class Deserializer>
        -:  227:  static bucket_entry deserialize(Deserializer& deserializer) {
        -:  228:    const slz_size_type index = deserialize_value<slz_size_type>(deserializer);
        -:  229:    const slz_size_type hash = deserialize_value<slz_size_type>(deserializer);
        -:  230:
        -:  231:    bucket_entry bentry;
        -:  232:    bentry.m_index =
        -:  233:        numeric_cast<index_type>(index, "Deserialized index is too big.");
        -:  234:    bentry.m_hash = numeric_cast<truncated_hash_type>(
        -:  235:        hash, "Deserialized hash is too big.");
        -:  236:
        -:  237:    return bentry;
        -:  238:  }
        -:  239:
function _ZN3tsl19detail_ordered_hash12bucket_entryIjE13truncate_hashEm called 0 returned 0% blocks executed 0%
    #####:  240:  static truncated_hash_type truncate_hash(std::size_t hash) noexcept {
    #####:  241:    return truncated_hash_type(hash);
    %%%%%:  241-block 2
        -:  242:  }
        -:  243:
function _ZN3tsl19detail_ordered_hash12bucket_entryIjE8max_sizeEv called 0 returned 0% blocks executed 0%
    #####:  244:  static std::size_t max_size() noexcept {
    #####:  245:    return static_cast<std::size_t>(std::numeric_limits<index_type>::max()) -
    %%%%%:  245-block 2
call    0 never executed
    #####:  246:           NB_RESERVED_INDEXES;
        -:  247:  }
        -:  248:
        -:  249: private:
        -:  250:  static const index_type EMPTY_MARKER_INDEX =
        -:  251:      std::numeric_limits<index_type>::max();
        -:  252:  static const std::size_t NB_RESERVED_INDEXES = 1;
        -:  253:
        -:  254:  index_type m_index;
        -:  255:  truncated_hash_type m_hash;
        -:  256:};
        -:  257:
        -:  258:/**
        -:  259: * Internal common class used by ordered_map and ordered_set.
        -:  260: *
        -:  261: * ValueType is what will be stored by ordered_hash (usually std::pair<Key, T>
        -:  262: * for map and Key for set).
        -:  263: *
        -:  264: * KeySelect should be a FunctionObject which takes a ValueType in parameter and
        -:  265: * return a reference to the key.
        -:  266: *
        -:  267: * ValueSelect should be a FunctionObject which takes a ValueType in parameter
        -:  268: * and return a reference to the value. ValueSelect should be void if there is
        -:  269: * no value (in set for example).
        -:  270: *
        -:  271: * ValueTypeContainer is the container which will be used to store ValueType
        -:  272: * values. Usually a std::deque<ValueType, Allocator> or std::vector<ValueType,
        -:  273: * Allocator>.
        -:  274: *
        -:  275: *
        -:  276: *
        -:  277: * The ordered_hash structure is a hash table which preserves the order of
        -:  278: * insertion of the elements. To do so, it stores the values in the
        -:  279: * ValueTypeContainer (m_values) using emplace_back at each insertion of a new
        -:  280: * element. Another structure (m_buckets of type std::vector<bucket_entry>) will
        -:  281: * serve as buckets array for the hash table part. Each bucket stores an index
        -:  282: * which corresponds to the index in m_values where the bucket's value is and
        -:  283: * the (truncated) hash of this value. An index is used instead of a pointer to
        -:  284: * the value to reduce the size of each bucket entry.
        -:  285: *
        -:  286: * To resolve collisions in the buckets array, the structures use robin hood
        -:  287: * linear probing with backward shift deletion.
        -:  288: */
        -:  289:template <class ValueType, class KeySelect, class ValueSelect, class Hash,
        -:  290:          class KeyEqual, class Allocator, class ValueTypeContainer,
        -:  291:          class IndexType>
        -:  292:class ordered_hash : private Hash, private KeyEqual {
        -:  293: private:
        -:  294:  template <typename U>
        -:  295:  using has_mapped_type =
        -:  296:      typename std::integral_constant<bool, !std::is_same<U, void>::value>;
        -:  297:
        -:  298:  static_assert(
        -:  299:      std::is_same<typename ValueTypeContainer::value_type, ValueType>::value,
        -:  300:      "ValueTypeContainer::value_type != ValueType. "
        -:  301:      "Check that the ValueTypeContainer has 'Key' as type for a set or "
        -:  302:      "'std::pair<Key, T>' as type for a map.");
        -:  303:
        -:  304:  static_assert(std::is_same<typename ValueTypeContainer::allocator_type,
        -:  305:                             Allocator>::value,
        -:  306:                "ValueTypeContainer::allocator_type != Allocator. "
        -:  307:                "Check that the allocator for ValueTypeContainer is the same "
        -:  308:                "as Allocator.");
        -:  309:
        -:  310:  static_assert(std::is_same<typename Allocator::value_type, ValueType>::value,
        -:  311:                "Allocator::value_type != ValueType. "
        -:  312:                "Check that the allocator has 'Key' as type for a set or "
        -:  313:                "'std::pair<Key, T>' as type for a map.");
        -:  314:
        -:  315: public:
        -:  316:  template <bool IsConst>
        -:  317:  class ordered_iterator;
        -:  318:
        -:  319:  using key_type = typename KeySelect::key_type;
        -:  320:  using value_type = ValueType;
        -:  321:  using size_type = std::size_t;
        -:  322:  using difference_type = std::ptrdiff_t;
        -:  323:  using hasher = Hash;
        -:  324:  using key_equal = KeyEqual;
        -:  325:  using allocator_type = Allocator;
        -:  326:  using reference = value_type&;
        -:  327:  using const_reference = const value_type&;
        -:  328:  using pointer = value_type*;
        -:  329:  using const_pointer = const value_type*;
        -:  330:  using iterator = ordered_iterator<false>;
        -:  331:  using const_iterator = ordered_iterator<true>;
        -:  332:  using reverse_iterator = std::reverse_iterator<iterator>;
        -:  333:  using const_reverse_iterator = std::reverse_iterator<const_iterator>;
        -:  334:
        -:  335:  using values_container_type = ValueTypeContainer;
        -:  336:
        -:  337: public:
        -:  338:  template <bool IsConst>
        -:  339:  class ordered_iterator {
        -:  340:    friend class ordered_hash;
        -:  341:
        -:  342:   private:
        -:  343:    using iterator = typename std::conditional<
        -:  344:        IsConst, typename values_container_type::const_iterator,
        -:  345:        typename values_container_type::iterator>::type;
        -:  346:
    #####:  347:    ordered_iterator(iterator it) noexcept : m_iterator(it) {}
------------------
_ZN3tsl19detail_ordered_hash12ordered_hashISt4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ENS_11ordered_mapIS8_S8_St4hashIS8_ESt8equal_toIS8_ESaIS9_ESt5dequeIS9_SF_EjE9KeySelectENSI_11ValueSelectESC_SE_SF_SH_jE16ordered_iteratorILb1EEC2ESt15_Deque_iteratorIS9_RKS9_PSP_E:
function _ZN3tsl19detail_ordered_hash12ordered_hashISt4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ENS_11ordered_mapIS8_S8_St4hashIS8_ESt8equal_toIS8_ESaIS9_ESt5dequeIS9_SF_EjE9KeySelectENSI_11ValueSelectESC_SE_SF_SH_jE16ordered_iteratorILb1EEC2ESt15_Deque_iteratorIS9_RKS9_PSP_E called 0 returned 0% blocks executed 0%
    #####:  347:    ordered_iterator(iterator it) noexcept : m_iterator(it) {}
    %%%%%:  347-block 2
call    0 never executed
------------------
_ZN3tsl19detail_ordered_hash12ordered_hashISt4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ENS_11ordered_mapIS8_S8_St4hashIS8_ESt8equal_toIS8_ESaIS9_ESt5dequeIS9_SF_EjE9KeySelectENSI_11ValueSelectESC_SE_SF_SH_jE16ordered_iteratorILb0EEC2ESt15_Deque_iteratorIS9_RS9_PS9_E:
function _ZN3tsl19detail_ordered_hash12ordered_hashISt4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ENS_11ordered_mapIS8_S8_St4hashIS8_ESt8equal_toIS8_ESaIS9_ESt5dequeIS9_SF_EjE9KeySelectENSI_11ValueSelectESC_SE_SF_SH_jE16ordered_iteratorILb0EEC2ESt15_Deque_iteratorIS9_RS9_PS9_E called 0 returned 0% blocks executed 0%
    #####:  347:    ordered_iterator(iterator it) noexcept : m_iterator(it) {}
    %%%%%:  347-block 2
call    0 never executed
------------------
        -:  348:
        -:  349:   public:
        -:  350:    using iterator_category = std::random_access_iterator_tag;
        -:  351:    using value_type = const typename ordered_hash::value_type;
        -:  352:    using difference_type = typename iterator::difference_type;
        -:  353:    using reference = value_type&;
        -:  354:    using pointer = value_type*;
        -:  355:
        -:  356:    ordered_iterator() noexcept {}
        -:  357:
        -:  358:    // Copy constructor from iterator to const_iterator.
        -:  359:    template <bool TIsConst = IsConst,
        -:  360:              typename std::enable_if<TIsConst>::type* = nullptr>
        -:  361:    ordered_iterator(const ordered_iterator<!TIsConst>& other) noexcept
        -:  362:        : m_iterator(other.m_iterator) {}
        -:  363:
function _ZN3tsl19detail_ordered_hash12ordered_hashISt4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ENS_11ordered_mapIS8_S8_St4hashIS8_ESt8equal_toIS8_ESaIS9_ESt5dequeIS9_SF_EjE9KeySelectENSI_11ValueSelectESC_SE_SF_SH_jE16ordered_iteratorILb0EEC2ERKSN_ called 0 returned 0% blocks executed 0%
    #####:  364:    ordered_iterator(const ordered_iterator& other) = default;
    %%%%%:  364-block 2
call    0 never executed
function _ZN3tsl19detail_ordered_hash12ordered_hashISt4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ENS_11ordered_mapIS8_S8_St4hashIS8_ESt8equal_toIS8_ESaIS9_ESt5dequeIS9_SF_EjE9KeySelectENSI_11ValueSelectESC_SE_SF_SH_jE16ordered_iteratorILb0EEC2EOSN_ called 0 returned 0% blocks executed 0%
    #####:  365:    ordered_iterator(ordered_iterator&& other) = default;
    %%%%%:  365-block 2
call    0 never executed
        -:  366:    ordered_iterator& operator=(const ordered_iterator& other) = default;
        -:  367:    ordered_iterator& operator=(ordered_iterator&& other) = default;
        -:  368:
        -:  369:    const typename ordered_hash::key_type& key() const {
        -:  370:      return KeySelect()(*m_iterator);
        -:  371:    }
        -:  372:
        -:  373:    template <class U = ValueSelect,
        -:  374:              typename std::enable_if<has_mapped_type<U>::value &&
        -:  375:                                      IsConst>::type* = nullptr>
        -:  376:    const typename U::value_type& value() const {
        -:  377:      return U()(*m_iterator);
        -:  378:    }
        -:  379:
        -:  380:    template <class U = ValueSelect,
        -:  381:              typename std::enable_if<has_mapped_type<U>::value &&
        -:  382:                                      !IsConst>::type* = nullptr>
function _ZN3tsl19detail_ordered_hash12ordered_hashISt4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ENS_11ordered_mapIS8_S8_St4hashIS8_ESt8equal_toIS8_ESaIS9_ESt5dequeIS9_SF_EjE9KeySelectENSI_11ValueSelectESC_SE_SF_SH_jE16ordered_iteratorILb0EE5valueISK_LPv0EEERNT_10value_typeEv called 0 returned 0% blocks executed 0%
    #####:  383:    typename U::value_type& value() {
    #####:  384:      return U()(*m_iterator);
    %%%%%:  384-block 2
call    0 never executed
call    1 never executed
        -:  385:    }
        -:  386:
function _ZNK3tsl19detail_ordered_hash12ordered_hashISt4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ENS_11ordered_mapIS8_S8_St4hashIS8_ESt8equal_toIS8_ESaIS9_ESt5dequeIS9_SF_EjE9KeySelectENSI_11ValueSelectESC_SE_SF_SH_jE16ordered_iteratorILb0EEdeEv called 0 returned 0% blocks executed 0%
    #####:  387:    reference operator*() const { return *m_iterator; }
    %%%%%:  387-block 2
call    0 never executed
        -:  388:    pointer operator->() const { return m_iterator.operator->(); }
        -:  389:
function _ZN3tsl19detail_ordered_hash12ordered_hashISt4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ENS_11ordered_mapIS8_S8_St4hashIS8_ESt8equal_toIS8_ESaIS9_ESt5dequeIS9_SF_EjE9KeySelectENSI_11ValueSelectESC_SE_SF_SH_jE16ordered_iteratorILb0EEppEv called 0 returned 0% blocks executed 0%
    #####:  390:    ordered_iterator& operator++() {
    #####:  391:      ++m_iterator;
    %%%%%:  391-block 2
call    0 never executed
    #####:  392:      return *this;
        -:  393:    }
        -:  394:    ordered_iterator& operator--() {
        -:  395:      --m_iterator;
        -:  396:      return *this;
        -:  397:    }
        -:  398:
        -:  399:    ordered_iterator operator++(int) {
        -:  400:      ordered_iterator tmp(*this);
        -:  401:      ++(*this);
        -:  402:      return tmp;
        -:  403:    }
        -:  404:    ordered_iterator operator--(int) {
        -:  405:      ordered_iterator tmp(*this);
        -:  406:      --(*this);
        -:  407:      return tmp;
        -:  408:    }
        -:  409:
        -:  410:    reference operator[](difference_type n) const { return m_iterator[n]; }
        -:  411:
function _ZN3tsl19detail_ordered_hash12ordered_hashISt4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ENS_11ordered_mapIS8_S8_St4hashIS8_ESt8equal_toIS8_ESaIS9_ESt5dequeIS9_SF_EjE9KeySelectENSI_11ValueSelectESC_SE_SF_SH_jE16ordered_iteratorILb0EEpLEl called 0 returned 0% blocks executed 0%
    #####:  412:    ordered_iterator& operator+=(difference_type n) {
    #####:  413:      m_iterator += n;
    %%%%%:  413-block 2
call    0 never executed
    #####:  414:      return *this;
        -:  415:    }
        -:  416:    ordered_iterator& operator-=(difference_type n) {
        -:  417:      m_iterator -= n;
        -:  418:      return *this;
        -:  419:    }
        -:  420:
function _ZN3tsl19detail_ordered_hash12ordered_hashISt4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ENS_11ordered_mapIS8_S8_St4hashIS8_ESt8equal_toIS8_ESaIS9_ESt5dequeIS9_SF_EjE9KeySelectENSI_11ValueSelectESC_SE_SF_SH_jE16ordered_iteratorILb0EEplEl called 0 returned 0% blocks executed 0%
    #####:  421:    ordered_iterator operator+(difference_type n) {
    #####:  422:      ordered_iterator tmp(*this);
    %%%%%:  422-block 2
call    0 never executed
    #####:  423:      tmp += n;
call    0 never executed
    #####:  424:      return tmp;
        -:  425:    }
        -:  426:    ordered_iterator operator-(difference_type n) {
        -:  427:      ordered_iterator tmp(*this);
        -:  428:      tmp -= n;
        -:  429:      return tmp;
        -:  430:    }
        -:  431:
        -:  432:    friend bool operator==(const ordered_iterator& lhs,
        -:  433:                           const ordered_iterator& rhs) {
        -:  434:      return lhs.m_iterator == rhs.m_iterator;
        -:  435:    }
        -:  436:
    #####:  437:    friend bool operator!=(const ordered_iterator& lhs,
        -:  438:                           const ordered_iterator& rhs) {
    #####:  439:      return lhs.m_iterator != rhs.m_iterator;
        -:  440:    }
------------------
_ZN3tsl19detail_ordered_hashneERKNS0_12ordered_hashISt4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ENS_11ordered_mapIS8_S8_St4hashIS8_ESt8equal_toIS8_ESaIS9_ESt5dequeIS9_SF_EjE9KeySelectENSI_11ValueSelectESC_SE_SF_SH_jE16ordered_iteratorILb1EEESP_:
function _ZN3tsl19detail_ordered_hashneERKNS0_12ordered_hashISt4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ENS_11ordered_mapIS8_S8_St4hashIS8_ESt8equal_toIS8_ESaIS9_ESt5dequeIS9_SF_EjE9KeySelectENSI_11ValueSelectESC_SE_SF_SH_jE16ordered_iteratorILb1EEESP_ called 0 returned 0% blocks executed 0%
    #####:  437:    friend bool operator!=(const ordered_iterator& lhs,
        -:  438:                           const ordered_iterator& rhs) {
    #####:  439:      return lhs.m_iterator != rhs.m_iterator;
    %%%%%:  439-block 2
call    0 never executed
        -:  440:    }
------------------
_ZN3tsl19detail_ordered_hashneERKNS0_12ordered_hashISt4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ENS_11ordered_mapIS8_S8_St4hashIS8_ESt8equal_toIS8_ESaIS9_ESt5dequeIS9_SF_EjE9KeySelectENSI_11ValueSelectESC_SE_SF_SH_jE16ordered_iteratorILb0EEESP_:
function _ZN3tsl19detail_ordered_hashneERKNS0_12ordered_hashISt4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ENS_11ordered_mapIS8_S8_St4hashIS8_ESt8equal_toIS8_ESaIS9_ESt5dequeIS9_SF_EjE9KeySelectENSI_11ValueSelectESC_SE_SF_SH_jE16ordered_iteratorILb0EEESP_ called 0 returned 0% blocks executed 0%
    #####:  437:    friend bool operator!=(const ordered_iterator& lhs,
        -:  438:                           const ordered_iterator& rhs) {
    #####:  439:      return lhs.m_iterator != rhs.m_iterator;
    %%%%%:  439-block 2
call    0 never executed
        -:  440:    }
------------------
        -:  441:
        -:  442:    friend bool operator<(const ordered_iterator& lhs,
        -:  443:                          const ordered_iterator& rhs) {
        -:  444:      return lhs.m_iterator < rhs.m_iterator;
        -:  445:    }
        -:  446:
        -:  447:    friend bool operator>(const ordered_iterator& lhs,
        -:  448:                          const ordered_iterator& rhs) {
        -:  449:      return lhs.m_iterator > rhs.m_iterator;
        -:  450:    }
        -:  451:
        -:  452:    friend bool operator<=(const ordered_iterator& lhs,
        -:  453:                           const ordered_iterator& rhs) {
        -:  454:      return lhs.m_iterator <= rhs.m_iterator;
        -:  455:    }
        -:  456:
        -:  457:    friend bool operator>=(const ordered_iterator& lhs,
        -:  458:                           const ordered_iterator& rhs) {
        -:  459:      return lhs.m_iterator >= rhs.m_iterator;
        -:  460:    }
        -:  461:
        -:  462:    friend ordered_iterator operator+(difference_type n,
        -:  463:                                      const ordered_iterator& it) {
        -:  464:      return n + it.m_iterator;
        -:  465:    }
        -:  466:
        -:  467:    friend difference_type operator-(const ordered_iterator& lhs,
        -:  468:                                     const ordered_iterator& rhs) {
        -:  469:      return lhs.m_iterator - rhs.m_iterator;
        -:  470:    }
        -:  471:
        -:  472:   private:
        -:  473:    iterator m_iterator;
        -:  474:  };
        -:  475:
        -:  476: private:
        -:  477:  using bucket_entry = tsl::detail_ordered_hash::bucket_entry<IndexType>;
        -:  478:
        -:  479:  using buckets_container_allocator = typename std::allocator_traits<
        -:  480:      allocator_type>::template rebind_alloc<bucket_entry>;
        -:  481:
        -:  482:  using buckets_container_type =
        -:  483:      std::vector<bucket_entry, buckets_container_allocator>;
        -:  484:
        -:  485:  using truncated_hash_type = typename bucket_entry::truncated_hash_type;
        -:  486:  using index_type = typename bucket_entry::index_type;
        -:  487:
        -:  488: public:
        -:  489:  ordered_hash(size_type bucket_count, const Hash& hash, const KeyEqual& equal,
        -:  490:               const Allocator& alloc, float max_load_factor)
        -:  491:      : Hash(hash),
        -:  492:        KeyEqual(equal),
        -:  493:        m_buckets_data(alloc),
        -:  494:        m_buckets(static_empty_bucket_ptr()),
        -:  495:        m_hash_mask(0),
        -:  496:        m_values(alloc),
        -:  497:        m_grow_on_next_insert(false) {
        -:  498:    if (bucket_count > max_bucket_count()) {
        -:  499:      TSL_OH_THROW_OR_TERMINATE(std::length_error,
        -:  500:                                "The map exceeds its maximum size.");
        -:  501:    }
        -:  502:
        -:  503:    if (bucket_count > 0) {
        -:  504:      bucket_count = round_up_to_power_of_two(bucket_count);
        -:  505:
        -:  506:      m_buckets_data.resize(bucket_count);
        -:  507:      m_buckets = m_buckets_data.data(), m_hash_mask = bucket_count - 1;
        -:  508:    }
        -:  509:
        -:  510:    this->max_load_factor(max_load_factor);
        -:  511:  }
        -:  512:
        -:  513:  ordered_hash(const ordered_hash& other)
        -:  514:      : Hash(other),
        -:  515:        KeyEqual(other),
        -:  516:        m_buckets_data(other.m_buckets_data),
        -:  517:        m_buckets(m_buckets_data.empty() ? static_empty_bucket_ptr()
        -:  518:                                         : m_buckets_data.data()),
        -:  519:        m_hash_mask(other.m_hash_mask),
        -:  520:        m_values(other.m_values),
        -:  521:        m_load_threshold(other.m_load_threshold),
        -:  522:        m_max_load_factor(other.m_max_load_factor),
        -:  523:        m_grow_on_next_insert(other.m_grow_on_next_insert) {}
        -:  524:
        -:  525:  ordered_hash(ordered_hash&& other) noexcept(
        -:  526:      std::is_nothrow_move_constructible<
        -:  527:          Hash>::value&& std::is_nothrow_move_constructible<KeyEqual>::value&&
        -:  528:          std::is_nothrow_move_constructible<buckets_container_type>::value&&
        -:  529:              std::is_nothrow_move_constructible<values_container_type>::value)
        -:  530:      : Hash(std::move(static_cast<Hash&>(other))),
        -:  531:        KeyEqual(std::move(static_cast<KeyEqual&>(other))),
        -:  532:        m_buckets_data(std::move(other.m_buckets_data)),
        -:  533:        m_buckets(m_buckets_data.empty() ? static_empty_bucket_ptr()
        -:  534:                                         : m_buckets_data.data()),
        -:  535:        m_hash_mask(other.m_hash_mask),
        -:  536:        m_values(std::move(other.m_values)),
        -:  537:        m_load_threshold(other.m_load_threshold),
        -:  538:        m_max_load_factor(other.m_max_load_factor),
        -:  539:        m_grow_on_next_insert(other.m_grow_on_next_insert) {
        -:  540:    other.m_buckets_data.clear();
        -:  541:    other.m_buckets = static_empty_bucket_ptr();
        -:  542:    other.m_hash_mask = 0;
        -:  543:    other.m_values.clear();
        -:  544:    other.m_load_threshold = 0;
        -:  545:    other.m_grow_on_next_insert = false;
        -:  546:  }
        -:  547:
        -:  548:  ordered_hash& operator=(const ordered_hash& other) {
        -:  549:    if (&other != this) {
        -:  550:      Hash::operator=(other);
        -:  551:      KeyEqual::operator=(other);
        -:  552:
        -:  553:      m_buckets_data = other.m_buckets_data;
        -:  554:      m_buckets = m_buckets_data.empty() ? static_empty_bucket_ptr()
        -:  555:                                         : m_buckets_data.data();
        -:  556:
        -:  557:      m_hash_mask = other.m_hash_mask;
        -:  558:      m_values = other.m_values;
        -:  559:      m_load_threshold = other.m_load_threshold;
        -:  560:      m_max_load_factor = other.m_max_load_factor;
        -:  561:      m_grow_on_next_insert = other.m_grow_on_next_insert;
        -:  562:    }
        -:  563:
        -:  564:    return *this;
        -:  565:  }
        -:  566:
        -:  567:  ordered_hash& operator=(ordered_hash&& other) {
        -:  568:    other.swap(*this);
        -:  569:    other.clear();
        -:  570:
        -:  571:    return *this;
        -:  572:  }
        -:  573:
        -:  574:  allocator_type get_allocator() const { return m_values.get_allocator(); }
        -:  575:
        -:  576:  /*
        -:  577:   * Iterators
        -:  578:   */
function _ZN3tsl19detail_ordered_hash12ordered_hashISt4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ENS_11ordered_mapIS8_S8_St4hashIS8_ESt8equal_toIS8_ESaIS9_ESt5dequeIS9_SF_EjE9KeySelectENSI_11ValueSelectESC_SE_SF_SH_jE5beginEv called 0 returned 0% blocks executed 0%
    #####:  579:  iterator begin() noexcept { return iterator(m_values.begin()); }
    %%%%%:  579-block 2
call    0 never executed
call    1 never executed
        -:  580:
        -:  581:  const_iterator begin() const noexcept { return cbegin(); }
        -:  582:
        -:  583:  const_iterator cbegin() const noexcept {
        -:  584:    return const_iterator(m_values.cbegin());
        -:  585:  }
        -:  586:
function _ZN3tsl19detail_ordered_hash12ordered_hashISt4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ENS_11ordered_mapIS8_S8_St4hashIS8_ESt8equal_toIS8_ESaIS9_ESt5dequeIS9_SF_EjE9KeySelectENSI_11ValueSelectESC_SE_SF_SH_jE3endEv called 0 returned 0% blocks executed 0%
    #####:  587:  iterator end() noexcept { return iterator(m_values.end()); }
    %%%%%:  587-block 2
call    0 never executed
call    1 never executed
        -:  588:
function _ZNK3tsl19detail_ordered_hash12ordered_hashISt4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ENS_11ordered_mapIS8_S8_St4hashIS8_ESt8equal_toIS8_ESaIS9_ESt5dequeIS9_SF_EjE9KeySelectENSI_11ValueSelectESC_SE_SF_SH_jE3endEv called 0 returned 0% blocks executed 0%
    #####:  589:  const_iterator end() const noexcept { return cend(); }
    %%%%%:  589-block 2
call    0 never executed
        -:  590:
function _ZNK3tsl19detail_ordered_hash12ordered_hashISt4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ENS_11ordered_mapIS8_S8_St4hashIS8_ESt8equal_toIS8_ESaIS9_ESt5dequeIS9_SF_EjE9KeySelectENSI_11ValueSelectESC_SE_SF_SH_jE4cendEv called 0 returned 0% blocks executed 0%
    #####:  591:  const_iterator cend() const noexcept {
    #####:  592:    return const_iterator(m_values.cend());
    %%%%%:  592-block 2
call    0 never executed
call    1 never executed
        -:  593:  }
        -:  594:
        -:  595:  reverse_iterator rbegin() noexcept {
        -:  596:    return reverse_iterator(m_values.end());
        -:  597:  }
        -:  598:
        -:  599:  const_reverse_iterator rbegin() const noexcept { return rcbegin(); }
        -:  600:
        -:  601:  const_reverse_iterator rcbegin() const noexcept {
        -:  602:    return const_reverse_iterator(m_values.cend());
        -:  603:  }
        -:  604:
        -:  605:  reverse_iterator rend() noexcept {
        -:  606:    return reverse_iterator(m_values.begin());
        -:  607:  }
        -:  608:
        -:  609:  const_reverse_iterator rend() const noexcept { return rcend(); }
        -:  610:
        -:  611:  const_reverse_iterator rcend() const noexcept {
        -:  612:    return const_reverse_iterator(m_values.cbegin());
        -:  613:  }
        -:  614:
        -:  615:  /*
        -:  616:   * Capacity
        -:  617:   */
        -:  618:  bool empty() const noexcept { return m_values.empty(); }
        -:  619:
function _ZNK3tsl19detail_ordered_hash12ordered_hashISt4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ENS_11ordered_mapIS8_S8_St4hashIS8_ESt8equal_toIS8_ESaIS9_ESt5dequeIS9_SF_EjE9KeySelectENSI_11ValueSelectESC_SE_SF_SH_jE4sizeEv called 0 returned 0% blocks executed 0%
    #####:  620:  size_type size() const noexcept { return m_values.size(); }
    %%%%%:  620-block 2
call    0 never executed
        -:  621:
function _ZNK3tsl19detail_ordered_hash12ordered_hashISt4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ENS_11ordered_mapIS8_S8_St4hashIS8_ESt8equal_toIS8_ESaIS9_ESt5dequeIS9_SF_EjE9KeySelectENSI_11ValueSelectESC_SE_SF_SH_jE8max_sizeEv called 0 returned 0% blocks executed 0%
    #####:  622:  size_type max_size() const noexcept {
    #####:  623:    return std::min(bucket_entry::max_size(), m_values.max_size());
    %%%%%:  623-block 2
call    0 never executed
call    1 never executed
call    2 never executed
    %%%%%:  623-block 6
        -:  624:  }
        -:  625:
        -:  626:  /*
        -:  627:   * Modifiers
        -:  628:   */
        -:  629:  void clear() noexcept {
        -:  630:    for (auto& bucket : m_buckets_data) {
        -:  631:      bucket.clear();
        -:  632:    }
        -:  633:
        -:  634:    m_values.clear();
        -:  635:    m_grow_on_next_insert = false;
        -:  636:  }
        -:  637:
        -:  638:  template <typename P>
        -:  639:  std::pair<iterator, bool> insert(P&& value) {
        -:  640:    return insert_impl(KeySelect()(value), std::forward<P>(value));
        -:  641:  }
        -:  642:
        -:  643:  template <typename P>
        -:  644:  iterator insert_hint(const_iterator hint, P&& value) {
        -:  645:    if (hint != cend() &&
        -:  646:        compare_keys(KeySelect()(*hint), KeySelect()(value))) {
        -:  647:      return mutable_iterator(hint);
        -:  648:    }
        -:  649:
        -:  650:    return insert(std::forward<P>(value)).first;
        -:  651:  }
        -:  652:
        -:  653:  template <class InputIt>
        -:  654:  void insert(InputIt first, InputIt last) {
        -:  655:    if (std::is_base_of<
        -:  656:            std::forward_iterator_tag,
        -:  657:            typename std::iterator_traits<InputIt>::iterator_category>::value) {
        -:  658:      const auto nb_elements_insert = std::distance(first, last);
        -:  659:      const size_type nb_free_buckets = m_load_threshold - size();
        -:  660:      tsl_oh_assert(m_load_threshold >= size());
        -:  661:
        -:  662:      if (nb_elements_insert > 0 &&
        -:  663:          nb_free_buckets < size_type(nb_elements_insert)) {
        -:  664:        reserve(size() + size_type(nb_elements_insert));
        -:  665:      }
        -:  666:    }
        -:  667:
        -:  668:    for (; first != last; ++first) {
        -:  669:      insert(*first);
        -:  670:    }
        -:  671:  }
        -:  672:
        -:  673:  template <class K, class M>
        -:  674:  std::pair<iterator, bool> insert_or_assign(K&& key, M&& value) {
        -:  675:    auto it = try_emplace(std::forward<K>(key), std::forward<M>(value));
        -:  676:    if (!it.second) {
        -:  677:      it.first.value() = std::forward<M>(value);
        -:  678:    }
        -:  679:
        -:  680:    return it;
        -:  681:  }
        -:  682:
        -:  683:  template <class K, class M>
        -:  684:  iterator insert_or_assign(const_iterator hint, K&& key, M&& obj) {
        -:  685:    if (hint != cend() && compare_keys(KeySelect()(*hint), key)) {
        -:  686:      auto it = mutable_iterator(hint);
        -:  687:      it.value() = std::forward<M>(obj);
        -:  688:
        -:  689:      return it;
        -:  690:    }
        -:  691:
        -:  692:    return insert_or_assign(std::forward<K>(key), std::forward<M>(obj)).first;
        -:  693:  }
        -:  694:
        -:  695:  template <class... Args>
        -:  696:  std::pair<iterator, bool> emplace(Args&&... args) {
        -:  697:    return insert(value_type(std::forward<Args>(args)...));
        -:  698:  }
        -:  699:
        -:  700:  template <class... Args>
        -:  701:  iterator emplace_hint(const_iterator hint, Args&&... args) {
        -:  702:    return insert_hint(hint, value_type(std::forward<Args>(args)...));
        -:  703:  }
        -:  704:
        -:  705:  template <class K, class... Args>
function _ZN3tsl19detail_ordered_hash12ordered_hashISt4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ENS_11ordered_mapIS8_S8_St4hashIS8_ESt8equal_toIS8_ESaIS9_ESt5dequeIS9_SF_EjE9KeySelectENSI_11ValueSelectESC_SE_SF_SH_jE11try_emplaceIRKS8_JEEES2_INSL_16ordered_iteratorILb0EEEbEOT_DpOT0_ called 0 returned 0% blocks executed 0%
    #####:  706:  std::pair<iterator, bool> try_emplace(K&& key, Args&&... value_args) {
        -:  707:    return insert_impl(
        -:  708:        key, std::piecewise_construct,
    #####:  709:        std::forward_as_tuple(std::forward<K>(key)),
call    0 never executed
call    1 never executed
    $$$$$:  709-block 9
    #####:  710:        std::forward_as_tuple(std::forward<Args>(value_args)...));
    %%%%%:  710-block 2
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:  710-block 7
    %%%%%:  710-block 8
        -:  711:  }
        -:  712:
        -:  713:  template <class K, class... Args>
        -:  714:  iterator try_emplace_hint(const_iterator hint, K&& key, Args&&... args) {
        -:  715:    if (hint != cend() && compare_keys(KeySelect()(*hint), key)) {
        -:  716:      return mutable_iterator(hint);
        -:  717:    }
        -:  718:
        -:  719:    return try_emplace(std::forward<K>(key), std::forward<Args>(args)...).first;
        -:  720:  }
        -:  721:
        -:  722:  /**
        -:  723:   * Here to avoid `template<class K> size_type erase(const K& key)` being used
        -:  724:   * when we use an `iterator` instead of a `const_iterator`.
        -:  725:   */
        -:  726:  iterator erase(iterator pos) { return erase(const_iterator(pos)); }
        -:  727:
        -:  728:  iterator erase(const_iterator pos) {
        -:  729:    tsl_oh_assert(pos != cend());
        -:  730:
        -:  731:    const std::size_t index_erase = iterator_to_index(pos);
        -:  732:
        -:  733:    auto it_bucket = find_key(pos.key(), hash_key(pos.key()));
        -:  734:    tsl_oh_assert(it_bucket != m_buckets_data.end());
        -:  735:
        -:  736:    erase_value_from_bucket(it_bucket);
        -:  737:
        -:  738:    /*
        -:  739:     * One element was removed from m_values, due to the left shift the next
        -:  740:     * element is now at the position of the previous element (or end if none).
        -:  741:     */
        -:  742:    return begin() + index_erase;
        -:  743:  }
        -:  744:
        -:  745:  iterator erase(const_iterator first, const_iterator last) {
        -:  746:    if (first == last) {
        -:  747:      return mutable_iterator(first);
        -:  748:    }
        -:  749:
        -:  750:    tsl_oh_assert(std::distance(first, last) > 0);
        -:  751:    const std::size_t start_index = iterator_to_index(first);
        -:  752:    const std::size_t nb_values = std::size_t(std::distance(first, last));
        -:  753:    const std::size_t end_index = start_index + nb_values;
        -:  754:
        -:  755:    // Delete all values
        -:  756:#ifdef TSL_OH_NO_CONTAINER_ERASE_CONST_ITERATOR
        -:  757:    auto next_it = m_values.erase(mutable_iterator(first).m_iterator,
        -:  758:                                  mutable_iterator(last).m_iterator);
        -:  759:#else
        -:  760:    auto next_it = m_values.erase(first.m_iterator, last.m_iterator);
        -:  761:#endif
        -:  762:
        -:  763:    /*
        -:  764:     * Mark the buckets corresponding to the values as empty and do a backward
        -:  765:     * shift.
        -:  766:     *
        -:  767:     * Also, the erase operation on m_values has shifted all the values on the
        -:  768:     * right of last.m_iterator. Adapt the indexes for these values.
        -:  769:     */
        -:  770:    std::size_t ibucket = 0;
        -:  771:    while (ibucket < m_buckets_data.size()) {
        -:  772:      if (m_buckets[ibucket].empty()) {
        -:  773:        ibucket++;
        -:  774:      } else if (m_buckets[ibucket].index() >= start_index &&
        -:  775:                 m_buckets[ibucket].index() < end_index) {
        -:  776:        m_buckets[ibucket].clear();
        -:  777:        backward_shift(ibucket);
        -:  778:        // Don't increment ibucket, backward_shift may have replaced current
        -:  779:        // bucket.
        -:  780:      } else if (m_buckets[ibucket].index() >= end_index) {
        -:  781:        m_buckets[ibucket].set_index(
        -:  782:            index_type(m_buckets[ibucket].index() - nb_values));
        -:  783:        ibucket++;
        -:  784:      } else {
        -:  785:        ibucket++;
        -:  786:      }
        -:  787:    }
        -:  788:
        -:  789:    return iterator(next_it);
        -:  790:  }
        -:  791:
        -:  792:  template <class K>
        -:  793:  size_type erase(const K& key) {
        -:  794:    return erase(key, hash_key(key));
        -:  795:  }
        -:  796:
        -:  797:  template <class K>
        -:  798:  size_type erase(const K& key, std::size_t hash) {
        -:  799:    return erase_impl(key, hash);
        -:  800:  }
        -:  801:
        -:  802:  void swap(ordered_hash& other) {
        -:  803:    using std::swap;
        -:  804:
        -:  805:    swap(static_cast<Hash&>(*this), static_cast<Hash&>(other));
        -:  806:    swap(static_cast<KeyEqual&>(*this), static_cast<KeyEqual&>(other));
        -:  807:    swap(m_buckets_data, other.m_buckets_data);
        -:  808:    swap(m_buckets, other.m_buckets);
        -:  809:    swap(m_hash_mask, other.m_hash_mask);
        -:  810:    swap(m_values, other.m_values);
        -:  811:    swap(m_load_threshold, other.m_load_threshold);
        -:  812:    swap(m_max_load_factor, other.m_max_load_factor);
        -:  813:    swap(m_grow_on_next_insert, other.m_grow_on_next_insert);
        -:  814:  }
        -:  815:
        -:  816:  /*
        -:  817:   * Lookup
        -:  818:   */
        -:  819:  template <class K, class U = ValueSelect,
        -:  820:            typename std::enable_if<has_mapped_type<U>::value>::type* = nullptr>
        -:  821:  typename U::value_type& at(const K& key) {
        -:  822:    return at(key, hash_key(key));
        -:  823:  }
        -:  824:
        -:  825:  template <class K, class U = ValueSelect,
        -:  826:            typename std::enable_if<has_mapped_type<U>::value>::type* = nullptr>
        -:  827:  typename U::value_type& at(const K& key, std::size_t hash) {
        -:  828:    return const_cast<typename U::value_type&>(
        -:  829:        static_cast<const ordered_hash*>(this)->at(key, hash));
        -:  830:  }
        -:  831:
        -:  832:  template <class K, class U = ValueSelect,
        -:  833:            typename std::enable_if<has_mapped_type<U>::value>::type* = nullptr>
        -:  834:  const typename U::value_type& at(const K& key) const {
        -:  835:    return at(key, hash_key(key));
        -:  836:  }
        -:  837:
        -:  838:  template <class K, class U = ValueSelect,
        -:  839:            typename std::enable_if<has_mapped_type<U>::value>::type* = nullptr>
        -:  840:  const typename U::value_type& at(const K& key, std::size_t hash) const {
        -:  841:    auto it = find(key, hash);
        -:  842:    if (it != end()) {
        -:  843:      return it.value();
        -:  844:    } else {
        -:  845:      TSL_OH_THROW_OR_TERMINATE(std::out_of_range, "Couldn't find the key.");
        -:  846:    }
        -:  847:  }
        -:  848:
        -:  849:  template <class K, class U = ValueSelect,
        -:  850:            typename std::enable_if<has_mapped_type<U>::value>::type* = nullptr>
function _ZN3tsl19detail_ordered_hash12ordered_hashISt4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ENS_11ordered_mapIS8_S8_St4hashIS8_ESt8equal_toIS8_ESaIS9_ESt5dequeIS9_SF_EjE9KeySelectENSI_11ValueSelectESC_SE_SF_SH_jEixIRKS8_SK_LPv0EEERNT0_10value_typeEOT_ called 0 returned 0% blocks executed 0%
    #####:  851:  typename U::value_type& operator[](K&& key) {
    #####:  852:    return try_emplace(std::forward<K>(key)).first.value();
    %%%%%:  852-block 2
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:  852-block 4
call    4 never executed
    %%%%%:  852-block 6
        -:  853:  }
        -:  854:
        -:  855:  template <class K>
        -:  856:  size_type count(const K& key) const {
        -:  857:    return count(key, hash_key(key));
        -:  858:  }
        -:  859:
        -:  860:  template <class K>
        -:  861:  size_type count(const K& key, std::size_t hash) const {
        -:  862:    if (find(key, hash) == cend()) {
        -:  863:      return 0;
        -:  864:    } else {
        -:  865:      return 1;
        -:  866:    }
        -:  867:  }
        -:  868:
        -:  869:  template <class K>
        -:  870:  iterator find(const K& key) {
        -:  871:    return find(key, hash_key(key));
        -:  872:  }
        -:  873:
        -:  874:  template <class K>
        -:  875:  iterator find(const K& key, std::size_t hash) {
        -:  876:    auto it_bucket = find_key(key, hash);
        -:  877:    return (it_bucket != m_buckets_data.end())
        -:  878:               ? iterator(m_values.begin() + it_bucket->index())
        -:  879:               : end();
        -:  880:  }
        -:  881:
        -:  882:  template <class K>
        -:  883:  const_iterator find(const K& key) const {
        -:  884:    return find(key, hash_key(key));
        -:  885:  }
        -:  886:
        -:  887:  template <class K>
function _ZNK3tsl19detail_ordered_hash12ordered_hashISt4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ENS_11ordered_mapIS8_S8_St4hashIS8_ESt8equal_toIS8_ESaIS9_ESt5dequeIS9_SF_EjE9KeySelectENSI_11ValueSelectESC_SE_SF_SH_jE4findIS8_EENSL_16ordered_iteratorILb1EEERKT_m called 0 returned 0% blocks executed 0%
    #####:  888:  const_iterator find(const K& key, std::size_t hash) const {
    #####:  889:    auto it_bucket = find_key(key, hash);
    %%%%%:  889-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  890:    return (it_bucket != m_buckets_data.cend())
    %%%%%:  890-block 3
call    0 never executed
call    1 never executed
    #####:  891:               ? const_iterator(m_values.begin() + it_bucket->index())
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  891-block 6
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    %%%%%:  891-block 13
    #####:  892:               : end();
call    0 never executed
    %%%%%:  892-block 11
call    1 never executed
    %%%%%:  892-block 14
        -:  893:  }
        -:  894:
        -:  895:  template <class K>
function _ZNK3tsl19detail_ordered_hash12ordered_hashISt4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ENS_11ordered_mapIS8_S8_St4hashIS8_ESt8equal_toIS8_ESaIS9_ESt5dequeIS9_SF_EjE9KeySelectENSI_11ValueSelectESC_SE_SF_SH_jE8containsIS8_EEbRKT_ called 0 returned 0% blocks executed 0%
    #####:  896:  bool contains(const K& key) const {
    #####:  897:    return contains(key, hash_key(key));
    %%%%%:  897-block 2
call    0 never executed
call    1 never executed
        -:  898:  }
        -:  899:
        -:  900:  template <class K>
function _ZNK3tsl19detail_ordered_hash12ordered_hashISt4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ENS_11ordered_mapIS8_S8_St4hashIS8_ESt8equal_toIS8_ESaIS9_ESt5dequeIS9_SF_EjE9KeySelectENSI_11ValueSelectESC_SE_SF_SH_jE8containsIS8_EEbRKT_m called 0 returned 0% blocks executed 0%
    #####:  901:  bool contains(const K& key, std::size_t hash) const {
    #####:  902:    return find(key, hash) != cend();
    %%%%%:  902-block 2
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:  902-block 4
call    4 never executed
    %%%%%:  902-block 6
    $$$$$:  902-block 7
        -:  903:  }
        -:  904:
        -:  905:  template <class K>
        -:  906:  std::pair<iterator, iterator> equal_range(const K& key) {
        -:  907:    return equal_range(key, hash_key(key));
        -:  908:  }
        -:  909:
        -:  910:  template <class K>
        -:  911:  std::pair<iterator, iterator> equal_range(const K& key, std::size_t hash) {
        -:  912:    iterator it = find(key, hash);
        -:  913:    return std::make_pair(it, (it == end()) ? it : std::next(it));
        -:  914:  }
        -:  915:
        -:  916:  template <class K>
        -:  917:  std::pair<const_iterator, const_iterator> equal_range(const K& key) const {
        -:  918:    return equal_range(key, hash_key(key));
        -:  919:  }
        -:  920:
        -:  921:  template <class K>
        -:  922:  std::pair<const_iterator, const_iterator> equal_range(
        -:  923:      const K& key, std::size_t hash) const {
        -:  924:    const_iterator it = find(key, hash);
        -:  925:    return std::make_pair(it, (it == cend()) ? it : std::next(it));
        -:  926:  }
        -:  927:
        -:  928:  /*
        -:  929:   * Bucket interface
        -:  930:   */
function _ZNK3tsl19detail_ordered_hash12ordered_hashISt4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ENS_11ordered_mapIS8_S8_St4hashIS8_ESt8equal_toIS8_ESaIS9_ESt5dequeIS9_SF_EjE9KeySelectENSI_11ValueSelectESC_SE_SF_SH_jE12bucket_countEv called 0 returned 0% blocks executed 0%
    #####:  931:  size_type bucket_count() const { return m_buckets_data.size(); }
    %%%%%:  931-block 2
call    0 never executed
        -:  932:
function _ZNK3tsl19detail_ordered_hash12ordered_hashISt4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ENS_11ordered_mapIS8_S8_St4hashIS8_ESt8equal_toIS8_ESaIS9_ESt5dequeIS9_SF_EjE9KeySelectENSI_11ValueSelectESC_SE_SF_SH_jE16max_bucket_countEv called 0 returned 0% blocks executed 0%
    #####:  933:  size_type max_bucket_count() const { return m_buckets_data.max_size(); }
    %%%%%:  933-block 2
call    0 never executed
        -:  934:
        -:  935:  /*
        -:  936:   *  Hash policy
        -:  937:   */
function _ZNK3tsl19detail_ordered_hash12ordered_hashISt4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ENS_11ordered_mapIS8_S8_St4hashIS8_ESt8equal_toIS8_ESaIS9_ESt5dequeIS9_SF_EjE9KeySelectENSI_11ValueSelectESC_SE_SF_SH_jE11load_factorEv called 0 returned 0% blocks executed 0%
    #####:  938:  float load_factor() const {
    #####:  939:    if (bucket_count() == 0) {
    %%%%%:  939-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:  940:      return 0;
    %%%%%:  940-block 4
        -:  941:    }
        -:  942:
    #####:  943:    return float(size()) / float(bucket_count());
    %%%%%:  943-block 5
call    0 never executed
call    1 never executed
        -:  944:  }
        -:  945:
        -:  946:  float max_load_factor() const { return m_max_load_factor; }
        -:  947:
function _ZN3tsl19detail_ordered_hash12ordered_hashISt4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ENS_11ordered_mapIS8_S8_St4hashIS8_ESt8equal_toIS8_ESaIS9_ESt5dequeIS9_SF_EjE9KeySelectENSI_11ValueSelectESC_SE_SF_SH_jE15max_load_factorEf called 0 returned 0% blocks executed 0%
    #####:  948:  void max_load_factor(float ml) {
    #####:  949:    m_max_load_factor = clamp(ml, float(MAX_LOAD_FACTOR__MINIMUM),
    $$$$$:  949-block 5
    #####:  950:                              float(MAX_LOAD_FACTOR__MAXIMUM));
    %%%%%:  950-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:  951:
    #####:  952:    m_max_load_factor = ml;
    #####:  953:    m_load_threshold = size_type(float(bucket_count()) * m_max_load_factor);
    %%%%%:  953-block 3
call    0 never executed
    #####:  954:  }
        -:  955:
        -:  956:  void rehash(size_type count) {
        -:  957:    count = std::max(count,
        -:  958:                     size_type(std::ceil(float(size()) / max_load_factor())));
        -:  959:    rehash_impl(count);
        -:  960:  }
        -:  961:
        -:  962:  void reserve(size_type count) {
        -:  963:    reserve_space_for_values(count);
        -:  964:
        -:  965:    count = size_type(std::ceil(float(count) / max_load_factor()));
        -:  966:    rehash(count);
        -:  967:  }
        -:  968:
        -:  969:  /*
        -:  970:   * Observers
        -:  971:   */
        -:  972:  hasher hash_function() const { return static_cast<const Hash&>(*this); }
        -:  973:
        -:  974:  key_equal key_eq() const { return static_cast<const KeyEqual&>(*this); }
        -:  975:
        -:  976:  /*
        -:  977:   * Other
        -:  978:   */
        -:  979:  iterator mutable_iterator(const_iterator pos) {
        -:  980:    return iterator(m_values.begin() + iterator_to_index(pos));
        -:  981:  }
        -:  982:
        -:  983:  iterator nth(size_type index) {
        -:  984:    tsl_oh_assert(index <= size());
        -:  985:    return iterator(m_values.begin() + index);
        -:  986:  }
        -:  987:
        -:  988:  const_iterator nth(size_type index) const {
        -:  989:    tsl_oh_assert(index <= size());
        -:  990:    return const_iterator(m_values.cbegin() + index);
        -:  991:  }
        -:  992:
        -:  993:  const_reference front() const {
        -:  994:    tsl_oh_assert(!empty());
        -:  995:    return m_values.front();
        -:  996:  }
        -:  997:
        -:  998:  const_reference back() const {
        -:  999:    tsl_oh_assert(!empty());
        -: 1000:    return m_values.back();
        -: 1001:  }
        -: 1002:
        -: 1003:  const values_container_type& values_container() const noexcept {
        -: 1004:    return m_values;
        -: 1005:  }
        -: 1006:
        -: 1007:  values_container_type release() {
        -: 1008:    values_container_type ret;
        -: 1009:    for (auto& bucket : m_buckets_data) {
        -: 1010:      bucket.clear();
        -: 1011:    }
        -: 1012:    m_grow_on_next_insert = false;
        -: 1013:    std::swap(ret, m_values);
        -: 1014:    return ret;
        -: 1015:  }
        -: 1016:
        -: 1017:  template <class U = values_container_type,
        -: 1018:            typename std::enable_if<is_vector<U>::value>::type* = nullptr>
        -: 1019:  const typename values_container_type::value_type* data() const noexcept {
        -: 1020:    return m_values.data();
        -: 1021:  }
        -: 1022:
        -: 1023:  template <class U = values_container_type,
        -: 1024:            typename std::enable_if<is_vector<U>::value>::type* = nullptr>
        -: 1025:  size_type capacity() const noexcept {
        -: 1026:    return m_values.capacity();
        -: 1027:  }
        -: 1028:
        -: 1029:  void shrink_to_fit() { m_values.shrink_to_fit(); }
        -: 1030:
        -: 1031:  template <typename P>
        -: 1032:  std::pair<iterator, bool> insert_at_position(const_iterator pos, P&& value) {
        -: 1033:    return insert_at_position_impl(pos.m_iterator, KeySelect()(value),
        -: 1034:                                   std::forward<P>(value));
        -: 1035:  }
        -: 1036:
        -: 1037:  template <class... Args>
        -: 1038:  std::pair<iterator, bool> emplace_at_position(const_iterator pos,
        -: 1039:                                                Args&&... args) {
        -: 1040:    return insert_at_position(pos, value_type(std::forward<Args>(args)...));
        -: 1041:  }
        -: 1042:
        -: 1043:  template <class K, class... Args>
        -: 1044:  std::pair<iterator, bool> try_emplace_at_position(const_iterator pos, K&& key,
        -: 1045:                                                    Args&&... value_args) {
        -: 1046:    return insert_at_position_impl(
        -: 1047:        pos.m_iterator, key, std::piecewise_construct,
        -: 1048:        std::forward_as_tuple(std::forward<K>(key)),
        -: 1049:        std::forward_as_tuple(std::forward<Args>(value_args)...));
        -: 1050:  }
        -: 1051:
        -: 1052:  void pop_back() {
        -: 1053:    tsl_oh_assert(!empty());
        -: 1054:    erase(std::prev(end()));
        -: 1055:  }
        -: 1056:
        -: 1057:  /**
        -: 1058:   * Here to avoid `template<class K> size_type unordered_erase(const K& key)`
        -: 1059:   * being used when we use a iterator instead of a const_iterator.
        -: 1060:   */
        -: 1061:  iterator unordered_erase(iterator pos) {
        -: 1062:    return unordered_erase(const_iterator(pos));
        -: 1063:  }
        -: 1064:
        -: 1065:  iterator unordered_erase(const_iterator pos) {
        -: 1066:    const std::size_t index_erase = iterator_to_index(pos);
        -: 1067:    unordered_erase(pos.key());
        -: 1068:
        -: 1069:    /*
        -: 1070:     * One element was deleted, index_erase now points to the next element as
        -: 1071:     * the elements after the deleted value were shifted to the left in m_values
        -: 1072:     * (will be end() if we deleted the last element).
        -: 1073:     */
        -: 1074:    return begin() + index_erase;
        -: 1075:  }
        -: 1076:
        -: 1077:  template <class K>
        -: 1078:  size_type unordered_erase(const K& key) {
        -: 1079:    return unordered_erase(key, hash_key(key));
        -: 1080:  }
        -: 1081:
        -: 1082:  template <class K>
        -: 1083:  size_type unordered_erase(const K& key, std::size_t hash) {
        -: 1084:    auto it_bucket_key = find_key(key, hash);
        -: 1085:    if (it_bucket_key == m_buckets_data.end()) {
        -: 1086:      return 0;
        -: 1087:    }
        -: 1088:
        -: 1089:    /**
        -: 1090:     * If we are not erasing the last element in m_values, we swap
        -: 1091:     * the element we are erasing with the last element. We then would
        -: 1092:     * just have to do a pop_back() in m_values.
        -: 1093:     */
        -: 1094:    if (!compare_keys(key, KeySelect()(back()))) {
        -: 1095:      auto it_bucket_last_elem =
        -: 1096:          find_key(KeySelect()(back()), hash_key(KeySelect()(back())));
        -: 1097:      tsl_oh_assert(it_bucket_last_elem != m_buckets_data.end());
        -: 1098:      tsl_oh_assert(it_bucket_last_elem->index() == m_values.size() - 1);
        -: 1099:
        -: 1100:      using std::swap;
        -: 1101:      swap(m_values[it_bucket_key->index()],
        -: 1102:           m_values[it_bucket_last_elem->index()]);
        -: 1103:      swap(it_bucket_key->index_ref(), it_bucket_last_elem->index_ref());
        -: 1104:    }
        -: 1105:
        -: 1106:    erase_value_from_bucket(it_bucket_key);
        -: 1107:
        -: 1108:    return 1;
        -: 1109:  }
        -: 1110:
        -: 1111:  /**
        -: 1112:   * Remove all entries for which the given predicate matches.
        -: 1113:   */
        -: 1114:  template <class Predicate>
        -: 1115:  size_type erase_if(Predicate& pred) {
        -: 1116:    // Get the bucket associated with the given element.
        -: 1117:    auto get_bucket = [this](typename values_container_type::iterator it) {
        -: 1118:      return find_key(KeySelect()(*it), hash_key(KeySelect()(*it)));
        -: 1119:    };
        -: 1120:    // Clear a bucket without touching the container holding the values.
        -: 1121:    auto clear_bucket = [this](typename buckets_container_type::iterator it) {
        -: 1122:      tsl_oh_assert(it != m_buckets_data.end());
        -: 1123:      it->clear();
        -: 1124:      backward_shift(std::size_t(std::distance(m_buckets_data.begin(), it)));
        -: 1125:    };
        -: 1126:    // Ensure that only const references are passed to the predicate.
        -: 1127:    auto cpred = [&pred](typename values_container_type::const_reference x) {
        -: 1128:      return pred(x);
        -: 1129:    };
        -: 1130:
        -: 1131:    // Find first element that matches the predicate.
        -: 1132:    const auto last = m_values.end();
        -: 1133:    auto first = std::find_if(m_values.begin(), last, cpred);
        -: 1134:    if (first == last) {
        -: 1135:      return 0;
        -: 1136:    }
        -: 1137:    // Remove all elements that match the predicate.
        -: 1138:    clear_bucket(get_bucket(first));
        -: 1139:    for (auto it = std::next(first); it != last; ++it) {
        -: 1140:      auto it_bucket = get_bucket(it);
        -: 1141:      if (cpred(*it)) {
        -: 1142:        clear_bucket(it_bucket);
        -: 1143:      } else {
        -: 1144:        it_bucket->set_index(
        -: 1145:            static_cast<index_type>(std::distance(m_values.begin(), first)));
        -: 1146:        *first++ = std::move(*it);
        -: 1147:      }
        -: 1148:    }
        -: 1149:    // Resize the vector and return the number of deleted elements.
        -: 1150:    auto deleted = static_cast<size_type>(std::distance(first, last));
        -: 1151:    m_values.erase(first, last);
        -: 1152:    return deleted;
        -: 1153:  }
        -: 1154:
        -: 1155:  template <class Serializer>
        -: 1156:  void serialize(Serializer& serializer) const {
        -: 1157:    serialize_impl(serializer);
        -: 1158:  }
        -: 1159:
        -: 1160:  template <class Deserializer>
        -: 1161:  void deserialize(Deserializer& deserializer, bool hash_compatible) {
        -: 1162:    deserialize_impl(deserializer, hash_compatible);
        -: 1163:  }
        -: 1164:
        -: 1165:  friend bool operator==(const ordered_hash& lhs, const ordered_hash& rhs) {
        -: 1166:    return lhs.m_values == rhs.m_values;
        -: 1167:  }
        -: 1168:
        -: 1169:  friend bool operator!=(const ordered_hash& lhs, const ordered_hash& rhs) {
        -: 1170:    return lhs.m_values != rhs.m_values;
        -: 1171:  }
        -: 1172:
        -: 1173:  friend bool operator<(const ordered_hash& lhs, const ordered_hash& rhs) {
        -: 1174:    return lhs.m_values < rhs.m_values;
        -: 1175:  }
        -: 1176:
        -: 1177:  friend bool operator<=(const ordered_hash& lhs, const ordered_hash& rhs) {
        -: 1178:    return lhs.m_values <= rhs.m_values;
        -: 1179:  }
        -: 1180:
        -: 1181:  friend bool operator>(const ordered_hash& lhs, const ordered_hash& rhs) {
        -: 1182:    return lhs.m_values > rhs.m_values;
        -: 1183:  }
        -: 1184:
        -: 1185:  friend bool operator>=(const ordered_hash& lhs, const ordered_hash& rhs) {
        -: 1186:    return lhs.m_values >= rhs.m_values;
        -: 1187:  }
        -: 1188:
        -: 1189: private:
        -: 1190:  template <class K>
function _ZNK3tsl19detail_ordered_hash12ordered_hashISt4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ENS_11ordered_mapIS8_S8_St4hashIS8_ESt8equal_toIS8_ESaIS9_ESt5dequeIS9_SF_EjE9KeySelectENSI_11ValueSelectESC_SE_SF_SH_jE8hash_keyIS8_EEmRKT_ called 0 returned 0% blocks executed 0%
    #####: 1191:  std::size_t hash_key(const K& key) const {
    #####: 1192:    return Hash::operator()(key);
    %%%%%: 1192-block 2
call    0 never executed
        -: 1193:  }
        -: 1194:
        -: 1195:  template <class K1, class K2>
function _ZNK3tsl19detail_ordered_hash12ordered_hashISt4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ENS_11ordered_mapIS8_S8_St4hashIS8_ESt8equal_toIS8_ESaIS9_ESt5dequeIS9_SF_EjE9KeySelectENSI_11ValueSelectESC_SE_SF_SH_jE12compare_keysIS8_S8_EEbRKT_RKT0_ called 0 returned 0% blocks executed 0%
    #####: 1196:  bool compare_keys(const K1& key1, const K2& key2) const {
    #####: 1197:    return KeyEqual::operator()(key1, key2);
    %%%%%: 1197-block 2
call    0 never executed
        -: 1198:  }
        -: 1199:
        -: 1200:  template <class K>
        -: 1201:  typename buckets_container_type::iterator find_key(const K& key,
        -: 1202:                                                     std::size_t hash) {
        -: 1203:    auto it = static_cast<const ordered_hash*>(this)->find_key(key, hash);
        -: 1204:    return m_buckets_data.begin() + std::distance(m_buckets_data.cbegin(), it);
        -: 1205:  }
        -: 1206:
        -: 1207:  /**
        -: 1208:   * Return bucket which has the key 'key' or m_buckets_data.end() if none.
        -: 1209:   *
        -: 1210:   * From the bucket_for_hash, search for the value until we either find an
        -: 1211:   * empty bucket or a bucket which has a value with a distance from its ideal
        -: 1212:   * bucket longer than the probe length for the value we are looking for.
        -: 1213:   */
        -: 1214:  template <class K>
function _ZNK3tsl19detail_ordered_hash12ordered_hashISt4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ENS_11ordered_mapIS8_S8_St4hashIS8_ESt8equal_toIS8_ESaIS9_ESt5dequeIS9_SF_EjE9KeySelectENSI_11ValueSelectESC_SE_SF_SH_jE8find_keyIS8_EEN9__gnu_cxx17__normal_iteratorIPKNS0_12bucket_entryIjEESt6vectorISQ_SaISQ_EEEERKT_m called 0 returned 0% blocks executed 0%
    #####: 1215:  typename buckets_container_type::const_iterator find_key(
        -: 1216:      const K& key, std::size_t hash) const {
    #####: 1217:    for (std::size_t ibucket = bucket_for_hash(hash),
    %%%%%: 1217-block 2
call    0 never executed
    #####: 1218:                     dist_from_ideal_bucket = 0;
    #####: 1219:         ; ibucket = next_bucket(ibucket), dist_from_ideal_bucket++) {
    %%%%%: 1219-block 24
call    0 never executed
    #####: 1220:      if (m_buckets[ibucket].empty()) {
    %%%%%: 1220-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 1221:        return m_buckets_data.end();
    %%%%%: 1221-block 6
call    0 never executed
    #####: 1222:      } else if (m_buckets[ibucket].truncated_hash() ==
    %%%%%: 1222-block 7
call    0 never executed
    #####: 1223:                     bucket_entry::truncate_hash(hash) &&
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 1223-block 15
    %%%%%: 1223-block 16
    #####: 1224:                 compare_keys(
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1224-block 14
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 1225:                     key, KeySelect()(m_values[m_buckets[ibucket].index()]))) {
    %%%%%: 1225-block 10
call    0 never executed
call    1 never executed
call    2 never executed
    %%%%%: 1225-block 17
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 1226:        return m_buckets_data.begin() + ibucket;
    %%%%%: 1226-block 18
call    0 never executed
call    1 never executed
    #####: 1227:      } else if (dist_from_ideal_bucket > distance_from_ideal_bucket(ibucket)) {
    %%%%%: 1227-block 21
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 1228:        return m_buckets_data.end();
    %%%%%: 1228-block 23
call    0 never executed
        -: 1229:      }
        -: 1230:    }
        -: 1231:  }
        -: 1232:
function _ZN3tsl19detail_ordered_hash12ordered_hashISt4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ENS_11ordered_mapIS8_S8_St4hashIS8_ESt8equal_toIS8_ESaIS9_ESt5dequeIS9_SF_EjE9KeySelectENSI_11ValueSelectESC_SE_SF_SH_jE11rehash_implEm called 0 returned 0% blocks executed 0%
    #####: 1233:  void rehash_impl(size_type bucket_count) {
        -: 1234:    tsl_oh_assert(bucket_count >=
        -: 1235:                  size_type(std::ceil(float(size()) / max_load_factor())));
        -: 1236:
    #####: 1237:    if (bucket_count > max_bucket_count()) {
    %%%%%: 1237-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 1238:      TSL_OH_THROW_OR_TERMINATE(std::length_error,
    %%%%%: 1238-block 4
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 1238-block 6
call    4 never executed
    $$$$$: 1238-block 57
call    5 never executed
        -: 1239:                                "The map exceeds its maximum size.");
        -: 1240:    }
        -: 1241:
    #####: 1242:    if (bucket_count > 0) {
    %%%%%: 1242-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1243:      bucket_count = round_up_to_power_of_two(bucket_count);
    %%%%%: 1243-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1243-block 9
        -: 1244:    }
        -: 1245:
    #####: 1246:    if (bucket_count == this->bucket_count()) {
    %%%%%: 1246-block 10
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 1247:      return;
    %%%%%: 1247-block 12
        -: 1248:    }
        -: 1249:
    #####: 1250:    buckets_container_type old_buckets(bucket_count);
    %%%%%: 1250-block 15
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    $$$$$: 1250-block 61
    #####: 1251:    m_buckets_data.swap(old_buckets);
    %%%%%: 1251-block 17
call    0 never executed
    #####: 1252:    m_buckets = m_buckets_data.empty() ? static_empty_bucket_ptr()
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 1252-block 20
call    3 never executed
    #####: 1253:                                       : m_buckets_data.data();
    %%%%%: 1253-block 21
call    0 never executed
        -: 1254:    // Everything should be noexcept from here.
        -: 1255:
    #####: 1256:    m_hash_mask = (bucket_count > 0) ? (bucket_count - 1) : 0;
    %%%%%: 1256-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1256-block 23
    %%%%%: 1256-block 24
    #####: 1257:    this->max_load_factor(m_max_load_factor);
    %%%%%: 1257-block 25
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1258:    m_grow_on_next_insert = false;
        -: 1259:
    #####: 1260:    for (const bucket_entry& old_bucket : old_buckets) {
    %%%%%: 1260-block 26
call    0 never executed
call    1 never executed
    %%%%%: 1260-block 28
call    2 never executed
    %%%%%: 1260-block 51
call    3 never executed
    %%%%%: 1260-block 52
call    4 never executed
branch  5 never executed
branch  6 never executed (fallthrough)
    #####: 1261:      if (old_bucket.empty()) {
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 1262:        continue;
    %%%%%: 1262-block 31
        -: 1263:      }
        -: 1264:
    #####: 1265:      truncated_hash_type insert_hash = old_bucket.truncated_hash();
    %%%%%: 1265-block 32
call    0 never executed
    #####: 1266:      index_type insert_index = old_bucket.index();
call    0 never executed
        -: 1267:
    #####: 1268:      for (std::size_t ibucket = bucket_for_hash(insert_hash),
call    0 never executed
    #####: 1269:                       dist_from_ideal_bucket = 0;
    #####: 1270:           ; ibucket = next_bucket(ibucket), dist_from_ideal_bucket++) {
    %%%%%: 1270-block 47
call    0 never executed
    #####: 1271:        if (m_buckets[ibucket].empty()) {
    %%%%%: 1271-block 36
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 1272:          m_buckets[ibucket].set_index(insert_index);
    %%%%%: 1272-block 38
call    0 never executed
    #####: 1273:          m_buckets[ibucket].set_hash(insert_hash);
call    0 never executed
    #####: 1274:          break;
        -: 1275:        }
        -: 1276:
    #####: 1277:        const std::size_t distance = distance_from_ideal_bucket(ibucket);
    %%%%%: 1277-block 40
call    0 never executed
    #####: 1278:        if (dist_from_ideal_bucket > distance) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1279:          std::swap(insert_index, m_buckets[ibucket].index_ref());
    %%%%%: 1279-block 42
call    0 never executed
call    1 never executed
    #####: 1280:          std::swap(insert_hash, m_buckets[ibucket].truncated_hash_ref());
call    0 never executed
call    1 never executed
    #####: 1281:          dist_from_ideal_bucket = distance;
        -: 1282:        }
        -: 1283:      }
        -: 1284:    }
    #####: 1285:  }
    %%%%%: 1285-block 54
call    0 never executed
    $$$$$: 1285-block 62
call    1 never executed
        -: 1286:
        -: 1287:  template <class T = values_container_type,
        -: 1288:            typename std::enable_if<is_vector<T>::value>::type* = nullptr>
        -: 1289:  void reserve_space_for_values(size_type count) {
        -: 1290:    m_values.reserve(count);
        -: 1291:  }
        -: 1292:
        -: 1293:  template <class T = values_container_type,
        -: 1294:            typename std::enable_if<!is_vector<T>::value>::type* = nullptr>
        -: 1295:  void reserve_space_for_values(size_type /*count*/) {}
        -: 1296:
        -: 1297:  /**
        -: 1298:   * Swap the empty bucket with the values on its right until we cross another
        -: 1299:   * empty bucket or if the other bucket has a distance_from_ideal_bucket == 0.
        -: 1300:   */
        -: 1301:  void backward_shift(std::size_t empty_ibucket) noexcept {
        -: 1302:    tsl_oh_assert(m_buckets[empty_ibucket].empty());
        -: 1303:
        -: 1304:    std::size_t previous_ibucket = empty_ibucket;
        -: 1305:    for (std::size_t current_ibucket = next_bucket(previous_ibucket);
        -: 1306:         !m_buckets[current_ibucket].empty() &&
        -: 1307:         distance_from_ideal_bucket(current_ibucket) > 0;
        -: 1308:         previous_ibucket = current_ibucket,
        -: 1309:                     current_ibucket = next_bucket(current_ibucket)) {
        -: 1310:      std::swap(m_buckets[current_ibucket], m_buckets[previous_ibucket]);
        -: 1311:    }
        -: 1312:  }
        -: 1313:
        -: 1314:  void erase_value_from_bucket(
        -: 1315:      typename buckets_container_type::iterator it_bucket) {
        -: 1316:    tsl_oh_assert(it_bucket != m_buckets_data.end() && !it_bucket->empty());
        -: 1317:
        -: 1318:    m_values.erase(m_values.begin() + it_bucket->index());
        -: 1319:
        -: 1320:    /*
        -: 1321:     * m_values.erase shifted all the values on the right of the erased value,
        -: 1322:     * shift the indexes by -1 in the buckets array for these values.
        -: 1323:     */
        -: 1324:    if (it_bucket->index() != m_values.size()) {
        -: 1325:      shift_indexes_in_buckets(it_bucket->index() + 1, -1);
        -: 1326:    }
        -: 1327:
        -: 1328:    // Mark the bucket as empty and do a backward shift of the values on the
        -: 1329:    // right
        -: 1330:    it_bucket->clear();
        -: 1331:    backward_shift(
        -: 1332:        std::size_t(std::distance(m_buckets_data.begin(), it_bucket)));
        -: 1333:  }
        -: 1334:
        -: 1335:  /**
        -: 1336:   * Shift any index >= index_above_or_equal in m_buckets_data by delta.
        -: 1337:   *
        -: 1338:   * delta must be equal to 1 or -1.
        -: 1339:   */
        -: 1340:  void shift_indexes_in_buckets(index_type index_above_or_equal,
        -: 1341:                                int delta) noexcept {
        -: 1342:    tsl_oh_assert(delta == 1 || delta == -1);
        -: 1343:
        -: 1344:    for (bucket_entry& bucket : m_buckets_data) {
        -: 1345:      if (!bucket.empty() && bucket.index() >= index_above_or_equal) {
        -: 1346:        tsl_oh_assert(delta >= 0 ||
        -: 1347:                      bucket.index() >= static_cast<index_type>(-delta));
        -: 1348:        tsl_oh_assert(delta <= 0 ||
        -: 1349:                      (bucket_entry::max_size() - bucket.index()) >=
        -: 1350:                          static_cast<index_type>(delta));
        -: 1351:        bucket.set_index(static_cast<index_type>(bucket.index() + delta));
        -: 1352:      }
        -: 1353:    }
        -: 1354:  }
        -: 1355:
        -: 1356:  template <class K>
        -: 1357:  size_type erase_impl(const K& key, std::size_t hash) {
        -: 1358:    auto it_bucket = find_key(key, hash);
        -: 1359:    if (it_bucket != m_buckets_data.end()) {
        -: 1360:      erase_value_from_bucket(it_bucket);
        -: 1361:
        -: 1362:      return 1;
        -: 1363:    } else {
        -: 1364:      return 0;
        -: 1365:    }
        -: 1366:  }
        -: 1367:
        -: 1368:  /**
        -: 1369:   * Insert the element at the end.
        -: 1370:   */
        -: 1371:  template <class K, class... Args>
function _ZN3tsl19detail_ordered_hash12ordered_hashISt4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ENS_11ordered_mapIS8_S8_St4hashIS8_ESt8equal_toIS8_ESaIS9_ESt5dequeIS9_SF_EjE9KeySelectENSI_11ValueSelectESC_SE_SF_SH_jE11insert_implIS8_JRKSt21piecewise_construct_tSt5tupleIJRKS8_EESQ_IJEEEEES2_INSL_16ordered_iteratorILb0EEEbERKT_DpOT0_ called 0 returned 0% blocks executed 0%
    #####: 1372:  std::pair<iterator, bool> insert_impl(const K& key,
        -: 1373:                                        Args&&... value_type_args) {
    #####: 1374:    const std::size_t hash = hash_key(key);
    %%%%%: 1374-block 2
call    0 never executed
        -: 1375:
    #####: 1376:    std::size_t ibucket = bucket_for_hash(hash);
call    0 never executed
    #####: 1377:    std::size_t dist_from_ideal_bucket = 0;
        -: 1378:
    #####: 1379:    while (!m_buckets[ibucket].empty() &&
    %%%%%: 1379-block 23
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 1379-block 27
    %%%%%: 1379-block 28
    %%%%%: 1379-block 29
branch  5 never executed
branch  6 never executed (fallthrough)
    #####: 1380:           dist_from_ideal_bucket <= distance_from_ideal_bucket(ibucket)) {
    %%%%%: 1380-block 25
call    0 never executed
    #####: 1381:      if (m_buckets[ibucket].truncated_hash() ==
    %%%%%: 1381-block 5
call    0 never executed
    #####: 1382:              bucket_entry::truncate_hash(hash) &&
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 1382-block 13
    %%%%%: 1382-block 14
    #####: 1383:          compare_keys(key,
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1383-block 12
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 1384:                       KeySelect()(m_values[m_buckets[ibucket].index()]))) {
    %%%%%: 1384-block 8
call    0 never executed
call    1 never executed
call    2 never executed
    %%%%%: 1384-block 15
branch  3 never executed (fallthrough)
branch  4 never executed
    $$$$$: 1384-block 57
call    5 never executed
    #####: 1385:        return std::make_pair(begin() + m_buckets[ibucket].index(), false);
    %%%%%: 1385-block 16
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 1385-block 19
call    5 never executed
    $$$$$: 1385-block 58
    $$$$$: 1385-block 59
    $$$$$: 1385-block 60
call    6 never executed
        -: 1386:      }
        -: 1387:
    #####: 1388:      ibucket = next_bucket(ibucket);
    %%%%%: 1388-block 21
call    0 never executed
    #####: 1389:      dist_from_ideal_bucket++;
        -: 1390:    }
        -: 1391:
    #####: 1392:    if (size() >= max_size()) {
    %%%%%: 1392-block 30
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 1393:      TSL_OH_THROW_OR_TERMINATE(
    %%%%%: 1393-block 33
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 1393-block 35
call    4 never executed
    $$$$$: 1393-block 61
call    5 never executed
        -: 1394:          std::length_error, "We reached the maximum size for the hash table.");
        -: 1395:    }
        -: 1396:
    #####: 1397:    if (grow_on_high_load()) {
    %%%%%: 1397-block 36
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 1398:      ibucket = bucket_for_hash(hash);
    %%%%%: 1398-block 38
call    0 never executed
    #####: 1399:      dist_from_ideal_bucket = 0;
        -: 1400:    }
        -: 1401:
    #####: 1402:    m_values.emplace_back(std::forward<Args>(value_type_args)...);
    %%%%%: 1402-block 40
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1403:    insert_index(ibucket, dist_from_ideal_bucket,
call    0 never executed
call    1 never executed
    #####: 1404:                 index_type(m_values.size() - 1),
call    0 never executed
        -: 1405:                 bucket_entry::truncate_hash(hash));
        -: 1406:
    #####: 1407:    return std::make_pair(std::prev(end()), true);
call    0 never executed
    %%%%%: 1407-block 54
call    1 never executed
    $$$$$: 1407-block 63
    $$$$$: 1407-block 64
        -: 1408:  }
        -: 1409:
        -: 1410:  /**
        -: 1411:   * Insert the element before insert_position.
        -: 1412:   */
        -: 1413:  template <class K, class... Args>
        -: 1414:  std::pair<iterator, bool> insert_at_position_impl(
        -: 1415:      typename values_container_type::const_iterator insert_position,
        -: 1416:      const K& key, Args&&... value_type_args) {
        -: 1417:    const std::size_t hash = hash_key(key);
        -: 1418:
        -: 1419:    std::size_t ibucket = bucket_for_hash(hash);
        -: 1420:    std::size_t dist_from_ideal_bucket = 0;
        -: 1421:
        -: 1422:    while (!m_buckets[ibucket].empty() &&
        -: 1423:           dist_from_ideal_bucket <= distance_from_ideal_bucket(ibucket)) {
        -: 1424:      if (m_buckets[ibucket].truncated_hash() ==
        -: 1425:              bucket_entry::truncate_hash(hash) &&
        -: 1426:          compare_keys(key,
        -: 1427:                       KeySelect()(m_values[m_buckets[ibucket].index()]))) {
        -: 1428:        return std::make_pair(begin() + m_buckets[ibucket].index(), false);
        -: 1429:      }
        -: 1430:
        -: 1431:      ibucket = next_bucket(ibucket);
        -: 1432:      dist_from_ideal_bucket++;
        -: 1433:    }
        -: 1434:
        -: 1435:    if (size() >= max_size()) {
        -: 1436:      TSL_OH_THROW_OR_TERMINATE(
        -: 1437:          std::length_error, "We reached the maximum size for the hash table.");
        -: 1438:    }
        -: 1439:
        -: 1440:    if (grow_on_high_load()) {
        -: 1441:      ibucket = bucket_for_hash(hash);
        -: 1442:      dist_from_ideal_bucket = 0;
        -: 1443:    }
        -: 1444:
        -: 1445:    const index_type index_insert_position =
        -: 1446:        index_type(std::distance(m_values.cbegin(), insert_position));
        -: 1447:
        -: 1448:#ifdef TSL_OH_NO_CONTAINER_EMPLACE_CONST_ITERATOR
        -: 1449:    m_values.emplace(
        -: 1450:        m_values.begin() + std::distance(m_values.cbegin(), insert_position),
        -: 1451:        std::forward<Args>(value_type_args)...);
        -: 1452:#else
        -: 1453:    m_values.emplace(insert_position, std::forward<Args>(value_type_args)...);
        -: 1454:#endif
        -: 1455:
        -: 1456:    /*
        -: 1457:     * The insertion didn't happend at the end of the m_values container,
        -: 1458:     * we need to shift the indexes in m_buckets_data.
        -: 1459:     */
        -: 1460:    if (index_insert_position != m_values.size() - 1) {
        -: 1461:      shift_indexes_in_buckets(index_insert_position, 1);
        -: 1462:    }
        -: 1463:
        -: 1464:    insert_index(ibucket, dist_from_ideal_bucket, index_insert_position,
        -: 1465:                 bucket_entry::truncate_hash(hash));
        -: 1466:
        -: 1467:    return std::make_pair(iterator(m_values.begin() + index_insert_position),
        -: 1468:                          true);
        -: 1469:  }
        -: 1470:
function _ZN3tsl19detail_ordered_hash12ordered_hashISt4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ENS_11ordered_mapIS8_S8_St4hashIS8_ESt8equal_toIS8_ESaIS9_ESt5dequeIS9_SF_EjE9KeySelectENSI_11ValueSelectESC_SE_SF_SH_jE12insert_indexEmmjj called 0 returned 0% blocks executed 0%
    #####: 1471:  void insert_index(std::size_t ibucket, std::size_t dist_from_ideal_bucket,
        -: 1472:                    index_type index_insert,
        -: 1473:                    truncated_hash_type hash_insert) noexcept {
    #####: 1474:    while (!m_buckets[ibucket].empty()) {
    %%%%%: 1474-block 2
    %%%%%: 1474-block 19
call    0 never executed
branch  1 never executed
branch  2 never executed (fallthrough)
    #####: 1475:      const std::size_t distance = distance_from_ideal_bucket(ibucket);
    %%%%%: 1475-block 3
call    0 never executed
    #####: 1476:      if (dist_from_ideal_bucket > distance) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1477:        std::swap(index_insert, m_buckets[ibucket].index_ref());
    %%%%%: 1477-block 5
call    0 never executed
call    1 never executed
    #####: 1478:        std::swap(hash_insert, m_buckets[ibucket].truncated_hash_ref());
call    0 never executed
call    1 never executed
        -: 1479:
    #####: 1480:        dist_from_ideal_bucket = distance;
        -: 1481:      }
        -: 1482:
    #####: 1483:      ibucket = next_bucket(ibucket);
    %%%%%: 1483-block 10
call    0 never executed
    #####: 1484:      dist_from_ideal_bucket++;
        -: 1485:
    #####: 1486:      if (dist_from_ideal_bucket > REHASH_ON_HIGH_NB_PROBES__NPROBES &&
    #####: 1487:          !m_grow_on_next_insert &&
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1487-block 12
branch  2 never executed (fallthrough)
branch  3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 1487-block 15
    %%%%%: 1487-block 16
    %%%%%: 1487-block 17
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 1488:          load_factor() >= REHASH_ON_HIGH_NB_PROBES__MIN_LOAD_FACTOR) {
    %%%%%: 1488-block 13
call    0 never executed
        -: 1489:        // We don't want to grow the map now as we need this method to be
        -: 1490:        // noexcept. Do it on next insert.
    #####: 1491:        m_grow_on_next_insert = true;
    %%%%%: 1491-block 18
        -: 1492:      }
        -: 1493:    }
        -: 1494:
    #####: 1495:    m_buckets[ibucket].set_index(index_insert);
    %%%%%: 1495-block 21
call    0 never executed
    #####: 1496:    m_buckets[ibucket].set_hash(hash_insert);
call    0 never executed
    #####: 1497:  }
        -: 1498:
function _ZNK3tsl19detail_ordered_hash12ordered_hashISt4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ENS_11ordered_mapIS8_S8_St4hashIS8_ESt8equal_toIS8_ESaIS9_ESt5dequeIS9_SF_EjE9KeySelectENSI_11ValueSelectESC_SE_SF_SH_jE26distance_from_ideal_bucketEm called 0 returned 0% blocks executed 0%
    #####: 1499:  std::size_t distance_from_ideal_bucket(std::size_t ibucket) const noexcept {
        -: 1500:    const std::size_t ideal_bucket =
    #####: 1501:        bucket_for_hash(m_buckets[ibucket].truncated_hash());
    %%%%%: 1501-block 2
call    0 never executed
call    1 never executed
        -: 1502:
    #####: 1503:    if (ibucket >= ideal_bucket) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1504:      return ibucket - ideal_bucket;
    %%%%%: 1504-block 5
        -: 1505:    }
        -: 1506:    // If the bucket is smaller than the ideal bucket for the value, there was a
        -: 1507:    // wrapping at the end of the bucket array due to the modulo.
        -: 1508:    else {
    #####: 1509:      return (bucket_count() + ibucket) - ideal_bucket;
    %%%%%: 1509-block 6
call    0 never executed
        -: 1510:    }
        -: 1511:  }
        -: 1512:
function _ZNK3tsl19detail_ordered_hash12ordered_hashISt4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ENS_11ordered_mapIS8_S8_St4hashIS8_ESt8equal_toIS8_ESaIS9_ESt5dequeIS9_SF_EjE9KeySelectENSI_11ValueSelectESC_SE_SF_SH_jE11next_bucketEm called 0 returned 0% blocks executed 0%
    #####: 1513:  std::size_t next_bucket(std::size_t index) const noexcept {
        -: 1514:    tsl_oh_assert(index < m_buckets_data.size());
        -: 1515:
    #####: 1516:    index++;
    #####: 1517:    return (index < m_buckets_data.size()) ? index : 0;
    %%%%%: 1517-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 1517-block 4
    %%%%%: 1517-block 5
    %%%%%: 1517-block 6
        -: 1518:  }
        -: 1519:
function _ZNK3tsl19detail_ordered_hash12ordered_hashISt4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ENS_11ordered_mapIS8_S8_St4hashIS8_ESt8equal_toIS8_ESaIS9_ESt5dequeIS9_SF_EjE9KeySelectENSI_11ValueSelectESC_SE_SF_SH_jE15bucket_for_hashEm called 0 returned 0% blocks executed 0%
    #####: 1520:  std::size_t bucket_for_hash(std::size_t hash) const noexcept {
    #####: 1521:    return hash & m_hash_mask;
    %%%%%: 1521-block 2
        -: 1522:  }
        -: 1523:
        -: 1524:  std::size_t iterator_to_index(const_iterator it) const noexcept {
        -: 1525:    const auto dist = std::distance(cbegin(), it);
        -: 1526:    tsl_oh_assert(dist >= 0);
        -: 1527:
        -: 1528:    return std::size_t(dist);
        -: 1529:  }
        -: 1530:
        -: 1531:  /**
        -: 1532:   * Return true if the map has been rehashed.
        -: 1533:   */
function _ZN3tsl19detail_ordered_hash12ordered_hashISt4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ENS_11ordered_mapIS8_S8_St4hashIS8_ESt8equal_toIS8_ESaIS9_ESt5dequeIS9_SF_EjE9KeySelectENSI_11ValueSelectESC_SE_SF_SH_jE17grow_on_high_loadEv called 0 returned 0% blocks executed 0%
    #####: 1534:  bool grow_on_high_load() {
    #####: 1535:    if (m_grow_on_next_insert || size() >= m_load_threshold) {
    %%%%%: 1535-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1535-block 3
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 1535-block 5
    %%%%%: 1535-block 6
    %%%%%: 1535-block 7
branch  5 never executed (fallthrough)
branch  6 never executed
    #####: 1536:      rehash_impl(std::max(size_type(1), bucket_count() * 2));
    %%%%%: 1536-block 8
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    $$$$$: 1536-block 14
    #####: 1537:      m_grow_on_next_insert = false;
        -: 1538:
    #####: 1539:      return true;
    %%%%%: 1539-block 11
        -: 1540:    } else {
    #####: 1541:      return false;
    %%%%%: 1541-block 12
        -: 1542:    }
        -: 1543:  }
        -: 1544:
        -: 1545:  template <class Serializer>
        -: 1546:  void serialize_impl(Serializer& serializer) const {
        -: 1547:    const slz_size_type version = SERIALIZATION_PROTOCOL_VERSION;
        -: 1548:    serializer(version);
        -: 1549:
        -: 1550:    const slz_size_type nb_elements = m_values.size();
        -: 1551:    serializer(nb_elements);
        -: 1552:
        -: 1553:    const slz_size_type bucket_count = m_buckets_data.size();
        -: 1554:    serializer(bucket_count);
        -: 1555:
        -: 1556:    const float max_load_factor = m_max_load_factor;
        -: 1557:    serializer(max_load_factor);
        -: 1558:
        -: 1559:    for (const value_type& value : m_values) {
        -: 1560:      serializer(value);
        -: 1561:    }
        -: 1562:
        -: 1563:    for (const bucket_entry& bucket : m_buckets_data) {
        -: 1564:      bucket.serialize(serializer);
        -: 1565:    }
        -: 1566:  }
        -: 1567:
        -: 1568:  template <class Deserializer>
        -: 1569:  void deserialize_impl(Deserializer& deserializer, bool hash_compatible) {
        -: 1570:    tsl_oh_assert(m_buckets_data.empty());  // Current hash table must be empty
        -: 1571:
        -: 1572:    const slz_size_type version =
        -: 1573:        deserialize_value<slz_size_type>(deserializer);
        -: 1574:    // For now we only have one version of the serialization protocol.
        -: 1575:    // If it doesn't match there is a problem with the file.
        -: 1576:    if (version != SERIALIZATION_PROTOCOL_VERSION) {
        -: 1577:      TSL_OH_THROW_OR_TERMINATE(std::runtime_error,
        -: 1578:                                "Can't deserialize the ordered_map/set. "
        -: 1579:                                "The protocol version header is invalid.");
        -: 1580:    }
        -: 1581:
        -: 1582:    const slz_size_type nb_elements =
        -: 1583:        deserialize_value<slz_size_type>(deserializer);
        -: 1584:    const slz_size_type bucket_count_ds =
        -: 1585:        deserialize_value<slz_size_type>(deserializer);
        -: 1586:    const float max_load_factor = deserialize_value<float>(deserializer);
        -: 1587:
        -: 1588:    if (max_load_factor < MAX_LOAD_FACTOR__MINIMUM ||
        -: 1589:        max_load_factor > MAX_LOAD_FACTOR__MAXIMUM) {
        -: 1590:      TSL_OH_THROW_OR_TERMINATE(
        -: 1591:          std::runtime_error,
        -: 1592:          "Invalid max_load_factor. Check that the serializer "
        -: 1593:          "and deserializer support floats correctly as they "
        -: 1594:          "can be converted implicitly to ints.");
        -: 1595:    }
        -: 1596:
        -: 1597:    this->max_load_factor(max_load_factor);
        -: 1598:
        -: 1599:    if (bucket_count_ds == 0) {
        -: 1600:      tsl_oh_assert(nb_elements == 0);
        -: 1601:      return;
        -: 1602:    }
        -: 1603:
        -: 1604:    if (!hash_compatible) {
        -: 1605:      reserve(numeric_cast<size_type>(nb_elements,
        -: 1606:                                      "Deserialized nb_elements is too big."));
        -: 1607:      for (slz_size_type el = 0; el < nb_elements; el++) {
        -: 1608:        insert(deserialize_value<value_type>(deserializer));
        -: 1609:      }
        -: 1610:    } else {
        -: 1611:      m_buckets_data.reserve(numeric_cast<size_type>(
        -: 1612:          bucket_count_ds, "Deserialized bucket_count is too big."));
        -: 1613:      m_buckets = m_buckets_data.data(),
        -: 1614:      m_hash_mask = m_buckets_data.capacity() - 1;
        -: 1615:
        -: 1616:      reserve_space_for_values(numeric_cast<size_type>(
        -: 1617:          nb_elements, "Deserialized nb_elements is too big."));
        -: 1618:      for (slz_size_type el = 0; el < nb_elements; el++) {
        -: 1619:        m_values.push_back(deserialize_value<value_type>(deserializer));
        -: 1620:      }
        -: 1621:
        -: 1622:      for (slz_size_type b = 0; b < bucket_count_ds; b++) {
        -: 1623:        m_buckets_data.push_back(bucket_entry::deserialize(deserializer));
        -: 1624:      }
        -: 1625:    }
        -: 1626:  }
        -: 1627:
function _ZN3tsl19detail_ordered_hash12ordered_hashISt4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ENS_11ordered_mapIS8_S8_St4hashIS8_ESt8equal_toIS8_ESaIS9_ESt5dequeIS9_SF_EjE9KeySelectENSI_11ValueSelectESC_SE_SF_SH_jE24round_up_to_power_of_twoEm called 0 returned 0% blocks executed 0%
    #####: 1628:  static std::size_t round_up_to_power_of_two(std::size_t value) {
    #####: 1629:    if (is_power_of_two(value)) {
    %%%%%: 1629-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 1630:      return value;
    %%%%%: 1630-block 4
        -: 1631:    }
        -: 1632:
    #####: 1633:    if (value == 0) {
    %%%%%: 1633-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1634:      return 1;
    %%%%%: 1634-block 6
        -: 1635:    }
        -: 1636:
    #####: 1637:    --value;
    #####: 1638:    for (std::size_t i = 1; i < sizeof(std::size_t) * CHAR_BIT; i *= 2) {
    %%%%%: 1638-block 7
    %%%%%: 1638-block 9
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 1639:      value |= value >> i;
    %%%%%: 1639-block 8
        -: 1640:    }
        -: 1641:
    #####: 1642:    return value + 1;
    %%%%%: 1642-block 10
        -: 1643:  }
        -: 1644:
function _ZN3tsl19detail_ordered_hash12ordered_hashISt4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ENS_11ordered_mapIS8_S8_St4hashIS8_ESt8equal_toIS8_ESaIS9_ESt5dequeIS9_SF_EjE9KeySelectENSI_11ValueSelectESC_SE_SF_SH_jE15is_power_of_twoEm called 0 returned 0% blocks executed 0%
    #####: 1645:  static constexpr bool is_power_of_two(std::size_t value) {
    #####: 1646:    return value != 0 && (value & (value - 1)) == 0;
    %%%%%: 1646-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1646-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1646-block 4
    %%%%%: 1646-block 5
    %%%%%: 1646-block 6
        -: 1647:  }
        -: 1648:
        -: 1649: public:
        -: 1650:  static const size_type DEFAULT_INIT_BUCKETS_SIZE = 0;
        -: 1651:  static constexpr float DEFAULT_MAX_LOAD_FACTOR = 0.75f;
        -: 1652:
        -: 1653: private:
        -: 1654:  static constexpr float MAX_LOAD_FACTOR__MINIMUM = 0.1f;
        -: 1655:  static constexpr float MAX_LOAD_FACTOR__MAXIMUM = 0.95f;
        -: 1656:
        -: 1657:  static const size_type REHASH_ON_HIGH_NB_PROBES__NPROBES = 128;
        -: 1658:  static constexpr float REHASH_ON_HIGH_NB_PROBES__MIN_LOAD_FACTOR = 0.15f;
        -: 1659:
        -: 1660:  /**
        -: 1661:   * Protocol version currenlty used for serialization.
        -: 1662:   */
        -: 1663:  static const slz_size_type SERIALIZATION_PROTOCOL_VERSION = 1;
        -: 1664:
        -: 1665:  /**
        -: 1666:   * Return an always valid pointer to an static empty bucket_entry with
        -: 1667:   * last_bucket() == true.
        -: 1668:   */
function _ZN3tsl19detail_ordered_hash12ordered_hashISt4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ENS_11ordered_mapIS8_S8_St4hashIS8_ESt8equal_toIS8_ESaIS9_ESt5dequeIS9_SF_EjE9KeySelectENSI_11ValueSelectESC_SE_SF_SH_jE23static_empty_bucket_ptrEv called 0 returned 0% blocks executed 0%
    #####: 1669:  bucket_entry* static_empty_bucket_ptr() {
    #####: 1670:    static bucket_entry empty_bucket;
    %%%%%: 1670-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1670-block 3
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 1670-block 5
call    5 never executed
call    6 never executed
    #####: 1671:    return &empty_bucket;
    %%%%%: 1671-block 7
        -: 1672:  }
        -: 1673:
        -: 1674: private:
        -: 1675:  buckets_container_type m_buckets_data;
        -: 1676:
        -: 1677:  /**
        -: 1678:   * Points to m_buckets_data.data() if !m_buckets_data.empty() otherwise points
        -: 1679:   * to static_empty_bucket_ptr. This variable is useful to avoid the cost of
        -: 1680:   * checking if m_buckets_data is empty when trying to find an element.
        -: 1681:   *
        -: 1682:   * TODO Remove m_buckets_data and only use a pointer+size instead of a
        -: 1683:   * pointer+vector to save some space in the ordered_hash object.
        -: 1684:   */
        -: 1685:  bucket_entry* m_buckets;
        -: 1686:
        -: 1687:  size_type m_hash_mask;
        -: 1688:
        -: 1689:  values_container_type m_values;
        -: 1690:
        -: 1691:  size_type m_load_threshold;
        -: 1692:  float m_max_load_factor;
        -: 1693:
        -: 1694:  bool m_grow_on_next_insert;
        -: 1695:};
        -: 1696:
        -: 1697:}  // end namespace detail_ordered_hash
        -: 1698:
        -: 1699:}  // end namespace tsl
        -: 1700:
        -: 1701:#endif
