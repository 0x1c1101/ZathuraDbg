        -:    0:Source:/home/rc/ZathuraDbg/vendor/imgui/imgui_widgets.cpp
        -:    0:Graph:/home/rc/ZathuraDbg/src/cmake-build-debug-coverage/CMakeFiles/Zathura.dir/home/rc/ZathuraDbg/vendor/imgui/imgui_widgets.cpp.gcno
        -:    0:Data:/home/rc/ZathuraDbg/src/cmake-build-debug-coverage/CMakeFiles/Zathura.dir/home/rc/ZathuraDbg/vendor/imgui/imgui_widgets.cpp.gcda
        -:    0:Runs:1
        -:    1:// dear imgui, v1.91.4
        -:    2:// (widgets code)
        -:    3:
        -:    4:/*
        -:    5:
        -:    6:Index of this file:
        -:    7:
        -:    8:// [SECTION] Forward Declarations
        -:    9:// [SECTION] Widgets: Text, etc.
        -:   10:// [SECTION] Widgets: Main (Button, Image, Checkbox, RadioButton, ProgressBar, Bullet, etc.)
        -:   11:// [SECTION] Widgets: Low-level Layout helpers (Spacing, Dummy, NewLine, Separator, etc.)
        -:   12:// [SECTION] Widgets: ComboBox
        -:   13:// [SECTION] Data Type and Data Formatting Helpers
        -:   14:// [SECTION] Widgets: DragScalar, DragFloat, DragInt, etc.
        -:   15:// [SECTION] Widgets: SliderScalar, SliderFloat, SliderInt, etc.
        -:   16:// [SECTION] Widgets: InputScalar, InputFloat, InputInt, etc.
        -:   17:// [SECTION] Widgets: InputText, InputTextMultiline
        -:   18:// [SECTION] Widgets: ColorEdit, ColorPicker, ColorButton, etc.
        -:   19:// [SECTION] Widgets: TreeNode, CollapsingHeader, etc.
        -:   20:// [SECTION] Widgets: Selectable
        -:   21:// [SECTION] Widgets: Typing-Select support
        -:   22:// [SECTION] Widgets: Box-Select support
        -:   23:// [SECTION] Widgets: Multi-Select support
        -:   24:// [SECTION] Widgets: Multi-Select helpers
        -:   25:// [SECTION] Widgets: ListBox
        -:   26:// [SECTION] Widgets: PlotLines, PlotHistogram
        -:   27:// [SECTION] Widgets: Value helpers
        -:   28:// [SECTION] Widgets: MenuItem, BeginMenu, EndMenu, etc.
        -:   29:// [SECTION] Widgets: BeginTabBar, EndTabBar, etc.
        -:   30:// [SECTION] Widgets: BeginTabItem, EndTabItem, etc.
        -:   31:// [SECTION] Widgets: Columns, BeginColumns, EndColumns, etc.
        -:   32:
        -:   33:*/
        -:   34:
        -:   35:#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
        -:   36:#define _CRT_SECURE_NO_WARNINGS
        -:   37:#endif
        -:   38:
        -:   39:#ifndef IMGUI_DEFINE_MATH_OPERATORS
        -:   40:#define IMGUI_DEFINE_MATH_OPERATORS
        -:   41:#endif
        -:   42:
        -:   43:#include "imgui.h"
        -:   44:#ifndef IMGUI_DISABLE
        -:   45:#include "imgui_internal.h"
        -:   46:
        -:   47:// System includes
        -:   48:#include <stdint.h>     // intptr_t
        -:   49:
        -:   50://-------------------------------------------------------------------------
        -:   51:// Warnings
        -:   52://-------------------------------------------------------------------------
        -:   53:
        -:   54:// Visual Studio warnings
        -:   55:#ifdef _MSC_VER
        -:   56:#pragma warning (disable: 4127)     // condition expression is constant
        -:   57:#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen
        -:   58:#if defined(_MSC_VER) && _MSC_VER >= 1922 // MSVC 2019 16.2 or later
        -:   59:#pragma warning (disable: 5054)     // operator '|': deprecated between enumerations of different types
        -:   60:#endif
        -:   61:#pragma warning (disable: 26451)    // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to a 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).
        -:   62:#pragma warning (disable: 26812)    // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3).
        -:   63:#endif
        -:   64:
        -:   65:// Clang/GCC warnings with -Weverything
        -:   66:#if defined(__clang__)
        -:   67:#if __has_warning("-Wunknown-warning-option")
        -:   68:#pragma clang diagnostic ignored "-Wunknown-warning-option"         // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!
        -:   69:#endif
        -:   70:#pragma clang diagnostic ignored "-Wunknown-pragmas"                // warning: unknown warning group 'xxx'
        -:   71:#pragma clang diagnostic ignored "-Wold-style-cast"                 // warning: use of old-style cast                            // yes, they are more terse.
        -:   72:#pragma clang diagnostic ignored "-Wfloat-equal"                    // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants (typically 0.0f) is ok.
        -:   73:#pragma clang diagnostic ignored "-Wformat-nonliteral"              // warning: format string is not a string literal            // passing non-literal to vsnformat(). yes, user passing incorrect format strings can crash the code.
        -:   74:#pragma clang diagnostic ignored "-Wsign-conversion"                // warning: implicit conversion changes signedness
        -:   75:#pragma clang diagnostic ignored "-Wunused-macros"                  // warning: macro is not used                                // we define snprintf/vsnprintf on Windows so they are available, but not always used.
        -:   76:#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"  // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0
        -:   77:#pragma clang diagnostic ignored "-Wdouble-promotion"               // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.
        -:   78:#pragma clang diagnostic ignored "-Wenum-enum-conversion"           // warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_')
        -:   79:#pragma clang diagnostic ignored "-Wdeprecated-enum-enum-conversion"// warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_') is deprecated
        -:   80:#pragma clang diagnostic ignored "-Wimplicit-int-float-conversion"  // warning: implicit conversion from 'xxx' to 'float' may lose precision
        -:   81:#pragma clang diagnostic ignored "-Wunsafe-buffer-usage"            // warning: 'xxx' is an unsafe pointer used for buffer access
        -:   82:#elif defined(__GNUC__)
        -:   83:#pragma GCC diagnostic ignored "-Wpragmas"                          // warning: unknown option after '#pragma GCC diagnostic' kind
        -:   84:#pragma GCC diagnostic ignored "-Wformat-nonliteral"                // warning: format not a string literal, format string not checked
        -:   85:#pragma GCC diagnostic ignored "-Wclass-memaccess"                  // [__GNUC__ >= 8] warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead
        -:   86:#pragma GCC diagnostic ignored "-Wdeprecated-enum-enum-conversion"  // warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_') is deprecated
        -:   87:#endif
        -:   88:
        -:   89://-------------------------------------------------------------------------
        -:   90:// Data
        -:   91://-------------------------------------------------------------------------
        -:   92:
        -:   93:// Widgets
        -:   94:static const float          DRAGDROP_HOLD_TO_OPEN_TIMER = 0.70f;    // Time for drag-hold to activate items accepting the ImGuiButtonFlags_PressedOnDragDropHold button behavior.
        -:   95:static const float          DRAG_MOUSE_THRESHOLD_FACTOR = 0.50f;    // Multiplier for the default value of io.MouseDragThreshold to make DragFloat/DragInt react faster to mouse drags.
        -:   96:
        -:   97:// Those MIN/MAX values are not define because we need to point to them
        -:   98:static const signed char    IM_S8_MIN  = -128;
        -:   99:static const signed char    IM_S8_MAX  = 127;
        -:  100:static const unsigned char  IM_U8_MIN  = 0;
        -:  101:static const unsigned char  IM_U8_MAX  = 0xFF;
        -:  102:static const signed short   IM_S16_MIN = -32768;
        -:  103:static const signed short   IM_S16_MAX = 32767;
        -:  104:static const unsigned short IM_U16_MIN = 0;
        -:  105:static const unsigned short IM_U16_MAX = 0xFFFF;
        -:  106:static const ImS32          IM_S32_MIN = INT_MIN;    // (-2147483647 - 1), (0x80000000);
        -:  107:static const ImS32          IM_S32_MAX = INT_MAX;    // (2147483647), (0x7FFFFFFF)
        -:  108:static const ImU32          IM_U32_MIN = 0;
        -:  109:static const ImU32          IM_U32_MAX = UINT_MAX;   // (0xFFFFFFFF)
        -:  110:#ifdef LLONG_MIN
        -:  111:static const ImS64          IM_S64_MIN = LLONG_MIN;  // (-9223372036854775807ll - 1ll);
        -:  112:static const ImS64          IM_S64_MAX = LLONG_MAX;  // (9223372036854775807ll);
        -:  113:#else
        -:  114:static const ImS64          IM_S64_MIN = -9223372036854775807LL - 1;
        -:  115:static const ImS64          IM_S64_MAX = 9223372036854775807LL;
        -:  116:#endif
        -:  117:static const ImU64          IM_U64_MIN = 0;
        -:  118:#ifdef ULLONG_MAX
        -:  119:static const ImU64          IM_U64_MAX = ULLONG_MAX; // (0xFFFFFFFFFFFFFFFFull);
        -:  120:#else
        -:  121:static const ImU64          IM_U64_MAX = (2ULL * 9223372036854775807LL + 1);
        -:  122:#endif
        -:  123:
        -:  124://-------------------------------------------------------------------------
        -:  125:// [SECTION] Forward Declarations
        -:  126://-------------------------------------------------------------------------
        -:  127:
        -:  128:// For InputTextEx()
        -:  129:static bool     InputTextFilterCharacter(ImGuiContext* ctx, unsigned int* p_char, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data, bool input_source_is_clipboard = false);
        -:  130:static int      InputTextCalcTextLenAndLineCount(const char* text_begin, const char** out_text_end);
        -:  131:static ImVec2   InputTextCalcTextSize(ImGuiContext* ctx, const char* text_begin, const char* text_end, const char** remaining = NULL, ImVec2* out_offset = NULL, bool stop_on_new_line = false);
        -:  132:
        -:  133://-------------------------------------------------------------------------
        -:  134:// [SECTION] Widgets: Text, etc.
        -:  135://-------------------------------------------------------------------------
        -:  136:// - TextEx() [Internal]
        -:  137:// - TextUnformatted()
        -:  138:// - Text()
        -:  139:// - TextV()
        -:  140:// - TextColored()
        -:  141:// - TextColoredV()
        -:  142:// - TextDisabled()
        -:  143:// - TextDisabledV()
        -:  144:// - TextWrapped()
        -:  145:// - TextWrappedV()
        -:  146:// - LabelText()
        -:  147:// - LabelTextV()
        -:  148:// - BulletText()
        -:  149:// - BulletTextV()
        -:  150://-------------------------------------------------------------------------
        -:  151:
function _ZN5ImGui6TextExEPKcS1_i called 422213 returned 100% blocks executed 28%
   422213:  152:void ImGui::TextEx(const char* text, const char* text_end, ImGuiTextFlags flags)
        -:  153:{
   422213:  154:    ImGuiWindow* window = GetCurrentWindow();
   422213:  154-block 2
call    0 returned 422213
   422213:  155:    if (window->SkipItems)
branch  0 taken 0 (fallthrough)
branch  1 taken 422213
  322801*:  156:        return;
    %%%%%:  156-block 4
   322801:  156-block 71
   422213:  157:    ImGuiContext& g = *GImGui;
        -:  158:
        -:  159:    // Accept null ranges
   422213:  160:    if (text == text_end)
   422213:  160-block 5
branch  0 taken 0 (fallthrough)
branch  1 taken 422213
    #####:  161:        text = text_end = "";
    %%%%%:  161-block 6
        -:  162:
        -:  163:    // Calculate length
   422213:  164:    const char* text_begin = text;
   422213:  165:    if (text_end == NULL)
   422213:  165-block 7
branch  0 taken 0 (fallthrough)
branch  1 taken 422213
    #####:  166:        text_end = text + strlen(text); // FIXME-OPT
    %%%%%:  166-block 8
        -:  167:
   422213:  168:    const ImVec2 text_pos(window->DC.CursorPos.x, window->DC.CursorPos.y + window->DC.CurrLineTextBaseOffset);
   422213:  168-block 9
call    0 returned 422213
   422213:  169:    const float wrap_pos_x = window->DC.TextWrapPos;
   422213:  170:    const bool wrap_enabled = (wrap_pos_x >= 0.0f);
  422213*:  171:    if (text_end - text <= 2000 || wrap_enabled)
branch  0 taken 0 (fallthrough)
branch  1 taken 422213
    %%%%%:  171-block 11
branch  2 never executed (fallthrough)
branch  3 never executed
        -:  172:    {
        -:  173:        // Common case
  422213*:  174:        const float wrap_width = wrap_enabled ? CalcWrapWidthForPos(window->DC.CursorPos, wrap_pos_x) : 0.0f;
   422213:  174-block 12
branch  0 taken 0 (fallthrough)
branch  1 taken 422213
    %%%%%:  174-block 13
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%:  174-block 14
   422213:  174-block 15
   422213:  175:        const ImVec2 text_size = CalcTextSize(text_begin, text_end, false, wrap_width);
   422213:  175-block 16
call    0 returned 422213
branch  1 taken 422213 (fallthrough)
branch  2 taken 0 (throw)
        -:  176:
   422213:  177:        ImRect bb(text_pos, text_pos + text_size);
   422213:  177-block 17
call    0 returned 422213
call    1 returned 422213
   422213:  178:        ItemSize(text_size, 0.0f);
call    0 returned 422213
branch  1 taken 422213 (fallthrough)
branch  2 taken 0 (throw)
   422213:  179:        if (!ItemAdd(bb, 0))
   422213:  179-block 20
call    0 returned 422213
branch  1 taken 422213 (fallthrough)
branch  2 taken 0 (throw)
   422213:  179-block 21
branch  3 taken 322801 (fallthrough)
branch  4 taken 99412
   322801:  180:            return;
   322801:  180-block 22
        -:  181:
        -:  182:        // Render (we don't hide text after ## in this end-user function)
    99412:  183:        RenderTextWrapped(bb.Min, text_begin, text_end, wrap_width);
    99412:  183-block 23
call    0 returned 99412
branch  1 taken 99412 (fallthrough)
branch  2 taken 0 (throw)
    99412:  184:    }
    99412:  184-block 24
        -:  185:    else
        -:  186:    {
        -:  187:        // Long text!
        -:  188:        // Perform manual coarse clipping to optimize for long multi-line text
        -:  189:        // - From this point we will only compute the width of lines that are visible. Optimization only available when word-wrapping is disabled.
        -:  190:        // - We also don't vertically center the text within the line full height, which is unlikely to matter because we are likely the biggest and only item on the line.
        -:  191:        // - We use memchr(), pay attention that well optimized versions of those str/mem functions are much faster than a casually written loop.
    #####:  192:        const char* line = text;
    #####:  193:        const float line_height = GetTextLineHeight();
    %%%%%:  193-block 25
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  194:        ImVec2 text_size(0, 0);
        -:  195:
        -:  196:        // Lines to skip (can't skip when logging text)
    #####:  197:        ImVec2 pos = text_pos;
    #####:  198:        if (!g.LogEnabled)
    %%%%%:  198-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
        -:  199:        {
    #####:  200:            int lines_skippable = (int)((window->ClipRect.Min.y - text_pos.y) / line_height);
    #####:  201:            if (lines_skippable > 0)
    %%%%%:  201-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
        -:  202:            {
    #####:  203:                int lines_skipped = 0;
    #####:  204:                while (line < text_end && lines_skipped < lines_skippable)
    %%%%%:  204-block 28
    %%%%%:  204-block 36
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  204-block 37
branch  2 never executed
branch  3 never executed (fallthrough)
        -:  205:                {
    #####:  206:                    const char* line_end = (const char*)memchr(line, '\n', text_end - line);
    #####:  207:                    if (!line_end)
    %%%%%:  207-block 29
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  208:                        line_end = text_end;
    %%%%%:  208-block 30
    #####:  209:                    if ((flags & ImGuiTextFlags_NoWidthForLargeClippedText) == 0)
    %%%%%:  209-block 31
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  210:                        text_size.x = ImMax(text_size.x, CalcTextSize(line, line_end).x);
    %%%%%:  210-block 32
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:  210-block 33
call    3 never executed
    #####:  211:                    line = line_end + 1;
    #####:  212:                    lines_skipped++;
    %%%%%:  212-block 35
        -:  213:                }
    #####:  214:                pos.y += lines_skipped * line_height;
    %%%%%:  214-block 38
        -:  215:            }
        -:  216:        }
        -:  217:
        -:  218:        // Lines to render
    #####:  219:        if (line < text_end)
    %%%%%:  219-block 39
branch  0 never executed (fallthrough)
branch  1 never executed
        -:  220:        {
    #####:  221:            ImRect line_rect(pos, pos + ImVec2(FLT_MAX, line_height));
    %%%%%:  221-block 40
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  222:            while (line < text_end)
    %%%%%:  222-block 53
branch  0 never executed
branch  1 never executed (fallthrough)
        -:  223:            {
    #####:  224:                if (IsClippedEx(line_rect, 0))
    %%%%%:  224-block 44
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:  224-block 45
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:  225:                    break;
    %%%%%:  225-block 46
        -:  226:
    #####:  227:                const char* line_end = (const char*)memchr(line, '\n', text_end - line);
    #####:  228:                if (!line_end)
    %%%%%:  228-block 47
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  229:                    line_end = text_end;
    %%%%%:  229-block 48
    #####:  230:                text_size.x = ImMax(text_size.x, CalcTextSize(line, line_end).x);
    %%%%%:  230-block 49
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:  230-block 50
call    3 never executed
    #####:  231:                RenderText(pos, line, line_end, false);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  232:                line = line_end + 1;
    #####:  233:                line_rect.Min.y += line_height;
    #####:  234:                line_rect.Max.y += line_height;
    #####:  235:                pos.y += line_height;
    %%%%%:  235-block 52
        -:  236:            }
        -:  237:
        -:  238:            // Count remaining lines
    #####:  239:            int lines_skipped = 0;
    #####:  240:            while (line < text_end)
    %%%%%:  240-block 54
    %%%%%:  240-block 62
branch  0 never executed
branch  1 never executed (fallthrough)
        -:  241:            {
    #####:  242:                const char* line_end = (const char*)memchr(line, '\n', text_end - line);
    #####:  243:                if (!line_end)
    %%%%%:  243-block 55
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  244:                    line_end = text_end;
    %%%%%:  244-block 56
    #####:  245:                if ((flags & ImGuiTextFlags_NoWidthForLargeClippedText) == 0)
    %%%%%:  245-block 57
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  246:                    text_size.x = ImMax(text_size.x, CalcTextSize(line, line_end).x);
    %%%%%:  246-block 58
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:  246-block 59
call    3 never executed
    #####:  247:                line = line_end + 1;
    #####:  248:                lines_skipped++;
    %%%%%:  248-block 61
        -:  249:            }
    #####:  250:            pos.y += lines_skipped * line_height;
    %%%%%:  250-block 63
        -:  251:        }
    #####:  252:        text_size.y = (pos - text_pos).y;
    %%%%%:  252-block 64
call    0 never executed
        -:  253:
    #####:  254:        ImRect bb(text_pos, text_pos + text_size);
call    0 never executed
call    1 never executed
    #####:  255:        ItemSize(text_size, 0.0f);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  256:        ItemAdd(bb, 0);
    %%%%%:  256-block 68
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:  257:    }
        -:  258:}
        -:  259:
function _ZN5ImGui15TextUnformattedEPKcS1_ called 0 returned 0% blocks executed 0%
    #####:  260:void ImGui::TextUnformatted(const char* text, const char* text_end)
        -:  261:{
    #####:  262:    TextEx(text, text_end, ImGuiTextFlags_NoWidthForLargeClippedText);
    %%%%%:  262-block 2
call    0 never executed
    #####:  263:}
        -:  264:
function _ZN5ImGui4TextEPKcz called 56464 returned 100% blocks executed 100%
    56464:  265:void ImGui::Text(const char* fmt, ...)
        -:  266:{
        -:  267:    va_list args;
    56464:  268:    va_start(args, fmt);
    56464:  269:    TextV(fmt, args);
    56464:  269-block 2
call    0 returned 56464
branch  1 taken 56464 (fallthrough)
branch  2 taken 0 (throw)
    56464:  270:    va_end(args);
    56464:  271:}
    56464:  271-block 3
        -:  272:
function _ZN5ImGui5TextVEPKcP13__va_list_tag called 422213 returned 100% blocks executed 88%
   422213:  273:void ImGui::TextV(const char* fmt, va_list args)
        -:  274:{
   422213:  275:    ImGuiWindow* window = GetCurrentWindow();
   422213:  275-block 2
call    0 returned 422213
   422213:  276:    if (window->SkipItems)
branch  0 taken 0 (fallthrough)
branch  1 taken 422213
    #####:  277:        return;
    %%%%%:  277-block 4
        -:  278:
        -:  279:    const char* text, *text_end;
   422213:  280:    ImFormatStringToTempBufferV(&text, &text_end, fmt, args);
   422213:  280-block 5
call    0 returned 422213
branch  1 taken 422213 (fallthrough)
branch  2 taken 0 (throw)
   422213:  281:    TextEx(text, text_end, ImGuiTextFlags_NoWidthForLargeClippedText);
   422213:  281-block 6
call    0 returned 422213
branch  1 taken 422213 (fallthrough)
branch  2 taken 0 (throw)
        -:  282:}
        -:  283:
function _ZN5ImGui11TextColoredERK6ImVec4PKcz called 0 returned 0% blocks executed 0%
    #####:  284:void ImGui::TextColored(const ImVec4& col, const char* fmt, ...)
        -:  285:{
        -:  286:    va_list args;
    #####:  287:    va_start(args, fmt);
    #####:  288:    TextColoredV(col, fmt, args);
    %%%%%:  288-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  289:    va_end(args);
    #####:  290:}
    %%%%%:  290-block 3
        -:  291:
function _ZN5ImGui12TextColoredVERK6ImVec4PKcP13__va_list_tag called 0 returned 0% blocks executed 0%
    #####:  292:void ImGui::TextColoredV(const ImVec4& col, const char* fmt, va_list args)
        -:  293:{
    #####:  294:    PushStyleColor(ImGuiCol_Text, col);
    %%%%%:  294-block 2
call    0 never executed
    #####:  295:    TextV(fmt, args);
call    0 never executed
    #####:  296:    PopStyleColor();
call    0 never executed
    #####:  297:}
        -:  298:
function _ZN5ImGui12TextDisabledEPKcz called 365749 returned 100% blocks executed 100%
   365749:  299:void ImGui::TextDisabled(const char* fmt, ...)
        -:  300:{
        -:  301:    va_list args;
   365749:  302:    va_start(args, fmt);
   365749:  303:    TextDisabledV(fmt, args);
   365749:  303-block 2
call    0 returned 365749
branch  1 taken 365749 (fallthrough)
branch  2 taken 0 (throw)
   365749:  304:    va_end(args);
   365749:  305:}
   365749:  305-block 3
        -:  306:
function _ZN5ImGui13TextDisabledVEPKcP13__va_list_tag called 365749 returned 100% blocks executed 100%
   365749:  307:void ImGui::TextDisabledV(const char* fmt, va_list args)
        -:  308:{
   365749:  309:    ImGuiContext& g = *GImGui;
   365749:  310:    PushStyleColor(ImGuiCol_Text, g.Style.Colors[ImGuiCol_TextDisabled]);
   365749:  310-block 2
call    0 returned 365749
   365749:  311:    TextV(fmt, args);
call    0 returned 365749
   365749:  312:    PopStyleColor();
call    0 returned 365749
   365749:  313:}
        -:  314:
function _ZN5ImGui11TextWrappedEPKcz called 0 returned 0% blocks executed 0%
    #####:  315:void ImGui::TextWrapped(const char* fmt, ...)
        -:  316:{
        -:  317:    va_list args;
    #####:  318:    va_start(args, fmt);
    #####:  319:    TextWrappedV(fmt, args);
    %%%%%:  319-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  320:    va_end(args);
    #####:  321:}
    %%%%%:  321-block 3
        -:  322:
function _ZN5ImGui12TextWrappedVEPKcP13__va_list_tag called 0 returned 0% blocks executed 0%
    #####:  323:void ImGui::TextWrappedV(const char* fmt, va_list args)
        -:  324:{
    #####:  325:    ImGuiContext& g = *GImGui;
    #####:  326:    const bool need_backup = (g.CurrentWindow->DC.TextWrapPos < 0.0f);  // Keep existing wrap position if one is already set
    #####:  327:    if (need_backup)
    %%%%%:  327-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  328:        PushTextWrapPos(0.0f);
    %%%%%:  328-block 3
call    0 never executed
    #####:  329:    TextV(fmt, args);
    %%%%%:  329-block 4
call    0 never executed
    #####:  330:    if (need_backup)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  331:        PopTextWrapPos();
    %%%%%:  331-block 6
call    0 never executed
    #####:  332:}
        -:  333:
function _ZN5ImGui9LabelTextEPKcS1_z called 0 returned 0% blocks executed 0%
    #####:  334:void ImGui::LabelText(const char* label, const char* fmt, ...)
        -:  335:{
        -:  336:    va_list args;
    #####:  337:    va_start(args, fmt);
    #####:  338:    LabelTextV(label, fmt, args);
    %%%%%:  338-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  339:    va_end(args);
    #####:  340:}
    %%%%%:  340-block 3
        -:  341:
        -:  342:// Add a label+text combo aligned to other label+value widgets
function _ZN5ImGui10LabelTextVEPKcS1_P13__va_list_tag called 0 returned 0% blocks executed 0%
    #####:  343:void ImGui::LabelTextV(const char* label, const char* fmt, va_list args)
        -:  344:{
    #####:  345:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%:  345-block 2
call    0 never executed
    #####:  346:    if (window->SkipItems)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  347:        return;
    %%%%%:  347-block 4
    %%%%%:  347-block 31
        -:  348:
    #####:  349:    ImGuiContext& g = *GImGui;
    #####:  350:    const ImGuiStyle& style = g.Style;
    #####:  351:    const float w = CalcItemWidth();
    %%%%%:  351-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:  352:
        -:  353:    const char* value_text_begin, *value_text_end;
    #####:  354:    ImFormatStringToTempBufferV(&value_text_begin, &value_text_end, fmt, args);
    %%%%%:  354-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  355:    const ImVec2 value_size = CalcTextSize(value_text_begin, value_text_end, false);
    %%%%%:  355-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  356:    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    %%%%%:  356-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:  357:
    #####:  358:    const ImVec2 pos = window->DC.CursorPos;
    #####:  359:    const ImRect value_bb(pos, pos + ImVec2(w, value_size.y + style.FramePadding.y * 2));
    %%%%%:  359-block 9
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  360:    const ImRect total_bb(pos, pos + ImVec2(w + (label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f), ImMax(value_size.y, label_size.y) + style.FramePadding.y * 2));
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%:  360-block 14
    %%%%%:  360-block 15
    %%%%%:  360-block 16
call    3 never executed
call    4 never executed
call    5 never executed
    #####:  361:    ItemSize(total_bb, style.FramePadding.y);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  362:    if (!ItemAdd(total_bb, 0))
    %%%%%:  362-block 20
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:  362-block 21
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:  363:        return;
    %%%%%:  363-block 22
        -:  364:
        -:  365:    // Render
    #####:  366:    RenderTextClipped(value_bb.Min + style.FramePadding, value_bb.Max, value_text_begin, value_text_end, &value_size, ImVec2(0.0f, 0.0f));
    %%%%%:  366-block 23
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    $$$$$:  366-block 33
    $$$$$:  366-block 34
    #####:  367:    if (label_size.x > 0.0f)
    %%%%%:  367-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  368:        RenderText(ImVec2(value_bb.Max.x + style.ItemInnerSpacing.x, value_bb.Min.y + style.FramePadding.y), label);
    %%%%%:  368-block 27
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:  368-block 29
    $$$$$:  368-block 35
        -:  369:}
        -:  370:
function _ZN5ImGui10BulletTextEPKcz called 0 returned 0% blocks executed 0%
    #####:  371:void ImGui::BulletText(const char* fmt, ...)
        -:  372:{
        -:  373:    va_list args;
    #####:  374:    va_start(args, fmt);
    #####:  375:    BulletTextV(fmt, args);
    %%%%%:  375-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  376:    va_end(args);
    #####:  377:}
    %%%%%:  377-block 3
        -:  378:
        -:  379:// Text with a little bullet aligned to the typical tree node.
function _ZN5ImGui11BulletTextVEPKcP13__va_list_tag called 0 returned 0% blocks executed 0%
    #####:  380:void ImGui::BulletTextV(const char* fmt, va_list args)
        -:  381:{
    #####:  382:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%:  382-block 2
call    0 never executed
    #####:  383:    if (window->SkipItems)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  384:        return;
    %%%%%:  384-block 4
    %%%%%:  384-block 25
        -:  385:
    #####:  386:    ImGuiContext& g = *GImGui;
    #####:  387:    const ImGuiStyle& style = g.Style;
        -:  388:
        -:  389:    const char* text_begin, *text_end;
    #####:  390:    ImFormatStringToTempBufferV(&text_begin, &text_end, fmt, args);
    %%%%%:  390-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  391:    const ImVec2 label_size = CalcTextSize(text_begin, text_end, false);
    %%%%%:  391-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  392:    const ImVec2 total_size = ImVec2(g.FontSize + (label_size.x > 0.0f ? (label_size.x + style.FramePadding.x * 2) : 0.0f), label_size.y);  // Empty text doesn't add padding
    %%%%%:  392-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  392-block 8
    %%%%%:  392-block 9
    %%%%%:  392-block 10
call    2 never executed
    #####:  393:    ImVec2 pos = window->DC.CursorPos;
    #####:  394:    pos.y += window->DC.CurrLineTextBaseOffset;
    #####:  395:    ItemSize(total_size, 0.0f);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  396:    const ImRect bb(pos, pos + total_size);
    %%%%%:  396-block 12
call    0 never executed
call    1 never executed
    #####:  397:    if (!ItemAdd(bb, 0))
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:  397-block 15
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:  398:        return;
    %%%%%:  398-block 16
        -:  399:
        -:  400:    // Render
    #####:  401:    ImU32 text_col = GetColorU32(ImGuiCol_Text);
    %%%%%:  401-block 17
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  402:    RenderBullet(window->DrawList, bb.Min + ImVec2(style.FramePadding.x + g.FontSize * 0.5f, g.FontSize * 0.5f), text_col);
    %%%%%:  402-block 18
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    $$$$$:  402-block 27
    #####:  403:    RenderText(bb.Min + ImVec2(g.FontSize + style.FramePadding.x * 2, 0.0f), text_begin, text_end, false);
    %%%%%:  403-block 21
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%:  403-block 24
    $$$$$:  403-block 28
        -:  404:}
        -:  405:
        -:  406://-------------------------------------------------------------------------
        -:  407:// [SECTION] Widgets: Main
        -:  408://-------------------------------------------------------------------------
        -:  409:// - ButtonBehavior() [Internal]
        -:  410:// - Button()
        -:  411:// - SmallButton()
        -:  412:// - InvisibleButton()
        -:  413:// - ArrowButton()
        -:  414:// - CloseButton() [Internal]
        -:  415:// - CollapseButton() [Internal]
        -:  416:// - GetWindowScrollbarID() [Internal]
        -:  417:// - GetWindowScrollbarRect() [Internal]
        -:  418:// - Scrollbar() [Internal]
        -:  419:// - ScrollbarEx() [Internal]
        -:  420:// - Image()
        -:  421:// - ImageButton()
        -:  422:// - Checkbox()
        -:  423:// - CheckboxFlagsT() [Internal]
        -:  424:// - CheckboxFlags()
        -:  425:// - RadioButton()
        -:  426:// - ProgressBar()
        -:  427:// - Bullet()
        -:  428:// - Hyperlink()
        -:  429://-------------------------------------------------------------------------
        -:  430:
        -:  431:// The ButtonBehavior() function is key to many interactions and used by many/most widgets.
        -:  432:// Because we handle so many cases (keyboard/gamepad navigation, drag and drop) and many specific behavior (via ImGuiButtonFlags_),
        -:  433:// this code is a little complex.
        -:  434:// By far the most common path is interacting with the Mouse using the default ImGuiButtonFlags_PressedOnClickRelease button behavior.
        -:  435:// See the series of events below and the corresponding state reported by dear imgui:
        -:  436://------------------------------------------------------------------------------------------------------------------------------------------------
        -:  437:// with PressedOnClickRelease:             return-value  IsItemHovered()  IsItemActive()  IsItemActivated()  IsItemDeactivated()  IsItemClicked()
        -:  438://   Frame N+0 (mouse is outside bb)        -             -                -               -                  -                    -
        -:  439://   Frame N+1 (mouse moves inside bb)      -             true             -               -                  -                    -
        -:  440://   Frame N+2 (mouse button is down)       -             true             true            true               -                    true
        -:  441://   Frame N+3 (mouse button is down)       -             true             true            -                  -                    -
        -:  442://   Frame N+4 (mouse moves outside bb)     -             -                true            -                  -                    -
        -:  443://   Frame N+5 (mouse moves inside bb)      -             true             true            -                  -                    -
        -:  444://   Frame N+6 (mouse button is released)   true          true             -               -                  true                 -
        -:  445://   Frame N+7 (mouse button is released)   -             true             -               -                  -                    -
        -:  446://   Frame N+8 (mouse moves outside bb)     -             -                -               -                  -                    -
        -:  447://------------------------------------------------------------------------------------------------------------------------------------------------
        -:  448:// with PressedOnClick:                    return-value  IsItemHovered()  IsItemActive()  IsItemActivated()  IsItemDeactivated()  IsItemClicked()
        -:  449://   Frame N+2 (mouse button is down)       true          true             true            true               -                    true
        -:  450://   Frame N+3 (mouse button is down)       -             true             true            -                  -                    -
        -:  451://   Frame N+6 (mouse button is released)   -             true             -               -                  true                 -
        -:  452://   Frame N+7 (mouse button is released)   -             true             -               -                  -                    -
        -:  453://------------------------------------------------------------------------------------------------------------------------------------------------
        -:  454:// with PressedOnRelease:                  return-value  IsItemHovered()  IsItemActive()  IsItemActivated()  IsItemDeactivated()  IsItemClicked()
        -:  455://   Frame N+2 (mouse button is down)       -             true             -               -                  -                    true
        -:  456://   Frame N+3 (mouse button is down)       -             true             -               -                  -                    -
        -:  457://   Frame N+6 (mouse button is released)   true          true             -               -                  -                    -
        -:  458://   Frame N+7 (mouse button is released)   -             true             -               -                  -                    -
        -:  459://------------------------------------------------------------------------------------------------------------------------------------------------
        -:  460:// with PressedOnDoubleClick:              return-value  IsItemHovered()  IsItemActive()  IsItemActivated()  IsItemDeactivated()  IsItemClicked()
        -:  461://   Frame N+0 (mouse button is down)       -             true             -               -                  -                    true
        -:  462://   Frame N+1 (mouse button is down)       -             true             -               -                  -                    -
        -:  463://   Frame N+2 (mouse button is released)   -             true             -               -                  -                    -
        -:  464://   Frame N+3 (mouse button is released)   -             true             -               -                  -                    -
        -:  465://   Frame N+4 (mouse button is down)       true          true             true            true               -                    true
        -:  466://   Frame N+5 (mouse button is down)       -             true             true            -                  -                    -
        -:  467://   Frame N+6 (mouse button is released)   -             true             -               -                  true                 -
        -:  468://   Frame N+7 (mouse button is released)   -             true             -               -                  -                    -
        -:  469://------------------------------------------------------------------------------------------------------------------------------------------------
        -:  470:// Note that some combinations are supported,
        -:  471:// - PressedOnDragDropHold can generally be associated with any flag.
        -:  472:// - PressedOnDoubleClick can be associated by PressedOnClickRelease/PressedOnRelease, in which case the second release event won't be reported.
        -:  473://------------------------------------------------------------------------------------------------------------------------------------------------
        -:  474:// The behavior of the return-value changes when ImGuiButtonFlags_Repeat is set:
        -:  475://                                         Repeat+                  Repeat+           Repeat+             Repeat+
        -:  476://                                         PressedOnClickRelease    PressedOnClick    PressedOnRelease    PressedOnDoubleClick
        -:  477://-------------------------------------------------------------------------------------------------------------------------------------------------
        -:  478://   Frame N+0 (mouse button is down)       -                        true              -                   true
        -:  479://   ...                                    -                        -                 -                   -
        -:  480://   Frame N + RepeatDelay                  true                     true              -                   true
        -:  481://   ...                                    -                        -                 -                   -
        -:  482://   Frame N + RepeatDelay + RepeatRate*N   true                     true              -                   true
        -:  483://-------------------------------------------------------------------------------------------------------------------------------------------------
        -:  484:
        -:  485:// - FIXME: For refactor we could output flags, incl mouse hovered vs nav keyboard vs nav triggered etc.
        -:  486://   And better standardize how widgets use 'GetColor32((held && hovered) ? ... : hovered ? ...)' vs 'GetColor32(held ? ... : hovered ? ...);'
        -:  487://   For mouse feedback we typically prefer the 'held && hovered' test, but for nav feedback not always. Outputting hovered=true on Activation may be misleading.
        -:  488:// - Since v1.91.2 (Sept 2024) we included io.ConfigDebugHighlightIdConflicts feature.
        -:  489://   One idiom which was previously valid which will now emit a warning is when using multiple overlayed ButtonBehavior()
        -:  490://   with same ID and different MouseButton (see #8030). You can fix it by:
        -:  491://       (1) switching to use a single ButtonBehavior() with multiple _MouseButton flags.
        -:  492://    or (2) surrounding those calls with PushItemFlag(ImGuiItemFlags_AllowDuplicateId, true); ... PopItemFlag()
function _ZN5ImGui14ButtonBehaviorERK6ImRectjPbS3_i called 80693 returned 100% blocks executed 56%
    80693:  493:bool ImGui::ButtonBehavior(const ImRect& bb, ImGuiID id, bool* out_hovered, bool* out_held, ImGuiButtonFlags flags)
        -:  494:{
    80693:  495:    ImGuiContext& g = *GImGui;
    80693:  496:    ImGuiWindow* window = GetCurrentWindow();
    80693:  496-block 2
call    0 returned 80693
        -:  497:
        -:  498:    // Default only reacts to left mouse button
    80693:  499:    if ((flags & ImGuiButtonFlags_MouseButtonMask_) == 0)
branch  0 taken 80693 (fallthrough)
branch  1 taken 0
    80693:  500:        flags |= ImGuiButtonFlags_MouseButtonLeft;
    80693:  500-block 4
        -:  501:
        -:  502:    // Default behavior requires click + release inside bounding box
    80693:  503:    if ((flags & ImGuiButtonFlags_PressedOnMask_) == 0)
    80693:  503-block 5
branch  0 taken 69929 (fallthrough)
branch  1 taken 10764
    69929:  504:        flags |= ImGuiButtonFlags_PressedOnDefault_;
    69929:  504-block 6
        -:  505:
        -:  506:    // Default behavior inherited from item flags
        -:  507:    // Note that _both_ ButtonFlags and ItemFlags are valid sources, so copy one into the item_flags and only check that.
    80693:  508:    ImGuiItemFlags item_flags = (g.LastItemData.ID == id ? g.LastItemData.ItemFlags : g.CurrentItemFlags);
    80693:  508-block 7
branch  0 taken 75313 (fallthrough)
branch  1 taken 5380
    75313:  508-block 8
     5380:  508-block 9
    80693:  509:    if (flags & ImGuiButtonFlags_AllowOverlap)
    80693:  509-block 10
branch  0 taken 18293 (fallthrough)
branch  1 taken 62400
    18293:  510:        item_flags |= ImGuiItemFlags_AllowOverlap;
    18293:  510-block 11
        -:  511:
    80693:  512:    ImGuiWindow* backup_hovered_window = g.HoveredWindow;
    80693:  513:    const bool flatten_hovered_children = (flags & ImGuiButtonFlags_FlattenChildren) && g.HoveredWindow && g.HoveredWindow->RootWindowDockTree == window->RootWindowDockTree;
    80693:  513-block 12
branch  0 taken 7533 (fallthrough)
branch  1 taken 73160
     7533:  513-block 13
branch  2 taken 7532 (fallthrough)
branch  3 taken 1
     7532:  513-block 14
branch  4 taken 7525 (fallthrough)
branch  5 taken 7
     7525:  513-block 15
    73168:  513-block 16
    80693:  514:    if (flatten_hovered_children)
    80693:  514-block 17
branch  0 taken 7525 (fallthrough)
branch  1 taken 73168
     7525:  515:        g.HoveredWindow = window;
     7525:  515-block 18
        -:  516:
        -:  517:#ifdef IMGUI_ENABLE_TEST_ENGINE
        -:  518:    // Alternate registration spot, for when caller didn't use ItemAdd()
        -:  519:    if (g.LastItemData.ID != id)
        -:  520:        IMGUI_TEST_ENGINE_ITEM_ADD(id, bb, NULL);
        -:  521:#endif
        -:  522:
    80693:  523:    bool pressed = false;
    80693:  524:    bool hovered = ItemHoverable(bb, id, item_flags);
    80693:  524-block 19
call    0 returned 80693
        -:  525:
        -:  526:    // Special mode for Drag and Drop where holding button pressed for a long time while dragging another item triggers the button
   80693*:  527:    if (g.DragDropActive && (flags & ImGuiButtonFlags_PressedOnDragDropHold) && !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoHoldToOpenOthers))
branch  0 taken 0 (fallthrough)
branch  1 taken 80693
    %%%%%:  527-block 21
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:  527-block 22
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:  528:        if (IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))
    %%%%%:  528-block 23
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -:  529:        {
    #####:  530:            hovered = true;
    #####:  531:            SetHoveredID(id);
    %%%%%:  531-block 25
call    0 never executed
    #####:  532:            if (g.HoveredIdTimer - g.IO.DeltaTime <= DRAGDROP_HOLD_TO_OPEN_TIMER && g.HoveredIdTimer >= DRAGDROP_HOLD_TO_OPEN_TIMER)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  532-block 27
branch  2 never executed (fallthrough)
branch  3 never executed
        -:  533:            {
    #####:  534:                pressed = true;
    #####:  535:                g.DragDropHoldJustPressedId = id;
    #####:  536:                FocusWindow(window);
    %%%%%:  536-block 28
call    0 never executed
        -:  537:            }
        -:  538:        }
        -:  539:
    80693:  540:    if (flatten_hovered_children)
    80693:  540-block 29
branch  0 taken 7525 (fallthrough)
branch  1 taken 73168
     7525:  541:        g.HoveredWindow = backup_hovered_window;
     7525:  541-block 30
        -:  542:
        -:  543:    // Mouse handling
   80693*:  544:    const ImGuiID test_owner_id = (flags & ImGuiButtonFlags_NoTestKeyOwner) ? ImGuiKeyOwner_Any : id;
    80693:  544-block 31
branch  0 taken 80693 (fallthrough)
branch  1 taken 0
    80693:  544-block 32
    %%%%%:  544-block 33
    80693:  545:    if (hovered)
    80693:  545-block 34
branch  0 taken 212 (fallthrough)
branch  1 taken 80481
        -:  546:    {
     212*:  547:        IM_ASSERT(id != 0); // Lazily check inside rare path.
      212:  547-block 35
branch  0 taken 0 (fallthrough)
branch  1 taken 212
    %%%%%:  547-block 36
call    2 never executed
        -:  548:
        -:  549:        // Poll mouse buttons
        -:  550:        // - 'mouse_button_clicked' is generally carried into ActiveIdMouseButton when setting ActiveId.
        -:  551:        // - Technically we only need some values in one code path, but since this is gated by hovered test this is fine.
      212:  552:        int mouse_button_clicked = -1;
      212:  553:        int mouse_button_released = -1;
      848:  554:        for (int button = 0; button < 3; button++)
      212:  554-block 37
      636:  554-block 53
      848:  554-block 54
branch  0 taken 636
branch  1 taken 212 (fallthrough)
      636:  555:            if (flags & (ImGuiButtonFlags_MouseButtonLeft << button)) // Handle ImGuiButtonFlags_MouseButtonRight and ImGuiButtonFlags_MouseButtonMiddle here.
      636:  555-block 38
branch  0 taken 212 (fallthrough)
branch  1 taken 424
        -:  556:            {
      212:  557:                if (IsMouseClicked(button, ImGuiInputFlags_None, test_owner_id) && mouse_button_clicked == -1) { mouse_button_clicked = button; }
      212:  557-block 39
call    0 returned 212
branch  1 taken 3 (fallthrough)
branch  2 taken 209
        3:  557-block 41
branch  3 taken 3 (fallthrough)
branch  4 taken 0
        3:  557-block 42
      209:  557-block 43
      212:  557-block 44
branch  5 taken 3 (fallthrough)
branch  6 taken 209
        3:  557-block 45
      212:  558:                if (IsMouseReleased(button, test_owner_id) && mouse_button_released == -1) { mouse_button_released = button; }
      212:  558-block 46
call    0 returned 212
branch  1 taken 3 (fallthrough)
branch  2 taken 209
        3:  558-block 48
branch  3 taken 3 (fallthrough)
branch  4 taken 0
        3:  558-block 49
      209:  558-block 50
      212:  558-block 51
branch  5 taken 3 (fallthrough)
branch  6 taken 209
        3:  558-block 52
        -:  559:            }
        -:  560:
        -:  561:        // Process initial action
     212*:  562:        const bool mods_ok = !(flags & ImGuiButtonFlags_NoKeyModsAllowed) || (!g.IO.KeyCtrl && !g.IO.KeyShift && !g.IO.KeyAlt);
      212:  562-block 55
branch  0 taken 0 (fallthrough)
branch  1 taken 212
    %%%%%:  562-block 56
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:  562-block 57
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:  562-block 58
branch  6 never executed (fallthrough)
branch  7 never executed
      212:  562-block 59
    %%%%%:  562-block 60
      212:  563:        if (mods_ok)
      212:  563-block 61
branch  0 taken 212 (fallthrough)
branch  1 taken 0
        -:  564:        {
      212:  565:            if (mouse_button_clicked != -1 && g.ActiveId != id)
      212:  565-block 62
branch  0 taken 3 (fallthrough)
branch  1 taken 209
        3:  565-block 63
branch  2 taken 3 (fallthrough)
branch  3 taken 0
        -:  566:            {
        3:  567:                if (!(flags & ImGuiButtonFlags_NoSetKeyOwner))
        3:  567-block 64
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3:  568:                    SetKeyOwner(MouseButtonToKey(mouse_button_clicked), id);
        3:  568-block 65
call    0 returned 3
call    1 returned 3
        3:  569:                if (flags & (ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnClickReleaseAnywhere))
        3:  569-block 67
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        -:  570:                {
        3:  571:                    SetActiveID(id, window);
        3:  571-block 68
call    0 returned 3
        3:  572:                    g.ActiveIdMouseButton = mouse_button_clicked;
        3:  573:                    if (!(flags & ImGuiButtonFlags_NoNavFocus))
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        -:  574:                    {
        3:  575:                        SetFocusID(id, window);
        3:  575-block 70
call    0 returned 3
        3:  576:                        FocusWindow(window);
call    0 returned 3
        -:  577:                    }
        -:  578:                    else
        -:  579:                    {
    #####:  580:                        FocusWindow(window, ImGuiFocusRequestFlags_RestoreFocusedChild); // Still need to focus and bring to front, but try to avoid losing NavId when navigating a child
    %%%%%:  580-block 72
call    0 never executed
        -:  581:                    }
        -:  582:                }
       3*:  583:                if ((flags & ImGuiButtonFlags_PressedOnClick) || ((flags & ImGuiButtonFlags_PressedOnDoubleClick) && g.IO.MouseClickedCount[mouse_button_clicked] == 2))
        3:  583-block 73
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3:  583-block 74
branch  2 taken 0 (fallthrough)
branch  3 taken 3
    %%%%%:  583-block 75
branch  4 never executed (fallthrough)
branch  5 never executed
        -:  584:                {
    #####:  585:                    pressed = true;
    #####:  586:                    if (flags & ImGuiButtonFlags_NoHoldingActiveId)
    %%%%%:  586-block 76
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  587:                        ClearActiveID();
    %%%%%:  587-block 77
call    0 never executed
        -:  588:                    else
    #####:  589:                        SetActiveID(id, window); // Hold on ID
    %%%%%:  589-block 78
call    0 never executed
    #####:  590:                    g.ActiveIdMouseButton = mouse_button_clicked;
    #####:  591:                    if (!(flags & ImGuiButtonFlags_NoNavFocus))
    %%%%%:  591-block 79
branch  0 never executed (fallthrough)
branch  1 never executed
        -:  592:                    {
    #####:  593:                        SetFocusID(id, window);
    %%%%%:  593-block 80
call    0 never executed
    #####:  594:                        FocusWindow(window);
call    0 never executed
        -:  595:                    }
        -:  596:                    else
        -:  597:                    {
    #####:  598:                        FocusWindow(window, ImGuiFocusRequestFlags_RestoreFocusedChild); // Still need to focus and bring to front, but try to avoid losing NavId when navigating a child
    %%%%%:  598-block 82
call    0 never executed
        -:  599:                    }
        -:  600:                }
        -:  601:            }
      212:  602:            if (flags & ImGuiButtonFlags_PressedOnRelease)
      212:  602-block 83
branch  0 taken 0 (fallthrough)
branch  1 taken 212
        -:  603:            {
    #####:  604:                if (mouse_button_released != -1)
    %%%%%:  604-block 84
branch  0 never executed (fallthrough)
branch  1 never executed
        -:  605:                {
    #####:  606:                    const bool has_repeated_at_least_once = (item_flags & ImGuiItemFlags_ButtonRepeat) && g.IO.MouseDownDurationPrev[mouse_button_released] >= g.IO.KeyRepeatDelay; // Repeat mode trumps on release behavior
    %%%%%:  606-block 85
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  606-block 86
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:  606-block 87
    %%%%%:  606-block 88
    #####:  607:                    if (!has_repeated_at_least_once)
    %%%%%:  607-block 89
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  608:                        pressed = true;
    %%%%%:  608-block 90
    #####:  609:                    if (!(flags & ImGuiButtonFlags_NoNavFocus))
    %%%%%:  609-block 91
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  610:                        SetFocusID(id, window); // FIXME: Lack of FocusWindow() call here is inconsistent with other paths. Research why.
    %%%%%:  610-block 92
call    0 never executed
    #####:  611:                    ClearActiveID();
    %%%%%:  611-block 93
call    0 never executed
        -:  612:                }
        -:  613:            }
        -:  614:
        -:  615:            // 'Repeat' mode acts when held regardless of _PressedOn flags (see table above).
        -:  616:            // Relies on repeat logic of IsMouseClicked() but we may as well do it ourselves if we end up exposing finer RepeatDelay/RepeatRate settings.
      212:  617:            if (g.ActiveId == id && (item_flags & ImGuiItemFlags_ButtonRepeat))
      212:  617-block 94
branch  0 taken 42 (fallthrough)
branch  1 taken 170
       42:  617-block 95
branch  2 taken 0 (fallthrough)
branch  3 taken 42
    #####:  618:                if (g.IO.MouseDownDuration[g.ActiveIdMouseButton] > 0.0f && IsMouseClicked(g.ActiveIdMouseButton, ImGuiInputFlags_Repeat, test_owner_id))
    %%%%%:  618-block 96
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  618-block 97
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:  618-block 99
    %%%%%:  618-block 100
    %%%%%:  618-block 101
branch  5 never executed (fallthrough)
branch  6 never executed
    #####:  619:                    pressed = true;
    %%%%%:  619-block 102
        -:  620:        }
        -:  621:
     212*:  622:        if (pressed && g.IO.ConfigNavCursorVisibleAuto)
      212:  622-block 103
branch  0 taken 0 (fallthrough)
branch  1 taken 212
    %%%%%:  622-block 104
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:  623:            g.NavCursorVisible = false;
    %%%%%:  623-block 105
        -:  624:    }
        -:  625:
        -:  626:    // Keyboard/Gamepad navigation handling
        -:  627:    // We report navigated and navigation-activated items as hovered but we don't set g.HoveredId to not interfere with mouse.
   80693*:  628:    if (g.NavId == id && g.NavCursorVisible && g.NavHighlightItemUnderNav)
    80693:  628-block 106
branch  0 taken 471 (fallthrough)
branch  1 taken 80222
      471:  628-block 107
branch  2 taken 0 (fallthrough)
branch  3 taken 471
    %%%%%:  628-block 108
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:  629:        if (!(flags & ImGuiButtonFlags_NoHoveredOnFocus))
    %%%%%:  629-block 109
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  630:            hovered = true;
    %%%%%:  630-block 110
    80693:  631:    if (g.NavActivateDownId == id)
    80693:  631-block 111
branch  0 taken 0 (fallthrough)
branch  1 taken 80693
        -:  632:    {
    #####:  633:        bool nav_activated_by_code = (g.NavActivateId == id);
    #####:  634:        bool nav_activated_by_inputs = (g.NavActivatePressedId == id);
    #####:  635:        if (!nav_activated_by_inputs && (item_flags & ImGuiItemFlags_ButtonRepeat))
    %%%%%:  635-block 112
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  635-block 113
branch  2 never executed (fallthrough)
branch  3 never executed
        -:  636:        {
        -:  637:            // Avoid pressing multiple keys from triggering excessive amount of repeat events
    #####:  638:            const ImGuiKeyData* key1 = GetKeyData(ImGuiKey_Space);
    %%%%%:  638-block 114
call    0 never executed
    #####:  639:            const ImGuiKeyData* key2 = GetKeyData(ImGuiKey_Enter);
call    0 never executed
    #####:  640:            const ImGuiKeyData* key3 = GetKeyData(ImGuiKey_NavGamepadActivate);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  640-block 117
    %%%%%:  640-block 118
    %%%%%:  640-block 119
call    2 never executed
    #####:  641:            const float t1 = ImMax(ImMax(key1->DownDuration, key2->DownDuration), key3->DownDuration);
call    0 never executed
call    1 never executed
    #####:  642:            nav_activated_by_inputs = CalcTypematicRepeatAmount(t1 - g.IO.DeltaTime, t1, g.IO.KeyRepeatDelay, g.IO.KeyRepeatRate) > 0;
call    0 never executed
        -:  643:        }
    #####:  644:        if (nav_activated_by_code || nav_activated_by_inputs)
    %%%%%:  644-block 124
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  644-block 125
branch  2 never executed (fallthrough)
branch  3 never executed
        -:  645:        {
        -:  646:            // Set active id so it can be queried by user via IsItemActive(), equivalent of holding the mouse button.
    #####:  647:            pressed = true;
    #####:  648:            SetActiveID(id, window);
    %%%%%:  648-block 126
call    0 never executed
    #####:  649:            g.ActiveIdSource = g.NavInputSource;
    #####:  650:            if (!(flags & ImGuiButtonFlags_NoNavFocus) && !(g.NavActivateFlags & ImGuiActivateFlags_FromShortcut))
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  650-block 128
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:  651:                SetFocusID(id, window);
    %%%%%:  651-block 129
call    0 never executed
    #####:  652:            if (g.NavActivateFlags & ImGuiActivateFlags_FromShortcut)
    %%%%%:  652-block 130
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  653:                g.ActiveIdFromShortcut = true;
    %%%%%:  653-block 131
        -:  654:        }
        -:  655:    }
        -:  656:
        -:  657:    // Process while held
    80693:  658:    bool held = false;
    80693:  659:    if (g.ActiveId == id)
    80693:  659-block 132
branch  0 taken 42 (fallthrough)
branch  1 taken 80651
        -:  660:    {
       42:  661:        if (g.ActiveIdSource == ImGuiInputSource_Mouse)
       42:  661-block 133
branch  0 taken 42 (fallthrough)
branch  1 taken 0
        -:  662:        {
       42:  663:            if (g.ActiveIdIsJustActivated)
       42:  663-block 134
branch  0 taken 3 (fallthrough)
branch  1 taken 39
        3:  664:                g.ActiveIdClickOffset = g.IO.MousePos - bb.Min;
        3:  664-block 135
call    0 returned 3
        -:  665:
       42:  666:            const int mouse_button = g.ActiveIdMouseButton;
       42:  667:            if (mouse_button == -1)
       42:  667-block 136
branch  0 taken 0 (fallthrough)
branch  1 taken 42
        -:  668:            {
        -:  669:                // Fallback for the rare situation were g.ActiveId was set programmatically or from another widget (e.g. #6304).
    #####:  670:                ClearActiveID();
    %%%%%:  670-block 137
call    0 never executed
        -:  671:            }
       42:  672:            else if (IsMouseDown(mouse_button, test_owner_id))
       42:  672-block 138
call    0 returned 42
branch  1 taken 39 (fallthrough)
branch  2 taken 3
        -:  673:            {
       39:  674:                held = true;
       39:  674-block 140
        -:  675:            }
        -:  676:            else
        -:  677:            {
       3*:  678:                bool release_in = hovered && (flags & ImGuiButtonFlags_PressedOnClickRelease) != 0;
        3:  678-block 141
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3:  678-block 142
branch  2 taken 3 (fallthrough)
branch  3 taken 0
        3:  678-block 143
    %%%%%:  678-block 144
        3:  679:                bool release_anywhere = (flags & ImGuiButtonFlags_PressedOnClickReleaseAnywhere) != 0;
       3*:  680:                if ((release_in || release_anywhere) && !g.DragDropActive)
        3:  680-block 145
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%:  680-block 146
branch  2 never executed (fallthrough)
branch  3 never executed
        3:  680-block 147
branch  4 taken 3 (fallthrough)
branch  5 taken 0
        -:  681:                {
        -:  682:                    // Report as pressed when releasing the mouse (this is the most common path)
       3*:  683:                    bool is_double_click_release = (flags & ImGuiButtonFlags_PressedOnDoubleClick) && g.IO.MouseReleased[mouse_button] && g.IO.MouseClickedLastCount[mouse_button] == 2;
        3:  683-block 148
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%:  683-block 149
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:  683-block 150
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:  683-block 151
        3:  683-block 152
       3*:  684:                    bool is_repeating_already = (item_flags & ImGuiItemFlags_ButtonRepeat) && g.IO.MouseDownDurationPrev[mouse_button] >= g.IO.KeyRepeatDelay; // Repeat mode trumps <on release>
        3:  684-block 153
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%:  684-block 154
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:  684-block 155
        3:  684-block 156
        3:  685:                    bool is_button_avail_or_owned = TestKeyOwner(MouseButtonToKey(mouse_button), test_owner_id);
        3:  685-block 157
call    0 returned 3
call    1 returned 3
        3:  686:                    if (!is_double_click_release && !is_repeating_already && is_button_avail_or_owned)
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3:  686-block 160
branch  2 taken 3 (fallthrough)
branch  3 taken 0
        3:  686-block 161
branch  4 taken 3 (fallthrough)
branch  5 taken 0
        3:  687:                        pressed = true;
        3:  687-block 162
        -:  688:                }
        3:  689:                ClearActiveID();
        3:  689-block 163
call    0 returned 3
        -:  690:            }
       42:  691:            if (!(flags & ImGuiButtonFlags_NoNavFocus) && g.IO.ConfigNavCursorVisibleAuto)
       42:  691-block 164
branch  0 taken 42 (fallthrough)
branch  1 taken 0
       42:  691-block 165
branch  2 taken 42 (fallthrough)
branch  3 taken 0
       42:  692:                g.NavCursorVisible = false;
       42:  692-block 166
        -:  693:        }
    #####:  694:        else if (g.ActiveIdSource == ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource_Gamepad)
    %%%%%:  694-block 167
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  694-block 168
branch  2 never executed (fallthrough)
branch  3 never executed
        -:  695:        {
        -:  696:            // When activated using Nav, we hold on the ActiveID until activation button is released
    #####:  697:            if (g.NavActivateDownId == id)
    %%%%%:  697-block 169
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  698:                held = true; // hovered == true not true as we are already likely hovered on direct activation.
    %%%%%:  698-block 170
        -:  699:            else
    #####:  700:                ClearActiveID();
    %%%%%:  700-block 171
call    0 never executed
        -:  701:        }
       42:  702:        if (pressed)
       42:  702-block 172
branch  0 taken 3 (fallthrough)
branch  1 taken 39
        3:  703:            g.ActiveIdHasBeenPressedBefore = true;
        3:  703-block 173
        -:  704:    }
        -:  705:
        -:  706:    // Activation highlight (this may be a remote activation)
    80693:  707:    if (g.NavHighlightActivatedId == id)
    80693:  707-block 174
branch  0 taken 0 (fallthrough)
branch  1 taken 80693
    #####:  708:        hovered = true;
    %%%%%:  708-block 175
        -:  709:
    80693:  710:    if (out_hovered) *out_hovered = hovered;
    80693:  710-block 176
branch  0 taken 75313 (fallthrough)
branch  1 taken 5380
    75313:  710-block 177
    80693:  711:    if (out_held) *out_held = held;
    80693:  711-block 178
branch  0 taken 80693 (fallthrough)
branch  1 taken 0
    80693:  711-block 179
        -:  712:
    80693:  713:    return pressed;
    80693:  713-block 180
        -:  714:}
        -:  715:
function _ZN5ImGui8ButtonExEPKcRK6ImVec2i called 13924 returned 100% blocks executed 84%
    13924:  716:bool ImGui::ButtonEx(const char* label, const ImVec2& size_arg, ImGuiButtonFlags flags)
        -:  717:{
    13924:  718:    ImGuiWindow* window = GetCurrentWindow();
    13924:  718-block 2
call    0 returned 13924
    13924:  719:    if (window->SkipItems)
branch  0 taken 0 (fallthrough)
branch  1 taken 13924
    #####:  720:        return false;
    %%%%%:  720-block 4
        -:  721:
    13924:  722:    ImGuiContext& g = *GImGui;
    13924:  723:    const ImGuiStyle& style = g.Style;
    13924:  724:    const ImGuiID id = window->GetID(label);
    13924:  724-block 5
call    0 returned 13924
branch  1 taken 13924 (fallthrough)
branch  2 taken 0 (throw)
    13924:  725:    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    13924:  725-block 6
call    0 returned 13924
branch  1 taken 13924 (fallthrough)
branch  2 taken 0 (throw)
        -:  726:
    13924:  727:    ImVec2 pos = window->DC.CursorPos;
   13924*:  728:    if ((flags & ImGuiButtonFlags_AlignTextBaseLine) && style.FramePadding.y < window->DC.CurrLineTextBaseOffset) // Try to vertically align buttons that are smaller/have no padding so that text baseline matches (bit hacky, since it shouldn't be a flag)
    13924:  728-block 7
branch  0 taken 0 (fallthrough)
branch  1 taken 13924
    %%%%%:  728-block 8
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:  729:        pos.y += window->DC.CurrLineTextBaseOffset - style.FramePadding.y;
    %%%%%:  729-block 9
    13924:  730:    ImVec2 size = CalcItemSize(size_arg, label_size.x + style.FramePadding.x * 2.0f, label_size.y + style.FramePadding.y * 2.0f);
    13924:  730-block 10
call    0 returned 13924
branch  1 taken 13924 (fallthrough)
branch  2 taken 0 (throw)
        -:  731:
    13924:  732:    const ImRect bb(pos, pos + size);
    13924:  732-block 11
call    0 returned 13924
call    1 returned 13924
    13924:  733:    ItemSize(size, style.FramePadding.y);
call    0 returned 13924
branch  1 taken 13924 (fallthrough)
branch  2 taken 0 (throw)
    13924:  734:    if (!ItemAdd(bb, id))
    13924:  734-block 14
call    0 returned 13924
branch  1 taken 13924 (fallthrough)
branch  2 taken 0 (throw)
    13924:  734-block 15
branch  3 taken 2152 (fallthrough)
branch  4 taken 11772
     2152:  735:        return false;
     2152:  735-block 16
        -:  736:
        -:  737:    bool hovered, held;
    11772:  738:    bool pressed = ButtonBehavior(bb, id, &hovered, &held, flags);
    11772:  738-block 17
call    0 returned 11772
branch  1 taken 11772 (fallthrough)
branch  2 taken 0 (throw)
        -:  739:
        -:  740:    // Render
    11772:  741:    const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);
    11772:  741-block 18
branch  0 taken 39 (fallthrough)
branch  1 taken 11733
       39:  741-block 19
branch  2 taken 0 (fallthrough)
branch  3 taken 39
    11733:  741-block 20
branch  4 taken 173 (fallthrough)
branch  5 taken 11560
      173:  741-block 21
    11560:  741-block 22
    11733:  741-block 23
       39:  741-block 24
    11772:  741-block 25
call    6 returned 11772
branch  7 taken 11772 (fallthrough)
branch  8 taken 0 (throw)
    11772:  742:    RenderNavCursor(bb, id);
    11772:  742-block 26
call    0 returned 11772
branch  1 taken 11772 (fallthrough)
branch  2 taken 0 (throw)
    11772:  743:    RenderFrame(bb.Min, bb.Max, col, true, style.FrameRounding);
    11772:  743-block 27
call    0 returned 11772
branch  1 taken 11772 (fallthrough)
branch  2 taken 0 (throw)
        -:  744:
    11772:  745:    if (g.LogEnabled)
    11772:  745-block 28
branch  0 taken 0 (fallthrough)
branch  1 taken 11772
    #####:  746:        LogSetNextTextDecoration("[", "]");
    %%%%%:  746-block 29
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    11772:  747:    RenderTextClipped(bb.Min + style.FramePadding, bb.Max - style.FramePadding, label, NULL, &label_size, style.ButtonTextAlign, &bb);
    11772:  747-block 30
call    0 returned 11772
call    1 returned 11772
call    2 returned 11772
branch  3 taken 11772 (fallthrough)
branch  4 taken 0 (throw)
    $$$$$:  747-block 36
    $$$$$:  747-block 37
        -:  748:
        -:  749:    // Automatically close popups
        -:  750:    //if (pressed && !(flags & ImGuiButtonFlags_DontClosePopups) && (window->Flags & ImGuiWindowFlags_Popup))
        -:  751:    //    CloseCurrentPopup();
        -:  752:
        -:  753:    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags);
    11772:  754:    return pressed;
    11772:  754-block 33
        -:  755:}
        -:  756:
function _ZN5ImGui6ButtonEPKcRK6ImVec2 called 13924 returned 100% blocks executed 100%
    13924:  757:bool ImGui::Button(const char* label, const ImVec2& size_arg)
        -:  758:{
    13924:  759:    return ButtonEx(label, size_arg, ImGuiButtonFlags_None);
    13924:  759-block 2
call    0 returned 13924
        -:  760:}
        -:  761:
        -:  762:// Small buttons fits within text without additional vertical spacing.
function _ZN5ImGui11SmallButtonEPKc called 0 returned 0% blocks executed 0%
    #####:  763:bool ImGui::SmallButton(const char* label)
        -:  764:{
    #####:  765:    ImGuiContext& g = *GImGui;
    #####:  766:    float backup_padding_y = g.Style.FramePadding.y;
    #####:  767:    g.Style.FramePadding.y = 0.0f;
    #####:  768:    bool pressed = ButtonEx(label, ImVec2(0, 0), ImGuiButtonFlags_AlignTextBaseLine);
    %%%%%:  768-block 2
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####:  769:    g.Style.FramePadding.y = backup_padding_y;
    #####:  770:    return pressed;
    %%%%%:  770-block 4
    %%%%%:  770-block 5
        -:  771:}
        -:  772:
        -:  773:// Tip: use ImGui::PushID()/PopID() to push indices or pointers in the ID stack.
        -:  774:// Then you can keep 'str_id' empty or the same for all your buttons (instead of creating a string based on a non-string id)
function _ZN5ImGui15InvisibleButtonEPKcRK6ImVec2i called 16189 returned 100% blocks executed 88%
    16189:  775:bool ImGui::InvisibleButton(const char* str_id, const ImVec2& size_arg, ImGuiButtonFlags flags)
        -:  776:{
    16189:  777:    ImGuiContext& g = *GImGui;
    16189:  778:    ImGuiWindow* window = GetCurrentWindow();
    16189:  778-block 2
call    0 returned 16189
    16189:  779:    if (window->SkipItems)
branch  0 taken 0 (fallthrough)
branch  1 taken 16189
    #####:  780:        return false;
    %%%%%:  780-block 4
        -:  781:
        -:  782:    // Cannot use zero-size for InvisibleButton(). Unlike Button() there is not way to fallback using the label size.
   16189*:  783:    IM_ASSERT(size_arg.x != 0.0f && size_arg.y != 0.0f);
    16189:  783-block 5
branch  0 taken 16189 (fallthrough)
branch  1 taken 0
    16189:  783-block 6
branch  2 taken 16189 (fallthrough)
branch  3 taken 0
    16189:  783-block 7
    %%%%%:  783-block 8
call    4 never executed
        -:  784:
    16189:  785:    const ImGuiID id = window->GetID(str_id);
    16189:  785-block 9
call    0 returned 16189
branch  1 taken 16189 (fallthrough)
branch  2 taken 0 (throw)
    16189:  786:    ImVec2 size = CalcItemSize(size_arg, 0.0f, 0.0f);
    16189:  786-block 10
call    0 returned 16189
branch  1 taken 16189 (fallthrough)
branch  2 taken 0 (throw)
    16189:  787:    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);
    16189:  787-block 11
call    0 returned 16189
call    1 returned 16189
    16189:  788:    ItemSize(size);
call    0 returned 16189
branch  1 taken 16189 (fallthrough)
branch  2 taken 0 (throw)
   16189*:  789:    if (!ItemAdd(bb, id, NULL, (flags & ImGuiButtonFlags_EnableNav) ? ImGuiItemFlags_None : ImGuiItemFlags_NoNav))
    16189:  789-block 14
branch  0 taken 0 (fallthrough)
branch  1 taken 16189
    %%%%%:  789-block 15
    16189:  789-block 16
    16189:  789-block 17
call    2 returned 16189
branch  3 taken 16189 (fallthrough)
branch  4 taken 0 (throw)
    16189:  789-block 18
branch  5 taken 16140 (fallthrough)
branch  6 taken 49
    16140:  790:        return false;
    16140:  790-block 19
        -:  791:
        -:  792:    bool hovered, held;
       49:  793:    bool pressed = ButtonBehavior(bb, id, &hovered, &held, flags);
       49:  793-block 20
call    0 returned 49
branch  1 taken 49 (fallthrough)
branch  2 taken 0 (throw)
       49:  794:    RenderNavCursor(bb, id);
       49:  794-block 21
call    0 returned 49
branch  1 taken 49 (fallthrough)
branch  2 taken 0 (throw)
        -:  795:
        -:  796:    IMGUI_TEST_ENGINE_ITEM_INFO(id, str_id, g.LastItemData.StatusFlags);
       49:  797:    return pressed;
       49:  797-block 22
        -:  798:}
        -:  799:
function _ZN5ImGui13ArrowButtonExEPKc8ImGuiDir6ImVec2i called 0 returned 0% blocks executed 0%
    #####:  800:bool ImGui::ArrowButtonEx(const char* str_id, ImGuiDir dir, ImVec2 size, ImGuiButtonFlags flags)
        -:  801:{
    #####:  802:    ImGuiContext& g = *GImGui;
    #####:  803:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%:  803-block 2
call    0 never executed
    #####:  804:    if (window->SkipItems)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  805:        return false;
    %%%%%:  805-block 4
        -:  806:
    #####:  807:    const ImGuiID id = window->GetID(str_id);
    %%%%%:  807-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  808:    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);
    %%%%%:  808-block 6
call    0 never executed
call    1 never executed
    #####:  809:    const float default_size = GetFrameHeight();
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  810:    ItemSize(size, (size.y >= default_size) ? g.Style.FramePadding.y : -1.0f);
    %%%%%:  810-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  810-block 10
    %%%%%:  810-block 11
    %%%%%:  810-block 12
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####:  811:    if (!ItemAdd(bb, id))
    %%%%%:  811-block 13
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:  811-block 14
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:  812:        return false;
    %%%%%:  812-block 15
        -:  813:
        -:  814:    bool hovered, held;
    #####:  815:    bool pressed = ButtonBehavior(bb, id, &hovered, &held, flags);
    %%%%%:  815-block 16
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:  816:
        -:  817:    // Render
    #####:  818:    const ImU32 bg_col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);
    %%%%%:  818-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  818-block 18
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:  818-block 19
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:  818-block 20
    %%%%%:  818-block 21
    %%%%%:  818-block 22
    %%%%%:  818-block 23
    %%%%%:  818-block 24
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed (throw)
    #####:  819:    const ImU32 text_col = GetColorU32(ImGuiCol_Text);
    %%%%%:  819-block 25
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  820:    RenderNavCursor(bb, id);
    %%%%%:  820-block 26
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  821:    RenderFrame(bb.Min, bb.Max, bg_col, true, g.Style.FrameRounding);
    %%%%%:  821-block 27
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  822:    RenderArrow(window->DrawList, bb.Min + ImVec2(ImMax(0.0f, (size.x - g.FontSize) * 0.5f), ImMax(0.0f, (size.y - g.FontSize) * 0.5f)), text_col, dir);
    %%%%%:  822-block 28
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    $$$$$:  822-block 36
        -:  823:
        -:  824:    IMGUI_TEST_ENGINE_ITEM_INFO(id, str_id, g.LastItemData.StatusFlags);
    #####:  825:    return pressed;
    %%%%%:  825-block 33
        -:  826:}
        -:  827:
function _ZN5ImGui11ArrowButtonEPKc8ImGuiDir called 0 returned 0% blocks executed 0%
    #####:  828:bool ImGui::ArrowButton(const char* str_id, ImGuiDir dir)
        -:  829:{
    #####:  830:    float sz = GetFrameHeight();
    %%%%%:  830-block 2
call    0 never executed
    #####:  831:    return ArrowButtonEx(str_id, dir, ImVec2(sz, sz), ImGuiButtonFlags_None);
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:  831-block 5
    %%%%%:  831-block 6
    %%%%%:  831-block 7
        -:  832:}
        -:  833:
        -:  834:// Button to close a window
function _ZN5ImGui11CloseButtonEjRK6ImVec2 called 5380 returned 100% blocks executed 67%
     5380:  835:bool ImGui::CloseButton(ImGuiID id, const ImVec2& pos)
        -:  836:{
     5380:  837:    ImGuiContext& g = *GImGui;
     5380:  838:    ImGuiWindow* window = g.CurrentWindow;
        -:  839:
        -:  840:    // Tweak 1: Shrink hit-testing area if button covers an abnormally large proportion of the visible region. That's in order to facilitate moving the window away. (#3825)
        -:  841:    // This may better be applied as a general hit-rect reduction mechanism for all widgets to ensure the area to move window is always accessible?
     5380:  842:    const ImRect bb(pos, pos + ImVec2(g.FontSize, g.FontSize));
     5380:  842-block 2
call    0 returned 5380
call    1 returned 5380
call    2 returned 5380
     5380:  843:    ImRect bb_interact = bb;
     5380:  844:    const float area_to_visible_ratio = window->OuterRectClipped.GetArea() / bb.GetArea();
call    0 returned 5380
call    1 returned 5380
     5380:  845:    if (area_to_visible_ratio < 1.5f)
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    #####:  846:        bb_interact.Expand(ImTrunc(bb_interact.GetSize() * -0.25f));
    %%%%%:  846-block 8
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  847:
        -:  848:    // Tweak 2: We intentionally allow interaction when clipped so that a mechanical Alt,Right,Activate sequence can always close a window.
        -:  849:    // (this isn't the common behavior of buttons, but it doesn't affect the user because navigation tends to keep items visible in scrolling layer).
     5380:  850:    bool is_clipped = !ItemAdd(bb_interact, id);
     5380:  850-block 13
call    0 returned 5380
branch  1 taken 5380 (fallthrough)
branch  2 taken 0 (throw)
        -:  851:
        -:  852:    bool hovered, held;
     5380:  853:    bool pressed = ButtonBehavior(bb_interact, id, &hovered, &held);
     5380:  853-block 14
call    0 returned 5380
branch  1 taken 5380 (fallthrough)
branch  2 taken 0 (throw)
     5380:  854:    if (is_clipped)
     5380:  854-block 15
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    #####:  855:        return pressed;
    %%%%%:  855-block 16
        -:  856:
        -:  857:    // Render
    5380*:  858:    ImU32 bg_col = GetColorU32(held ? ImGuiCol_ButtonActive : ImGuiCol_ButtonHovered);
     5380:  858-block 17
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    %%%%%:  858-block 18
     5380:  858-block 19
     5380:  858-block 20
call    2 returned 5380
branch  3 taken 5380 (fallthrough)
branch  4 taken 0 (throw)
     5380:  859:    if (hovered)
     5380:  859-block 21
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    #####:  860:        window->DrawList->AddRectFilled(bb.Min, bb.Max, bg_col);
    %%%%%:  860-block 22
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
     5380:  861:    RenderNavCursor(bb, id, ImGuiNavRenderCursorFlags_Compact);
     5380:  861-block 23
call    0 returned 5380
branch  1 taken 5380 (fallthrough)
branch  2 taken 0 (throw)
     5380:  862:    ImU32 cross_col = GetColorU32(ImGuiCol_Text);
     5380:  862-block 24
call    0 returned 5380
branch  1 taken 5380 (fallthrough)
branch  2 taken 0 (throw)
     5380:  863:    ImVec2 cross_center = bb.GetCenter() - ImVec2(0.5f, 0.5f);
     5380:  863-block 25
call    0 returned 5380
call    1 returned 5380
call    2 returned 5380
     5380:  864:    float cross_extent = g.FontSize * 0.5f * 0.7071f - 1.0f;
     5380:  865:    window->DrawList->AddLine(cross_center + ImVec2(+cross_extent, +cross_extent), cross_center + ImVec2(-cross_extent, -cross_extent), cross_col, 1.0f);
call    0 returned 5380
call    1 returned 5380
call    2 returned 5380
call    3 returned 5380
call    4 returned 5380
branch  5 taken 5380 (fallthrough)
branch  6 taken 0 (throw)
    $$$$$:  865-block 41
    $$$$$:  865-block 42
    $$$$$:  865-block 43
    $$$$$:  865-block 44
     5380:  866:    window->DrawList->AddLine(cross_center + ImVec2(+cross_extent, -cross_extent), cross_center + ImVec2(-cross_extent, +cross_extent), cross_col, 1.0f);
     5380:  866-block 33
call    0 returned 5380
call    1 returned 5380
call    2 returned 5380
call    3 returned 5380
call    4 returned 5380
branch  5 taken 5380 (fallthrough)
branch  6 taken 0 (throw)
    $$$$$:  866-block 45
    $$$$$:  866-block 46
    $$$$$:  866-block 47
    $$$$$:  866-block 48
        -:  867:
     5380:  868:    return pressed;
     5380:  868-block 38
        -:  869:}
        -:  870:
        -:  871:// The Collapse button also functions as a Dock Menu button.
function _ZN5ImGui14CollapseButtonEjRK6ImVec2P13ImGuiDockNode called 6457 returned 100% blocks executed 74%
     6457:  872:bool ImGui::CollapseButton(ImGuiID id, const ImVec2& pos, ImGuiDockNode* dock_node)
        -:  873:{
     6457:  874:    ImGuiContext& g = *GImGui;
     6457:  875:    ImGuiWindow* window = g.CurrentWindow;
        -:  876:
     6457:  877:    ImRect bb(pos, pos + ImVec2(g.FontSize, g.FontSize));
     6457:  877-block 2
call    0 returned 6457
call    1 returned 6457
call    2 returned 6457
     6457:  878:    bool is_clipped = !ItemAdd(bb, id);
call    0 returned 6457
branch  1 taken 6457 (fallthrough)
branch  2 taken 0 (throw)
        -:  879:    bool hovered, held;
     6457:  880:    bool pressed = ButtonBehavior(bb, id, &hovered, &held, ImGuiButtonFlags_None);
     6457:  880-block 6
call    0 returned 6457
branch  1 taken 6457 (fallthrough)
branch  2 taken 0 (throw)
     6457:  881:    if (is_clipped)
     6457:  881-block 7
branch  0 taken 0 (fallthrough)
branch  1 taken 6457
    #####:  882:        return pressed;
    %%%%%:  882-block 8
        -:  883:
        -:  884:    // Render
        -:  885:    //bool is_dock_menu = (window->DockNodeAsHost && !window->Collapsed);
    6457*:  886:    ImU32 bg_col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);
     6457:  886-block 9
branch  0 taken 0 (fallthrough)
branch  1 taken 6457
    %%%%%:  886-block 10
branch  2 never executed (fallthrough)
branch  3 never executed
     6457:  886-block 11
branch  4 taken 0 (fallthrough)
branch  5 taken 6457
    %%%%%:  886-block 12
     6457:  886-block 13
     6457:  886-block 14
    %%%%%:  886-block 15
     6457:  886-block 16
call    6 returned 6457
branch  7 taken 6457 (fallthrough)
branch  8 taken 0 (throw)
     6457:  887:    ImU32 text_col = GetColorU32(ImGuiCol_Text);
     6457:  887-block 17
call    0 returned 6457
branch  1 taken 6457 (fallthrough)
branch  2 taken 0 (throw)
     6457:  888:    if (hovered || held)
     6457:  888-block 18
branch  0 taken 6457 (fallthrough)
branch  1 taken 0
     6457:  888-block 19
branch  2 taken 0 (fallthrough)
branch  3 taken 6457
    #####:  889:        window->DrawList->AddRectFilled(bb.Min, bb.Max, bg_col);
    %%%%%:  889-block 20
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
     6457:  890:    RenderNavCursor(bb, id, ImGuiNavRenderCursorFlags_Compact);
     6457:  890-block 21
call    0 returned 6457
branch  1 taken 6457 (fallthrough)
branch  2 taken 0 (throw)
        -:  891:
     6457:  892:    if (dock_node)
     6457:  892-block 22
branch  0 taken 5380 (fallthrough)
branch  1 taken 1077
     5380:  893:        RenderArrowDockMenu(window->DrawList, bb.Min, g.FontSize, text_col);
     5380:  893-block 23
call    0 returned 5380
branch  1 taken 5380 (fallthrough)
branch  2 taken 0 (throw)
        -:  894:    else
    1077*:  895:        RenderArrow(window->DrawList, bb.Min, text_col, window->Collapsed ? ImGuiDir_Right : ImGuiDir_Down, 1.0f);
     1077:  895-block 24
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:  895-block 25
     1077:  895-block 26
     1077:  895-block 27
call    2 returned 1077
branch  3 taken 1077 (fallthrough)
branch  4 taken 0 (throw)
        -:  896:
        -:  897:    // Switch to moving the window after mouse is moved beyond the initial drag threshold
    6457*:  898:    if (IsItemActive() && IsMouseDragging(0))
     6457:  898-block 28
call    0 returned 6457
branch  1 taken 6457 (fallthrough)
branch  2 taken 0 (throw)
     6457:  898-block 29
branch  3 taken 0 (fallthrough)
branch  4 taken 6457
    %%%%%:  898-block 30
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
    %%%%%:  898-block 31
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%:  898-block 32
     6457:  898-block 33
     6457:  898-block 34
branch 10 taken 0 (fallthrough)
branch 11 taken 6457
    #####:  899:        StartMouseMovingWindowOrNode(window, dock_node, true); // Undock from window/collapse menu button
    %%%%%:  899-block 35
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:  900:
     6457:  901:    return pressed;
     6457:  901-block 36
        -:  902:}
        -:  903:
function _ZN5ImGui20GetWindowScrollbarIDEP11ImGuiWindow9ImGuiAxis called 7534 returned 100% blocks executed 100%
     7534:  904:ImGuiID ImGui::GetWindowScrollbarID(ImGuiWindow* window, ImGuiAxis axis)
        -:  905:{
     7534:  906:    return window->GetID(axis == ImGuiAxis_X ? "#SCROLLX" : "#SCROLLY");
     7534:  906-block 2
branch  0 taken 2152 (fallthrough)
branch  1 taken 5382
     2152:  906-block 3
     5382:  906-block 4
     7534:  906-block 5
call    2 returned 7534
        -:  907:}
        -:  908:
        -:  909:// Return scrollbar rectangle, must only be called for corresponding axis if window->ScrollbarX/Y is set.
function _ZN5ImGui22GetWindowScrollbarRectEP11ImGuiWindow9ImGuiAxis called 7534 returned 100% blocks executed 93%
     7534:  910:ImRect ImGui::GetWindowScrollbarRect(ImGuiWindow* window, ImGuiAxis axis)
        -:  911:{
     7534:  912:    const ImRect outer_rect = window->Rect();
     7534:  912-block 2
call    0 returned 7534
     7534:  913:    const ImRect inner_rect = window->InnerRect;
     7534:  914:    const float border_size = window->WindowBorderSize;
     7534:  915:    const float scrollbar_size = window->ScrollbarSizes[axis ^ 1]; // (ScrollbarSizes.x = width of Y scrollbar; ScrollbarSizes.y = height of X scrollbar)
call    0 returned 7534
    7534*:  916:    IM_ASSERT(scrollbar_size > 0.0f);
branch  0 taken 0 (fallthrough)
branch  1 taken 7534
    %%%%%:  916-block 5
call    2 never executed
     7534:  917:    if (axis == ImGuiAxis_X)
     7534:  917-block 6
branch  0 taken 2152 (fallthrough)
branch  1 taken 5382
     2152:  918:        return ImRect(inner_rect.Min.x, ImMax(outer_rect.Min.y, outer_rect.Max.y - border_size - scrollbar_size), inner_rect.Max.x - border_size, outer_rect.Max.y - border_size);
     2152:  918-block 7
call    0 returned 2152
call    1 returned 2152
     2152:  918-block 10
        -:  919:    else
     5382:  920:        return ImRect(ImMax(outer_rect.Min.x, outer_rect.Max.x - border_size - scrollbar_size), inner_rect.Min.y, outer_rect.Max.x - border_size, inner_rect.Max.y - border_size);
     5382:  920-block 11
call    0 returned 5382
call    1 returned 5382
     5382:  920-block 14
        -:  921:}
        -:  922:
function _ZN5ImGui9ScrollbarE9ImGuiAxis called 7534 returned 100% blocks executed 100%
     7534:  923:void ImGui::Scrollbar(ImGuiAxis axis)
        -:  924:{
     7534:  925:    ImGuiContext& g = *GImGui;
     7534:  926:    ImGuiWindow* window = g.CurrentWindow;
     7534:  927:    const ImGuiID id = GetWindowScrollbarID(window, axis);
     7534:  927-block 2
call    0 returned 7534
branch  1 taken 7534 (fallthrough)
branch  2 taken 0 (throw)
        -:  928:
        -:  929:    // Calculate scrollbar bounding box
     7534:  930:    ImRect bb = GetWindowScrollbarRect(window, axis);
     7534:  930-block 3
call    0 returned 7534
branch  1 taken 7534 (fallthrough)
branch  2 taken 0 (throw)
     7534:  931:    ImDrawFlags rounding_corners = ImDrawFlags_RoundCornersNone;
     7534:  932:    if (axis == ImGuiAxis_X)
     7534:  932-block 4
branch  0 taken 2152 (fallthrough)
branch  1 taken 5382
        -:  933:    {
     2152:  934:        rounding_corners |= ImDrawFlags_RoundCornersBottomLeft;
     2152:  935:        if (!window->ScrollbarY)
     2152:  935-block 5
branch  0 taken 1075 (fallthrough)
branch  1 taken 1077
     1075:  936:            rounding_corners |= ImDrawFlags_RoundCornersBottomRight;
     1075:  936-block 6
        -:  937:    }
        -:  938:    else
        -:  939:    {
     5382:  940:        if ((window->Flags & ImGuiWindowFlags_NoTitleBar) && !(window->Flags & ImGuiWindowFlags_MenuBar))
     5382:  940-block 7
branch  0 taken 3229 (fallthrough)
branch  1 taken 2153
     3229:  940-block 8
branch  2 taken 3229 (fallthrough)
branch  3 taken 0
     3229:  941:            rounding_corners |= ImDrawFlags_RoundCornersTopRight;
     3229:  941-block 9
     5382:  942:        if (!window->ScrollbarX)
     5382:  942-block 10
branch  0 taken 4305 (fallthrough)
branch  1 taken 1077
     4305:  943:            rounding_corners |= ImDrawFlags_RoundCornersBottomRight;
     4305:  943-block 11
        -:  944:    }
     7534:  945:    float size_visible = window->InnerRect.Max[axis] - window->InnerRect.Min[axis];
     7534:  945-block 12
call    0 returned 7534
call    1 returned 7534
     7534:  946:    float size_contents = window->ContentSize[axis] + window->WindowPadding[axis] * 2.0f;
call    0 returned 7534
call    1 returned 7534
     7534:  947:    ImS64 scroll = (ImS64)window->Scroll[axis];
call    0 returned 7534
     7534:  948:    ScrollbarEx(bb, id, axis, &scroll, (ImS64)size_visible, (ImS64)size_contents, rounding_corners);
call    0 returned 7534
branch  1 taken 7534 (fallthrough)
branch  2 taken 0 (throw)
     7534:  949:    window->Scroll[axis] = (float)scroll;
     7534:  949-block 18
call    0 returned 7534
     7534:  950:}
        -:  951:
        -:  952:// Vertical/Horizontal scrollbar
        -:  953:// The entire piece of code below is rather confusing because:
        -:  954:// - We handle absolute seeking (when first clicking outside the grab) and relative manipulation (afterward or when clicking inside the grab)
        -:  955:// - We store values as normalized ratio and in a form that allows the window content to change while we are holding on a scrollbar
        -:  956:// - We handle both horizontal and vertical scrollbars, which makes the terminology not ideal.
        -:  957:// Still, the code should probably be made simpler..
function _ZN5ImGui11ScrollbarExERK6ImRectj9ImGuiAxisPxxxi called 7534 returned 100% blocks executed 49%
     7534:  958:bool ImGui::ScrollbarEx(const ImRect& bb_frame, ImGuiID id, ImGuiAxis axis, ImS64* p_scroll_v, ImS64 size_visible_v, ImS64 size_contents_v, ImDrawFlags flags)
        -:  959:{
     7534:  960:    ImGuiContext& g = *GImGui;
     7534:  961:    ImGuiWindow* window = g.CurrentWindow;
     7534:  962:    if (window->SkipItems)
     7534:  962-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 7534
    #####:  963:        return false;
    %%%%%:  963-block 3
        -:  964:
     7534:  965:    const float bb_frame_width = bb_frame.GetWidth();
     7534:  965-block 4
call    0 returned 7534
     7534:  966:    const float bb_frame_height = bb_frame.GetHeight();
call    0 returned 7534
     7534:  967:    if (bb_frame_width <= 0.0f || bb_frame_height <= 0.0f)
branch  0 taken 7534 (fallthrough)
branch  1 taken 0
     7534:  967-block 7
branch  2 taken 0 (fallthrough)
branch  3 taken 7534
    #####:  968:        return false;
    %%%%%:  968-block 8
        -:  969:
        -:  970:    // When we are too small, start hiding and disabling the grab (this reduce visual noise on very small window and facilitate using the window resize grab)
     7534:  971:    float alpha = 1.0f;
     7534:  972:    if ((axis == ImGuiAxis_Y) && bb_frame_height < g.FontSize + g.Style.FramePadding.y * 2.0f)
     7534:  972-block 9
branch  0 taken 5382 (fallthrough)
branch  1 taken 2152
     5382:  972-block 10
branch  2 taken 0 (fallthrough)
branch  3 taken 5382
    #####:  973:        alpha = ImSaturate((bb_frame_height - g.FontSize) / (g.Style.FramePadding.y * 2.0f));
    %%%%%:  973-block 11
call    0 never executed
     7534:  974:    if (alpha <= 0.0f)
     7534:  974-block 12
branch  0 taken 0 (fallthrough)
branch  1 taken 7534
    #####:  975:        return false;
    %%%%%:  975-block 13
        -:  976:
     7534:  977:    const ImGuiStyle& style = g.Style;
     7534:  978:    const bool allow_interaction = (alpha >= 1.0f);
        -:  979:
     7534:  980:    ImRect bb = bb_frame;
     7534:  981:    bb.Expand(ImVec2(-ImClamp(IM_TRUNC((bb_frame_width - 2.0f) * 0.5f), 0.0f, 3.0f), -ImClamp(IM_TRUNC((bb_frame_height - 2.0f) * 0.5f), 0.0f, 3.0f)));
     7534:  981-block 14
call    0 returned 7534
call    1 returned 7534
call    2 returned 7534
call    3 returned 7534
        -:  982:
        -:  983:    // V denote the main, longer axis of the scrollbar (= height for a vertical scrollbar)
     7534:  984:    const float scrollbar_size_v = (axis == ImGuiAxis_X) ? bb.GetWidth() : bb.GetHeight();
branch  0 taken 2152 (fallthrough)
branch  1 taken 5382
     2152:  984-block 19
call    2 returned 2152
     5382:  984-block 20
call    3 returned 5382
        -:  985:
        -:  986:    // Calculate the height of our grabbable box. It generally represent the amount visible (vs the total scrollable amount)
        -:  987:    // But we maintain a minimum size in pixel to allow for the user to still aim inside.
    7534*:  988:    IM_ASSERT(ImMax(size_contents_v, size_visible_v) > 0.0f); // Adding this assert to check if the ImMax(XXX,1.0f) is still needed. PLEASE CONTACT ME if this triggers.
     7534:  988-block 21
call    0 returned 7534
branch  1 taken 0 (fallthrough)
branch  2 taken 7534
    %%%%%:  988-block 23
call    3 never executed
     7534:  989:    const ImS64 win_size_v = ImMax(ImMax(size_contents_v, size_visible_v), (ImS64)1);
     7534:  989-block 24
call    0 returned 7534
call    1 returned 7534
     7534:  990:    const float grab_h_pixels = ImClamp(scrollbar_size_v * ((float)size_visible_v / (float)win_size_v), style.GrabMinSize, scrollbar_size_v);
call    0 returned 7534
     7534:  991:    const float grab_h_norm = grab_h_pixels / scrollbar_size_v;
        -:  992:
        -:  993:    // Handle input right away. None of the code of Begin() is relying on scrolling position before calling Scrollbar().
     7534:  994:    bool held = false;
     7534:  995:    bool hovered = false;
     7534:  996:    ItemAdd(bb_frame, id, NULL, ImGuiItemFlags_NoNav);
call    0 returned 7534
branch  1 taken 7534 (fallthrough)
branch  2 taken 0 (throw)
     7534:  997:    ButtonBehavior(bb, id, &hovered, &held, ImGuiButtonFlags_NoNavFocus);
     7534:  997-block 28
call    0 returned 7534
branch  1 taken 7534 (fallthrough)
branch  2 taken 0 (throw)
        -:  998:
     7534:  999:    const ImS64 scroll_max = ImMax((ImS64)1, size_contents_v - size_visible_v);
     7534:  999-block 29
call    0 returned 7534
     7534: 1000:    float scroll_ratio = ImSaturate((float)*p_scroll_v / (float)scroll_max);
call    0 returned 7534
     7534: 1001:    float grab_v_norm = scroll_ratio * (scrollbar_size_v - grab_h_pixels) / scrollbar_size_v; // Grab position in normalized space
    7534*: 1002:    if (held && allow_interaction && grab_h_norm < 1.0f)
branch  0 taken 0 (fallthrough)
branch  1 taken 7534
    %%%%%: 1002-block 32
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1002-block 33
branch  4 never executed (fallthrough)
branch  5 never executed
        -: 1003:    {
    #####: 1004:        const float scrollbar_pos_v = bb.Min[axis];
    %%%%%: 1004-block 34
call    0 never executed
    #####: 1005:        const float mouse_pos_v = g.IO.MousePos[axis];
call    0 never executed
        -: 1006:
        -: 1007:        // Click position in scrollbar normalized space (0.0f->1.0f)
    #####: 1008:        const float clicked_v_norm = ImSaturate((mouse_pos_v - scrollbar_pos_v) / scrollbar_size_v);
call    0 never executed
        -: 1009:
    #####: 1010:        const int held_dir = (clicked_v_norm < grab_v_norm) ? -1 : (clicked_v_norm > grab_v_norm + grab_h_norm) ? +1 : 0;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1010-block 38
    %%%%%: 1010-block 39
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1010-block 40
    %%%%%: 1010-block 41
    %%%%%: 1010-block 42
    #####: 1011:        if (g.ActiveIdIsJustActivated)
    %%%%%: 1011-block 43
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1012:        {
        -: 1013:            // On initial click when held_dir == 0 (clicked over grab): calculate the distance between mouse and the center of the grab
    #####: 1014:            const bool scroll_to_clicked_location = (g.IO.ConfigScrollbarScrollByPage == false || g.IO.KeyShift || held_dir == 0);
    %%%%%: 1014-block 44
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1014-block 45
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1014-block 46
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 1014-block 47
    %%%%%: 1014-block 48
    #####: 1015:            g.ScrollbarSeekMode = scroll_to_clicked_location ? 0 : (short)held_dir;
    %%%%%: 1015-block 49
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1015-block 50
    %%%%%: 1015-block 51
    #####: 1016:            g.ScrollbarClickDeltaToGrabCenter = (held_dir == 0 && !g.IO.KeyShift) ? clicked_v_norm - grab_v_norm - grab_h_norm * 0.5f : 0.0f;
    %%%%%: 1016-block 52
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1016-block 53
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1016-block 54
    %%%%%: 1016-block 55
    %%%%%: 1016-block 56
        -: 1017:        }
        -: 1018:
        -: 1019:        // Apply scroll (p_scroll_v will generally point on one member of window->Scroll)
        -: 1020:        // It is ok to modify Scroll here because we are being called in Begin() after the calculation of ContentSize and before setting up our starting position
    #####: 1021:        if (g.ScrollbarSeekMode == 0)
    %%%%%: 1021-block 57
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1022:        {
        -: 1023:            // Absolute seeking
    #####: 1024:            const float scroll_v_norm = ImSaturate((clicked_v_norm - g.ScrollbarClickDeltaToGrabCenter - grab_h_norm * 0.5f) / (1.0f - grab_h_norm));
    %%%%%: 1024-block 58
call    0 never executed
    #####: 1025:            *p_scroll_v = (ImS64)(scroll_v_norm * scroll_max);
        -: 1026:        }
        -: 1027:        else
        -: 1028:        {
        -: 1029:            // Page by page
    #####: 1030:            if (IsMouseClicked(ImGuiMouseButton_Left, ImGuiInputFlags_Repeat) && held_dir == g.ScrollbarSeekMode)
    %%%%%: 1030-block 60
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1030-block 61
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 1030-block 62
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 1030-block 63
    %%%%%: 1030-block 64
    %%%%%: 1030-block 65
branch  7 never executed (fallthrough)
branch  8 never executed
        -: 1031:            {
    #####: 1032:                float page_dir = (g.ScrollbarSeekMode > 0.0f) ? +1.0f : -1.0f;
    %%%%%: 1032-block 66
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1032-block 67
    %%%%%: 1032-block 68
    #####: 1033:                *p_scroll_v = ImClamp(*p_scroll_v + (ImS64)(page_dir * size_visible_v), (ImS64)0, scroll_max);
    %%%%%: 1033-block 69
call    0 never executed
        -: 1034:            }
        -: 1035:        }
        -: 1036:
        -: 1037:        // Update values for rendering
    #####: 1038:        scroll_ratio = ImSaturate((float)*p_scroll_v / (float)scroll_max);
    %%%%%: 1038-block 71
call    0 never executed
    #####: 1039:        grab_v_norm = scroll_ratio * (scrollbar_size_v - grab_h_pixels) / scrollbar_size_v;
        -: 1040:
        -: 1041:        // Update distance to grab now that we have seek'ed and saturated
        -: 1042:        //if (seek_absolute)
        -: 1043:        //    g.ScrollbarClickDeltaToGrabCenter = clicked_v_norm - grab_v_norm - grab_h_norm * 0.5f;
        -: 1044:    }
        -: 1045:
        -: 1046:    // Render
     7534: 1047:    const ImU32 bg_col = GetColorU32(ImGuiCol_ScrollbarBg);
     7534: 1047-block 73
call    0 returned 7534
branch  1 taken 7534 (fallthrough)
branch  2 taken 0 (throw)
    7534*: 1048:    const ImU32 grab_col = GetColorU32(held ? ImGuiCol_ScrollbarGrabActive : hovered ? ImGuiCol_ScrollbarGrabHovered : ImGuiCol_ScrollbarGrab, alpha);
     7534: 1048-block 74
branch  0 taken 0 (fallthrough)
branch  1 taken 7534
    %%%%%: 1048-block 75
     7534: 1048-block 76
branch  2 taken 0 (fallthrough)
branch  3 taken 7534
    %%%%%: 1048-block 77
     7534: 1048-block 78
     7534: 1048-block 79
     7534: 1048-block 80
call    4 returned 7534
branch  5 taken 7534 (fallthrough)
branch  6 taken 0 (throw)
     7534: 1049:    window->DrawList->AddRectFilled(bb_frame.Min, bb_frame.Max, bg_col, window->WindowRounding, flags);
     7534: 1049-block 81
call    0 returned 7534
branch  1 taken 7534 (fallthrough)
branch  2 taken 0 (throw)
     7534: 1050:    ImRect grab_rect;
     7534: 1051:    if (axis == ImGuiAxis_X)
     7534: 1051-block 82
branch  0 taken 2152 (fallthrough)
branch  1 taken 5382
     2152: 1052:        grab_rect = ImRect(ImLerp(bb.Min.x, bb.Max.x, grab_v_norm), bb.Min.y, ImLerp(bb.Min.x, bb.Max.x, grab_v_norm) + grab_h_pixels, bb.Max.y);
     2152: 1052-block 83
call    0 returned 2152
call    1 returned 2152
call    2 returned 2152
        -: 1053:    else
     5382: 1054:        grab_rect = ImRect(bb.Min.x, ImLerp(bb.Min.y, bb.Max.y, grab_v_norm), bb.Max.x, ImLerp(bb.Min.y, bb.Max.y, grab_v_norm) + grab_h_pixels);
     5382: 1054-block 87
call    0 returned 5382
call    1 returned 5382
call    2 returned 5382
     7534: 1055:    window->DrawList->AddRectFilled(grab_rect.Min, grab_rect.Max, grab_col, style.ScrollbarRounding);
     7534: 1055-block 91
call    0 returned 7534
branch  1 taken 7534 (fallthrough)
branch  2 taken 0 (throw)
        -: 1056:
     7534: 1057:    return held;
     7534: 1057-block 92
        -: 1058:}
        -: 1059:
        -: 1060:// - Read about ImTextureID here: https://github.com/ocornut/imgui/wiki/Image-Loading-and-Displaying-Examples
        -: 1061:// - 'uv0' and 'uv1' are texture coordinates. Read about them from the same link above.
function _ZN5ImGui5ImageEyRK6ImVec2S2_S2_RK6ImVec4S5_ called 0 returned 0% blocks executed 0%
    #####: 1062:void ImGui::Image(ImTextureID user_texture_id, const ImVec2& image_size, const ImVec2& uv0, const ImVec2& uv1, const ImVec4& tint_col, const ImVec4& border_col)
        -: 1063:{
    #####: 1064:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%: 1064-block 2
call    0 never executed
    #####: 1065:    if (window->SkipItems)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1066:        return;
    %%%%%: 1066-block 4
    %%%%%: 1066-block 25
        -: 1067:
    #####: 1068:    const float border_size = (border_col.w > 0.0f) ? 1.0f : 0.0f;
    %%%%%: 1068-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1068-block 6
    %%%%%: 1068-block 7
    #####: 1069:    const ImVec2 padding(border_size, border_size);
    %%%%%: 1069-block 8
call    0 never executed
    #####: 1070:    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + image_size + padding * 2.0f);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1071:    ItemSize(bb);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1072:    if (!ItemAdd(bb, 0))
    %%%%%: 1072-block 14
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1072-block 15
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 1073:        return;
    %%%%%: 1073-block 16
        -: 1074:
        -: 1075:    // Render
    #####: 1076:    if (border_size > 0.0f)
    %%%%%: 1076-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1077:        window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(border_col), 0.0f, ImDrawFlags_None, border_size);
    %%%%%: 1077-block 18
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1077-block 19
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    #####: 1078:    window->DrawList->AddImage(user_texture_id, bb.Min + padding, bb.Max - padding, uv0, uv1, GetColorU32(tint_col));
    %%%%%: 1078-block 20
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1078-block 21
call    3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
    %%%%%: 1078-block 24
    $$$$$: 1078-block 27
    $$$$$: 1078-block 28
        -: 1079:}
        -: 1080:
        -: 1081:// ImageButton() is flawed as 'id' is always derived from 'texture_id' (see #2464 #1390)
        -: 1082:// We provide this internal helper to write your own variant while we figure out how to redesign the public ImageButton() API.
function _ZN5ImGui13ImageButtonExEjyRK6ImVec2S2_S2_RK6ImVec4S5_i called 0 returned 0% blocks executed 0%
    #####: 1083:bool ImGui::ImageButtonEx(ImGuiID id, ImTextureID texture_id, const ImVec2& image_size, const ImVec2& uv0, const ImVec2& uv1, const ImVec4& bg_col, const ImVec4& tint_col, ImGuiButtonFlags flags)
        -: 1084:{
    #####: 1085:    ImGuiContext& g = *GImGui;
    #####: 1086:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%: 1086-block 2
call    0 never executed
    #####: 1087:    if (window->SkipItems)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1088:        return false;
    %%%%%: 1088-block 4
        -: 1089:
    #####: 1090:    const ImVec2 padding = g.Style.FramePadding;
    #####: 1091:    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + image_size + padding * 2.0f);
    %%%%%: 1091-block 5
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1092:    ItemSize(bb);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1093:    if (!ItemAdd(bb, id))
    %%%%%: 1093-block 10
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1093-block 11
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 1094:        return false;
    %%%%%: 1094-block 12
        -: 1095:
        -: 1096:    bool hovered, held;
    #####: 1097:    bool pressed = ButtonBehavior(bb, id, &hovered, &held, flags);
    %%%%%: 1097-block 13
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 1098:
        -: 1099:    // Render
    #####: 1100:    const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);
    %%%%%: 1100-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1100-block 15
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1100-block 16
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 1100-block 17
    %%%%%: 1100-block 18
    %%%%%: 1100-block 19
    %%%%%: 1100-block 20
    %%%%%: 1100-block 21
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed (throw)
    #####: 1101:    RenderNavCursor(bb, id);
    %%%%%: 1101-block 22
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1102:    RenderFrame(bb.Min, bb.Max, col, true, ImClamp((float)ImMin(padding.x, padding.y), 0.0f, g.Style.FrameRounding));
    %%%%%: 1102-block 23
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####: 1103:    if (bg_col.w > 0.0f)
    %%%%%: 1103-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1104:        window->DrawList->AddRectFilled(bb.Min + padding, bb.Max - padding, GetColorU32(bg_col));
    %%%%%: 1104-block 27
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1104-block 28
call    3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
    %%%%%: 1104-block 31
    $$$$$: 1104-block 39
    $$$$$: 1104-block 40
    #####: 1105:    window->DrawList->AddImage(texture_id, bb.Min + padding, bb.Max - padding, uv0, uv1, GetColorU32(tint_col));
    %%%%%: 1105-block 32
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1105-block 33
call    3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
    $$$$$: 1105-block 41
    $$$$$: 1105-block 42
        -: 1106:
    #####: 1107:    return pressed;
    %%%%%: 1107-block 36
        -: 1108:}
        -: 1109:
        -: 1110:// Note that ImageButton() adds style.FramePadding*2.0f to provided size. This is in order to facilitate fitting an image in a button.
function _ZN5ImGui11ImageButtonEPKcyRK6ImVec2S4_S4_RK6ImVec4S7_ called 0 returned 0% blocks executed 0%
    #####: 1111:bool ImGui::ImageButton(const char* str_id, ImTextureID user_texture_id, const ImVec2& image_size, const ImVec2& uv0, const ImVec2& uv1, const ImVec4& bg_col, const ImVec4& tint_col)
        -: 1112:{
    #####: 1113:    ImGuiContext& g = *GImGui;
    #####: 1114:    ImGuiWindow* window = g.CurrentWindow;
    #####: 1115:    if (window->SkipItems)
    %%%%%: 1115-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1116:        return false;
    %%%%%: 1116-block 3
        -: 1117:
    #####: 1118:    return ImageButtonEx(window->GetID(str_id), user_texture_id, image_size, uv0, uv1, bg_col, tint_col);
    %%%%%: 1118-block 4
call    0 never executed
call    1 never executed
        -: 1119:}
        -: 1120:
        -: 1121:#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
        -: 1122:// Legacy API obsoleted in 1.89. Two differences with new ImageButton()
        -: 1123:// - old ImageButton() used ImTextureId as item id (created issue with multiple buttons with same image, transient texture id values, opaque computation of ID)
        -: 1124:// - new ImageButton() requires an explicit 'const char* str_id'
        -: 1125:// - old ImageButton() had frame_padding' override argument.
        -: 1126:// - new ImageButton() always use style.FramePadding.
        -: 1127:/*
        -: 1128:bool ImGui::ImageButton(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, int frame_padding, const ImVec4& bg_col, const ImVec4& tint_col)
        -: 1129:{
        -: 1130:    // Default to using texture ID as ID. User can still push string/integer prefixes.
        -: 1131:    PushID((ImTextureID)(intptr_t)user_texture_id);
        -: 1132:    if (frame_padding >= 0)
        -: 1133:        PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2((float)frame_padding, (float)frame_padding));
        -: 1134:    bool ret = ImageButton("", user_texture_id, size, uv0, uv1, bg_col, tint_col);
        -: 1135:    if (frame_padding >= 0)
        -: 1136:        PopStyleVar();
        -: 1137:    PopID();
        -: 1138:    return ret;
        -: 1139:}
        -: 1140:*/
        -: 1141:#endif // #ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
        -: 1142:
function _ZN5ImGui8CheckboxEPKcPb called 0 returned 0% blocks executed 0%
    #####: 1143:bool ImGui::Checkbox(const char* label, bool* v)
        -: 1144:{
    #####: 1145:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%: 1145-block 2
call    0 never executed
    #####: 1146:    if (window->SkipItems)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1147:        return false;
    %%%%%: 1147-block 4
        -: 1148:
    #####: 1149:    ImGuiContext& g = *GImGui;
    #####: 1150:    const ImGuiStyle& style = g.Style;
    #####: 1151:    const ImGuiID id = window->GetID(label);
    %%%%%: 1151-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1152:    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    %%%%%: 1152-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 1153:
    #####: 1154:    const float square_sz = GetFrameHeight();
    %%%%%: 1154-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1155:    const ImVec2 pos = window->DC.CursorPos;
    #####: 1156:    const ImRect total_bb(pos, pos + ImVec2(square_sz + (label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f), label_size.y + style.FramePadding.y * 2.0f));
    %%%%%: 1156-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1156-block 9
    %%%%%: 1156-block 10
    %%%%%: 1156-block 11
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 1157:    ItemSize(total_bb, style.FramePadding.y);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1158:    const bool is_visible = ItemAdd(total_bb, id);
    %%%%%: 1158-block 15
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1159:    const bool is_multi_select = (g.LastItemData.ItemFlags & ImGuiItemFlags_IsMultiSelect) != 0;
    #####: 1160:    if (!is_visible)
    %%%%%: 1160-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1161:        if (!is_multi_select || !g.BoxSelectState.UnclipMode || !g.BoxSelectState.UnclipRect.Overlaps(total_bb)) // Extra layer of "no logic clip" for box-select support
    %%%%%: 1161-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1161-block 18
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1161-block 19
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 1161-block 21
    %%%%%: 1161-block 22
    %%%%%: 1161-block 23
branch  7 never executed (fallthrough)
branch  8 never executed
        -: 1162:        {
        -: 1163:            IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags | ImGuiItemStatusFlags_Checkable | (*v ? ImGuiItemStatusFlags_Checked : 0));
    #####: 1164:            return false;
    %%%%%: 1164-block 24
        -: 1165:        }
        -: 1166:
        -: 1167:    // Range-Selection/Multi-selection support (header)
    #####: 1168:    bool checked = *v;
    #####: 1169:    if (is_multi_select)
    %%%%%: 1169-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1170:        MultiSelectItemHeader(id, &checked, NULL);
    %%%%%: 1170-block 26
call    0 never executed
        -: 1171:
        -: 1172:    bool hovered, held;
    #####: 1173:    bool pressed = ButtonBehavior(total_bb, id, &hovered, &held);
    %%%%%: 1173-block 27
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 1174:
        -: 1175:    // Range-Selection/Multi-selection support (footer)
    #####: 1176:    if (is_multi_select)
    %%%%%: 1176-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1177:        MultiSelectItemFooter(id, &checked, &pressed);
    %%%%%: 1177-block 29
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1178:    else if (pressed)
    %%%%%: 1178-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1179:        checked = !checked;
    %%%%%: 1179-block 31
        -: 1180:
    #####: 1181:    if (*v != checked)
    %%%%%: 1181-block 32
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1182:    {
    #####: 1183:        *v = checked;
    #####: 1184:        pressed = true; // return value
    #####: 1185:        MarkItemEdited(id);
    %%%%%: 1185-block 33
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 1186:    }
        -: 1187:
    #####: 1188:    const ImRect check_bb(pos, pos + ImVec2(square_sz, square_sz));
    %%%%%: 1188-block 34
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1189:    const bool mixed_value = (g.LastItemData.ItemFlags & ImGuiItemFlags_MixedValue) != 0;
    #####: 1190:    if (is_visible)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1191:    {
    #####: 1192:        RenderNavCursor(total_bb, id);
    %%%%%: 1192-block 38
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1193:        RenderFrame(check_bb.Min, check_bb.Max, GetColorU32((held && hovered) ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg), true, style.FrameRounding);
    %%%%%: 1193-block 39
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1193-block 40
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1193-block 41
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 1193-block 42
    %%%%%: 1193-block 43
    %%%%%: 1193-block 44
    %%%%%: 1193-block 45
    %%%%%: 1193-block 46
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed (throw)
    %%%%%: 1193-block 47
call    9 never executed
branch 10 never executed (fallthrough)
branch 11 never executed (throw)
    #####: 1194:        ImU32 check_col = GetColorU32(ImGuiCol_CheckMark);
    %%%%%: 1194-block 48
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1195:        if (mixed_value)
    %%%%%: 1195-block 49
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1196:        {
        -: 1197:            // Undocumented tristate/mixed/indeterminate checkbox (#2644)
        -: 1198:            // This may seem awkwardly designed because the aim is to make ImGuiItemFlags_MixedValue supported by all widgets (not just checkbox)
    #####: 1199:            ImVec2 pad(ImMax(1.0f, IM_TRUNC(square_sz / 3.6f)), ImMax(1.0f, IM_TRUNC(square_sz / 3.6f)));
    %%%%%: 1199-block 50
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1200:            window->DrawList->AddRectFilled(check_bb.Min + pad, check_bb.Max - pad, check_col, style.FrameRounding);
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 1200-block 56
    $$$$$: 1200-block 78
    $$$$$: 1200-block 79
        -: 1201:        }
    #####: 1202:        else if (*v)
    %%%%%: 1202-block 57
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1203:        {
    #####: 1204:            const float pad = ImMax(1.0f, IM_TRUNC(square_sz / 6.0f));
    %%%%%: 1204-block 58
call    0 never executed
    #####: 1205:            RenderCheckMark(window->DrawList, check_bb.Min + ImVec2(pad, pad), check_col, square_sz - pad * 2.0f);
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 1205-block 62
    $$$$$: 1205-block 81
        -: 1206:        }
        -: 1207:    }
    #####: 1208:    const ImVec2 label_pos = ImVec2(check_bb.Max.x + style.ItemInnerSpacing.x, check_bb.Min.y + style.FramePadding.y);
    %%%%%: 1208-block 63
call    0 never executed
    #####: 1209:    if (g.LogEnabled)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1210:        LogRenderedText(&label_pos, mixed_value ? "[~]" : *v ? "[x]" : "[ ]");
    %%%%%: 1210-block 65
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1210-block 66
    %%%%%: 1210-block 67
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1210-block 68
    %%%%%: 1210-block 69
    %%%%%: 1210-block 70
    %%%%%: 1210-block 71
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    #####: 1211:    if (is_visible && label_size.x > 0.0f)
    %%%%%: 1211-block 72
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1211-block 73
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 1212:        RenderText(label_pos, label);
    %%%%%: 1212-block 74
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 1213:
        -: 1214:    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags | ImGuiItemStatusFlags_Checkable | (*v ? ImGuiItemStatusFlags_Checked : 0));
    #####: 1215:    return pressed;
    %%%%%: 1215-block 75
        -: 1216:}
        -: 1217:
        -: 1218:template<typename T>
    #####: 1219:bool ImGui::CheckboxFlagsT(const char* label, T* flags, T flags_value)
        -: 1220:{
    #####: 1221:    bool all_on = (*flags & flags_value) == flags_value;
    #####: 1222:    bool any_on = (*flags & flags_value) != 0;
        -: 1223:    bool pressed;
    #####: 1224:    if (!all_on && any_on)
        -: 1225:    {
    #####: 1226:        ImGuiContext& g = *GImGui;
    #####: 1227:        g.NextItemData.ItemFlags |= ImGuiItemFlags_MixedValue;
    #####: 1228:        pressed = Checkbox(label, &all_on);
    #####: 1229:    }
        -: 1230:    else
        -: 1231:    {
    #####: 1232:        pressed = Checkbox(label, &all_on);
        -: 1233:
        -: 1234:    }
    #####: 1235:    if (pressed)
        -: 1236:    {
    #####: 1237:        if (all_on)
    #####: 1238:            *flags |= flags_value;
        -: 1239:        else
    #####: 1240:            *flags &= ~flags_value;
        -: 1241:    }
    #####: 1242:    return pressed;
        -: 1243:}
------------------
_ZN5ImGui14CheckboxFlagsTIyEEbPKcPT_S3_:
function _ZN5ImGui14CheckboxFlagsTIyEEbPKcPT_S3_ called 0 returned 0% blocks executed 0%
    #####: 1219:bool ImGui::CheckboxFlagsT(const char* label, T* flags, T flags_value)
        -: 1220:{
    #####: 1221:    bool all_on = (*flags & flags_value) == flags_value;
    #####: 1222:    bool any_on = (*flags & flags_value) != 0;
        -: 1223:    bool pressed;
    #####: 1224:    if (!all_on && any_on)
    %%%%%: 1224-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1224-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 1225:    {
    #####: 1226:        ImGuiContext& g = *GImGui;
    #####: 1227:        g.NextItemData.ItemFlags |= ImGuiItemFlags_MixedValue;
    #####: 1228:        pressed = Checkbox(label, &all_on);
    %%%%%: 1228-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1229:    }
    %%%%%: 1229-block 5
        -: 1230:    else
        -: 1231:    {
    #####: 1232:        pressed = Checkbox(label, &all_on);
    %%%%%: 1232-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1232-block 7
        -: 1233:
        -: 1234:    }
    #####: 1235:    if (pressed)
    %%%%%: 1235-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1236:    {
    #####: 1237:        if (all_on)
    %%%%%: 1237-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1238:            *flags |= flags_value;
    %%%%%: 1238-block 10
        -: 1239:        else
    #####: 1240:            *flags &= ~flags_value;
    %%%%%: 1240-block 11
        -: 1241:    }
    #####: 1242:    return pressed;
    %%%%%: 1242-block 12
    %%%%%: 1242-block 13
        -: 1243:}
------------------
_ZN5ImGui14CheckboxFlagsTIxEEbPKcPT_S3_:
function _ZN5ImGui14CheckboxFlagsTIxEEbPKcPT_S3_ called 0 returned 0% blocks executed 0%
    #####: 1219:bool ImGui::CheckboxFlagsT(const char* label, T* flags, T flags_value)
        -: 1220:{
    #####: 1221:    bool all_on = (*flags & flags_value) == flags_value;
    #####: 1222:    bool any_on = (*flags & flags_value) != 0;
        -: 1223:    bool pressed;
    #####: 1224:    if (!all_on && any_on)
    %%%%%: 1224-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1224-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 1225:    {
    #####: 1226:        ImGuiContext& g = *GImGui;
    #####: 1227:        g.NextItemData.ItemFlags |= ImGuiItemFlags_MixedValue;
    #####: 1228:        pressed = Checkbox(label, &all_on);
    %%%%%: 1228-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1229:    }
    %%%%%: 1229-block 5
        -: 1230:    else
        -: 1231:    {
    #####: 1232:        pressed = Checkbox(label, &all_on);
    %%%%%: 1232-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1232-block 7
        -: 1233:
        -: 1234:    }
    #####: 1235:    if (pressed)
    %%%%%: 1235-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1236:    {
    #####: 1237:        if (all_on)
    %%%%%: 1237-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1238:            *flags |= flags_value;
    %%%%%: 1238-block 10
        -: 1239:        else
    #####: 1240:            *flags &= ~flags_value;
    %%%%%: 1240-block 11
        -: 1241:    }
    #####: 1242:    return pressed;
    %%%%%: 1242-block 12
    %%%%%: 1242-block 13
        -: 1243:}
------------------
_ZN5ImGui14CheckboxFlagsTIjEEbPKcPT_S3_:
function _ZN5ImGui14CheckboxFlagsTIjEEbPKcPT_S3_ called 0 returned 0% blocks executed 0%
    #####: 1219:bool ImGui::CheckboxFlagsT(const char* label, T* flags, T flags_value)
        -: 1220:{
    #####: 1221:    bool all_on = (*flags & flags_value) == flags_value;
    #####: 1222:    bool any_on = (*flags & flags_value) != 0;
        -: 1223:    bool pressed;
    #####: 1224:    if (!all_on && any_on)
    %%%%%: 1224-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1224-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 1225:    {
    #####: 1226:        ImGuiContext& g = *GImGui;
    #####: 1227:        g.NextItemData.ItemFlags |= ImGuiItemFlags_MixedValue;
    #####: 1228:        pressed = Checkbox(label, &all_on);
    %%%%%: 1228-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1229:    }
    %%%%%: 1229-block 5
        -: 1230:    else
        -: 1231:    {
    #####: 1232:        pressed = Checkbox(label, &all_on);
    %%%%%: 1232-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1232-block 7
        -: 1233:
        -: 1234:    }
    #####: 1235:    if (pressed)
    %%%%%: 1235-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1236:    {
    #####: 1237:        if (all_on)
    %%%%%: 1237-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1238:            *flags |= flags_value;
    %%%%%: 1238-block 10
        -: 1239:        else
    #####: 1240:            *flags &= ~flags_value;
    %%%%%: 1240-block 11
        -: 1241:    }
    #####: 1242:    return pressed;
    %%%%%: 1242-block 12
    %%%%%: 1242-block 13
        -: 1243:}
------------------
_ZN5ImGui14CheckboxFlagsTIiEEbPKcPT_S3_:
function _ZN5ImGui14CheckboxFlagsTIiEEbPKcPT_S3_ called 0 returned 0% blocks executed 0%
    #####: 1219:bool ImGui::CheckboxFlagsT(const char* label, T* flags, T flags_value)
        -: 1220:{
    #####: 1221:    bool all_on = (*flags & flags_value) == flags_value;
    #####: 1222:    bool any_on = (*flags & flags_value) != 0;
        -: 1223:    bool pressed;
    #####: 1224:    if (!all_on && any_on)
    %%%%%: 1224-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1224-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 1225:    {
    #####: 1226:        ImGuiContext& g = *GImGui;
    #####: 1227:        g.NextItemData.ItemFlags |= ImGuiItemFlags_MixedValue;
    #####: 1228:        pressed = Checkbox(label, &all_on);
    %%%%%: 1228-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1229:    }
    %%%%%: 1229-block 5
        -: 1230:    else
        -: 1231:    {
    #####: 1232:        pressed = Checkbox(label, &all_on);
    %%%%%: 1232-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1232-block 7
        -: 1233:
        -: 1234:    }
    #####: 1235:    if (pressed)
    %%%%%: 1235-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1236:    {
    #####: 1237:        if (all_on)
    %%%%%: 1237-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1238:            *flags |= flags_value;
    %%%%%: 1238-block 10
        -: 1239:        else
    #####: 1240:            *flags &= ~flags_value;
    %%%%%: 1240-block 11
        -: 1241:    }
    #####: 1242:    return pressed;
    %%%%%: 1242-block 12
    %%%%%: 1242-block 13
        -: 1243:}
------------------
        -: 1244:
function _ZN5ImGui13CheckboxFlagsEPKcPii called 0 returned 0% blocks executed 0%
    #####: 1245:bool ImGui::CheckboxFlags(const char* label, int* flags, int flags_value)
        -: 1246:{
    #####: 1247:    return CheckboxFlagsT(label, flags, flags_value);
    %%%%%: 1247-block 2
call    0 never executed
        -: 1248:}
        -: 1249:
function _ZN5ImGui13CheckboxFlagsEPKcPjj called 0 returned 0% blocks executed 0%
    #####: 1250:bool ImGui::CheckboxFlags(const char* label, unsigned int* flags, unsigned int flags_value)
        -: 1251:{
    #####: 1252:    return CheckboxFlagsT(label, flags, flags_value);
    %%%%%: 1252-block 2
call    0 never executed
        -: 1253:}
        -: 1254:
function _ZN5ImGui13CheckboxFlagsEPKcPxx called 0 returned 0% blocks executed 0%
    #####: 1255:bool ImGui::CheckboxFlags(const char* label, ImS64* flags, ImS64 flags_value)
        -: 1256:{
    #####: 1257:    return CheckboxFlagsT(label, flags, flags_value);
    %%%%%: 1257-block 2
call    0 never executed
        -: 1258:}
        -: 1259:
function _ZN5ImGui13CheckboxFlagsEPKcPyy called 0 returned 0% blocks executed 0%
    #####: 1260:bool ImGui::CheckboxFlags(const char* label, ImU64* flags, ImU64 flags_value)
        -: 1261:{
    #####: 1262:    return CheckboxFlagsT(label, flags, flags_value);
    %%%%%: 1262-block 2
call    0 never executed
        -: 1263:}
        -: 1264:
function _ZN5ImGui11RadioButtonEPKcb called 0 returned 0% blocks executed 0%
    #####: 1265:bool ImGui::RadioButton(const char* label, bool active)
        -: 1266:{
    #####: 1267:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%: 1267-block 2
call    0 never executed
    #####: 1268:    if (window->SkipItems)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1269:        return false;
    %%%%%: 1269-block 4
        -: 1270:
    #####: 1271:    ImGuiContext& g = *GImGui;
    #####: 1272:    const ImGuiStyle& style = g.Style;
    #####: 1273:    const ImGuiID id = window->GetID(label);
    %%%%%: 1273-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1274:    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    %%%%%: 1274-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 1275:
    #####: 1276:    const float square_sz = GetFrameHeight();
    %%%%%: 1276-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1277:    const ImVec2 pos = window->DC.CursorPos;
    #####: 1278:    const ImRect check_bb(pos, pos + ImVec2(square_sz, square_sz));
    %%%%%: 1278-block 8
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1279:    const ImRect total_bb(pos, pos + ImVec2(square_sz + (label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f), label_size.y + style.FramePadding.y * 2.0f));
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1279-block 12
    %%%%%: 1279-block 13
    %%%%%: 1279-block 14
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 1280:    ItemSize(total_bb, style.FramePadding.y);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1281:    if (!ItemAdd(total_bb, id))
    %%%%%: 1281-block 18
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1281-block 19
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 1282:        return false;
    %%%%%: 1282-block 20
        -: 1283:
    #####: 1284:    ImVec2 center = check_bb.GetCenter();
    %%%%%: 1284-block 21
call    0 never executed
    #####: 1285:    center.x = IM_ROUND(center.x);
    #####: 1286:    center.y = IM_ROUND(center.y);
    #####: 1287:    const float radius = (square_sz - 1.0f) * 0.5f;
        -: 1288:
        -: 1289:    bool hovered, held;
    #####: 1290:    bool pressed = ButtonBehavior(total_bb, id, &hovered, &held);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1291:    if (pressed)
    %%%%%: 1291-block 23
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1292:        MarkItemEdited(id);
    %%%%%: 1292-block 24
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 1293:
    #####: 1294:    RenderNavCursor(total_bb, id);
    %%%%%: 1294-block 25
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1295:    const int num_segment = window->DrawList->_CalcCircleAutoSegmentCount(radius);
    %%%%%: 1295-block 26
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1296:    window->DrawList->AddCircleFilled(center, radius, GetColorU32((held && hovered) ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg), num_segment);
    %%%%%: 1296-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1296-block 28
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1296-block 29
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 1296-block 30
    %%%%%: 1296-block 31
    %%%%%: 1296-block 32
    %%%%%: 1296-block 33
    %%%%%: 1296-block 34
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed (throw)
    %%%%%: 1296-block 35
call    9 never executed
branch 10 never executed (fallthrough)
branch 11 never executed (throw)
    #####: 1297:    if (active)
    %%%%%: 1297-block 36
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1298:    {
    #####: 1299:        const float pad = ImMax(1.0f, IM_TRUNC(square_sz / 6.0f));
    %%%%%: 1299-block 37
call    0 never executed
    #####: 1300:        window->DrawList->AddCircleFilled(center, radius - pad, GetColorU32(ImGuiCol_CheckMark));
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1300-block 39
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
        -: 1301:    }
        -: 1302:
    #####: 1303:    if (style.FrameBorderSize > 0.0f)
    %%%%%: 1303-block 40
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1304:    {
    #####: 1305:        window->DrawList->AddCircle(center + ImVec2(1, 1), radius, GetColorU32(ImGuiCol_BorderShadow), num_segment, style.FrameBorderSize);
    %%%%%: 1305-block 41
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1305-block 42
call    3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
    $$$$$: 1305-block 58
    $$$$$: 1305-block 59
    #####: 1306:        window->DrawList->AddCircle(center, radius, GetColorU32(ImGuiCol_Border), num_segment, style.FrameBorderSize);
    %%%%%: 1306-block 45
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1306-block 46
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
        -: 1307:    }
        -: 1308:
    #####: 1309:    ImVec2 label_pos = ImVec2(check_bb.Max.x + style.ItemInnerSpacing.x, check_bb.Min.y + style.FramePadding.y);
    %%%%%: 1309-block 47
call    0 never executed
    #####: 1310:    if (g.LogEnabled)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1311:        LogRenderedText(&label_pos, active ? "(x)" : "( )");
    %%%%%: 1311-block 49
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1311-block 50
    %%%%%: 1311-block 51
    %%%%%: 1311-block 52
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####: 1312:    if (label_size.x > 0.0f)
    %%%%%: 1312-block 53
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1313:        RenderText(label_pos, label);
    %%%%%: 1313-block 54
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 1314:
        -: 1315:    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags);
    #####: 1316:    return pressed;
    %%%%%: 1316-block 55
        -: 1317:}
        -: 1318:
        -: 1319:// FIXME: This would work nicely if it was a public template, e.g. 'template<T> RadioButton(const char* label, T* v, T v_button)', but I'm not sure how we would expose it..
function _ZN5ImGui11RadioButtonEPKcPii called 0 returned 0% blocks executed 0%
    #####: 1320:bool ImGui::RadioButton(const char* label, int* v, int v_button)
        -: 1321:{
    #####: 1322:    const bool pressed = RadioButton(label, *v == v_button);
    %%%%%: 1322-block 2
call    0 never executed
    #####: 1323:    if (pressed)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1324:        *v = v_button;
    %%%%%: 1324-block 4
    #####: 1325:    return pressed;
    %%%%%: 1325-block 5
        -: 1326:}
        -: 1327:
        -: 1328:// size_arg (for each axis) < 0.0f: align to end, 0.0f: auto, > 0.0f: specified size
function _ZN5ImGui11ProgressBarEfRK6ImVec2PKc called 0 returned 0% blocks executed 0%
    #####: 1329:void ImGui::ProgressBar(float fraction, const ImVec2& size_arg, const char* overlay)
        -: 1330:{
    #####: 1331:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%: 1331-block 2
call    0 never executed
    #####: 1332:    if (window->SkipItems)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1333:        return;
    %%%%%: 1333-block 4
    %%%%%: 1333-block 45
        -: 1334:
    #####: 1335:    ImGuiContext& g = *GImGui;
    #####: 1336:    const ImGuiStyle& style = g.Style;
        -: 1337:
    #####: 1338:    ImVec2 pos = window->DC.CursorPos;
    #####: 1339:    ImVec2 size = CalcItemSize(size_arg, CalcItemWidth(), g.FontSize + style.FramePadding.y * 2.0f);
    %%%%%: 1339-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1339-block 6
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    #####: 1340:    ImRect bb(pos, pos + size);
    %%%%%: 1340-block 7
call    0 never executed
call    1 never executed
    #####: 1341:    ItemSize(size, style.FramePadding.y);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1342:    if (!ItemAdd(bb, 0))
    %%%%%: 1342-block 10
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1342-block 11
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 1343:        return;
    %%%%%: 1343-block 12
        -: 1344:
        -: 1345:    // Fraction < 0.0f will display an indeterminate progress bar animation
        -: 1346:    // The value must be animated along with time, so e.g. passing '-1.0f * ImGui::GetTime()' as fraction works.
    #####: 1347:    const bool is_indeterminate = (fraction < 0.0f);
    #####: 1348:    if (!is_indeterminate)
    %%%%%: 1348-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1349:        fraction = ImSaturate(fraction);
    %%%%%: 1349-block 14
call    0 never executed
        -: 1350:
        -: 1351:    // Out of courtesy we accept a NaN fraction without crashing
    #####: 1352:    float fill_n0 = 0.0f;
    #####: 1353:    float fill_n1 = (fraction == fraction) ? fraction : 0.0f;
    %%%%%: 1353-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1353-block 16
    %%%%%: 1353-block 17
        -: 1354:
    #####: 1355:    if (is_indeterminate)
    %%%%%: 1355-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1356:    {
    #####: 1357:        const float fill_width_n = 0.2f;
    #####: 1358:        fill_n0 = ImFmod(-fraction, 1.0f) * (1.0f + fill_width_n) - fill_width_n;
    #####: 1359:        fill_n1 = ImSaturate(fill_n0 + fill_width_n);
    %%%%%: 1359-block 19
call    0 never executed
    #####: 1360:        fill_n0 = ImSaturate(fill_n0);
call    0 never executed
        -: 1361:    }
        -: 1362:
        -: 1363:    // Render
    #####: 1364:    RenderFrame(bb.Min, bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);
    %%%%%: 1364-block 21
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1364-block 22
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    #####: 1365:    bb.Expand(ImVec2(-style.FrameBorderSize, -style.FrameBorderSize));
    %%%%%: 1365-block 23
call    0 never executed
call    1 never executed
    #####: 1366:    RenderRectFilledRangeH(window->DrawList, bb, GetColorU32(ImGuiCol_PlotHistogram), fill_n0, fill_n1, style.FrameRounding);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1366-block 26
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
        -: 1367:
        -: 1368:    // Default displaying the fraction as percentage string, but user can override it
        -: 1369:    // Don't display text for indeterminate bars by default
        -: 1370:    char overlay_buf[32];
    #####: 1371:    if (!is_indeterminate || overlay != NULL)
    %%%%%: 1371-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1371-block 28
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 1372:    {
    #####: 1373:        if (!overlay)
    %%%%%: 1373-block 29
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1374:        {
    #####: 1375:            ImFormatString(overlay_buf, IM_ARRAYSIZE(overlay_buf), "%.0f%%", fraction * 100 + 0.01f);
    %%%%%: 1375-block 30
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1376:            overlay = overlay_buf;
    %%%%%: 1376-block 31
        -: 1377:        }
        -: 1378:
    #####: 1379:        ImVec2 overlay_size = CalcTextSize(overlay, NULL);
    %%%%%: 1379-block 32
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1380:        if (overlay_size.x > 0.0f)
    %%%%%: 1380-block 33
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1381:        {
    #####: 1382:            float text_x = is_indeterminate ? (bb.Min.x + bb.Max.x - overlay_size.x) * 0.5f : ImLerp(bb.Min.x, bb.Max.x, fill_n1) + style.ItemSpacing.x;
    %%%%%: 1382-block 34
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1382-block 35
    %%%%%: 1382-block 36
call    2 never executed
    #####: 1383:            RenderTextClipped(ImVec2(ImClamp(text_x, bb.Min.x, bb.Max.x - overlay_size.x - style.ItemInnerSpacing.x), bb.Min.y), bb.Max, overlay, NULL, &overlay_size, ImVec2(0.0f, 0.5f), &bb);
    %%%%%: 1383-block 38
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    %%%%%: 1383-block 42
    $$$$$: 1383-block 47
    $$$$$: 1383-block 48
        -: 1384:        }
        -: 1385:    }
        -: 1386:}
        -: 1387:
function _ZN5ImGui6BulletEv called 0 returned 0% blocks executed 0%
    #####: 1388:void ImGui::Bullet()
        -: 1389:{
    #####: 1390:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%: 1390-block 2
call    0 never executed
    #####: 1391:    if (window->SkipItems)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1392:        return;
    %%%%%: 1392-block 4
    %%%%%: 1392-block 21
        -: 1393:
    #####: 1394:    ImGuiContext& g = *GImGui;
    #####: 1395:    const ImGuiStyle& style = g.Style;
    #####: 1396:    const float line_height = ImMax(ImMin(window->DC.CurrLineSize.y, g.FontSize + style.FramePadding.y * 2), g.FontSize);
    %%%%%: 1396-block 5
call    0 never executed
call    1 never executed
    #####: 1397:    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(g.FontSize, line_height));
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1398:    ItemSize(bb);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1399:    if (!ItemAdd(bb, 0))
    %%%%%: 1399-block 11
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1399-block 12
branch  3 never executed (fallthrough)
branch  4 never executed
        -: 1400:    {
    #####: 1401:        SameLine(0, style.FramePadding.x * 2);
    %%%%%: 1401-block 13
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1402:        return;
    %%%%%: 1402-block 14
        -: 1403:    }
        -: 1404:
        -: 1405:    // Render and stay on same line
    #####: 1406:    ImU32 text_col = GetColorU32(ImGuiCol_Text);
    %%%%%: 1406-block 15
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1407:    RenderBullet(window->DrawList, bb.Min + ImVec2(style.FramePadding.x + g.FontSize * 0.5f, line_height * 0.5f), text_col);
    %%%%%: 1407-block 16
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    $$$$$: 1407-block 23
    #####: 1408:    SameLine(0, style.FramePadding.x * 2.0f);
    %%%%%: 1408-block 19
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 1409:}
        -: 1410:
        -: 1411:// This is provided as a convenience for being an often requested feature.
        -: 1412:// FIXME-STYLE: we delayed adding as there is a larger plan to revamp the styling system.
        -: 1413:// Because of this we currently don't provide many styling options for this widget
        -: 1414:// (e.g. hovered/active colors are automatically inferred from a single color).
function _ZN5ImGui8TextLinkEPKc called 0 returned 0% blocks executed 0%
    #####: 1415:bool ImGui::TextLink(const char* label)
        -: 1416:{
    #####: 1417:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%: 1417-block 2
call    0 never executed
    #####: 1418:    if (window->SkipItems)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1419:        return false;
    %%%%%: 1419-block 4
        -: 1420:
    #####: 1421:    ImGuiContext& g = *GImGui;
    #####: 1422:    const ImGuiID id = window->GetID(label);
    %%%%%: 1422-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1423:    const char* label_end = FindRenderedTextEnd(label);
    %%%%%: 1423-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 1424:
    #####: 1425:    ImVec2 pos = window->DC.CursorPos;
    #####: 1426:    ImVec2 size = CalcTextSize(label, label_end, true);
    %%%%%: 1426-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1427:    ImRect bb(pos, pos + size);
    %%%%%: 1427-block 8
call    0 never executed
call    1 never executed
    #####: 1428:    ItemSize(size, 0.0f);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1429:    if (!ItemAdd(bb, id))
    %%%%%: 1429-block 11
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1429-block 12
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 1430:        return false;
    %%%%%: 1430-block 13
        -: 1431:
        -: 1432:    bool hovered, held;
    #####: 1433:    bool pressed = ButtonBehavior(bb, id, &hovered, &held);
    %%%%%: 1433-block 14
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1434:    RenderNavCursor(bb, id);
    %%%%%: 1434-block 15
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 1435:
    #####: 1436:    if (hovered)
    %%%%%: 1436-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1437:        SetMouseCursor(ImGuiMouseCursor_Hand);
    %%%%%: 1437-block 17
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 1438:
    #####: 1439:    ImVec4 text_colf = g.Style.Colors[ImGuiCol_TextLink];
    #####: 1440:    ImVec4 line_colf = text_colf;
        -: 1441:    {
        -: 1442:        // FIXME-STYLE: Read comments above. This widget is NOT written in the same style as some earlier widgets,
        -: 1443:        // as we are currently experimenting/planning a different styling system.
        -: 1444:        float h, s, v;
    #####: 1445:        ColorConvertRGBtoHSV(text_colf.x, text_colf.y, text_colf.z, h, s, v);
    %%%%%: 1445-block 18
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1446:        if (held || hovered)
    %%%%%: 1446-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1446-block 20
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 1447:        {
    #####: 1448:            v = ImSaturate(v + (held ? 0.4f : 0.3f));
    %%%%%: 1448-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1448-block 22
    %%%%%: 1448-block 23
    %%%%%: 1448-block 24
call    2 never executed
    #####: 1449:            h = ImFmod(h + 0.02f, 1.0f);
        -: 1450:        }
    #####: 1451:        ColorConvertHSVtoRGB(h, s, v, text_colf.x, text_colf.y, text_colf.z);
    %%%%%: 1451-block 26
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1452:        v = ImSaturate(v - 0.20f);
    %%%%%: 1452-block 27
call    0 never executed
    #####: 1453:        ColorConvertHSVtoRGB(h, s, v, line_colf.x, line_colf.y, line_colf.z);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 1454:    }
        -: 1455:
    #####: 1456:    float line_y = bb.Max.y + ImFloor(g.Font->Descent * g.FontScale * 0.20f);
    %%%%%: 1456-block 29
call    0 never executed
    #####: 1457:    window->DrawList->AddLine(ImVec2(bb.Min.x, line_y), ImVec2(bb.Max.x, line_y), GetColorU32(line_colf)); // FIXME-TEXT: Underline mode.
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1457-block 31
call    3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
    $$$$$: 1457-block 42
    $$$$$: 1457-block 43
        -: 1458:
    #####: 1459:    PushStyleColor(ImGuiCol_Text, GetColorU32(text_colf));
    %%%%%: 1459-block 34
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1459-block 35
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    #####: 1460:    RenderText(bb.Min, label, label_end);
    %%%%%: 1460-block 36
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1461:    PopStyleColor();
    %%%%%: 1461-block 37
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 1462:
        -: 1463:    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags);
    #####: 1464:    return pressed;
    %%%%%: 1464-block 38
        -: 1465:}
        -: 1466:
function _ZN5ImGui15TextLinkOpenURLEPKcS1_ called 0 returned 0% blocks executed 0%
    #####: 1467:void ImGui::TextLinkOpenURL(const char* label, const char* url)
        -: 1468:{
    #####: 1469:    ImGuiContext& g = *GImGui;
    #####: 1470:    if (url == NULL)
    %%%%%: 1470-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1471:        url = label;
    %%%%%: 1471-block 3
    #####: 1472:    if (TextLink(label))
    %%%%%: 1472-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 1473:        if (g.PlatformIO.Platform_OpenInShellFn != NULL)
    %%%%%: 1473-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1474:            g.PlatformIO.Platform_OpenInShellFn(&g, url);
    %%%%%: 1474-block 7
call    0 never executed
    #####: 1475:    SetItemTooltip(LocalizeGetMsg(ImGuiLocKey_OpenLink_s), url); // It is more reassuring for user to _always_ display URL when we same as label
    %%%%%: 1475-block 8
call    0 never executed
call    1 never executed
    #####: 1476:    if (BeginPopupContextItem())
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -: 1477:    {
    #####: 1478:        if (MenuItem(LocalizeGetMsg(ImGuiLocKey_CopyLink)))
    %%%%%: 1478-block 12
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 1479:            SetClipboardText(url);
    %%%%%: 1479-block 15
call    0 never executed
    #####: 1480:        EndPopup();
    %%%%%: 1480-block 16
call    0 never executed
        -: 1481:    }
    #####: 1482:}
        -: 1483:
        -: 1484://-------------------------------------------------------------------------
        -: 1485:// [SECTION] Widgets: Low-level Layout helpers
        -: 1486://-------------------------------------------------------------------------
        -: 1487:// - Spacing()
        -: 1488:// - Dummy()
        -: 1489:// - NewLine()
        -: 1490:// - AlignTextToFramePadding()
        -: 1491:// - SeparatorEx() [Internal]
        -: 1492:// - Separator()
        -: 1493:// - SplitterBehavior() [Internal]
        -: 1494:// - ShrinkWidths() [Internal]
        -: 1495://-------------------------------------------------------------------------
        -: 1496:
function _ZN5ImGui7SpacingEv called 0 returned 0% blocks executed 0%
    #####: 1497:void ImGui::Spacing()
        -: 1498:{
    #####: 1499:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%: 1499-block 2
call    0 never executed
    #####: 1500:    if (window->SkipItems)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1501:        return;
    %%%%%: 1501-block 4
    #####: 1502:    ItemSize(ImVec2(0, 0));
    %%%%%: 1502-block 5
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 1502-block 7
        -: 1503:}
        -: 1504:
function _ZN5ImGui5DummyERK6ImVec2 called 3231 returned 100% blocks executed 90%
     3231: 1505:void ImGui::Dummy(const ImVec2& size)
        -: 1506:{
     3231: 1507:    ImGuiWindow* window = GetCurrentWindow();
     3231: 1507-block 2
call    0 returned 3231
     3231: 1508:    if (window->SkipItems)
branch  0 taken 0 (fallthrough)
branch  1 taken 3231
    #####: 1509:        return;
    %%%%%: 1509-block 4
        -: 1510:
     3231: 1511:    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);
     3231: 1511-block 5
call    0 returned 3231
call    1 returned 3231
     3231: 1512:    ItemSize(size);
call    0 returned 3231
branch  1 taken 3231 (fallthrough)
branch  2 taken 0 (throw)
     3231: 1513:    ItemAdd(bb, 0);
     3231: 1513-block 8
call    0 returned 3231
branch  1 taken 3231 (fallthrough)
branch  2 taken 0 (throw)
        -: 1514:}
        -: 1515:
function _ZN5ImGui7NewLineEv called 0 returned 0% blocks executed 0%
    #####: 1516:void ImGui::NewLine()
        -: 1517:{
    #####: 1518:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%: 1518-block 2
call    0 never executed
    #####: 1519:    if (window->SkipItems)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1520:        return;
    %%%%%: 1520-block 4
        -: 1521:
    #####: 1522:    ImGuiContext& g = *GImGui;
    #####: 1523:    const ImGuiLayoutType backup_layout_type = window->DC.LayoutType;
    #####: 1524:    window->DC.LayoutType = ImGuiLayoutType_Vertical;
    #####: 1525:    window->DC.IsSameLine = false;
    #####: 1526:    if (window->DC.CurrLineSize.y > 0.0f)     // In the event that we are on a line with items that is smaller that FontSize high, we will preserve its height.
    %%%%%: 1526-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1527:        ItemSize(ImVec2(0, 0));
    %%%%%: 1527-block 6
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 1527-block 8
    $$$$$: 1527-block 14
call    4 never executed
        -: 1528:    else
    #####: 1529:        ItemSize(ImVec2(0.0f, g.FontSize));
    %%%%%: 1529-block 9
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 1529-block 11
    #####: 1530:    window->DC.LayoutType = backup_layout_type;
    %%%%%: 1530-block 12
        -: 1531:}
        -: 1532:
function _ZN5ImGui23AlignTextToFramePaddingEv called 1077 returned 100% blocks executed 86%
     1077: 1533:void ImGui::AlignTextToFramePadding()
        -: 1534:{
     1077: 1535:    ImGuiWindow* window = GetCurrentWindow();
     1077: 1535-block 2
call    0 returned 1077
     1077: 1536:    if (window->SkipItems)
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####: 1537:        return;
    %%%%%: 1537-block 4
        -: 1538:
     1077: 1539:    ImGuiContext& g = *GImGui;
     1077: 1540:    window->DC.CurrLineSize.y = ImMax(window->DC.CurrLineSize.y, g.FontSize + g.Style.FramePadding.y * 2);
     1077: 1540-block 5
call    0 returned 1077
     1077: 1541:    window->DC.CurrLineTextBaseOffset = ImMax(window->DC.CurrLineTextBaseOffset, g.Style.FramePadding.y);
call    0 returned 1077
        -: 1542:}
        -: 1543:
        -: 1544:// Horizontal/vertical separating line
        -: 1545:// FIXME: Surprisingly, this seemingly trivial widget is a victim of many different legacy/tricky layout issues.
        -: 1546:// Note how thickness == 1.0f is handled specifically as not moving CursorPos by 'thickness', but other values are.
function _ZN5ImGui11SeparatorExEif called 9866 returned 100% blocks executed 51%
     9866: 1547:void ImGui::SeparatorEx(ImGuiSeparatorFlags flags, float thickness)
        -: 1548:{
     9866: 1549:    ImGuiWindow* window = GetCurrentWindow();
     9866: 1549-block 2
call    0 returned 9866
     9866: 1550:    if (window->SkipItems)
branch  0 taken 0 (fallthrough)
branch  1 taken 9866
    #####: 1551:        return;
    %%%%%: 1551-block 4
        -: 1552:
     9866: 1553:    ImGuiContext& g = *GImGui;
    9866*: 1554:    IM_ASSERT(ImIsPowerOfTwo(flags & (ImGuiSeparatorFlags_Horizontal | ImGuiSeparatorFlags_Vertical)));   // Check that only 1 option is selected
     9866: 1554-block 5
call    0 returned 9866
branch  1 taken 0 (fallthrough)
branch  2 taken 9866
    %%%%%: 1554-block 7
call    3 never executed
    9866*: 1555:    IM_ASSERT(thickness > 0.0f);
     9866: 1555-block 8
branch  0 taken 0 (fallthrough)
branch  1 taken 9866
    %%%%%: 1555-block 9
call    2 never executed
        -: 1556:
     9866: 1557:    if (flags & ImGuiSeparatorFlags_Vertical)
     9866: 1557-block 10
branch  0 taken 0 (fallthrough)
branch  1 taken 9866
        -: 1558:    {
        -: 1559:        // Vertical separator, for menu bars (use current line height).
    #####: 1560:        float y1 = window->DC.CursorPos.y;
    #####: 1561:        float y2 = window->DC.CursorPos.y + window->DC.CurrLineSize.y;
    #####: 1562:        const ImRect bb(ImVec2(window->DC.CursorPos.x, y1), ImVec2(window->DC.CursorPos.x + thickness, y2));
    %%%%%: 1562-block 11
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1563:        ItemSize(ImVec2(thickness, 0.0f));
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$: 1563-block 49
    #####: 1564:        if (!ItemAdd(bb, 0))
    %%%%%: 1564-block 16
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1564-block 17
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 1565:            return;
    %%%%%: 1565-block 18
        -: 1566:
        -: 1567:        // Draw
    #####: 1568:        window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(ImGuiCol_Separator));
    %%%%%: 1568-block 19
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1568-block 20
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    #####: 1569:        if (g.LogEnabled)
    %%%%%: 1569-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1570:            LogText(" |");
    %%%%%: 1570-block 22
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 1571:    }
     9866: 1572:    else if (flags & ImGuiSeparatorFlags_Horizontal)
     9866: 1572-block 24
branch  0 taken 9866 (fallthrough)
branch  1 taken 0
        -: 1573:    {
        -: 1574:        // Horizontal Separator
     9866: 1575:        float x1 = window->DC.CursorPos.x;
     9866: 1576:        float x2 = window->WorkRect.Max.x;
        -: 1577:
        -: 1578:        // Preserve legacy behavior inside Columns()
        -: 1579:        // Before Tables API happened, we relied on Separator() to span all columns of a Columns() set.
        -: 1580:        // We currently don't need to provide the same feature for tables because tables naturally have border features.
    9866*: 1581:        ImGuiOldColumns* columns = (flags & ImGuiSeparatorFlags_SpanAllColumns) ? window->DC.CurrentColumns : NULL;
     9866: 1581-block 25
branch  0 taken 0 (fallthrough)
branch  1 taken 9866
    %%%%%: 1581-block 26
     9866: 1581-block 27
     9866: 1582:        if (columns)
     9866: 1582-block 28
branch  0 taken 0 (fallthrough)
branch  1 taken 9866
        -: 1583:        {
    #####: 1584:            x1 = window->Pos.x + window->DC.Indent.x; // Used to be Pos.x before 2023/10/03
    #####: 1585:            x2 = window->Pos.x + window->Size.x;
    #####: 1586:            PushColumnsBackground();
    %%%%%: 1586-block 29
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 1587:        }
        -: 1588:
        -: 1589:        // We don't provide our width to the layout so that it doesn't get feed back into AutoFit
        -: 1590:        // FIXME: This prevents ->CursorMaxPos based bounding box evaluation from working (e.g. TableEndCell)
    9866*: 1591:        const float thickness_for_layout = (thickness == 1.0f) ? 0.0f : thickness; // FIXME: See 1.70/1.71 Separator() change: makes legacy 1-px separator not affect layout yet. Should change.
     9866: 1591-block 30
branch  0 taken 0 (fallthrough)
branch  1 taken 9866
    %%%%%: 1591-block 31
     9866: 1591-block 32
     9866: 1592:        const ImRect bb(ImVec2(x1, window->DC.CursorPos.y), ImVec2(x2, window->DC.CursorPos.y + thickness));
     9866: 1592-block 33
call    0 returned 9866
call    1 returned 9866
call    2 returned 9866
     9866: 1593:        ItemSize(ImVec2(0.0f, thickness_for_layout));
call    0 returned 9866
call    1 returned 9866
branch  2 taken 9866 (fallthrough)
branch  3 taken 0 (throw)
    $$$$$: 1593-block 51
        -: 1594:
     9866: 1595:        if (ItemAdd(bb, 0))
     9866: 1595-block 38
call    0 returned 9866
branch  1 taken 9866 (fallthrough)
branch  2 taken 0 (throw)
     9866: 1595-block 39
branch  3 taken 9865 (fallthrough)
branch  4 taken 1
        -: 1596:        {
        -: 1597:            // Draw
     9865: 1598:            window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(ImGuiCol_Separator));
     9865: 1598-block 40
call    0 returned 9865
branch  1 taken 9865 (fallthrough)
branch  2 taken 0 (throw)
     9865: 1598-block 41
call    3 returned 9865
branch  4 taken 9865 (fallthrough)
branch  5 taken 0 (throw)
     9865: 1599:            if (g.LogEnabled)
     9865: 1599-block 42
branch  0 taken 0 (fallthrough)
branch  1 taken 9865
    #####: 1600:                LogRenderedText(&bb.Min, "--------------------------------\n");
    %%%%%: 1600-block 43
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 1601:
        -: 1602:        }
     9866: 1603:        if (columns)
     9866: 1603-block 44
branch  0 taken 0 (fallthrough)
branch  1 taken 9866
        -: 1604:        {
    #####: 1605:            PopColumnsBackground();
    %%%%%: 1605-block 45
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1606:            columns->LineMinY = window->DC.CursorPos.y;
    %%%%%: 1606-block 46
        -: 1607:        }
        -: 1608:    }
        -: 1609:}
        -: 1610:
function _ZN5ImGui9SeparatorEv called 9866 returned 100% blocks executed 67%
     9866: 1611:void ImGui::Separator()
        -: 1612:{
     9866: 1613:    ImGuiContext& g = *GImGui;
     9866: 1614:    ImGuiWindow* window = g.CurrentWindow;
     9866: 1615:    if (window->SkipItems)
     9866: 1615-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 9866
    #####: 1616:        return;
    %%%%%: 1616-block 3
        -: 1617:
        -: 1618:    // Those flags should eventually be configurable by the user
        -: 1619:    // FIXME: We cannot g.Style.SeparatorTextBorderSize for thickness as it relates to SeparatorText() which is a decorated separator, not defaulting to 1.0f.
    9866*: 1620:    ImGuiSeparatorFlags flags = (window->DC.LayoutType == ImGuiLayoutType_Horizontal) ? ImGuiSeparatorFlags_Vertical : ImGuiSeparatorFlags_Horizontal;
     9866: 1620-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 9866
    %%%%%: 1620-block 5
     9866: 1620-block 6
        -: 1621:
        -: 1622:    // Only applies to legacy Columns() api as they relied on Separator() a lot.
     9866: 1623:    if (window->DC.CurrentColumns)
     9866: 1623-block 7
branch  0 taken 0 (fallthrough)
branch  1 taken 9866
    #####: 1624:        flags |= ImGuiSeparatorFlags_SpanAllColumns;
    %%%%%: 1624-block 8
        -: 1625:
     9866: 1626:    SeparatorEx(flags, 1.0f);
     9866: 1626-block 9
call    0 returned 9866
        -: 1627:}
        -: 1628:
function _ZN5ImGui15SeparatorTextExEjPKcS1_f called 0 returned 0% blocks executed 0%
    #####: 1629:void ImGui::SeparatorTextEx(ImGuiID id, const char* label, const char* label_end, float extra_w)
        -: 1630:{
    #####: 1631:    ImGuiContext& g = *GImGui;
    #####: 1632:    ImGuiWindow* window = g.CurrentWindow;
    #####: 1633:    ImGuiStyle& style = g.Style;
        -: 1634:
    #####: 1635:    const ImVec2 label_size = CalcTextSize(label, label_end, false);
    %%%%%: 1635-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1636:    const ImVec2 pos = window->DC.CursorPos;
    #####: 1637:    const ImVec2 padding = style.SeparatorTextPadding;
        -: 1638:
    #####: 1639:    const float separator_thickness = style.SeparatorTextBorderSize;
    #####: 1640:    const ImVec2 min_size(label_size.x + extra_w + padding.x * 2.0f, ImMax(label_size.y + padding.y * 2.0f, separator_thickness));
    %%%%%: 1640-block 3
call    0 never executed
call    1 never executed
    #####: 1641:    const ImRect bb(pos, ImVec2(window->WorkRect.Max.x, pos.y + min_size.y));
call    0 never executed
call    1 never executed
    #####: 1642:    const float text_baseline_y = ImTrunc((bb.GetHeight() - label_size.y) * style.SeparatorTextAlign.y + 0.99999f); //ImMax(padding.y, ImTrunc((style.SeparatorTextSize - label_size.y) * 0.5f));
call    0 never executed
call    1 never executed
    #####: 1643:    ItemSize(min_size, text_baseline_y);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1644:    if (!ItemAdd(bb, id))
    %%%%%: 1644-block 10
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1644-block 11
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 1645:        return;
    %%%%%: 1645-block 12
        -: 1646:
    #####: 1647:    const float sep1_x1 = pos.x;
    #####: 1648:    const float sep2_x2 = bb.Max.x;
    #####: 1649:    const float seps_y = ImTrunc((bb.Min.y + bb.Max.y) * 0.5f + 0.99999f);
    %%%%%: 1649-block 13
call    0 never executed
        -: 1650:
    #####: 1651:    const float label_avail_w = ImMax(0.0f, sep2_x2 - sep1_x1 - padding.x * 2.0f);
call    0 never executed
    #####: 1652:    const ImVec2 label_pos(pos.x + padding.x + ImMax(0.0f, (label_avail_w - label_size.x - extra_w) * style.SeparatorTextAlign.x), pos.y + text_baseline_y); // FIXME-ALIGN
call    0 never executed
call    1 never executed
        -: 1653:
        -: 1654:    // This allows using SameLine() to position something in the 'extra_w'
    #####: 1655:    window->DC.CursorPosPrevLine.x = label_pos.x + label_size.x;
        -: 1656:
    #####: 1657:    const ImU32 separator_col = GetColorU32(ImGuiCol_Separator);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1658:    if (label_size.x > 0.0f)
    %%%%%: 1658-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1659:    {
    #####: 1660:        const float sep1_x2 = label_pos.x - style.ItemSpacing.x;
    #####: 1661:        const float sep2_x1 = label_pos.x + label_size.x + extra_w + style.ItemSpacing.x;
    #####: 1662:        if (sep1_x2 > sep1_x1 && separator_thickness > 0.0f)
    %%%%%: 1662-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1662-block 20
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 1663:            window->DrawList->AddLine(ImVec2(sep1_x1, seps_y), ImVec2(sep1_x2, seps_y), separator_col, separator_thickness);
    %%%%%: 1663-block 21
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 1663-block 24
    $$$$$: 1663-block 45
    $$$$$: 1663-block 46
    #####: 1664:        if (sep2_x2 > sep2_x1 && separator_thickness > 0.0f)
    %%%%%: 1664-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1664-block 26
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 1665:            window->DrawList->AddLine(ImVec2(sep2_x1, seps_y), ImVec2(sep2_x2, seps_y), separator_col, separator_thickness);
    %%%%%: 1665-block 27
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 1665-block 30
    $$$$$: 1665-block 47
    $$$$$: 1665-block 48
    #####: 1666:        if (g.LogEnabled)
    %%%%%: 1666-block 31
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1667:            LogSetNextTextDecoration("---", NULL);
    %%%%%: 1667-block 32
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1668:        RenderTextEllipsis(window->DrawList, label_pos, ImVec2(bb.Max.x, bb.Max.y + style.ItemSpacing.y), bb.Max.x, bb.Max.x, label, label_end, &label_size);
    %%%%%: 1668-block 33
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 1668-block 35
    $$$$$: 1668-block 49
        -: 1669:    }
        -: 1670:    else
        -: 1671:    {
    #####: 1672:        if (g.LogEnabled)
    %%%%%: 1672-block 36
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1673:            LogText("---");
    %%%%%: 1673-block 37
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1674:        if (separator_thickness > 0.0f)
    %%%%%: 1674-block 38
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1675:            window->DrawList->AddLine(ImVec2(sep1_x1, seps_y), ImVec2(sep2_x2, seps_y), separator_col, separator_thickness);
    %%%%%: 1675-block 39
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 1675-block 42
    $$$$$: 1675-block 50
    $$$$$: 1675-block 51
        -: 1676:    }
        -: 1677:}
        -: 1678:
function _ZN5ImGui13SeparatorTextEPKc called 0 returned 0% blocks executed 0%
    #####: 1679:void ImGui::SeparatorText(const char* label)
        -: 1680:{
    #####: 1681:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%: 1681-block 2
call    0 never executed
    #####: 1682:    if (window->SkipItems)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1683:        return;
    %%%%%: 1683-block 4
        -: 1684:
        -: 1685:    // The SeparatorText() vs SeparatorTextEx() distinction is designed to be considerate that we may want:
        -: 1686:    // - allow separator-text to be draggable items (would require a stable ID + a noticeable highlight)
        -: 1687:    // - this high-level entry point to allow formatting? (which in turns may require ID separate from formatted string)
        -: 1688:    // - because of this we probably can't turn 'const char* label' into 'const char* fmt, ...'
        -: 1689:    // Otherwise, we can decide that users wanting to drag this would layout a dedicated drag-item,
        -: 1690:    // and then we can turn this into a format function.
    #####: 1691:    SeparatorTextEx(0, label, FindRenderedTextEnd(label), 0.0f);
    %%%%%: 1691-block 5
call    0 never executed
call    1 never executed
        -: 1692:}
        -: 1693:
        -: 1694:// Using 'hover_visibility_delay' allows us to hide the highlight and mouse cursor for a short time, which can be convenient to reduce visual noise.
function _ZN5ImGui16SplitterBehaviorERK6ImRectj9ImGuiAxisPfS4_ffffj called 4304 returned 100% blocks executed 45%
     4304: 1695:bool ImGui::SplitterBehavior(const ImRect& bb, ImGuiID id, ImGuiAxis axis, float* size1, float* size2, float min_size1, float min_size2, float hover_extend, float hover_visibility_delay, ImU32 bg_col)
        -: 1696:{
     4304: 1697:    ImGuiContext& g = *GImGui;
     4304: 1698:    ImGuiWindow* window = g.CurrentWindow;
        -: 1699:
     4304: 1700:    if (!ItemAdd(bb, id, NULL, ImGuiItemFlags_NoNav))
     4304: 1700-block 2
call    0 returned 4304
branch  1 taken 4304 (fallthrough)
branch  2 taken 0 (throw)
     4304: 1700-block 3
branch  3 taken 0 (fallthrough)
branch  4 taken 4304
    #####: 1701:        return false;
    %%%%%: 1701-block 4
        -: 1702:
        -: 1703:    // FIXME: AFAIK the only leftover reason for passing ImGuiButtonFlags_AllowOverlap here is
        -: 1704:    // to allow caller of SplitterBehavior() to call SetItemAllowOverlap() after the item.
        -: 1705:    // Nowadays we would instead want to use SetNextItemAllowOverlap() before the item.
     4304: 1706:    ImGuiButtonFlags button_flags = ImGuiButtonFlags_FlattenChildren;
        -: 1707:#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
     4304: 1708:    button_flags |= ImGuiButtonFlags_AllowOverlap;
        -: 1709:#endif
        -: 1710:
        -: 1711:    bool hovered, held;
     4304: 1712:    ImRect bb_interact = bb;
     4304: 1713:    bb_interact.Expand(axis == ImGuiAxis_Y ? ImVec2(0.0f, hover_extend) : ImVec2(hover_extend, 0.0f));
     4304: 1713-block 5
branch  0 taken 1076 (fallthrough)
branch  1 taken 3228
     1076: 1713-block 6
call    2 returned 1076
     3228: 1713-block 7
call    3 returned 3228
     4304: 1713-block 8
call    4 returned 4304
     4304: 1714:    ButtonBehavior(bb_interact, id, &hovered, &held, button_flags);
call    0 returned 4304
branch  1 taken 4304 (fallthrough)
branch  2 taken 0 (throw)
     4304: 1715:    if (hovered)
     4304: 1715-block 10
branch  0 taken 0 (fallthrough)
branch  1 taken 4304
    #####: 1716:        g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredRect; // for IsItemHovered(), because bb_interact is larger than bb
    %%%%%: 1716-block 11
        -: 1717:
    4304*: 1718:    if (held || (hovered && g.HoveredIdPreviousFrame == id && g.HoveredIdTimer >= hover_visibility_delay))
     4304: 1718-block 12
branch  0 taken 4304 (fallthrough)
branch  1 taken 0
     4304: 1718-block 13
branch  2 taken 0 (fallthrough)
branch  3 taken 4304
    %%%%%: 1718-block 14
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 1718-block 15
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 1719:        SetMouseCursor(axis == ImGuiAxis_Y ? ImGuiMouseCursor_ResizeNS : ImGuiMouseCursor_ResizeEW);
    %%%%%: 1719-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1719-block 17
    %%%%%: 1719-block 18
    %%%%%: 1719-block 19
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
        -: 1720:
     4304: 1721:    ImRect bb_render = bb;
     4304: 1722:    if (held)
     4304: 1722-block 20
branch  0 taken 0 (fallthrough)
branch  1 taken 4304
        -: 1723:    {
    #####: 1724:        float mouse_delta = (g.IO.MousePos - g.ActiveIdClickOffset - bb_interact.Min)[axis];
    %%%%%: 1724-block 21
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1725:
        -: 1726:        // Minimum pane size
    #####: 1727:        float size_1_maximum_delta = ImMax(0.0f, *size1 - min_size1);
call    0 never executed
    #####: 1728:        float size_2_maximum_delta = ImMax(0.0f, *size2 - min_size2);
call    0 never executed
    #####: 1729:        if (mouse_delta < -size_1_maximum_delta)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1730:            mouse_delta = -size_1_maximum_delta;
    %%%%%: 1730-block 27
    #####: 1731:        if (mouse_delta > size_2_maximum_delta)
    %%%%%: 1731-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1732:            mouse_delta = size_2_maximum_delta;
    %%%%%: 1732-block 29
        -: 1733:
        -: 1734:        // Apply resize
    #####: 1735:        if (mouse_delta != 0.0f)
    %%%%%: 1735-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1736:        {
    #####: 1737:            *size1 = ImMax(*size1 + mouse_delta, min_size1);
    %%%%%: 1737-block 31
call    0 never executed
    #####: 1738:            *size2 = ImMax(*size2 - mouse_delta, min_size2);
call    0 never executed
    #####: 1739:            bb_render.Translate((axis == ImGuiAxis_X) ? ImVec2(mouse_delta, 0.0f) : ImVec2(0.0f, mouse_delta));
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1739-block 34
call    2 never executed
    %%%%%: 1739-block 35
call    3 never executed
    %%%%%: 1739-block 36
call    4 never executed
    #####: 1740:            MarkItemEdited(id);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 1741:        }
        -: 1742:    }
        -: 1743:
        -: 1744:    // Render at new position
     4304: 1745:    if (bg_col & IM_COL32_A_MASK)
     4304: 1745-block 38
branch  0 taken 4304 (fallthrough)
branch  1 taken 0
     4304: 1746:        window->DrawList->AddRectFilled(bb_render.Min, bb_render.Max, bg_col, 0.0f);
     4304: 1746-block 39
call    0 returned 4304
branch  1 taken 4304 (fallthrough)
branch  2 taken 0 (throw)
    4304*: 1747:    const ImU32 col = GetColorU32(held ? ImGuiCol_SeparatorActive : (hovered && g.HoveredIdTimer >= hover_visibility_delay) ? ImGuiCol_SeparatorHovered : ImGuiCol_Separator);
     4304: 1747-block 40
branch  0 taken 0 (fallthrough)
branch  1 taken 4304
    %%%%%: 1747-block 41
     4304: 1747-block 42
branch  2 taken 0 (fallthrough)
branch  3 taken 4304
    %%%%%: 1747-block 43
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 1747-block 44
     4304: 1747-block 45
     4304: 1747-block 46
     4304: 1747-block 47
call    6 returned 4304
branch  7 taken 4304 (fallthrough)
branch  8 taken 0 (throw)
     4304: 1748:    window->DrawList->AddRectFilled(bb_render.Min, bb_render.Max, col, 0.0f);
     4304: 1748-block 48
call    0 returned 4304
branch  1 taken 4304 (fallthrough)
branch  2 taken 0 (throw)
        -: 1749:
     4304: 1750:    return held;
     4304: 1750-block 49
        -: 1751:}
        -: 1752:
function _ZL23ShrinkWidthItemComparerPKvS0_ called 0 returned 0% blocks executed 0%
    #####: 1753:static int IMGUI_CDECL ShrinkWidthItemComparer(const void* lhs, const void* rhs)
        -: 1754:{
    #####: 1755:    const ImGuiShrinkWidthItem* a = (const ImGuiShrinkWidthItem*)lhs;
    #####: 1756:    const ImGuiShrinkWidthItem* b = (const ImGuiShrinkWidthItem*)rhs;
    #####: 1757:    if (int d = (int)(b->Width - a->Width))
    %%%%%: 1757-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1758:        return d;
    %%%%%: 1758-block 3
    #####: 1759:    return (b->Index - a->Index);
    %%%%%: 1759-block 4
        -: 1760:}
        -: 1761:
        -: 1762:// Shrink excess width from a set of item, by removing width from the larger items first.
        -: 1763:// Set items Width to -1.0f to disable shrinking this item.
function _ZN5ImGui12ShrinkWidthsEP20ImGuiShrinkWidthItemif called 2152 returned 100% blocks executed 39%
     2152: 1764:void ImGui::ShrinkWidths(ImGuiShrinkWidthItem* items, int count, float width_excess)
        -: 1765:{
     2152: 1766:    if (count == 1)
     2152: 1766-block 2
branch  0 taken 1076 (fallthrough)
branch  1 taken 1076
        -: 1767:    {
     1076: 1768:        if (items[0].Width >= 0.0f)
     1076: 1768-block 3
branch  0 taken 1076 (fallthrough)
branch  1 taken 0
     1076: 1769:            items[0].Width = ImMax(items[0].Width - width_excess, 1.0f);
     1076: 1769-block 4
call    0 returned 1076
     1076: 1770:        return;
     1076: 1770-block 6
        -: 1771:    }
     1076: 1772:    ImQsort(items, (size_t)count, sizeof(ImGuiShrinkWidthItem), ShrinkWidthItemComparer);
     1076: 1772-block 7
call    0 returned 1076
     1076: 1773:    int count_same_width = 1;
     1076: 1774:    while (width_excess > 0.0f && count_same_width < count)
     1076: 1774-block 24
branch  0 taken 1076 (fallthrough)
branch  1 taken 0
     1076: 1774-block 25
branch  2 taken 0
branch  3 taken 1076 (fallthrough)
        -: 1775:    {
    #####: 1776:        while (count_same_width < count && items[0].Width <= items[count_same_width].Width)
    %%%%%: 1776-block 9
    %%%%%: 1776-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1776-block 12
branch  2 never executed
branch  3 never executed (fallthrough)
    #####: 1777:            count_same_width++;
    %%%%%: 1777-block 10
    #####: 1778:        float max_width_to_remove_per_item = (count_same_width < count && items[count_same_width].Width >= 0.0f) ? (items[0].Width - items[count_same_width].Width) : (items[0].Width - 1.0f);
    %%%%%: 1778-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1778-block 14
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1778-block 15
    %%%%%: 1778-block 16
    #####: 1779:        if (max_width_to_remove_per_item <= 0.0f)
    %%%%%: 1779-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1780:            break;
    %%%%%: 1780-block 18
    #####: 1781:        float width_to_remove_per_item = ImMin(width_excess / count_same_width, max_width_to_remove_per_item);
    %%%%%: 1781-block 19
call    0 never executed
    #####: 1782:        for (int item_n = 0; item_n < count_same_width; item_n++)
    %%%%%: 1782-block 22
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 1783:            items[item_n].Width -= width_to_remove_per_item;
    %%%%%: 1783-block 21
    #####: 1784:        width_excess -= width_to_remove_per_item * count_same_width;
    %%%%%: 1784-block 23
        -: 1785:    }
        -: 1786:
        -: 1787:    // Round width and redistribute remainder
        -: 1788:    // Ensure that e.g. the right-most tab of a shrunk tab-bar always reaches exactly at the same distance from the right-most edge of the tab bar separator.
     1076: 1789:    width_excess = 0.0f;
    1076*: 1790:    for (int n = 0; n < count; n++)
     1076: 1790-block 26
     1076: 1790-block 29
branch  0 taken 0
branch  1 taken 1076 (fallthrough)
        -: 1791:    {
    #####: 1792:        float width_rounded = ImTrunc(items[n].Width);
    %%%%%: 1792-block 27
call    0 never executed
    #####: 1793:        width_excess += items[n].Width - width_rounded;
    #####: 1794:        items[n].Width = width_rounded;
        -: 1795:    }
     1076: 1796:    while (width_excess > 0.0f)
     1076: 1796-block 30
     1076: 1796-block 36
branch  0 taken 0
branch  1 taken 1076 (fallthrough)
    #####: 1797:        for (int n = 0; n < count && width_excess > 0.0f; n++)
    %%%%%: 1797-block 31
    %%%%%: 1797-block 34
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1797-block 35
branch  2 never executed
branch  3 never executed (fallthrough)
        -: 1798:        {
    #####: 1799:            float width_to_add = ImMin(items[n].InitialWidth - items[n].Width, 1.0f);
    %%%%%: 1799-block 32
call    0 never executed
    #####: 1800:            items[n].Width += width_to_add;
    #####: 1801:            width_excess -= width_to_add;
        -: 1802:        }
        -: 1803:}
        -: 1804:
        -: 1805://-------------------------------------------------------------------------
        -: 1806:// [SECTION] Widgets: ComboBox
        -: 1807://-------------------------------------------------------------------------
        -: 1808:// - CalcMaxPopupHeightFromItemCount() [Internal]
        -: 1809:// - BeginCombo()
        -: 1810:// - BeginComboPopup() [Internal]
        -: 1811:// - EndCombo()
        -: 1812:// - BeginComboPreview() [Internal]
        -: 1813:// - EndComboPreview() [Internal]
        -: 1814:// - Combo()
        -: 1815://-------------------------------------------------------------------------
        -: 1816:
function _ZL31CalcMaxPopupHeightFromItemCounti called 0 returned 0% blocks executed 0%
    #####: 1817:static float CalcMaxPopupHeightFromItemCount(int items_count)
        -: 1818:{
    #####: 1819:    ImGuiContext& g = *GImGui;
    #####: 1820:    if (items_count <= 0)
    %%%%%: 1820-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1821:        return FLT_MAX;
    %%%%%: 1821-block 3
    #####: 1822:    return (g.FontSize + g.Style.ItemSpacing.y) * items_count - g.Style.ItemSpacing.y + (g.Style.WindowPadding.y * 2);
    %%%%%: 1822-block 4
        -: 1823:}
        -: 1824:
function _ZN5ImGui10BeginComboEPKcS1_i called 0 returned 0% blocks executed 0%
    #####: 1825:bool ImGui::BeginCombo(const char* label, const char* preview_value, ImGuiComboFlags flags)
        -: 1826:{
    #####: 1827:    ImGuiContext& g = *GImGui;
    #####: 1828:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%: 1828-block 2
call    0 never executed
        -: 1829:
    #####: 1830:    ImGuiNextWindowDataFlags backup_next_window_data_flags = g.NextWindowData.Flags;
    #####: 1831:    g.NextWindowData.ClearFlags(); // We behave like Begin() and need to consume those values
call    0 never executed
    #####: 1832:    if (window->SkipItems)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1833:        return false;
    %%%%%: 1833-block 5
        -: 1834:
    #####: 1835:    const ImGuiStyle& style = g.Style;
    #####: 1836:    const ImGuiID id = window->GetID(label);
    %%%%%: 1836-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1837:    IM_ASSERT((flags & (ImGuiComboFlags_NoArrowButton | ImGuiComboFlags_NoPreview)) != (ImGuiComboFlags_NoArrowButton | ImGuiComboFlags_NoPreview)); // Can't use both flags together
    %%%%%: 1837-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1837-block 8
call    2 never executed
    #####: 1838:    if (flags & ImGuiComboFlags_WidthFitPreview)
    %%%%%: 1838-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1839:        IM_ASSERT((flags & (ImGuiComboFlags_NoPreview | (ImGuiComboFlags)ImGuiComboFlags_CustomPreview)) == 0);
    %%%%%: 1839-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1839-block 11
call    2 never executed
        -: 1840:
    #####: 1841:    const float arrow_size = (flags & ImGuiComboFlags_NoArrowButton) ? 0.0f : GetFrameHeight();
    %%%%%: 1841-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1841-block 13
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 1841-block 14
    %%%%%: 1841-block 15
    #####: 1842:    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    %%%%%: 1842-block 16
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1843:    const float preview_width = ((flags & ImGuiComboFlags_WidthFitPreview) && (preview_value != NULL)) ? CalcTextSize(preview_value, NULL, true).x : 0.0f;
    %%%%%: 1843-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1843-block 18
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1843-block 19
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    %%%%%: 1843-block 20
    %%%%%: 1843-block 21
    #####: 1844:    const float w = (flags & ImGuiComboFlags_NoPreview) ? arrow_size : ((flags & ImGuiComboFlags_WidthFitPreview) ? (arrow_size + preview_width + style.FramePadding.x * 2.0f) : CalcItemWidth());
    %%%%%: 1844-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1844-block 23
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1844-block 24
    %%%%%: 1844-block 25
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    %%%%%: 1844-block 26
    %%%%%: 1844-block 27
    %%%%%: 1844-block 28
    #####: 1845:    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y * 2.0f));
    %%%%%: 1845-block 29
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1846:    const ImRect total_bb(bb.Min, bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1846-block 33
    %%%%%: 1846-block 34
    %%%%%: 1846-block 35
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 1847:    ItemSize(total_bb, style.FramePadding.y);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1848:    if (!ItemAdd(total_bb, id, &bb))
    %%%%%: 1848-block 39
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1848-block 40
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 1849:        return false;
    %%%%%: 1849-block 41
        -: 1850:
        -: 1851:    // Open on click
        -: 1852:    bool hovered, held;
    #####: 1853:    bool pressed = ButtonBehavior(bb, id, &hovered, &held);
    %%%%%: 1853-block 42
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1854:    const ImGuiID popup_id = ImHashStr("##ComboPopup", 0, id);
    %%%%%: 1854-block 43
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1855:    bool popup_open = IsPopupOpen(popup_id, ImGuiPopupFlags_None);
    %%%%%: 1855-block 44
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1856:    if (pressed && !popup_open)
    %%%%%: 1856-block 45
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1856-block 46
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 1857:    {
    #####: 1858:        OpenPopupEx(popup_id, ImGuiPopupFlags_None);
    %%%%%: 1858-block 47
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1859:        popup_open = true;
    %%%%%: 1859-block 48
        -: 1860:    }
        -: 1861:
        -: 1862:    // Render shape
    #####: 1863:    const ImU32 frame_col = GetColorU32(hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);
    %%%%%: 1863-block 49
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1863-block 50
    %%%%%: 1863-block 51
    %%%%%: 1863-block 52
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####: 1864:    const float value_x2 = ImMax(bb.Min.x, bb.Max.x - arrow_size);
    %%%%%: 1864-block 53
call    0 never executed
    #####: 1865:    RenderNavCursor(bb, id);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1866:    if (!(flags & ImGuiComboFlags_NoPreview))
    %%%%%: 1866-block 55
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1867:        window->DrawList->AddRectFilled(bb.Min, ImVec2(value_x2, bb.Max.y), frame_col, style.FrameRounding, (flags & ImGuiComboFlags_NoArrowButton) ? ImDrawFlags_RoundCornersAll : ImDrawFlags_RoundCornersLeft);
    %%%%%: 1867-block 56
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1867-block 57
    %%%%%: 1867-block 58
    %%%%%: 1867-block 59
call    2 never executed
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    %%%%%: 1867-block 61
    $$$$$: 1867-block 104
    #####: 1868:    if (!(flags & ImGuiComboFlags_NoArrowButton))
    %%%%%: 1868-block 62
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1869:    {
    #####: 1870:        ImU32 bg_col = GetColorU32((popup_open || hovered) ? ImGuiCol_ButtonHovered : ImGuiCol_Button);
    %%%%%: 1870-block 63
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1870-block 64
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1870-block 65
    %%%%%: 1870-block 66
    %%%%%: 1870-block 67
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    #####: 1871:        ImU32 text_col = GetColorU32(ImGuiCol_Text);
    %%%%%: 1871-block 68
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1872:        window->DrawList->AddRectFilled(ImVec2(value_x2, bb.Min.y), bb.Max, bg_col, style.FrameRounding, (w <= arrow_size) ? ImDrawFlags_RoundCornersAll : ImDrawFlags_RoundCornersRight);
    %%%%%: 1872-block 69
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1872-block 70
    %%%%%: 1872-block 71
    %%%%%: 1872-block 72
call    2 never executed
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    $$$$$: 1872-block 105
    #####: 1873:        if (value_x2 + arrow_size - style.FramePadding.x <= bb.Max.x)
    %%%%%: 1873-block 74
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1874:            RenderArrow(window->DrawList, ImVec2(value_x2 + style.FramePadding.y, bb.Min.y + style.FramePadding.y), text_col, ImGuiDir_Down, 1.0f);
    %%%%%: 1874-block 75
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 1874-block 77
    $$$$$: 1874-block 106
        -: 1875:    }
    #####: 1876:    RenderFrameBorder(bb.Min, bb.Max, style.FrameRounding);
    %%%%%: 1876-block 78
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 1877:
        -: 1878:    // Custom preview
    #####: 1879:    if (flags & ImGuiComboFlags_CustomPreview)
    %%%%%: 1879-block 79
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1880:    {
    #####: 1881:        g.ComboPreviewData.PreviewRect = ImRect(bb.Min.x, bb.Min.y, value_x2, bb.Max.y);
    %%%%%: 1881-block 80
call    0 never executed
    #####: 1882:        IM_ASSERT(preview_value == NULL || preview_value[0] == 0);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1882-block 82
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1882-block 83
call    4 never executed
    #####: 1883:        preview_value = NULL;
    %%%%%: 1883-block 84
        -: 1884:    }
        -: 1885:
        -: 1886:    // Render preview and label
    #####: 1887:    if (preview_value != NULL && !(flags & ImGuiComboFlags_NoPreview))
    %%%%%: 1887-block 85
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1887-block 86
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 1888:    {
    #####: 1889:        if (g.LogEnabled)
    %%%%%: 1889-block 87
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1890:            LogSetNextTextDecoration("{", "}");
    %%%%%: 1890-block 88
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1891:        RenderTextClipped(bb.Min + style.FramePadding, ImVec2(value_x2, bb.Max.y), preview_value, NULL, NULL);
    %%%%%: 1891-block 89
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    %%%%%: 1891-block 93
    $$$$$: 1891-block 107
    $$$$$: 1891-block 108
    $$$$$: 1891-block 109
        -: 1892:    }
    #####: 1893:    if (label_size.x > 0)
    %%%%%: 1893-block 94
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1894:        RenderText(ImVec2(bb.Max.x + style.ItemInnerSpacing.x, bb.Min.y + style.FramePadding.y), label);
    %%%%%: 1894-block 95
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 1894-block 97
    $$$$$: 1894-block 110
        -: 1895:
    #####: 1896:    if (!popup_open)
    %%%%%: 1896-block 98
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1897:        return false;
    %%%%%: 1897-block 99
        -: 1898:
    #####: 1899:    g.NextWindowData.Flags = backup_next_window_data_flags;
    #####: 1900:    return BeginComboPopup(popup_id, bb, flags);
    %%%%%: 1900-block 100
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1900-block 101
        -: 1901:}
        -: 1902:
function _ZN5ImGui15BeginComboPopupEjRK6ImRecti called 0 returned 0% blocks executed 0%
    #####: 1903:bool ImGui::BeginComboPopup(ImGuiID popup_id, const ImRect& bb, ImGuiComboFlags flags)
        -: 1904:{
    #####: 1905:    ImGuiContext& g = *GImGui;
    #####: 1906:    if (!IsPopupOpen(popup_id, ImGuiPopupFlags_None))
    %%%%%: 1906-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1906-block 3
branch  3 never executed (fallthrough)
branch  4 never executed
        -: 1907:    {
    #####: 1908:        g.NextWindowData.ClearFlags();
    %%%%%: 1908-block 4
call    0 never executed
    #####: 1909:        return false;
        -: 1910:    }
        -: 1911:
        -: 1912:    // Set popup size
    #####: 1913:    float w = bb.GetWidth();
    %%%%%: 1913-block 6
call    0 never executed
    #####: 1914:    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSizeConstraint)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1915:    {
    #####: 1916:        g.NextWindowData.SizeConstraintRect.Min.x = ImMax(g.NextWindowData.SizeConstraintRect.Min.x, w);
    %%%%%: 1916-block 8
call    0 never executed
        -: 1917:    }
        -: 1918:    else
        -: 1919:    {
    #####: 1920:        if ((flags & ImGuiComboFlags_HeightMask_) == 0)
    %%%%%: 1920-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1921:            flags |= ImGuiComboFlags_HeightRegular;
    %%%%%: 1921-block 11
    #####: 1922:        IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiComboFlags_HeightMask_)); // Only one
    %%%%%: 1922-block 12
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 1922-block 14
call    3 never executed
    #####: 1923:        int popup_max_height_in_items = -1;
    #####: 1924:        if (flags & ImGuiComboFlags_HeightRegular)     popup_max_height_in_items = 8;
    %%%%%: 1924-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1924-block 16
    #####: 1925:        else if (flags & ImGuiComboFlags_HeightSmall)  popup_max_height_in_items = 4;
    %%%%%: 1925-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1925-block 18
    #####: 1926:        else if (flags & ImGuiComboFlags_HeightLarge)  popup_max_height_in_items = 20;
    %%%%%: 1926-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1926-block 20
    #####: 1927:        ImVec2 constraint_min(0.0f, 0.0f), constraint_max(FLT_MAX, FLT_MAX);
    #####: 1928:        if ((g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSize) == 0 || g.NextWindowData.SizeVal.x <= 0.0f) // Don't apply constraints if user specified a size
    %%%%%: 1928-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1928-block 22
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 1929:            constraint_min.x = w;
    %%%%%: 1929-block 23
    #####: 1930:        if ((g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSize) == 0 || g.NextWindowData.SizeVal.y <= 0.0f)
    %%%%%: 1930-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1930-block 25
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 1931:            constraint_max.y = CalcMaxPopupHeightFromItemCount(popup_max_height_in_items);
    %%%%%: 1931-block 26
call    0 never executed
    #####: 1932:        SetNextWindowSizeConstraints(constraint_min, constraint_max);
    %%%%%: 1932-block 28
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 1933:    }
        -: 1934:
        -: 1935:    // This is essentially a specialized version of BeginPopupEx()
        -: 1936:    char name[16];
    #####: 1937:    ImFormatString(name, IM_ARRAYSIZE(name), "##Combo_%02d", g.BeginComboDepth); // Recycle windows based on depth
    %%%%%: 1937-block 30
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 1938:
        -: 1939:    // Set position given a custom constraint (peak into expected window size so we can position it)
        -: 1940:    // FIXME: This might be easier to express with an hypothetical SetNextWindowPosConstraints() function?
        -: 1941:    // FIXME: This might be moved to Begin() or at least around the same spot where Tooltips and other Popups are calling FindBestWindowPosForPopupEx()?
    #####: 1942:    if (ImGuiWindow* popup_window = FindWindowByName(name))
    %%%%%: 1942-block 31
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 1942-block 32
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 1943:        if (popup_window->WasActive)
    %%%%%: 1943-block 33
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1944:        {
        -: 1945:            // Always override 'AutoPosLastDirection' to not leave a chance for a past value to affect us.
    #####: 1946:            ImVec2 size_expected = CalcWindowNextAutoFitSize(popup_window);
    %%%%%: 1946-block 34
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1947:            popup_window->AutoPosLastDirection = (flags & ImGuiComboFlags_PopupAlignLeft) ? ImGuiDir_Left : ImGuiDir_Down; // Left = "Below, Toward Left", Down = "Below, Toward Right (default)"
    %%%%%: 1947-block 35
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1947-block 36
    %%%%%: 1947-block 37
    #####: 1948:            ImRect r_outer = GetPopupAllowedExtentRect(popup_window);
    %%%%%: 1948-block 38
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1949:            ImVec2 pos = FindBestWindowPosForPopupEx(bb.GetBL(), size_expected, &popup_window->AutoPosLastDirection, r_outer, bb, ImGuiPopupPositionPolicy_ComboBox);
    %%%%%: 1949-block 39
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$: 1949-block 54
    #####: 1950:            SetNextWindowPos(pos);
    %%%%%: 1950-block 41
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 1950-block 43
    $$$$$: 1950-block 55
        -: 1951:        }
        -: 1952:
        -: 1953:    // We don't use BeginPopupEx() solely because we have a custom name string, which we could make an argument to BeginPopupEx()
    #####: 1954:    ImGuiWindowFlags window_flags = ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_Popup | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoMove;
    #####: 1955:    PushStyleVarX(ImGuiStyleVar_WindowPadding, g.Style.FramePadding.x); // Horizontally align ourselves with the framed text
    %%%%%: 1955-block 44
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1956:    bool ret = Begin(name, NULL, window_flags);
    %%%%%: 1956-block 45
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1957:    PopStyleVar();
    %%%%%: 1957-block 46
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1958:    if (!ret)
    %%%%%: 1958-block 47
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1959:    {
    #####: 1960:        EndPopup();
    %%%%%: 1960-block 48
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1961:        IM_ASSERT(0);   // This should never happen as we tested for IsPopupOpen() above
    %%%%%: 1961-block 49
call    0 never executed
        -: 1962:        return false;
        -: 1963:    }
    #####: 1964:    g.BeginComboDepth++;
    #####: 1965:    return true;
    %%%%%: 1965-block 50
        -: 1966:}
        -: 1967:
function _ZN5ImGui8EndComboEv called 0 returned 0% blocks executed 0%
    #####: 1968:void ImGui::EndCombo()
        -: 1969:{
    #####: 1970:    ImGuiContext& g = *GImGui;
    #####: 1971:    EndPopup();
    %%%%%: 1971-block 2
call    0 never executed
    #####: 1972:    g.BeginComboDepth--;
    #####: 1973:}
        -: 1974:
        -: 1975:// Call directly after the BeginCombo/EndCombo block. The preview is designed to only host non-interactive elements
        -: 1976:// (Experimental, see GitHub issues: #1658, #4168)
function _ZN5ImGui17BeginComboPreviewEv called 0 returned 0% blocks executed 0%
    #####: 1977:bool ImGui::BeginComboPreview()
        -: 1978:{
    #####: 1979:    ImGuiContext& g = *GImGui;
    #####: 1980:    ImGuiWindow* window = g.CurrentWindow;
    #####: 1981:    ImGuiComboPreviewData* preview_data = &g.ComboPreviewData;
        -: 1982:
    #####: 1983:    if (window->SkipItems || !(g.LastItemData.StatusFlags & ImGuiItemStatusFlags_Visible))
    %%%%%: 1983-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1983-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 1984:        return false;
    %%%%%: 1984-block 4
    #####: 1985:    IM_ASSERT(g.LastItemData.Rect.Min.x == preview_data->PreviewRect.Min.x && g.LastItemData.Rect.Min.y == preview_data->PreviewRect.Min.y); // Didn't call after BeginCombo/EndCombo block or forgot to pass ImGuiComboFlags_CustomPreview flag?
    %%%%%: 1985-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1985-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1985-block 7
    %%%%%: 1985-block 8
call    4 never executed
    #####: 1986:    if (!window->ClipRect.Overlaps(preview_data->PreviewRect)) // Narrower test (optional)
    %%%%%: 1986-block 9
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 1987:        return false;
    %%%%%: 1987-block 11
        -: 1988:
        -: 1989:    // FIXME: This could be contained in a PushWorkRect() api
    #####: 1990:    preview_data->BackupCursorPos = window->DC.CursorPos;
    #####: 1991:    preview_data->BackupCursorMaxPos = window->DC.CursorMaxPos;
    #####: 1992:    preview_data->BackupCursorPosPrevLine = window->DC.CursorPosPrevLine;
    #####: 1993:    preview_data->BackupPrevLineTextBaseOffset = window->DC.PrevLineTextBaseOffset;
    #####: 1994:    preview_data->BackupLayout = window->DC.LayoutType;
    #####: 1995:    window->DC.CursorPos = preview_data->PreviewRect.Min + g.Style.FramePadding;
    %%%%%: 1995-block 12
call    0 never executed
    #####: 1996:    window->DC.CursorMaxPos = window->DC.CursorPos;
    #####: 1997:    window->DC.LayoutType = ImGuiLayoutType_Horizontal;
    #####: 1998:    window->DC.IsSameLine = false;
    #####: 1999:    PushClipRect(preview_data->PreviewRect.Min, preview_data->PreviewRect.Max, true);
call    0 never executed
        -: 2000:
    #####: 2001:    return true;
        -: 2002:}
        -: 2003:
function _ZN5ImGui15EndComboPreviewEv called 0 returned 0% blocks executed 0%
    #####: 2004:void ImGui::EndComboPreview()
        -: 2005:{
    #####: 2006:    ImGuiContext& g = *GImGui;
    #####: 2007:    ImGuiWindow* window = g.CurrentWindow;
    #####: 2008:    ImGuiComboPreviewData* preview_data = &g.ComboPreviewData;
        -: 2009:
        -: 2010:    // FIXME: Using CursorMaxPos approximation instead of correct AABB which we will store in ImDrawCmd in the future
    #####: 2011:    ImDrawList* draw_list = window->DrawList;
    #####: 2012:    if (window->DC.CursorMaxPos.x < preview_data->PreviewRect.Max.x && window->DC.CursorMaxPos.y < preview_data->PreviewRect.Max.y)
    %%%%%: 2012-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2012-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2013:        if (draw_list->CmdBuffer.Size > 1) // Unlikely case that the PushClipRect() didn't create a command
    %%%%%: 2013-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2014:        {
    #####: 2015:            draw_list->_CmdHeader.ClipRect = draw_list->CmdBuffer[draw_list->CmdBuffer.Size - 1].ClipRect = draw_list->CmdBuffer[draw_list->CmdBuffer.Size - 2].ClipRect;
    %%%%%: 2015-block 5
call    0 never executed
call    1 never executed
    #####: 2016:            draw_list->_TryMergeDrawCmds();
call    0 never executed
        -: 2017:        }
    #####: 2018:    PopClipRect();
    %%%%%: 2018-block 8
call    0 never executed
    #####: 2019:    window->DC.CursorPos = preview_data->BackupCursorPos;
    #####: 2020:    window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, preview_data->BackupCursorMaxPos);
call    0 never executed
    #####: 2021:    window->DC.CursorPosPrevLine = preview_data->BackupCursorPosPrevLine;
    #####: 2022:    window->DC.PrevLineTextBaseOffset = preview_data->BackupPrevLineTextBaseOffset;
    #####: 2023:    window->DC.LayoutType = preview_data->BackupLayout;
    #####: 2024:    window->DC.IsSameLine = false;
    #####: 2025:    preview_data->PreviewRect = ImRect();
call    0 never executed
    #####: 2026:}
        -: 2027:
        -: 2028:// Getter for the old Combo() API: const char*[]
function _ZL17Items_ArrayGetterPvi called 0 returned 0% blocks executed 0%
    #####: 2029:static const char* Items_ArrayGetter(void* data, int idx)
        -: 2030:{
    #####: 2031:    const char* const* items = (const char* const*)data;
    #####: 2032:    return items[idx];
    %%%%%: 2032-block 2
        -: 2033:}
        -: 2034:
        -: 2035:// Getter for the old Combo() API: "item1\0item2\0item3\0"
function _ZL24Items_SingleStringGetterPvi called 0 returned 0% blocks executed 0%
    #####: 2036:static const char* Items_SingleStringGetter(void* data, int idx)
        -: 2037:{
    #####: 2038:    const char* items_separated_by_zeros = (const char*)data;
    #####: 2039:    int items_count = 0;
    #####: 2040:    const char* p = items_separated_by_zeros;
    #####: 2041:    while (*p)
    %%%%%: 2041-block 2
    %%%%%: 2041-block 6
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 2042:    {
    #####: 2043:        if (idx == items_count)
    %%%%%: 2043-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2044:            break;
    %%%%%: 2044-block 4
    #####: 2045:        p += strlen(p) + 1;
    #####: 2046:        items_count++;
    %%%%%: 2046-block 5
        -: 2047:    }
    #####: 2048:    return *p ? p : NULL;
    %%%%%: 2048-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2048-block 8
    %%%%%: 2048-block 9
    %%%%%: 2048-block 10
        -: 2049:}
        -: 2050:
        -: 2051:// Old API, prefer using BeginCombo() nowadays if you can.
function _ZN5ImGui5ComboEPKcPiPFS1_PviES3_ii called 0 returned 0% blocks executed 0%
    #####: 2052:bool ImGui::Combo(const char* label, int* current_item, const char* (*getter)(void* user_data, int idx), void* user_data, int items_count, int popup_max_height_in_items)
        -: 2053:{
    #####: 2054:    ImGuiContext& g = *GImGui;
        -: 2055:
        -: 2056:    // Call the getter to obtain the preview string which is a parameter to BeginCombo()
    #####: 2057:    const char* preview_value = NULL;
    #####: 2058:    if (*current_item >= 0 && *current_item < items_count)
    %%%%%: 2058-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2058-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2059:        preview_value = getter(user_data, *current_item);
    %%%%%: 2059-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 2059-block 5
        -: 2060:
        -: 2061:    // The old Combo() API exposed "popup_max_height_in_items". The new more general BeginCombo() API doesn't have/need it, but we emulate it here.
    #####: 2062:    if (popup_max_height_in_items != -1 && !(g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSizeConstraint))
    %%%%%: 2062-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2062-block 7
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2063:        SetNextWindowSizeConstraints(ImVec2(0, 0), ImVec2(FLT_MAX, CalcMaxPopupHeightFromItemCount(popup_max_height_in_items)));
    %%%%%: 2063-block 8
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    %%%%%: 2063-block 12
    $$$$$: 2063-block 46
    $$$$$: 2063-block 47
        -: 2064:
    #####: 2065:    if (!BeginCombo(label, preview_value, ImGuiComboFlags_None))
    %%%%%: 2065-block 13
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 2065-block 14
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 2066:        return false;
    %%%%%: 2066-block 15
        -: 2067:
        -: 2068:    // Display items
    #####: 2069:    bool value_changed = false;
    #####: 2070:    ImGuiListClipper clipper;
    %%%%%: 2070-block 16
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 2071:    clipper.Begin(items_count);
    %%%%%: 2071-block 17
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 2072:    clipper.IncludeItemByIndex(*current_item);
    %%%%%: 2072-block 18
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 2073:    while (clipper.Step())
    %%%%%: 2073-block 19
    %%%%%: 2073-block 38
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 2073-block 39
branch  3 never executed
branch  4 never executed (fallthrough)
    #####: 2074:        for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)
    %%%%%: 2074-block 20
    %%%%%: 2074-block 36
    %%%%%: 2074-block 37
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 2075:        {
    #####: 2076:            const char* item_text = getter(user_data, i);
    %%%%%: 2076-block 21
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 2077:            if (item_text == NULL)
    %%%%%: 2077-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2078:                item_text = "*Unknown item*";
    %%%%%: 2078-block 23
        -: 2079:
    #####: 2080:            PushID(i);
    %%%%%: 2080-block 24
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 2081:            const bool item_selected = (i == *current_item);
    #####: 2082:            if (Selectable(item_text, item_selected) && *current_item != i)
    %%%%%: 2082-block 25
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 2082-block 27
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 2082-block 28
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 2082-block 29
    %%%%%: 2082-block 30
    %%%%%: 2082-block 31
branch  8 never executed (fallthrough)
branch  9 never executed
    $$$$$: 2082-block 48
        -: 2083:            {
    #####: 2084:                value_changed = true;
    #####: 2085:                *current_item = i;
    %%%%%: 2085-block 32
        -: 2086:            }
    #####: 2087:            if (item_selected)
    %%%%%: 2087-block 33
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2088:                SetItemDefaultFocus();
    %%%%%: 2088-block 34
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 2089:            PopID();
    %%%%%: 2089-block 35
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 2090:        }
        -: 2091:
    #####: 2092:    EndCombo();
    %%%%%: 2092-block 40
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 2093:    if (value_changed)
    %%%%%: 2093-block 41
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2094:        MarkItemEdited(g.LastItemData.ID);
    %%%%%: 2094-block 42
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 2095:
    #####: 2096:    return value_changed;
    #####: 2097:}
    %%%%%: 2097-block 43
call    0 never executed
    $$$$$: 2097-block 49
call    1 never executed
        -: 2098:
        -: 2099:// Combo box helper allowing to pass an array of strings.
function _ZN5ImGui5ComboEPKcPiPKS1_ii called 0 returned 0% blocks executed 0%
    #####: 2100:bool ImGui::Combo(const char* label, int* current_item, const char* const items[], int items_count, int height_in_items)
        -: 2101:{
    #####: 2102:    const bool value_changed = Combo(label, current_item, Items_ArrayGetter, (void*)items, items_count, height_in_items);
    %%%%%: 2102-block 2
call    0 never executed
    #####: 2103:    return value_changed;
        -: 2104:}
        -: 2105:
        -: 2106:// Combo box helper allowing to pass all items in a single string literal holding multiple zero-terminated items "item1\0item2\0"
function _ZN5ImGui5ComboEPKcPiS1_i called 0 returned 0% blocks executed 0%
    #####: 2107:bool ImGui::Combo(const char* label, int* current_item, const char* items_separated_by_zeros, int height_in_items)
        -: 2108:{
    #####: 2109:    int items_count = 0;
    #####: 2110:    const char* p = items_separated_by_zeros;       // FIXME-OPT: Avoid computing this, or at least only when combo is open
    #####: 2111:    while (*p)
    %%%%%: 2111-block 2
    %%%%%: 2111-block 4
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 2112:    {
    #####: 2113:        p += strlen(p) + 1;
    #####: 2114:        items_count++;
    %%%%%: 2114-block 3
        -: 2115:    }
    #####: 2116:    bool value_changed = Combo(label, current_item, Items_SingleStringGetter, (void*)items_separated_by_zeros, items_count, height_in_items);
    %%%%%: 2116-block 5
call    0 never executed
    #####: 2117:    return value_changed;
        -: 2118:}
        -: 2119:
        -: 2120:#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
        -: 2121:
        -: 2122:struct ImGuiGetNameFromIndexOldToNewCallbackData { void* UserData; bool (*OldCallback)(void*, int, const char**); };
function _ZL37ImGuiGetNameFromIndexOldToNewCallbackPvi called 0 returned 0% blocks executed 0%
    #####: 2123:static const char* ImGuiGetNameFromIndexOldToNewCallback(void* user_data, int idx)
        -: 2124:{
    #####: 2125:    ImGuiGetNameFromIndexOldToNewCallbackData* data = (ImGuiGetNameFromIndexOldToNewCallbackData*)user_data;
    #####: 2126:    const char* s = NULL;
    #####: 2127:    data->OldCallback(data->UserData, idx, &s);
    %%%%%: 2127-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 2128:    return s;
    %%%%%: 2128-block 3
    %%%%%: 2128-block 4
        -: 2129:}
        -: 2130:
function _ZN5ImGui7ListBoxEPKcPiPFbPviPS1_ES3_ii called 0 returned 0% blocks executed 0%
    #####: 2131:bool ImGui::ListBox(const char* label, int* current_item, bool (*old_getter)(void*, int, const char**), void* user_data, int items_count, int height_in_items)
        -: 2132:{
    #####: 2133:    ImGuiGetNameFromIndexOldToNewCallbackData old_to_new_data = { user_data, old_getter };
    #####: 2134:    return ListBox(label, current_item, ImGuiGetNameFromIndexOldToNewCallback, &old_to_new_data, items_count, height_in_items);
    %%%%%: 2134-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 2134-block 3
    %%%%%: 2134-block 5
        -: 2135:}
function _ZN5ImGui5ComboEPKcPiPFbPviPS1_ES3_ii called 0 returned 0% blocks executed 0%
    #####: 2136:bool ImGui::Combo(const char* label, int* current_item, bool (*old_getter)(void*, int, const char**), void* user_data, int items_count, int popup_max_height_in_items)
        -: 2137:{
    #####: 2138:    ImGuiGetNameFromIndexOldToNewCallbackData old_to_new_data = { user_data, old_getter };
    #####: 2139:    return Combo(label, current_item, ImGuiGetNameFromIndexOldToNewCallback, &old_to_new_data, items_count, popup_max_height_in_items);
    %%%%%: 2139-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 2139-block 3
    %%%%%: 2139-block 5
        -: 2140:}
        -: 2141:
        -: 2142:#endif
        -: 2143:
        -: 2144://-------------------------------------------------------------------------
        -: 2145:// [SECTION] Data Type and Data Formatting Helpers [Internal]
        -: 2146://-------------------------------------------------------------------------
        -: 2147:// - DataTypeGetInfo()
        -: 2148:// - DataTypeFormatString()
        -: 2149:// - DataTypeApplyOp()
        -: 2150:// - DataTypeApplyFromText()
        -: 2151:// - DataTypeCompare()
        -: 2152:// - DataTypeClamp()
        -: 2153:// - GetMinimumStepAtDecimalPrecision
        -: 2154:// - RoundScalarWithFormat<>()
        -: 2155://-------------------------------------------------------------------------
        -: 2156:
        -: 2157:static const ImGuiDataTypeInfo GDataTypeInfo[] =
        -: 2158:{
        -: 2159:    { sizeof(char),             "S8",   "%d",   "%d"    },  // ImGuiDataType_S8
        -: 2160:    { sizeof(unsigned char),    "U8",   "%u",   "%u"    },
        -: 2161:    { sizeof(short),            "S16",  "%d",   "%d"    },  // ImGuiDataType_S16
        -: 2162:    { sizeof(unsigned short),   "U16",  "%u",   "%u"    },
        -: 2163:    { sizeof(int),              "S32",  "%d",   "%d"    },  // ImGuiDataType_S32
        -: 2164:    { sizeof(unsigned int),     "U32",  "%u",   "%u"    },
        -: 2165:#ifdef _MSC_VER
        -: 2166:    { sizeof(ImS64),            "S64",  "%I64d","%I64d" },  // ImGuiDataType_S64
        -: 2167:    { sizeof(ImU64),            "U64",  "%I64u","%I64u" },
        -: 2168:#else
        -: 2169:    { sizeof(ImS64),            "S64",  "%lld", "%lld"  },  // ImGuiDataType_S64
        -: 2170:    { sizeof(ImU64),            "U64",  "%llu", "%llu"  },
        -: 2171:#endif
        -: 2172:    { sizeof(float),            "float", "%.3f","%f"    },  // ImGuiDataType_Float (float are promoted to double in va_arg)
        -: 2173:    { sizeof(double),           "double","%f",  "%lf"   },  // ImGuiDataType_Double
        -: 2174:    { sizeof(bool),             "bool", "%d",   "%d"    },  // ImGuiDataType_Bool
        -: 2175:};
        -: 2176:IM_STATIC_ASSERT(IM_ARRAYSIZE(GDataTypeInfo) == ImGuiDataType_COUNT);
        -: 2177:
function _ZN5ImGui15DataTypeGetInfoEi called 0 returned 0% blocks executed 0%
    #####: 2178:const ImGuiDataTypeInfo* ImGui::DataTypeGetInfo(ImGuiDataType data_type)
        -: 2179:{
    #####: 2180:    IM_ASSERT(data_type >= 0 && data_type < ImGuiDataType_COUNT);
    %%%%%: 2180-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2180-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2180-block 4
    %%%%%: 2180-block 5
call    4 never executed
    #####: 2181:    return &GDataTypeInfo[data_type];
    %%%%%: 2181-block 6
        -: 2182:}
        -: 2183:
function _ZN5ImGui20DataTypeFormatStringEPciiPKvPKc called 0 returned 0% blocks executed 0%
    #####: 2184:int ImGui::DataTypeFormatString(char* buf, int buf_size, ImGuiDataType data_type, const void* p_data, const char* format)
        -: 2185:{
        -: 2186:    // Signedness doesn't matter when pushing integer arguments
    #####: 2187:    if (data_type == ImGuiDataType_S32 || data_type == ImGuiDataType_U32)
    %%%%%: 2187-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2187-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2188:        return ImFormatString(buf, buf_size, format, *(const ImU32*)p_data);
    %%%%%: 2188-block 4
call    0 never executed
    #####: 2189:    if (data_type == ImGuiDataType_S64 || data_type == ImGuiDataType_U64)
    %%%%%: 2189-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2189-block 7
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2190:        return ImFormatString(buf, buf_size, format, *(const ImU64*)p_data);
    %%%%%: 2190-block 8
call    0 never executed
    #####: 2191:    if (data_type == ImGuiDataType_Float)
    %%%%%: 2191-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2192:        return ImFormatString(buf, buf_size, format, *(const float*)p_data);
    %%%%%: 2192-block 11
call    0 never executed
    #####: 2193:    if (data_type == ImGuiDataType_Double)
    %%%%%: 2193-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2194:        return ImFormatString(buf, buf_size, format, *(const double*)p_data);
    %%%%%: 2194-block 14
call    0 never executed
    #####: 2195:    if (data_type == ImGuiDataType_S8)
    %%%%%: 2195-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2196:        return ImFormatString(buf, buf_size, format, *(const ImS8*)p_data);
    %%%%%: 2196-block 17
call    0 never executed
    #####: 2197:    if (data_type == ImGuiDataType_U8)
    %%%%%: 2197-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2198:        return ImFormatString(buf, buf_size, format, *(const ImU8*)p_data);
    %%%%%: 2198-block 20
call    0 never executed
    #####: 2199:    if (data_type == ImGuiDataType_S16)
    %%%%%: 2199-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2200:        return ImFormatString(buf, buf_size, format, *(const ImS16*)p_data);
    %%%%%: 2200-block 23
call    0 never executed
    #####: 2201:    if (data_type == ImGuiDataType_U16)
    %%%%%: 2201-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2202:        return ImFormatString(buf, buf_size, format, *(const ImU16*)p_data);
    %%%%%: 2202-block 26
call    0 never executed
    #####: 2203:    IM_ASSERT(0);
    %%%%%: 2203-block 28
call    0 never executed
        -: 2204:    return 0;
        -: 2205:}
        -: 2206:
function _ZN5ImGui15DataTypeApplyOpEiiPvPKvS2_ called 0 returned 0% blocks executed 0%
    #####: 2207:void ImGui::DataTypeApplyOp(ImGuiDataType data_type, int op, void* output, const void* arg1, const void* arg2)
        -: 2208:{
    #####: 2209:    IM_ASSERT(op == '+' || op == '-');
    %%%%%: 2209-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2209-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2209-block 4
call    4 never executed
    #####: 2210:    switch (data_type)
    %%%%%: 2210-block 5
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
        -: 2211:    {
    #####: 2212:        case ImGuiDataType_S8:
    #####: 2213:            if (op == '+') { *(ImS8*)output  = ImAddClampOverflow(*(const ImS8*)arg1,  *(const ImS8*)arg2,  IM_S8_MIN,  IM_S8_MAX); }
    %%%%%: 2213-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2213-block 7
call    2 never executed
    #####: 2214:            if (op == '-') { *(ImS8*)output  = ImSubClampOverflow(*(const ImS8*)arg1,  *(const ImS8*)arg2,  IM_S8_MIN,  IM_S8_MAX); }
    %%%%%: 2214-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2214-block 10
call    2 never executed
    #####: 2215:            return;
    %%%%%: 2215-block 12
    #####: 2216:        case ImGuiDataType_U8:
    #####: 2217:            if (op == '+') { *(ImU8*)output  = ImAddClampOverflow(*(const ImU8*)arg1,  *(const ImU8*)arg2,  IM_U8_MIN,  IM_U8_MAX); }
    %%%%%: 2217-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2217-block 14
call    2 never executed
    #####: 2218:            if (op == '-') { *(ImU8*)output  = ImSubClampOverflow(*(const ImU8*)arg1,  *(const ImU8*)arg2,  IM_U8_MIN,  IM_U8_MAX); }
    %%%%%: 2218-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2218-block 17
call    2 never executed
    #####: 2219:            return;
    %%%%%: 2219-block 19
    #####: 2220:        case ImGuiDataType_S16:
    #####: 2221:            if (op == '+') { *(ImS16*)output = ImAddClampOverflow(*(const ImS16*)arg1, *(const ImS16*)arg2, IM_S16_MIN, IM_S16_MAX); }
    %%%%%: 2221-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2221-block 21
call    2 never executed
    #####: 2222:            if (op == '-') { *(ImS16*)output = ImSubClampOverflow(*(const ImS16*)arg1, *(const ImS16*)arg2, IM_S16_MIN, IM_S16_MAX); }
    %%%%%: 2222-block 23
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2222-block 24
call    2 never executed
    #####: 2223:            return;
    %%%%%: 2223-block 26
    #####: 2224:        case ImGuiDataType_U16:
    #####: 2225:            if (op == '+') { *(ImU16*)output = ImAddClampOverflow(*(const ImU16*)arg1, *(const ImU16*)arg2, IM_U16_MIN, IM_U16_MAX); }
    %%%%%: 2225-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2225-block 28
call    2 never executed
    #####: 2226:            if (op == '-') { *(ImU16*)output = ImSubClampOverflow(*(const ImU16*)arg1, *(const ImU16*)arg2, IM_U16_MIN, IM_U16_MAX); }
    %%%%%: 2226-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2226-block 31
call    2 never executed
    #####: 2227:            return;
    %%%%%: 2227-block 33
    #####: 2228:        case ImGuiDataType_S32:
    #####: 2229:            if (op == '+') { *(ImS32*)output = ImAddClampOverflow(*(const ImS32*)arg1, *(const ImS32*)arg2, IM_S32_MIN, IM_S32_MAX); }
    %%%%%: 2229-block 34
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2229-block 35
call    2 never executed
    #####: 2230:            if (op == '-') { *(ImS32*)output = ImSubClampOverflow(*(const ImS32*)arg1, *(const ImS32*)arg2, IM_S32_MIN, IM_S32_MAX); }
    %%%%%: 2230-block 37
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2230-block 38
call    2 never executed
    #####: 2231:            return;
    %%%%%: 2231-block 40
    #####: 2232:        case ImGuiDataType_U32:
    #####: 2233:            if (op == '+') { *(ImU32*)output = ImAddClampOverflow(*(const ImU32*)arg1, *(const ImU32*)arg2, IM_U32_MIN, IM_U32_MAX); }
    %%%%%: 2233-block 41
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2233-block 42
call    2 never executed
    #####: 2234:            if (op == '-') { *(ImU32*)output = ImSubClampOverflow(*(const ImU32*)arg1, *(const ImU32*)arg2, IM_U32_MIN, IM_U32_MAX); }
    %%%%%: 2234-block 44
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2234-block 45
call    2 never executed
    #####: 2235:            return;
    %%%%%: 2235-block 47
    #####: 2236:        case ImGuiDataType_S64:
    #####: 2237:            if (op == '+') { *(ImS64*)output = ImAddClampOverflow(*(const ImS64*)arg1, *(const ImS64*)arg2, IM_S64_MIN, IM_S64_MAX); }
    %%%%%: 2237-block 48
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2237-block 49
call    2 never executed
    #####: 2238:            if (op == '-') { *(ImS64*)output = ImSubClampOverflow(*(const ImS64*)arg1, *(const ImS64*)arg2, IM_S64_MIN, IM_S64_MAX); }
    %%%%%: 2238-block 51
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2238-block 52
call    2 never executed
    #####: 2239:            return;
    %%%%%: 2239-block 54
    #####: 2240:        case ImGuiDataType_U64:
    #####: 2241:            if (op == '+') { *(ImU64*)output = ImAddClampOverflow(*(const ImU64*)arg1, *(const ImU64*)arg2, IM_U64_MIN, IM_U64_MAX); }
    %%%%%: 2241-block 55
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2241-block 56
call    2 never executed
    #####: 2242:            if (op == '-') { *(ImU64*)output = ImSubClampOverflow(*(const ImU64*)arg1, *(const ImU64*)arg2, IM_U64_MIN, IM_U64_MAX); }
    %%%%%: 2242-block 58
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2242-block 59
call    2 never executed
    #####: 2243:            return;
    %%%%%: 2243-block 61
    #####: 2244:        case ImGuiDataType_Float:
    #####: 2245:            if (op == '+') { *(float*)output = *(const float*)arg1 + *(const float*)arg2; }
    %%%%%: 2245-block 62
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2245-block 63
    #####: 2246:            if (op == '-') { *(float*)output = *(const float*)arg1 - *(const float*)arg2; }
    %%%%%: 2246-block 64
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2246-block 65
    #####: 2247:            return;
    %%%%%: 2247-block 66
    #####: 2248:        case ImGuiDataType_Double:
    #####: 2249:            if (op == '+') { *(double*)output = *(const double*)arg1 + *(const double*)arg2; }
    %%%%%: 2249-block 67
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2249-block 68
    #####: 2250:            if (op == '-') { *(double*)output = *(const double*)arg1 - *(const double*)arg2; }
    %%%%%: 2250-block 69
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2250-block 70
    #####: 2251:            return;
    %%%%%: 2251-block 71
    #####: 2252:        case ImGuiDataType_COUNT: break;
    %%%%%: 2252-block 72
        -: 2253:    }
    #####: 2254:    IM_ASSERT(0);
    %%%%%: 2254-block 73
call    0 never executed
        -: 2255:}
        -: 2256:
        -: 2257:// User can input math operators (e.g. +100) to edit a numerical values.
        -: 2258:// NB: This is _not_ a full expression evaluator. We should probably add one and replace this dumb mess..
function _ZN5ImGui21DataTypeApplyFromTextEPKciPvS1_S2_ called 0 returned 0% blocks executed 0%
    #####: 2259:bool ImGui::DataTypeApplyFromText(const char* buf, ImGuiDataType data_type, void* p_data, const char* format, void* p_data_when_empty)
        -: 2260:{
        -: 2261:    // Copy the value in an opaque buffer so we can compare at the end of the function if it changed at all.
    #####: 2262:    const ImGuiDataTypeInfo* type_info = DataTypeGetInfo(data_type);
    %%%%%: 2262-block 2
call    0 never executed
        -: 2263:    ImGuiDataTypeStorage data_backup;
    #####: 2264:    memcpy(&data_backup, p_data, type_info->Size);
        -: 2265:
    #####: 2266:    while (ImCharIsBlankA(*buf))
    %%%%%: 2266-block 5
call    0 never executed
branch  1 never executed
branch  2 never executed (fallthrough)
    #####: 2267:        buf++;
    %%%%%: 2267-block 4
    #####: 2268:    if (!buf[0])
    %%%%%: 2268-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2269:    {
    #####: 2270:        if (p_data_when_empty != NULL)
    %%%%%: 2270-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2271:        {
    #####: 2272:            memcpy(p_data, p_data_when_empty, type_info->Size);
    #####: 2273:            return memcmp(&data_backup, p_data, type_info->Size) != 0;
    %%%%%: 2273-block 9
        -: 2274:        }
    #####: 2275:        return false;
    %%%%%: 2275-block 10
        -: 2276:    }
        -: 2277:
        -: 2278:    // Sanitize format
        -: 2279:    // - For float/double we have to ignore format with precision (e.g. "%.2f") because sscanf doesn't take them in, so force them into %f and %lf
        -: 2280:    // - In theory could treat empty format as using default, but this would only cover rare/bizarre case of using InputScalar() + integer + format string without %.
        -: 2281:    char format_sanitized[32];
    #####: 2282:    if (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double)
    %%%%%: 2282-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2282-block 12
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2283:        format = type_info->ScanFmt;
    %%%%%: 2283-block 13
        -: 2284:    else
    #####: 2285:        format = ImParseFormatSanitizeForScanning(format, format_sanitized, IM_ARRAYSIZE(format_sanitized));
    %%%%%: 2285-block 14
call    0 never executed
        -: 2286:
        -: 2287:    // Small types need a 32-bit buffer to receive the result from scanf()
    #####: 2288:    int v32 = 0;
    #####: 2289:    if (sscanf(buf, format, type_info->Size >= 4 ? p_data : &v32) < 1)
    %%%%%: 2289-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2289-block 16
    %%%%%: 2289-block 17
    %%%%%: 2289-block 18
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2290:        return false;
    %%%%%: 2290-block 19
    #####: 2291:    if (type_info->Size < 4)
    %%%%%: 2291-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2292:    {
    #####: 2293:        if (data_type == ImGuiDataType_S8)
    %%%%%: 2293-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2294:            *(ImS8*)p_data = (ImS8)ImClamp(v32, (int)IM_S8_MIN, (int)IM_S8_MAX);
    %%%%%: 2294-block 22
call    0 never executed
    #####: 2295:        else if (data_type == ImGuiDataType_U8)
    %%%%%: 2295-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2296:            *(ImU8*)p_data = (ImU8)ImClamp(v32, (int)IM_U8_MIN, (int)IM_U8_MAX);
    %%%%%: 2296-block 25
call    0 never executed
    #####: 2297:        else if (data_type == ImGuiDataType_S16)
    %%%%%: 2297-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2298:            *(ImS16*)p_data = (ImS16)ImClamp(v32, (int)IM_S16_MIN, (int)IM_S16_MAX);
    %%%%%: 2298-block 28
call    0 never executed
    #####: 2299:        else if (data_type == ImGuiDataType_U16)
    %%%%%: 2299-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2300:            *(ImU16*)p_data = (ImU16)ImClamp(v32, (int)IM_U16_MIN, (int)IM_U16_MAX);
    %%%%%: 2300-block 31
call    0 never executed
        -: 2301:        else
    #####: 2302:            IM_ASSERT(0);
    %%%%%: 2302-block 33
call    0 never executed
        -: 2303:    }
        -: 2304:
    #####: 2305:    return memcmp(&data_backup, p_data, type_info->Size) != 0;
    %%%%%: 2305-block 34
        -: 2306:}
        -: 2307:
        -: 2308:template<typename T>
    #####: 2309:static int DataTypeCompareT(const T* lhs, const T* rhs)
        -: 2310:{
    #####: 2311:    if (*lhs < *rhs) return -1;
    #####: 2312:    if (*lhs > *rhs) return +1;
    #####: 2313:    return 0;
        -: 2314:}
------------------
_Z16DataTypeCompareTIdEiPKT_S2_:
function _Z16DataTypeCompareTIdEiPKT_S2_ called 0 returned 0% blocks executed 0%
    #####: 2309:static int DataTypeCompareT(const T* lhs, const T* rhs)
        -: 2310:{
    #####: 2311:    if (*lhs < *rhs) return -1;
    %%%%%: 2311-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2311-block 3
    #####: 2312:    if (*lhs > *rhs) return +1;
    %%%%%: 2312-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2312-block 5
    #####: 2313:    return 0;
    %%%%%: 2313-block 6
        -: 2314:}
------------------
_Z16DataTypeCompareTIfEiPKT_S2_:
function _Z16DataTypeCompareTIfEiPKT_S2_ called 0 returned 0% blocks executed 0%
    #####: 2309:static int DataTypeCompareT(const T* lhs, const T* rhs)
        -: 2310:{
    #####: 2311:    if (*lhs < *rhs) return -1;
    %%%%%: 2311-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2311-block 3
    #####: 2312:    if (*lhs > *rhs) return +1;
    %%%%%: 2312-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2312-block 5
    #####: 2313:    return 0;
    %%%%%: 2313-block 6
        -: 2314:}
------------------
_Z16DataTypeCompareTIyEiPKT_S2_:
function _Z16DataTypeCompareTIyEiPKT_S2_ called 0 returned 0% blocks executed 0%
    #####: 2309:static int DataTypeCompareT(const T* lhs, const T* rhs)
        -: 2310:{
    #####: 2311:    if (*lhs < *rhs) return -1;
    %%%%%: 2311-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2311-block 3
    #####: 2312:    if (*lhs > *rhs) return +1;
    %%%%%: 2312-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2312-block 5
    #####: 2313:    return 0;
    %%%%%: 2313-block 6
        -: 2314:}
------------------
_Z16DataTypeCompareTIxEiPKT_S2_:
function _Z16DataTypeCompareTIxEiPKT_S2_ called 0 returned 0% blocks executed 0%
    #####: 2309:static int DataTypeCompareT(const T* lhs, const T* rhs)
        -: 2310:{
    #####: 2311:    if (*lhs < *rhs) return -1;
    %%%%%: 2311-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2311-block 3
    #####: 2312:    if (*lhs > *rhs) return +1;
    %%%%%: 2312-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2312-block 5
    #####: 2313:    return 0;
    %%%%%: 2313-block 6
        -: 2314:}
------------------
_Z16DataTypeCompareTIjEiPKT_S2_:
function _Z16DataTypeCompareTIjEiPKT_S2_ called 0 returned 0% blocks executed 0%
    #####: 2309:static int DataTypeCompareT(const T* lhs, const T* rhs)
        -: 2310:{
    #####: 2311:    if (*lhs < *rhs) return -1;
    %%%%%: 2311-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2311-block 3
    #####: 2312:    if (*lhs > *rhs) return +1;
    %%%%%: 2312-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2312-block 5
    #####: 2313:    return 0;
    %%%%%: 2313-block 6
        -: 2314:}
------------------
_Z16DataTypeCompareTIiEiPKT_S2_:
function _Z16DataTypeCompareTIiEiPKT_S2_ called 0 returned 0% blocks executed 0%
    #####: 2309:static int DataTypeCompareT(const T* lhs, const T* rhs)
        -: 2310:{
    #####: 2311:    if (*lhs < *rhs) return -1;
    %%%%%: 2311-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2311-block 3
    #####: 2312:    if (*lhs > *rhs) return +1;
    %%%%%: 2312-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2312-block 5
    #####: 2313:    return 0;
    %%%%%: 2313-block 6
        -: 2314:}
------------------
_Z16DataTypeCompareTItEiPKT_S2_:
function _Z16DataTypeCompareTItEiPKT_S2_ called 0 returned 0% blocks executed 0%
    #####: 2309:static int DataTypeCompareT(const T* lhs, const T* rhs)
        -: 2310:{
    #####: 2311:    if (*lhs < *rhs) return -1;
    %%%%%: 2311-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2311-block 3
    #####: 2312:    if (*lhs > *rhs) return +1;
    %%%%%: 2312-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2312-block 5
    #####: 2313:    return 0;
    %%%%%: 2313-block 6
        -: 2314:}
------------------
_Z16DataTypeCompareTIsEiPKT_S2_:
function _Z16DataTypeCompareTIsEiPKT_S2_ called 0 returned 0% blocks executed 0%
    #####: 2309:static int DataTypeCompareT(const T* lhs, const T* rhs)
        -: 2310:{
    #####: 2311:    if (*lhs < *rhs) return -1;
    %%%%%: 2311-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2311-block 3
    #####: 2312:    if (*lhs > *rhs) return +1;
    %%%%%: 2312-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2312-block 5
    #####: 2313:    return 0;
    %%%%%: 2313-block 6
        -: 2314:}
------------------
_Z16DataTypeCompareTIhEiPKT_S2_:
function _Z16DataTypeCompareTIhEiPKT_S2_ called 0 returned 0% blocks executed 0%
    #####: 2309:static int DataTypeCompareT(const T* lhs, const T* rhs)
        -: 2310:{
    #####: 2311:    if (*lhs < *rhs) return -1;
    %%%%%: 2311-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2311-block 3
    #####: 2312:    if (*lhs > *rhs) return +1;
    %%%%%: 2312-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2312-block 5
    #####: 2313:    return 0;
    %%%%%: 2313-block 6
        -: 2314:}
------------------
_Z16DataTypeCompareTIaEiPKT_S2_:
function _Z16DataTypeCompareTIaEiPKT_S2_ called 0 returned 0% blocks executed 0%
    #####: 2309:static int DataTypeCompareT(const T* lhs, const T* rhs)
        -: 2310:{
    #####: 2311:    if (*lhs < *rhs) return -1;
    %%%%%: 2311-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2311-block 3
    #####: 2312:    if (*lhs > *rhs) return +1;
    %%%%%: 2312-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2312-block 5
    #####: 2313:    return 0;
    %%%%%: 2313-block 6
        -: 2314:}
------------------
        -: 2315:
function _ZN5ImGui15DataTypeCompareEiPKvS1_ called 0 returned 0% blocks executed 0%
    #####: 2316:int ImGui::DataTypeCompare(ImGuiDataType data_type, const void* arg_1, const void* arg_2)
        -: 2317:{
    #####: 2318:    switch (data_type)
    %%%%%: 2318-block 2
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
        -: 2319:    {
    #####: 2320:    case ImGuiDataType_S8:     return DataTypeCompareT<ImS8  >((const ImS8*  )arg_1, (const ImS8*  )arg_2);
    %%%%%: 2320-block 3
call    0 never executed
    #####: 2321:    case ImGuiDataType_U8:     return DataTypeCompareT<ImU8  >((const ImU8*  )arg_1, (const ImU8*  )arg_2);
    %%%%%: 2321-block 4
call    0 never executed
    #####: 2322:    case ImGuiDataType_S16:    return DataTypeCompareT<ImS16 >((const ImS16* )arg_1, (const ImS16* )arg_2);
    %%%%%: 2322-block 5
call    0 never executed
    #####: 2323:    case ImGuiDataType_U16:    return DataTypeCompareT<ImU16 >((const ImU16* )arg_1, (const ImU16* )arg_2);
    %%%%%: 2323-block 6
call    0 never executed
    #####: 2324:    case ImGuiDataType_S32:    return DataTypeCompareT<ImS32 >((const ImS32* )arg_1, (const ImS32* )arg_2);
    %%%%%: 2324-block 7
call    0 never executed
    #####: 2325:    case ImGuiDataType_U32:    return DataTypeCompareT<ImU32 >((const ImU32* )arg_1, (const ImU32* )arg_2);
    %%%%%: 2325-block 8
call    0 never executed
    #####: 2326:    case ImGuiDataType_S64:    return DataTypeCompareT<ImS64 >((const ImS64* )arg_1, (const ImS64* )arg_2);
    %%%%%: 2326-block 9
call    0 never executed
    #####: 2327:    case ImGuiDataType_U64:    return DataTypeCompareT<ImU64 >((const ImU64* )arg_1, (const ImU64* )arg_2);
    %%%%%: 2327-block 10
call    0 never executed
    #####: 2328:    case ImGuiDataType_Float:  return DataTypeCompareT<float >((const float* )arg_1, (const float* )arg_2);
    %%%%%: 2328-block 11
call    0 never executed
    #####: 2329:    case ImGuiDataType_Double: return DataTypeCompareT<double>((const double*)arg_1, (const double*)arg_2);
    %%%%%: 2329-block 12
call    0 never executed
    #####: 2330:    case ImGuiDataType_COUNT:  break;
    %%%%%: 2330-block 13
        -: 2331:    }
    #####: 2332:    IM_ASSERT(0);
    %%%%%: 2332-block 14
call    0 never executed
        -: 2333:    return 0;
        -: 2334:}
        -: 2335:
        -: 2336:template<typename T>
    #####: 2337:static bool DataTypeClampT(T* v, const T* v_min, const T* v_max)
        -: 2338:{
        -: 2339:    // Clamp, both sides are optional, return true if modified
    #####: 2340:    if (v_min && *v < *v_min) { *v = *v_min; return true; }
    #####: 2341:    if (v_max && *v > *v_max) { *v = *v_max; return true; }
    #####: 2342:    return false;
        -: 2343:}
------------------
_Z14DataTypeClampTIdEbPT_PKS0_S3_:
function _Z14DataTypeClampTIdEbPT_PKS0_S3_ called 0 returned 0% blocks executed 0%
    #####: 2337:static bool DataTypeClampT(T* v, const T* v_min, const T* v_max)
        -: 2338:{
        -: 2339:    // Clamp, both sides are optional, return true if modified
    #####: 2340:    if (v_min && *v < *v_min) { *v = *v_min; return true; }
    %%%%%: 2340-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2340-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2340-block 4
    #####: 2341:    if (v_max && *v > *v_max) { *v = *v_max; return true; }
    %%%%%: 2341-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2341-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2341-block 7
    #####: 2342:    return false;
    %%%%%: 2342-block 8
        -: 2343:}
------------------
_Z14DataTypeClampTIfEbPT_PKS0_S3_:
function _Z14DataTypeClampTIfEbPT_PKS0_S3_ called 0 returned 0% blocks executed 0%
    #####: 2337:static bool DataTypeClampT(T* v, const T* v_min, const T* v_max)
        -: 2338:{
        -: 2339:    // Clamp, both sides are optional, return true if modified
    #####: 2340:    if (v_min && *v < *v_min) { *v = *v_min; return true; }
    %%%%%: 2340-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2340-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2340-block 4
    #####: 2341:    if (v_max && *v > *v_max) { *v = *v_max; return true; }
    %%%%%: 2341-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2341-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2341-block 7
    #####: 2342:    return false;
    %%%%%: 2342-block 8
        -: 2343:}
------------------
_Z14DataTypeClampTIyEbPT_PKS0_S3_:
function _Z14DataTypeClampTIyEbPT_PKS0_S3_ called 0 returned 0% blocks executed 0%
    #####: 2337:static bool DataTypeClampT(T* v, const T* v_min, const T* v_max)
        -: 2338:{
        -: 2339:    // Clamp, both sides are optional, return true if modified
    #####: 2340:    if (v_min && *v < *v_min) { *v = *v_min; return true; }
    %%%%%: 2340-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2340-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2340-block 4
    #####: 2341:    if (v_max && *v > *v_max) { *v = *v_max; return true; }
    %%%%%: 2341-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2341-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2341-block 7
    #####: 2342:    return false;
    %%%%%: 2342-block 8
        -: 2343:}
------------------
_Z14DataTypeClampTIxEbPT_PKS0_S3_:
function _Z14DataTypeClampTIxEbPT_PKS0_S3_ called 0 returned 0% blocks executed 0%
    #####: 2337:static bool DataTypeClampT(T* v, const T* v_min, const T* v_max)
        -: 2338:{
        -: 2339:    // Clamp, both sides are optional, return true if modified
    #####: 2340:    if (v_min && *v < *v_min) { *v = *v_min; return true; }
    %%%%%: 2340-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2340-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2340-block 4
    #####: 2341:    if (v_max && *v > *v_max) { *v = *v_max; return true; }
    %%%%%: 2341-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2341-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2341-block 7
    #####: 2342:    return false;
    %%%%%: 2342-block 8
        -: 2343:}
------------------
_Z14DataTypeClampTIjEbPT_PKS0_S3_:
function _Z14DataTypeClampTIjEbPT_PKS0_S3_ called 0 returned 0% blocks executed 0%
    #####: 2337:static bool DataTypeClampT(T* v, const T* v_min, const T* v_max)
        -: 2338:{
        -: 2339:    // Clamp, both sides are optional, return true if modified
    #####: 2340:    if (v_min && *v < *v_min) { *v = *v_min; return true; }
    %%%%%: 2340-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2340-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2340-block 4
    #####: 2341:    if (v_max && *v > *v_max) { *v = *v_max; return true; }
    %%%%%: 2341-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2341-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2341-block 7
    #####: 2342:    return false;
    %%%%%: 2342-block 8
        -: 2343:}
------------------
_Z14DataTypeClampTIiEbPT_PKS0_S3_:
function _Z14DataTypeClampTIiEbPT_PKS0_S3_ called 0 returned 0% blocks executed 0%
    #####: 2337:static bool DataTypeClampT(T* v, const T* v_min, const T* v_max)
        -: 2338:{
        -: 2339:    // Clamp, both sides are optional, return true if modified
    #####: 2340:    if (v_min && *v < *v_min) { *v = *v_min; return true; }
    %%%%%: 2340-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2340-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2340-block 4
    #####: 2341:    if (v_max && *v > *v_max) { *v = *v_max; return true; }
    %%%%%: 2341-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2341-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2341-block 7
    #####: 2342:    return false;
    %%%%%: 2342-block 8
        -: 2343:}
------------------
_Z14DataTypeClampTItEbPT_PKS0_S3_:
function _Z14DataTypeClampTItEbPT_PKS0_S3_ called 0 returned 0% blocks executed 0%
    #####: 2337:static bool DataTypeClampT(T* v, const T* v_min, const T* v_max)
        -: 2338:{
        -: 2339:    // Clamp, both sides are optional, return true if modified
    #####: 2340:    if (v_min && *v < *v_min) { *v = *v_min; return true; }
    %%%%%: 2340-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2340-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2340-block 4
    #####: 2341:    if (v_max && *v > *v_max) { *v = *v_max; return true; }
    %%%%%: 2341-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2341-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2341-block 7
    #####: 2342:    return false;
    %%%%%: 2342-block 8
        -: 2343:}
------------------
_Z14DataTypeClampTIsEbPT_PKS0_S3_:
function _Z14DataTypeClampTIsEbPT_PKS0_S3_ called 0 returned 0% blocks executed 0%
    #####: 2337:static bool DataTypeClampT(T* v, const T* v_min, const T* v_max)
        -: 2338:{
        -: 2339:    // Clamp, both sides are optional, return true if modified
    #####: 2340:    if (v_min && *v < *v_min) { *v = *v_min; return true; }
    %%%%%: 2340-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2340-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2340-block 4
    #####: 2341:    if (v_max && *v > *v_max) { *v = *v_max; return true; }
    %%%%%: 2341-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2341-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2341-block 7
    #####: 2342:    return false;
    %%%%%: 2342-block 8
        -: 2343:}
------------------
_Z14DataTypeClampTIhEbPT_PKS0_S3_:
function _Z14DataTypeClampTIhEbPT_PKS0_S3_ called 0 returned 0% blocks executed 0%
    #####: 2337:static bool DataTypeClampT(T* v, const T* v_min, const T* v_max)
        -: 2338:{
        -: 2339:    // Clamp, both sides are optional, return true if modified
    #####: 2340:    if (v_min && *v < *v_min) { *v = *v_min; return true; }
    %%%%%: 2340-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2340-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2340-block 4
    #####: 2341:    if (v_max && *v > *v_max) { *v = *v_max; return true; }
    %%%%%: 2341-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2341-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2341-block 7
    #####: 2342:    return false;
    %%%%%: 2342-block 8
        -: 2343:}
------------------
_Z14DataTypeClampTIaEbPT_PKS0_S3_:
function _Z14DataTypeClampTIaEbPT_PKS0_S3_ called 0 returned 0% blocks executed 0%
    #####: 2337:static bool DataTypeClampT(T* v, const T* v_min, const T* v_max)
        -: 2338:{
        -: 2339:    // Clamp, both sides are optional, return true if modified
    #####: 2340:    if (v_min && *v < *v_min) { *v = *v_min; return true; }
    %%%%%: 2340-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2340-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2340-block 4
    #####: 2341:    if (v_max && *v > *v_max) { *v = *v_max; return true; }
    %%%%%: 2341-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2341-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2341-block 7
    #####: 2342:    return false;
    %%%%%: 2342-block 8
        -: 2343:}
------------------
        -: 2344:
function _ZN5ImGui13DataTypeClampEiPvPKvS2_ called 0 returned 0% blocks executed 0%
    #####: 2345:bool ImGui::DataTypeClamp(ImGuiDataType data_type, void* p_data, const void* p_min, const void* p_max)
        -: 2346:{
    #####: 2347:    switch (data_type)
    %%%%%: 2347-block 2
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
        -: 2348:    {
    #####: 2349:    case ImGuiDataType_S8:     return DataTypeClampT<ImS8  >((ImS8*  )p_data, (const ImS8*  )p_min, (const ImS8*  )p_max);
    %%%%%: 2349-block 3
call    0 never executed
    #####: 2350:    case ImGuiDataType_U8:     return DataTypeClampT<ImU8  >((ImU8*  )p_data, (const ImU8*  )p_min, (const ImU8*  )p_max);
    %%%%%: 2350-block 4
call    0 never executed
    #####: 2351:    case ImGuiDataType_S16:    return DataTypeClampT<ImS16 >((ImS16* )p_data, (const ImS16* )p_min, (const ImS16* )p_max);
    %%%%%: 2351-block 5
call    0 never executed
    #####: 2352:    case ImGuiDataType_U16:    return DataTypeClampT<ImU16 >((ImU16* )p_data, (const ImU16* )p_min, (const ImU16* )p_max);
    %%%%%: 2352-block 6
call    0 never executed
    #####: 2353:    case ImGuiDataType_S32:    return DataTypeClampT<ImS32 >((ImS32* )p_data, (const ImS32* )p_min, (const ImS32* )p_max);
    %%%%%: 2353-block 7
call    0 never executed
    #####: 2354:    case ImGuiDataType_U32:    return DataTypeClampT<ImU32 >((ImU32* )p_data, (const ImU32* )p_min, (const ImU32* )p_max);
    %%%%%: 2354-block 8
call    0 never executed
    #####: 2355:    case ImGuiDataType_S64:    return DataTypeClampT<ImS64 >((ImS64* )p_data, (const ImS64* )p_min, (const ImS64* )p_max);
    %%%%%: 2355-block 9
call    0 never executed
    #####: 2356:    case ImGuiDataType_U64:    return DataTypeClampT<ImU64 >((ImU64* )p_data, (const ImU64* )p_min, (const ImU64* )p_max);
    %%%%%: 2356-block 10
call    0 never executed
    #####: 2357:    case ImGuiDataType_Float:  return DataTypeClampT<float >((float* )p_data, (const float* )p_min, (const float* )p_max);
    %%%%%: 2357-block 11
call    0 never executed
    #####: 2358:    case ImGuiDataType_Double: return DataTypeClampT<double>((double*)p_data, (const double*)p_min, (const double*)p_max);
    %%%%%: 2358-block 12
call    0 never executed
    #####: 2359:    case ImGuiDataType_COUNT:  break;
    %%%%%: 2359-block 13
        -: 2360:    }
    #####: 2361:    IM_ASSERT(0);
    %%%%%: 2361-block 14
call    0 never executed
        -: 2362:    return false;
        -: 2363:}
        -: 2364:
function _ZN5ImGui14DataTypeIsZeroEiPKv called 0 returned 0% blocks executed 0%
    #####: 2365:bool ImGui::DataTypeIsZero(ImGuiDataType data_type, const void* p_data)
        -: 2366:{
    #####: 2367:    ImGuiContext& g = *GImGui;
    #####: 2368:    return DataTypeCompare(data_type, p_data, &g.DataTypeZeroValue) == 0;
    %%%%%: 2368-block 2
call    0 never executed
        -: 2369:}
        -: 2370:
function _ZL32GetMinimumStepAtDecimalPrecisioni called 0 returned 0% blocks executed 0%
    #####: 2371:static float GetMinimumStepAtDecimalPrecision(int decimal_precision)
        -: 2372:{
        -: 2373:    static const float min_steps[10] = { 1.0f, 0.1f, 0.01f, 0.001f, 0.0001f, 0.00001f, 0.000001f, 0.0000001f, 0.00000001f, 0.000000001f };
    #####: 2374:    if (decimal_precision < 0)
    %%%%%: 2374-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2375:        return FLT_MIN;
    %%%%%: 2375-block 3
    #####: 2376:    return (decimal_precision < IM_ARRAYSIZE(min_steps)) ? min_steps[decimal_precision] : ImPow(10.0f, (float)-decimal_precision);
    %%%%%: 2376-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2376-block 5
    %%%%%: 2376-block 6
call    2 never executed
    %%%%%: 2376-block 7
        -: 2377:}
        -: 2378:
        -: 2379:template<typename TYPE>
    #####: 2380:TYPE ImGui::RoundScalarWithFormatT(const char* format, ImGuiDataType data_type, TYPE v)
        -: 2381:{
        -: 2382:    IM_UNUSED(data_type);
    #####: 2383:    IM_ASSERT(data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double);
    #####: 2384:    const char* fmt_start = ImParseFormatFindStart(format);
    #####: 2385:    if (fmt_start[0] != '%' || fmt_start[1] == '%') // Don't apply if the value is not visible in the format string
    #####: 2386:        return v;
        -: 2387:
        -: 2388:    // Sanitize format
        -: 2389:    char fmt_sanitized[32];
    #####: 2390:    ImParseFormatSanitizeForPrinting(fmt_start, fmt_sanitized, IM_ARRAYSIZE(fmt_sanitized));
    #####: 2391:    fmt_start = fmt_sanitized;
        -: 2392:
        -: 2393:    // Format value with our rounding, and read back
        -: 2394:    char v_str[64];
    #####: 2395:    ImFormatString(v_str, IM_ARRAYSIZE(v_str), fmt_start, v);
    #####: 2396:    const char* p = v_str;
    #####: 2397:    while (*p == ' ')
    #####: 2398:        p++;
    #####: 2399:    v = (TYPE)ImAtof(p);
        -: 2400:
    #####: 2401:    return v;
        -: 2402:}
------------------
_ZN5ImGui22RoundScalarWithFormatTIdEET_PKciS1_:
function _ZN5ImGui22RoundScalarWithFormatTIdEET_PKciS1_ called 0 returned 0% blocks executed 0%
    #####: 2380:TYPE ImGui::RoundScalarWithFormatT(const char* format, ImGuiDataType data_type, TYPE v)
        -: 2381:{
        -: 2382:    IM_UNUSED(data_type);
    #####: 2383:    IM_ASSERT(data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double);
    %%%%%: 2383-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2383-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2383-block 4
call    4 never executed
    #####: 2384:    const char* fmt_start = ImParseFormatFindStart(format);
    %%%%%: 2384-block 5
call    0 never executed
    #####: 2385:    if (fmt_start[0] != '%' || fmt_start[1] == '%') // Don't apply if the value is not visible in the format string
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2385-block 7
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2386:        return v;
    %%%%%: 2386-block 8
        -: 2387:
        -: 2388:    // Sanitize format
        -: 2389:    char fmt_sanitized[32];
    #####: 2390:    ImParseFormatSanitizeForPrinting(fmt_start, fmt_sanitized, IM_ARRAYSIZE(fmt_sanitized));
    %%%%%: 2390-block 9
call    0 never executed
    #####: 2391:    fmt_start = fmt_sanitized;
        -: 2392:
        -: 2393:    // Format value with our rounding, and read back
        -: 2394:    char v_str[64];
    #####: 2395:    ImFormatString(v_str, IM_ARRAYSIZE(v_str), fmt_start, v);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 2396:    const char* p = v_str;
    #####: 2397:    while (*p == ' ')
    %%%%%: 2397-block 11
    %%%%%: 2397-block 13
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2398:        p++;
    %%%%%: 2398-block 12
    #####: 2399:    v = (TYPE)ImAtof(p);
        -: 2400:
    #####: 2401:    return v;
    %%%%%: 2401-block 14
        -: 2402:}
------------------
_ZN5ImGui22RoundScalarWithFormatTIfEET_PKciS1_:
function _ZN5ImGui22RoundScalarWithFormatTIfEET_PKciS1_ called 0 returned 0% blocks executed 0%
    #####: 2380:TYPE ImGui::RoundScalarWithFormatT(const char* format, ImGuiDataType data_type, TYPE v)
        -: 2381:{
        -: 2382:    IM_UNUSED(data_type);
    #####: 2383:    IM_ASSERT(data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double);
    %%%%%: 2383-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2383-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2383-block 4
call    4 never executed
    #####: 2384:    const char* fmt_start = ImParseFormatFindStart(format);
    %%%%%: 2384-block 5
call    0 never executed
    #####: 2385:    if (fmt_start[0] != '%' || fmt_start[1] == '%') // Don't apply if the value is not visible in the format string
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2385-block 7
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2386:        return v;
    %%%%%: 2386-block 8
        -: 2387:
        -: 2388:    // Sanitize format
        -: 2389:    char fmt_sanitized[32];
    #####: 2390:    ImParseFormatSanitizeForPrinting(fmt_start, fmt_sanitized, IM_ARRAYSIZE(fmt_sanitized));
    %%%%%: 2390-block 9
call    0 never executed
    #####: 2391:    fmt_start = fmt_sanitized;
        -: 2392:
        -: 2393:    // Format value with our rounding, and read back
        -: 2394:    char v_str[64];
    #####: 2395:    ImFormatString(v_str, IM_ARRAYSIZE(v_str), fmt_start, v);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 2396:    const char* p = v_str;
    #####: 2397:    while (*p == ' ')
    %%%%%: 2397-block 11
    %%%%%: 2397-block 13
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2398:        p++;
    %%%%%: 2398-block 12
    #####: 2399:    v = (TYPE)ImAtof(p);
        -: 2400:
    #####: 2401:    return v;
    %%%%%: 2401-block 14
        -: 2402:}
------------------
_ZN5ImGui22RoundScalarWithFormatTIyEET_PKciS1_:
function _ZN5ImGui22RoundScalarWithFormatTIyEET_PKciS1_ called 0 returned 0% blocks executed 0%
    #####: 2380:TYPE ImGui::RoundScalarWithFormatT(const char* format, ImGuiDataType data_type, TYPE v)
        -: 2381:{
        -: 2382:    IM_UNUSED(data_type);
    #####: 2383:    IM_ASSERT(data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double);
    %%%%%: 2383-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2383-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2383-block 4
call    4 never executed
    #####: 2384:    const char* fmt_start = ImParseFormatFindStart(format);
    %%%%%: 2384-block 5
call    0 never executed
    #####: 2385:    if (fmt_start[0] != '%' || fmt_start[1] == '%') // Don't apply if the value is not visible in the format string
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2385-block 7
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2386:        return v;
    %%%%%: 2386-block 8
        -: 2387:
        -: 2388:    // Sanitize format
        -: 2389:    char fmt_sanitized[32];
    #####: 2390:    ImParseFormatSanitizeForPrinting(fmt_start, fmt_sanitized, IM_ARRAYSIZE(fmt_sanitized));
    %%%%%: 2390-block 9
call    0 never executed
    #####: 2391:    fmt_start = fmt_sanitized;
        -: 2392:
        -: 2393:    // Format value with our rounding, and read back
        -: 2394:    char v_str[64];
    #####: 2395:    ImFormatString(v_str, IM_ARRAYSIZE(v_str), fmt_start, v);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 2396:    const char* p = v_str;
    #####: 2397:    while (*p == ' ')
    %%%%%: 2397-block 11
    %%%%%: 2397-block 13
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2398:        p++;
    %%%%%: 2398-block 12
    #####: 2399:    v = (TYPE)ImAtof(p);
        -: 2400:
    #####: 2401:    return v;
    %%%%%: 2401-block 14
        -: 2402:}
------------------
_ZN5ImGui22RoundScalarWithFormatTIxEET_PKciS1_:
function _ZN5ImGui22RoundScalarWithFormatTIxEET_PKciS1_ called 0 returned 0% blocks executed 0%
    #####: 2380:TYPE ImGui::RoundScalarWithFormatT(const char* format, ImGuiDataType data_type, TYPE v)
        -: 2381:{
        -: 2382:    IM_UNUSED(data_type);
    #####: 2383:    IM_ASSERT(data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double);
    %%%%%: 2383-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2383-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2383-block 4
call    4 never executed
    #####: 2384:    const char* fmt_start = ImParseFormatFindStart(format);
    %%%%%: 2384-block 5
call    0 never executed
    #####: 2385:    if (fmt_start[0] != '%' || fmt_start[1] == '%') // Don't apply if the value is not visible in the format string
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2385-block 7
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2386:        return v;
    %%%%%: 2386-block 8
        -: 2387:
        -: 2388:    // Sanitize format
        -: 2389:    char fmt_sanitized[32];
    #####: 2390:    ImParseFormatSanitizeForPrinting(fmt_start, fmt_sanitized, IM_ARRAYSIZE(fmt_sanitized));
    %%%%%: 2390-block 9
call    0 never executed
    #####: 2391:    fmt_start = fmt_sanitized;
        -: 2392:
        -: 2393:    // Format value with our rounding, and read back
        -: 2394:    char v_str[64];
    #####: 2395:    ImFormatString(v_str, IM_ARRAYSIZE(v_str), fmt_start, v);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 2396:    const char* p = v_str;
    #####: 2397:    while (*p == ' ')
    %%%%%: 2397-block 11
    %%%%%: 2397-block 13
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2398:        p++;
    %%%%%: 2398-block 12
    #####: 2399:    v = (TYPE)ImAtof(p);
        -: 2400:
    #####: 2401:    return v;
    %%%%%: 2401-block 14
        -: 2402:}
------------------
_ZN5ImGui22RoundScalarWithFormatTIjEET_PKciS1_:
function _ZN5ImGui22RoundScalarWithFormatTIjEET_PKciS1_ called 0 returned 0% blocks executed 0%
    #####: 2380:TYPE ImGui::RoundScalarWithFormatT(const char* format, ImGuiDataType data_type, TYPE v)
        -: 2381:{
        -: 2382:    IM_UNUSED(data_type);
    #####: 2383:    IM_ASSERT(data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double);
    %%%%%: 2383-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2383-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2383-block 4
call    4 never executed
    #####: 2384:    const char* fmt_start = ImParseFormatFindStart(format);
    %%%%%: 2384-block 5
call    0 never executed
    #####: 2385:    if (fmt_start[0] != '%' || fmt_start[1] == '%') // Don't apply if the value is not visible in the format string
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2385-block 7
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2386:        return v;
    %%%%%: 2386-block 8
        -: 2387:
        -: 2388:    // Sanitize format
        -: 2389:    char fmt_sanitized[32];
    #####: 2390:    ImParseFormatSanitizeForPrinting(fmt_start, fmt_sanitized, IM_ARRAYSIZE(fmt_sanitized));
    %%%%%: 2390-block 9
call    0 never executed
    #####: 2391:    fmt_start = fmt_sanitized;
        -: 2392:
        -: 2393:    // Format value with our rounding, and read back
        -: 2394:    char v_str[64];
    #####: 2395:    ImFormatString(v_str, IM_ARRAYSIZE(v_str), fmt_start, v);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 2396:    const char* p = v_str;
    #####: 2397:    while (*p == ' ')
    %%%%%: 2397-block 11
    %%%%%: 2397-block 13
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2398:        p++;
    %%%%%: 2398-block 12
    #####: 2399:    v = (TYPE)ImAtof(p);
        -: 2400:
    #####: 2401:    return v;
    %%%%%: 2401-block 14
        -: 2402:}
------------------
_ZN5ImGui22RoundScalarWithFormatTIiEET_PKciS1_:
function _ZN5ImGui22RoundScalarWithFormatTIiEET_PKciS1_ called 0 returned 0% blocks executed 0%
    #####: 2380:TYPE ImGui::RoundScalarWithFormatT(const char* format, ImGuiDataType data_type, TYPE v)
        -: 2381:{
        -: 2382:    IM_UNUSED(data_type);
    #####: 2383:    IM_ASSERT(data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double);
    %%%%%: 2383-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2383-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2383-block 4
call    4 never executed
    #####: 2384:    const char* fmt_start = ImParseFormatFindStart(format);
    %%%%%: 2384-block 5
call    0 never executed
    #####: 2385:    if (fmt_start[0] != '%' || fmt_start[1] == '%') // Don't apply if the value is not visible in the format string
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2385-block 7
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2386:        return v;
    %%%%%: 2386-block 8
        -: 2387:
        -: 2388:    // Sanitize format
        -: 2389:    char fmt_sanitized[32];
    #####: 2390:    ImParseFormatSanitizeForPrinting(fmt_start, fmt_sanitized, IM_ARRAYSIZE(fmt_sanitized));
    %%%%%: 2390-block 9
call    0 never executed
    #####: 2391:    fmt_start = fmt_sanitized;
        -: 2392:
        -: 2393:    // Format value with our rounding, and read back
        -: 2394:    char v_str[64];
    #####: 2395:    ImFormatString(v_str, IM_ARRAYSIZE(v_str), fmt_start, v);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 2396:    const char* p = v_str;
    #####: 2397:    while (*p == ' ')
    %%%%%: 2397-block 11
    %%%%%: 2397-block 13
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2398:        p++;
    %%%%%: 2398-block 12
    #####: 2399:    v = (TYPE)ImAtof(p);
        -: 2400:
    #####: 2401:    return v;
    %%%%%: 2401-block 14
        -: 2402:}
------------------
        -: 2403:
        -: 2404://-------------------------------------------------------------------------
        -: 2405:// [SECTION] Widgets: DragScalar, DragFloat, DragInt, etc.
        -: 2406://-------------------------------------------------------------------------
        -: 2407:// - DragBehaviorT<>() [Internal]
        -: 2408:// - DragBehavior() [Internal]
        -: 2409:// - DragScalar()
        -: 2410:// - DragScalarN()
        -: 2411:// - DragFloat()
        -: 2412:// - DragFloat2()
        -: 2413:// - DragFloat3()
        -: 2414:// - DragFloat4()
        -: 2415:// - DragFloatRange2()
        -: 2416:// - DragInt()
        -: 2417:// - DragInt2()
        -: 2418:// - DragInt3()
        -: 2419:// - DragInt4()
        -: 2420:// - DragIntRange2()
        -: 2421://-------------------------------------------------------------------------
        -: 2422:
        -: 2423:// This is called by DragBehavior() when the widget is active (held by mouse or being manipulated with Nav controls)
        -: 2424:template<typename TYPE, typename SIGNEDTYPE, typename FLOATTYPE>
    #####: 2425:bool ImGui::DragBehaviorT(ImGuiDataType data_type, TYPE* v, float v_speed, const TYPE v_min, const TYPE v_max, const char* format, ImGuiSliderFlags flags)
        -: 2426:{
    #####: 2427:    ImGuiContext& g = *GImGui;
    #####: 2428:    const ImGuiAxis axis = (flags & ImGuiSliderFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;
    #####: 2429:    const bool is_bounded = (v_min < v_max) || ((v_min == v_max) && (v_min != 0.0f || (flags & ImGuiSliderFlags_ClampZeroRange)));
    #####: 2430:    const bool is_wrapped = is_bounded && (flags & ImGuiSliderFlags_WrapAround);
    #####: 2431:    const bool is_logarithmic = (flags & ImGuiSliderFlags_Logarithmic) != 0;
    #####: 2432:    const bool is_floating_point = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);
        -: 2433:
        -: 2434:    // Default tweak speed
    #####: 2435:    if (v_speed == 0.0f && is_bounded && (v_max - v_min < FLT_MAX))
    #####: 2436:        v_speed = (float)((v_max - v_min) * g.DragSpeedDefaultRatio);
        -: 2437:
        -: 2438:    // Inputs accumulates into g.DragCurrentAccum, which is flushed into the current value as soon as it makes a difference with our precision settings
    #####: 2439:    float adjust_delta = 0.0f;
    #####: 2440:    if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && IsMouseDragPastThreshold(0, g.IO.MouseDragThreshold * DRAG_MOUSE_THRESHOLD_FACTOR))
        -: 2441:    {
    #####: 2442:        adjust_delta = g.IO.MouseDelta[axis];
    #####: 2443:        if (g.IO.KeyAlt)
    #####: 2444:            adjust_delta *= 1.0f / 100.0f;
    #####: 2445:        if (g.IO.KeyShift)
    #####: 2446:            adjust_delta *= 10.0f;
        -: 2447:    }
    #####: 2448:    else if (g.ActiveIdSource == ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource_Gamepad)
        -: 2449:    {
    #####: 2450:        const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 0;
    #####: 2451:        const bool tweak_slow = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakSlow : ImGuiKey_NavKeyboardTweakSlow);
    #####: 2452:        const bool tweak_fast = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakFast : ImGuiKey_NavKeyboardTweakFast);
    #####: 2453:        const float tweak_factor = tweak_slow ? 1.0f / 10.0f : tweak_fast ? 10.0f : 1.0f;
    #####: 2454:        adjust_delta = GetNavTweakPressedAmount(axis) * tweak_factor;
    #####: 2455:        v_speed = ImMax(v_speed, GetMinimumStepAtDecimalPrecision(decimal_precision));
        -: 2456:    }
    #####: 2457:    adjust_delta *= v_speed;
        -: 2458:
        -: 2459:    // For vertical drag we currently assume that Up=higher value (like we do with vertical sliders). This may become a parameter.
    #####: 2460:    if (axis == ImGuiAxis_Y)
    #####: 2461:        adjust_delta = -adjust_delta;
        -: 2462:
        -: 2463:    // For logarithmic use our range is effectively 0..1 so scale the delta into that range
    #####: 2464:    if (is_logarithmic && (v_max - v_min < FLT_MAX) && ((v_max - v_min) > 0.000001f)) // Epsilon to avoid /0
    #####: 2465:        adjust_delta /= (float)(v_max - v_min);
        -: 2466:
        -: 2467:    // Clear current value on activation
        -: 2468:    // Avoid altering values and clamping when we are _already_ past the limits and heading in the same direction, so e.g. if range is 0..255, current value is 300 and we are pushing to the right side, keep the 300.
    #####: 2469:    const bool is_just_activated = g.ActiveIdIsJustActivated;
    #####: 2470:    const bool is_already_past_limits_and_pushing_outward = is_bounded && !is_wrapped && ((*v >= v_max && adjust_delta > 0.0f) || (*v <= v_min && adjust_delta < 0.0f));
    #####: 2471:    if (is_just_activated || is_already_past_limits_and_pushing_outward)
        -: 2472:    {
    #####: 2473:        g.DragCurrentAccum = 0.0f;
    #####: 2474:        g.DragCurrentAccumDirty = false;
        -: 2475:    }
    #####: 2476:    else if (adjust_delta != 0.0f)
        -: 2477:    {
    #####: 2478:        g.DragCurrentAccum += adjust_delta;
    #####: 2479:        g.DragCurrentAccumDirty = true;
        -: 2480:    }
        -: 2481:
    #####: 2482:    if (!g.DragCurrentAccumDirty)
    #####: 2483:        return false;
        -: 2484:
    #####: 2485:    TYPE v_cur = *v;
    #####: 2486:    FLOATTYPE v_old_ref_for_accum_remainder = (FLOATTYPE)0.0f;
        -: 2487:
    #####: 2488:    float logarithmic_zero_epsilon = 0.0f; // Only valid when is_logarithmic is true
    #####: 2489:    const float zero_deadzone_halfsize = 0.0f; // Drag widgets have no deadzone (as it doesn't make sense)
    #####: 2490:    if (is_logarithmic)
        -: 2491:    {
        -: 2492:        // When using logarithmic sliders, we need to clamp to avoid hitting zero, but our choice of clamp value greatly affects slider precision. We attempt to use the specified precision to estimate a good lower bound.
    #####: 2493:        const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 1;
    #####: 2494:        logarithmic_zero_epsilon = ImPow(0.1f, (float)decimal_precision);
        -: 2495:
        -: 2496:        // Convert to parametric space, apply delta, convert back
    #####: 2497:        float v_old_parametric = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_cur, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
    #####: 2498:        float v_new_parametric = v_old_parametric + g.DragCurrentAccum;
    #####: 2499:        v_cur = ScaleValueFromRatioT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_new_parametric, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
    #####: 2500:        v_old_ref_for_accum_remainder = v_old_parametric;
        -: 2501:    }
        -: 2502:    else
        -: 2503:    {
    #####: 2504:        v_cur += (SIGNEDTYPE)g.DragCurrentAccum;
        -: 2505:    }
        -: 2506:
        -: 2507:    // Round to user desired precision based on format string
    #####: 2508:    if (is_floating_point && !(flags & ImGuiSliderFlags_NoRoundToFormat))
    #####: 2509:        v_cur = RoundScalarWithFormatT<TYPE>(format, data_type, v_cur);
        -: 2510:
        -: 2511:    // Preserve remainder after rounding has been applied. This also allow slow tweaking of values.
    #####: 2512:    g.DragCurrentAccumDirty = false;
    #####: 2513:    if (is_logarithmic)
        -: 2514:    {
        -: 2515:        // Convert to parametric space, apply delta, convert back
    #####: 2516:        float v_new_parametric = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_cur, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
    #####: 2517:        g.DragCurrentAccum -= (float)(v_new_parametric - v_old_ref_for_accum_remainder);
        -: 2518:    }
        -: 2519:    else
        -: 2520:    {
    #####: 2521:        g.DragCurrentAccum -= (float)((SIGNEDTYPE)v_cur - (SIGNEDTYPE)*v);
        -: 2522:    }
        -: 2523:
        -: 2524:    // Lose zero sign for float/double
    #####: 2525:    if (v_cur == (TYPE)-0)
    #####: 2526:        v_cur = (TYPE)0;
        -: 2527:
    #####: 2528:    if (*v != v_cur && is_bounded)
        -: 2529:    {
    #####: 2530:        if (is_wrapped)
        -: 2531:        {
        -: 2532:            // Wrap values
    #####: 2533:            if (v_cur < v_min)
    #####: 2534:                v_cur += v_max - v_min + (is_floating_point ? 0 : 1);
    #####: 2535:            if (v_cur > v_max)
    #####: 2536:                v_cur -= v_max - v_min + (is_floating_point ? 0 : 1);
        -: 2537:        }
        -: 2538:        else
        -: 2539:        {
        -: 2540:            // Clamp values + handle overflow/wrap-around for integer types.
    #####: 2541:            if (v_cur < v_min || (v_cur > *v && adjust_delta < 0.0f && !is_floating_point))
    #####: 2542:                v_cur = v_min;
    #####: 2543:            if (v_cur > v_max || (v_cur < *v && adjust_delta > 0.0f && !is_floating_point))
    #####: 2544:                v_cur = v_max;
        -: 2545:        }
        -: 2546:    }
        -: 2547:
        -: 2548:    // Apply result
    #####: 2549:    if (*v == v_cur)
    #####: 2550:        return false;
    #####: 2551:    *v = v_cur;
    #####: 2552:    return true;
        -: 2553:}
------------------
_ZN5ImGui13DragBehaviorTIdddEEbiPT_fS1_S1_PKci:
function _ZN5ImGui13DragBehaviorTIdddEEbiPT_fS1_S1_PKci called 0 returned 0% blocks executed 0%
    #####: 2425:bool ImGui::DragBehaviorT(ImGuiDataType data_type, TYPE* v, float v_speed, const TYPE v_min, const TYPE v_max, const char* format, ImGuiSliderFlags flags)
        -: 2426:{
    #####: 2427:    ImGuiContext& g = *GImGui;
    #####: 2428:    const ImGuiAxis axis = (flags & ImGuiSliderFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;
    #####: 2429:    const bool is_bounded = (v_min < v_max) || ((v_min == v_max) && (v_min != 0.0f || (flags & ImGuiSliderFlags_ClampZeroRange)));
    %%%%%: 2429-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2429-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2429-block 4
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 2429-block 5
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 2429-block 6
    %%%%%: 2429-block 7
    #####: 2430:    const bool is_wrapped = is_bounded && (flags & ImGuiSliderFlags_WrapAround);
    %%%%%: 2430-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2430-block 9
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2430-block 10
    %%%%%: 2430-block 11
    #####: 2431:    const bool is_logarithmic = (flags & ImGuiSliderFlags_Logarithmic) != 0;
    #####: 2432:    const bool is_floating_point = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);
    %%%%%: 2432-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2432-block 13
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2432-block 14
    %%%%%: 2432-block 15
        -: 2433:
        -: 2434:    // Default tweak speed
    #####: 2435:    if (v_speed == 0.0f && is_bounded && (v_max - v_min < FLT_MAX))
    %%%%%: 2435-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2435-block 17
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2435-block 18
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 2436:        v_speed = (float)((v_max - v_min) * g.DragSpeedDefaultRatio);
    %%%%%: 2436-block 19
        -: 2437:
        -: 2438:    // Inputs accumulates into g.DragCurrentAccum, which is flushed into the current value as soon as it makes a difference with our precision settings
    #####: 2439:    float adjust_delta = 0.0f;
    #####: 2440:    if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && IsMouseDragPastThreshold(0, g.IO.MouseDragThreshold * DRAG_MOUSE_THRESHOLD_FACTOR))
    %%%%%: 2440-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2440-block 21
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 2440-block 23
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 2440-block 25
    %%%%%: 2440-block 26
    %%%%%: 2440-block 27
branch  8 never executed (fallthrough)
branch  9 never executed
        -: 2441:    {
    #####: 2442:        adjust_delta = g.IO.MouseDelta[axis];
    %%%%%: 2442-block 28
call    0 never executed
    #####: 2443:        if (g.IO.KeyAlt)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2444:            adjust_delta *= 1.0f / 100.0f;
    %%%%%: 2444-block 30
    #####: 2445:        if (g.IO.KeyShift)
    %%%%%: 2445-block 31
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2446:            adjust_delta *= 10.0f;
    %%%%%: 2446-block 32
        -: 2447:    }
    #####: 2448:    else if (g.ActiveIdSource == ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource_Gamepad)
    %%%%%: 2448-block 33
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2448-block 34
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 2449:    {
    #####: 2450:        const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 0;
    %%%%%: 2450-block 35
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2450-block 36
call    2 never executed
    %%%%%: 2450-block 38
    #####: 2451:        const bool tweak_slow = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakSlow : ImGuiKey_NavKeyboardTweakSlow);
    %%%%%: 2451-block 39
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2451-block 40
    %%%%%: 2451-block 41
    %%%%%: 2451-block 42
call    2 never executed
    #####: 2452:        const bool tweak_fast = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakFast : ImGuiKey_NavKeyboardTweakFast);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2452-block 44
    %%%%%: 2452-block 45
    %%%%%: 2452-block 46
call    2 never executed
    #####: 2453:        const float tweak_factor = tweak_slow ? 1.0f / 10.0f : tweak_fast ? 10.0f : 1.0f;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2453-block 48
    %%%%%: 2453-block 49
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2453-block 50
    %%%%%: 2453-block 51
    %%%%%: 2453-block 52
    #####: 2454:        adjust_delta = GetNavTweakPressedAmount(axis) * tweak_factor;
    %%%%%: 2454-block 53
call    0 never executed
    #####: 2455:        v_speed = ImMax(v_speed, GetMinimumStepAtDecimalPrecision(decimal_precision));
call    0 never executed
call    1 never executed
        -: 2456:    }
    #####: 2457:    adjust_delta *= v_speed;
        -: 2458:
        -: 2459:    // For vertical drag we currently assume that Up=higher value (like we do with vertical sliders). This may become a parameter.
    #####: 2460:    if (axis == ImGuiAxis_Y)
    %%%%%: 2460-block 56
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2461:        adjust_delta = -adjust_delta;
    %%%%%: 2461-block 57
        -: 2462:
        -: 2463:    // For logarithmic use our range is effectively 0..1 so scale the delta into that range
    #####: 2464:    if (is_logarithmic && (v_max - v_min < FLT_MAX) && ((v_max - v_min) > 0.000001f)) // Epsilon to avoid /0
    %%%%%: 2464-block 58
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2464-block 59
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2464-block 60
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 2465:        adjust_delta /= (float)(v_max - v_min);
    %%%%%: 2465-block 61
        -: 2466:
        -: 2467:    // Clear current value on activation
        -: 2468:    // Avoid altering values and clamping when we are _already_ past the limits and heading in the same direction, so e.g. if range is 0..255, current value is 300 and we are pushing to the right side, keep the 300.
    #####: 2469:    const bool is_just_activated = g.ActiveIdIsJustActivated;
    #####: 2470:    const bool is_already_past_limits_and_pushing_outward = is_bounded && !is_wrapped && ((*v >= v_max && adjust_delta > 0.0f) || (*v <= v_min && adjust_delta < 0.0f));
    %%%%%: 2470-block 62
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2470-block 63
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2470-block 64
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 2470-block 65
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 2470-block 66
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%: 2470-block 67
branch 10 never executed (fallthrough)
branch 11 never executed
    %%%%%: 2470-block 68
    %%%%%: 2470-block 69
    #####: 2471:    if (is_just_activated || is_already_past_limits_and_pushing_outward)
    %%%%%: 2471-block 70
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2471-block 71
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 2472:    {
    #####: 2473:        g.DragCurrentAccum = 0.0f;
    #####: 2474:        g.DragCurrentAccumDirty = false;
    %%%%%: 2474-block 72
        -: 2475:    }
    #####: 2476:    else if (adjust_delta != 0.0f)
    %%%%%: 2476-block 73
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2477:    {
    #####: 2478:        g.DragCurrentAccum += adjust_delta;
    #####: 2479:        g.DragCurrentAccumDirty = true;
    %%%%%: 2479-block 74
        -: 2480:    }
        -: 2481:
    #####: 2482:    if (!g.DragCurrentAccumDirty)
    %%%%%: 2482-block 75
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2483:        return false;
    %%%%%: 2483-block 76
        -: 2484:
    #####: 2485:    TYPE v_cur = *v;
    #####: 2486:    FLOATTYPE v_old_ref_for_accum_remainder = (FLOATTYPE)0.0f;
        -: 2487:
    #####: 2488:    float logarithmic_zero_epsilon = 0.0f; // Only valid when is_logarithmic is true
    #####: 2489:    const float zero_deadzone_halfsize = 0.0f; // Drag widgets have no deadzone (as it doesn't make sense)
    #####: 2490:    if (is_logarithmic)
    %%%%%: 2490-block 77
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2491:    {
        -: 2492:        // When using logarithmic sliders, we need to clamp to avoid hitting zero, but our choice of clamp value greatly affects slider precision. We attempt to use the specified precision to estimate a good lower bound.
    #####: 2493:        const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 1;
    %%%%%: 2493-block 78
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2493-block 79
call    2 never executed
    %%%%%: 2493-block 81
    #####: 2494:        logarithmic_zero_epsilon = ImPow(0.1f, (float)decimal_precision);
    %%%%%: 2494-block 82
call    0 never executed
        -: 2495:
        -: 2496:        // Convert to parametric space, apply delta, convert back
    #####: 2497:        float v_old_parametric = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_cur, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
call    0 never executed
    #####: 2498:        float v_new_parametric = v_old_parametric + g.DragCurrentAccum;
    #####: 2499:        v_cur = ScaleValueFromRatioT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_new_parametric, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
call    0 never executed
    #####: 2500:        v_old_ref_for_accum_remainder = v_old_parametric;
        -: 2501:    }
        -: 2502:    else
        -: 2503:    {
    #####: 2504:        v_cur += (SIGNEDTYPE)g.DragCurrentAccum;
    %%%%%: 2504-block 86
        -: 2505:    }
        -: 2506:
        -: 2507:    // Round to user desired precision based on format string
    #####: 2508:    if (is_floating_point && !(flags & ImGuiSliderFlags_NoRoundToFormat))
    %%%%%: 2508-block 87
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2508-block 88
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2509:        v_cur = RoundScalarWithFormatT<TYPE>(format, data_type, v_cur);
    %%%%%: 2509-block 89
call    0 never executed
        -: 2510:
        -: 2511:    // Preserve remainder after rounding has been applied. This also allow slow tweaking of values.
    #####: 2512:    g.DragCurrentAccumDirty = false;
    #####: 2513:    if (is_logarithmic)
    %%%%%: 2513-block 91
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2514:    {
        -: 2515:        // Convert to parametric space, apply delta, convert back
    #####: 2516:        float v_new_parametric = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_cur, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
    %%%%%: 2516-block 92
call    0 never executed
    #####: 2517:        g.DragCurrentAccum -= (float)(v_new_parametric - v_old_ref_for_accum_remainder);
        -: 2518:    }
        -: 2519:    else
        -: 2520:    {
    #####: 2521:        g.DragCurrentAccum -= (float)((SIGNEDTYPE)v_cur - (SIGNEDTYPE)*v);
    %%%%%: 2521-block 94
        -: 2522:    }
        -: 2523:
        -: 2524:    // Lose zero sign for float/double
    #####: 2525:    if (v_cur == (TYPE)-0)
    %%%%%: 2525-block 95
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2526:        v_cur = (TYPE)0;
    %%%%%: 2526-block 96
        -: 2527:
    #####: 2528:    if (*v != v_cur && is_bounded)
    %%%%%: 2528-block 97
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2528-block 98
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 2529:    {
    #####: 2530:        if (is_wrapped)
    %%%%%: 2530-block 99
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2531:        {
        -: 2532:            // Wrap values
    #####: 2533:            if (v_cur < v_min)
    %%%%%: 2533-block 100
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2534:                v_cur += v_max - v_min + (is_floating_point ? 0 : 1);
    %%%%%: 2534-block 101
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2534-block 102
    %%%%%: 2534-block 103
    %%%%%: 2534-block 104
    #####: 2535:            if (v_cur > v_max)
    %%%%%: 2535-block 105
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2536:                v_cur -= v_max - v_min + (is_floating_point ? 0 : 1);
    %%%%%: 2536-block 106
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2536-block 107
    %%%%%: 2536-block 108
    %%%%%: 2536-block 109
        -: 2537:        }
        -: 2538:        else
        -: 2539:        {
        -: 2540:            // Clamp values + handle overflow/wrap-around for integer types.
    #####: 2541:            if (v_cur < v_min || (v_cur > *v && adjust_delta < 0.0f && !is_floating_point))
    %%%%%: 2541-block 110
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2541-block 111
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2541-block 112
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 2541-block 113
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 2542:                v_cur = v_min;
    %%%%%: 2542-block 114
    #####: 2543:            if (v_cur > v_max || (v_cur < *v && adjust_delta > 0.0f && !is_floating_point))
    %%%%%: 2543-block 115
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2543-block 116
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2543-block 117
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 2543-block 118
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 2544:                v_cur = v_max;
    %%%%%: 2544-block 119
        -: 2545:        }
        -: 2546:    }
        -: 2547:
        -: 2548:    // Apply result
    #####: 2549:    if (*v == v_cur)
    %%%%%: 2549-block 120
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2550:        return false;
    %%%%%: 2550-block 121
    #####: 2551:    *v = v_cur;
    #####: 2552:    return true;
    %%%%%: 2552-block 122
        -: 2553:}
------------------
_ZN5ImGui13DragBehaviorTIfffEEbiPT_fS1_S1_PKci:
function _ZN5ImGui13DragBehaviorTIfffEEbiPT_fS1_S1_PKci called 0 returned 0% blocks executed 0%
    #####: 2425:bool ImGui::DragBehaviorT(ImGuiDataType data_type, TYPE* v, float v_speed, const TYPE v_min, const TYPE v_max, const char* format, ImGuiSliderFlags flags)
        -: 2426:{
    #####: 2427:    ImGuiContext& g = *GImGui;
    #####: 2428:    const ImGuiAxis axis = (flags & ImGuiSliderFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;
    #####: 2429:    const bool is_bounded = (v_min < v_max) || ((v_min == v_max) && (v_min != 0.0f || (flags & ImGuiSliderFlags_ClampZeroRange)));
    %%%%%: 2429-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2429-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2429-block 4
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 2429-block 5
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 2429-block 6
    %%%%%: 2429-block 7
    #####: 2430:    const bool is_wrapped = is_bounded && (flags & ImGuiSliderFlags_WrapAround);
    %%%%%: 2430-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2430-block 9
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2430-block 10
    %%%%%: 2430-block 11
    #####: 2431:    const bool is_logarithmic = (flags & ImGuiSliderFlags_Logarithmic) != 0;
    #####: 2432:    const bool is_floating_point = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);
    %%%%%: 2432-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2432-block 13
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2432-block 14
    %%%%%: 2432-block 15
        -: 2433:
        -: 2434:    // Default tweak speed
    #####: 2435:    if (v_speed == 0.0f && is_bounded && (v_max - v_min < FLT_MAX))
    %%%%%: 2435-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2435-block 17
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2435-block 18
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 2436:        v_speed = (float)((v_max - v_min) * g.DragSpeedDefaultRatio);
    %%%%%: 2436-block 19
        -: 2437:
        -: 2438:    // Inputs accumulates into g.DragCurrentAccum, which is flushed into the current value as soon as it makes a difference with our precision settings
    #####: 2439:    float adjust_delta = 0.0f;
    #####: 2440:    if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && IsMouseDragPastThreshold(0, g.IO.MouseDragThreshold * DRAG_MOUSE_THRESHOLD_FACTOR))
    %%%%%: 2440-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2440-block 21
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 2440-block 23
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 2440-block 25
    %%%%%: 2440-block 26
    %%%%%: 2440-block 27
branch  8 never executed (fallthrough)
branch  9 never executed
        -: 2441:    {
    #####: 2442:        adjust_delta = g.IO.MouseDelta[axis];
    %%%%%: 2442-block 28
call    0 never executed
    #####: 2443:        if (g.IO.KeyAlt)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2444:            adjust_delta *= 1.0f / 100.0f;
    %%%%%: 2444-block 30
    #####: 2445:        if (g.IO.KeyShift)
    %%%%%: 2445-block 31
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2446:            adjust_delta *= 10.0f;
    %%%%%: 2446-block 32
        -: 2447:    }
    #####: 2448:    else if (g.ActiveIdSource == ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource_Gamepad)
    %%%%%: 2448-block 33
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2448-block 34
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 2449:    {
    #####: 2450:        const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 0;
    %%%%%: 2450-block 35
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2450-block 36
call    2 never executed
    %%%%%: 2450-block 38
    #####: 2451:        const bool tweak_slow = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakSlow : ImGuiKey_NavKeyboardTweakSlow);
    %%%%%: 2451-block 39
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2451-block 40
    %%%%%: 2451-block 41
    %%%%%: 2451-block 42
call    2 never executed
    #####: 2452:        const bool tweak_fast = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakFast : ImGuiKey_NavKeyboardTweakFast);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2452-block 44
    %%%%%: 2452-block 45
    %%%%%: 2452-block 46
call    2 never executed
    #####: 2453:        const float tweak_factor = tweak_slow ? 1.0f / 10.0f : tweak_fast ? 10.0f : 1.0f;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2453-block 48
    %%%%%: 2453-block 49
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2453-block 50
    %%%%%: 2453-block 51
    %%%%%: 2453-block 52
    #####: 2454:        adjust_delta = GetNavTweakPressedAmount(axis) * tweak_factor;
    %%%%%: 2454-block 53
call    0 never executed
    #####: 2455:        v_speed = ImMax(v_speed, GetMinimumStepAtDecimalPrecision(decimal_precision));
call    0 never executed
call    1 never executed
        -: 2456:    }
    #####: 2457:    adjust_delta *= v_speed;
        -: 2458:
        -: 2459:    // For vertical drag we currently assume that Up=higher value (like we do with vertical sliders). This may become a parameter.
    #####: 2460:    if (axis == ImGuiAxis_Y)
    %%%%%: 2460-block 56
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2461:        adjust_delta = -adjust_delta;
    %%%%%: 2461-block 57
        -: 2462:
        -: 2463:    // For logarithmic use our range is effectively 0..1 so scale the delta into that range
    #####: 2464:    if (is_logarithmic && (v_max - v_min < FLT_MAX) && ((v_max - v_min) > 0.000001f)) // Epsilon to avoid /0
    %%%%%: 2464-block 58
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2464-block 59
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2464-block 60
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 2465:        adjust_delta /= (float)(v_max - v_min);
    %%%%%: 2465-block 61
        -: 2466:
        -: 2467:    // Clear current value on activation
        -: 2468:    // Avoid altering values and clamping when we are _already_ past the limits and heading in the same direction, so e.g. if range is 0..255, current value is 300 and we are pushing to the right side, keep the 300.
    #####: 2469:    const bool is_just_activated = g.ActiveIdIsJustActivated;
    #####: 2470:    const bool is_already_past_limits_and_pushing_outward = is_bounded && !is_wrapped && ((*v >= v_max && adjust_delta > 0.0f) || (*v <= v_min && adjust_delta < 0.0f));
    %%%%%: 2470-block 62
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2470-block 63
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2470-block 64
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 2470-block 65
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 2470-block 66
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%: 2470-block 67
branch 10 never executed (fallthrough)
branch 11 never executed
    %%%%%: 2470-block 68
    %%%%%: 2470-block 69
    #####: 2471:    if (is_just_activated || is_already_past_limits_and_pushing_outward)
    %%%%%: 2471-block 70
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2471-block 71
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 2472:    {
    #####: 2473:        g.DragCurrentAccum = 0.0f;
    #####: 2474:        g.DragCurrentAccumDirty = false;
    %%%%%: 2474-block 72
        -: 2475:    }
    #####: 2476:    else if (adjust_delta != 0.0f)
    %%%%%: 2476-block 73
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2477:    {
    #####: 2478:        g.DragCurrentAccum += adjust_delta;
    #####: 2479:        g.DragCurrentAccumDirty = true;
    %%%%%: 2479-block 74
        -: 2480:    }
        -: 2481:
    #####: 2482:    if (!g.DragCurrentAccumDirty)
    %%%%%: 2482-block 75
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2483:        return false;
    %%%%%: 2483-block 76
        -: 2484:
    #####: 2485:    TYPE v_cur = *v;
    #####: 2486:    FLOATTYPE v_old_ref_for_accum_remainder = (FLOATTYPE)0.0f;
        -: 2487:
    #####: 2488:    float logarithmic_zero_epsilon = 0.0f; // Only valid when is_logarithmic is true
    #####: 2489:    const float zero_deadzone_halfsize = 0.0f; // Drag widgets have no deadzone (as it doesn't make sense)
    #####: 2490:    if (is_logarithmic)
    %%%%%: 2490-block 77
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2491:    {
        -: 2492:        // When using logarithmic sliders, we need to clamp to avoid hitting zero, but our choice of clamp value greatly affects slider precision. We attempt to use the specified precision to estimate a good lower bound.
    #####: 2493:        const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 1;
    %%%%%: 2493-block 78
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2493-block 79
call    2 never executed
    %%%%%: 2493-block 81
    #####: 2494:        logarithmic_zero_epsilon = ImPow(0.1f, (float)decimal_precision);
    %%%%%: 2494-block 82
call    0 never executed
        -: 2495:
        -: 2496:        // Convert to parametric space, apply delta, convert back
    #####: 2497:        float v_old_parametric = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_cur, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
call    0 never executed
    #####: 2498:        float v_new_parametric = v_old_parametric + g.DragCurrentAccum;
    #####: 2499:        v_cur = ScaleValueFromRatioT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_new_parametric, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
call    0 never executed
    #####: 2500:        v_old_ref_for_accum_remainder = v_old_parametric;
        -: 2501:    }
        -: 2502:    else
        -: 2503:    {
    #####: 2504:        v_cur += (SIGNEDTYPE)g.DragCurrentAccum;
    %%%%%: 2504-block 86
        -: 2505:    }
        -: 2506:
        -: 2507:    // Round to user desired precision based on format string
    #####: 2508:    if (is_floating_point && !(flags & ImGuiSliderFlags_NoRoundToFormat))
    %%%%%: 2508-block 87
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2508-block 88
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2509:        v_cur = RoundScalarWithFormatT<TYPE>(format, data_type, v_cur);
    %%%%%: 2509-block 89
call    0 never executed
        -: 2510:
        -: 2511:    // Preserve remainder after rounding has been applied. This also allow slow tweaking of values.
    #####: 2512:    g.DragCurrentAccumDirty = false;
    #####: 2513:    if (is_logarithmic)
    %%%%%: 2513-block 91
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2514:    {
        -: 2515:        // Convert to parametric space, apply delta, convert back
    #####: 2516:        float v_new_parametric = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_cur, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
    %%%%%: 2516-block 92
call    0 never executed
    #####: 2517:        g.DragCurrentAccum -= (float)(v_new_parametric - v_old_ref_for_accum_remainder);
        -: 2518:    }
        -: 2519:    else
        -: 2520:    {
    #####: 2521:        g.DragCurrentAccum -= (float)((SIGNEDTYPE)v_cur - (SIGNEDTYPE)*v);
    %%%%%: 2521-block 94
        -: 2522:    }
        -: 2523:
        -: 2524:    // Lose zero sign for float/double
    #####: 2525:    if (v_cur == (TYPE)-0)
    %%%%%: 2525-block 95
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2526:        v_cur = (TYPE)0;
    %%%%%: 2526-block 96
        -: 2527:
    #####: 2528:    if (*v != v_cur && is_bounded)
    %%%%%: 2528-block 97
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2528-block 98
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 2529:    {
    #####: 2530:        if (is_wrapped)
    %%%%%: 2530-block 99
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2531:        {
        -: 2532:            // Wrap values
    #####: 2533:            if (v_cur < v_min)
    %%%%%: 2533-block 100
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2534:                v_cur += v_max - v_min + (is_floating_point ? 0 : 1);
    %%%%%: 2534-block 101
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2534-block 102
    %%%%%: 2534-block 103
    %%%%%: 2534-block 104
    #####: 2535:            if (v_cur > v_max)
    %%%%%: 2535-block 105
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2536:                v_cur -= v_max - v_min + (is_floating_point ? 0 : 1);
    %%%%%: 2536-block 106
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2536-block 107
    %%%%%: 2536-block 108
    %%%%%: 2536-block 109
        -: 2537:        }
        -: 2538:        else
        -: 2539:        {
        -: 2540:            // Clamp values + handle overflow/wrap-around for integer types.
    #####: 2541:            if (v_cur < v_min || (v_cur > *v && adjust_delta < 0.0f && !is_floating_point))
    %%%%%: 2541-block 110
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2541-block 111
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2541-block 112
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 2541-block 113
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 2542:                v_cur = v_min;
    %%%%%: 2542-block 114
    #####: 2543:            if (v_cur > v_max || (v_cur < *v && adjust_delta > 0.0f && !is_floating_point))
    %%%%%: 2543-block 115
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2543-block 116
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2543-block 117
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 2543-block 118
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 2544:                v_cur = v_max;
    %%%%%: 2544-block 119
        -: 2545:        }
        -: 2546:    }
        -: 2547:
        -: 2548:    // Apply result
    #####: 2549:    if (*v == v_cur)
    %%%%%: 2549-block 120
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2550:        return false;
    %%%%%: 2550-block 121
    #####: 2551:    *v = v_cur;
    #####: 2552:    return true;
    %%%%%: 2552-block 122
        -: 2553:}
------------------
_ZN5ImGui13DragBehaviorTIyxdEEbiPT_fS1_S1_PKci:
function _ZN5ImGui13DragBehaviorTIyxdEEbiPT_fS1_S1_PKci called 0 returned 0% blocks executed 0%
    #####: 2425:bool ImGui::DragBehaviorT(ImGuiDataType data_type, TYPE* v, float v_speed, const TYPE v_min, const TYPE v_max, const char* format, ImGuiSliderFlags flags)
        -: 2426:{
    #####: 2427:    ImGuiContext& g = *GImGui;
    #####: 2428:    const ImGuiAxis axis = (flags & ImGuiSliderFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;
    #####: 2429:    const bool is_bounded = (v_min < v_max) || ((v_min == v_max) && (v_min != 0.0f || (flags & ImGuiSliderFlags_ClampZeroRange)));
    %%%%%: 2429-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2429-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2429-block 4
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 2429-block 5
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 2429-block 6
    %%%%%: 2429-block 7
    #####: 2430:    const bool is_wrapped = is_bounded && (flags & ImGuiSliderFlags_WrapAround);
    %%%%%: 2430-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2430-block 9
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2430-block 10
    %%%%%: 2430-block 11
    #####: 2431:    const bool is_logarithmic = (flags & ImGuiSliderFlags_Logarithmic) != 0;
    #####: 2432:    const bool is_floating_point = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);
    %%%%%: 2432-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2432-block 13
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2432-block 14
    %%%%%: 2432-block 15
        -: 2433:
        -: 2434:    // Default tweak speed
    #####: 2435:    if (v_speed == 0.0f && is_bounded && (v_max - v_min < FLT_MAX))
    %%%%%: 2435-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2435-block 17
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2435-block 18
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 2436:        v_speed = (float)((v_max - v_min) * g.DragSpeedDefaultRatio);
    %%%%%: 2436-block 19
        -: 2437:
        -: 2438:    // Inputs accumulates into g.DragCurrentAccum, which is flushed into the current value as soon as it makes a difference with our precision settings
    #####: 2439:    float adjust_delta = 0.0f;
    #####: 2440:    if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && IsMouseDragPastThreshold(0, g.IO.MouseDragThreshold * DRAG_MOUSE_THRESHOLD_FACTOR))
    %%%%%: 2440-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2440-block 21
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 2440-block 23
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 2440-block 25
    %%%%%: 2440-block 26
    %%%%%: 2440-block 27
branch  8 never executed (fallthrough)
branch  9 never executed
        -: 2441:    {
    #####: 2442:        adjust_delta = g.IO.MouseDelta[axis];
    %%%%%: 2442-block 28
call    0 never executed
    #####: 2443:        if (g.IO.KeyAlt)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2444:            adjust_delta *= 1.0f / 100.0f;
    %%%%%: 2444-block 30
    #####: 2445:        if (g.IO.KeyShift)
    %%%%%: 2445-block 31
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2446:            adjust_delta *= 10.0f;
    %%%%%: 2446-block 32
        -: 2447:    }
    #####: 2448:    else if (g.ActiveIdSource == ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource_Gamepad)
    %%%%%: 2448-block 33
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2448-block 34
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 2449:    {
    #####: 2450:        const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 0;
    %%%%%: 2450-block 35
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2450-block 36
call    2 never executed
    %%%%%: 2450-block 38
    #####: 2451:        const bool tweak_slow = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakSlow : ImGuiKey_NavKeyboardTweakSlow);
    %%%%%: 2451-block 39
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2451-block 40
    %%%%%: 2451-block 41
    %%%%%: 2451-block 42
call    2 never executed
    #####: 2452:        const bool tweak_fast = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakFast : ImGuiKey_NavKeyboardTweakFast);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2452-block 44
    %%%%%: 2452-block 45
    %%%%%: 2452-block 46
call    2 never executed
    #####: 2453:        const float tweak_factor = tweak_slow ? 1.0f / 10.0f : tweak_fast ? 10.0f : 1.0f;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2453-block 48
    %%%%%: 2453-block 49
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2453-block 50
    %%%%%: 2453-block 51
    %%%%%: 2453-block 52
    #####: 2454:        adjust_delta = GetNavTweakPressedAmount(axis) * tweak_factor;
    %%%%%: 2454-block 53
call    0 never executed
    #####: 2455:        v_speed = ImMax(v_speed, GetMinimumStepAtDecimalPrecision(decimal_precision));
call    0 never executed
call    1 never executed
        -: 2456:    }
    #####: 2457:    adjust_delta *= v_speed;
        -: 2458:
        -: 2459:    // For vertical drag we currently assume that Up=higher value (like we do with vertical sliders). This may become a parameter.
    #####: 2460:    if (axis == ImGuiAxis_Y)
    %%%%%: 2460-block 56
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2461:        adjust_delta = -adjust_delta;
    %%%%%: 2461-block 57
        -: 2462:
        -: 2463:    // For logarithmic use our range is effectively 0..1 so scale the delta into that range
    #####: 2464:    if (is_logarithmic && (v_max - v_min < FLT_MAX) && ((v_max - v_min) > 0.000001f)) // Epsilon to avoid /0
    %%%%%: 2464-block 58
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2464-block 59
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2464-block 60
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 2465:        adjust_delta /= (float)(v_max - v_min);
    %%%%%: 2465-block 61
        -: 2466:
        -: 2467:    // Clear current value on activation
        -: 2468:    // Avoid altering values and clamping when we are _already_ past the limits and heading in the same direction, so e.g. if range is 0..255, current value is 300 and we are pushing to the right side, keep the 300.
    #####: 2469:    const bool is_just_activated = g.ActiveIdIsJustActivated;
    #####: 2470:    const bool is_already_past_limits_and_pushing_outward = is_bounded && !is_wrapped && ((*v >= v_max && adjust_delta > 0.0f) || (*v <= v_min && adjust_delta < 0.0f));
    %%%%%: 2470-block 62
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2470-block 63
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2470-block 64
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 2470-block 65
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 2470-block 66
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%: 2470-block 67
branch 10 never executed (fallthrough)
branch 11 never executed
    %%%%%: 2470-block 68
    %%%%%: 2470-block 69
    #####: 2471:    if (is_just_activated || is_already_past_limits_and_pushing_outward)
    %%%%%: 2471-block 70
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2471-block 71
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 2472:    {
    #####: 2473:        g.DragCurrentAccum = 0.0f;
    #####: 2474:        g.DragCurrentAccumDirty = false;
    %%%%%: 2474-block 72
        -: 2475:    }
    #####: 2476:    else if (adjust_delta != 0.0f)
    %%%%%: 2476-block 73
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2477:    {
    #####: 2478:        g.DragCurrentAccum += adjust_delta;
    #####: 2479:        g.DragCurrentAccumDirty = true;
    %%%%%: 2479-block 74
        -: 2480:    }
        -: 2481:
    #####: 2482:    if (!g.DragCurrentAccumDirty)
    %%%%%: 2482-block 75
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2483:        return false;
    %%%%%: 2483-block 76
        -: 2484:
    #####: 2485:    TYPE v_cur = *v;
    #####: 2486:    FLOATTYPE v_old_ref_for_accum_remainder = (FLOATTYPE)0.0f;
        -: 2487:
    #####: 2488:    float logarithmic_zero_epsilon = 0.0f; // Only valid when is_logarithmic is true
    #####: 2489:    const float zero_deadzone_halfsize = 0.0f; // Drag widgets have no deadzone (as it doesn't make sense)
    #####: 2490:    if (is_logarithmic)
    %%%%%: 2490-block 77
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2491:    {
        -: 2492:        // When using logarithmic sliders, we need to clamp to avoid hitting zero, but our choice of clamp value greatly affects slider precision. We attempt to use the specified precision to estimate a good lower bound.
    #####: 2493:        const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 1;
    %%%%%: 2493-block 78
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2493-block 79
call    2 never executed
    %%%%%: 2493-block 81
    #####: 2494:        logarithmic_zero_epsilon = ImPow(0.1f, (float)decimal_precision);
    %%%%%: 2494-block 82
call    0 never executed
        -: 2495:
        -: 2496:        // Convert to parametric space, apply delta, convert back
    #####: 2497:        float v_old_parametric = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_cur, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
call    0 never executed
    #####: 2498:        float v_new_parametric = v_old_parametric + g.DragCurrentAccum;
    #####: 2499:        v_cur = ScaleValueFromRatioT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_new_parametric, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
call    0 never executed
    #####: 2500:        v_old_ref_for_accum_remainder = v_old_parametric;
        -: 2501:    }
        -: 2502:    else
        -: 2503:    {
    #####: 2504:        v_cur += (SIGNEDTYPE)g.DragCurrentAccum;
    %%%%%: 2504-block 86
        -: 2505:    }
        -: 2506:
        -: 2507:    // Round to user desired precision based on format string
    #####: 2508:    if (is_floating_point && !(flags & ImGuiSliderFlags_NoRoundToFormat))
    %%%%%: 2508-block 87
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2508-block 88
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2509:        v_cur = RoundScalarWithFormatT<TYPE>(format, data_type, v_cur);
    %%%%%: 2509-block 89
call    0 never executed
        -: 2510:
        -: 2511:    // Preserve remainder after rounding has been applied. This also allow slow tweaking of values.
    #####: 2512:    g.DragCurrentAccumDirty = false;
    #####: 2513:    if (is_logarithmic)
    %%%%%: 2513-block 91
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2514:    {
        -: 2515:        // Convert to parametric space, apply delta, convert back
    #####: 2516:        float v_new_parametric = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_cur, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
    %%%%%: 2516-block 92
call    0 never executed
    #####: 2517:        g.DragCurrentAccum -= (float)(v_new_parametric - v_old_ref_for_accum_remainder);
        -: 2518:    }
        -: 2519:    else
        -: 2520:    {
    #####: 2521:        g.DragCurrentAccum -= (float)((SIGNEDTYPE)v_cur - (SIGNEDTYPE)*v);
    %%%%%: 2521-block 94
        -: 2522:    }
        -: 2523:
        -: 2524:    // Lose zero sign for float/double
    #####: 2525:    if (v_cur == (TYPE)-0)
    %%%%%: 2525-block 95
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2526:        v_cur = (TYPE)0;
    %%%%%: 2526-block 96
        -: 2527:
    #####: 2528:    if (*v != v_cur && is_bounded)
    %%%%%: 2528-block 97
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2528-block 98
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 2529:    {
    #####: 2530:        if (is_wrapped)
    %%%%%: 2530-block 99
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2531:        {
        -: 2532:            // Wrap values
    #####: 2533:            if (v_cur < v_min)
    %%%%%: 2533-block 100
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2534:                v_cur += v_max - v_min + (is_floating_point ? 0 : 1);
    %%%%%: 2534-block 101
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2534-block 102
    %%%%%: 2534-block 103
    %%%%%: 2534-block 104
    #####: 2535:            if (v_cur > v_max)
    %%%%%: 2535-block 105
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2536:                v_cur -= v_max - v_min + (is_floating_point ? 0 : 1);
    %%%%%: 2536-block 106
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2536-block 107
    %%%%%: 2536-block 108
    %%%%%: 2536-block 109
        -: 2537:        }
        -: 2538:        else
        -: 2539:        {
        -: 2540:            // Clamp values + handle overflow/wrap-around for integer types.
    #####: 2541:            if (v_cur < v_min || (v_cur > *v && adjust_delta < 0.0f && !is_floating_point))
    %%%%%: 2541-block 110
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2541-block 111
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2541-block 112
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 2541-block 113
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 2542:                v_cur = v_min;
    %%%%%: 2542-block 114
    #####: 2543:            if (v_cur > v_max || (v_cur < *v && adjust_delta > 0.0f && !is_floating_point))
    %%%%%: 2543-block 115
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2543-block 116
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2543-block 117
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 2543-block 118
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 2544:                v_cur = v_max;
    %%%%%: 2544-block 119
        -: 2545:        }
        -: 2546:    }
        -: 2547:
        -: 2548:    // Apply result
    #####: 2549:    if (*v == v_cur)
    %%%%%: 2549-block 120
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2550:        return false;
    %%%%%: 2550-block 121
    #####: 2551:    *v = v_cur;
    #####: 2552:    return true;
    %%%%%: 2552-block 122
        -: 2553:}
------------------
_ZN5ImGui13DragBehaviorTIxxdEEbiPT_fS1_S1_PKci:
function _ZN5ImGui13DragBehaviorTIxxdEEbiPT_fS1_S1_PKci called 0 returned 0% blocks executed 0%
    #####: 2425:bool ImGui::DragBehaviorT(ImGuiDataType data_type, TYPE* v, float v_speed, const TYPE v_min, const TYPE v_max, const char* format, ImGuiSliderFlags flags)
        -: 2426:{
    #####: 2427:    ImGuiContext& g = *GImGui;
    #####: 2428:    const ImGuiAxis axis = (flags & ImGuiSliderFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;
    #####: 2429:    const bool is_bounded = (v_min < v_max) || ((v_min == v_max) && (v_min != 0.0f || (flags & ImGuiSliderFlags_ClampZeroRange)));
    %%%%%: 2429-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2429-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2429-block 4
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 2429-block 5
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 2429-block 6
    %%%%%: 2429-block 7
    #####: 2430:    const bool is_wrapped = is_bounded && (flags & ImGuiSliderFlags_WrapAround);
    %%%%%: 2430-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2430-block 9
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2430-block 10
    %%%%%: 2430-block 11
    #####: 2431:    const bool is_logarithmic = (flags & ImGuiSliderFlags_Logarithmic) != 0;
    #####: 2432:    const bool is_floating_point = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);
    %%%%%: 2432-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2432-block 13
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2432-block 14
    %%%%%: 2432-block 15
        -: 2433:
        -: 2434:    // Default tweak speed
    #####: 2435:    if (v_speed == 0.0f && is_bounded && (v_max - v_min < FLT_MAX))
    %%%%%: 2435-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2435-block 17
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2435-block 18
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 2436:        v_speed = (float)((v_max - v_min) * g.DragSpeedDefaultRatio);
    %%%%%: 2436-block 19
        -: 2437:
        -: 2438:    // Inputs accumulates into g.DragCurrentAccum, which is flushed into the current value as soon as it makes a difference with our precision settings
    #####: 2439:    float adjust_delta = 0.0f;
    #####: 2440:    if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && IsMouseDragPastThreshold(0, g.IO.MouseDragThreshold * DRAG_MOUSE_THRESHOLD_FACTOR))
    %%%%%: 2440-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2440-block 21
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 2440-block 23
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 2440-block 25
    %%%%%: 2440-block 26
    %%%%%: 2440-block 27
branch  8 never executed (fallthrough)
branch  9 never executed
        -: 2441:    {
    #####: 2442:        adjust_delta = g.IO.MouseDelta[axis];
    %%%%%: 2442-block 28
call    0 never executed
    #####: 2443:        if (g.IO.KeyAlt)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2444:            adjust_delta *= 1.0f / 100.0f;
    %%%%%: 2444-block 30
    #####: 2445:        if (g.IO.KeyShift)
    %%%%%: 2445-block 31
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2446:            adjust_delta *= 10.0f;
    %%%%%: 2446-block 32
        -: 2447:    }
    #####: 2448:    else if (g.ActiveIdSource == ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource_Gamepad)
    %%%%%: 2448-block 33
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2448-block 34
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 2449:    {
    #####: 2450:        const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 0;
    %%%%%: 2450-block 35
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2450-block 36
call    2 never executed
    %%%%%: 2450-block 38
    #####: 2451:        const bool tweak_slow = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakSlow : ImGuiKey_NavKeyboardTweakSlow);
    %%%%%: 2451-block 39
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2451-block 40
    %%%%%: 2451-block 41
    %%%%%: 2451-block 42
call    2 never executed
    #####: 2452:        const bool tweak_fast = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakFast : ImGuiKey_NavKeyboardTweakFast);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2452-block 44
    %%%%%: 2452-block 45
    %%%%%: 2452-block 46
call    2 never executed
    #####: 2453:        const float tweak_factor = tweak_slow ? 1.0f / 10.0f : tweak_fast ? 10.0f : 1.0f;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2453-block 48
    %%%%%: 2453-block 49
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2453-block 50
    %%%%%: 2453-block 51
    %%%%%: 2453-block 52
    #####: 2454:        adjust_delta = GetNavTweakPressedAmount(axis) * tweak_factor;
    %%%%%: 2454-block 53
call    0 never executed
    #####: 2455:        v_speed = ImMax(v_speed, GetMinimumStepAtDecimalPrecision(decimal_precision));
call    0 never executed
call    1 never executed
        -: 2456:    }
    #####: 2457:    adjust_delta *= v_speed;
        -: 2458:
        -: 2459:    // For vertical drag we currently assume that Up=higher value (like we do with vertical sliders). This may become a parameter.
    #####: 2460:    if (axis == ImGuiAxis_Y)
    %%%%%: 2460-block 56
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2461:        adjust_delta = -adjust_delta;
    %%%%%: 2461-block 57
        -: 2462:
        -: 2463:    // For logarithmic use our range is effectively 0..1 so scale the delta into that range
    #####: 2464:    if (is_logarithmic && (v_max - v_min < FLT_MAX) && ((v_max - v_min) > 0.000001f)) // Epsilon to avoid /0
    %%%%%: 2464-block 58
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2464-block 59
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2464-block 60
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 2465:        adjust_delta /= (float)(v_max - v_min);
    %%%%%: 2465-block 61
        -: 2466:
        -: 2467:    // Clear current value on activation
        -: 2468:    // Avoid altering values and clamping when we are _already_ past the limits and heading in the same direction, so e.g. if range is 0..255, current value is 300 and we are pushing to the right side, keep the 300.
    #####: 2469:    const bool is_just_activated = g.ActiveIdIsJustActivated;
    #####: 2470:    const bool is_already_past_limits_and_pushing_outward = is_bounded && !is_wrapped && ((*v >= v_max && adjust_delta > 0.0f) || (*v <= v_min && adjust_delta < 0.0f));
    %%%%%: 2470-block 62
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2470-block 63
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2470-block 64
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 2470-block 65
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 2470-block 66
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%: 2470-block 67
branch 10 never executed (fallthrough)
branch 11 never executed
    %%%%%: 2470-block 68
    %%%%%: 2470-block 69
    #####: 2471:    if (is_just_activated || is_already_past_limits_and_pushing_outward)
    %%%%%: 2471-block 70
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2471-block 71
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 2472:    {
    #####: 2473:        g.DragCurrentAccum = 0.0f;
    #####: 2474:        g.DragCurrentAccumDirty = false;
    %%%%%: 2474-block 72
        -: 2475:    }
    #####: 2476:    else if (adjust_delta != 0.0f)
    %%%%%: 2476-block 73
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2477:    {
    #####: 2478:        g.DragCurrentAccum += adjust_delta;
    #####: 2479:        g.DragCurrentAccumDirty = true;
    %%%%%: 2479-block 74
        -: 2480:    }
        -: 2481:
    #####: 2482:    if (!g.DragCurrentAccumDirty)
    %%%%%: 2482-block 75
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2483:        return false;
    %%%%%: 2483-block 76
        -: 2484:
    #####: 2485:    TYPE v_cur = *v;
    #####: 2486:    FLOATTYPE v_old_ref_for_accum_remainder = (FLOATTYPE)0.0f;
        -: 2487:
    #####: 2488:    float logarithmic_zero_epsilon = 0.0f; // Only valid when is_logarithmic is true
    #####: 2489:    const float zero_deadzone_halfsize = 0.0f; // Drag widgets have no deadzone (as it doesn't make sense)
    #####: 2490:    if (is_logarithmic)
    %%%%%: 2490-block 77
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2491:    {
        -: 2492:        // When using logarithmic sliders, we need to clamp to avoid hitting zero, but our choice of clamp value greatly affects slider precision. We attempt to use the specified precision to estimate a good lower bound.
    #####: 2493:        const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 1;
    %%%%%: 2493-block 78
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2493-block 79
call    2 never executed
    %%%%%: 2493-block 81
    #####: 2494:        logarithmic_zero_epsilon = ImPow(0.1f, (float)decimal_precision);
    %%%%%: 2494-block 82
call    0 never executed
        -: 2495:
        -: 2496:        // Convert to parametric space, apply delta, convert back
    #####: 2497:        float v_old_parametric = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_cur, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
call    0 never executed
    #####: 2498:        float v_new_parametric = v_old_parametric + g.DragCurrentAccum;
    #####: 2499:        v_cur = ScaleValueFromRatioT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_new_parametric, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
call    0 never executed
    #####: 2500:        v_old_ref_for_accum_remainder = v_old_parametric;
        -: 2501:    }
        -: 2502:    else
        -: 2503:    {
    #####: 2504:        v_cur += (SIGNEDTYPE)g.DragCurrentAccum;
    %%%%%: 2504-block 86
        -: 2505:    }
        -: 2506:
        -: 2507:    // Round to user desired precision based on format string
    #####: 2508:    if (is_floating_point && !(flags & ImGuiSliderFlags_NoRoundToFormat))
    %%%%%: 2508-block 87
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2508-block 88
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2509:        v_cur = RoundScalarWithFormatT<TYPE>(format, data_type, v_cur);
    %%%%%: 2509-block 89
call    0 never executed
        -: 2510:
        -: 2511:    // Preserve remainder after rounding has been applied. This also allow slow tweaking of values.
    #####: 2512:    g.DragCurrentAccumDirty = false;
    #####: 2513:    if (is_logarithmic)
    %%%%%: 2513-block 91
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2514:    {
        -: 2515:        // Convert to parametric space, apply delta, convert back
    #####: 2516:        float v_new_parametric = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_cur, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
    %%%%%: 2516-block 92
call    0 never executed
    #####: 2517:        g.DragCurrentAccum -= (float)(v_new_parametric - v_old_ref_for_accum_remainder);
        -: 2518:    }
        -: 2519:    else
        -: 2520:    {
    #####: 2521:        g.DragCurrentAccum -= (float)((SIGNEDTYPE)v_cur - (SIGNEDTYPE)*v);
    %%%%%: 2521-block 94
        -: 2522:    }
        -: 2523:
        -: 2524:    // Lose zero sign for float/double
    #####: 2525:    if (v_cur == (TYPE)-0)
    %%%%%: 2525-block 95
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2526:        v_cur = (TYPE)0;
    %%%%%: 2526-block 96
        -: 2527:
    #####: 2528:    if (*v != v_cur && is_bounded)
    %%%%%: 2528-block 97
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2528-block 98
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 2529:    {
    #####: 2530:        if (is_wrapped)
    %%%%%: 2530-block 99
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2531:        {
        -: 2532:            // Wrap values
    #####: 2533:            if (v_cur < v_min)
    %%%%%: 2533-block 100
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2534:                v_cur += v_max - v_min + (is_floating_point ? 0 : 1);
    %%%%%: 2534-block 101
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2534-block 102
    %%%%%: 2534-block 103
    %%%%%: 2534-block 104
    #####: 2535:            if (v_cur > v_max)
    %%%%%: 2535-block 105
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2536:                v_cur -= v_max - v_min + (is_floating_point ? 0 : 1);
    %%%%%: 2536-block 106
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2536-block 107
    %%%%%: 2536-block 108
    %%%%%: 2536-block 109
        -: 2537:        }
        -: 2538:        else
        -: 2539:        {
        -: 2540:            // Clamp values + handle overflow/wrap-around for integer types.
    #####: 2541:            if (v_cur < v_min || (v_cur > *v && adjust_delta < 0.0f && !is_floating_point))
    %%%%%: 2541-block 110
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2541-block 111
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2541-block 112
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 2541-block 113
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 2542:                v_cur = v_min;
    %%%%%: 2542-block 114
    #####: 2543:            if (v_cur > v_max || (v_cur < *v && adjust_delta > 0.0f && !is_floating_point))
    %%%%%: 2543-block 115
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2543-block 116
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2543-block 117
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 2543-block 118
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 2544:                v_cur = v_max;
    %%%%%: 2544-block 119
        -: 2545:        }
        -: 2546:    }
        -: 2547:
        -: 2548:    // Apply result
    #####: 2549:    if (*v == v_cur)
    %%%%%: 2549-block 120
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2550:        return false;
    %%%%%: 2550-block 121
    #####: 2551:    *v = v_cur;
    #####: 2552:    return true;
    %%%%%: 2552-block 122
        -: 2553:}
------------------
_ZN5ImGui13DragBehaviorTIjifEEbiPT_fS1_S1_PKci:
function _ZN5ImGui13DragBehaviorTIjifEEbiPT_fS1_S1_PKci called 0 returned 0% blocks executed 0%
    #####: 2425:bool ImGui::DragBehaviorT(ImGuiDataType data_type, TYPE* v, float v_speed, const TYPE v_min, const TYPE v_max, const char* format, ImGuiSliderFlags flags)
        -: 2426:{
    #####: 2427:    ImGuiContext& g = *GImGui;
    #####: 2428:    const ImGuiAxis axis = (flags & ImGuiSliderFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;
    #####: 2429:    const bool is_bounded = (v_min < v_max) || ((v_min == v_max) && (v_min != 0.0f || (flags & ImGuiSliderFlags_ClampZeroRange)));
    %%%%%: 2429-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2429-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2429-block 4
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 2429-block 5
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 2429-block 6
    %%%%%: 2429-block 7
    #####: 2430:    const bool is_wrapped = is_bounded && (flags & ImGuiSliderFlags_WrapAround);
    %%%%%: 2430-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2430-block 9
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2430-block 10
    %%%%%: 2430-block 11
    #####: 2431:    const bool is_logarithmic = (flags & ImGuiSliderFlags_Logarithmic) != 0;
    #####: 2432:    const bool is_floating_point = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);
    %%%%%: 2432-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2432-block 13
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2432-block 14
    %%%%%: 2432-block 15
        -: 2433:
        -: 2434:    // Default tweak speed
    #####: 2435:    if (v_speed == 0.0f && is_bounded && (v_max - v_min < FLT_MAX))
    %%%%%: 2435-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2435-block 17
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2435-block 18
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 2436:        v_speed = (float)((v_max - v_min) * g.DragSpeedDefaultRatio);
    %%%%%: 2436-block 19
        -: 2437:
        -: 2438:    // Inputs accumulates into g.DragCurrentAccum, which is flushed into the current value as soon as it makes a difference with our precision settings
    #####: 2439:    float adjust_delta = 0.0f;
    #####: 2440:    if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && IsMouseDragPastThreshold(0, g.IO.MouseDragThreshold * DRAG_MOUSE_THRESHOLD_FACTOR))
    %%%%%: 2440-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2440-block 21
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 2440-block 23
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 2440-block 25
    %%%%%: 2440-block 26
    %%%%%: 2440-block 27
branch  8 never executed (fallthrough)
branch  9 never executed
        -: 2441:    {
    #####: 2442:        adjust_delta = g.IO.MouseDelta[axis];
    %%%%%: 2442-block 28
call    0 never executed
    #####: 2443:        if (g.IO.KeyAlt)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2444:            adjust_delta *= 1.0f / 100.0f;
    %%%%%: 2444-block 30
    #####: 2445:        if (g.IO.KeyShift)
    %%%%%: 2445-block 31
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2446:            adjust_delta *= 10.0f;
    %%%%%: 2446-block 32
        -: 2447:    }
    #####: 2448:    else if (g.ActiveIdSource == ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource_Gamepad)
    %%%%%: 2448-block 33
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2448-block 34
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 2449:    {
    #####: 2450:        const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 0;
    %%%%%: 2450-block 35
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2450-block 36
call    2 never executed
    %%%%%: 2450-block 38
    #####: 2451:        const bool tweak_slow = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakSlow : ImGuiKey_NavKeyboardTweakSlow);
    %%%%%: 2451-block 39
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2451-block 40
    %%%%%: 2451-block 41
    %%%%%: 2451-block 42
call    2 never executed
    #####: 2452:        const bool tweak_fast = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakFast : ImGuiKey_NavKeyboardTweakFast);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2452-block 44
    %%%%%: 2452-block 45
    %%%%%: 2452-block 46
call    2 never executed
    #####: 2453:        const float tweak_factor = tweak_slow ? 1.0f / 10.0f : tweak_fast ? 10.0f : 1.0f;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2453-block 48
    %%%%%: 2453-block 49
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2453-block 50
    %%%%%: 2453-block 51
    %%%%%: 2453-block 52
    #####: 2454:        adjust_delta = GetNavTweakPressedAmount(axis) * tweak_factor;
    %%%%%: 2454-block 53
call    0 never executed
    #####: 2455:        v_speed = ImMax(v_speed, GetMinimumStepAtDecimalPrecision(decimal_precision));
call    0 never executed
call    1 never executed
        -: 2456:    }
    #####: 2457:    adjust_delta *= v_speed;
        -: 2458:
        -: 2459:    // For vertical drag we currently assume that Up=higher value (like we do with vertical sliders). This may become a parameter.
    #####: 2460:    if (axis == ImGuiAxis_Y)
    %%%%%: 2460-block 56
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2461:        adjust_delta = -adjust_delta;
    %%%%%: 2461-block 57
        -: 2462:
        -: 2463:    // For logarithmic use our range is effectively 0..1 so scale the delta into that range
    #####: 2464:    if (is_logarithmic && (v_max - v_min < FLT_MAX) && ((v_max - v_min) > 0.000001f)) // Epsilon to avoid /0
    %%%%%: 2464-block 58
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2464-block 59
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2464-block 60
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 2465:        adjust_delta /= (float)(v_max - v_min);
    %%%%%: 2465-block 61
        -: 2466:
        -: 2467:    // Clear current value on activation
        -: 2468:    // Avoid altering values and clamping when we are _already_ past the limits and heading in the same direction, so e.g. if range is 0..255, current value is 300 and we are pushing to the right side, keep the 300.
    #####: 2469:    const bool is_just_activated = g.ActiveIdIsJustActivated;
    #####: 2470:    const bool is_already_past_limits_and_pushing_outward = is_bounded && !is_wrapped && ((*v >= v_max && adjust_delta > 0.0f) || (*v <= v_min && adjust_delta < 0.0f));
    %%%%%: 2470-block 62
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2470-block 63
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2470-block 64
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 2470-block 65
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 2470-block 66
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%: 2470-block 67
branch 10 never executed (fallthrough)
branch 11 never executed
    %%%%%: 2470-block 68
    %%%%%: 2470-block 69
    #####: 2471:    if (is_just_activated || is_already_past_limits_and_pushing_outward)
    %%%%%: 2471-block 70
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2471-block 71
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 2472:    {
    #####: 2473:        g.DragCurrentAccum = 0.0f;
    #####: 2474:        g.DragCurrentAccumDirty = false;
    %%%%%: 2474-block 72
        -: 2475:    }
    #####: 2476:    else if (adjust_delta != 0.0f)
    %%%%%: 2476-block 73
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2477:    {
    #####: 2478:        g.DragCurrentAccum += adjust_delta;
    #####: 2479:        g.DragCurrentAccumDirty = true;
    %%%%%: 2479-block 74
        -: 2480:    }
        -: 2481:
    #####: 2482:    if (!g.DragCurrentAccumDirty)
    %%%%%: 2482-block 75
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2483:        return false;
    %%%%%: 2483-block 76
        -: 2484:
    #####: 2485:    TYPE v_cur = *v;
    #####: 2486:    FLOATTYPE v_old_ref_for_accum_remainder = (FLOATTYPE)0.0f;
        -: 2487:
    #####: 2488:    float logarithmic_zero_epsilon = 0.0f; // Only valid when is_logarithmic is true
    #####: 2489:    const float zero_deadzone_halfsize = 0.0f; // Drag widgets have no deadzone (as it doesn't make sense)
    #####: 2490:    if (is_logarithmic)
    %%%%%: 2490-block 77
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2491:    {
        -: 2492:        // When using logarithmic sliders, we need to clamp to avoid hitting zero, but our choice of clamp value greatly affects slider precision. We attempt to use the specified precision to estimate a good lower bound.
    #####: 2493:        const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 1;
    %%%%%: 2493-block 78
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2493-block 79
call    2 never executed
    %%%%%: 2493-block 81
    #####: 2494:        logarithmic_zero_epsilon = ImPow(0.1f, (float)decimal_precision);
    %%%%%: 2494-block 82
call    0 never executed
        -: 2495:
        -: 2496:        // Convert to parametric space, apply delta, convert back
    #####: 2497:        float v_old_parametric = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_cur, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
call    0 never executed
    #####: 2498:        float v_new_parametric = v_old_parametric + g.DragCurrentAccum;
    #####: 2499:        v_cur = ScaleValueFromRatioT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_new_parametric, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
call    0 never executed
    #####: 2500:        v_old_ref_for_accum_remainder = v_old_parametric;
        -: 2501:    }
        -: 2502:    else
        -: 2503:    {
    #####: 2504:        v_cur += (SIGNEDTYPE)g.DragCurrentAccum;
    %%%%%: 2504-block 86
        -: 2505:    }
        -: 2506:
        -: 2507:    // Round to user desired precision based on format string
    #####: 2508:    if (is_floating_point && !(flags & ImGuiSliderFlags_NoRoundToFormat))
    %%%%%: 2508-block 87
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2508-block 88
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2509:        v_cur = RoundScalarWithFormatT<TYPE>(format, data_type, v_cur);
    %%%%%: 2509-block 89
call    0 never executed
        -: 2510:
        -: 2511:    // Preserve remainder after rounding has been applied. This also allow slow tweaking of values.
    #####: 2512:    g.DragCurrentAccumDirty = false;
    #####: 2513:    if (is_logarithmic)
    %%%%%: 2513-block 91
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2514:    {
        -: 2515:        // Convert to parametric space, apply delta, convert back
    #####: 2516:        float v_new_parametric = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_cur, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
    %%%%%: 2516-block 92
call    0 never executed
    #####: 2517:        g.DragCurrentAccum -= (float)(v_new_parametric - v_old_ref_for_accum_remainder);
        -: 2518:    }
        -: 2519:    else
        -: 2520:    {
    #####: 2521:        g.DragCurrentAccum -= (float)((SIGNEDTYPE)v_cur - (SIGNEDTYPE)*v);
    %%%%%: 2521-block 94
        -: 2522:    }
        -: 2523:
        -: 2524:    // Lose zero sign for float/double
    #####: 2525:    if (v_cur == (TYPE)-0)
    %%%%%: 2525-block 95
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2526:        v_cur = (TYPE)0;
    %%%%%: 2526-block 96
        -: 2527:
    #####: 2528:    if (*v != v_cur && is_bounded)
    %%%%%: 2528-block 97
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2528-block 98
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 2529:    {
    #####: 2530:        if (is_wrapped)
    %%%%%: 2530-block 99
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2531:        {
        -: 2532:            // Wrap values
    #####: 2533:            if (v_cur < v_min)
    %%%%%: 2533-block 100
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2534:                v_cur += v_max - v_min + (is_floating_point ? 0 : 1);
    %%%%%: 2534-block 101
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2534-block 102
    %%%%%: 2534-block 103
    %%%%%: 2534-block 104
    #####: 2535:            if (v_cur > v_max)
    %%%%%: 2535-block 105
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2536:                v_cur -= v_max - v_min + (is_floating_point ? 0 : 1);
    %%%%%: 2536-block 106
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2536-block 107
    %%%%%: 2536-block 108
    %%%%%: 2536-block 109
        -: 2537:        }
        -: 2538:        else
        -: 2539:        {
        -: 2540:            // Clamp values + handle overflow/wrap-around for integer types.
    #####: 2541:            if (v_cur < v_min || (v_cur > *v && adjust_delta < 0.0f && !is_floating_point))
    %%%%%: 2541-block 110
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2541-block 111
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2541-block 112
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 2541-block 113
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 2542:                v_cur = v_min;
    %%%%%: 2542-block 114
    #####: 2543:            if (v_cur > v_max || (v_cur < *v && adjust_delta > 0.0f && !is_floating_point))
    %%%%%: 2543-block 115
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2543-block 116
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2543-block 117
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 2543-block 118
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 2544:                v_cur = v_max;
    %%%%%: 2544-block 119
        -: 2545:        }
        -: 2546:    }
        -: 2547:
        -: 2548:    // Apply result
    #####: 2549:    if (*v == v_cur)
    %%%%%: 2549-block 120
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2550:        return false;
    %%%%%: 2550-block 121
    #####: 2551:    *v = v_cur;
    #####: 2552:    return true;
    %%%%%: 2552-block 122
        -: 2553:}
------------------
_ZN5ImGui13DragBehaviorTIiifEEbiPT_fS1_S1_PKci:
function _ZN5ImGui13DragBehaviorTIiifEEbiPT_fS1_S1_PKci called 0 returned 0% blocks executed 0%
    #####: 2425:bool ImGui::DragBehaviorT(ImGuiDataType data_type, TYPE* v, float v_speed, const TYPE v_min, const TYPE v_max, const char* format, ImGuiSliderFlags flags)
        -: 2426:{
    #####: 2427:    ImGuiContext& g = *GImGui;
    #####: 2428:    const ImGuiAxis axis = (flags & ImGuiSliderFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;
    #####: 2429:    const bool is_bounded = (v_min < v_max) || ((v_min == v_max) && (v_min != 0.0f || (flags & ImGuiSliderFlags_ClampZeroRange)));
    %%%%%: 2429-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2429-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2429-block 4
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 2429-block 5
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 2429-block 6
    %%%%%: 2429-block 7
    #####: 2430:    const bool is_wrapped = is_bounded && (flags & ImGuiSliderFlags_WrapAround);
    %%%%%: 2430-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2430-block 9
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2430-block 10
    %%%%%: 2430-block 11
    #####: 2431:    const bool is_logarithmic = (flags & ImGuiSliderFlags_Logarithmic) != 0;
    #####: 2432:    const bool is_floating_point = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);
    %%%%%: 2432-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2432-block 13
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2432-block 14
    %%%%%: 2432-block 15
        -: 2433:
        -: 2434:    // Default tweak speed
    #####: 2435:    if (v_speed == 0.0f && is_bounded && (v_max - v_min < FLT_MAX))
    %%%%%: 2435-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2435-block 17
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2435-block 18
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 2436:        v_speed = (float)((v_max - v_min) * g.DragSpeedDefaultRatio);
    %%%%%: 2436-block 19
        -: 2437:
        -: 2438:    // Inputs accumulates into g.DragCurrentAccum, which is flushed into the current value as soon as it makes a difference with our precision settings
    #####: 2439:    float adjust_delta = 0.0f;
    #####: 2440:    if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && IsMouseDragPastThreshold(0, g.IO.MouseDragThreshold * DRAG_MOUSE_THRESHOLD_FACTOR))
    %%%%%: 2440-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2440-block 21
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 2440-block 23
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 2440-block 25
    %%%%%: 2440-block 26
    %%%%%: 2440-block 27
branch  8 never executed (fallthrough)
branch  9 never executed
        -: 2441:    {
    #####: 2442:        adjust_delta = g.IO.MouseDelta[axis];
    %%%%%: 2442-block 28
call    0 never executed
    #####: 2443:        if (g.IO.KeyAlt)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2444:            adjust_delta *= 1.0f / 100.0f;
    %%%%%: 2444-block 30
    #####: 2445:        if (g.IO.KeyShift)
    %%%%%: 2445-block 31
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2446:            adjust_delta *= 10.0f;
    %%%%%: 2446-block 32
        -: 2447:    }
    #####: 2448:    else if (g.ActiveIdSource == ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource_Gamepad)
    %%%%%: 2448-block 33
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2448-block 34
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 2449:    {
    #####: 2450:        const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 0;
    %%%%%: 2450-block 35
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2450-block 36
call    2 never executed
    %%%%%: 2450-block 38
    #####: 2451:        const bool tweak_slow = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakSlow : ImGuiKey_NavKeyboardTweakSlow);
    %%%%%: 2451-block 39
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2451-block 40
    %%%%%: 2451-block 41
    %%%%%: 2451-block 42
call    2 never executed
    #####: 2452:        const bool tweak_fast = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakFast : ImGuiKey_NavKeyboardTweakFast);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2452-block 44
    %%%%%: 2452-block 45
    %%%%%: 2452-block 46
call    2 never executed
    #####: 2453:        const float tweak_factor = tweak_slow ? 1.0f / 10.0f : tweak_fast ? 10.0f : 1.0f;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2453-block 48
    %%%%%: 2453-block 49
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2453-block 50
    %%%%%: 2453-block 51
    %%%%%: 2453-block 52
    #####: 2454:        adjust_delta = GetNavTweakPressedAmount(axis) * tweak_factor;
    %%%%%: 2454-block 53
call    0 never executed
    #####: 2455:        v_speed = ImMax(v_speed, GetMinimumStepAtDecimalPrecision(decimal_precision));
call    0 never executed
call    1 never executed
        -: 2456:    }
    #####: 2457:    adjust_delta *= v_speed;
        -: 2458:
        -: 2459:    // For vertical drag we currently assume that Up=higher value (like we do with vertical sliders). This may become a parameter.
    #####: 2460:    if (axis == ImGuiAxis_Y)
    %%%%%: 2460-block 56
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2461:        adjust_delta = -adjust_delta;
    %%%%%: 2461-block 57
        -: 2462:
        -: 2463:    // For logarithmic use our range is effectively 0..1 so scale the delta into that range
    #####: 2464:    if (is_logarithmic && (v_max - v_min < FLT_MAX) && ((v_max - v_min) > 0.000001f)) // Epsilon to avoid /0
    %%%%%: 2464-block 58
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2464-block 59
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2464-block 60
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 2465:        adjust_delta /= (float)(v_max - v_min);
    %%%%%: 2465-block 61
        -: 2466:
        -: 2467:    // Clear current value on activation
        -: 2468:    // Avoid altering values and clamping when we are _already_ past the limits and heading in the same direction, so e.g. if range is 0..255, current value is 300 and we are pushing to the right side, keep the 300.
    #####: 2469:    const bool is_just_activated = g.ActiveIdIsJustActivated;
    #####: 2470:    const bool is_already_past_limits_and_pushing_outward = is_bounded && !is_wrapped && ((*v >= v_max && adjust_delta > 0.0f) || (*v <= v_min && adjust_delta < 0.0f));
    %%%%%: 2470-block 62
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2470-block 63
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2470-block 64
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 2470-block 65
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 2470-block 66
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%: 2470-block 67
branch 10 never executed (fallthrough)
branch 11 never executed
    %%%%%: 2470-block 68
    %%%%%: 2470-block 69
    #####: 2471:    if (is_just_activated || is_already_past_limits_and_pushing_outward)
    %%%%%: 2471-block 70
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2471-block 71
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 2472:    {
    #####: 2473:        g.DragCurrentAccum = 0.0f;
    #####: 2474:        g.DragCurrentAccumDirty = false;
    %%%%%: 2474-block 72
        -: 2475:    }
    #####: 2476:    else if (adjust_delta != 0.0f)
    %%%%%: 2476-block 73
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2477:    {
    #####: 2478:        g.DragCurrentAccum += adjust_delta;
    #####: 2479:        g.DragCurrentAccumDirty = true;
    %%%%%: 2479-block 74
        -: 2480:    }
        -: 2481:
    #####: 2482:    if (!g.DragCurrentAccumDirty)
    %%%%%: 2482-block 75
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2483:        return false;
    %%%%%: 2483-block 76
        -: 2484:
    #####: 2485:    TYPE v_cur = *v;
    #####: 2486:    FLOATTYPE v_old_ref_for_accum_remainder = (FLOATTYPE)0.0f;
        -: 2487:
    #####: 2488:    float logarithmic_zero_epsilon = 0.0f; // Only valid when is_logarithmic is true
    #####: 2489:    const float zero_deadzone_halfsize = 0.0f; // Drag widgets have no deadzone (as it doesn't make sense)
    #####: 2490:    if (is_logarithmic)
    %%%%%: 2490-block 77
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2491:    {
        -: 2492:        // When using logarithmic sliders, we need to clamp to avoid hitting zero, but our choice of clamp value greatly affects slider precision. We attempt to use the specified precision to estimate a good lower bound.
    #####: 2493:        const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 1;
    %%%%%: 2493-block 78
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2493-block 79
call    2 never executed
    %%%%%: 2493-block 81
    #####: 2494:        logarithmic_zero_epsilon = ImPow(0.1f, (float)decimal_precision);
    %%%%%: 2494-block 82
call    0 never executed
        -: 2495:
        -: 2496:        // Convert to parametric space, apply delta, convert back
    #####: 2497:        float v_old_parametric = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_cur, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
call    0 never executed
    #####: 2498:        float v_new_parametric = v_old_parametric + g.DragCurrentAccum;
    #####: 2499:        v_cur = ScaleValueFromRatioT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_new_parametric, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
call    0 never executed
    #####: 2500:        v_old_ref_for_accum_remainder = v_old_parametric;
        -: 2501:    }
        -: 2502:    else
        -: 2503:    {
    #####: 2504:        v_cur += (SIGNEDTYPE)g.DragCurrentAccum;
    %%%%%: 2504-block 86
        -: 2505:    }
        -: 2506:
        -: 2507:    // Round to user desired precision based on format string
    #####: 2508:    if (is_floating_point && !(flags & ImGuiSliderFlags_NoRoundToFormat))
    %%%%%: 2508-block 87
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2508-block 88
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2509:        v_cur = RoundScalarWithFormatT<TYPE>(format, data_type, v_cur);
    %%%%%: 2509-block 89
call    0 never executed
        -: 2510:
        -: 2511:    // Preserve remainder after rounding has been applied. This also allow slow tweaking of values.
    #####: 2512:    g.DragCurrentAccumDirty = false;
    #####: 2513:    if (is_logarithmic)
    %%%%%: 2513-block 91
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2514:    {
        -: 2515:        // Convert to parametric space, apply delta, convert back
    #####: 2516:        float v_new_parametric = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_cur, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
    %%%%%: 2516-block 92
call    0 never executed
    #####: 2517:        g.DragCurrentAccum -= (float)(v_new_parametric - v_old_ref_for_accum_remainder);
        -: 2518:    }
        -: 2519:    else
        -: 2520:    {
    #####: 2521:        g.DragCurrentAccum -= (float)((SIGNEDTYPE)v_cur - (SIGNEDTYPE)*v);
    %%%%%: 2521-block 94
        -: 2522:    }
        -: 2523:
        -: 2524:    // Lose zero sign for float/double
    #####: 2525:    if (v_cur == (TYPE)-0)
    %%%%%: 2525-block 95
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2526:        v_cur = (TYPE)0;
    %%%%%: 2526-block 96
        -: 2527:
    #####: 2528:    if (*v != v_cur && is_bounded)
    %%%%%: 2528-block 97
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2528-block 98
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 2529:    {
    #####: 2530:        if (is_wrapped)
    %%%%%: 2530-block 99
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2531:        {
        -: 2532:            // Wrap values
    #####: 2533:            if (v_cur < v_min)
    %%%%%: 2533-block 100
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2534:                v_cur += v_max - v_min + (is_floating_point ? 0 : 1);
    %%%%%: 2534-block 101
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2534-block 102
    %%%%%: 2534-block 103
    %%%%%: 2534-block 104
    #####: 2535:            if (v_cur > v_max)
    %%%%%: 2535-block 105
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2536:                v_cur -= v_max - v_min + (is_floating_point ? 0 : 1);
    %%%%%: 2536-block 106
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2536-block 107
    %%%%%: 2536-block 108
    %%%%%: 2536-block 109
        -: 2537:        }
        -: 2538:        else
        -: 2539:        {
        -: 2540:            // Clamp values + handle overflow/wrap-around for integer types.
    #####: 2541:            if (v_cur < v_min || (v_cur > *v && adjust_delta < 0.0f && !is_floating_point))
    %%%%%: 2541-block 110
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2541-block 111
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2541-block 112
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 2541-block 113
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 2542:                v_cur = v_min;
    %%%%%: 2542-block 114
    #####: 2543:            if (v_cur > v_max || (v_cur < *v && adjust_delta > 0.0f && !is_floating_point))
    %%%%%: 2543-block 115
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2543-block 116
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2543-block 117
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 2543-block 118
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 2544:                v_cur = v_max;
    %%%%%: 2544-block 119
        -: 2545:        }
        -: 2546:    }
        -: 2547:
        -: 2548:    // Apply result
    #####: 2549:    if (*v == v_cur)
    %%%%%: 2549-block 120
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2550:        return false;
    %%%%%: 2550-block 121
    #####: 2551:    *v = v_cur;
    #####: 2552:    return true;
    %%%%%: 2552-block 122
        -: 2553:}
------------------
        -: 2554:
function _ZN5ImGui12DragBehaviorEjiPvfPKvS2_PKci called 0 returned 0% blocks executed 0%
    #####: 2555:bool ImGui::DragBehavior(ImGuiID id, ImGuiDataType data_type, void* p_v, float v_speed, const void* p_min, const void* p_max, const char* format, ImGuiSliderFlags flags)
        -: 2556:{
        -: 2557:    // Read imgui.cpp "API BREAKING CHANGES" section for 1.78 if you hit this assert.
    #####: 2558:    IM_ASSERT((flags == 1 || (flags & ImGuiSliderFlags_InvalidMask_) == 0) && "Invalid ImGuiSliderFlags flags! Has the legacy 'float power' argument been mistakenly cast to flags? Call function with ImGuiSliderFlags_Logarithmic flags instead.");
    %%%%%: 2558-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2558-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2558-block 4
call    4 never executed
        -: 2559:
    #####: 2560:    ImGuiContext& g = *GImGui;
    #####: 2561:    if (g.ActiveId == id)
    %%%%%: 2561-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2562:    {
        -: 2563:        // Those are the things we can do easily outside the DragBehaviorT<> template, saves code generation.
    #####: 2564:        if (g.ActiveIdSource == ImGuiInputSource_Mouse && !g.IO.MouseDown[0])
    %%%%%: 2564-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2564-block 7
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2565:            ClearActiveID();
    %%%%%: 2565-block 8
call    0 never executed
    #####: 2566:        else if ((g.ActiveIdSource == ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource_Gamepad) && g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated)
    %%%%%: 2566-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2566-block 10
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2566-block 11
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 2566-block 12
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 2567:            ClearActiveID();
    %%%%%: 2567-block 13
call    0 never executed
        -: 2568:    }
    #####: 2569:    if (g.ActiveId != id)
    %%%%%: 2569-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2570:        return false;
    %%%%%: 2570-block 16
    #####: 2571:    if ((g.LastItemData.ItemFlags & ImGuiItemFlags_ReadOnly) || (flags & ImGuiSliderFlags_ReadOnly))
    %%%%%: 2571-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2571-block 18
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2572:        return false;
    %%%%%: 2572-block 19
        -: 2573:
    #####: 2574:    switch (data_type)
    %%%%%: 2574-block 20
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
        -: 2575:    {
    #####: 2576:    case ImGuiDataType_S8:     { ImS32 v32 = (ImS32)*(ImS8*)p_v;  bool r = DragBehaviorT<ImS32, ImS32, float>(ImGuiDataType_S32, &v32, v_speed, p_min ? *(const ImS8*) p_min : IM_S8_MIN,  p_max ? *(const ImS8*)p_max  : IM_S8_MAX,  format, flags); if (r) *(ImS8*)p_v = (ImS8)v32; return r; }
    %%%%%: 2576-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2576-block 22
    %%%%%: 2576-block 23
    %%%%%: 2576-block 24
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2576-block 25
    %%%%%: 2576-block 26
    %%%%%: 2576-block 27
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    %%%%%: 2576-block 28
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 2576-block 29
    %%%%%: 2576-block 30
    #####: 2577:    case ImGuiDataType_U8:     { ImU32 v32 = (ImU32)*(ImU8*)p_v;  bool r = DragBehaviorT<ImU32, ImS32, float>(ImGuiDataType_U32, &v32, v_speed, p_min ? *(const ImU8*) p_min : IM_U8_MIN,  p_max ? *(const ImU8*)p_max  : IM_U8_MAX,  format, flags); if (r) *(ImU8*)p_v = (ImU8)v32; return r; }
    %%%%%: 2577-block 32
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2577-block 33
    %%%%%: 2577-block 34
    %%%%%: 2577-block 35
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2577-block 36
    %%%%%: 2577-block 37
    %%%%%: 2577-block 38
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    %%%%%: 2577-block 39
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 2577-block 40
    %%%%%: 2577-block 41
    #####: 2578:    case ImGuiDataType_S16:    { ImS32 v32 = (ImS32)*(ImS16*)p_v; bool r = DragBehaviorT<ImS32, ImS32, float>(ImGuiDataType_S32, &v32, v_speed, p_min ? *(const ImS16*)p_min : IM_S16_MIN, p_max ? *(const ImS16*)p_max : IM_S16_MAX, format, flags); if (r) *(ImS16*)p_v = (ImS16)v32; return r; }
    %%%%%: 2578-block 43
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2578-block 44
    %%%%%: 2578-block 45
    %%%%%: 2578-block 46
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2578-block 47
    %%%%%: 2578-block 48
    %%%%%: 2578-block 49
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    %%%%%: 2578-block 50
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 2578-block 51
    %%%%%: 2578-block 52
    #####: 2579:    case ImGuiDataType_U16:    { ImU32 v32 = (ImU32)*(ImU16*)p_v; bool r = DragBehaviorT<ImU32, ImS32, float>(ImGuiDataType_U32, &v32, v_speed, p_min ? *(const ImU16*)p_min : IM_U16_MIN, p_max ? *(const ImU16*)p_max : IM_U16_MAX, format, flags); if (r) *(ImU16*)p_v = (ImU16)v32; return r; }
    %%%%%: 2579-block 54
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2579-block 55
    %%%%%: 2579-block 56
    %%%%%: 2579-block 57
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2579-block 58
    %%%%%: 2579-block 59
    %%%%%: 2579-block 60
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    %%%%%: 2579-block 61
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 2579-block 62
    %%%%%: 2579-block 63
    #####: 2580:    case ImGuiDataType_S32:    return DragBehaviorT<ImS32, ImS32, float >(data_type, (ImS32*)p_v,  v_speed, p_min ? *(const ImS32* )p_min : IM_S32_MIN, p_max ? *(const ImS32* )p_max : IM_S32_MAX, format, flags);
    %%%%%: 2580-block 65
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2580-block 66
    %%%%%: 2580-block 67
    %%%%%: 2580-block 68
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2580-block 69
    %%%%%: 2580-block 70
    %%%%%: 2580-block 71
call    4 never executed
    #####: 2581:    case ImGuiDataType_U32:    return DragBehaviorT<ImU32, ImS32, float >(data_type, (ImU32*)p_v,  v_speed, p_min ? *(const ImU32* )p_min : IM_U32_MIN, p_max ? *(const ImU32* )p_max : IM_U32_MAX, format, flags);
    %%%%%: 2581-block 73
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2581-block 74
    %%%%%: 2581-block 75
    %%%%%: 2581-block 76
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2581-block 77
    %%%%%: 2581-block 78
    %%%%%: 2581-block 79
call    4 never executed
    #####: 2582:    case ImGuiDataType_S64:    return DragBehaviorT<ImS64, ImS64, double>(data_type, (ImS64*)p_v,  v_speed, p_min ? *(const ImS64* )p_min : IM_S64_MIN, p_max ? *(const ImS64* )p_max : IM_S64_MAX, format, flags);
    %%%%%: 2582-block 81
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2582-block 82
    %%%%%: 2582-block 83
    %%%%%: 2582-block 84
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2582-block 85
    %%%%%: 2582-block 86
    %%%%%: 2582-block 87
call    4 never executed
    #####: 2583:    case ImGuiDataType_U64:    return DragBehaviorT<ImU64, ImS64, double>(data_type, (ImU64*)p_v,  v_speed, p_min ? *(const ImU64* )p_min : IM_U64_MIN, p_max ? *(const ImU64* )p_max : IM_U64_MAX, format, flags);
    %%%%%: 2583-block 89
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2583-block 90
    %%%%%: 2583-block 91
    %%%%%: 2583-block 92
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2583-block 93
    %%%%%: 2583-block 94
    %%%%%: 2583-block 95
call    4 never executed
    #####: 2584:    case ImGuiDataType_Float:  return DragBehaviorT<float, float, float >(data_type, (float*)p_v,  v_speed, p_min ? *(const float* )p_min : -FLT_MAX,   p_max ? *(const float* )p_max : FLT_MAX,    format, flags);
    %%%%%: 2584-block 97
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2584-block 98
    %%%%%: 2584-block 99
    %%%%%: 2584-block 100
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2584-block 101
    %%%%%: 2584-block 102
    %%%%%: 2584-block 103
call    4 never executed
    #####: 2585:    case ImGuiDataType_Double: return DragBehaviorT<double,double,double>(data_type, (double*)p_v, v_speed, p_min ? *(const double*)p_min : -DBL_MAX,   p_max ? *(const double*)p_max : DBL_MAX,    format, flags);
    %%%%%: 2585-block 105
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2585-block 106
    %%%%%: 2585-block 107
    %%%%%: 2585-block 108
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2585-block 109
    %%%%%: 2585-block 110
    %%%%%: 2585-block 111
call    4 never executed
    #####: 2586:    case ImGuiDataType_COUNT:  break;
    %%%%%: 2586-block 113
        -: 2587:    }
    #####: 2588:    IM_ASSERT(0);
    %%%%%: 2588-block 114
call    0 never executed
        -: 2589:    return false;
        -: 2590:}
        -: 2591:
        -: 2592:// Note: p_data, p_min and p_max are _pointers_ to a memory address holding the data. For a Drag widget, p_min and p_max are optional.
        -: 2593:// Read code of e.g. DragFloat(), DragInt() etc. or examples in 'Demo->Widgets->Data Types' to understand how to use this function directly.
function _ZN5ImGui10DragScalarEPKciPvfPKvS4_S1_i called 0 returned 0% blocks executed 0%
    #####: 2594:bool ImGui::DragScalar(const char* label, ImGuiDataType data_type, void* p_data, float v_speed, const void* p_min, const void* p_max, const char* format, ImGuiSliderFlags flags)
        -: 2595:{
    #####: 2596:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%: 2596-block 2
call    0 never executed
    #####: 2597:    if (window->SkipItems)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2598:        return false;
    %%%%%: 2598-block 4
        -: 2599:
    #####: 2600:    ImGuiContext& g = *GImGui;
    #####: 2601:    const ImGuiStyle& style = g.Style;
    #####: 2602:    const ImGuiID id = window->GetID(label);
    %%%%%: 2602-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 2603:    const float w = CalcItemWidth();
    %%%%%: 2603-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 2604:
    #####: 2605:    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    %%%%%: 2605-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 2606:    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y * 2.0f));
    %%%%%: 2606-block 8
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2607:    const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2607-block 12
    %%%%%: 2607-block 13
    %%%%%: 2607-block 14
call    2 never executed
call    3 never executed
call    4 never executed
        -: 2608:
    #####: 2609:    const bool temp_input_allowed = (flags & ImGuiSliderFlags_NoInput) == 0;
    #####: 2610:    ItemSize(total_bb, style.FramePadding.y);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 2611:    if (!ItemAdd(total_bb, id, &frame_bb, temp_input_allowed ? ImGuiItemFlags_Inputable : 0))
    %%%%%: 2611-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2611-block 19
    %%%%%: 2611-block 20
    %%%%%: 2611-block 21
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 2611-block 22
branch  5 never executed (fallthrough)
branch  6 never executed
    #####: 2612:        return false;
    %%%%%: 2612-block 23
        -: 2613:
        -: 2614:    // Default format string when passing NULL
    #####: 2615:    if (format == NULL)
    %%%%%: 2615-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2616:        format = DataTypeGetInfo(data_type)->PrintFmt;
    %%%%%: 2616-block 25
call    0 never executed
        -: 2617:
    #####: 2618:    const bool hovered = ItemHoverable(frame_bb, id, g.LastItemData.ItemFlags);
    %%%%%: 2618-block 27
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 2619:    bool temp_input_is_active = temp_input_allowed && TempInputIsActive(id);
    %%%%%: 2619-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2619-block 29
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 2619-block 31
    %%%%%: 2619-block 32
    #####: 2620:    if (!temp_input_is_active)
    %%%%%: 2620-block 33
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2621:    {
        -: 2622:        // Tabbing or CTRL-clicking on Drag turns it into an InputText
    #####: 2623:        const bool clicked = hovered && IsMouseClicked(0, ImGuiInputFlags_None, id);
    %%%%%: 2623-block 34
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2623-block 35
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 2623-block 36
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 2623-block 37
    %%%%%: 2623-block 38
    #####: 2624:        const bool double_clicked = (hovered && g.IO.MouseClickedCount[0] == 2 && TestKeyOwner(ImGuiKey_MouseLeft, id));
    %%%%%: 2624-block 39
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2624-block 40
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2624-block 41
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    %%%%%: 2624-block 42
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 2624-block 43
    %%%%%: 2624-block 44
    #####: 2625:        const bool make_active = (clicked || double_clicked || g.NavActivateId == id);
    %%%%%: 2625-block 45
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2625-block 46
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2625-block 47
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 2625-block 48
    %%%%%: 2625-block 49
    #####: 2626:        if (make_active && (clicked || double_clicked))
    %%%%%: 2626-block 50
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2626-block 51
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2626-block 52
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 2627:            SetKeyOwner(ImGuiKey_MouseLeft, id);
    %%%%%: 2627-block 53
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 2628:        if (make_active && temp_input_allowed)
    %%%%%: 2628-block 54
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2628-block 55
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2629:            if ((clicked && g.IO.KeyCtrl) || double_clicked || (g.NavActivateId == id && (g.NavActivateFlags & ImGuiActivateFlags_PreferInput)))
    %%%%%: 2629-block 56
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2629-block 57
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2629-block 58
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 2629-block 59
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 2629-block 60
branch  8 never executed (fallthrough)
branch  9 never executed
    #####: 2630:                temp_input_is_active = true;
    %%%%%: 2630-block 61
        -: 2631:
        -: 2632:        // (Optional) simple click (without moving) turns Drag into an InputText
    #####: 2633:        if (g.IO.ConfigDragClickToInputText && temp_input_allowed && !temp_input_is_active)
    %%%%%: 2633-block 62
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2633-block 63
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2633-block 64
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 2634:            if (g.ActiveId == id && hovered && g.IO.MouseReleased[0] && !IsMouseDragPastThreshold(0, g.IO.MouseDragThreshold * DRAG_MOUSE_THRESHOLD_FACTOR))
    %%%%%: 2634-block 65
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2634-block 66
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2634-block 67
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 2634-block 68
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed (throw)
    %%%%%: 2634-block 69
branch  9 never executed (fallthrough)
branch 10 never executed
    %%%%%: 2634-block 70
    %%%%%: 2634-block 71
    %%%%%: 2634-block 72
branch 11 never executed (fallthrough)
branch 12 never executed
        -: 2635:            {
    #####: 2636:                g.NavActivateId = id;
    #####: 2637:                g.NavActivateFlags = ImGuiActivateFlags_PreferInput;
    #####: 2638:                temp_input_is_active = true;
    %%%%%: 2638-block 73
        -: 2639:            }
        -: 2640:
    #####: 2641:        if (make_active && !temp_input_is_active)
    %%%%%: 2641-block 74
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2641-block 75
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 2642:        {
    #####: 2643:            SetActiveID(id, window);
    %%%%%: 2643-block 76
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 2644:            SetFocusID(id, window);
    %%%%%: 2644-block 77
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 2645:            FocusWindow(window);
    %%%%%: 2645-block 78
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 2646:            g.ActiveIdUsingNavDirMask = (1 << ImGuiDir_Left) | (1 << ImGuiDir_Right);
    %%%%%: 2646-block 79
        -: 2647:        }
        -: 2648:    }
        -: 2649:
    #####: 2650:    if (temp_input_is_active)
    %%%%%: 2650-block 80
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2651:    {
        -: 2652:        // Only clamp CTRL+Click input when ImGuiSliderFlags_ClampOnInput is set (generally via ImGuiSliderFlags_AlwaysClamp)
    #####: 2653:        bool clamp_enabled = false;
    #####: 2654:        if ((flags & ImGuiSliderFlags_ClampOnInput) && (p_min != NULL || p_max != NULL))
    %%%%%: 2654-block 81
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2654-block 82
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2654-block 83
branch  4 never executed (fallthrough)
branch  5 never executed
        -: 2655:        {
    #####: 2656:            const int clamp_range_dir = (p_min != NULL && p_max != NULL) ? DataTypeCompare(data_type, p_min, p_max) : 0; // -1 when *p_min < *p_max, == 0 when *p_min == *p_max
    %%%%%: 2656-block 84
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2656-block 85
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2656-block 86
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    %%%%%: 2656-block 87
    %%%%%: 2656-block 88
    #####: 2657:            if (p_min == NULL || p_max == NULL || clamp_range_dir < 0)
    %%%%%: 2657-block 89
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2657-block 90
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2657-block 91
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 2658:                clamp_enabled = true;
    %%%%%: 2658-block 92
    #####: 2659:            else if (clamp_range_dir == 0)
    %%%%%: 2659-block 93
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2660:                clamp_enabled = DataTypeIsZero(data_type, p_min) ? ((flags & ImGuiSliderFlags_ClampZeroRange) != 0) : true;
    %%%%%: 2660-block 94
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 2660-block 95
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 2660-block 96
    %%%%%: 2660-block 97
    %%%%%: 2660-block 98
        -: 2661:        }
    #####: 2662:        return TempInputScalar(frame_bb, id, label, data_type, p_data, format, clamp_enabled ? p_min : NULL, clamp_enabled ? p_max : NULL);
    %%%%%: 2662-block 99
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2662-block 100
    %%%%%: 2662-block 101
    %%%%%: 2662-block 102
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2662-block 103
    %%%%%: 2662-block 104
    %%%%%: 2662-block 105
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    %%%%%: 2662-block 106
        -: 2663:    }
        -: 2664:
        -: 2665:    // Draw frame
    #####: 2666:    const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);
    %%%%%: 2666-block 107
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2666-block 108
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2666-block 109
    %%%%%: 2666-block 110
    %%%%%: 2666-block 111
    %%%%%: 2666-block 112
    %%%%%: 2666-block 113
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    #####: 2667:    RenderNavCursor(frame_bb, id);
    %%%%%: 2667-block 114
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 2668:    RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, style.FrameRounding);
    %%%%%: 2668-block 115
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 2669:
        -: 2670:    // Drag behavior
    #####: 2671:    const bool value_changed = DragBehavior(id, data_type, p_data, v_speed, p_min, p_max, format, flags);
    %%%%%: 2671-block 116
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 2672:    if (value_changed)
    %%%%%: 2672-block 117
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2673:        MarkItemEdited(id);
    %%%%%: 2673-block 118
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 2674:
        -: 2675:    // Display value using user-provided display format so user can add prefix/suffix/decorations to the value.
        -: 2676:    char value_buf[64];
    #####: 2677:    const char* value_buf_end = value_buf + DataTypeFormatString(value_buf, IM_ARRAYSIZE(value_buf), data_type, p_data, format);
    %%%%%: 2677-block 119
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 2678:    if (g.LogEnabled)
    %%%%%: 2678-block 120
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2679:        LogSetNextTextDecoration("{", "}");
    %%%%%: 2679-block 121
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 2680:    RenderTextClipped(frame_bb.Min, frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f, 0.5f));
    %%%%%: 2680-block 122
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$: 2680-block 131
        -: 2681:
    #####: 2682:    if (label_size.x > 0.0f)
    %%%%%: 2682-block 124
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2683:        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);
    %%%%%: 2683-block 125
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 2683-block 127
    $$$$$: 2683-block 132
        -: 2684:
        -: 2685:    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags | (temp_input_allowed ? ImGuiItemStatusFlags_Inputable : 0));
    #####: 2686:    return value_changed;
    %%%%%: 2686-block 128
        -: 2687:}
        -: 2688:
function _ZN5ImGui11DragScalarNEPKciPvifPKvS4_S1_i called 0 returned 0% blocks executed 0%
    #####: 2689:bool ImGui::DragScalarN(const char* label, ImGuiDataType data_type, void* p_data, int components, float v_speed, const void* p_min, const void* p_max, const char* format, ImGuiSliderFlags flags)
        -: 2690:{
    #####: 2691:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%: 2691-block 2
call    0 never executed
    #####: 2692:    if (window->SkipItems)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2693:        return false;
    %%%%%: 2693-block 4
        -: 2694:
    #####: 2695:    ImGuiContext& g = *GImGui;
    #####: 2696:    bool value_changed = false;
    #####: 2697:    BeginGroup();
    %%%%%: 2697-block 5
call    0 never executed
    #####: 2698:    PushID(label);
call    0 never executed
    #####: 2699:    PushMultiItemsWidths(components, CalcItemWidth());
call    0 never executed
call    1 never executed
    #####: 2700:    size_t type_size = GDataTypeInfo[data_type].Size;
    #####: 2701:    for (int i = 0; i < components; i++)
    %%%%%: 2701-block 17
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 2702:    {
    #####: 2703:        PushID(i);
    %%%%%: 2703-block 10
call    0 never executed
    #####: 2704:        if (i > 0)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2705:            SameLine(0, g.Style.ItemInnerSpacing.x);
    %%%%%: 2705-block 12
call    0 never executed
    #####: 2706:        value_changed |= DragScalar("", data_type, p_data, v_speed, p_min, p_max, format, flags);
    %%%%%: 2706-block 13
call    0 never executed
    #####: 2707:        PopID();
call    0 never executed
    #####: 2708:        PopItemWidth();
call    0 never executed
    #####: 2709:        p_data = (void*)((char*)p_data + type_size);
        -: 2710:    }
    #####: 2711:    PopID();
    %%%%%: 2711-block 18
call    0 never executed
        -: 2712:
    #####: 2713:    const char* label_end = FindRenderedTextEnd(label);
call    0 never executed
    #####: 2714:    if (label != label_end)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2715:    {
    #####: 2716:        SameLine(0, g.Style.ItemInnerSpacing.x);
    %%%%%: 2716-block 21
call    0 never executed
    #####: 2717:        TextEx(label, label_end);
call    0 never executed
        -: 2718:    }
        -: 2719:
    #####: 2720:    EndGroup();
    %%%%%: 2720-block 23
call    0 never executed
    #####: 2721:    return value_changed;
        -: 2722:}
        -: 2723:
function _ZN5ImGui9DragFloatEPKcPffffS1_i called 0 returned 0% blocks executed 0%
    #####: 2724:bool ImGui::DragFloat(const char* label, float* v, float v_speed, float v_min, float v_max, const char* format, ImGuiSliderFlags flags)
        -: 2725:{
    #####: 2726:    return DragScalar(label, ImGuiDataType_Float, v, v_speed, &v_min, &v_max, format, flags);
    %%%%%: 2726-block 2
call    0 never executed
        -: 2727:}
        -: 2728:
function _ZN5ImGui10DragFloat2EPKcPffffS1_i called 0 returned 0% blocks executed 0%
    #####: 2729:bool ImGui::DragFloat2(const char* label, float v[2], float v_speed, float v_min, float v_max, const char* format, ImGuiSliderFlags flags)
        -: 2730:{
    #####: 2731:    return DragScalarN(label, ImGuiDataType_Float, v, 2, v_speed, &v_min, &v_max, format, flags);
    %%%%%: 2731-block 2
call    0 never executed
        -: 2732:}
        -: 2733:
function _ZN5ImGui10DragFloat3EPKcPffffS1_i called 0 returned 0% blocks executed 0%
    #####: 2734:bool ImGui::DragFloat3(const char* label, float v[3], float v_speed, float v_min, float v_max, const char* format, ImGuiSliderFlags flags)
        -: 2735:{
    #####: 2736:    return DragScalarN(label, ImGuiDataType_Float, v, 3, v_speed, &v_min, &v_max, format, flags);
    %%%%%: 2736-block 2
call    0 never executed
        -: 2737:}
        -: 2738:
function _ZN5ImGui10DragFloat4EPKcPffffS1_i called 0 returned 0% blocks executed 0%
    #####: 2739:bool ImGui::DragFloat4(const char* label, float v[4], float v_speed, float v_min, float v_max, const char* format, ImGuiSliderFlags flags)
        -: 2740:{
    #####: 2741:    return DragScalarN(label, ImGuiDataType_Float, v, 4, v_speed, &v_min, &v_max, format, flags);
    %%%%%: 2741-block 2
call    0 never executed
        -: 2742:}
        -: 2743:
        -: 2744:// NB: You likely want to specify the ImGuiSliderFlags_AlwaysClamp when using this.
function _ZN5ImGui15DragFloatRange2EPKcPfS2_fffS1_S1_i called 0 returned 0% blocks executed 0%
    #####: 2745:bool ImGui::DragFloatRange2(const char* label, float* v_current_min, float* v_current_max, float v_speed, float v_min, float v_max, const char* format, const char* format_max, ImGuiSliderFlags flags)
        -: 2746:{
    #####: 2747:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%: 2747-block 2
call    0 never executed
    #####: 2748:    if (window->SkipItems)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2749:        return false;
    %%%%%: 2749-block 4
        -: 2750:
    #####: 2751:    ImGuiContext& g = *GImGui;
    #####: 2752:    PushID(label);
    %%%%%: 2752-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 2753:    BeginGroup();
    %%%%%: 2753-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 2754:    PushMultiItemsWidths(2, CalcItemWidth());
    %%%%%: 2754-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 2754-block 8
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
        -: 2755:
    #####: 2756:    float min_min = (v_min >= v_max) ? -FLT_MAX : v_min;
    %%%%%: 2756-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2756-block 10
    %%%%%: 2756-block 11
    #####: 2757:    float min_max = (v_min >= v_max) ? *v_current_max : ImMin(v_max, *v_current_max);
    %%%%%: 2757-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2757-block 13
    %%%%%: 2757-block 14
call    2 never executed
    #####: 2758:    ImGuiSliderFlags min_flags = flags | ((min_min == min_max) ? ImGuiSliderFlags_ReadOnly : 0);
    %%%%%: 2758-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2758-block 16
    %%%%%: 2758-block 17
    #####: 2759:    bool value_changed = DragScalar("##min", ImGuiDataType_Float, v_current_min, v_speed, &min_min, &min_max, format, min_flags);
    %%%%%: 2759-block 18
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 2760:    PopItemWidth();
    %%%%%: 2760-block 19
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 2761:    SameLine(0, g.Style.ItemInnerSpacing.x);
    %%%%%: 2761-block 20
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 2762:
    #####: 2763:    float max_min = (v_min >= v_max) ? *v_current_min : ImMax(v_min, *v_current_min);
    %%%%%: 2763-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2763-block 22
    %%%%%: 2763-block 23
call    2 never executed
    #####: 2764:    float max_max = (v_min >= v_max) ? FLT_MAX : v_max;
    %%%%%: 2764-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2764-block 25
    %%%%%: 2764-block 26
    #####: 2765:    ImGuiSliderFlags max_flags = flags | ((max_min == max_max) ? ImGuiSliderFlags_ReadOnly : 0);
    %%%%%: 2765-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2765-block 28
    %%%%%: 2765-block 29
    #####: 2766:    value_changed |= DragScalar("##max", ImGuiDataType_Float, v_current_max, v_speed, &max_min, &max_max, format_max ? format_max : format, max_flags);
    %%%%%: 2766-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2766-block 31
    %%%%%: 2766-block 32
    %%%%%: 2766-block 33
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####: 2767:    PopItemWidth();
    %%%%%: 2767-block 34
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 2768:    SameLine(0, g.Style.ItemInnerSpacing.x);
    %%%%%: 2768-block 35
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 2769:
    #####: 2770:    TextEx(label, FindRenderedTextEnd(label));
    %%%%%: 2770-block 36
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 2770-block 37
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    #####: 2771:    EndGroup();
    %%%%%: 2771-block 38
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 2772:    PopID();
    %%%%%: 2772-block 39
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 2773:
    #####: 2774:    return value_changed;
    %%%%%: 2774-block 40
        -: 2775:}
        -: 2776:
        -: 2777:// NB: v_speed is float to allow adjusting the drag speed with more precision
function _ZN5ImGui7DragIntEPKcPifiiS1_i called 0 returned 0% blocks executed 0%
    #####: 2778:bool ImGui::DragInt(const char* label, int* v, float v_speed, int v_min, int v_max, const char* format, ImGuiSliderFlags flags)
        -: 2779:{
    #####: 2780:    return DragScalar(label, ImGuiDataType_S32, v, v_speed, &v_min, &v_max, format, flags);
    %%%%%: 2780-block 2
call    0 never executed
        -: 2781:}
        -: 2782:
function _ZN5ImGui8DragInt2EPKcPifiiS1_i called 0 returned 0% blocks executed 0%
    #####: 2783:bool ImGui::DragInt2(const char* label, int v[2], float v_speed, int v_min, int v_max, const char* format, ImGuiSliderFlags flags)
        -: 2784:{
    #####: 2785:    return DragScalarN(label, ImGuiDataType_S32, v, 2, v_speed, &v_min, &v_max, format, flags);
    %%%%%: 2785-block 2
call    0 never executed
        -: 2786:}
        -: 2787:
function _ZN5ImGui8DragInt3EPKcPifiiS1_i called 0 returned 0% blocks executed 0%
    #####: 2788:bool ImGui::DragInt3(const char* label, int v[3], float v_speed, int v_min, int v_max, const char* format, ImGuiSliderFlags flags)
        -: 2789:{
    #####: 2790:    return DragScalarN(label, ImGuiDataType_S32, v, 3, v_speed, &v_min, &v_max, format, flags);
    %%%%%: 2790-block 2
call    0 never executed
        -: 2791:}
        -: 2792:
function _ZN5ImGui8DragInt4EPKcPifiiS1_i called 0 returned 0% blocks executed 0%
    #####: 2793:bool ImGui::DragInt4(const char* label, int v[4], float v_speed, int v_min, int v_max, const char* format, ImGuiSliderFlags flags)
        -: 2794:{
    #####: 2795:    return DragScalarN(label, ImGuiDataType_S32, v, 4, v_speed, &v_min, &v_max, format, flags);
    %%%%%: 2795-block 2
call    0 never executed
        -: 2796:}
        -: 2797:
        -: 2798:// NB: You likely want to specify the ImGuiSliderFlags_AlwaysClamp when using this.
function _ZN5ImGui13DragIntRange2EPKcPiS2_fiiS1_S1_i called 0 returned 0% blocks executed 0%
    #####: 2799:bool ImGui::DragIntRange2(const char* label, int* v_current_min, int* v_current_max, float v_speed, int v_min, int v_max, const char* format, const char* format_max, ImGuiSliderFlags flags)
        -: 2800:{
    #####: 2801:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%: 2801-block 2
call    0 never executed
    #####: 2802:    if (window->SkipItems)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2803:        return false;
    %%%%%: 2803-block 4
        -: 2804:
    #####: 2805:    ImGuiContext& g = *GImGui;
    #####: 2806:    PushID(label);
    %%%%%: 2806-block 5
call    0 never executed
    #####: 2807:    BeginGroup();
call    0 never executed
    #####: 2808:    PushMultiItemsWidths(2, CalcItemWidth());
call    0 never executed
call    1 never executed
        -: 2809:
    #####: 2810:    int min_min = (v_min >= v_max) ? INT_MIN : v_min;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2810-block 10
    %%%%%: 2810-block 11
    #####: 2811:    int min_max = (v_min >= v_max) ? *v_current_max : ImMin(v_max, *v_current_max);
    %%%%%: 2811-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2811-block 13
    %%%%%: 2811-block 14
call    2 never executed
    #####: 2812:    ImGuiSliderFlags min_flags = flags | ((min_min == min_max) ? ImGuiSliderFlags_ReadOnly : 0);
    %%%%%: 2812-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2812-block 16
    %%%%%: 2812-block 17
    #####: 2813:    bool value_changed = DragInt("##min", v_current_min, v_speed, min_min, min_max, format, min_flags);
    %%%%%: 2813-block 18
call    0 never executed
    #####: 2814:    PopItemWidth();
call    0 never executed
    #####: 2815:    SameLine(0, g.Style.ItemInnerSpacing.x);
call    0 never executed
        -: 2816:
    #####: 2817:    int max_min = (v_min >= v_max) ? *v_current_min : ImMax(v_min, *v_current_min);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2817-block 22
    %%%%%: 2817-block 23
call    2 never executed
    #####: 2818:    int max_max = (v_min >= v_max) ? INT_MAX : v_max;
    %%%%%: 2818-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2818-block 25
    %%%%%: 2818-block 26
    #####: 2819:    ImGuiSliderFlags max_flags = flags | ((max_min == max_max) ? ImGuiSliderFlags_ReadOnly : 0);
    %%%%%: 2819-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2819-block 28
    %%%%%: 2819-block 29
    #####: 2820:    value_changed |= DragInt("##max", v_current_max, v_speed, max_min, max_max, format_max ? format_max : format, max_flags);
    %%%%%: 2820-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2820-block 31
    %%%%%: 2820-block 32
    %%%%%: 2820-block 33
call    2 never executed
    #####: 2821:    PopItemWidth();
call    0 never executed
    #####: 2822:    SameLine(0, g.Style.ItemInnerSpacing.x);
call    0 never executed
        -: 2823:
    #####: 2824:    TextEx(label, FindRenderedTextEnd(label));
call    0 never executed
call    1 never executed
    #####: 2825:    EndGroup();
call    0 never executed
    #####: 2826:    PopID();
call    0 never executed
        -: 2827:
    #####: 2828:    return value_changed;
        -: 2829:}
        -: 2830:
        -: 2831://-------------------------------------------------------------------------
        -: 2832:// [SECTION] Widgets: SliderScalar, SliderFloat, SliderInt, etc.
        -: 2833://-------------------------------------------------------------------------
        -: 2834:// - ScaleRatioFromValueT<> [Internal]
        -: 2835:// - ScaleValueFromRatioT<> [Internal]
        -: 2836:// - SliderBehaviorT<>() [Internal]
        -: 2837:// - SliderBehavior() [Internal]
        -: 2838:// - SliderScalar()
        -: 2839:// - SliderScalarN()
        -: 2840:// - SliderFloat()
        -: 2841:// - SliderFloat2()
        -: 2842:// - SliderFloat3()
        -: 2843:// - SliderFloat4()
        -: 2844:// - SliderAngle()
        -: 2845:// - SliderInt()
        -: 2846:// - SliderInt2()
        -: 2847:// - SliderInt3()
        -: 2848:// - SliderInt4()
        -: 2849:// - VSliderScalar()
        -: 2850:// - VSliderFloat()
        -: 2851:// - VSliderInt()
        -: 2852://-------------------------------------------------------------------------
        -: 2853:
        -: 2854:// Convert a value v in the output space of a slider into a parametric position on the slider itself (the logical opposite of ScaleValueFromRatioT)
        -: 2855:template<typename TYPE, typename SIGNEDTYPE, typename FLOATTYPE>
    #####: 2856:float ImGui::ScaleRatioFromValueT(ImGuiDataType data_type, TYPE v, TYPE v_min, TYPE v_max, bool is_logarithmic, float logarithmic_zero_epsilon, float zero_deadzone_halfsize)
        -: 2857:{
    #####: 2858:    if (v_min == v_max)
    #####: 2859:        return 0.0f;
        -: 2860:    IM_UNUSED(data_type);
        -: 2861:
    #####: 2862:    const TYPE v_clamped = (v_min < v_max) ? ImClamp(v, v_min, v_max) : ImClamp(v, v_max, v_min);
    #####: 2863:    if (is_logarithmic)
        -: 2864:    {
    #####: 2865:        bool flipped = v_max < v_min;
        -: 2866:
    #####: 2867:        if (flipped) // Handle the case where the range is backwards
    #####: 2868:            ImSwap(v_min, v_max);
        -: 2869:
        -: 2870:        // Fudge min/max to avoid getting close to log(0)
    #####: 2871:        FLOATTYPE v_min_fudged = (ImAbs((FLOATTYPE)v_min) < logarithmic_zero_epsilon) ? ((v_min < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_min;
    #####: 2872:        FLOATTYPE v_max_fudged = (ImAbs((FLOATTYPE)v_max) < logarithmic_zero_epsilon) ? ((v_max < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_max;
        -: 2873:
        -: 2874:        // Awkward special cases - we need ranges of the form (-100 .. 0) to convert to (-100 .. -epsilon), not (-100 .. epsilon)
    #####: 2875:        if ((v_min == 0.0f) && (v_max < 0.0f))
    #####: 2876:            v_min_fudged = -logarithmic_zero_epsilon;
    #####: 2877:        else if ((v_max == 0.0f) && (v_min < 0.0f))
    #####: 2878:            v_max_fudged = -logarithmic_zero_epsilon;
        -: 2879:
        -: 2880:        float result;
    #####: 2881:        if (v_clamped <= v_min_fudged)
    #####: 2882:            result = 0.0f; // Workaround for values that are in-range but below our fudge
    #####: 2883:        else if (v_clamped >= v_max_fudged)
    #####: 2884:            result = 1.0f; // Workaround for values that are in-range but above our fudge
    #####: 2885:        else if ((v_min * v_max) < 0.0f) // Range crosses zero, so split into two portions
        -: 2886:        {
    #####: 2887:            float zero_point_center = (-(float)v_min) / ((float)v_max - (float)v_min); // The zero point in parametric space.  There's an argument we should take the logarithmic nature into account when calculating this, but for now this should do (and the most common case of a symmetrical range works fine)
    #####: 2888:            float zero_point_snap_L = zero_point_center - zero_deadzone_halfsize;
    #####: 2889:            float zero_point_snap_R = zero_point_center + zero_deadzone_halfsize;
    #####: 2890:            if (v == 0.0f)
    #####: 2891:                result = zero_point_center; // Special case for exactly zero
    #####: 2892:            else if (v < 0.0f)
    #####: 2893:                result = (1.0f - (float)(ImLog(-(FLOATTYPE)v_clamped / logarithmic_zero_epsilon) / ImLog(-v_min_fudged / logarithmic_zero_epsilon))) * zero_point_snap_L;
        -: 2894:            else
    #####: 2895:                result = zero_point_snap_R + ((float)(ImLog((FLOATTYPE)v_clamped / logarithmic_zero_epsilon) / ImLog(v_max_fudged / logarithmic_zero_epsilon)) * (1.0f - zero_point_snap_R));
        -: 2896:        }
    #####: 2897:        else if ((v_min < 0.0f) || (v_max < 0.0f)) // Entirely negative slider
    #####: 2898:            result = 1.0f - (float)(ImLog(-(FLOATTYPE)v_clamped / -v_max_fudged) / ImLog(-v_min_fudged / -v_max_fudged));
        -: 2899:        else
    #####: 2900:            result = (float)(ImLog((FLOATTYPE)v_clamped / v_min_fudged) / ImLog(v_max_fudged / v_min_fudged));
        -: 2901:
    #####: 2902:        return flipped ? (1.0f - result) : result;
        -: 2903:    }
        -: 2904:    else
        -: 2905:    {
        -: 2906:        // Linear slider
    #####: 2907:        return (float)((FLOATTYPE)(SIGNEDTYPE)(v_clamped - v_min) / (FLOATTYPE)(SIGNEDTYPE)(v_max - v_min));
        -: 2908:    }
        -: 2909:}
------------------
_ZN5ImGui20ScaleRatioFromValueTIdddEEfiT_S1_S1_bff:
function _ZN5ImGui20ScaleRatioFromValueTIdddEEfiT_S1_S1_bff called 0 returned 0% blocks executed 0%
    #####: 2856:float ImGui::ScaleRatioFromValueT(ImGuiDataType data_type, TYPE v, TYPE v_min, TYPE v_max, bool is_logarithmic, float logarithmic_zero_epsilon, float zero_deadzone_halfsize)
        -: 2857:{
    #####: 2858:    if (v_min == v_max)
    %%%%%: 2858-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2859:        return 0.0f;
    %%%%%: 2859-block 3
        -: 2860:    IM_UNUSED(data_type);
        -: 2861:
    #####: 2862:    const TYPE v_clamped = (v_min < v_max) ? ImClamp(v, v_min, v_max) : ImClamp(v, v_max, v_min);
    %%%%%: 2862-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2862-block 5
call    2 never executed
    %%%%%: 2862-block 6
call    3 never executed
    #####: 2863:    if (is_logarithmic)
    %%%%%: 2863-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2864:    {
    #####: 2865:        bool flipped = v_max < v_min;
        -: 2866:
    #####: 2867:        if (flipped) // Handle the case where the range is backwards
    %%%%%: 2867-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2868:            ImSwap(v_min, v_max);
    %%%%%: 2868-block 9
call    0 never executed
        -: 2869:
        -: 2870:        // Fudge min/max to avoid getting close to log(0)
    #####: 2871:        FLOATTYPE v_min_fudged = (ImAbs((FLOATTYPE)v_min) < logarithmic_zero_epsilon) ? ((v_min < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_min;
    %%%%%: 2871-block 10
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 2871-block 12
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 2871-block 13
    %%%%%: 2871-block 14
    %%%%%: 2871-block 15
    %%%%%: 2871-block 16
    #####: 2872:        FLOATTYPE v_max_fudged = (ImAbs((FLOATTYPE)v_max) < logarithmic_zero_epsilon) ? ((v_max < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_max;
    %%%%%: 2872-block 17
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 2872-block 19
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 2872-block 20
    %%%%%: 2872-block 21
    %%%%%: 2872-block 22
    %%%%%: 2872-block 23
        -: 2873:
        -: 2874:        // Awkward special cases - we need ranges of the form (-100 .. 0) to convert to (-100 .. -epsilon), not (-100 .. epsilon)
    #####: 2875:        if ((v_min == 0.0f) && (v_max < 0.0f))
    %%%%%: 2875-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2875-block 25
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2876:            v_min_fudged = -logarithmic_zero_epsilon;
    %%%%%: 2876-block 26
    #####: 2877:        else if ((v_max == 0.0f) && (v_min < 0.0f))
    %%%%%: 2877-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2877-block 28
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2878:            v_max_fudged = -logarithmic_zero_epsilon;
    %%%%%: 2878-block 29
        -: 2879:
        -: 2880:        float result;
    #####: 2881:        if (v_clamped <= v_min_fudged)
    %%%%%: 2881-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2882:            result = 0.0f; // Workaround for values that are in-range but below our fudge
    %%%%%: 2882-block 31
    #####: 2883:        else if (v_clamped >= v_max_fudged)
    %%%%%: 2883-block 32
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2884:            result = 1.0f; // Workaround for values that are in-range but above our fudge
    %%%%%: 2884-block 33
    #####: 2885:        else if ((v_min * v_max) < 0.0f) // Range crosses zero, so split into two portions
    %%%%%: 2885-block 34
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2886:        {
    #####: 2887:            float zero_point_center = (-(float)v_min) / ((float)v_max - (float)v_min); // The zero point in parametric space.  There's an argument we should take the logarithmic nature into account when calculating this, but for now this should do (and the most common case of a symmetrical range works fine)
    #####: 2888:            float zero_point_snap_L = zero_point_center - zero_deadzone_halfsize;
    #####: 2889:            float zero_point_snap_R = zero_point_center + zero_deadzone_halfsize;
    #####: 2890:            if (v == 0.0f)
    %%%%%: 2890-block 35
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2891:                result = zero_point_center; // Special case for exactly zero
    %%%%%: 2891-block 36
    #####: 2892:            else if (v < 0.0f)
    %%%%%: 2892-block 37
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2893:                result = (1.0f - (float)(ImLog(-(FLOATTYPE)v_clamped / logarithmic_zero_epsilon) / ImLog(-v_min_fudged / logarithmic_zero_epsilon))) * zero_point_snap_L;
    %%%%%: 2893-block 38
call    0 never executed
call    1 never executed
        -: 2894:            else
    #####: 2895:                result = zero_point_snap_R + ((float)(ImLog((FLOATTYPE)v_clamped / logarithmic_zero_epsilon) / ImLog(v_max_fudged / logarithmic_zero_epsilon)) * (1.0f - zero_point_snap_R));
    %%%%%: 2895-block 41
call    0 never executed
call    1 never executed
        -: 2896:        }
    #####: 2897:        else if ((v_min < 0.0f) || (v_max < 0.0f)) // Entirely negative slider
    %%%%%: 2897-block 44
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2897-block 45
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2898:            result = 1.0f - (float)(ImLog(-(FLOATTYPE)v_clamped / -v_max_fudged) / ImLog(-v_min_fudged / -v_max_fudged));
    %%%%%: 2898-block 46
call    0 never executed
call    1 never executed
        -: 2899:        else
    #####: 2900:            result = (float)(ImLog((FLOATTYPE)v_clamped / v_min_fudged) / ImLog(v_max_fudged / v_min_fudged));
    %%%%%: 2900-block 49
call    0 never executed
call    1 never executed
        -: 2901:
    #####: 2902:        return flipped ? (1.0f - result) : result;
    %%%%%: 2902-block 52
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2902-block 53
    %%%%%: 2902-block 54
    %%%%%: 2902-block 55
        -: 2903:    }
        -: 2904:    else
        -: 2905:    {
        -: 2906:        // Linear slider
    #####: 2907:        return (float)((FLOATTYPE)(SIGNEDTYPE)(v_clamped - v_min) / (FLOATTYPE)(SIGNEDTYPE)(v_max - v_min));
    %%%%%: 2907-block 56
        -: 2908:    }
        -: 2909:}
------------------
_ZN5ImGui20ScaleRatioFromValueTIfffEEfiT_S1_S1_bff:
function _ZN5ImGui20ScaleRatioFromValueTIfffEEfiT_S1_S1_bff called 0 returned 0% blocks executed 0%
    #####: 2856:float ImGui::ScaleRatioFromValueT(ImGuiDataType data_type, TYPE v, TYPE v_min, TYPE v_max, bool is_logarithmic, float logarithmic_zero_epsilon, float zero_deadzone_halfsize)
        -: 2857:{
    #####: 2858:    if (v_min == v_max)
    %%%%%: 2858-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2859:        return 0.0f;
    %%%%%: 2859-block 3
        -: 2860:    IM_UNUSED(data_type);
        -: 2861:
    #####: 2862:    const TYPE v_clamped = (v_min < v_max) ? ImClamp(v, v_min, v_max) : ImClamp(v, v_max, v_min);
    %%%%%: 2862-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2862-block 5
call    2 never executed
    %%%%%: 2862-block 6
call    3 never executed
    #####: 2863:    if (is_logarithmic)
    %%%%%: 2863-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2864:    {
    #####: 2865:        bool flipped = v_max < v_min;
        -: 2866:
    #####: 2867:        if (flipped) // Handle the case where the range is backwards
    %%%%%: 2867-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2868:            ImSwap(v_min, v_max);
    %%%%%: 2868-block 9
call    0 never executed
        -: 2869:
        -: 2870:        // Fudge min/max to avoid getting close to log(0)
    #####: 2871:        FLOATTYPE v_min_fudged = (ImAbs((FLOATTYPE)v_min) < logarithmic_zero_epsilon) ? ((v_min < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_min;
    %%%%%: 2871-block 10
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 2871-block 12
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 2871-block 13
    %%%%%: 2871-block 14
    %%%%%: 2871-block 15
    %%%%%: 2871-block 16
    #####: 2872:        FLOATTYPE v_max_fudged = (ImAbs((FLOATTYPE)v_max) < logarithmic_zero_epsilon) ? ((v_max < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_max;
    %%%%%: 2872-block 17
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 2872-block 19
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 2872-block 20
    %%%%%: 2872-block 21
    %%%%%: 2872-block 22
    %%%%%: 2872-block 23
        -: 2873:
        -: 2874:        // Awkward special cases - we need ranges of the form (-100 .. 0) to convert to (-100 .. -epsilon), not (-100 .. epsilon)
    #####: 2875:        if ((v_min == 0.0f) && (v_max < 0.0f))
    %%%%%: 2875-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2875-block 25
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2876:            v_min_fudged = -logarithmic_zero_epsilon;
    %%%%%: 2876-block 26
    #####: 2877:        else if ((v_max == 0.0f) && (v_min < 0.0f))
    %%%%%: 2877-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2877-block 28
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2878:            v_max_fudged = -logarithmic_zero_epsilon;
    %%%%%: 2878-block 29
        -: 2879:
        -: 2880:        float result;
    #####: 2881:        if (v_clamped <= v_min_fudged)
    %%%%%: 2881-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2882:            result = 0.0f; // Workaround for values that are in-range but below our fudge
    %%%%%: 2882-block 31
    #####: 2883:        else if (v_clamped >= v_max_fudged)
    %%%%%: 2883-block 32
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2884:            result = 1.0f; // Workaround for values that are in-range but above our fudge
    %%%%%: 2884-block 33
    #####: 2885:        else if ((v_min * v_max) < 0.0f) // Range crosses zero, so split into two portions
    %%%%%: 2885-block 34
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2886:        {
    #####: 2887:            float zero_point_center = (-(float)v_min) / ((float)v_max - (float)v_min); // The zero point in parametric space.  There's an argument we should take the logarithmic nature into account when calculating this, but for now this should do (and the most common case of a symmetrical range works fine)
    #####: 2888:            float zero_point_snap_L = zero_point_center - zero_deadzone_halfsize;
    #####: 2889:            float zero_point_snap_R = zero_point_center + zero_deadzone_halfsize;
    #####: 2890:            if (v == 0.0f)
    %%%%%: 2890-block 35
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2891:                result = zero_point_center; // Special case for exactly zero
    %%%%%: 2891-block 36
    #####: 2892:            else if (v < 0.0f)
    %%%%%: 2892-block 37
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2893:                result = (1.0f - (float)(ImLog(-(FLOATTYPE)v_clamped / logarithmic_zero_epsilon) / ImLog(-v_min_fudged / logarithmic_zero_epsilon))) * zero_point_snap_L;
    %%%%%: 2893-block 38
call    0 never executed
call    1 never executed
        -: 2894:            else
    #####: 2895:                result = zero_point_snap_R + ((float)(ImLog((FLOATTYPE)v_clamped / logarithmic_zero_epsilon) / ImLog(v_max_fudged / logarithmic_zero_epsilon)) * (1.0f - zero_point_snap_R));
    %%%%%: 2895-block 41
call    0 never executed
call    1 never executed
        -: 2896:        }
    #####: 2897:        else if ((v_min < 0.0f) || (v_max < 0.0f)) // Entirely negative slider
    %%%%%: 2897-block 44
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2897-block 45
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2898:            result = 1.0f - (float)(ImLog(-(FLOATTYPE)v_clamped / -v_max_fudged) / ImLog(-v_min_fudged / -v_max_fudged));
    %%%%%: 2898-block 46
call    0 never executed
call    1 never executed
        -: 2899:        else
    #####: 2900:            result = (float)(ImLog((FLOATTYPE)v_clamped / v_min_fudged) / ImLog(v_max_fudged / v_min_fudged));
    %%%%%: 2900-block 49
call    0 never executed
call    1 never executed
        -: 2901:
    #####: 2902:        return flipped ? (1.0f - result) : result;
    %%%%%: 2902-block 52
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2902-block 53
    %%%%%: 2902-block 54
    %%%%%: 2902-block 55
        -: 2903:    }
        -: 2904:    else
        -: 2905:    {
        -: 2906:        // Linear slider
    #####: 2907:        return (float)((FLOATTYPE)(SIGNEDTYPE)(v_clamped - v_min) / (FLOATTYPE)(SIGNEDTYPE)(v_max - v_min));
    %%%%%: 2907-block 56
        -: 2908:    }
        -: 2909:}
------------------
_ZN5ImGui20ScaleRatioFromValueTIyxdEEfiT_S1_S1_bff:
function _ZN5ImGui20ScaleRatioFromValueTIyxdEEfiT_S1_S1_bff called 0 returned 0% blocks executed 0%
    #####: 2856:float ImGui::ScaleRatioFromValueT(ImGuiDataType data_type, TYPE v, TYPE v_min, TYPE v_max, bool is_logarithmic, float logarithmic_zero_epsilon, float zero_deadzone_halfsize)
        -: 2857:{
    #####: 2858:    if (v_min == v_max)
    %%%%%: 2858-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2859:        return 0.0f;
    %%%%%: 2859-block 3
        -: 2860:    IM_UNUSED(data_type);
        -: 2861:
    #####: 2862:    const TYPE v_clamped = (v_min < v_max) ? ImClamp(v, v_min, v_max) : ImClamp(v, v_max, v_min);
    %%%%%: 2862-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2862-block 5
call    2 never executed
    %%%%%: 2862-block 6
call    3 never executed
    #####: 2863:    if (is_logarithmic)
    %%%%%: 2863-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2864:    {
    #####: 2865:        bool flipped = v_max < v_min;
        -: 2866:
    #####: 2867:        if (flipped) // Handle the case where the range is backwards
    %%%%%: 2867-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2868:            ImSwap(v_min, v_max);
    %%%%%: 2868-block 9
call    0 never executed
        -: 2869:
        -: 2870:        // Fudge min/max to avoid getting close to log(0)
    #####: 2871:        FLOATTYPE v_min_fudged = (ImAbs((FLOATTYPE)v_min) < logarithmic_zero_epsilon) ? ((v_min < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_min;
    %%%%%: 2871-block 10
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 2871-block 12
    %%%%%: 2871-block 13
    #####: 2872:        FLOATTYPE v_max_fudged = (ImAbs((FLOATTYPE)v_max) < logarithmic_zero_epsilon) ? ((v_max < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_max;
    %%%%%: 2872-block 14
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 2872-block 16
    %%%%%: 2872-block 17
    %%%%%: 2872-block 18
        -: 2873:
        -: 2874:        // Awkward special cases - we need ranges of the form (-100 .. 0) to convert to (-100 .. -epsilon), not (-100 .. epsilon)
        -: 2875:        if ((v_min == 0.0f) && (v_max < 0.0f))
        -: 2876:            v_min_fudged = -logarithmic_zero_epsilon;
        -: 2877:        else if ((v_max == 0.0f) && (v_min < 0.0f))
        -: 2878:            v_max_fudged = -logarithmic_zero_epsilon;
        -: 2879:
        -: 2880:        float result;
    #####: 2881:        if (v_clamped <= v_min_fudged)
    %%%%%: 2881-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2882:            result = 0.0f; // Workaround for values that are in-range but below our fudge
    %%%%%: 2882-block 20
    #####: 2883:        else if (v_clamped >= v_max_fudged)
    %%%%%: 2883-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2884:            result = 1.0f; // Workaround for values that are in-range but above our fudge
    %%%%%: 2884-block 22
        -: 2885:        else if ((v_min * v_max) < 0.0f) // Range crosses zero, so split into two portions
        -: 2886:        {
        -: 2887:            float zero_point_center = (-(float)v_min) / ((float)v_max - (float)v_min); // The zero point in parametric space.  There's an argument we should take the logarithmic nature into account when calculating this, but for now this should do (and the most common case of a symmetrical range works fine)
        -: 2888:            float zero_point_snap_L = zero_point_center - zero_deadzone_halfsize;
        -: 2889:            float zero_point_snap_R = zero_point_center + zero_deadzone_halfsize;
        -: 2890:            if (v == 0.0f)
        -: 2891:                result = zero_point_center; // Special case for exactly zero
        -: 2892:            else if (v < 0.0f)
        -: 2893:                result = (1.0f - (float)(ImLog(-(FLOATTYPE)v_clamped / logarithmic_zero_epsilon) / ImLog(-v_min_fudged / logarithmic_zero_epsilon))) * zero_point_snap_L;
        -: 2894:            else
        -: 2895:                result = zero_point_snap_R + ((float)(ImLog((FLOATTYPE)v_clamped / logarithmic_zero_epsilon) / ImLog(v_max_fudged / logarithmic_zero_epsilon)) * (1.0f - zero_point_snap_R));
        -: 2896:        }
        -: 2897:        else if ((v_min < 0.0f) || (v_max < 0.0f)) // Entirely negative slider
        -: 2898:            result = 1.0f - (float)(ImLog(-(FLOATTYPE)v_clamped / -v_max_fudged) / ImLog(-v_min_fudged / -v_max_fudged));
        -: 2899:        else
    #####: 2900:            result = (float)(ImLog((FLOATTYPE)v_clamped / v_min_fudged) / ImLog(v_max_fudged / v_min_fudged));
    %%%%%: 2900-block 23
call    0 never executed
call    1 never executed
        -: 2901:
    #####: 2902:        return flipped ? (1.0f - result) : result;
    %%%%%: 2902-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2902-block 27
    %%%%%: 2902-block 28
    %%%%%: 2902-block 29
        -: 2903:    }
        -: 2904:    else
        -: 2905:    {
        -: 2906:        // Linear slider
    #####: 2907:        return (float)((FLOATTYPE)(SIGNEDTYPE)(v_clamped - v_min) / (FLOATTYPE)(SIGNEDTYPE)(v_max - v_min));
    %%%%%: 2907-block 30
        -: 2908:    }
        -: 2909:}
------------------
_ZN5ImGui20ScaleRatioFromValueTIxxdEEfiT_S1_S1_bff:
function _ZN5ImGui20ScaleRatioFromValueTIxxdEEfiT_S1_S1_bff called 0 returned 0% blocks executed 0%
    #####: 2856:float ImGui::ScaleRatioFromValueT(ImGuiDataType data_type, TYPE v, TYPE v_min, TYPE v_max, bool is_logarithmic, float logarithmic_zero_epsilon, float zero_deadzone_halfsize)
        -: 2857:{
    #####: 2858:    if (v_min == v_max)
    %%%%%: 2858-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2859:        return 0.0f;
    %%%%%: 2859-block 3
        -: 2860:    IM_UNUSED(data_type);
        -: 2861:
    #####: 2862:    const TYPE v_clamped = (v_min < v_max) ? ImClamp(v, v_min, v_max) : ImClamp(v, v_max, v_min);
    %%%%%: 2862-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2862-block 5
call    2 never executed
    %%%%%: 2862-block 6
call    3 never executed
    #####: 2863:    if (is_logarithmic)
    %%%%%: 2863-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2864:    {
    #####: 2865:        bool flipped = v_max < v_min;
        -: 2866:
    #####: 2867:        if (flipped) // Handle the case where the range is backwards
    %%%%%: 2867-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2868:            ImSwap(v_min, v_max);
    %%%%%: 2868-block 9
call    0 never executed
        -: 2869:
        -: 2870:        // Fudge min/max to avoid getting close to log(0)
    #####: 2871:        FLOATTYPE v_min_fudged = (ImAbs((FLOATTYPE)v_min) < logarithmic_zero_epsilon) ? ((v_min < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_min;
    %%%%%: 2871-block 10
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 2871-block 12
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 2871-block 13
    %%%%%: 2871-block 14
    %%%%%: 2871-block 15
    %%%%%: 2871-block 16
    #####: 2872:        FLOATTYPE v_max_fudged = (ImAbs((FLOATTYPE)v_max) < logarithmic_zero_epsilon) ? ((v_max < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_max;
    %%%%%: 2872-block 17
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 2872-block 19
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 2872-block 20
    %%%%%: 2872-block 21
    %%%%%: 2872-block 22
    %%%%%: 2872-block 23
        -: 2873:
        -: 2874:        // Awkward special cases - we need ranges of the form (-100 .. 0) to convert to (-100 .. -epsilon), not (-100 .. epsilon)
    #####: 2875:        if ((v_min == 0.0f) && (v_max < 0.0f))
    %%%%%: 2875-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2875-block 25
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2876:            v_min_fudged = -logarithmic_zero_epsilon;
    %%%%%: 2876-block 26
    #####: 2877:        else if ((v_max == 0.0f) && (v_min < 0.0f))
    %%%%%: 2877-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2877-block 28
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2878:            v_max_fudged = -logarithmic_zero_epsilon;
    %%%%%: 2878-block 29
        -: 2879:
        -: 2880:        float result;
    #####: 2881:        if (v_clamped <= v_min_fudged)
    %%%%%: 2881-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2882:            result = 0.0f; // Workaround for values that are in-range but below our fudge
    %%%%%: 2882-block 31
    #####: 2883:        else if (v_clamped >= v_max_fudged)
    %%%%%: 2883-block 32
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2884:            result = 1.0f; // Workaround for values that are in-range but above our fudge
    %%%%%: 2884-block 33
    #####: 2885:        else if ((v_min * v_max) < 0.0f) // Range crosses zero, so split into two portions
    %%%%%: 2885-block 34
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2886:        {
    #####: 2887:            float zero_point_center = (-(float)v_min) / ((float)v_max - (float)v_min); // The zero point in parametric space.  There's an argument we should take the logarithmic nature into account when calculating this, but for now this should do (and the most common case of a symmetrical range works fine)
    #####: 2888:            float zero_point_snap_L = zero_point_center - zero_deadzone_halfsize;
    #####: 2889:            float zero_point_snap_R = zero_point_center + zero_deadzone_halfsize;
    #####: 2890:            if (v == 0.0f)
    %%%%%: 2890-block 35
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2891:                result = zero_point_center; // Special case for exactly zero
    %%%%%: 2891-block 36
    #####: 2892:            else if (v < 0.0f)
    %%%%%: 2892-block 37
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2893:                result = (1.0f - (float)(ImLog(-(FLOATTYPE)v_clamped / logarithmic_zero_epsilon) / ImLog(-v_min_fudged / logarithmic_zero_epsilon))) * zero_point_snap_L;
    %%%%%: 2893-block 38
call    0 never executed
call    1 never executed
        -: 2894:            else
    #####: 2895:                result = zero_point_snap_R + ((float)(ImLog((FLOATTYPE)v_clamped / logarithmic_zero_epsilon) / ImLog(v_max_fudged / logarithmic_zero_epsilon)) * (1.0f - zero_point_snap_R));
    %%%%%: 2895-block 41
call    0 never executed
call    1 never executed
        -: 2896:        }
    #####: 2897:        else if ((v_min < 0.0f) || (v_max < 0.0f)) // Entirely negative slider
    %%%%%: 2897-block 44
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2897-block 45
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2898:            result = 1.0f - (float)(ImLog(-(FLOATTYPE)v_clamped / -v_max_fudged) / ImLog(-v_min_fudged / -v_max_fudged));
    %%%%%: 2898-block 46
call    0 never executed
call    1 never executed
        -: 2899:        else
    #####: 2900:            result = (float)(ImLog((FLOATTYPE)v_clamped / v_min_fudged) / ImLog(v_max_fudged / v_min_fudged));
    %%%%%: 2900-block 49
call    0 never executed
call    1 never executed
        -: 2901:
    #####: 2902:        return flipped ? (1.0f - result) : result;
    %%%%%: 2902-block 52
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2902-block 53
    %%%%%: 2902-block 54
    %%%%%: 2902-block 55
        -: 2903:    }
        -: 2904:    else
        -: 2905:    {
        -: 2906:        // Linear slider
    #####: 2907:        return (float)((FLOATTYPE)(SIGNEDTYPE)(v_clamped - v_min) / (FLOATTYPE)(SIGNEDTYPE)(v_max - v_min));
    %%%%%: 2907-block 56
        -: 2908:    }
        -: 2909:}
------------------
_ZN5ImGui20ScaleRatioFromValueTIjifEEfiT_S1_S1_bff:
function _ZN5ImGui20ScaleRatioFromValueTIjifEEfiT_S1_S1_bff called 0 returned 0% blocks executed 0%
    #####: 2856:float ImGui::ScaleRatioFromValueT(ImGuiDataType data_type, TYPE v, TYPE v_min, TYPE v_max, bool is_logarithmic, float logarithmic_zero_epsilon, float zero_deadzone_halfsize)
        -: 2857:{
    #####: 2858:    if (v_min == v_max)
    %%%%%: 2858-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2859:        return 0.0f;
    %%%%%: 2859-block 3
        -: 2860:    IM_UNUSED(data_type);
        -: 2861:
    #####: 2862:    const TYPE v_clamped = (v_min < v_max) ? ImClamp(v, v_min, v_max) : ImClamp(v, v_max, v_min);
    %%%%%: 2862-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2862-block 5
call    2 never executed
    %%%%%: 2862-block 6
call    3 never executed
    #####: 2863:    if (is_logarithmic)
    %%%%%: 2863-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2864:    {
    #####: 2865:        bool flipped = v_max < v_min;
        -: 2866:
    #####: 2867:        if (flipped) // Handle the case where the range is backwards
    %%%%%: 2867-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2868:            ImSwap(v_min, v_max);
    %%%%%: 2868-block 9
call    0 never executed
        -: 2869:
        -: 2870:        // Fudge min/max to avoid getting close to log(0)
    #####: 2871:        FLOATTYPE v_min_fudged = (ImAbs((FLOATTYPE)v_min) < logarithmic_zero_epsilon) ? ((v_min < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_min;
    %%%%%: 2871-block 10
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 2871-block 12
    %%%%%: 2871-block 13
    #####: 2872:        FLOATTYPE v_max_fudged = (ImAbs((FLOATTYPE)v_max) < logarithmic_zero_epsilon) ? ((v_max < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_max;
    %%%%%: 2872-block 14
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 2872-block 16
    %%%%%: 2872-block 17
    %%%%%: 2872-block 18
        -: 2873:
        -: 2874:        // Awkward special cases - we need ranges of the form (-100 .. 0) to convert to (-100 .. -epsilon), not (-100 .. epsilon)
        -: 2875:        if ((v_min == 0.0f) && (v_max < 0.0f))
        -: 2876:            v_min_fudged = -logarithmic_zero_epsilon;
        -: 2877:        else if ((v_max == 0.0f) && (v_min < 0.0f))
        -: 2878:            v_max_fudged = -logarithmic_zero_epsilon;
        -: 2879:
        -: 2880:        float result;
    #####: 2881:        if (v_clamped <= v_min_fudged)
    %%%%%: 2881-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2882:            result = 0.0f; // Workaround for values that are in-range but below our fudge
    %%%%%: 2882-block 20
    #####: 2883:        else if (v_clamped >= v_max_fudged)
    %%%%%: 2883-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2884:            result = 1.0f; // Workaround for values that are in-range but above our fudge
    %%%%%: 2884-block 22
        -: 2885:        else if ((v_min * v_max) < 0.0f) // Range crosses zero, so split into two portions
        -: 2886:        {
        -: 2887:            float zero_point_center = (-(float)v_min) / ((float)v_max - (float)v_min); // The zero point in parametric space.  There's an argument we should take the logarithmic nature into account when calculating this, but for now this should do (and the most common case of a symmetrical range works fine)
        -: 2888:            float zero_point_snap_L = zero_point_center - zero_deadzone_halfsize;
        -: 2889:            float zero_point_snap_R = zero_point_center + zero_deadzone_halfsize;
        -: 2890:            if (v == 0.0f)
        -: 2891:                result = zero_point_center; // Special case for exactly zero
        -: 2892:            else if (v < 0.0f)
        -: 2893:                result = (1.0f - (float)(ImLog(-(FLOATTYPE)v_clamped / logarithmic_zero_epsilon) / ImLog(-v_min_fudged / logarithmic_zero_epsilon))) * zero_point_snap_L;
        -: 2894:            else
        -: 2895:                result = zero_point_snap_R + ((float)(ImLog((FLOATTYPE)v_clamped / logarithmic_zero_epsilon) / ImLog(v_max_fudged / logarithmic_zero_epsilon)) * (1.0f - zero_point_snap_R));
        -: 2896:        }
        -: 2897:        else if ((v_min < 0.0f) || (v_max < 0.0f)) // Entirely negative slider
        -: 2898:            result = 1.0f - (float)(ImLog(-(FLOATTYPE)v_clamped / -v_max_fudged) / ImLog(-v_min_fudged / -v_max_fudged));
        -: 2899:        else
    #####: 2900:            result = (float)(ImLog((FLOATTYPE)v_clamped / v_min_fudged) / ImLog(v_max_fudged / v_min_fudged));
    %%%%%: 2900-block 23
call    0 never executed
call    1 never executed
        -: 2901:
    #####: 2902:        return flipped ? (1.0f - result) : result;
    %%%%%: 2902-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2902-block 27
    %%%%%: 2902-block 28
    %%%%%: 2902-block 29
        -: 2903:    }
        -: 2904:    else
        -: 2905:    {
        -: 2906:        // Linear slider
    #####: 2907:        return (float)((FLOATTYPE)(SIGNEDTYPE)(v_clamped - v_min) / (FLOATTYPE)(SIGNEDTYPE)(v_max - v_min));
    %%%%%: 2907-block 30
        -: 2908:    }
        -: 2909:}
------------------
_ZN5ImGui20ScaleRatioFromValueTIiifEEfiT_S1_S1_bff:
function _ZN5ImGui20ScaleRatioFromValueTIiifEEfiT_S1_S1_bff called 0 returned 0% blocks executed 0%
    #####: 2856:float ImGui::ScaleRatioFromValueT(ImGuiDataType data_type, TYPE v, TYPE v_min, TYPE v_max, bool is_logarithmic, float logarithmic_zero_epsilon, float zero_deadzone_halfsize)
        -: 2857:{
    #####: 2858:    if (v_min == v_max)
    %%%%%: 2858-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2859:        return 0.0f;
    %%%%%: 2859-block 3
        -: 2860:    IM_UNUSED(data_type);
        -: 2861:
    #####: 2862:    const TYPE v_clamped = (v_min < v_max) ? ImClamp(v, v_min, v_max) : ImClamp(v, v_max, v_min);
    %%%%%: 2862-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2862-block 5
call    2 never executed
    %%%%%: 2862-block 6
call    3 never executed
    #####: 2863:    if (is_logarithmic)
    %%%%%: 2863-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2864:    {
    #####: 2865:        bool flipped = v_max < v_min;
        -: 2866:
    #####: 2867:        if (flipped) // Handle the case where the range is backwards
    %%%%%: 2867-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2868:            ImSwap(v_min, v_max);
    %%%%%: 2868-block 9
call    0 never executed
        -: 2869:
        -: 2870:        // Fudge min/max to avoid getting close to log(0)
    #####: 2871:        FLOATTYPE v_min_fudged = (ImAbs((FLOATTYPE)v_min) < logarithmic_zero_epsilon) ? ((v_min < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_min;
    %%%%%: 2871-block 10
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 2871-block 12
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 2871-block 13
    %%%%%: 2871-block 14
    %%%%%: 2871-block 15
    %%%%%: 2871-block 16
    #####: 2872:        FLOATTYPE v_max_fudged = (ImAbs((FLOATTYPE)v_max) < logarithmic_zero_epsilon) ? ((v_max < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_max;
    %%%%%: 2872-block 17
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 2872-block 19
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 2872-block 20
    %%%%%: 2872-block 21
    %%%%%: 2872-block 22
    %%%%%: 2872-block 23
        -: 2873:
        -: 2874:        // Awkward special cases - we need ranges of the form (-100 .. 0) to convert to (-100 .. -epsilon), not (-100 .. epsilon)
    #####: 2875:        if ((v_min == 0.0f) && (v_max < 0.0f))
    %%%%%: 2875-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2875-block 25
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2876:            v_min_fudged = -logarithmic_zero_epsilon;
    %%%%%: 2876-block 26
    #####: 2877:        else if ((v_max == 0.0f) && (v_min < 0.0f))
    %%%%%: 2877-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2877-block 28
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2878:            v_max_fudged = -logarithmic_zero_epsilon;
    %%%%%: 2878-block 29
        -: 2879:
        -: 2880:        float result;
    #####: 2881:        if (v_clamped <= v_min_fudged)
    %%%%%: 2881-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2882:            result = 0.0f; // Workaround for values that are in-range but below our fudge
    %%%%%: 2882-block 31
    #####: 2883:        else if (v_clamped >= v_max_fudged)
    %%%%%: 2883-block 32
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2884:            result = 1.0f; // Workaround for values that are in-range but above our fudge
    %%%%%: 2884-block 33
    #####: 2885:        else if ((v_min * v_max) < 0.0f) // Range crosses zero, so split into two portions
    %%%%%: 2885-block 34
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2886:        {
    #####: 2887:            float zero_point_center = (-(float)v_min) / ((float)v_max - (float)v_min); // The zero point in parametric space.  There's an argument we should take the logarithmic nature into account when calculating this, but for now this should do (and the most common case of a symmetrical range works fine)
    #####: 2888:            float zero_point_snap_L = zero_point_center - zero_deadzone_halfsize;
    #####: 2889:            float zero_point_snap_R = zero_point_center + zero_deadzone_halfsize;
    #####: 2890:            if (v == 0.0f)
    %%%%%: 2890-block 35
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2891:                result = zero_point_center; // Special case for exactly zero
    %%%%%: 2891-block 36
    #####: 2892:            else if (v < 0.0f)
    %%%%%: 2892-block 37
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2893:                result = (1.0f - (float)(ImLog(-(FLOATTYPE)v_clamped / logarithmic_zero_epsilon) / ImLog(-v_min_fudged / logarithmic_zero_epsilon))) * zero_point_snap_L;
    %%%%%: 2893-block 38
call    0 never executed
call    1 never executed
        -: 2894:            else
    #####: 2895:                result = zero_point_snap_R + ((float)(ImLog((FLOATTYPE)v_clamped / logarithmic_zero_epsilon) / ImLog(v_max_fudged / logarithmic_zero_epsilon)) * (1.0f - zero_point_snap_R));
    %%%%%: 2895-block 41
call    0 never executed
call    1 never executed
        -: 2896:        }
    #####: 2897:        else if ((v_min < 0.0f) || (v_max < 0.0f)) // Entirely negative slider
    %%%%%: 2897-block 44
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2897-block 45
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2898:            result = 1.0f - (float)(ImLog(-(FLOATTYPE)v_clamped / -v_max_fudged) / ImLog(-v_min_fudged / -v_max_fudged));
    %%%%%: 2898-block 46
call    0 never executed
call    1 never executed
        -: 2899:        else
    #####: 2900:            result = (float)(ImLog((FLOATTYPE)v_clamped / v_min_fudged) / ImLog(v_max_fudged / v_min_fudged));
    %%%%%: 2900-block 49
call    0 never executed
call    1 never executed
        -: 2901:
    #####: 2902:        return flipped ? (1.0f - result) : result;
    %%%%%: 2902-block 52
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2902-block 53
    %%%%%: 2902-block 54
    %%%%%: 2902-block 55
        -: 2903:    }
        -: 2904:    else
        -: 2905:    {
        -: 2906:        // Linear slider
    #####: 2907:        return (float)((FLOATTYPE)(SIGNEDTYPE)(v_clamped - v_min) / (FLOATTYPE)(SIGNEDTYPE)(v_max - v_min));
    %%%%%: 2907-block 56
        -: 2908:    }
        -: 2909:}
------------------
        -: 2910:
        -: 2911:// Convert a parametric position on a slider into a value v in the output space (the logical opposite of ScaleRatioFromValueT)
        -: 2912:template<typename TYPE, typename SIGNEDTYPE, typename FLOATTYPE>
    #####: 2913:TYPE ImGui::ScaleValueFromRatioT(ImGuiDataType data_type, float t, TYPE v_min, TYPE v_max, bool is_logarithmic, float logarithmic_zero_epsilon, float zero_deadzone_halfsize)
        -: 2914:{
        -: 2915:    // We special-case the extents because otherwise our logarithmic fudging can lead to "mathematically correct"
        -: 2916:    // but non-intuitive behaviors like a fully-left slider not actually reaching the minimum value. Also generally simpler.
    #####: 2917:    if (t <= 0.0f || v_min == v_max)
    #####: 2918:        return v_min;
    #####: 2919:    if (t >= 1.0f)
    #####: 2920:        return v_max;
        -: 2921:
    #####: 2922:    TYPE result = (TYPE)0;
    #####: 2923:    if (is_logarithmic)
        -: 2924:    {
        -: 2925:        // Fudge min/max to avoid getting silly results close to zero
    #####: 2926:        FLOATTYPE v_min_fudged = (ImAbs((FLOATTYPE)v_min) < logarithmic_zero_epsilon) ? ((v_min < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_min;
    #####: 2927:        FLOATTYPE v_max_fudged = (ImAbs((FLOATTYPE)v_max) < logarithmic_zero_epsilon) ? ((v_max < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_max;
        -: 2928:
    #####: 2929:        const bool flipped = v_max < v_min; // Check if range is "backwards"
    #####: 2930:        if (flipped)
    #####: 2931:            ImSwap(v_min_fudged, v_max_fudged);
        -: 2932:
        -: 2933:        // Awkward special case - we need ranges of the form (-100 .. 0) to convert to (-100 .. -epsilon), not (-100 .. epsilon)
    #####: 2934:        if ((v_max == 0.0f) && (v_min < 0.0f))
    #####: 2935:            v_max_fudged = -logarithmic_zero_epsilon;
        -: 2936:
    #####: 2937:        float t_with_flip = flipped ? (1.0f - t) : t; // t, but flipped if necessary to account for us flipping the range
        -: 2938:
    #####: 2939:        if ((v_min * v_max) < 0.0f) // Range crosses zero, so we have to do this in two parts
        -: 2940:        {
    #####: 2941:            float zero_point_center = (-(float)ImMin(v_min, v_max)) / ImAbs((float)v_max - (float)v_min); // The zero point in parametric space
    #####: 2942:            float zero_point_snap_L = zero_point_center - zero_deadzone_halfsize;
    #####: 2943:            float zero_point_snap_R = zero_point_center + zero_deadzone_halfsize;
    #####: 2944:            if (t_with_flip >= zero_point_snap_L && t_with_flip <= zero_point_snap_R)
    #####: 2945:                result = (TYPE)0.0f; // Special case to make getting exactly zero possible (the epsilon prevents it otherwise)
    #####: 2946:            else if (t_with_flip < zero_point_center)
    #####: 2947:                result = (TYPE)-(logarithmic_zero_epsilon * ImPow(-v_min_fudged / logarithmic_zero_epsilon, (FLOATTYPE)(1.0f - (t_with_flip / zero_point_snap_L))));
        -: 2948:            else
    #####: 2949:                result = (TYPE)(logarithmic_zero_epsilon * ImPow(v_max_fudged / logarithmic_zero_epsilon, (FLOATTYPE)((t_with_flip - zero_point_snap_R) / (1.0f - zero_point_snap_R))));
        -: 2950:        }
    #####: 2951:        else if ((v_min < 0.0f) || (v_max < 0.0f)) // Entirely negative slider
    #####: 2952:            result = (TYPE)-(-v_max_fudged * ImPow(-v_min_fudged / -v_max_fudged, (FLOATTYPE)(1.0f - t_with_flip)));
        -: 2953:        else
    #####: 2954:            result = (TYPE)(v_min_fudged * ImPow(v_max_fudged / v_min_fudged, (FLOATTYPE)t_with_flip));
        -: 2955:    }
        -: 2956:    else
        -: 2957:    {
        -: 2958:        // Linear slider
    #####: 2959:        const bool is_floating_point = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);
    #####: 2960:        if (is_floating_point)
        -: 2961:        {
    #####: 2962:            result = ImLerp(v_min, v_max, t);
        -: 2963:        }
    #####: 2964:        else if (t < 1.0)
        -: 2965:        {
        -: 2966:            // - For integer values we want the clicking position to match the grab box so we round above
        -: 2967:            //   This code is carefully tuned to work with large values (e.g. high ranges of U64) while preserving this property..
        -: 2968:            // - Not doing a *1.0 multiply at the end of a range as it tends to be lossy. While absolute aiming at a large s64/u64
        -: 2969:            //   range is going to be imprecise anyway, with this check we at least make the edge values matches expected limits.
    #####: 2970:            FLOATTYPE v_new_off_f = (SIGNEDTYPE)(v_max - v_min) * t;
    #####: 2971:            result = (TYPE)((SIGNEDTYPE)v_min + (SIGNEDTYPE)(v_new_off_f + (FLOATTYPE)(v_min > v_max ? -0.5 : 0.5)));
        -: 2972:        }
        -: 2973:    }
        -: 2974:
    #####: 2975:    return result;
        -: 2976:}
------------------
_ZN5ImGui20ScaleValueFromRatioTIdddEET_ifS1_S1_bff:
function _ZN5ImGui20ScaleValueFromRatioTIdddEET_ifS1_S1_bff called 0 returned 0% blocks executed 0%
    #####: 2913:TYPE ImGui::ScaleValueFromRatioT(ImGuiDataType data_type, float t, TYPE v_min, TYPE v_max, bool is_logarithmic, float logarithmic_zero_epsilon, float zero_deadzone_halfsize)
        -: 2914:{
        -: 2915:    // We special-case the extents because otherwise our logarithmic fudging can lead to "mathematically correct"
        -: 2916:    // but non-intuitive behaviors like a fully-left slider not actually reaching the minimum value. Also generally simpler.
    #####: 2917:    if (t <= 0.0f || v_min == v_max)
    %%%%%: 2917-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2917-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2918:        return v_min;
    %%%%%: 2918-block 4
    #####: 2919:    if (t >= 1.0f)
    %%%%%: 2919-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2920:        return v_max;
    %%%%%: 2920-block 6
        -: 2921:
    #####: 2922:    TYPE result = (TYPE)0;
    #####: 2923:    if (is_logarithmic)
    %%%%%: 2923-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2924:    {
        -: 2925:        // Fudge min/max to avoid getting silly results close to zero
    #####: 2926:        FLOATTYPE v_min_fudged = (ImAbs((FLOATTYPE)v_min) < logarithmic_zero_epsilon) ? ((v_min < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_min;
    %%%%%: 2926-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 2926-block 10
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 2926-block 11
    %%%%%: 2926-block 12
    %%%%%: 2926-block 13
    %%%%%: 2926-block 14
    #####: 2927:        FLOATTYPE v_max_fudged = (ImAbs((FLOATTYPE)v_max) < logarithmic_zero_epsilon) ? ((v_max < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_max;
    %%%%%: 2927-block 15
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 2927-block 17
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 2927-block 18
    %%%%%: 2927-block 19
    %%%%%: 2927-block 20
    %%%%%: 2927-block 21
        -: 2928:
    #####: 2929:        const bool flipped = v_max < v_min; // Check if range is "backwards"
    #####: 2930:        if (flipped)
    %%%%%: 2930-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2931:            ImSwap(v_min_fudged, v_max_fudged);
    %%%%%: 2931-block 23
call    0 never executed
        -: 2932:
        -: 2933:        // Awkward special case - we need ranges of the form (-100 .. 0) to convert to (-100 .. -epsilon), not (-100 .. epsilon)
    #####: 2934:        if ((v_max == 0.0f) && (v_min < 0.0f))
    %%%%%: 2934-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2934-block 25
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2935:            v_max_fudged = -logarithmic_zero_epsilon;
    %%%%%: 2935-block 26
        -: 2936:
    #####: 2937:        float t_with_flip = flipped ? (1.0f - t) : t; // t, but flipped if necessary to account for us flipping the range
    %%%%%: 2937-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2937-block 28
    %%%%%: 2937-block 29
        -: 2938:
    #####: 2939:        if ((v_min * v_max) < 0.0f) // Range crosses zero, so we have to do this in two parts
    %%%%%: 2939-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2940:        {
    #####: 2941:            float zero_point_center = (-(float)ImMin(v_min, v_max)) / ImAbs((float)v_max - (float)v_min); // The zero point in parametric space
    %%%%%: 2941-block 31
call    0 never executed
call    1 never executed
    #####: 2942:            float zero_point_snap_L = zero_point_center - zero_deadzone_halfsize;
    #####: 2943:            float zero_point_snap_R = zero_point_center + zero_deadzone_halfsize;
    #####: 2944:            if (t_with_flip >= zero_point_snap_L && t_with_flip <= zero_point_snap_R)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2944-block 34
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2945:                result = (TYPE)0.0f; // Special case to make getting exactly zero possible (the epsilon prevents it otherwise)
    %%%%%: 2945-block 35
    #####: 2946:            else if (t_with_flip < zero_point_center)
    %%%%%: 2946-block 36
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2947:                result = (TYPE)-(logarithmic_zero_epsilon * ImPow(-v_min_fudged / logarithmic_zero_epsilon, (FLOATTYPE)(1.0f - (t_with_flip / zero_point_snap_L))));
    %%%%%: 2947-block 37
call    0 never executed
        -: 2948:            else
    #####: 2949:                result = (TYPE)(logarithmic_zero_epsilon * ImPow(v_max_fudged / logarithmic_zero_epsilon, (FLOATTYPE)((t_with_flip - zero_point_snap_R) / (1.0f - zero_point_snap_R))));
    %%%%%: 2949-block 39
call    0 never executed
        -: 2950:        }
    #####: 2951:        else if ((v_min < 0.0f) || (v_max < 0.0f)) // Entirely negative slider
    %%%%%: 2951-block 42
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2951-block 43
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2952:            result = (TYPE)-(-v_max_fudged * ImPow(-v_min_fudged / -v_max_fudged, (FLOATTYPE)(1.0f - t_with_flip)));
    %%%%%: 2952-block 44
call    0 never executed
        -: 2953:        else
    #####: 2954:            result = (TYPE)(v_min_fudged * ImPow(v_max_fudged / v_min_fudged, (FLOATTYPE)t_with_flip));
    %%%%%: 2954-block 46
call    0 never executed
        -: 2955:    }
        -: 2956:    else
        -: 2957:    {
        -: 2958:        // Linear slider
    #####: 2959:        const bool is_floating_point = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);
    %%%%%: 2959-block 49
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2959-block 50
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2959-block 51
    %%%%%: 2959-block 52
    #####: 2960:        if (is_floating_point)
    %%%%%: 2960-block 53
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2961:        {
    #####: 2962:            result = ImLerp(v_min, v_max, t);
    %%%%%: 2962-block 54
call    0 never executed
        -: 2963:        }
    #####: 2964:        else if (t < 1.0)
    %%%%%: 2964-block 55
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2965:        {
        -: 2966:            // - For integer values we want the clicking position to match the grab box so we round above
        -: 2967:            //   This code is carefully tuned to work with large values (e.g. high ranges of U64) while preserving this property..
        -: 2968:            // - Not doing a *1.0 multiply at the end of a range as it tends to be lossy. While absolute aiming at a large s64/u64
        -: 2969:            //   range is going to be imprecise anyway, with this check we at least make the edge values matches expected limits.
    #####: 2970:            FLOATTYPE v_new_off_f = (SIGNEDTYPE)(v_max - v_min) * t;
    #####: 2971:            result = (TYPE)((SIGNEDTYPE)v_min + (SIGNEDTYPE)(v_new_off_f + (FLOATTYPE)(v_min > v_max ? -0.5 : 0.5)));
    %%%%%: 2971-block 56
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2971-block 57
    %%%%%: 2971-block 58
    %%%%%: 2971-block 59
        -: 2972:        }
        -: 2973:    }
        -: 2974:
    #####: 2975:    return result;
    %%%%%: 2975-block 60
        -: 2976:}
------------------
_ZN5ImGui20ScaleValueFromRatioTIfffEET_ifS1_S1_bff:
function _ZN5ImGui20ScaleValueFromRatioTIfffEET_ifS1_S1_bff called 0 returned 0% blocks executed 0%
    #####: 2913:TYPE ImGui::ScaleValueFromRatioT(ImGuiDataType data_type, float t, TYPE v_min, TYPE v_max, bool is_logarithmic, float logarithmic_zero_epsilon, float zero_deadzone_halfsize)
        -: 2914:{
        -: 2915:    // We special-case the extents because otherwise our logarithmic fudging can lead to "mathematically correct"
        -: 2916:    // but non-intuitive behaviors like a fully-left slider not actually reaching the minimum value. Also generally simpler.
    #####: 2917:    if (t <= 0.0f || v_min == v_max)
    %%%%%: 2917-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2917-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2918:        return v_min;
    %%%%%: 2918-block 4
    #####: 2919:    if (t >= 1.0f)
    %%%%%: 2919-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2920:        return v_max;
    %%%%%: 2920-block 6
        -: 2921:
    #####: 2922:    TYPE result = (TYPE)0;
    #####: 2923:    if (is_logarithmic)
    %%%%%: 2923-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2924:    {
        -: 2925:        // Fudge min/max to avoid getting silly results close to zero
    #####: 2926:        FLOATTYPE v_min_fudged = (ImAbs((FLOATTYPE)v_min) < logarithmic_zero_epsilon) ? ((v_min < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_min;
    %%%%%: 2926-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 2926-block 10
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 2926-block 11
    %%%%%: 2926-block 12
    %%%%%: 2926-block 13
    %%%%%: 2926-block 14
    #####: 2927:        FLOATTYPE v_max_fudged = (ImAbs((FLOATTYPE)v_max) < logarithmic_zero_epsilon) ? ((v_max < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_max;
    %%%%%: 2927-block 15
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 2927-block 17
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 2927-block 18
    %%%%%: 2927-block 19
    %%%%%: 2927-block 20
    %%%%%: 2927-block 21
        -: 2928:
    #####: 2929:        const bool flipped = v_max < v_min; // Check if range is "backwards"
    #####: 2930:        if (flipped)
    %%%%%: 2930-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2931:            ImSwap(v_min_fudged, v_max_fudged);
    %%%%%: 2931-block 23
call    0 never executed
        -: 2932:
        -: 2933:        // Awkward special case - we need ranges of the form (-100 .. 0) to convert to (-100 .. -epsilon), not (-100 .. epsilon)
    #####: 2934:        if ((v_max == 0.0f) && (v_min < 0.0f))
    %%%%%: 2934-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2934-block 25
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2935:            v_max_fudged = -logarithmic_zero_epsilon;
    %%%%%: 2935-block 26
        -: 2936:
    #####: 2937:        float t_with_flip = flipped ? (1.0f - t) : t; // t, but flipped if necessary to account for us flipping the range
    %%%%%: 2937-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2937-block 28
    %%%%%: 2937-block 29
        -: 2938:
    #####: 2939:        if ((v_min * v_max) < 0.0f) // Range crosses zero, so we have to do this in two parts
    %%%%%: 2939-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2940:        {
    #####: 2941:            float zero_point_center = (-(float)ImMin(v_min, v_max)) / ImAbs((float)v_max - (float)v_min); // The zero point in parametric space
    %%%%%: 2941-block 31
call    0 never executed
call    1 never executed
    #####: 2942:            float zero_point_snap_L = zero_point_center - zero_deadzone_halfsize;
    #####: 2943:            float zero_point_snap_R = zero_point_center + zero_deadzone_halfsize;
    #####: 2944:            if (t_with_flip >= zero_point_snap_L && t_with_flip <= zero_point_snap_R)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2944-block 34
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2945:                result = (TYPE)0.0f; // Special case to make getting exactly zero possible (the epsilon prevents it otherwise)
    %%%%%: 2945-block 35
    #####: 2946:            else if (t_with_flip < zero_point_center)
    %%%%%: 2946-block 36
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2947:                result = (TYPE)-(logarithmic_zero_epsilon * ImPow(-v_min_fudged / logarithmic_zero_epsilon, (FLOATTYPE)(1.0f - (t_with_flip / zero_point_snap_L))));
    %%%%%: 2947-block 37
call    0 never executed
        -: 2948:            else
    #####: 2949:                result = (TYPE)(logarithmic_zero_epsilon * ImPow(v_max_fudged / logarithmic_zero_epsilon, (FLOATTYPE)((t_with_flip - zero_point_snap_R) / (1.0f - zero_point_snap_R))));
    %%%%%: 2949-block 39
call    0 never executed
        -: 2950:        }
    #####: 2951:        else if ((v_min < 0.0f) || (v_max < 0.0f)) // Entirely negative slider
    %%%%%: 2951-block 42
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2951-block 43
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2952:            result = (TYPE)-(-v_max_fudged * ImPow(-v_min_fudged / -v_max_fudged, (FLOATTYPE)(1.0f - t_with_flip)));
    %%%%%: 2952-block 44
call    0 never executed
        -: 2953:        else
    #####: 2954:            result = (TYPE)(v_min_fudged * ImPow(v_max_fudged / v_min_fudged, (FLOATTYPE)t_with_flip));
    %%%%%: 2954-block 46
call    0 never executed
        -: 2955:    }
        -: 2956:    else
        -: 2957:    {
        -: 2958:        // Linear slider
    #####: 2959:        const bool is_floating_point = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);
    %%%%%: 2959-block 49
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2959-block 50
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2959-block 51
    %%%%%: 2959-block 52
    #####: 2960:        if (is_floating_point)
    %%%%%: 2960-block 53
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2961:        {
    #####: 2962:            result = ImLerp(v_min, v_max, t);
    %%%%%: 2962-block 54
call    0 never executed
        -: 2963:        }
    #####: 2964:        else if (t < 1.0)
    %%%%%: 2964-block 55
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2965:        {
        -: 2966:            // - For integer values we want the clicking position to match the grab box so we round above
        -: 2967:            //   This code is carefully tuned to work with large values (e.g. high ranges of U64) while preserving this property..
        -: 2968:            // - Not doing a *1.0 multiply at the end of a range as it tends to be lossy. While absolute aiming at a large s64/u64
        -: 2969:            //   range is going to be imprecise anyway, with this check we at least make the edge values matches expected limits.
    #####: 2970:            FLOATTYPE v_new_off_f = (SIGNEDTYPE)(v_max - v_min) * t;
    #####: 2971:            result = (TYPE)((SIGNEDTYPE)v_min + (SIGNEDTYPE)(v_new_off_f + (FLOATTYPE)(v_min > v_max ? -0.5 : 0.5)));
    %%%%%: 2971-block 56
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2971-block 57
    %%%%%: 2971-block 58
    %%%%%: 2971-block 59
        -: 2972:        }
        -: 2973:    }
        -: 2974:
    #####: 2975:    return result;
    %%%%%: 2975-block 60
        -: 2976:}
------------------
_ZN5ImGui20ScaleValueFromRatioTIyxdEET_ifS1_S1_bff:
function _ZN5ImGui20ScaleValueFromRatioTIyxdEET_ifS1_S1_bff called 0 returned 0% blocks executed 0%
    #####: 2913:TYPE ImGui::ScaleValueFromRatioT(ImGuiDataType data_type, float t, TYPE v_min, TYPE v_max, bool is_logarithmic, float logarithmic_zero_epsilon, float zero_deadzone_halfsize)
        -: 2914:{
        -: 2915:    // We special-case the extents because otherwise our logarithmic fudging can lead to "mathematically correct"
        -: 2916:    // but non-intuitive behaviors like a fully-left slider not actually reaching the minimum value. Also generally simpler.
    #####: 2917:    if (t <= 0.0f || v_min == v_max)
    %%%%%: 2917-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2917-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2918:        return v_min;
    %%%%%: 2918-block 4
    #####: 2919:    if (t >= 1.0f)
    %%%%%: 2919-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2920:        return v_max;
    %%%%%: 2920-block 6
        -: 2921:
    #####: 2922:    TYPE result = (TYPE)0;
    #####: 2923:    if (is_logarithmic)
    %%%%%: 2923-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2924:    {
        -: 2925:        // Fudge min/max to avoid getting silly results close to zero
    #####: 2926:        FLOATTYPE v_min_fudged = (ImAbs((FLOATTYPE)v_min) < logarithmic_zero_epsilon) ? ((v_min < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_min;
    %%%%%: 2926-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 2926-block 10
    %%%%%: 2926-block 11
    #####: 2927:        FLOATTYPE v_max_fudged = (ImAbs((FLOATTYPE)v_max) < logarithmic_zero_epsilon) ? ((v_max < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_max;
    %%%%%: 2927-block 12
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 2927-block 14
    %%%%%: 2927-block 15
        -: 2928:
    #####: 2929:        const bool flipped = v_max < v_min; // Check if range is "backwards"
    #####: 2930:        if (flipped)
    %%%%%: 2930-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2931:            ImSwap(v_min_fudged, v_max_fudged);
    %%%%%: 2931-block 17
call    0 never executed
        -: 2932:
        -: 2933:        // Awkward special case - we need ranges of the form (-100 .. 0) to convert to (-100 .. -epsilon), not (-100 .. epsilon)
        -: 2934:        if ((v_max == 0.0f) && (v_min < 0.0f))
        -: 2935:            v_max_fudged = -logarithmic_zero_epsilon;
        -: 2936:
    #####: 2937:        float t_with_flip = flipped ? (1.0f - t) : t; // t, but flipped if necessary to account for us flipping the range
    %%%%%: 2937-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2937-block 19
    %%%%%: 2937-block 20
    %%%%%: 2937-block 21
        -: 2938:
        -: 2939:        if ((v_min * v_max) < 0.0f) // Range crosses zero, so we have to do this in two parts
        -: 2940:        {
        -: 2941:            float zero_point_center = (-(float)ImMin(v_min, v_max)) / ImAbs((float)v_max - (float)v_min); // The zero point in parametric space
        -: 2942:            float zero_point_snap_L = zero_point_center - zero_deadzone_halfsize;
        -: 2943:            float zero_point_snap_R = zero_point_center + zero_deadzone_halfsize;
        -: 2944:            if (t_with_flip >= zero_point_snap_L && t_with_flip <= zero_point_snap_R)
        -: 2945:                result = (TYPE)0.0f; // Special case to make getting exactly zero possible (the epsilon prevents it otherwise)
        -: 2946:            else if (t_with_flip < zero_point_center)
        -: 2947:                result = (TYPE)-(logarithmic_zero_epsilon * ImPow(-v_min_fudged / logarithmic_zero_epsilon, (FLOATTYPE)(1.0f - (t_with_flip / zero_point_snap_L))));
        -: 2948:            else
        -: 2949:                result = (TYPE)(logarithmic_zero_epsilon * ImPow(v_max_fudged / logarithmic_zero_epsilon, (FLOATTYPE)((t_with_flip - zero_point_snap_R) / (1.0f - zero_point_snap_R))));
        -: 2950:        }
        -: 2951:        else if ((v_min < 0.0f) || (v_max < 0.0f)) // Entirely negative slider
        -: 2952:            result = (TYPE)-(-v_max_fudged * ImPow(-v_min_fudged / -v_max_fudged, (FLOATTYPE)(1.0f - t_with_flip)));
        -: 2953:        else
    #####: 2954:            result = (TYPE)(v_min_fudged * ImPow(v_max_fudged / v_min_fudged, (FLOATTYPE)t_with_flip));
    %%%%%: 2954-block 22
call    0 never executed
        -: 2955:    }
        -: 2956:    else
        -: 2957:    {
        -: 2958:        // Linear slider
    #####: 2959:        const bool is_floating_point = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);
    %%%%%: 2959-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2959-block 25
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2959-block 26
    %%%%%: 2959-block 27
    #####: 2960:        if (is_floating_point)
    %%%%%: 2960-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2961:        {
    #####: 2962:            result = ImLerp(v_min, v_max, t);
    %%%%%: 2962-block 29
call    0 never executed
        -: 2963:        }
    #####: 2964:        else if (t < 1.0)
    %%%%%: 2964-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2965:        {
        -: 2966:            // - For integer values we want the clicking position to match the grab box so we round above
        -: 2967:            //   This code is carefully tuned to work with large values (e.g. high ranges of U64) while preserving this property..
        -: 2968:            // - Not doing a *1.0 multiply at the end of a range as it tends to be lossy. While absolute aiming at a large s64/u64
        -: 2969:            //   range is going to be imprecise anyway, with this check we at least make the edge values matches expected limits.
    #####: 2970:            FLOATTYPE v_new_off_f = (SIGNEDTYPE)(v_max - v_min) * t;
    #####: 2971:            result = (TYPE)((SIGNEDTYPE)v_min + (SIGNEDTYPE)(v_new_off_f + (FLOATTYPE)(v_min > v_max ? -0.5 : 0.5)));
    %%%%%: 2971-block 31
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2971-block 32
    %%%%%: 2971-block 33
    %%%%%: 2971-block 34
        -: 2972:        }
        -: 2973:    }
        -: 2974:
    #####: 2975:    return result;
    %%%%%: 2975-block 35
        -: 2976:}
------------------
_ZN5ImGui20ScaleValueFromRatioTIxxdEET_ifS1_S1_bff:
function _ZN5ImGui20ScaleValueFromRatioTIxxdEET_ifS1_S1_bff called 0 returned 0% blocks executed 0%
    #####: 2913:TYPE ImGui::ScaleValueFromRatioT(ImGuiDataType data_type, float t, TYPE v_min, TYPE v_max, bool is_logarithmic, float logarithmic_zero_epsilon, float zero_deadzone_halfsize)
        -: 2914:{
        -: 2915:    // We special-case the extents because otherwise our logarithmic fudging can lead to "mathematically correct"
        -: 2916:    // but non-intuitive behaviors like a fully-left slider not actually reaching the minimum value. Also generally simpler.
    #####: 2917:    if (t <= 0.0f || v_min == v_max)
    %%%%%: 2917-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2917-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2918:        return v_min;
    %%%%%: 2918-block 4
    #####: 2919:    if (t >= 1.0f)
    %%%%%: 2919-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2920:        return v_max;
    %%%%%: 2920-block 6
        -: 2921:
    #####: 2922:    TYPE result = (TYPE)0;
    #####: 2923:    if (is_logarithmic)
    %%%%%: 2923-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2924:    {
        -: 2925:        // Fudge min/max to avoid getting silly results close to zero
    #####: 2926:        FLOATTYPE v_min_fudged = (ImAbs((FLOATTYPE)v_min) < logarithmic_zero_epsilon) ? ((v_min < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_min;
    %%%%%: 2926-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 2926-block 10
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 2926-block 11
    %%%%%: 2926-block 12
    %%%%%: 2926-block 13
    %%%%%: 2926-block 14
    #####: 2927:        FLOATTYPE v_max_fudged = (ImAbs((FLOATTYPE)v_max) < logarithmic_zero_epsilon) ? ((v_max < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_max;
    %%%%%: 2927-block 15
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 2927-block 17
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 2927-block 18
    %%%%%: 2927-block 19
    %%%%%: 2927-block 20
    %%%%%: 2927-block 21
        -: 2928:
    #####: 2929:        const bool flipped = v_max < v_min; // Check if range is "backwards"
    #####: 2930:        if (flipped)
    %%%%%: 2930-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2931:            ImSwap(v_min_fudged, v_max_fudged);
    %%%%%: 2931-block 23
call    0 never executed
        -: 2932:
        -: 2933:        // Awkward special case - we need ranges of the form (-100 .. 0) to convert to (-100 .. -epsilon), not (-100 .. epsilon)
    #####: 2934:        if ((v_max == 0.0f) && (v_min < 0.0f))
    %%%%%: 2934-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2934-block 25
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2935:            v_max_fudged = -logarithmic_zero_epsilon;
    %%%%%: 2935-block 26
        -: 2936:
    #####: 2937:        float t_with_flip = flipped ? (1.0f - t) : t; // t, but flipped if necessary to account for us flipping the range
    %%%%%: 2937-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2937-block 28
    %%%%%: 2937-block 29
        -: 2938:
    #####: 2939:        if ((v_min * v_max) < 0.0f) // Range crosses zero, so we have to do this in two parts
    %%%%%: 2939-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2940:        {
    #####: 2941:            float zero_point_center = (-(float)ImMin(v_min, v_max)) / ImAbs((float)v_max - (float)v_min); // The zero point in parametric space
    %%%%%: 2941-block 31
call    0 never executed
call    1 never executed
    #####: 2942:            float zero_point_snap_L = zero_point_center - zero_deadzone_halfsize;
    #####: 2943:            float zero_point_snap_R = zero_point_center + zero_deadzone_halfsize;
    #####: 2944:            if (t_with_flip >= zero_point_snap_L && t_with_flip <= zero_point_snap_R)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2944-block 34
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2945:                result = (TYPE)0.0f; // Special case to make getting exactly zero possible (the epsilon prevents it otherwise)
    %%%%%: 2945-block 35
    #####: 2946:            else if (t_with_flip < zero_point_center)
    %%%%%: 2946-block 36
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2947:                result = (TYPE)-(logarithmic_zero_epsilon * ImPow(-v_min_fudged / logarithmic_zero_epsilon, (FLOATTYPE)(1.0f - (t_with_flip / zero_point_snap_L))));
    %%%%%: 2947-block 37
call    0 never executed
        -: 2948:            else
    #####: 2949:                result = (TYPE)(logarithmic_zero_epsilon * ImPow(v_max_fudged / logarithmic_zero_epsilon, (FLOATTYPE)((t_with_flip - zero_point_snap_R) / (1.0f - zero_point_snap_R))));
    %%%%%: 2949-block 39
call    0 never executed
        -: 2950:        }
    #####: 2951:        else if ((v_min < 0.0f) || (v_max < 0.0f)) // Entirely negative slider
    %%%%%: 2951-block 42
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2951-block 43
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2952:            result = (TYPE)-(-v_max_fudged * ImPow(-v_min_fudged / -v_max_fudged, (FLOATTYPE)(1.0f - t_with_flip)));
    %%%%%: 2952-block 44
call    0 never executed
        -: 2953:        else
    #####: 2954:            result = (TYPE)(v_min_fudged * ImPow(v_max_fudged / v_min_fudged, (FLOATTYPE)t_with_flip));
    %%%%%: 2954-block 46
call    0 never executed
        -: 2955:    }
        -: 2956:    else
        -: 2957:    {
        -: 2958:        // Linear slider
    #####: 2959:        const bool is_floating_point = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);
    %%%%%: 2959-block 49
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2959-block 50
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2959-block 51
    %%%%%: 2959-block 52
    #####: 2960:        if (is_floating_point)
    %%%%%: 2960-block 53
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2961:        {
    #####: 2962:            result = ImLerp(v_min, v_max, t);
    %%%%%: 2962-block 54
call    0 never executed
        -: 2963:        }
    #####: 2964:        else if (t < 1.0)
    %%%%%: 2964-block 55
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2965:        {
        -: 2966:            // - For integer values we want the clicking position to match the grab box so we round above
        -: 2967:            //   This code is carefully tuned to work with large values (e.g. high ranges of U64) while preserving this property..
        -: 2968:            // - Not doing a *1.0 multiply at the end of a range as it tends to be lossy. While absolute aiming at a large s64/u64
        -: 2969:            //   range is going to be imprecise anyway, with this check we at least make the edge values matches expected limits.
    #####: 2970:            FLOATTYPE v_new_off_f = (SIGNEDTYPE)(v_max - v_min) * t;
    #####: 2971:            result = (TYPE)((SIGNEDTYPE)v_min + (SIGNEDTYPE)(v_new_off_f + (FLOATTYPE)(v_min > v_max ? -0.5 : 0.5)));
    %%%%%: 2971-block 56
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2971-block 57
    %%%%%: 2971-block 58
    %%%%%: 2971-block 59
        -: 2972:        }
        -: 2973:    }
        -: 2974:
    #####: 2975:    return result;
    %%%%%: 2975-block 60
        -: 2976:}
------------------
_ZN5ImGui20ScaleValueFromRatioTIjifEET_ifS1_S1_bff:
function _ZN5ImGui20ScaleValueFromRatioTIjifEET_ifS1_S1_bff called 0 returned 0% blocks executed 0%
    #####: 2913:TYPE ImGui::ScaleValueFromRatioT(ImGuiDataType data_type, float t, TYPE v_min, TYPE v_max, bool is_logarithmic, float logarithmic_zero_epsilon, float zero_deadzone_halfsize)
        -: 2914:{
        -: 2915:    // We special-case the extents because otherwise our logarithmic fudging can lead to "mathematically correct"
        -: 2916:    // but non-intuitive behaviors like a fully-left slider not actually reaching the minimum value. Also generally simpler.
    #####: 2917:    if (t <= 0.0f || v_min == v_max)
    %%%%%: 2917-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2917-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2918:        return v_min;
    %%%%%: 2918-block 4
    #####: 2919:    if (t >= 1.0f)
    %%%%%: 2919-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2920:        return v_max;
    %%%%%: 2920-block 6
        -: 2921:
    #####: 2922:    TYPE result = (TYPE)0;
    #####: 2923:    if (is_logarithmic)
    %%%%%: 2923-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2924:    {
        -: 2925:        // Fudge min/max to avoid getting silly results close to zero
    #####: 2926:        FLOATTYPE v_min_fudged = (ImAbs((FLOATTYPE)v_min) < logarithmic_zero_epsilon) ? ((v_min < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_min;
    %%%%%: 2926-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 2926-block 10
    %%%%%: 2926-block 11
    #####: 2927:        FLOATTYPE v_max_fudged = (ImAbs((FLOATTYPE)v_max) < logarithmic_zero_epsilon) ? ((v_max < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_max;
    %%%%%: 2927-block 12
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 2927-block 14
    %%%%%: 2927-block 15
        -: 2928:
    #####: 2929:        const bool flipped = v_max < v_min; // Check if range is "backwards"
    #####: 2930:        if (flipped)
    %%%%%: 2930-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2931:            ImSwap(v_min_fudged, v_max_fudged);
    %%%%%: 2931-block 17
call    0 never executed
        -: 2932:
        -: 2933:        // Awkward special case - we need ranges of the form (-100 .. 0) to convert to (-100 .. -epsilon), not (-100 .. epsilon)
        -: 2934:        if ((v_max == 0.0f) && (v_min < 0.0f))
        -: 2935:            v_max_fudged = -logarithmic_zero_epsilon;
        -: 2936:
    #####: 2937:        float t_with_flip = flipped ? (1.0f - t) : t; // t, but flipped if necessary to account for us flipping the range
    %%%%%: 2937-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2937-block 19
    %%%%%: 2937-block 20
    %%%%%: 2937-block 21
        -: 2938:
        -: 2939:        if ((v_min * v_max) < 0.0f) // Range crosses zero, so we have to do this in two parts
        -: 2940:        {
        -: 2941:            float zero_point_center = (-(float)ImMin(v_min, v_max)) / ImAbs((float)v_max - (float)v_min); // The zero point in parametric space
        -: 2942:            float zero_point_snap_L = zero_point_center - zero_deadzone_halfsize;
        -: 2943:            float zero_point_snap_R = zero_point_center + zero_deadzone_halfsize;
        -: 2944:            if (t_with_flip >= zero_point_snap_L && t_with_flip <= zero_point_snap_R)
        -: 2945:                result = (TYPE)0.0f; // Special case to make getting exactly zero possible (the epsilon prevents it otherwise)
        -: 2946:            else if (t_with_flip < zero_point_center)
        -: 2947:                result = (TYPE)-(logarithmic_zero_epsilon * ImPow(-v_min_fudged / logarithmic_zero_epsilon, (FLOATTYPE)(1.0f - (t_with_flip / zero_point_snap_L))));
        -: 2948:            else
        -: 2949:                result = (TYPE)(logarithmic_zero_epsilon * ImPow(v_max_fudged / logarithmic_zero_epsilon, (FLOATTYPE)((t_with_flip - zero_point_snap_R) / (1.0f - zero_point_snap_R))));
        -: 2950:        }
        -: 2951:        else if ((v_min < 0.0f) || (v_max < 0.0f)) // Entirely negative slider
        -: 2952:            result = (TYPE)-(-v_max_fudged * ImPow(-v_min_fudged / -v_max_fudged, (FLOATTYPE)(1.0f - t_with_flip)));
        -: 2953:        else
    #####: 2954:            result = (TYPE)(v_min_fudged * ImPow(v_max_fudged / v_min_fudged, (FLOATTYPE)t_with_flip));
    %%%%%: 2954-block 22
call    0 never executed
        -: 2955:    }
        -: 2956:    else
        -: 2957:    {
        -: 2958:        // Linear slider
    #####: 2959:        const bool is_floating_point = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);
    %%%%%: 2959-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2959-block 25
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2959-block 26
    %%%%%: 2959-block 27
    #####: 2960:        if (is_floating_point)
    %%%%%: 2960-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2961:        {
    #####: 2962:            result = ImLerp(v_min, v_max, t);
    %%%%%: 2962-block 29
call    0 never executed
        -: 2963:        }
    #####: 2964:        else if (t < 1.0)
    %%%%%: 2964-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2965:        {
        -: 2966:            // - For integer values we want the clicking position to match the grab box so we round above
        -: 2967:            //   This code is carefully tuned to work with large values (e.g. high ranges of U64) while preserving this property..
        -: 2968:            // - Not doing a *1.0 multiply at the end of a range as it tends to be lossy. While absolute aiming at a large s64/u64
        -: 2969:            //   range is going to be imprecise anyway, with this check we at least make the edge values matches expected limits.
    #####: 2970:            FLOATTYPE v_new_off_f = (SIGNEDTYPE)(v_max - v_min) * t;
    #####: 2971:            result = (TYPE)((SIGNEDTYPE)v_min + (SIGNEDTYPE)(v_new_off_f + (FLOATTYPE)(v_min > v_max ? -0.5 : 0.5)));
    %%%%%: 2971-block 31
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2971-block 32
    %%%%%: 2971-block 33
    %%%%%: 2971-block 34
        -: 2972:        }
        -: 2973:    }
        -: 2974:
    #####: 2975:    return result;
    %%%%%: 2975-block 35
        -: 2976:}
------------------
_ZN5ImGui20ScaleValueFromRatioTIiifEET_ifS1_S1_bff:
function _ZN5ImGui20ScaleValueFromRatioTIiifEET_ifS1_S1_bff called 0 returned 0% blocks executed 0%
    #####: 2913:TYPE ImGui::ScaleValueFromRatioT(ImGuiDataType data_type, float t, TYPE v_min, TYPE v_max, bool is_logarithmic, float logarithmic_zero_epsilon, float zero_deadzone_halfsize)
        -: 2914:{
        -: 2915:    // We special-case the extents because otherwise our logarithmic fudging can lead to "mathematically correct"
        -: 2916:    // but non-intuitive behaviors like a fully-left slider not actually reaching the minimum value. Also generally simpler.
    #####: 2917:    if (t <= 0.0f || v_min == v_max)
    %%%%%: 2917-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2917-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2918:        return v_min;
    %%%%%: 2918-block 4
    #####: 2919:    if (t >= 1.0f)
    %%%%%: 2919-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2920:        return v_max;
    %%%%%: 2920-block 6
        -: 2921:
    #####: 2922:    TYPE result = (TYPE)0;
    #####: 2923:    if (is_logarithmic)
    %%%%%: 2923-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2924:    {
        -: 2925:        // Fudge min/max to avoid getting silly results close to zero
    #####: 2926:        FLOATTYPE v_min_fudged = (ImAbs((FLOATTYPE)v_min) < logarithmic_zero_epsilon) ? ((v_min < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_min;
    %%%%%: 2926-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 2926-block 10
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 2926-block 11
    %%%%%: 2926-block 12
    %%%%%: 2926-block 13
    %%%%%: 2926-block 14
    #####: 2927:        FLOATTYPE v_max_fudged = (ImAbs((FLOATTYPE)v_max) < logarithmic_zero_epsilon) ? ((v_max < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_max;
    %%%%%: 2927-block 15
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 2927-block 17
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 2927-block 18
    %%%%%: 2927-block 19
    %%%%%: 2927-block 20
    %%%%%: 2927-block 21
        -: 2928:
    #####: 2929:        const bool flipped = v_max < v_min; // Check if range is "backwards"
    #####: 2930:        if (flipped)
    %%%%%: 2930-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2931:            ImSwap(v_min_fudged, v_max_fudged);
    %%%%%: 2931-block 23
call    0 never executed
        -: 2932:
        -: 2933:        // Awkward special case - we need ranges of the form (-100 .. 0) to convert to (-100 .. -epsilon), not (-100 .. epsilon)
    #####: 2934:        if ((v_max == 0.0f) && (v_min < 0.0f))
    %%%%%: 2934-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2934-block 25
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2935:            v_max_fudged = -logarithmic_zero_epsilon;
    %%%%%: 2935-block 26
        -: 2936:
    #####: 2937:        float t_with_flip = flipped ? (1.0f - t) : t; // t, but flipped if necessary to account for us flipping the range
    %%%%%: 2937-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2937-block 28
    %%%%%: 2937-block 29
        -: 2938:
    #####: 2939:        if ((v_min * v_max) < 0.0f) // Range crosses zero, so we have to do this in two parts
    %%%%%: 2939-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2940:        {
    #####: 2941:            float zero_point_center = (-(float)ImMin(v_min, v_max)) / ImAbs((float)v_max - (float)v_min); // The zero point in parametric space
    %%%%%: 2941-block 31
call    0 never executed
call    1 never executed
    #####: 2942:            float zero_point_snap_L = zero_point_center - zero_deadzone_halfsize;
    #####: 2943:            float zero_point_snap_R = zero_point_center + zero_deadzone_halfsize;
    #####: 2944:            if (t_with_flip >= zero_point_snap_L && t_with_flip <= zero_point_snap_R)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2944-block 34
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2945:                result = (TYPE)0.0f; // Special case to make getting exactly zero possible (the epsilon prevents it otherwise)
    %%%%%: 2945-block 35
    #####: 2946:            else if (t_with_flip < zero_point_center)
    %%%%%: 2946-block 36
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2947:                result = (TYPE)-(logarithmic_zero_epsilon * ImPow(-v_min_fudged / logarithmic_zero_epsilon, (FLOATTYPE)(1.0f - (t_with_flip / zero_point_snap_L))));
    %%%%%: 2947-block 37
call    0 never executed
        -: 2948:            else
    #####: 2949:                result = (TYPE)(logarithmic_zero_epsilon * ImPow(v_max_fudged / logarithmic_zero_epsilon, (FLOATTYPE)((t_with_flip - zero_point_snap_R) / (1.0f - zero_point_snap_R))));
    %%%%%: 2949-block 39
call    0 never executed
        -: 2950:        }
    #####: 2951:        else if ((v_min < 0.0f) || (v_max < 0.0f)) // Entirely negative slider
    %%%%%: 2951-block 42
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2951-block 43
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2952:            result = (TYPE)-(-v_max_fudged * ImPow(-v_min_fudged / -v_max_fudged, (FLOATTYPE)(1.0f - t_with_flip)));
    %%%%%: 2952-block 44
call    0 never executed
        -: 2953:        else
    #####: 2954:            result = (TYPE)(v_min_fudged * ImPow(v_max_fudged / v_min_fudged, (FLOATTYPE)t_with_flip));
    %%%%%: 2954-block 46
call    0 never executed
        -: 2955:    }
        -: 2956:    else
        -: 2957:    {
        -: 2958:        // Linear slider
    #####: 2959:        const bool is_floating_point = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);
    %%%%%: 2959-block 49
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2959-block 50
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2959-block 51
    %%%%%: 2959-block 52
    #####: 2960:        if (is_floating_point)
    %%%%%: 2960-block 53
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2961:        {
    #####: 2962:            result = ImLerp(v_min, v_max, t);
    %%%%%: 2962-block 54
call    0 never executed
        -: 2963:        }
    #####: 2964:        else if (t < 1.0)
    %%%%%: 2964-block 55
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2965:        {
        -: 2966:            // - For integer values we want the clicking position to match the grab box so we round above
        -: 2967:            //   This code is carefully tuned to work with large values (e.g. high ranges of U64) while preserving this property..
        -: 2968:            // - Not doing a *1.0 multiply at the end of a range as it tends to be lossy. While absolute aiming at a large s64/u64
        -: 2969:            //   range is going to be imprecise anyway, with this check we at least make the edge values matches expected limits.
    #####: 2970:            FLOATTYPE v_new_off_f = (SIGNEDTYPE)(v_max - v_min) * t;
    #####: 2971:            result = (TYPE)((SIGNEDTYPE)v_min + (SIGNEDTYPE)(v_new_off_f + (FLOATTYPE)(v_min > v_max ? -0.5 : 0.5)));
    %%%%%: 2971-block 56
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2971-block 57
    %%%%%: 2971-block 58
    %%%%%: 2971-block 59
        -: 2972:        }
        -: 2973:    }
        -: 2974:
    #####: 2975:    return result;
    %%%%%: 2975-block 60
        -: 2976:}
------------------
        -: 2977:
        -: 2978:// FIXME: Try to move more of the code into shared SliderBehavior()
        -: 2979:template<typename TYPE, typename SIGNEDTYPE, typename FLOATTYPE>
    #####: 2980:bool ImGui::SliderBehaviorT(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, TYPE* v, const TYPE v_min, const TYPE v_max, const char* format, ImGuiSliderFlags flags, ImRect* out_grab_bb)
        -: 2981:{
    #####: 2982:    ImGuiContext& g = *GImGui;
    #####: 2983:    const ImGuiStyle& style = g.Style;
        -: 2984:
    #####: 2985:    const ImGuiAxis axis = (flags & ImGuiSliderFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;
    #####: 2986:    const bool is_logarithmic = (flags & ImGuiSliderFlags_Logarithmic) != 0;
    #####: 2987:    const bool is_floating_point = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);
    #####: 2988:    const float v_range_f = (float)(v_min < v_max ? v_max - v_min : v_min - v_max); // We don't need high precision for what we do with it.
        -: 2989:
        -: 2990:    // Calculate bounds
    #####: 2991:    const float grab_padding = 2.0f; // FIXME: Should be part of style.
    #####: 2992:    const float slider_sz = (bb.Max[axis] - bb.Min[axis]) - grab_padding * 2.0f;
    #####: 2993:    float grab_sz = style.GrabMinSize;
    #####: 2994:    if (!is_floating_point && v_range_f >= 0.0f)                         // v_range_f < 0 may happen on integer overflows
    #####: 2995:        grab_sz = ImMax(slider_sz / (v_range_f + 1), style.GrabMinSize); // For integer sliders: if possible have the grab size represent 1 unit
    #####: 2996:    grab_sz = ImMin(grab_sz, slider_sz);
    #####: 2997:    const float slider_usable_sz = slider_sz - grab_sz;
    #####: 2998:    const float slider_usable_pos_min = bb.Min[axis] + grab_padding + grab_sz * 0.5f;
    #####: 2999:    const float slider_usable_pos_max = bb.Max[axis] - grab_padding - grab_sz * 0.5f;
        -: 3000:
    #####: 3001:    float logarithmic_zero_epsilon = 0.0f; // Only valid when is_logarithmic is true
    #####: 3002:    float zero_deadzone_halfsize = 0.0f; // Only valid when is_logarithmic is true
    #####: 3003:    if (is_logarithmic)
        -: 3004:    {
        -: 3005:        // When using logarithmic sliders, we need to clamp to avoid hitting zero, but our choice of clamp value greatly affects slider precision. We attempt to use the specified precision to estimate a good lower bound.
    #####: 3006:        const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 1;
    #####: 3007:        logarithmic_zero_epsilon = ImPow(0.1f, (float)decimal_precision);
    #####: 3008:        zero_deadzone_halfsize = (style.LogSliderDeadzone * 0.5f) / ImMax(slider_usable_sz, 1.0f);
        -: 3009:    }
        -: 3010:
        -: 3011:    // Process interacting with the slider
    #####: 3012:    bool value_changed = false;
    #####: 3013:    if (g.ActiveId == id)
        -: 3014:    {
    #####: 3015:        bool set_new_value = false;
    #####: 3016:        float clicked_t = 0.0f;
    #####: 3017:        if (g.ActiveIdSource == ImGuiInputSource_Mouse)
        -: 3018:        {
    #####: 3019:            if (!g.IO.MouseDown[0])
        -: 3020:            {
    #####: 3021:                ClearActiveID();
        -: 3022:            }
        -: 3023:            else
        -: 3024:            {
    #####: 3025:                const float mouse_abs_pos = g.IO.MousePos[axis];
    #####: 3026:                if (g.ActiveIdIsJustActivated)
        -: 3027:                {
    #####: 3028:                    float grab_t = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, *v, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
    #####: 3029:                    if (axis == ImGuiAxis_Y)
    #####: 3030:                        grab_t = 1.0f - grab_t;
    #####: 3031:                    const float grab_pos = ImLerp(slider_usable_pos_min, slider_usable_pos_max, grab_t);
    #####: 3032:                    const bool clicked_around_grab = (mouse_abs_pos >= grab_pos - grab_sz * 0.5f - 1.0f) && (mouse_abs_pos <= grab_pos + grab_sz * 0.5f + 1.0f); // No harm being extra generous here.
    #####: 3033:                    g.SliderGrabClickOffset = (clicked_around_grab && is_floating_point) ? mouse_abs_pos - grab_pos : 0.0f;
        -: 3034:                }
    #####: 3035:                if (slider_usable_sz > 0.0f)
    #####: 3036:                    clicked_t = ImSaturate((mouse_abs_pos - g.SliderGrabClickOffset - slider_usable_pos_min) / slider_usable_sz);
    #####: 3037:                if (axis == ImGuiAxis_Y)
    #####: 3038:                    clicked_t = 1.0f - clicked_t;
    #####: 3039:                set_new_value = true;
        -: 3040:            }
        -: 3041:        }
    #####: 3042:        else if (g.ActiveIdSource == ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource_Gamepad)
        -: 3043:        {
    #####: 3044:            if (g.ActiveIdIsJustActivated)
        -: 3045:            {
    #####: 3046:                g.SliderCurrentAccum = 0.0f; // Reset any stored nav delta upon activation
    #####: 3047:                g.SliderCurrentAccumDirty = false;
        -: 3048:            }
        -: 3049:
    #####: 3050:            float input_delta = (axis == ImGuiAxis_X) ? GetNavTweakPressedAmount(axis) : -GetNavTweakPressedAmount(axis);
    #####: 3051:            if (input_delta != 0.0f)
        -: 3052:            {
    #####: 3053:                const bool tweak_slow = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakSlow : ImGuiKey_NavKeyboardTweakSlow);
    #####: 3054:                const bool tweak_fast = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakFast : ImGuiKey_NavKeyboardTweakFast);
    #####: 3055:                const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 0;
    #####: 3056:                if (decimal_precision > 0)
        -: 3057:                {
    #####: 3058:                    input_delta /= 100.0f; // Keyboard/Gamepad tweak speeds in % of slider bounds
    #####: 3059:                    if (tweak_slow)
    #####: 3060:                        input_delta /= 10.0f;
        -: 3061:                }
        -: 3062:                else
        -: 3063:                {
    #####: 3064:                    if ((v_range_f >= -100.0f && v_range_f <= 100.0f && v_range_f != 0.0f) || tweak_slow)
    #####: 3065:                        input_delta = ((input_delta < 0.0f) ? -1.0f : +1.0f) / v_range_f; // Keyboard/Gamepad tweak speeds in integer steps
        -: 3066:                    else
    #####: 3067:                        input_delta /= 100.0f;
        -: 3068:                }
    #####: 3069:                if (tweak_fast)
    #####: 3070:                    input_delta *= 10.0f;
        -: 3071:
    #####: 3072:                g.SliderCurrentAccum += input_delta;
    #####: 3073:                g.SliderCurrentAccumDirty = true;
        -: 3074:            }
        -: 3075:
    #####: 3076:            float delta = g.SliderCurrentAccum;
    #####: 3077:            if (g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated)
        -: 3078:            {
    #####: 3079:                ClearActiveID();
        -: 3080:            }
    #####: 3081:            else if (g.SliderCurrentAccumDirty)
        -: 3082:            {
    #####: 3083:                clicked_t = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, *v, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
        -: 3084:
    #####: 3085:                if ((clicked_t >= 1.0f && delta > 0.0f) || (clicked_t <= 0.0f && delta < 0.0f)) // This is to avoid applying the saturation when already past the limits
        -: 3086:                {
    #####: 3087:                    set_new_value = false;
    #####: 3088:                    g.SliderCurrentAccum = 0.0f; // If pushing up against the limits, don't continue to accumulate
        -: 3089:                }
        -: 3090:                else
        -: 3091:                {
    #####: 3092:                    set_new_value = true;
    #####: 3093:                    float old_clicked_t = clicked_t;
    #####: 3094:                    clicked_t = ImSaturate(clicked_t + delta);
        -: 3095:
        -: 3096:                    // Calculate what our "new" clicked_t will be, and thus how far we actually moved the slider, and subtract this from the accumulator
    #####: 3097:                    TYPE v_new = ScaleValueFromRatioT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, clicked_t, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
    #####: 3098:                    if (is_floating_point && !(flags & ImGuiSliderFlags_NoRoundToFormat))
    #####: 3099:                        v_new = RoundScalarWithFormatT<TYPE>(format, data_type, v_new);
    #####: 3100:                    float new_clicked_t = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_new, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
        -: 3101:
    #####: 3102:                    if (delta > 0)
    #####: 3103:                        g.SliderCurrentAccum -= ImMin(new_clicked_t - old_clicked_t, delta);
        -: 3104:                    else
    #####: 3105:                        g.SliderCurrentAccum -= ImMax(new_clicked_t - old_clicked_t, delta);
        -: 3106:                }
        -: 3107:
    #####: 3108:                g.SliderCurrentAccumDirty = false;
        -: 3109:            }
        -: 3110:        }
        -: 3111:
    #####: 3112:        if (set_new_value)
    #####: 3113:            if ((g.LastItemData.ItemFlags & ImGuiItemFlags_ReadOnly) || (flags & ImGuiSliderFlags_ReadOnly))
    #####: 3114:                set_new_value = false;
        -: 3115:
    #####: 3116:        if (set_new_value)
        -: 3117:        {
    #####: 3118:            TYPE v_new = ScaleValueFromRatioT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, clicked_t, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
        -: 3119:
        -: 3120:            // Round to user desired precision based on format string
    #####: 3121:            if (is_floating_point && !(flags & ImGuiSliderFlags_NoRoundToFormat))
    #####: 3122:                v_new = RoundScalarWithFormatT<TYPE>(format, data_type, v_new);
        -: 3123:
        -: 3124:            // Apply result
    #####: 3125:            if (*v != v_new)
        -: 3126:            {
    #####: 3127:                *v = v_new;
    #####: 3128:                value_changed = true;
        -: 3129:            }
        -: 3130:        }
        -: 3131:    }
        -: 3132:
    #####: 3133:    if (slider_sz < 1.0f)
        -: 3134:    {
    #####: 3135:        *out_grab_bb = ImRect(bb.Min, bb.Min);
        -: 3136:    }
        -: 3137:    else
        -: 3138:    {
        -: 3139:        // Output grab position so it can be displayed by the caller
    #####: 3140:        float grab_t = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, *v, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
    #####: 3141:        if (axis == ImGuiAxis_Y)
    #####: 3142:            grab_t = 1.0f - grab_t;
    #####: 3143:        const float grab_pos = ImLerp(slider_usable_pos_min, slider_usable_pos_max, grab_t);
    #####: 3144:        if (axis == ImGuiAxis_X)
    #####: 3145:            *out_grab_bb = ImRect(grab_pos - grab_sz * 0.5f, bb.Min.y + grab_padding, grab_pos + grab_sz * 0.5f, bb.Max.y - grab_padding);
        -: 3146:        else
    #####: 3147:            *out_grab_bb = ImRect(bb.Min.x + grab_padding, grab_pos - grab_sz * 0.5f, bb.Max.x - grab_padding, grab_pos + grab_sz * 0.5f);
        -: 3148:    }
        -: 3149:
    #####: 3150:    return value_changed;
        -: 3151:}
------------------
_ZN5ImGui15SliderBehaviorTIdddEEbRK6ImRectjiPT_S4_S4_PKciPS1_:
function _ZN5ImGui15SliderBehaviorTIdddEEbRK6ImRectjiPT_S4_S4_PKciPS1_ called 0 returned 0% blocks executed 0%
    #####: 2980:bool ImGui::SliderBehaviorT(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, TYPE* v, const TYPE v_min, const TYPE v_max, const char* format, ImGuiSliderFlags flags, ImRect* out_grab_bb)
        -: 2981:{
    #####: 2982:    ImGuiContext& g = *GImGui;
    #####: 2983:    const ImGuiStyle& style = g.Style;
        -: 2984:
    #####: 2985:    const ImGuiAxis axis = (flags & ImGuiSliderFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;
    #####: 2986:    const bool is_logarithmic = (flags & ImGuiSliderFlags_Logarithmic) != 0;
    #####: 2987:    const bool is_floating_point = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);
    %%%%%: 2987-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2987-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2987-block 4
    %%%%%: 2987-block 5
    #####: 2988:    const float v_range_f = (float)(v_min < v_max ? v_max - v_min : v_min - v_max); // We don't need high precision for what we do with it.
    %%%%%: 2988-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2988-block 7
    %%%%%: 2988-block 8
        -: 2989:
        -: 2990:    // Calculate bounds
    #####: 2991:    const float grab_padding = 2.0f; // FIXME: Should be part of style.
    #####: 2992:    const float slider_sz = (bb.Max[axis] - bb.Min[axis]) - grab_padding * 2.0f;
    %%%%%: 2992-block 9
call    0 never executed
call    1 never executed
    #####: 2993:    float grab_sz = style.GrabMinSize;
    #####: 2994:    if (!is_floating_point && v_range_f >= 0.0f)                         // v_range_f < 0 may happen on integer overflows
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2994-block 12
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2995:        grab_sz = ImMax(slider_sz / (v_range_f + 1), style.GrabMinSize); // For integer sliders: if possible have the grab size represent 1 unit
    %%%%%: 2995-block 13
call    0 never executed
    #####: 2996:    grab_sz = ImMin(grab_sz, slider_sz);
    %%%%%: 2996-block 14
call    0 never executed
    #####: 2997:    const float slider_usable_sz = slider_sz - grab_sz;
    #####: 2998:    const float slider_usable_pos_min = bb.Min[axis] + grab_padding + grab_sz * 0.5f;
call    0 never executed
    #####: 2999:    const float slider_usable_pos_max = bb.Max[axis] - grab_padding - grab_sz * 0.5f;
call    0 never executed
        -: 3000:
    #####: 3001:    float logarithmic_zero_epsilon = 0.0f; // Only valid when is_logarithmic is true
    #####: 3002:    float zero_deadzone_halfsize = 0.0f; // Only valid when is_logarithmic is true
    #####: 3003:    if (is_logarithmic)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3004:    {
        -: 3005:        // When using logarithmic sliders, we need to clamp to avoid hitting zero, but our choice of clamp value greatly affects slider precision. We attempt to use the specified precision to estimate a good lower bound.
    #####: 3006:        const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 1;
    %%%%%: 3006-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3006-block 19
call    2 never executed
    %%%%%: 3006-block 21
    #####: 3007:        logarithmic_zero_epsilon = ImPow(0.1f, (float)decimal_precision);
    %%%%%: 3007-block 22
call    0 never executed
    #####: 3008:        zero_deadzone_halfsize = (style.LogSliderDeadzone * 0.5f) / ImMax(slider_usable_sz, 1.0f);
call    0 never executed
        -: 3009:    }
        -: 3010:
        -: 3011:    // Process interacting with the slider
    #####: 3012:    bool value_changed = false;
    #####: 3013:    if (g.ActiveId == id)
    %%%%%: 3013-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3014:    {
    #####: 3015:        bool set_new_value = false;
    #####: 3016:        float clicked_t = 0.0f;
    #####: 3017:        if (g.ActiveIdSource == ImGuiInputSource_Mouse)
    %%%%%: 3017-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3018:        {
    #####: 3019:            if (!g.IO.MouseDown[0])
    %%%%%: 3019-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3020:            {
    #####: 3021:                ClearActiveID();
    %%%%%: 3021-block 28
call    0 never executed
        -: 3022:            }
        -: 3023:            else
        -: 3024:            {
    #####: 3025:                const float mouse_abs_pos = g.IO.MousePos[axis];
    %%%%%: 3025-block 29
call    0 never executed
    #####: 3026:                if (g.ActiveIdIsJustActivated)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3027:                {
    #####: 3028:                    float grab_t = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, *v, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
    %%%%%: 3028-block 31
call    0 never executed
    #####: 3029:                    if (axis == ImGuiAxis_Y)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3030:                        grab_t = 1.0f - grab_t;
    %%%%%: 3030-block 33
    #####: 3031:                    const float grab_pos = ImLerp(slider_usable_pos_min, slider_usable_pos_max, grab_t);
    %%%%%: 3031-block 34
call    0 never executed
    #####: 3032:                    const bool clicked_around_grab = (mouse_abs_pos >= grab_pos - grab_sz * 0.5f - 1.0f) && (mouse_abs_pos <= grab_pos + grab_sz * 0.5f + 1.0f); // No harm being extra generous here.
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3032-block 36
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3032-block 37
    %%%%%: 3032-block 38
    #####: 3033:                    g.SliderGrabClickOffset = (clicked_around_grab && is_floating_point) ? mouse_abs_pos - grab_pos : 0.0f;
    %%%%%: 3033-block 39
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3033-block 40
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3033-block 41
    %%%%%: 3033-block 42
    %%%%%: 3033-block 43
        -: 3034:                }
    #####: 3035:                if (slider_usable_sz > 0.0f)
    %%%%%: 3035-block 44
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3036:                    clicked_t = ImSaturate((mouse_abs_pos - g.SliderGrabClickOffset - slider_usable_pos_min) / slider_usable_sz);
    %%%%%: 3036-block 45
call    0 never executed
    #####: 3037:                if (axis == ImGuiAxis_Y)
    %%%%%: 3037-block 46
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3038:                    clicked_t = 1.0f - clicked_t;
    %%%%%: 3038-block 47
    #####: 3039:                set_new_value = true;
    %%%%%: 3039-block 48
        -: 3040:            }
        -: 3041:        }
    #####: 3042:        else if (g.ActiveIdSource == ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource_Gamepad)
    %%%%%: 3042-block 49
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3042-block 50
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 3043:        {
    #####: 3044:            if (g.ActiveIdIsJustActivated)
    %%%%%: 3044-block 51
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3045:            {
    #####: 3046:                g.SliderCurrentAccum = 0.0f; // Reset any stored nav delta upon activation
    #####: 3047:                g.SliderCurrentAccumDirty = false;
    %%%%%: 3047-block 52
        -: 3048:            }
        -: 3049:
    #####: 3050:            float input_delta = (axis == ImGuiAxis_X) ? GetNavTweakPressedAmount(axis) : -GetNavTweakPressedAmount(axis);
    %%%%%: 3050-block 53
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3050-block 54
call    2 never executed
    %%%%%: 3050-block 56
call    3 never executed
    #####: 3051:            if (input_delta != 0.0f)
    %%%%%: 3051-block 58
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3052:            {
    #####: 3053:                const bool tweak_slow = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakSlow : ImGuiKey_NavKeyboardTweakSlow);
    %%%%%: 3053-block 59
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3053-block 60
    %%%%%: 3053-block 61
    %%%%%: 3053-block 62
call    2 never executed
    #####: 3054:                const bool tweak_fast = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakFast : ImGuiKey_NavKeyboardTweakFast);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3054-block 64
    %%%%%: 3054-block 65
    %%%%%: 3054-block 66
call    2 never executed
    #####: 3055:                const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 0;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3055-block 68
call    2 never executed
    %%%%%: 3055-block 70
    #####: 3056:                if (decimal_precision > 0)
    %%%%%: 3056-block 71
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3057:                {
    #####: 3058:                    input_delta /= 100.0f; // Keyboard/Gamepad tweak speeds in % of slider bounds
    #####: 3059:                    if (tweak_slow)
    %%%%%: 3059-block 72
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3060:                        input_delta /= 10.0f;
    %%%%%: 3060-block 73
        -: 3061:                }
        -: 3062:                else
        -: 3063:                {
    #####: 3064:                    if ((v_range_f >= -100.0f && v_range_f <= 100.0f && v_range_f != 0.0f) || tweak_slow)
    %%%%%: 3064-block 74
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3064-block 75
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3064-block 76
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 3064-block 77
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 3065:                        input_delta = ((input_delta < 0.0f) ? -1.0f : +1.0f) / v_range_f; // Keyboard/Gamepad tweak speeds in integer steps
    %%%%%: 3065-block 78
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3065-block 79
    %%%%%: 3065-block 80
    %%%%%: 3065-block 81
        -: 3066:                    else
    #####: 3067:                        input_delta /= 100.0f;
    %%%%%: 3067-block 82
        -: 3068:                }
    #####: 3069:                if (tweak_fast)
    %%%%%: 3069-block 83
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3070:                    input_delta *= 10.0f;
    %%%%%: 3070-block 84
        -: 3071:
    #####: 3072:                g.SliderCurrentAccum += input_delta;
    #####: 3073:                g.SliderCurrentAccumDirty = true;
    %%%%%: 3073-block 85
        -: 3074:            }
        -: 3075:
    #####: 3076:            float delta = g.SliderCurrentAccum;
    #####: 3077:            if (g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated)
    %%%%%: 3077-block 86
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3077-block 87
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 3078:            {
    #####: 3079:                ClearActiveID();
    %%%%%: 3079-block 88
call    0 never executed
        -: 3080:            }
    #####: 3081:            else if (g.SliderCurrentAccumDirty)
    %%%%%: 3081-block 89
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3082:            {
    #####: 3083:                clicked_t = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, *v, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
    %%%%%: 3083-block 90
call    0 never executed
        -: 3084:
    #####: 3085:                if ((clicked_t >= 1.0f && delta > 0.0f) || (clicked_t <= 0.0f && delta < 0.0f)) // This is to avoid applying the saturation when already past the limits
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3085-block 92
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3085-block 93
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 3085-block 94
branch  6 never executed (fallthrough)
branch  7 never executed
        -: 3086:                {
    #####: 3087:                    set_new_value = false;
    #####: 3088:                    g.SliderCurrentAccum = 0.0f; // If pushing up against the limits, don't continue to accumulate
    %%%%%: 3088-block 95
        -: 3089:                }
        -: 3090:                else
        -: 3091:                {
    #####: 3092:                    set_new_value = true;
    #####: 3093:                    float old_clicked_t = clicked_t;
    #####: 3094:                    clicked_t = ImSaturate(clicked_t + delta);
    %%%%%: 3094-block 96
call    0 never executed
        -: 3095:
        -: 3096:                    // Calculate what our "new" clicked_t will be, and thus how far we actually moved the slider, and subtract this from the accumulator
    #####: 3097:                    TYPE v_new = ScaleValueFromRatioT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, clicked_t, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
call    0 never executed
    #####: 3098:                    if (is_floating_point && !(flags & ImGuiSliderFlags_NoRoundToFormat))
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3098-block 99
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3099:                        v_new = RoundScalarWithFormatT<TYPE>(format, data_type, v_new);
    %%%%%: 3099-block 100
call    0 never executed
    #####: 3100:                    float new_clicked_t = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_new, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
    %%%%%: 3100-block 102
call    0 never executed
        -: 3101:
    #####: 3102:                    if (delta > 0)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3103:                        g.SliderCurrentAccum -= ImMin(new_clicked_t - old_clicked_t, delta);
    %%%%%: 3103-block 104
call    0 never executed
        -: 3104:                    else
    #####: 3105:                        g.SliderCurrentAccum -= ImMax(new_clicked_t - old_clicked_t, delta);
    %%%%%: 3105-block 106
call    0 never executed
        -: 3106:                }
        -: 3107:
    #####: 3108:                g.SliderCurrentAccumDirty = false;
    %%%%%: 3108-block 108
        -: 3109:            }
        -: 3110:        }
        -: 3111:
    #####: 3112:        if (set_new_value)
    %%%%%: 3112-block 109
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3113:            if ((g.LastItemData.ItemFlags & ImGuiItemFlags_ReadOnly) || (flags & ImGuiSliderFlags_ReadOnly))
    %%%%%: 3113-block 110
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3113-block 111
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3114:                set_new_value = false;
    %%%%%: 3114-block 112
        -: 3115:
    #####: 3116:        if (set_new_value)
    %%%%%: 3116-block 113
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3117:        {
    #####: 3118:            TYPE v_new = ScaleValueFromRatioT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, clicked_t, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
    %%%%%: 3118-block 114
call    0 never executed
        -: 3119:
        -: 3120:            // Round to user desired precision based on format string
    #####: 3121:            if (is_floating_point && !(flags & ImGuiSliderFlags_NoRoundToFormat))
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3121-block 116
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3122:                v_new = RoundScalarWithFormatT<TYPE>(format, data_type, v_new);
    %%%%%: 3122-block 117
call    0 never executed
        -: 3123:
        -: 3124:            // Apply result
    #####: 3125:            if (*v != v_new)
    %%%%%: 3125-block 119
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3126:            {
    #####: 3127:                *v = v_new;
    #####: 3128:                value_changed = true;
    %%%%%: 3128-block 120
        -: 3129:            }
        -: 3130:        }
        -: 3131:    }
        -: 3132:
    #####: 3133:    if (slider_sz < 1.0f)
    %%%%%: 3133-block 121
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3134:    {
    #####: 3135:        *out_grab_bb = ImRect(bb.Min, bb.Min);
    %%%%%: 3135-block 122
call    0 never executed
        -: 3136:    }
        -: 3137:    else
        -: 3138:    {
        -: 3139:        // Output grab position so it can be displayed by the caller
    #####: 3140:        float grab_t = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, *v, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
    %%%%%: 3140-block 124
call    0 never executed
    #####: 3141:        if (axis == ImGuiAxis_Y)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3142:            grab_t = 1.0f - grab_t;
    %%%%%: 3142-block 126
    #####: 3143:        const float grab_pos = ImLerp(slider_usable_pos_min, slider_usable_pos_max, grab_t);
    %%%%%: 3143-block 127
call    0 never executed
    #####: 3144:        if (axis == ImGuiAxis_X)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3145:            *out_grab_bb = ImRect(grab_pos - grab_sz * 0.5f, bb.Min.y + grab_padding, grab_pos + grab_sz * 0.5f, bb.Max.y - grab_padding);
    %%%%%: 3145-block 129
call    0 never executed
        -: 3146:        else
    #####: 3147:            *out_grab_bb = ImRect(bb.Min.x + grab_padding, grab_pos - grab_sz * 0.5f, bb.Max.x - grab_padding, grab_pos + grab_sz * 0.5f);
    %%%%%: 3147-block 131
call    0 never executed
        -: 3148:    }
        -: 3149:
    #####: 3150:    return value_changed;
    %%%%%: 3150-block 133
        -: 3151:}
------------------
_ZN5ImGui15SliderBehaviorTIfffEEbRK6ImRectjiPT_S4_S4_PKciPS1_:
function _ZN5ImGui15SliderBehaviorTIfffEEbRK6ImRectjiPT_S4_S4_PKciPS1_ called 0 returned 0% blocks executed 0%
    #####: 2980:bool ImGui::SliderBehaviorT(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, TYPE* v, const TYPE v_min, const TYPE v_max, const char* format, ImGuiSliderFlags flags, ImRect* out_grab_bb)
        -: 2981:{
    #####: 2982:    ImGuiContext& g = *GImGui;
    #####: 2983:    const ImGuiStyle& style = g.Style;
        -: 2984:
    #####: 2985:    const ImGuiAxis axis = (flags & ImGuiSliderFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;
    #####: 2986:    const bool is_logarithmic = (flags & ImGuiSliderFlags_Logarithmic) != 0;
    #####: 2987:    const bool is_floating_point = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);
    %%%%%: 2987-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2987-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2987-block 4
    %%%%%: 2987-block 5
    #####: 2988:    const float v_range_f = (float)(v_min < v_max ? v_max - v_min : v_min - v_max); // We don't need high precision for what we do with it.
    %%%%%: 2988-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2988-block 7
    %%%%%: 2988-block 8
        -: 2989:
        -: 2990:    // Calculate bounds
    #####: 2991:    const float grab_padding = 2.0f; // FIXME: Should be part of style.
    #####: 2992:    const float slider_sz = (bb.Max[axis] - bb.Min[axis]) - grab_padding * 2.0f;
    %%%%%: 2992-block 9
call    0 never executed
call    1 never executed
    #####: 2993:    float grab_sz = style.GrabMinSize;
    #####: 2994:    if (!is_floating_point && v_range_f >= 0.0f)                         // v_range_f < 0 may happen on integer overflows
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2994-block 12
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2995:        grab_sz = ImMax(slider_sz / (v_range_f + 1), style.GrabMinSize); // For integer sliders: if possible have the grab size represent 1 unit
    %%%%%: 2995-block 13
call    0 never executed
    #####: 2996:    grab_sz = ImMin(grab_sz, slider_sz);
    %%%%%: 2996-block 14
call    0 never executed
    #####: 2997:    const float slider_usable_sz = slider_sz - grab_sz;
    #####: 2998:    const float slider_usable_pos_min = bb.Min[axis] + grab_padding + grab_sz * 0.5f;
call    0 never executed
    #####: 2999:    const float slider_usable_pos_max = bb.Max[axis] - grab_padding - grab_sz * 0.5f;
call    0 never executed
        -: 3000:
    #####: 3001:    float logarithmic_zero_epsilon = 0.0f; // Only valid when is_logarithmic is true
    #####: 3002:    float zero_deadzone_halfsize = 0.0f; // Only valid when is_logarithmic is true
    #####: 3003:    if (is_logarithmic)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3004:    {
        -: 3005:        // When using logarithmic sliders, we need to clamp to avoid hitting zero, but our choice of clamp value greatly affects slider precision. We attempt to use the specified precision to estimate a good lower bound.
    #####: 3006:        const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 1;
    %%%%%: 3006-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3006-block 19
call    2 never executed
    %%%%%: 3006-block 21
    #####: 3007:        logarithmic_zero_epsilon = ImPow(0.1f, (float)decimal_precision);
    %%%%%: 3007-block 22
call    0 never executed
    #####: 3008:        zero_deadzone_halfsize = (style.LogSliderDeadzone * 0.5f) / ImMax(slider_usable_sz, 1.0f);
call    0 never executed
        -: 3009:    }
        -: 3010:
        -: 3011:    // Process interacting with the slider
    #####: 3012:    bool value_changed = false;
    #####: 3013:    if (g.ActiveId == id)
    %%%%%: 3013-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3014:    {
    #####: 3015:        bool set_new_value = false;
    #####: 3016:        float clicked_t = 0.0f;
    #####: 3017:        if (g.ActiveIdSource == ImGuiInputSource_Mouse)
    %%%%%: 3017-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3018:        {
    #####: 3019:            if (!g.IO.MouseDown[0])
    %%%%%: 3019-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3020:            {
    #####: 3021:                ClearActiveID();
    %%%%%: 3021-block 28
call    0 never executed
        -: 3022:            }
        -: 3023:            else
        -: 3024:            {
    #####: 3025:                const float mouse_abs_pos = g.IO.MousePos[axis];
    %%%%%: 3025-block 29
call    0 never executed
    #####: 3026:                if (g.ActiveIdIsJustActivated)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3027:                {
    #####: 3028:                    float grab_t = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, *v, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
    %%%%%: 3028-block 31
call    0 never executed
    #####: 3029:                    if (axis == ImGuiAxis_Y)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3030:                        grab_t = 1.0f - grab_t;
    %%%%%: 3030-block 33
    #####: 3031:                    const float grab_pos = ImLerp(slider_usable_pos_min, slider_usable_pos_max, grab_t);
    %%%%%: 3031-block 34
call    0 never executed
    #####: 3032:                    const bool clicked_around_grab = (mouse_abs_pos >= grab_pos - grab_sz * 0.5f - 1.0f) && (mouse_abs_pos <= grab_pos + grab_sz * 0.5f + 1.0f); // No harm being extra generous here.
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3032-block 36
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3032-block 37
    %%%%%: 3032-block 38
    #####: 3033:                    g.SliderGrabClickOffset = (clicked_around_grab && is_floating_point) ? mouse_abs_pos - grab_pos : 0.0f;
    %%%%%: 3033-block 39
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3033-block 40
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3033-block 41
    %%%%%: 3033-block 42
    %%%%%: 3033-block 43
        -: 3034:                }
    #####: 3035:                if (slider_usable_sz > 0.0f)
    %%%%%: 3035-block 44
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3036:                    clicked_t = ImSaturate((mouse_abs_pos - g.SliderGrabClickOffset - slider_usable_pos_min) / slider_usable_sz);
    %%%%%: 3036-block 45
call    0 never executed
    #####: 3037:                if (axis == ImGuiAxis_Y)
    %%%%%: 3037-block 46
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3038:                    clicked_t = 1.0f - clicked_t;
    %%%%%: 3038-block 47
    #####: 3039:                set_new_value = true;
    %%%%%: 3039-block 48
        -: 3040:            }
        -: 3041:        }
    #####: 3042:        else if (g.ActiveIdSource == ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource_Gamepad)
    %%%%%: 3042-block 49
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3042-block 50
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 3043:        {
    #####: 3044:            if (g.ActiveIdIsJustActivated)
    %%%%%: 3044-block 51
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3045:            {
    #####: 3046:                g.SliderCurrentAccum = 0.0f; // Reset any stored nav delta upon activation
    #####: 3047:                g.SliderCurrentAccumDirty = false;
    %%%%%: 3047-block 52
        -: 3048:            }
        -: 3049:
    #####: 3050:            float input_delta = (axis == ImGuiAxis_X) ? GetNavTweakPressedAmount(axis) : -GetNavTweakPressedAmount(axis);
    %%%%%: 3050-block 53
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3050-block 54
call    2 never executed
    %%%%%: 3050-block 56
call    3 never executed
    #####: 3051:            if (input_delta != 0.0f)
    %%%%%: 3051-block 58
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3052:            {
    #####: 3053:                const bool tweak_slow = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakSlow : ImGuiKey_NavKeyboardTweakSlow);
    %%%%%: 3053-block 59
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3053-block 60
    %%%%%: 3053-block 61
    %%%%%: 3053-block 62
call    2 never executed
    #####: 3054:                const bool tweak_fast = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakFast : ImGuiKey_NavKeyboardTweakFast);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3054-block 64
    %%%%%: 3054-block 65
    %%%%%: 3054-block 66
call    2 never executed
    #####: 3055:                const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 0;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3055-block 68
call    2 never executed
    %%%%%: 3055-block 70
    #####: 3056:                if (decimal_precision > 0)
    %%%%%: 3056-block 71
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3057:                {
    #####: 3058:                    input_delta /= 100.0f; // Keyboard/Gamepad tweak speeds in % of slider bounds
    #####: 3059:                    if (tweak_slow)
    %%%%%: 3059-block 72
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3060:                        input_delta /= 10.0f;
    %%%%%: 3060-block 73
        -: 3061:                }
        -: 3062:                else
        -: 3063:                {
    #####: 3064:                    if ((v_range_f >= -100.0f && v_range_f <= 100.0f && v_range_f != 0.0f) || tweak_slow)
    %%%%%: 3064-block 74
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3064-block 75
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3064-block 76
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 3064-block 77
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 3065:                        input_delta = ((input_delta < 0.0f) ? -1.0f : +1.0f) / v_range_f; // Keyboard/Gamepad tweak speeds in integer steps
    %%%%%: 3065-block 78
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3065-block 79
    %%%%%: 3065-block 80
    %%%%%: 3065-block 81
        -: 3066:                    else
    #####: 3067:                        input_delta /= 100.0f;
    %%%%%: 3067-block 82
        -: 3068:                }
    #####: 3069:                if (tweak_fast)
    %%%%%: 3069-block 83
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3070:                    input_delta *= 10.0f;
    %%%%%: 3070-block 84
        -: 3071:
    #####: 3072:                g.SliderCurrentAccum += input_delta;
    #####: 3073:                g.SliderCurrentAccumDirty = true;
    %%%%%: 3073-block 85
        -: 3074:            }
        -: 3075:
    #####: 3076:            float delta = g.SliderCurrentAccum;
    #####: 3077:            if (g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated)
    %%%%%: 3077-block 86
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3077-block 87
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 3078:            {
    #####: 3079:                ClearActiveID();
    %%%%%: 3079-block 88
call    0 never executed
        -: 3080:            }
    #####: 3081:            else if (g.SliderCurrentAccumDirty)
    %%%%%: 3081-block 89
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3082:            {
    #####: 3083:                clicked_t = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, *v, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
    %%%%%: 3083-block 90
call    0 never executed
        -: 3084:
    #####: 3085:                if ((clicked_t >= 1.0f && delta > 0.0f) || (clicked_t <= 0.0f && delta < 0.0f)) // This is to avoid applying the saturation when already past the limits
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3085-block 92
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3085-block 93
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 3085-block 94
branch  6 never executed (fallthrough)
branch  7 never executed
        -: 3086:                {
    #####: 3087:                    set_new_value = false;
    #####: 3088:                    g.SliderCurrentAccum = 0.0f; // If pushing up against the limits, don't continue to accumulate
    %%%%%: 3088-block 95
        -: 3089:                }
        -: 3090:                else
        -: 3091:                {
    #####: 3092:                    set_new_value = true;
    #####: 3093:                    float old_clicked_t = clicked_t;
    #####: 3094:                    clicked_t = ImSaturate(clicked_t + delta);
    %%%%%: 3094-block 96
call    0 never executed
        -: 3095:
        -: 3096:                    // Calculate what our "new" clicked_t will be, and thus how far we actually moved the slider, and subtract this from the accumulator
    #####: 3097:                    TYPE v_new = ScaleValueFromRatioT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, clicked_t, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
call    0 never executed
    #####: 3098:                    if (is_floating_point && !(flags & ImGuiSliderFlags_NoRoundToFormat))
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3098-block 99
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3099:                        v_new = RoundScalarWithFormatT<TYPE>(format, data_type, v_new);
    %%%%%: 3099-block 100
call    0 never executed
    #####: 3100:                    float new_clicked_t = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_new, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
    %%%%%: 3100-block 102
call    0 never executed
        -: 3101:
    #####: 3102:                    if (delta > 0)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3103:                        g.SliderCurrentAccum -= ImMin(new_clicked_t - old_clicked_t, delta);
    %%%%%: 3103-block 104
call    0 never executed
        -: 3104:                    else
    #####: 3105:                        g.SliderCurrentAccum -= ImMax(new_clicked_t - old_clicked_t, delta);
    %%%%%: 3105-block 106
call    0 never executed
        -: 3106:                }
        -: 3107:
    #####: 3108:                g.SliderCurrentAccumDirty = false;
    %%%%%: 3108-block 108
        -: 3109:            }
        -: 3110:        }
        -: 3111:
    #####: 3112:        if (set_new_value)
    %%%%%: 3112-block 109
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3113:            if ((g.LastItemData.ItemFlags & ImGuiItemFlags_ReadOnly) || (flags & ImGuiSliderFlags_ReadOnly))
    %%%%%: 3113-block 110
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3113-block 111
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3114:                set_new_value = false;
    %%%%%: 3114-block 112
        -: 3115:
    #####: 3116:        if (set_new_value)
    %%%%%: 3116-block 113
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3117:        {
    #####: 3118:            TYPE v_new = ScaleValueFromRatioT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, clicked_t, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
    %%%%%: 3118-block 114
call    0 never executed
        -: 3119:
        -: 3120:            // Round to user desired precision based on format string
    #####: 3121:            if (is_floating_point && !(flags & ImGuiSliderFlags_NoRoundToFormat))
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3121-block 116
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3122:                v_new = RoundScalarWithFormatT<TYPE>(format, data_type, v_new);
    %%%%%: 3122-block 117
call    0 never executed
        -: 3123:
        -: 3124:            // Apply result
    #####: 3125:            if (*v != v_new)
    %%%%%: 3125-block 119
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3126:            {
    #####: 3127:                *v = v_new;
    #####: 3128:                value_changed = true;
    %%%%%: 3128-block 120
        -: 3129:            }
        -: 3130:        }
        -: 3131:    }
        -: 3132:
    #####: 3133:    if (slider_sz < 1.0f)
    %%%%%: 3133-block 121
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3134:    {
    #####: 3135:        *out_grab_bb = ImRect(bb.Min, bb.Min);
    %%%%%: 3135-block 122
call    0 never executed
        -: 3136:    }
        -: 3137:    else
        -: 3138:    {
        -: 3139:        // Output grab position so it can be displayed by the caller
    #####: 3140:        float grab_t = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, *v, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
    %%%%%: 3140-block 124
call    0 never executed
    #####: 3141:        if (axis == ImGuiAxis_Y)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3142:            grab_t = 1.0f - grab_t;
    %%%%%: 3142-block 126
    #####: 3143:        const float grab_pos = ImLerp(slider_usable_pos_min, slider_usable_pos_max, grab_t);
    %%%%%: 3143-block 127
call    0 never executed
    #####: 3144:        if (axis == ImGuiAxis_X)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3145:            *out_grab_bb = ImRect(grab_pos - grab_sz * 0.5f, bb.Min.y + grab_padding, grab_pos + grab_sz * 0.5f, bb.Max.y - grab_padding);
    %%%%%: 3145-block 129
call    0 never executed
        -: 3146:        else
    #####: 3147:            *out_grab_bb = ImRect(bb.Min.x + grab_padding, grab_pos - grab_sz * 0.5f, bb.Max.x - grab_padding, grab_pos + grab_sz * 0.5f);
    %%%%%: 3147-block 131
call    0 never executed
        -: 3148:    }
        -: 3149:
    #####: 3150:    return value_changed;
    %%%%%: 3150-block 133
        -: 3151:}
------------------
_ZN5ImGui15SliderBehaviorTIyxdEEbRK6ImRectjiPT_S4_S4_PKciPS1_:
function _ZN5ImGui15SliderBehaviorTIyxdEEbRK6ImRectjiPT_S4_S4_PKciPS1_ called 0 returned 0% blocks executed 0%
    #####: 2980:bool ImGui::SliderBehaviorT(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, TYPE* v, const TYPE v_min, const TYPE v_max, const char* format, ImGuiSliderFlags flags, ImRect* out_grab_bb)
        -: 2981:{
    #####: 2982:    ImGuiContext& g = *GImGui;
    #####: 2983:    const ImGuiStyle& style = g.Style;
        -: 2984:
    #####: 2985:    const ImGuiAxis axis = (flags & ImGuiSliderFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;
    #####: 2986:    const bool is_logarithmic = (flags & ImGuiSliderFlags_Logarithmic) != 0;
    #####: 2987:    const bool is_floating_point = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);
    %%%%%: 2987-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2987-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2987-block 4
    %%%%%: 2987-block 5
    #####: 2988:    const float v_range_f = (float)(v_min < v_max ? v_max - v_min : v_min - v_max); // We don't need high precision for what we do with it.
    %%%%%: 2988-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2988-block 7
    %%%%%: 2988-block 8
        -: 2989:
        -: 2990:    // Calculate bounds
    #####: 2991:    const float grab_padding = 2.0f; // FIXME: Should be part of style.
    #####: 2992:    const float slider_sz = (bb.Max[axis] - bb.Min[axis]) - grab_padding * 2.0f;
    %%%%%: 2992-block 9
call    0 never executed
call    1 never executed
    #####: 2993:    float grab_sz = style.GrabMinSize;
    #####: 2994:    if (!is_floating_point && v_range_f >= 0.0f)                         // v_range_f < 0 may happen on integer overflows
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2994-block 12
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2995:        grab_sz = ImMax(slider_sz / (v_range_f + 1), style.GrabMinSize); // For integer sliders: if possible have the grab size represent 1 unit
    %%%%%: 2995-block 13
call    0 never executed
    #####: 2996:    grab_sz = ImMin(grab_sz, slider_sz);
    %%%%%: 2996-block 14
call    0 never executed
    #####: 2997:    const float slider_usable_sz = slider_sz - grab_sz;
    #####: 2998:    const float slider_usable_pos_min = bb.Min[axis] + grab_padding + grab_sz * 0.5f;
call    0 never executed
    #####: 2999:    const float slider_usable_pos_max = bb.Max[axis] - grab_padding - grab_sz * 0.5f;
call    0 never executed
        -: 3000:
    #####: 3001:    float logarithmic_zero_epsilon = 0.0f; // Only valid when is_logarithmic is true
    #####: 3002:    float zero_deadzone_halfsize = 0.0f; // Only valid when is_logarithmic is true
    #####: 3003:    if (is_logarithmic)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3004:    {
        -: 3005:        // When using logarithmic sliders, we need to clamp to avoid hitting zero, but our choice of clamp value greatly affects slider precision. We attempt to use the specified precision to estimate a good lower bound.
    #####: 3006:        const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 1;
    %%%%%: 3006-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3006-block 19
call    2 never executed
    %%%%%: 3006-block 21
    #####: 3007:        logarithmic_zero_epsilon = ImPow(0.1f, (float)decimal_precision);
    %%%%%: 3007-block 22
call    0 never executed
    #####: 3008:        zero_deadzone_halfsize = (style.LogSliderDeadzone * 0.5f) / ImMax(slider_usable_sz, 1.0f);
call    0 never executed
        -: 3009:    }
        -: 3010:
        -: 3011:    // Process interacting with the slider
    #####: 3012:    bool value_changed = false;
    #####: 3013:    if (g.ActiveId == id)
    %%%%%: 3013-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3014:    {
    #####: 3015:        bool set_new_value = false;
    #####: 3016:        float clicked_t = 0.0f;
    #####: 3017:        if (g.ActiveIdSource == ImGuiInputSource_Mouse)
    %%%%%: 3017-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3018:        {
    #####: 3019:            if (!g.IO.MouseDown[0])
    %%%%%: 3019-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3020:            {
    #####: 3021:                ClearActiveID();
    %%%%%: 3021-block 28
call    0 never executed
        -: 3022:            }
        -: 3023:            else
        -: 3024:            {
    #####: 3025:                const float mouse_abs_pos = g.IO.MousePos[axis];
    %%%%%: 3025-block 29
call    0 never executed
    #####: 3026:                if (g.ActiveIdIsJustActivated)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3027:                {
    #####: 3028:                    float grab_t = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, *v, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
    %%%%%: 3028-block 31
call    0 never executed
    #####: 3029:                    if (axis == ImGuiAxis_Y)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3030:                        grab_t = 1.0f - grab_t;
    %%%%%: 3030-block 33
    #####: 3031:                    const float grab_pos = ImLerp(slider_usable_pos_min, slider_usable_pos_max, grab_t);
    %%%%%: 3031-block 34
call    0 never executed
    #####: 3032:                    const bool clicked_around_grab = (mouse_abs_pos >= grab_pos - grab_sz * 0.5f - 1.0f) && (mouse_abs_pos <= grab_pos + grab_sz * 0.5f + 1.0f); // No harm being extra generous here.
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3032-block 36
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3032-block 37
    %%%%%: 3032-block 38
    #####: 3033:                    g.SliderGrabClickOffset = (clicked_around_grab && is_floating_point) ? mouse_abs_pos - grab_pos : 0.0f;
    %%%%%: 3033-block 39
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3033-block 40
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3033-block 41
    %%%%%: 3033-block 42
    %%%%%: 3033-block 43
        -: 3034:                }
    #####: 3035:                if (slider_usable_sz > 0.0f)
    %%%%%: 3035-block 44
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3036:                    clicked_t = ImSaturate((mouse_abs_pos - g.SliderGrabClickOffset - slider_usable_pos_min) / slider_usable_sz);
    %%%%%: 3036-block 45
call    0 never executed
    #####: 3037:                if (axis == ImGuiAxis_Y)
    %%%%%: 3037-block 46
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3038:                    clicked_t = 1.0f - clicked_t;
    %%%%%: 3038-block 47
    #####: 3039:                set_new_value = true;
    %%%%%: 3039-block 48
        -: 3040:            }
        -: 3041:        }
    #####: 3042:        else if (g.ActiveIdSource == ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource_Gamepad)
    %%%%%: 3042-block 49
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3042-block 50
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 3043:        {
    #####: 3044:            if (g.ActiveIdIsJustActivated)
    %%%%%: 3044-block 51
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3045:            {
    #####: 3046:                g.SliderCurrentAccum = 0.0f; // Reset any stored nav delta upon activation
    #####: 3047:                g.SliderCurrentAccumDirty = false;
    %%%%%: 3047-block 52
        -: 3048:            }
        -: 3049:
    #####: 3050:            float input_delta = (axis == ImGuiAxis_X) ? GetNavTweakPressedAmount(axis) : -GetNavTweakPressedAmount(axis);
    %%%%%: 3050-block 53
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3050-block 54
call    2 never executed
    %%%%%: 3050-block 56
call    3 never executed
    #####: 3051:            if (input_delta != 0.0f)
    %%%%%: 3051-block 58
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3052:            {
    #####: 3053:                const bool tweak_slow = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakSlow : ImGuiKey_NavKeyboardTweakSlow);
    %%%%%: 3053-block 59
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3053-block 60
    %%%%%: 3053-block 61
    %%%%%: 3053-block 62
call    2 never executed
    #####: 3054:                const bool tweak_fast = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakFast : ImGuiKey_NavKeyboardTweakFast);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3054-block 64
    %%%%%: 3054-block 65
    %%%%%: 3054-block 66
call    2 never executed
    #####: 3055:                const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 0;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3055-block 68
call    2 never executed
    %%%%%: 3055-block 70
    #####: 3056:                if (decimal_precision > 0)
    %%%%%: 3056-block 71
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3057:                {
    #####: 3058:                    input_delta /= 100.0f; // Keyboard/Gamepad tweak speeds in % of slider bounds
    #####: 3059:                    if (tweak_slow)
    %%%%%: 3059-block 72
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3060:                        input_delta /= 10.0f;
    %%%%%: 3060-block 73
        -: 3061:                }
        -: 3062:                else
        -: 3063:                {
    #####: 3064:                    if ((v_range_f >= -100.0f && v_range_f <= 100.0f && v_range_f != 0.0f) || tweak_slow)
    %%%%%: 3064-block 74
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3064-block 75
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3064-block 76
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 3064-block 77
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 3065:                        input_delta = ((input_delta < 0.0f) ? -1.0f : +1.0f) / v_range_f; // Keyboard/Gamepad tweak speeds in integer steps
    %%%%%: 3065-block 78
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3065-block 79
    %%%%%: 3065-block 80
    %%%%%: 3065-block 81
        -: 3066:                    else
    #####: 3067:                        input_delta /= 100.0f;
    %%%%%: 3067-block 82
        -: 3068:                }
    #####: 3069:                if (tweak_fast)
    %%%%%: 3069-block 83
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3070:                    input_delta *= 10.0f;
    %%%%%: 3070-block 84
        -: 3071:
    #####: 3072:                g.SliderCurrentAccum += input_delta;
    #####: 3073:                g.SliderCurrentAccumDirty = true;
    %%%%%: 3073-block 85
        -: 3074:            }
        -: 3075:
    #####: 3076:            float delta = g.SliderCurrentAccum;
    #####: 3077:            if (g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated)
    %%%%%: 3077-block 86
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3077-block 87
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 3078:            {
    #####: 3079:                ClearActiveID();
    %%%%%: 3079-block 88
call    0 never executed
        -: 3080:            }
    #####: 3081:            else if (g.SliderCurrentAccumDirty)
    %%%%%: 3081-block 89
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3082:            {
    #####: 3083:                clicked_t = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, *v, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
    %%%%%: 3083-block 90
call    0 never executed
        -: 3084:
    #####: 3085:                if ((clicked_t >= 1.0f && delta > 0.0f) || (clicked_t <= 0.0f && delta < 0.0f)) // This is to avoid applying the saturation when already past the limits
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3085-block 92
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3085-block 93
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 3085-block 94
branch  6 never executed (fallthrough)
branch  7 never executed
        -: 3086:                {
    #####: 3087:                    set_new_value = false;
    #####: 3088:                    g.SliderCurrentAccum = 0.0f; // If pushing up against the limits, don't continue to accumulate
    %%%%%: 3088-block 95
        -: 3089:                }
        -: 3090:                else
        -: 3091:                {
    #####: 3092:                    set_new_value = true;
    #####: 3093:                    float old_clicked_t = clicked_t;
    #####: 3094:                    clicked_t = ImSaturate(clicked_t + delta);
    %%%%%: 3094-block 96
call    0 never executed
        -: 3095:
        -: 3096:                    // Calculate what our "new" clicked_t will be, and thus how far we actually moved the slider, and subtract this from the accumulator
    #####: 3097:                    TYPE v_new = ScaleValueFromRatioT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, clicked_t, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
call    0 never executed
    #####: 3098:                    if (is_floating_point && !(flags & ImGuiSliderFlags_NoRoundToFormat))
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3098-block 99
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3099:                        v_new = RoundScalarWithFormatT<TYPE>(format, data_type, v_new);
    %%%%%: 3099-block 100
call    0 never executed
    #####: 3100:                    float new_clicked_t = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_new, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
    %%%%%: 3100-block 102
call    0 never executed
        -: 3101:
    #####: 3102:                    if (delta > 0)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3103:                        g.SliderCurrentAccum -= ImMin(new_clicked_t - old_clicked_t, delta);
    %%%%%: 3103-block 104
call    0 never executed
        -: 3104:                    else
    #####: 3105:                        g.SliderCurrentAccum -= ImMax(new_clicked_t - old_clicked_t, delta);
    %%%%%: 3105-block 106
call    0 never executed
        -: 3106:                }
        -: 3107:
    #####: 3108:                g.SliderCurrentAccumDirty = false;
    %%%%%: 3108-block 108
        -: 3109:            }
        -: 3110:        }
        -: 3111:
    #####: 3112:        if (set_new_value)
    %%%%%: 3112-block 109
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3113:            if ((g.LastItemData.ItemFlags & ImGuiItemFlags_ReadOnly) || (flags & ImGuiSliderFlags_ReadOnly))
    %%%%%: 3113-block 110
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3113-block 111
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3114:                set_new_value = false;
    %%%%%: 3114-block 112
        -: 3115:
    #####: 3116:        if (set_new_value)
    %%%%%: 3116-block 113
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3117:        {
    #####: 3118:            TYPE v_new = ScaleValueFromRatioT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, clicked_t, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
    %%%%%: 3118-block 114
call    0 never executed
        -: 3119:
        -: 3120:            // Round to user desired precision based on format string
    #####: 3121:            if (is_floating_point && !(flags & ImGuiSliderFlags_NoRoundToFormat))
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3121-block 116
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3122:                v_new = RoundScalarWithFormatT<TYPE>(format, data_type, v_new);
    %%%%%: 3122-block 117
call    0 never executed
        -: 3123:
        -: 3124:            // Apply result
    #####: 3125:            if (*v != v_new)
    %%%%%: 3125-block 119
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3126:            {
    #####: 3127:                *v = v_new;
    #####: 3128:                value_changed = true;
    %%%%%: 3128-block 120
        -: 3129:            }
        -: 3130:        }
        -: 3131:    }
        -: 3132:
    #####: 3133:    if (slider_sz < 1.0f)
    %%%%%: 3133-block 121
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3134:    {
    #####: 3135:        *out_grab_bb = ImRect(bb.Min, bb.Min);
    %%%%%: 3135-block 122
call    0 never executed
        -: 3136:    }
        -: 3137:    else
        -: 3138:    {
        -: 3139:        // Output grab position so it can be displayed by the caller
    #####: 3140:        float grab_t = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, *v, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
    %%%%%: 3140-block 124
call    0 never executed
    #####: 3141:        if (axis == ImGuiAxis_Y)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3142:            grab_t = 1.0f - grab_t;
    %%%%%: 3142-block 126
    #####: 3143:        const float grab_pos = ImLerp(slider_usable_pos_min, slider_usable_pos_max, grab_t);
    %%%%%: 3143-block 127
call    0 never executed
    #####: 3144:        if (axis == ImGuiAxis_X)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3145:            *out_grab_bb = ImRect(grab_pos - grab_sz * 0.5f, bb.Min.y + grab_padding, grab_pos + grab_sz * 0.5f, bb.Max.y - grab_padding);
    %%%%%: 3145-block 129
call    0 never executed
        -: 3146:        else
    #####: 3147:            *out_grab_bb = ImRect(bb.Min.x + grab_padding, grab_pos - grab_sz * 0.5f, bb.Max.x - grab_padding, grab_pos + grab_sz * 0.5f);
    %%%%%: 3147-block 131
call    0 never executed
        -: 3148:    }
        -: 3149:
    #####: 3150:    return value_changed;
    %%%%%: 3150-block 133
        -: 3151:}
------------------
_ZN5ImGui15SliderBehaviorTIxxdEEbRK6ImRectjiPT_S4_S4_PKciPS1_:
function _ZN5ImGui15SliderBehaviorTIxxdEEbRK6ImRectjiPT_S4_S4_PKciPS1_ called 0 returned 0% blocks executed 0%
    #####: 2980:bool ImGui::SliderBehaviorT(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, TYPE* v, const TYPE v_min, const TYPE v_max, const char* format, ImGuiSliderFlags flags, ImRect* out_grab_bb)
        -: 2981:{
    #####: 2982:    ImGuiContext& g = *GImGui;
    #####: 2983:    const ImGuiStyle& style = g.Style;
        -: 2984:
    #####: 2985:    const ImGuiAxis axis = (flags & ImGuiSliderFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;
    #####: 2986:    const bool is_logarithmic = (flags & ImGuiSliderFlags_Logarithmic) != 0;
    #####: 2987:    const bool is_floating_point = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);
    %%%%%: 2987-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2987-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2987-block 4
    %%%%%: 2987-block 5
    #####: 2988:    const float v_range_f = (float)(v_min < v_max ? v_max - v_min : v_min - v_max); // We don't need high precision for what we do with it.
    %%%%%: 2988-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2988-block 7
    %%%%%: 2988-block 8
        -: 2989:
        -: 2990:    // Calculate bounds
    #####: 2991:    const float grab_padding = 2.0f; // FIXME: Should be part of style.
    #####: 2992:    const float slider_sz = (bb.Max[axis] - bb.Min[axis]) - grab_padding * 2.0f;
    %%%%%: 2992-block 9
call    0 never executed
call    1 never executed
    #####: 2993:    float grab_sz = style.GrabMinSize;
    #####: 2994:    if (!is_floating_point && v_range_f >= 0.0f)                         // v_range_f < 0 may happen on integer overflows
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2994-block 12
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2995:        grab_sz = ImMax(slider_sz / (v_range_f + 1), style.GrabMinSize); // For integer sliders: if possible have the grab size represent 1 unit
    %%%%%: 2995-block 13
call    0 never executed
    #####: 2996:    grab_sz = ImMin(grab_sz, slider_sz);
    %%%%%: 2996-block 14
call    0 never executed
    #####: 2997:    const float slider_usable_sz = slider_sz - grab_sz;
    #####: 2998:    const float slider_usable_pos_min = bb.Min[axis] + grab_padding + grab_sz * 0.5f;
call    0 never executed
    #####: 2999:    const float slider_usable_pos_max = bb.Max[axis] - grab_padding - grab_sz * 0.5f;
call    0 never executed
        -: 3000:
    #####: 3001:    float logarithmic_zero_epsilon = 0.0f; // Only valid when is_logarithmic is true
    #####: 3002:    float zero_deadzone_halfsize = 0.0f; // Only valid when is_logarithmic is true
    #####: 3003:    if (is_logarithmic)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3004:    {
        -: 3005:        // When using logarithmic sliders, we need to clamp to avoid hitting zero, but our choice of clamp value greatly affects slider precision. We attempt to use the specified precision to estimate a good lower bound.
    #####: 3006:        const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 1;
    %%%%%: 3006-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3006-block 19
call    2 never executed
    %%%%%: 3006-block 21
    #####: 3007:        logarithmic_zero_epsilon = ImPow(0.1f, (float)decimal_precision);
    %%%%%: 3007-block 22
call    0 never executed
    #####: 3008:        zero_deadzone_halfsize = (style.LogSliderDeadzone * 0.5f) / ImMax(slider_usable_sz, 1.0f);
call    0 never executed
        -: 3009:    }
        -: 3010:
        -: 3011:    // Process interacting with the slider
    #####: 3012:    bool value_changed = false;
    #####: 3013:    if (g.ActiveId == id)
    %%%%%: 3013-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3014:    {
    #####: 3015:        bool set_new_value = false;
    #####: 3016:        float clicked_t = 0.0f;
    #####: 3017:        if (g.ActiveIdSource == ImGuiInputSource_Mouse)
    %%%%%: 3017-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3018:        {
    #####: 3019:            if (!g.IO.MouseDown[0])
    %%%%%: 3019-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3020:            {
    #####: 3021:                ClearActiveID();
    %%%%%: 3021-block 28
call    0 never executed
        -: 3022:            }
        -: 3023:            else
        -: 3024:            {
    #####: 3025:                const float mouse_abs_pos = g.IO.MousePos[axis];
    %%%%%: 3025-block 29
call    0 never executed
    #####: 3026:                if (g.ActiveIdIsJustActivated)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3027:                {
    #####: 3028:                    float grab_t = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, *v, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
    %%%%%: 3028-block 31
call    0 never executed
    #####: 3029:                    if (axis == ImGuiAxis_Y)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3030:                        grab_t = 1.0f - grab_t;
    %%%%%: 3030-block 33
    #####: 3031:                    const float grab_pos = ImLerp(slider_usable_pos_min, slider_usable_pos_max, grab_t);
    %%%%%: 3031-block 34
call    0 never executed
    #####: 3032:                    const bool clicked_around_grab = (mouse_abs_pos >= grab_pos - grab_sz * 0.5f - 1.0f) && (mouse_abs_pos <= grab_pos + grab_sz * 0.5f + 1.0f); // No harm being extra generous here.
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3032-block 36
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3032-block 37
    %%%%%: 3032-block 38
    #####: 3033:                    g.SliderGrabClickOffset = (clicked_around_grab && is_floating_point) ? mouse_abs_pos - grab_pos : 0.0f;
    %%%%%: 3033-block 39
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3033-block 40
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3033-block 41
    %%%%%: 3033-block 42
    %%%%%: 3033-block 43
        -: 3034:                }
    #####: 3035:                if (slider_usable_sz > 0.0f)
    %%%%%: 3035-block 44
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3036:                    clicked_t = ImSaturate((mouse_abs_pos - g.SliderGrabClickOffset - slider_usable_pos_min) / slider_usable_sz);
    %%%%%: 3036-block 45
call    0 never executed
    #####: 3037:                if (axis == ImGuiAxis_Y)
    %%%%%: 3037-block 46
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3038:                    clicked_t = 1.0f - clicked_t;
    %%%%%: 3038-block 47
    #####: 3039:                set_new_value = true;
    %%%%%: 3039-block 48
        -: 3040:            }
        -: 3041:        }
    #####: 3042:        else if (g.ActiveIdSource == ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource_Gamepad)
    %%%%%: 3042-block 49
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3042-block 50
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 3043:        {
    #####: 3044:            if (g.ActiveIdIsJustActivated)
    %%%%%: 3044-block 51
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3045:            {
    #####: 3046:                g.SliderCurrentAccum = 0.0f; // Reset any stored nav delta upon activation
    #####: 3047:                g.SliderCurrentAccumDirty = false;
    %%%%%: 3047-block 52
        -: 3048:            }
        -: 3049:
    #####: 3050:            float input_delta = (axis == ImGuiAxis_X) ? GetNavTweakPressedAmount(axis) : -GetNavTweakPressedAmount(axis);
    %%%%%: 3050-block 53
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3050-block 54
call    2 never executed
    %%%%%: 3050-block 56
call    3 never executed
    #####: 3051:            if (input_delta != 0.0f)
    %%%%%: 3051-block 58
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3052:            {
    #####: 3053:                const bool tweak_slow = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakSlow : ImGuiKey_NavKeyboardTweakSlow);
    %%%%%: 3053-block 59
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3053-block 60
    %%%%%: 3053-block 61
    %%%%%: 3053-block 62
call    2 never executed
    #####: 3054:                const bool tweak_fast = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakFast : ImGuiKey_NavKeyboardTweakFast);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3054-block 64
    %%%%%: 3054-block 65
    %%%%%: 3054-block 66
call    2 never executed
    #####: 3055:                const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 0;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3055-block 68
call    2 never executed
    %%%%%: 3055-block 70
    #####: 3056:                if (decimal_precision > 0)
    %%%%%: 3056-block 71
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3057:                {
    #####: 3058:                    input_delta /= 100.0f; // Keyboard/Gamepad tweak speeds in % of slider bounds
    #####: 3059:                    if (tweak_slow)
    %%%%%: 3059-block 72
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3060:                        input_delta /= 10.0f;
    %%%%%: 3060-block 73
        -: 3061:                }
        -: 3062:                else
        -: 3063:                {
    #####: 3064:                    if ((v_range_f >= -100.0f && v_range_f <= 100.0f && v_range_f != 0.0f) || tweak_slow)
    %%%%%: 3064-block 74
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3064-block 75
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3064-block 76
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 3064-block 77
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 3065:                        input_delta = ((input_delta < 0.0f) ? -1.0f : +1.0f) / v_range_f; // Keyboard/Gamepad tweak speeds in integer steps
    %%%%%: 3065-block 78
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3065-block 79
    %%%%%: 3065-block 80
    %%%%%: 3065-block 81
        -: 3066:                    else
    #####: 3067:                        input_delta /= 100.0f;
    %%%%%: 3067-block 82
        -: 3068:                }
    #####: 3069:                if (tweak_fast)
    %%%%%: 3069-block 83
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3070:                    input_delta *= 10.0f;
    %%%%%: 3070-block 84
        -: 3071:
    #####: 3072:                g.SliderCurrentAccum += input_delta;
    #####: 3073:                g.SliderCurrentAccumDirty = true;
    %%%%%: 3073-block 85
        -: 3074:            }
        -: 3075:
    #####: 3076:            float delta = g.SliderCurrentAccum;
    #####: 3077:            if (g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated)
    %%%%%: 3077-block 86
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3077-block 87
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 3078:            {
    #####: 3079:                ClearActiveID();
    %%%%%: 3079-block 88
call    0 never executed
        -: 3080:            }
    #####: 3081:            else if (g.SliderCurrentAccumDirty)
    %%%%%: 3081-block 89
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3082:            {
    #####: 3083:                clicked_t = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, *v, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
    %%%%%: 3083-block 90
call    0 never executed
        -: 3084:
    #####: 3085:                if ((clicked_t >= 1.0f && delta > 0.0f) || (clicked_t <= 0.0f && delta < 0.0f)) // This is to avoid applying the saturation when already past the limits
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3085-block 92
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3085-block 93
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 3085-block 94
branch  6 never executed (fallthrough)
branch  7 never executed
        -: 3086:                {
    #####: 3087:                    set_new_value = false;
    #####: 3088:                    g.SliderCurrentAccum = 0.0f; // If pushing up against the limits, don't continue to accumulate
    %%%%%: 3088-block 95
        -: 3089:                }
        -: 3090:                else
        -: 3091:                {
    #####: 3092:                    set_new_value = true;
    #####: 3093:                    float old_clicked_t = clicked_t;
    #####: 3094:                    clicked_t = ImSaturate(clicked_t + delta);
    %%%%%: 3094-block 96
call    0 never executed
        -: 3095:
        -: 3096:                    // Calculate what our "new" clicked_t will be, and thus how far we actually moved the slider, and subtract this from the accumulator
    #####: 3097:                    TYPE v_new = ScaleValueFromRatioT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, clicked_t, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
call    0 never executed
    #####: 3098:                    if (is_floating_point && !(flags & ImGuiSliderFlags_NoRoundToFormat))
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3098-block 99
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3099:                        v_new = RoundScalarWithFormatT<TYPE>(format, data_type, v_new);
    %%%%%: 3099-block 100
call    0 never executed
    #####: 3100:                    float new_clicked_t = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_new, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
    %%%%%: 3100-block 102
call    0 never executed
        -: 3101:
    #####: 3102:                    if (delta > 0)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3103:                        g.SliderCurrentAccum -= ImMin(new_clicked_t - old_clicked_t, delta);
    %%%%%: 3103-block 104
call    0 never executed
        -: 3104:                    else
    #####: 3105:                        g.SliderCurrentAccum -= ImMax(new_clicked_t - old_clicked_t, delta);
    %%%%%: 3105-block 106
call    0 never executed
        -: 3106:                }
        -: 3107:
    #####: 3108:                g.SliderCurrentAccumDirty = false;
    %%%%%: 3108-block 108
        -: 3109:            }
        -: 3110:        }
        -: 3111:
    #####: 3112:        if (set_new_value)
    %%%%%: 3112-block 109
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3113:            if ((g.LastItemData.ItemFlags & ImGuiItemFlags_ReadOnly) || (flags & ImGuiSliderFlags_ReadOnly))
    %%%%%: 3113-block 110
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3113-block 111
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3114:                set_new_value = false;
    %%%%%: 3114-block 112
        -: 3115:
    #####: 3116:        if (set_new_value)
    %%%%%: 3116-block 113
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3117:        {
    #####: 3118:            TYPE v_new = ScaleValueFromRatioT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, clicked_t, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
    %%%%%: 3118-block 114
call    0 never executed
        -: 3119:
        -: 3120:            // Round to user desired precision based on format string
    #####: 3121:            if (is_floating_point && !(flags & ImGuiSliderFlags_NoRoundToFormat))
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3121-block 116
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3122:                v_new = RoundScalarWithFormatT<TYPE>(format, data_type, v_new);
    %%%%%: 3122-block 117
call    0 never executed
        -: 3123:
        -: 3124:            // Apply result
    #####: 3125:            if (*v != v_new)
    %%%%%: 3125-block 119
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3126:            {
    #####: 3127:                *v = v_new;
    #####: 3128:                value_changed = true;
    %%%%%: 3128-block 120
        -: 3129:            }
        -: 3130:        }
        -: 3131:    }
        -: 3132:
    #####: 3133:    if (slider_sz < 1.0f)
    %%%%%: 3133-block 121
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3134:    {
    #####: 3135:        *out_grab_bb = ImRect(bb.Min, bb.Min);
    %%%%%: 3135-block 122
call    0 never executed
        -: 3136:    }
        -: 3137:    else
        -: 3138:    {
        -: 3139:        // Output grab position so it can be displayed by the caller
    #####: 3140:        float grab_t = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, *v, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
    %%%%%: 3140-block 124
call    0 never executed
    #####: 3141:        if (axis == ImGuiAxis_Y)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3142:            grab_t = 1.0f - grab_t;
    %%%%%: 3142-block 126
    #####: 3143:        const float grab_pos = ImLerp(slider_usable_pos_min, slider_usable_pos_max, grab_t);
    %%%%%: 3143-block 127
call    0 never executed
    #####: 3144:        if (axis == ImGuiAxis_X)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3145:            *out_grab_bb = ImRect(grab_pos - grab_sz * 0.5f, bb.Min.y + grab_padding, grab_pos + grab_sz * 0.5f, bb.Max.y - grab_padding);
    %%%%%: 3145-block 129
call    0 never executed
        -: 3146:        else
    #####: 3147:            *out_grab_bb = ImRect(bb.Min.x + grab_padding, grab_pos - grab_sz * 0.5f, bb.Max.x - grab_padding, grab_pos + grab_sz * 0.5f);
    %%%%%: 3147-block 131
call    0 never executed
        -: 3148:    }
        -: 3149:
    #####: 3150:    return value_changed;
    %%%%%: 3150-block 133
        -: 3151:}
------------------
_ZN5ImGui15SliderBehaviorTIjifEEbRK6ImRectjiPT_S4_S4_PKciPS1_:
function _ZN5ImGui15SliderBehaviorTIjifEEbRK6ImRectjiPT_S4_S4_PKciPS1_ called 0 returned 0% blocks executed 0%
    #####: 2980:bool ImGui::SliderBehaviorT(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, TYPE* v, const TYPE v_min, const TYPE v_max, const char* format, ImGuiSliderFlags flags, ImRect* out_grab_bb)
        -: 2981:{
    #####: 2982:    ImGuiContext& g = *GImGui;
    #####: 2983:    const ImGuiStyle& style = g.Style;
        -: 2984:
    #####: 2985:    const ImGuiAxis axis = (flags & ImGuiSliderFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;
    #####: 2986:    const bool is_logarithmic = (flags & ImGuiSliderFlags_Logarithmic) != 0;
    #####: 2987:    const bool is_floating_point = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);
    %%%%%: 2987-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2987-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2987-block 4
    %%%%%: 2987-block 5
    #####: 2988:    const float v_range_f = (float)(v_min < v_max ? v_max - v_min : v_min - v_max); // We don't need high precision for what we do with it.
    %%%%%: 2988-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2988-block 7
    %%%%%: 2988-block 8
        -: 2989:
        -: 2990:    // Calculate bounds
    #####: 2991:    const float grab_padding = 2.0f; // FIXME: Should be part of style.
    #####: 2992:    const float slider_sz = (bb.Max[axis] - bb.Min[axis]) - grab_padding * 2.0f;
    %%%%%: 2992-block 9
call    0 never executed
call    1 never executed
    #####: 2993:    float grab_sz = style.GrabMinSize;
    #####: 2994:    if (!is_floating_point && v_range_f >= 0.0f)                         // v_range_f < 0 may happen on integer overflows
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2994-block 12
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2995:        grab_sz = ImMax(slider_sz / (v_range_f + 1), style.GrabMinSize); // For integer sliders: if possible have the grab size represent 1 unit
    %%%%%: 2995-block 13
call    0 never executed
    #####: 2996:    grab_sz = ImMin(grab_sz, slider_sz);
    %%%%%: 2996-block 14
call    0 never executed
    #####: 2997:    const float slider_usable_sz = slider_sz - grab_sz;
    #####: 2998:    const float slider_usable_pos_min = bb.Min[axis] + grab_padding + grab_sz * 0.5f;
call    0 never executed
    #####: 2999:    const float slider_usable_pos_max = bb.Max[axis] - grab_padding - grab_sz * 0.5f;
call    0 never executed
        -: 3000:
    #####: 3001:    float logarithmic_zero_epsilon = 0.0f; // Only valid when is_logarithmic is true
    #####: 3002:    float zero_deadzone_halfsize = 0.0f; // Only valid when is_logarithmic is true
    #####: 3003:    if (is_logarithmic)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3004:    {
        -: 3005:        // When using logarithmic sliders, we need to clamp to avoid hitting zero, but our choice of clamp value greatly affects slider precision. We attempt to use the specified precision to estimate a good lower bound.
    #####: 3006:        const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 1;
    %%%%%: 3006-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3006-block 19
call    2 never executed
    %%%%%: 3006-block 21
    #####: 3007:        logarithmic_zero_epsilon = ImPow(0.1f, (float)decimal_precision);
    %%%%%: 3007-block 22
call    0 never executed
    #####: 3008:        zero_deadzone_halfsize = (style.LogSliderDeadzone * 0.5f) / ImMax(slider_usable_sz, 1.0f);
call    0 never executed
        -: 3009:    }
        -: 3010:
        -: 3011:    // Process interacting with the slider
    #####: 3012:    bool value_changed = false;
    #####: 3013:    if (g.ActiveId == id)
    %%%%%: 3013-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3014:    {
    #####: 3015:        bool set_new_value = false;
    #####: 3016:        float clicked_t = 0.0f;
    #####: 3017:        if (g.ActiveIdSource == ImGuiInputSource_Mouse)
    %%%%%: 3017-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3018:        {
    #####: 3019:            if (!g.IO.MouseDown[0])
    %%%%%: 3019-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3020:            {
    #####: 3021:                ClearActiveID();
    %%%%%: 3021-block 28
call    0 never executed
        -: 3022:            }
        -: 3023:            else
        -: 3024:            {
    #####: 3025:                const float mouse_abs_pos = g.IO.MousePos[axis];
    %%%%%: 3025-block 29
call    0 never executed
    #####: 3026:                if (g.ActiveIdIsJustActivated)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3027:                {
    #####: 3028:                    float grab_t = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, *v, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
    %%%%%: 3028-block 31
call    0 never executed
    #####: 3029:                    if (axis == ImGuiAxis_Y)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3030:                        grab_t = 1.0f - grab_t;
    %%%%%: 3030-block 33
    #####: 3031:                    const float grab_pos = ImLerp(slider_usable_pos_min, slider_usable_pos_max, grab_t);
    %%%%%: 3031-block 34
call    0 never executed
    #####: 3032:                    const bool clicked_around_grab = (mouse_abs_pos >= grab_pos - grab_sz * 0.5f - 1.0f) && (mouse_abs_pos <= grab_pos + grab_sz * 0.5f + 1.0f); // No harm being extra generous here.
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3032-block 36
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3032-block 37
    %%%%%: 3032-block 38
    #####: 3033:                    g.SliderGrabClickOffset = (clicked_around_grab && is_floating_point) ? mouse_abs_pos - grab_pos : 0.0f;
    %%%%%: 3033-block 39
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3033-block 40
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3033-block 41
    %%%%%: 3033-block 42
    %%%%%: 3033-block 43
        -: 3034:                }
    #####: 3035:                if (slider_usable_sz > 0.0f)
    %%%%%: 3035-block 44
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3036:                    clicked_t = ImSaturate((mouse_abs_pos - g.SliderGrabClickOffset - slider_usable_pos_min) / slider_usable_sz);
    %%%%%: 3036-block 45
call    0 never executed
    #####: 3037:                if (axis == ImGuiAxis_Y)
    %%%%%: 3037-block 46
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3038:                    clicked_t = 1.0f - clicked_t;
    %%%%%: 3038-block 47
    #####: 3039:                set_new_value = true;
    %%%%%: 3039-block 48
        -: 3040:            }
        -: 3041:        }
    #####: 3042:        else if (g.ActiveIdSource == ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource_Gamepad)
    %%%%%: 3042-block 49
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3042-block 50
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 3043:        {
    #####: 3044:            if (g.ActiveIdIsJustActivated)
    %%%%%: 3044-block 51
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3045:            {
    #####: 3046:                g.SliderCurrentAccum = 0.0f; // Reset any stored nav delta upon activation
    #####: 3047:                g.SliderCurrentAccumDirty = false;
    %%%%%: 3047-block 52
        -: 3048:            }
        -: 3049:
    #####: 3050:            float input_delta = (axis == ImGuiAxis_X) ? GetNavTweakPressedAmount(axis) : -GetNavTweakPressedAmount(axis);
    %%%%%: 3050-block 53
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3050-block 54
call    2 never executed
    %%%%%: 3050-block 56
call    3 never executed
    #####: 3051:            if (input_delta != 0.0f)
    %%%%%: 3051-block 58
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3052:            {
    #####: 3053:                const bool tweak_slow = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakSlow : ImGuiKey_NavKeyboardTweakSlow);
    %%%%%: 3053-block 59
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3053-block 60
    %%%%%: 3053-block 61
    %%%%%: 3053-block 62
call    2 never executed
    #####: 3054:                const bool tweak_fast = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakFast : ImGuiKey_NavKeyboardTweakFast);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3054-block 64
    %%%%%: 3054-block 65
    %%%%%: 3054-block 66
call    2 never executed
    #####: 3055:                const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 0;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3055-block 68
call    2 never executed
    %%%%%: 3055-block 70
    #####: 3056:                if (decimal_precision > 0)
    %%%%%: 3056-block 71
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3057:                {
    #####: 3058:                    input_delta /= 100.0f; // Keyboard/Gamepad tweak speeds in % of slider bounds
    #####: 3059:                    if (tweak_slow)
    %%%%%: 3059-block 72
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3060:                        input_delta /= 10.0f;
    %%%%%: 3060-block 73
        -: 3061:                }
        -: 3062:                else
        -: 3063:                {
    #####: 3064:                    if ((v_range_f >= -100.0f && v_range_f <= 100.0f && v_range_f != 0.0f) || tweak_slow)
    %%%%%: 3064-block 74
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3064-block 75
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3064-block 76
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 3064-block 77
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 3065:                        input_delta = ((input_delta < 0.0f) ? -1.0f : +1.0f) / v_range_f; // Keyboard/Gamepad tweak speeds in integer steps
    %%%%%: 3065-block 78
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3065-block 79
    %%%%%: 3065-block 80
    %%%%%: 3065-block 81
        -: 3066:                    else
    #####: 3067:                        input_delta /= 100.0f;
    %%%%%: 3067-block 82
        -: 3068:                }
    #####: 3069:                if (tweak_fast)
    %%%%%: 3069-block 83
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3070:                    input_delta *= 10.0f;
    %%%%%: 3070-block 84
        -: 3071:
    #####: 3072:                g.SliderCurrentAccum += input_delta;
    #####: 3073:                g.SliderCurrentAccumDirty = true;
    %%%%%: 3073-block 85
        -: 3074:            }
        -: 3075:
    #####: 3076:            float delta = g.SliderCurrentAccum;
    #####: 3077:            if (g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated)
    %%%%%: 3077-block 86
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3077-block 87
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 3078:            {
    #####: 3079:                ClearActiveID();
    %%%%%: 3079-block 88
call    0 never executed
        -: 3080:            }
    #####: 3081:            else if (g.SliderCurrentAccumDirty)
    %%%%%: 3081-block 89
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3082:            {
    #####: 3083:                clicked_t = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, *v, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
    %%%%%: 3083-block 90
call    0 never executed
        -: 3084:
    #####: 3085:                if ((clicked_t >= 1.0f && delta > 0.0f) || (clicked_t <= 0.0f && delta < 0.0f)) // This is to avoid applying the saturation when already past the limits
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3085-block 92
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3085-block 93
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 3085-block 94
branch  6 never executed (fallthrough)
branch  7 never executed
        -: 3086:                {
    #####: 3087:                    set_new_value = false;
    #####: 3088:                    g.SliderCurrentAccum = 0.0f; // If pushing up against the limits, don't continue to accumulate
    %%%%%: 3088-block 95
        -: 3089:                }
        -: 3090:                else
        -: 3091:                {
    #####: 3092:                    set_new_value = true;
    #####: 3093:                    float old_clicked_t = clicked_t;
    #####: 3094:                    clicked_t = ImSaturate(clicked_t + delta);
    %%%%%: 3094-block 96
call    0 never executed
        -: 3095:
        -: 3096:                    // Calculate what our "new" clicked_t will be, and thus how far we actually moved the slider, and subtract this from the accumulator
    #####: 3097:                    TYPE v_new = ScaleValueFromRatioT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, clicked_t, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
call    0 never executed
    #####: 3098:                    if (is_floating_point && !(flags & ImGuiSliderFlags_NoRoundToFormat))
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3098-block 99
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3099:                        v_new = RoundScalarWithFormatT<TYPE>(format, data_type, v_new);
    %%%%%: 3099-block 100
call    0 never executed
    #####: 3100:                    float new_clicked_t = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_new, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
    %%%%%: 3100-block 102
call    0 never executed
        -: 3101:
    #####: 3102:                    if (delta > 0)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3103:                        g.SliderCurrentAccum -= ImMin(new_clicked_t - old_clicked_t, delta);
    %%%%%: 3103-block 104
call    0 never executed
        -: 3104:                    else
    #####: 3105:                        g.SliderCurrentAccum -= ImMax(new_clicked_t - old_clicked_t, delta);
    %%%%%: 3105-block 106
call    0 never executed
        -: 3106:                }
        -: 3107:
    #####: 3108:                g.SliderCurrentAccumDirty = false;
    %%%%%: 3108-block 108
        -: 3109:            }
        -: 3110:        }
        -: 3111:
    #####: 3112:        if (set_new_value)
    %%%%%: 3112-block 109
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3113:            if ((g.LastItemData.ItemFlags & ImGuiItemFlags_ReadOnly) || (flags & ImGuiSliderFlags_ReadOnly))
    %%%%%: 3113-block 110
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3113-block 111
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3114:                set_new_value = false;
    %%%%%: 3114-block 112
        -: 3115:
    #####: 3116:        if (set_new_value)
    %%%%%: 3116-block 113
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3117:        {
    #####: 3118:            TYPE v_new = ScaleValueFromRatioT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, clicked_t, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
    %%%%%: 3118-block 114
call    0 never executed
        -: 3119:
        -: 3120:            // Round to user desired precision based on format string
    #####: 3121:            if (is_floating_point && !(flags & ImGuiSliderFlags_NoRoundToFormat))
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3121-block 116
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3122:                v_new = RoundScalarWithFormatT<TYPE>(format, data_type, v_new);
    %%%%%: 3122-block 117
call    0 never executed
        -: 3123:
        -: 3124:            // Apply result
    #####: 3125:            if (*v != v_new)
    %%%%%: 3125-block 119
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3126:            {
    #####: 3127:                *v = v_new;
    #####: 3128:                value_changed = true;
    %%%%%: 3128-block 120
        -: 3129:            }
        -: 3130:        }
        -: 3131:    }
        -: 3132:
    #####: 3133:    if (slider_sz < 1.0f)
    %%%%%: 3133-block 121
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3134:    {
    #####: 3135:        *out_grab_bb = ImRect(bb.Min, bb.Min);
    %%%%%: 3135-block 122
call    0 never executed
        -: 3136:    }
        -: 3137:    else
        -: 3138:    {
        -: 3139:        // Output grab position so it can be displayed by the caller
    #####: 3140:        float grab_t = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, *v, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
    %%%%%: 3140-block 124
call    0 never executed
    #####: 3141:        if (axis == ImGuiAxis_Y)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3142:            grab_t = 1.0f - grab_t;
    %%%%%: 3142-block 126
    #####: 3143:        const float grab_pos = ImLerp(slider_usable_pos_min, slider_usable_pos_max, grab_t);
    %%%%%: 3143-block 127
call    0 never executed
    #####: 3144:        if (axis == ImGuiAxis_X)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3145:            *out_grab_bb = ImRect(grab_pos - grab_sz * 0.5f, bb.Min.y + grab_padding, grab_pos + grab_sz * 0.5f, bb.Max.y - grab_padding);
    %%%%%: 3145-block 129
call    0 never executed
        -: 3146:        else
    #####: 3147:            *out_grab_bb = ImRect(bb.Min.x + grab_padding, grab_pos - grab_sz * 0.5f, bb.Max.x - grab_padding, grab_pos + grab_sz * 0.5f);
    %%%%%: 3147-block 131
call    0 never executed
        -: 3148:    }
        -: 3149:
    #####: 3150:    return value_changed;
    %%%%%: 3150-block 133
        -: 3151:}
------------------
_ZN5ImGui15SliderBehaviorTIiifEEbRK6ImRectjiPT_S4_S4_PKciPS1_:
function _ZN5ImGui15SliderBehaviorTIiifEEbRK6ImRectjiPT_S4_S4_PKciPS1_ called 0 returned 0% blocks executed 0%
    #####: 2980:bool ImGui::SliderBehaviorT(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, TYPE* v, const TYPE v_min, const TYPE v_max, const char* format, ImGuiSliderFlags flags, ImRect* out_grab_bb)
        -: 2981:{
    #####: 2982:    ImGuiContext& g = *GImGui;
    #####: 2983:    const ImGuiStyle& style = g.Style;
        -: 2984:
    #####: 2985:    const ImGuiAxis axis = (flags & ImGuiSliderFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;
    #####: 2986:    const bool is_logarithmic = (flags & ImGuiSliderFlags_Logarithmic) != 0;
    #####: 2987:    const bool is_floating_point = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);
    %%%%%: 2987-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2987-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2987-block 4
    %%%%%: 2987-block 5
    #####: 2988:    const float v_range_f = (float)(v_min < v_max ? v_max - v_min : v_min - v_max); // We don't need high precision for what we do with it.
    %%%%%: 2988-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2988-block 7
    %%%%%: 2988-block 8
        -: 2989:
        -: 2990:    // Calculate bounds
    #####: 2991:    const float grab_padding = 2.0f; // FIXME: Should be part of style.
    #####: 2992:    const float slider_sz = (bb.Max[axis] - bb.Min[axis]) - grab_padding * 2.0f;
    %%%%%: 2992-block 9
call    0 never executed
call    1 never executed
    #####: 2993:    float grab_sz = style.GrabMinSize;
    #####: 2994:    if (!is_floating_point && v_range_f >= 0.0f)                         // v_range_f < 0 may happen on integer overflows
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2994-block 12
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2995:        grab_sz = ImMax(slider_sz / (v_range_f + 1), style.GrabMinSize); // For integer sliders: if possible have the grab size represent 1 unit
    %%%%%: 2995-block 13
call    0 never executed
    #####: 2996:    grab_sz = ImMin(grab_sz, slider_sz);
    %%%%%: 2996-block 14
call    0 never executed
    #####: 2997:    const float slider_usable_sz = slider_sz - grab_sz;
    #####: 2998:    const float slider_usable_pos_min = bb.Min[axis] + grab_padding + grab_sz * 0.5f;
call    0 never executed
    #####: 2999:    const float slider_usable_pos_max = bb.Max[axis] - grab_padding - grab_sz * 0.5f;
call    0 never executed
        -: 3000:
    #####: 3001:    float logarithmic_zero_epsilon = 0.0f; // Only valid when is_logarithmic is true
    #####: 3002:    float zero_deadzone_halfsize = 0.0f; // Only valid when is_logarithmic is true
    #####: 3003:    if (is_logarithmic)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3004:    {
        -: 3005:        // When using logarithmic sliders, we need to clamp to avoid hitting zero, but our choice of clamp value greatly affects slider precision. We attempt to use the specified precision to estimate a good lower bound.
    #####: 3006:        const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 1;
    %%%%%: 3006-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3006-block 19
call    2 never executed
    %%%%%: 3006-block 21
    #####: 3007:        logarithmic_zero_epsilon = ImPow(0.1f, (float)decimal_precision);
    %%%%%: 3007-block 22
call    0 never executed
    #####: 3008:        zero_deadzone_halfsize = (style.LogSliderDeadzone * 0.5f) / ImMax(slider_usable_sz, 1.0f);
call    0 never executed
        -: 3009:    }
        -: 3010:
        -: 3011:    // Process interacting with the slider
    #####: 3012:    bool value_changed = false;
    #####: 3013:    if (g.ActiveId == id)
    %%%%%: 3013-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3014:    {
    #####: 3015:        bool set_new_value = false;
    #####: 3016:        float clicked_t = 0.0f;
    #####: 3017:        if (g.ActiveIdSource == ImGuiInputSource_Mouse)
    %%%%%: 3017-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3018:        {
    #####: 3019:            if (!g.IO.MouseDown[0])
    %%%%%: 3019-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3020:            {
    #####: 3021:                ClearActiveID();
    %%%%%: 3021-block 28
call    0 never executed
        -: 3022:            }
        -: 3023:            else
        -: 3024:            {
    #####: 3025:                const float mouse_abs_pos = g.IO.MousePos[axis];
    %%%%%: 3025-block 29
call    0 never executed
    #####: 3026:                if (g.ActiveIdIsJustActivated)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3027:                {
    #####: 3028:                    float grab_t = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, *v, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
    %%%%%: 3028-block 31
call    0 never executed
    #####: 3029:                    if (axis == ImGuiAxis_Y)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3030:                        grab_t = 1.0f - grab_t;
    %%%%%: 3030-block 33
    #####: 3031:                    const float grab_pos = ImLerp(slider_usable_pos_min, slider_usable_pos_max, grab_t);
    %%%%%: 3031-block 34
call    0 never executed
    #####: 3032:                    const bool clicked_around_grab = (mouse_abs_pos >= grab_pos - grab_sz * 0.5f - 1.0f) && (mouse_abs_pos <= grab_pos + grab_sz * 0.5f + 1.0f); // No harm being extra generous here.
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3032-block 36
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3032-block 37
    %%%%%: 3032-block 38
    #####: 3033:                    g.SliderGrabClickOffset = (clicked_around_grab && is_floating_point) ? mouse_abs_pos - grab_pos : 0.0f;
    %%%%%: 3033-block 39
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3033-block 40
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3033-block 41
    %%%%%: 3033-block 42
    %%%%%: 3033-block 43
        -: 3034:                }
    #####: 3035:                if (slider_usable_sz > 0.0f)
    %%%%%: 3035-block 44
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3036:                    clicked_t = ImSaturate((mouse_abs_pos - g.SliderGrabClickOffset - slider_usable_pos_min) / slider_usable_sz);
    %%%%%: 3036-block 45
call    0 never executed
    #####: 3037:                if (axis == ImGuiAxis_Y)
    %%%%%: 3037-block 46
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3038:                    clicked_t = 1.0f - clicked_t;
    %%%%%: 3038-block 47
    #####: 3039:                set_new_value = true;
    %%%%%: 3039-block 48
        -: 3040:            }
        -: 3041:        }
    #####: 3042:        else if (g.ActiveIdSource == ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource_Gamepad)
    %%%%%: 3042-block 49
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3042-block 50
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 3043:        {
    #####: 3044:            if (g.ActiveIdIsJustActivated)
    %%%%%: 3044-block 51
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3045:            {
    #####: 3046:                g.SliderCurrentAccum = 0.0f; // Reset any stored nav delta upon activation
    #####: 3047:                g.SliderCurrentAccumDirty = false;
    %%%%%: 3047-block 52
        -: 3048:            }
        -: 3049:
    #####: 3050:            float input_delta = (axis == ImGuiAxis_X) ? GetNavTweakPressedAmount(axis) : -GetNavTweakPressedAmount(axis);
    %%%%%: 3050-block 53
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3050-block 54
call    2 never executed
    %%%%%: 3050-block 56
call    3 never executed
    #####: 3051:            if (input_delta != 0.0f)
    %%%%%: 3051-block 58
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3052:            {
    #####: 3053:                const bool tweak_slow = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakSlow : ImGuiKey_NavKeyboardTweakSlow);
    %%%%%: 3053-block 59
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3053-block 60
    %%%%%: 3053-block 61
    %%%%%: 3053-block 62
call    2 never executed
    #####: 3054:                const bool tweak_fast = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakFast : ImGuiKey_NavKeyboardTweakFast);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3054-block 64
    %%%%%: 3054-block 65
    %%%%%: 3054-block 66
call    2 never executed
    #####: 3055:                const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 0;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3055-block 68
call    2 never executed
    %%%%%: 3055-block 70
    #####: 3056:                if (decimal_precision > 0)
    %%%%%: 3056-block 71
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3057:                {
    #####: 3058:                    input_delta /= 100.0f; // Keyboard/Gamepad tweak speeds in % of slider bounds
    #####: 3059:                    if (tweak_slow)
    %%%%%: 3059-block 72
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3060:                        input_delta /= 10.0f;
    %%%%%: 3060-block 73
        -: 3061:                }
        -: 3062:                else
        -: 3063:                {
    #####: 3064:                    if ((v_range_f >= -100.0f && v_range_f <= 100.0f && v_range_f != 0.0f) || tweak_slow)
    %%%%%: 3064-block 74
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3064-block 75
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3064-block 76
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 3064-block 77
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 3065:                        input_delta = ((input_delta < 0.0f) ? -1.0f : +1.0f) / v_range_f; // Keyboard/Gamepad tweak speeds in integer steps
    %%%%%: 3065-block 78
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3065-block 79
    %%%%%: 3065-block 80
    %%%%%: 3065-block 81
        -: 3066:                    else
    #####: 3067:                        input_delta /= 100.0f;
    %%%%%: 3067-block 82
        -: 3068:                }
    #####: 3069:                if (tweak_fast)
    %%%%%: 3069-block 83
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3070:                    input_delta *= 10.0f;
    %%%%%: 3070-block 84
        -: 3071:
    #####: 3072:                g.SliderCurrentAccum += input_delta;
    #####: 3073:                g.SliderCurrentAccumDirty = true;
    %%%%%: 3073-block 85
        -: 3074:            }
        -: 3075:
    #####: 3076:            float delta = g.SliderCurrentAccum;
    #####: 3077:            if (g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated)
    %%%%%: 3077-block 86
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3077-block 87
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 3078:            {
    #####: 3079:                ClearActiveID();
    %%%%%: 3079-block 88
call    0 never executed
        -: 3080:            }
    #####: 3081:            else if (g.SliderCurrentAccumDirty)
    %%%%%: 3081-block 89
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3082:            {
    #####: 3083:                clicked_t = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, *v, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
    %%%%%: 3083-block 90
call    0 never executed
        -: 3084:
    #####: 3085:                if ((clicked_t >= 1.0f && delta > 0.0f) || (clicked_t <= 0.0f && delta < 0.0f)) // This is to avoid applying the saturation when already past the limits
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3085-block 92
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3085-block 93
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 3085-block 94
branch  6 never executed (fallthrough)
branch  7 never executed
        -: 3086:                {
    #####: 3087:                    set_new_value = false;
    #####: 3088:                    g.SliderCurrentAccum = 0.0f; // If pushing up against the limits, don't continue to accumulate
    %%%%%: 3088-block 95
        -: 3089:                }
        -: 3090:                else
        -: 3091:                {
    #####: 3092:                    set_new_value = true;
    #####: 3093:                    float old_clicked_t = clicked_t;
    #####: 3094:                    clicked_t = ImSaturate(clicked_t + delta);
    %%%%%: 3094-block 96
call    0 never executed
        -: 3095:
        -: 3096:                    // Calculate what our "new" clicked_t will be, and thus how far we actually moved the slider, and subtract this from the accumulator
    #####: 3097:                    TYPE v_new = ScaleValueFromRatioT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, clicked_t, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
call    0 never executed
    #####: 3098:                    if (is_floating_point && !(flags & ImGuiSliderFlags_NoRoundToFormat))
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3098-block 99
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3099:                        v_new = RoundScalarWithFormatT<TYPE>(format, data_type, v_new);
    %%%%%: 3099-block 100
call    0 never executed
    #####: 3100:                    float new_clicked_t = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_new, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
    %%%%%: 3100-block 102
call    0 never executed
        -: 3101:
    #####: 3102:                    if (delta > 0)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3103:                        g.SliderCurrentAccum -= ImMin(new_clicked_t - old_clicked_t, delta);
    %%%%%: 3103-block 104
call    0 never executed
        -: 3104:                    else
    #####: 3105:                        g.SliderCurrentAccum -= ImMax(new_clicked_t - old_clicked_t, delta);
    %%%%%: 3105-block 106
call    0 never executed
        -: 3106:                }
        -: 3107:
    #####: 3108:                g.SliderCurrentAccumDirty = false;
    %%%%%: 3108-block 108
        -: 3109:            }
        -: 3110:        }
        -: 3111:
    #####: 3112:        if (set_new_value)
    %%%%%: 3112-block 109
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3113:            if ((g.LastItemData.ItemFlags & ImGuiItemFlags_ReadOnly) || (flags & ImGuiSliderFlags_ReadOnly))
    %%%%%: 3113-block 110
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3113-block 111
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3114:                set_new_value = false;
    %%%%%: 3114-block 112
        -: 3115:
    #####: 3116:        if (set_new_value)
    %%%%%: 3116-block 113
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3117:        {
    #####: 3118:            TYPE v_new = ScaleValueFromRatioT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, clicked_t, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
    %%%%%: 3118-block 114
call    0 never executed
        -: 3119:
        -: 3120:            // Round to user desired precision based on format string
    #####: 3121:            if (is_floating_point && !(flags & ImGuiSliderFlags_NoRoundToFormat))
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3121-block 116
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3122:                v_new = RoundScalarWithFormatT<TYPE>(format, data_type, v_new);
    %%%%%: 3122-block 117
call    0 never executed
        -: 3123:
        -: 3124:            // Apply result
    #####: 3125:            if (*v != v_new)
    %%%%%: 3125-block 119
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3126:            {
    #####: 3127:                *v = v_new;
    #####: 3128:                value_changed = true;
    %%%%%: 3128-block 120
        -: 3129:            }
        -: 3130:        }
        -: 3131:    }
        -: 3132:
    #####: 3133:    if (slider_sz < 1.0f)
    %%%%%: 3133-block 121
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3134:    {
    #####: 3135:        *out_grab_bb = ImRect(bb.Min, bb.Min);
    %%%%%: 3135-block 122
call    0 never executed
        -: 3136:    }
        -: 3137:    else
        -: 3138:    {
        -: 3139:        // Output grab position so it can be displayed by the caller
    #####: 3140:        float grab_t = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, *v, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
    %%%%%: 3140-block 124
call    0 never executed
    #####: 3141:        if (axis == ImGuiAxis_Y)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3142:            grab_t = 1.0f - grab_t;
    %%%%%: 3142-block 126
    #####: 3143:        const float grab_pos = ImLerp(slider_usable_pos_min, slider_usable_pos_max, grab_t);
    %%%%%: 3143-block 127
call    0 never executed
    #####: 3144:        if (axis == ImGuiAxis_X)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3145:            *out_grab_bb = ImRect(grab_pos - grab_sz * 0.5f, bb.Min.y + grab_padding, grab_pos + grab_sz * 0.5f, bb.Max.y - grab_padding);
    %%%%%: 3145-block 129
call    0 never executed
        -: 3146:        else
    #####: 3147:            *out_grab_bb = ImRect(bb.Min.x + grab_padding, grab_pos - grab_sz * 0.5f, bb.Max.x - grab_padding, grab_pos + grab_sz * 0.5f);
    %%%%%: 3147-block 131
call    0 never executed
        -: 3148:    }
        -: 3149:
    #####: 3150:    return value_changed;
    %%%%%: 3150-block 133
        -: 3151:}
------------------
        -: 3152:
        -: 3153:// For 32-bit and larger types, slider bounds are limited to half the natural type range.
        -: 3154:// So e.g. an integer Slider between INT_MAX-10 and INT_MAX will fail, but an integer Slider between INT_MAX/2-10 and INT_MAX/2 will be ok.
        -: 3155:// It would be possible to lift that limitation with some work but it doesn't seem to be worth it for sliders.
function _ZN5ImGui14SliderBehaviorERK6ImRectjiPvPKvS5_PKciPS0_ called 0 returned 0% blocks executed 0%
    #####: 3156:bool ImGui::SliderBehavior(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, void* p_v, const void* p_min, const void* p_max, const char* format, ImGuiSliderFlags flags, ImRect* out_grab_bb)
        -: 3157:{
        -: 3158:    // Read imgui.cpp "API BREAKING CHANGES" section for 1.78 if you hit this assert.
    #####: 3159:    IM_ASSERT((flags == 1 || (flags & ImGuiSliderFlags_InvalidMask_) == 0) && "Invalid ImGuiSliderFlags flags! Has the legacy 'float power' argument been mistakenly cast to flags? Call function with ImGuiSliderFlags_Logarithmic flags instead.");
    %%%%%: 3159-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3159-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3159-block 4
call    4 never executed
    #####: 3160:    IM_ASSERT((flags & ImGuiSliderFlags_WrapAround) == 0); // Not supported by SliderXXX(), only by DragXXX()
    %%%%%: 3160-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3160-block 6
call    2 never executed
        -: 3161:
    #####: 3162:    switch (data_type)
    %%%%%: 3162-block 7
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
        -: 3163:    {
    #####: 3164:    case ImGuiDataType_S8:  { ImS32 v32 = (ImS32)*(ImS8*)p_v;  bool r = SliderBehaviorT<ImS32, ImS32, float>(bb, id, ImGuiDataType_S32, &v32, *(const ImS8*)p_min,  *(const ImS8*)p_max,  format, flags, out_grab_bb); if (r) *(ImS8*)p_v  = (ImS8)v32;  return r; }
    %%%%%: 3164-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 3164-block 9
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 3164-block 10
    %%%%%: 3164-block 11
    #####: 3165:    case ImGuiDataType_U8:  { ImU32 v32 = (ImU32)*(ImU8*)p_v;  bool r = SliderBehaviorT<ImU32, ImS32, float>(bb, id, ImGuiDataType_U32, &v32, *(const ImU8*)p_min,  *(const ImU8*)p_max,  format, flags, out_grab_bb); if (r) *(ImU8*)p_v  = (ImU8)v32;  return r; }
    %%%%%: 3165-block 13
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 3165-block 14
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 3165-block 15
    %%%%%: 3165-block 16
    #####: 3166:    case ImGuiDataType_S16: { ImS32 v32 = (ImS32)*(ImS16*)p_v; bool r = SliderBehaviorT<ImS32, ImS32, float>(bb, id, ImGuiDataType_S32, &v32, *(const ImS16*)p_min, *(const ImS16*)p_max, format, flags, out_grab_bb); if (r) *(ImS16*)p_v = (ImS16)v32; return r; }
    %%%%%: 3166-block 18
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 3166-block 19
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 3166-block 20
    %%%%%: 3166-block 21
    #####: 3167:    case ImGuiDataType_U16: { ImU32 v32 = (ImU32)*(ImU16*)p_v; bool r = SliderBehaviorT<ImU32, ImS32, float>(bb, id, ImGuiDataType_U32, &v32, *(const ImU16*)p_min, *(const ImU16*)p_max, format, flags, out_grab_bb); if (r) *(ImU16*)p_v = (ImU16)v32; return r; }
    %%%%%: 3167-block 23
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 3167-block 24
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 3167-block 25
    %%%%%: 3167-block 26
    #####: 3168:    case ImGuiDataType_S32:
    #####: 3169:        IM_ASSERT(*(const ImS32*)p_min >= IM_S32_MIN / 2 && *(const ImS32*)p_max <= IM_S32_MAX / 2);
    %%%%%: 3169-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3169-block 29
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3169-block 30
    %%%%%: 3169-block 31
call    4 never executed
    #####: 3170:        return SliderBehaviorT<ImS32, ImS32, float >(bb, id, data_type, (ImS32*)p_v,  *(const ImS32*)p_min,  *(const ImS32*)p_max,  format, flags, out_grab_bb);
    %%%%%: 3170-block 32
call    0 never executed
    #####: 3171:    case ImGuiDataType_U32:
    #####: 3172:        IM_ASSERT(*(const ImU32*)p_max <= IM_U32_MAX / 2);
    %%%%%: 3172-block 34
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3172-block 35
call    2 never executed
    #####: 3173:        return SliderBehaviorT<ImU32, ImS32, float >(bb, id, data_type, (ImU32*)p_v,  *(const ImU32*)p_min,  *(const ImU32*)p_max,  format, flags, out_grab_bb);
    %%%%%: 3173-block 36
call    0 never executed
    #####: 3174:    case ImGuiDataType_S64:
    #####: 3175:        IM_ASSERT(*(const ImS64*)p_min >= IM_S64_MIN / 2 && *(const ImS64*)p_max <= IM_S64_MAX / 2);
    %%%%%: 3175-block 38
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3175-block 39
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3175-block 40
    %%%%%: 3175-block 41
call    4 never executed
    #####: 3176:        return SliderBehaviorT<ImS64, ImS64, double>(bb, id, data_type, (ImS64*)p_v,  *(const ImS64*)p_min,  *(const ImS64*)p_max,  format, flags, out_grab_bb);
    %%%%%: 3176-block 42
call    0 never executed
    #####: 3177:    case ImGuiDataType_U64:
    #####: 3178:        IM_ASSERT(*(const ImU64*)p_max <= IM_U64_MAX / 2);
    %%%%%: 3178-block 44
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3178-block 45
call    2 never executed
    #####: 3179:        return SliderBehaviorT<ImU64, ImS64, double>(bb, id, data_type, (ImU64*)p_v,  *(const ImU64*)p_min,  *(const ImU64*)p_max,  format, flags, out_grab_bb);
    %%%%%: 3179-block 46
call    0 never executed
    #####: 3180:    case ImGuiDataType_Float:
    #####: 3181:        IM_ASSERT(*(const float*)p_min >= -FLT_MAX / 2.0f && *(const float*)p_max <= FLT_MAX / 2.0f);
    %%%%%: 3181-block 48
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3181-block 49
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3181-block 50
    %%%%%: 3181-block 51
call    4 never executed
    #####: 3182:        return SliderBehaviorT<float, float, float >(bb, id, data_type, (float*)p_v,  *(const float*)p_min,  *(const float*)p_max,  format, flags, out_grab_bb);
    %%%%%: 3182-block 52
call    0 never executed
    #####: 3183:    case ImGuiDataType_Double:
    #####: 3184:        IM_ASSERT(*(const double*)p_min >= -DBL_MAX / 2.0f && *(const double*)p_max <= DBL_MAX / 2.0f);
    %%%%%: 3184-block 54
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3184-block 55
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3184-block 56
    %%%%%: 3184-block 57
call    4 never executed
    #####: 3185:        return SliderBehaviorT<double, double, double>(bb, id, data_type, (double*)p_v, *(const double*)p_min, *(const double*)p_max, format, flags, out_grab_bb);
    %%%%%: 3185-block 58
call    0 never executed
    #####: 3186:    case ImGuiDataType_COUNT: break;
    %%%%%: 3186-block 60
        -: 3187:    }
    #####: 3188:    IM_ASSERT(0);
    %%%%%: 3188-block 61
call    0 never executed
        -: 3189:    return false;
        -: 3190:}
        -: 3191:
        -: 3192:// Note: p_data, p_min and p_max are _pointers_ to a memory address holding the data. For a slider, they are all required.
        -: 3193:// Read code of e.g. SliderFloat(), SliderInt() etc. or examples in 'Demo->Widgets->Data Types' to understand how to use this function directly.
function _ZN5ImGui12SliderScalarEPKciPvPKvS4_S1_i called 0 returned 0% blocks executed 0%
    #####: 3194:bool ImGui::SliderScalar(const char* label, ImGuiDataType data_type, void* p_data, const void* p_min, const void* p_max, const char* format, ImGuiSliderFlags flags)
        -: 3195:{
    #####: 3196:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%: 3196-block 2
call    0 never executed
    #####: 3197:    if (window->SkipItems)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3198:        return false;
    %%%%%: 3198-block 4
        -: 3199:
    #####: 3200:    ImGuiContext& g = *GImGui;
    #####: 3201:    const ImGuiStyle& style = g.Style;
    #####: 3202:    const ImGuiID id = window->GetID(label);
    %%%%%: 3202-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3203:    const float w = CalcItemWidth();
    %%%%%: 3203-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 3204:
    #####: 3205:    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    %%%%%: 3205-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3206:    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y * 2.0f));
    %%%%%: 3206-block 8
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3207:    const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3207-block 12
    %%%%%: 3207-block 13
    %%%%%: 3207-block 14
call    2 never executed
call    3 never executed
call    4 never executed
        -: 3208:
    #####: 3209:    const bool temp_input_allowed = (flags & ImGuiSliderFlags_NoInput) == 0;
    #####: 3210:    ItemSize(total_bb, style.FramePadding.y);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3211:    if (!ItemAdd(total_bb, id, &frame_bb, temp_input_allowed ? ImGuiItemFlags_Inputable : 0))
    %%%%%: 3211-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3211-block 19
    %%%%%: 3211-block 20
    %%%%%: 3211-block 21
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 3211-block 22
branch  5 never executed (fallthrough)
branch  6 never executed
    #####: 3212:        return false;
    %%%%%: 3212-block 23
        -: 3213:
        -: 3214:    // Default format string when passing NULL
    #####: 3215:    if (format == NULL)
    %%%%%: 3215-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3216:        format = DataTypeGetInfo(data_type)->PrintFmt;
    %%%%%: 3216-block 25
call    0 never executed
        -: 3217:
    #####: 3218:    const bool hovered = ItemHoverable(frame_bb, id, g.LastItemData.ItemFlags);
    %%%%%: 3218-block 27
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3219:    bool temp_input_is_active = temp_input_allowed && TempInputIsActive(id);
    %%%%%: 3219-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3219-block 29
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 3219-block 31
    %%%%%: 3219-block 32
    #####: 3220:    if (!temp_input_is_active)
    %%%%%: 3220-block 33
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3221:    {
        -: 3222:        // Tabbing or CTRL-clicking on Slider turns it into an input box
    #####: 3223:        const bool clicked = hovered && IsMouseClicked(0, ImGuiInputFlags_None, id);
    %%%%%: 3223-block 34
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3223-block 35
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 3223-block 36
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 3223-block 37
    %%%%%: 3223-block 38
    #####: 3224:        const bool make_active = (clicked || g.NavActivateId == id);
    %%%%%: 3224-block 39
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3224-block 40
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3224-block 41
    %%%%%: 3224-block 42
    #####: 3225:        if (make_active && clicked)
    %%%%%: 3225-block 43
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3225-block 44
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3226:            SetKeyOwner(ImGuiKey_MouseLeft, id);
    %%%%%: 3226-block 45
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3227:        if (make_active && temp_input_allowed)
    %%%%%: 3227-block 46
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3227-block 47
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3228:            if ((clicked && g.IO.KeyCtrl) || (g.NavActivateId == id && (g.NavActivateFlags & ImGuiActivateFlags_PreferInput)))
    %%%%%: 3228-block 48
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3228-block 49
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3228-block 50
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 3228-block 51
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 3229:                temp_input_is_active = true;
    %%%%%: 3229-block 52
        -: 3230:
    #####: 3231:        if (make_active && !temp_input_is_active)
    %%%%%: 3231-block 53
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3231-block 54
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 3232:        {
    #####: 3233:            SetActiveID(id, window);
    %%%%%: 3233-block 55
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3234:            SetFocusID(id, window);
    %%%%%: 3234-block 56
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3235:            FocusWindow(window);
    %%%%%: 3235-block 57
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3236:            g.ActiveIdUsingNavDirMask |= (1 << ImGuiDir_Left) | (1 << ImGuiDir_Right);
    %%%%%: 3236-block 58
        -: 3237:        }
        -: 3238:    }
        -: 3239:
    #####: 3240:    if (temp_input_is_active)
    %%%%%: 3240-block 59
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3241:    {
        -: 3242:        // Only clamp CTRL+Click input when ImGuiSliderFlags_ClampOnInput is set (generally via ImGuiSliderFlags_AlwaysClamp)
    #####: 3243:        const bool clamp_enabled = (flags & ImGuiSliderFlags_ClampOnInput) != 0;
    #####: 3244:        return TempInputScalar(frame_bb, id, label, data_type, p_data, format, clamp_enabled ? p_min : NULL, clamp_enabled ? p_max : NULL);
    %%%%%: 3244-block 60
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3244-block 61
    %%%%%: 3244-block 62
    %%%%%: 3244-block 63
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3244-block 64
    %%%%%: 3244-block 65
    %%%%%: 3244-block 66
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    %%%%%: 3244-block 67
        -: 3245:    }
        -: 3246:
        -: 3247:    // Draw frame
    #####: 3248:    const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);
    %%%%%: 3248-block 68
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3248-block 69
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3248-block 70
    %%%%%: 3248-block 71
    %%%%%: 3248-block 72
    %%%%%: 3248-block 73
    %%%%%: 3248-block 74
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    #####: 3249:    RenderNavCursor(frame_bb, id);
    %%%%%: 3249-block 75
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3250:    RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, g.Style.FrameRounding);
    %%%%%: 3250-block 76
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 3251:
        -: 3252:    // Slider behavior
    #####: 3253:    ImRect grab_bb;
    #####: 3254:    const bool value_changed = SliderBehavior(frame_bb, id, data_type, p_data, p_min, p_max, format, flags, &grab_bb);
    %%%%%: 3254-block 77
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3255:    if (value_changed)
    %%%%%: 3255-block 78
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3256:        MarkItemEdited(id);
    %%%%%: 3256-block 79
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 3257:
        -: 3258:    // Render grab
    #####: 3259:    if (grab_bb.Max.x > grab_bb.Min.x)
    %%%%%: 3259-block 80
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3260:        window->DrawList->AddRectFilled(grab_bb.Min, grab_bb.Max, GetColorU32(g.ActiveId == id ? ImGuiCol_SliderGrabActive : ImGuiCol_SliderGrab), style.GrabRounding);
    %%%%%: 3260-block 81
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3260-block 82
    %%%%%: 3260-block 83
    %%%%%: 3260-block 84
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 3260-block 85
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
        -: 3261:
        -: 3262:    // Display value using user-provided display format so user can add prefix/suffix/decorations to the value.
        -: 3263:    char value_buf[64];
    #####: 3264:    const char* value_buf_end = value_buf + DataTypeFormatString(value_buf, IM_ARRAYSIZE(value_buf), data_type, p_data, format);
    %%%%%: 3264-block 86
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3265:    if (g.LogEnabled)
    %%%%%: 3265-block 87
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3266:        LogSetNextTextDecoration("{", "}");
    %%%%%: 3266-block 88
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3267:    RenderTextClipped(frame_bb.Min, frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f, 0.5f));
    %%%%%: 3267-block 89
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$: 3267-block 98
        -: 3268:
    #####: 3269:    if (label_size.x > 0.0f)
    %%%%%: 3269-block 91
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3270:        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);
    %%%%%: 3270-block 92
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 3270-block 94
    $$$$$: 3270-block 99
        -: 3271:
        -: 3272:    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags | (temp_input_allowed ? ImGuiItemStatusFlags_Inputable : 0));
    #####: 3273:    return value_changed;
    %%%%%: 3273-block 95
        -: 3274:}
        -: 3275:
        -: 3276:// Add multiple sliders on 1 line for compact edition of multiple components
function _ZN5ImGui13SliderScalarNEPKciPviPKvS4_S1_i called 0 returned 0% blocks executed 0%
    #####: 3277:bool ImGui::SliderScalarN(const char* label, ImGuiDataType data_type, void* v, int components, const void* v_min, const void* v_max, const char* format, ImGuiSliderFlags flags)
        -: 3278:{
    #####: 3279:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%: 3279-block 2
call    0 never executed
    #####: 3280:    if (window->SkipItems)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3281:        return false;
    %%%%%: 3281-block 4
        -: 3282:
    #####: 3283:    ImGuiContext& g = *GImGui;
    #####: 3284:    bool value_changed = false;
    #####: 3285:    BeginGroup();
    %%%%%: 3285-block 5
call    0 never executed
    #####: 3286:    PushID(label);
call    0 never executed
    #####: 3287:    PushMultiItemsWidths(components, CalcItemWidth());
call    0 never executed
call    1 never executed
    #####: 3288:    size_t type_size = GDataTypeInfo[data_type].Size;
    #####: 3289:    for (int i = 0; i < components; i++)
    %%%%%: 3289-block 17
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 3290:    {
    #####: 3291:        PushID(i);
    %%%%%: 3291-block 10
call    0 never executed
    #####: 3292:        if (i > 0)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3293:            SameLine(0, g.Style.ItemInnerSpacing.x);
    %%%%%: 3293-block 12
call    0 never executed
    #####: 3294:        value_changed |= SliderScalar("", data_type, v, v_min, v_max, format, flags);
    %%%%%: 3294-block 13
call    0 never executed
    #####: 3295:        PopID();
call    0 never executed
    #####: 3296:        PopItemWidth();
call    0 never executed
    #####: 3297:        v = (void*)((char*)v + type_size);
        -: 3298:    }
    #####: 3299:    PopID();
    %%%%%: 3299-block 18
call    0 never executed
        -: 3300:
    #####: 3301:    const char* label_end = FindRenderedTextEnd(label);
call    0 never executed
    #####: 3302:    if (label != label_end)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3303:    {
    #####: 3304:        SameLine(0, g.Style.ItemInnerSpacing.x);
    %%%%%: 3304-block 21
call    0 never executed
    #####: 3305:        TextEx(label, label_end);
call    0 never executed
        -: 3306:    }
        -: 3307:
    #####: 3308:    EndGroup();
    %%%%%: 3308-block 23
call    0 never executed
    #####: 3309:    return value_changed;
        -: 3310:}
        -: 3311:
function _ZN5ImGui11SliderFloatEPKcPfffS1_i called 0 returned 0% blocks executed 0%
    #####: 3312:bool ImGui::SliderFloat(const char* label, float* v, float v_min, float v_max, const char* format, ImGuiSliderFlags flags)
        -: 3313:{
    #####: 3314:    return SliderScalar(label, ImGuiDataType_Float, v, &v_min, &v_max, format, flags);
    %%%%%: 3314-block 2
call    0 never executed
        -: 3315:}
        -: 3316:
function _ZN5ImGui12SliderFloat2EPKcPfffS1_i called 0 returned 0% blocks executed 0%
    #####: 3317:bool ImGui::SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* format, ImGuiSliderFlags flags)
        -: 3318:{
    #####: 3319:    return SliderScalarN(label, ImGuiDataType_Float, v, 2, &v_min, &v_max, format, flags);
    %%%%%: 3319-block 2
call    0 never executed
        -: 3320:}
        -: 3321:
function _ZN5ImGui12SliderFloat3EPKcPfffS1_i called 0 returned 0% blocks executed 0%
    #####: 3322:bool ImGui::SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* format, ImGuiSliderFlags flags)
        -: 3323:{
    #####: 3324:    return SliderScalarN(label, ImGuiDataType_Float, v, 3, &v_min, &v_max, format, flags);
    %%%%%: 3324-block 2
call    0 never executed
        -: 3325:}
        -: 3326:
function _ZN5ImGui12SliderFloat4EPKcPfffS1_i called 0 returned 0% blocks executed 0%
    #####: 3327:bool ImGui::SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* format, ImGuiSliderFlags flags)
        -: 3328:{
    #####: 3329:    return SliderScalarN(label, ImGuiDataType_Float, v, 4, &v_min, &v_max, format, flags);
    %%%%%: 3329-block 2
call    0 never executed
        -: 3330:}
        -: 3331:
function _ZN5ImGui11SliderAngleEPKcPfffS1_i called 0 returned 0% blocks executed 0%
    #####: 3332:bool ImGui::SliderAngle(const char* label, float* v_rad, float v_degrees_min, float v_degrees_max, const char* format, ImGuiSliderFlags flags)
        -: 3333:{
    #####: 3334:    if (format == NULL)
    %%%%%: 3334-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3335:        format = "%.0f deg";
    %%%%%: 3335-block 3
    #####: 3336:    float v_deg = (*v_rad) * 360.0f / (2 * IM_PI);
    #####: 3337:    bool value_changed = SliderFloat(label, &v_deg, v_degrees_min, v_degrees_max, format, flags);
    %%%%%: 3337-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3338:    *v_rad = v_deg * (2 * IM_PI) / 360.0f;
    #####: 3339:    return value_changed;
    %%%%%: 3339-block 5
    %%%%%: 3339-block 6
        -: 3340:}
        -: 3341:
function _ZN5ImGui9SliderIntEPKcPiiiS1_i called 0 returned 0% blocks executed 0%
    #####: 3342:bool ImGui::SliderInt(const char* label, int* v, int v_min, int v_max, const char* format, ImGuiSliderFlags flags)
        -: 3343:{
    #####: 3344:    return SliderScalar(label, ImGuiDataType_S32, v, &v_min, &v_max, format, flags);
    %%%%%: 3344-block 2
call    0 never executed
        -: 3345:}
        -: 3346:
function _ZN5ImGui10SliderInt2EPKcPiiiS1_i called 0 returned 0% blocks executed 0%
    #####: 3347:bool ImGui::SliderInt2(const char* label, int v[2], int v_min, int v_max, const char* format, ImGuiSliderFlags flags)
        -: 3348:{
    #####: 3349:    return SliderScalarN(label, ImGuiDataType_S32, v, 2, &v_min, &v_max, format, flags);
    %%%%%: 3349-block 2
call    0 never executed
        -: 3350:}
        -: 3351:
function _ZN5ImGui10SliderInt3EPKcPiiiS1_i called 0 returned 0% blocks executed 0%
    #####: 3352:bool ImGui::SliderInt3(const char* label, int v[3], int v_min, int v_max, const char* format, ImGuiSliderFlags flags)
        -: 3353:{
    #####: 3354:    return SliderScalarN(label, ImGuiDataType_S32, v, 3, &v_min, &v_max, format, flags);
    %%%%%: 3354-block 2
call    0 never executed
        -: 3355:}
        -: 3356:
function _ZN5ImGui10SliderInt4EPKcPiiiS1_i called 0 returned 0% blocks executed 0%
    #####: 3357:bool ImGui::SliderInt4(const char* label, int v[4], int v_min, int v_max, const char* format, ImGuiSliderFlags flags)
        -: 3358:{
    #####: 3359:    return SliderScalarN(label, ImGuiDataType_S32, v, 4, &v_min, &v_max, format, flags);
    %%%%%: 3359-block 2
call    0 never executed
        -: 3360:}
        -: 3361:
function _ZN5ImGui13VSliderScalarEPKcRK6ImVec2iPvPKvS7_S1_i called 0 returned 0% blocks executed 0%
    #####: 3362:bool ImGui::VSliderScalar(const char* label, const ImVec2& size, ImGuiDataType data_type, void* p_data, const void* p_min, const void* p_max, const char* format, ImGuiSliderFlags flags)
        -: 3363:{
    #####: 3364:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%: 3364-block 2
call    0 never executed
    #####: 3365:    if (window->SkipItems)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3366:        return false;
    %%%%%: 3366-block 4
        -: 3367:
    #####: 3368:    ImGuiContext& g = *GImGui;
    #####: 3369:    const ImGuiStyle& style = g.Style;
    #####: 3370:    const ImGuiID id = window->GetID(label);
    %%%%%: 3370-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 3371:
    #####: 3372:    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    %%%%%: 3372-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3373:    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + size);
    %%%%%: 3373-block 7
call    0 never executed
call    1 never executed
    #####: 3374:    const ImRect bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3374-block 10
    %%%%%: 3374-block 11
    %%%%%: 3374-block 12
call    2 never executed
call    3 never executed
call    4 never executed
        -: 3375:
    #####: 3376:    ItemSize(bb, style.FramePadding.y);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3377:    if (!ItemAdd(frame_bb, id))
    %%%%%: 3377-block 16
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 3377-block 17
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 3378:        return false;
    %%%%%: 3378-block 18
        -: 3379:
        -: 3380:    // Default format string when passing NULL
    #####: 3381:    if (format == NULL)
    %%%%%: 3381-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3382:        format = DataTypeGetInfo(data_type)->PrintFmt;
    %%%%%: 3382-block 20
call    0 never executed
        -: 3383:
    #####: 3384:    const bool hovered = ItemHoverable(frame_bb, id, g.LastItemData.ItemFlags);
    %%%%%: 3384-block 22
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3385:    const bool clicked = hovered && IsMouseClicked(0, ImGuiInputFlags_None, id);
    %%%%%: 3385-block 23
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3385-block 24
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 3385-block 25
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 3385-block 26
    %%%%%: 3385-block 27
    #####: 3386:    if (clicked || g.NavActivateId == id)
    %%%%%: 3386-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3386-block 29
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 3387:    {
    #####: 3388:        if (clicked)
    %%%%%: 3388-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3389:            SetKeyOwner(ImGuiKey_MouseLeft, id);
    %%%%%: 3389-block 31
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3390:        SetActiveID(id, window);
    %%%%%: 3390-block 32
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3391:        SetFocusID(id, window);
    %%%%%: 3391-block 33
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3392:        FocusWindow(window);
    %%%%%: 3392-block 34
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3393:        g.ActiveIdUsingNavDirMask |= (1 << ImGuiDir_Up) | (1 << ImGuiDir_Down);
    %%%%%: 3393-block 35
        -: 3394:    }
        -: 3395:
        -: 3396:    // Draw frame
    #####: 3397:    const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);
    %%%%%: 3397-block 36
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3397-block 37
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3397-block 38
    %%%%%: 3397-block 39
    %%%%%: 3397-block 40
    %%%%%: 3397-block 41
    %%%%%: 3397-block 42
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    #####: 3398:    RenderNavCursor(frame_bb, id);
    %%%%%: 3398-block 43
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3399:    RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, g.Style.FrameRounding);
    %%%%%: 3399-block 44
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 3400:
        -: 3401:    // Slider behavior
    #####: 3402:    ImRect grab_bb;
    #####: 3403:    const bool value_changed = SliderBehavior(frame_bb, id, data_type, p_data, p_min, p_max, format, flags | ImGuiSliderFlags_Vertical, &grab_bb);
    %%%%%: 3403-block 45
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3404:    if (value_changed)
    %%%%%: 3404-block 46
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3405:        MarkItemEdited(id);
    %%%%%: 3405-block 47
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 3406:
        -: 3407:    // Render grab
    #####: 3408:    if (grab_bb.Max.y > grab_bb.Min.y)
    %%%%%: 3408-block 48
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3409:        window->DrawList->AddRectFilled(grab_bb.Min, grab_bb.Max, GetColorU32(g.ActiveId == id ? ImGuiCol_SliderGrabActive : ImGuiCol_SliderGrab), style.GrabRounding);
    %%%%%: 3409-block 49
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3409-block 50
    %%%%%: 3409-block 51
    %%%%%: 3409-block 52
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 3409-block 53
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
        -: 3410:
        -: 3411:    // Display value using user-provided display format so user can add prefix/suffix/decorations to the value.
        -: 3412:    // For the vertical slider we allow centered text to overlap the frame padding
        -: 3413:    char value_buf[64];
    #####: 3414:    const char* value_buf_end = value_buf + DataTypeFormatString(value_buf, IM_ARRAYSIZE(value_buf), data_type, p_data, format);
    %%%%%: 3414-block 54
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3415:    RenderTextClipped(ImVec2(frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y), frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f, 0.0f));
    %%%%%: 3415-block 55
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    $$$$$: 3415-block 65
    $$$$$: 3415-block 66
    #####: 3416:    if (label_size.x > 0.0f)
    %%%%%: 3416-block 58
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3417:        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);
    %%%%%: 3417-block 59
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 3417-block 61
    $$$$$: 3417-block 67
        -: 3418:
    #####: 3419:    return value_changed;
    %%%%%: 3419-block 62
        -: 3420:}
        -: 3421:
function _ZN5ImGui12VSliderFloatEPKcRK6ImVec2PfffS1_i called 0 returned 0% blocks executed 0%
    #####: 3422:bool ImGui::VSliderFloat(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* format, ImGuiSliderFlags flags)
        -: 3423:{
    #####: 3424:    return VSliderScalar(label, size, ImGuiDataType_Float, v, &v_min, &v_max, format, flags);
    %%%%%: 3424-block 2
call    0 never executed
        -: 3425:}
        -: 3426:
function _ZN5ImGui10VSliderIntEPKcRK6ImVec2PiiiS1_i called 0 returned 0% blocks executed 0%
    #####: 3427:bool ImGui::VSliderInt(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* format, ImGuiSliderFlags flags)
        -: 3428:{
    #####: 3429:    return VSliderScalar(label, size, ImGuiDataType_S32, v, &v_min, &v_max, format, flags);
    %%%%%: 3429-block 2
call    0 never executed
        -: 3430:}
        -: 3431:
        -: 3432://-------------------------------------------------------------------------
        -: 3433:// [SECTION] Widgets: InputScalar, InputFloat, InputInt, etc.
        -: 3434://-------------------------------------------------------------------------
        -: 3435:// - ImParseFormatFindStart() [Internal]
        -: 3436:// - ImParseFormatFindEnd() [Internal]
        -: 3437:// - ImParseFormatTrimDecorations() [Internal]
        -: 3438:// - ImParseFormatSanitizeForPrinting() [Internal]
        -: 3439:// - ImParseFormatSanitizeForScanning() [Internal]
        -: 3440:// - ImParseFormatPrecision() [Internal]
        -: 3441:// - TempInputTextScalar() [Internal]
        -: 3442:// - InputScalar()
        -: 3443:// - InputScalarN()
        -: 3444:// - InputFloat()
        -: 3445:// - InputFloat2()
        -: 3446:// - InputFloat3()
        -: 3447:// - InputFloat4()
        -: 3448:// - InputInt()
        -: 3449:// - InputInt2()
        -: 3450:// - InputInt3()
        -: 3451:// - InputInt4()
        -: 3452:// - InputDouble()
        -: 3453://-------------------------------------------------------------------------
        -: 3454:
        -: 3455:// We don't use strchr() because our strings are usually very short and often start with '%'
function _Z22ImParseFormatFindStartPKc called 0 returned 0% blocks executed 0%
    #####: 3456:const char* ImParseFormatFindStart(const char* fmt)
        -: 3457:{
    #####: 3458:    while (char c = fmt[0])
    %%%%%: 3458-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3459:    {
    #####: 3460:        if (c == '%' && fmt[1] != '%')
    %%%%%: 3460-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3460-block 4
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3461:            return fmt;
    %%%%%: 3461-block 5
    #####: 3462:        else if (c == '%')
    %%%%%: 3462-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3463:            fmt++;
    %%%%%: 3463-block 7
    #####: 3464:        fmt++;
    #####: 3465:    }
    %%%%%: 3465-block 8
    #####: 3466:    return fmt;
    %%%%%: 3466-block 9
        -: 3467:}
        -: 3468:
function _Z20ImParseFormatFindEndPKc called 0 returned 0% blocks executed 0%
    #####: 3469:const char* ImParseFormatFindEnd(const char* fmt)
        -: 3470:{
        -: 3471:    // Printf/scanf types modifiers: I/L/h/j/l/t/w/z. Other uppercase letters qualify as types aka end of the format.
    #####: 3472:    if (fmt[0] != '%')
    %%%%%: 3472-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3473:        return fmt;
    %%%%%: 3473-block 3
    #####: 3474:    const unsigned int ignored_uppercase_mask = (1 << ('I'-'A')) | (1 << ('L'-'A'));
    #####: 3475:    const unsigned int ignored_lowercase_mask = (1 << ('h'-'a')) | (1 << ('j'-'a')) | (1 << ('l'-'a')) | (1 << ('t'-'a')) | (1 << ('w'-'a')) | (1 << ('z'-'a'));
    #####: 3476:    for (char c; (c = *fmt) != 0; fmt++)
    %%%%%: 3476-block 4
    %%%%%: 3476-block 13
    %%%%%: 3476-block 14
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 3477:    {
    #####: 3478:        if (c >= 'A' && c <= 'Z' && ((1 << (c - 'A')) & ignored_uppercase_mask) == 0)
    %%%%%: 3478-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3478-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3478-block 7
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 3479:            return fmt + 1;
    %%%%%: 3479-block 8
    #####: 3480:        if (c >= 'a' && c <= 'z' && ((1 << (c - 'a')) & ignored_lowercase_mask) == 0)
    %%%%%: 3480-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3480-block 10
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3480-block 11
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 3481:            return fmt + 1;
    %%%%%: 3481-block 12
        -: 3482:    }
    #####: 3483:    return fmt;
    %%%%%: 3483-block 15
        -: 3484:}
        -: 3485:
        -: 3486:// Extract the format out of a format string with leading or trailing decorations
        -: 3487://  fmt = "blah blah"  -> return ""
        -: 3488://  fmt = "%.3f"       -> return fmt
        -: 3489://  fmt = "hello %.3f" -> return fmt + 6
        -: 3490://  fmt = "%.3f hello" -> return buf written with "%.3f"
function _Z28ImParseFormatTrimDecorationsPKcPcm called 0 returned 0% blocks executed 0%
    #####: 3491:const char* ImParseFormatTrimDecorations(const char* fmt, char* buf, size_t buf_size)
        -: 3492:{
    #####: 3493:    const char* fmt_start = ImParseFormatFindStart(fmt);
    %%%%%: 3493-block 2
call    0 never executed
    #####: 3494:    if (fmt_start[0] != '%')
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3495:        return "";
    %%%%%: 3495-block 4
    #####: 3496:    const char* fmt_end = ImParseFormatFindEnd(fmt_start);
    %%%%%: 3496-block 5
call    0 never executed
    #####: 3497:    if (fmt_end[0] == 0) // If we only have leading decoration, we don't need to copy the data.
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3498:        return fmt_start;
    %%%%%: 3498-block 7
    #####: 3499:    ImStrncpy(buf, fmt_start, ImMin((size_t)(fmt_end - fmt_start) + 1, buf_size));
    %%%%%: 3499-block 8
call    0 never executed
call    1 never executed
    #####: 3500:    return buf;
        -: 3501:}
        -: 3502:
        -: 3503:// Sanitize format
        -: 3504:// - Zero terminate so extra characters after format (e.g. "%f123") don't confuse atof/atoi
        -: 3505:// - stb_sprintf.h supports several new modifiers which format numbers in a way that also makes them incompatible atof/atoi.
function _Z32ImParseFormatSanitizeForPrintingPKcPcm called 0 returned 0% blocks executed 0%
    #####: 3506:void ImParseFormatSanitizeForPrinting(const char* fmt_in, char* fmt_out, size_t fmt_out_size)
        -: 3507:{
    #####: 3508:    const char* fmt_end = ImParseFormatFindEnd(fmt_in);
    %%%%%: 3508-block 2
call    0 never executed
        -: 3509:    IM_UNUSED(fmt_out_size);
    #####: 3510:    IM_ASSERT((size_t)(fmt_end - fmt_in + 1) < fmt_out_size); // Format is too long, let us know if this happens to you!
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3510-block 4
call    2 never executed
    #####: 3511:    while (fmt_in < fmt_end)
    %%%%%: 3511-block 5
    %%%%%: 3511-block 10
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 3512:    {
    #####: 3513:        char c = *fmt_in++;
    #####: 3514:        if (c != '\'' && c != '$' && c != '_') // Custom flags provided by stb_sprintf.h. POSIX 2008 also supports '.
    %%%%%: 3514-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3514-block 7
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3514-block 8
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 3515:            *(fmt_out++) = c;
    %%%%%: 3515-block 9
        -: 3516:    }
    #####: 3517:    *fmt_out = 0; // Zero-terminate
    #####: 3518:}
        -: 3519:
        -: 3520:// - For scanning we need to remove all width and precision fields and flags "%+3.7f" -> "%f". BUT don't strip types like "%I64d" which includes digits. ! "%07I64d" -> "%I64d"
function _Z32ImParseFormatSanitizeForScanningPKcPcm called 0 returned 0% blocks executed 0%
    #####: 3521:const char* ImParseFormatSanitizeForScanning(const char* fmt_in, char* fmt_out, size_t fmt_out_size)
        -: 3522:{
    #####: 3523:    const char* fmt_end = ImParseFormatFindEnd(fmt_in);
    %%%%%: 3523-block 2
call    0 never executed
    #####: 3524:    const char* fmt_out_begin = fmt_out;
        -: 3525:    IM_UNUSED(fmt_out_size);
    #####: 3526:    IM_ASSERT((size_t)(fmt_end - fmt_in + 1) < fmt_out_size); // Format is too long, let us know if this happens to you!
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3526-block 4
call    2 never executed
    #####: 3527:    bool has_type = false;
    #####: 3528:    while (fmt_in < fmt_end)
    %%%%%: 3528-block 5
    %%%%%: 3528-block 23
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 3529:    {
    #####: 3530:        char c = *fmt_in++;
    #####: 3531:        if (!has_type && ((c >= '0' && c <= '9') || c == '.' || c == '+' || c == '#'))
    %%%%%: 3531-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3531-block 7
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3531-block 8
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 3531-block 9
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 3531-block 10
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%: 3531-block 11
branch 10 never executed (fallthrough)
branch 11 never executed
    #####: 3532:            continue;
    %%%%%: 3532-block 12
    #####: 3533:        has_type |= ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')); // Stop skipping digits
    %%%%%: 3533-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3533-block 14
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3533-block 15
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 3533-block 16
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 3533-block 17
    %%%%%: 3533-block 18
    #####: 3534:        if (c != '\'' && c != '$' && c != '_') // Custom flags provided by stb_sprintf.h. POSIX 2008 also supports '.
    %%%%%: 3534-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3534-block 20
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3534-block 21
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 3535:            *(fmt_out++) = c;
    %%%%%: 3535-block 22
        -: 3536:    }
    #####: 3537:    *fmt_out = 0; // Zero-terminate
    #####: 3538:    return fmt_out_begin;
    %%%%%: 3538-block 24
        -: 3539:}
        -: 3540:
        -: 3541:template<typename TYPE>
function _Z6ImAtoiIiEPKcS1_PT_ called 0 returned 0% blocks executed 0%
    #####: 3542:static const char* ImAtoi(const char* src, TYPE* output)
        -: 3543:{
    #####: 3544:    int negative = 0;
    #####: 3545:    if (*src == '-') { negative = 1; src++; }
    %%%%%: 3545-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3545-block 3
    #####: 3546:    if (*src == '+') { src++; }
    %%%%%: 3546-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3546-block 5
    #####: 3547:    TYPE v = 0;
    #####: 3548:    while (*src >= '0' && *src <= '9')
    %%%%%: 3548-block 6
    %%%%%: 3548-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3548-block 9
branch  2 never executed
branch  3 never executed (fallthrough)
    #####: 3549:        v = (v * 10) + (*src++ - '0');
    %%%%%: 3549-block 7
    #####: 3550:    *output = negative ? -v : v;
    %%%%%: 3550-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3550-block 11
    %%%%%: 3550-block 12
    #####: 3551:    return src;
    %%%%%: 3551-block 13
        -: 3552:}
        -: 3553:
        -: 3554:// Parse display precision back from the display format string
        -: 3555:// FIXME: This is still used by some navigation code path to infer a minimum tweak step, but we should aim to rework widgets so it isn't needed.
function _Z22ImParseFormatPrecisionPKci called 0 returned 0% blocks executed 0%
    #####: 3556:int ImParseFormatPrecision(const char* fmt, int default_precision)
        -: 3557:{
    #####: 3558:    fmt = ImParseFormatFindStart(fmt);
    %%%%%: 3558-block 2
call    0 never executed
    #####: 3559:    if (fmt[0] != '%')
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3560:        return default_precision;
    %%%%%: 3560-block 4
    #####: 3561:    fmt++;
    #####: 3562:    while (*fmt >= '0' && *fmt <= '9')
    %%%%%: 3562-block 5
    %%%%%: 3562-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3562-block 8
branch  2 never executed
branch  3 never executed (fallthrough)
    #####: 3563:        fmt++;
    %%%%%: 3563-block 6
    #####: 3564:    int precision = INT_MAX;
    #####: 3565:    if (*fmt == '.')
    %%%%%: 3565-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3566:    {
    #####: 3567:        fmt = ImAtoi<int>(fmt + 1, &precision);
    %%%%%: 3567-block 10
call    0 never executed
    #####: 3568:        if (precision < 0 || precision > 99)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3568-block 12
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3569:            precision = default_precision;
    %%%%%: 3569-block 13
        -: 3570:    }
    #####: 3571:    if (*fmt == 'e' || *fmt == 'E') // Maximum precision with scientific notation
    %%%%%: 3571-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3571-block 15
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3572:        precision = -1;
    %%%%%: 3572-block 16
    #####: 3573:    if ((*fmt == 'g' || *fmt == 'G') && precision == INT_MAX)
    %%%%%: 3573-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3573-block 18
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3573-block 19
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 3574:        precision = -1;
    %%%%%: 3574-block 20
    #####: 3575:    return (precision == INT_MAX) ? default_precision : precision;
    %%%%%: 3575-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3575-block 22
    %%%%%: 3575-block 23
    %%%%%: 3575-block 24
        -: 3576:}
        -: 3577:
        -: 3578:// Create text input in place of another active widget (e.g. used when doing a CTRL+Click on drag/slider widgets)
        -: 3579:// FIXME: Facilitate using this in variety of other situations.
        -: 3580:// FIXME: Among other things, setting ImGuiItemFlags_AllowDuplicateId in LastItemData is currently correct but
        -: 3581:// the expected relationship between TempInputXXX functions and LastItemData is a little fishy.
function _ZN5ImGui13TempInputTextERK6ImRectjPKcPcii called 0 returned 0% blocks executed 0%
    #####: 3582:bool ImGui::TempInputText(const ImRect& bb, ImGuiID id, const char* label, char* buf, int buf_size, ImGuiInputTextFlags flags)
        -: 3583:{
        -: 3584:    // On the first frame, g.TempInputTextId == 0, then on subsequent frames it becomes == id.
        -: 3585:    // We clear ActiveID on the first frame to allow the InputText() taking it back.
    #####: 3586:    ImGuiContext& g = *GImGui;
    #####: 3587:    const bool init = (g.TempInputId != id);
    #####: 3588:    if (init)
    %%%%%: 3588-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3589:        ClearActiveID();
    %%%%%: 3589-block 3
call    0 never executed
        -: 3590:
    #####: 3591:    g.CurrentWindow->DC.CursorPos = bb.Min;
    #####: 3592:    g.LastItemData.ItemFlags |= ImGuiItemFlags_AllowDuplicateId;
    #####: 3593:    bool value_changed = InputTextEx(label, NULL, buf, buf_size, bb.GetSize(), flags | ImGuiInputTextFlags_MergedItem);
    %%%%%: 3593-block 4
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####: 3594:    if (init)
    %%%%%: 3594-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3595:    {
        -: 3596:        // First frame we started displaying the InputText widget, we expect it to take the active id.
    #####: 3597:        IM_ASSERT(g.ActiveId == id);
    %%%%%: 3597-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3597-block 8
call    2 never executed
    #####: 3598:        g.TempInputId = g.ActiveId;
    %%%%%: 3598-block 9
        -: 3599:    }
    #####: 3600:    return value_changed;
    %%%%%: 3600-block 10
    %%%%%: 3600-block 11
        -: 3601:}
        -: 3602:
        -: 3603:// Note that Drag/Slider functions are only forwarding the min/max values clamping values if the ImGuiSliderFlags_AlwaysClamp flag is set!
        -: 3604:// This is intended: this way we allow CTRL+Click manual input to set a value out of bounds, for maximum flexibility.
        -: 3605:// However this may not be ideal for all uses, as some user code may break on out of bound values.
function _ZN5ImGui15TempInputScalarERK6ImRectjPKciPvS4_PKvS7_ called 0 returned 0% blocks executed 0%
    #####: 3606:bool ImGui::TempInputScalar(const ImRect& bb, ImGuiID id, const char* label, ImGuiDataType data_type, void* p_data, const char* format, const void* p_clamp_min, const void* p_clamp_max)
        -: 3607:{
        -: 3608:    // FIXME: May need to clarify display behavior if format doesn't contain %.
        -: 3609:    // "%d" -> "%d" / "There are %d items" -> "%d" / "items" -> "%d" (fallback). Also see #6405
    #####: 3610:    ImGuiContext& g = *GImGui;
    #####: 3611:    const ImGuiDataTypeInfo* type_info = DataTypeGetInfo(data_type);
    %%%%%: 3611-block 2
call    0 never executed
        -: 3612:    char fmt_buf[32];
        -: 3613:    char data_buf[32];
    #####: 3614:    format = ImParseFormatTrimDecorations(format, fmt_buf, IM_ARRAYSIZE(fmt_buf));
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3615:    if (format[0] == 0)
    %%%%%: 3615-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3616:        format = type_info->PrintFmt;
    %%%%%: 3616-block 5
    #####: 3617:    DataTypeFormatString(data_buf, IM_ARRAYSIZE(data_buf), data_type, p_data, format);
    %%%%%: 3617-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3618:    ImStrTrimBlanks(data_buf);
    %%%%%: 3618-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 3619:
    #####: 3620:    ImGuiInputTextFlags flags = ImGuiInputTextFlags_AutoSelectAll | (ImGuiInputTextFlags)ImGuiInputTextFlags_LocalizeDecimalPoint;
    #####: 3621:    g.LastItemData.ItemFlags |= ImGuiItemFlags_NoMarkEdited; // Because TempInputText() uses ImGuiInputTextFlags_MergedItem it doesn't submit a new item, so we poke LastItemData.
    #####: 3622:    bool value_changed = false;
    #####: 3623:    if (TempInputText(bb, id, label, data_buf, IM_ARRAYSIZE(data_buf), flags))
    %%%%%: 3623-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 3623-block 9
branch  3 never executed (fallthrough)
branch  4 never executed
        -: 3624:    {
        -: 3625:        // Backup old value
    #####: 3626:        size_t data_type_size = type_info->Size;
        -: 3627:        ImGuiDataTypeStorage data_backup;
    #####: 3628:        memcpy(&data_backup, p_data, data_type_size);
        -: 3629:
        -: 3630:        // Apply new value (or operations) then clamp
    #####: 3631:        DataTypeApplyFromText(data_buf, data_type, p_data, format, NULL);
    %%%%%: 3631-block 10
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3632:        if (p_clamp_min || p_clamp_max)
    %%%%%: 3632-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3632-block 12
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 3633:        {
    #####: 3634:            if (p_clamp_min && p_clamp_max && DataTypeCompare(data_type, p_clamp_min, p_clamp_max) > 0)
    %%%%%: 3634-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3634-block 14
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3634-block 15
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    %%%%%: 3634-block 16
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 3634-block 17
    %%%%%: 3634-block 18
    %%%%%: 3634-block 19
branch  9 never executed (fallthrough)
branch 10 never executed
    #####: 3635:                ImSwap(p_clamp_min, p_clamp_max);
    %%%%%: 3635-block 20
call    0 never executed
    #####: 3636:            DataTypeClamp(data_type, p_data, p_clamp_min, p_clamp_max);
    %%%%%: 3636-block 21
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 3637:        }
        -: 3638:
        -: 3639:        // Only mark as edited if new value is different
    #####: 3640:        g.LastItemData.ItemFlags &= ~ImGuiItemFlags_NoMarkEdited;
    #####: 3641:        value_changed = memcmp(&data_backup, p_data, data_type_size) != 0;
    #####: 3642:        if (value_changed)
    %%%%%: 3642-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3643:            MarkItemEdited(id);
    %%%%%: 3643-block 23
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 3644:    }
    #####: 3645:    return value_changed;
    %%%%%: 3645-block 25
    %%%%%: 3645-block 26
        -: 3646:}
        -: 3647:
function _ZN5ImGui17SetNextItemRefValEiPv called 0 returned 0% blocks executed 0%
    #####: 3648:void ImGui::SetNextItemRefVal(ImGuiDataType data_type, void* p_data)
        -: 3649:{
    #####: 3650:    ImGuiContext& g = *GImGui;
    #####: 3651:    g.NextItemData.HasFlags |= ImGuiNextItemDataFlags_HasRefVal;
    #####: 3652:    memcpy(&g.NextItemData.RefVal, p_data, DataTypeGetInfo(data_type)->Size);
    %%%%%: 3652-block 2
call    0 never executed
    #####: 3653:}
        -: 3654:
        -: 3655:// Note: p_data, p_step, p_step_fast are _pointers_ to a memory address holding the data. For an Input widget, p_step and p_step_fast are optional.
        -: 3656:// Read code of e.g. InputFloat(), InputInt() etc. or examples in 'Demo->Widgets->Data Types' to understand how to use this function directly.
function _ZN5ImGui11InputScalarEPKciPvPKvS4_S1_i called 0 returned 0% blocks executed 0%
    #####: 3657:bool ImGui::InputScalar(const char* label, ImGuiDataType data_type, void* p_data, const void* p_step, const void* p_step_fast, const char* format, ImGuiInputTextFlags flags)
        -: 3658:{
    #####: 3659:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%: 3659-block 2
call    0 never executed
    #####: 3660:    if (window->SkipItems)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3661:        return false;
    %%%%%: 3661-block 4
        -: 3662:
    #####: 3663:    ImGuiContext& g = *GImGui;
    #####: 3664:    ImGuiStyle& style = g.Style;
    #####: 3665:    IM_ASSERT((flags & ImGuiInputTextFlags_EnterReturnsTrue) == 0); // Not supported by InputScalar(). Please open an issue if you this would be useful to you. Otherwise use IsItemDeactivatedAfterEdit()!
    %%%%%: 3665-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3665-block 6
call    2 never executed
        -: 3666:
    #####: 3667:    if (format == NULL)
    %%%%%: 3667-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3668:        format = DataTypeGetInfo(data_type)->PrintFmt;
    %%%%%: 3668-block 8
call    0 never executed
        -: 3669:
    #####: 3670:    void* p_data_default = (g.NextItemData.HasFlags & ImGuiNextItemDataFlags_HasRefVal) ? &g.NextItemData.RefVal : &g.DataTypeZeroValue;
    %%%%%: 3670-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3670-block 11
    %%%%%: 3670-block 12
        -: 3671:
        -: 3672:    char buf[64];
    #####: 3673:    if ((flags & ImGuiInputTextFlags_DisplayEmptyRefVal) && DataTypeCompare(data_type, p_data, p_data_default) == 0)
    %%%%%: 3673-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3673-block 14
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 3673-block 15
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 3673-block 16
    %%%%%: 3673-block 17
    %%%%%: 3673-block 18
branch  7 never executed (fallthrough)
branch  8 never executed
    #####: 3674:        buf[0] = 0;
    %%%%%: 3674-block 19
        -: 3675:    else
    #####: 3676:        DataTypeFormatString(buf, IM_ARRAYSIZE(buf), data_type, p_data, format);
    %%%%%: 3676-block 20
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 3677:
        -: 3678:    // Disable the MarkItemEdited() call in InputText but keep ImGuiItemStatusFlags_Edited.
        -: 3679:    // We call MarkItemEdited() ourselves by comparing the actual data rather than the string.
    #####: 3680:    g.NextItemData.ItemFlags |= ImGuiItemFlags_NoMarkEdited;
    #####: 3681:    flags |= ImGuiInputTextFlags_AutoSelectAll | (ImGuiInputTextFlags)ImGuiInputTextFlags_LocalizeDecimalPoint;
        -: 3682:
    #####: 3683:    bool value_changed = false;
    #####: 3684:    if (p_step == NULL)
    %%%%%: 3684-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3685:    {
    #####: 3686:        if (InputText(label, buf, IM_ARRAYSIZE(buf), flags))
    %%%%%: 3686-block 22
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 3686-block 23
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 3687:            value_changed = DataTypeApplyFromText(buf, data_type, p_data, format, (flags & ImGuiInputTextFlags_ParseEmptyRefVal) ? p_data_default : NULL);
    %%%%%: 3687-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3687-block 25
    %%%%%: 3687-block 26
    %%%%%: 3687-block 27
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 3687-block 28
        -: 3688:    }
        -: 3689:    else
        -: 3690:    {
    #####: 3691:        const float button_size = GetFrameHeight();
    %%%%%: 3691-block 29
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 3692:
    #####: 3693:        BeginGroup(); // The only purpose of the group here is to allow the caller to query item data e.g. IsItemActive()
    %%%%%: 3693-block 30
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3694:        PushID(label);
    %%%%%: 3694-block 31
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3695:        SetNextItemWidth(ImMax(1.0f, CalcItemWidth() - (button_size + style.ItemInnerSpacing.x) * 2));
    %%%%%: 3695-block 32
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 3695-block 33
call    3 never executed
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    #####: 3696:        if (InputText("", buf, IM_ARRAYSIZE(buf), flags)) // PushId(label) + "" gives us the expected ID from outside point of view
    %%%%%: 3696-block 35
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 3696-block 36
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 3697:            value_changed = DataTypeApplyFromText(buf, data_type, p_data, format, (flags & ImGuiInputTextFlags_ParseEmptyRefVal) ? p_data_default : NULL);
    %%%%%: 3697-block 37
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3697-block 38
    %%%%%: 3697-block 39
    %%%%%: 3697-block 40
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 3697-block 41
        -: 3698:        IMGUI_TEST_ENGINE_ITEM_INFO(g.LastItemData.ID, label, g.LastItemData.StatusFlags | ImGuiItemStatusFlags_Inputable);
        -: 3699:
        -: 3700:        // Step buttons
    #####: 3701:        const ImVec2 backup_frame_padding = style.FramePadding;
    #####: 3702:        style.FramePadding.x = style.FramePadding.y;
    #####: 3703:        if (flags & ImGuiInputTextFlags_ReadOnly)
    %%%%%: 3703-block 42
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3704:            BeginDisabled();
    %%%%%: 3704-block 43
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3705:        PushItemFlag(ImGuiItemFlags_ButtonRepeat, true);
    %%%%%: 3705-block 44
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3706:        SameLine(0, style.ItemInnerSpacing.x);
    %%%%%: 3706-block 45
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3707:        if (ButtonEx("-", ImVec2(button_size, button_size)))
    %%%%%: 3707-block 46
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 3707-block 48
branch  4 never executed (fallthrough)
branch  5 never executed
    $$$$$: 3707-block 80
        -: 3708:        {
    #####: 3709:            DataTypeApplyOp(data_type, '-', p_data, p_data, g.IO.KeyCtrl && p_step_fast ? p_step_fast : p_step);
    %%%%%: 3709-block 49
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3709-block 50
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3709-block 51
    %%%%%: 3709-block 52
    %%%%%: 3709-block 53
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    #####: 3710:            value_changed = true;
    %%%%%: 3710-block 54
        -: 3711:        }
    #####: 3712:        SameLine(0, style.ItemInnerSpacing.x);
    %%%%%: 3712-block 55
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3713:        if (ButtonEx("+", ImVec2(button_size, button_size)))
    %%%%%: 3713-block 56
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 3713-block 58
branch  4 never executed (fallthrough)
branch  5 never executed
    $$$$$: 3713-block 81
        -: 3714:        {
    #####: 3715:            DataTypeApplyOp(data_type, '+', p_data, p_data, g.IO.KeyCtrl && p_step_fast ? p_step_fast : p_step);
    %%%%%: 3715-block 59
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3715-block 60
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3715-block 61
    %%%%%: 3715-block 62
    %%%%%: 3715-block 63
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    #####: 3716:            value_changed = true;
    %%%%%: 3716-block 64
        -: 3717:        }
    #####: 3718:        PopItemFlag();
    %%%%%: 3718-block 65
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3719:        if (flags & ImGuiInputTextFlags_ReadOnly)
    %%%%%: 3719-block 66
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3720:            EndDisabled();
    %%%%%: 3720-block 67
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 3721:
    #####: 3722:        const char* label_end = FindRenderedTextEnd(label);
    %%%%%: 3722-block 68
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3723:        if (label != label_end)
    %%%%%: 3723-block 69
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3724:        {
    #####: 3725:            SameLine(0, style.ItemInnerSpacing.x);
    %%%%%: 3725-block 70
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3726:            TextEx(label, label_end);
    %%%%%: 3726-block 71
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 3727:        }
    #####: 3728:        style.FramePadding = backup_frame_padding;
        -: 3729:
    #####: 3730:        PopID();
    %%%%%: 3730-block 72
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3731:        EndGroup();
    %%%%%: 3731-block 73
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 3732:    }
        -: 3733:
    #####: 3734:    g.LastItemData.ItemFlags &= ~ImGuiItemFlags_NoMarkEdited;
    #####: 3735:    if (value_changed)
    %%%%%: 3735-block 75
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3736:        MarkItemEdited(g.LastItemData.ID);
    %%%%%: 3736-block 76
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 3737:
    #####: 3738:    return value_changed;
    %%%%%: 3738-block 77
        -: 3739:}
        -: 3740:
function _ZN5ImGui12InputScalarNEPKciPviPKvS4_S1_i called 0 returned 0% blocks executed 0%
    #####: 3741:bool ImGui::InputScalarN(const char* label, ImGuiDataType data_type, void* p_data, int components, const void* p_step, const void* p_step_fast, const char* format, ImGuiInputTextFlags flags)
        -: 3742:{
    #####: 3743:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%: 3743-block 2
call    0 never executed
    #####: 3744:    if (window->SkipItems)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3745:        return false;
    %%%%%: 3745-block 4
        -: 3746:
    #####: 3747:    ImGuiContext& g = *GImGui;
    #####: 3748:    bool value_changed = false;
    #####: 3749:    BeginGroup();
    %%%%%: 3749-block 5
call    0 never executed
    #####: 3750:    PushID(label);
call    0 never executed
    #####: 3751:    PushMultiItemsWidths(components, CalcItemWidth());
call    0 never executed
call    1 never executed
    #####: 3752:    size_t type_size = GDataTypeInfo[data_type].Size;
    #####: 3753:    for (int i = 0; i < components; i++)
    %%%%%: 3753-block 17
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 3754:    {
    #####: 3755:        PushID(i);
    %%%%%: 3755-block 10
call    0 never executed
    #####: 3756:        if (i > 0)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3757:            SameLine(0, g.Style.ItemInnerSpacing.x);
    %%%%%: 3757-block 12
call    0 never executed
    #####: 3758:        value_changed |= InputScalar("", data_type, p_data, p_step, p_step_fast, format, flags);
    %%%%%: 3758-block 13
call    0 never executed
    #####: 3759:        PopID();
call    0 never executed
    #####: 3760:        PopItemWidth();
call    0 never executed
    #####: 3761:        p_data = (void*)((char*)p_data + type_size);
        -: 3762:    }
    #####: 3763:    PopID();
    %%%%%: 3763-block 18
call    0 never executed
        -: 3764:
    #####: 3765:    const char* label_end = FindRenderedTextEnd(label);
call    0 never executed
    #####: 3766:    if (label != label_end)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3767:    {
    #####: 3768:        SameLine(0.0f, g.Style.ItemInnerSpacing.x);
    %%%%%: 3768-block 21
call    0 never executed
    #####: 3769:        TextEx(label, label_end);
call    0 never executed
        -: 3770:    }
        -: 3771:
    #####: 3772:    EndGroup();
    %%%%%: 3772-block 23
call    0 never executed
    #####: 3773:    return value_changed;
        -: 3774:}
        -: 3775:
function _ZN5ImGui10InputFloatEPKcPfffS1_i called 0 returned 0% blocks executed 0%
    #####: 3776:bool ImGui::InputFloat(const char* label, float* v, float step, float step_fast, const char* format, ImGuiInputTextFlags flags)
        -: 3777:{
    #####: 3778:    return InputScalar(label, ImGuiDataType_Float, (void*)v, (void*)(step > 0.0f ? &step : NULL), (void*)(step_fast > 0.0f ? &step_fast : NULL), format, flags);
    %%%%%: 3778-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3778-block 3
    %%%%%: 3778-block 4
    %%%%%: 3778-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3778-block 6
    %%%%%: 3778-block 7
    %%%%%: 3778-block 8
call    4 never executed
        -: 3779:}
        -: 3780:
function _ZN5ImGui11InputFloat2EPKcPfS1_i called 0 returned 0% blocks executed 0%
    #####: 3781:bool ImGui::InputFloat2(const char* label, float v[2], const char* format, ImGuiInputTextFlags flags)
        -: 3782:{
    #####: 3783:    return InputScalarN(label, ImGuiDataType_Float, v, 2, NULL, NULL, format, flags);
    %%%%%: 3783-block 2
call    0 never executed
        -: 3784:}
        -: 3785:
function _ZN5ImGui11InputFloat3EPKcPfS1_i called 0 returned 0% blocks executed 0%
    #####: 3786:bool ImGui::InputFloat3(const char* label, float v[3], const char* format, ImGuiInputTextFlags flags)
        -: 3787:{
    #####: 3788:    return InputScalarN(label, ImGuiDataType_Float, v, 3, NULL, NULL, format, flags);
    %%%%%: 3788-block 2
call    0 never executed
        -: 3789:}
        -: 3790:
function _ZN5ImGui11InputFloat4EPKcPfS1_i called 0 returned 0% blocks executed 0%
    #####: 3791:bool ImGui::InputFloat4(const char* label, float v[4], const char* format, ImGuiInputTextFlags flags)
        -: 3792:{
    #####: 3793:    return InputScalarN(label, ImGuiDataType_Float, v, 4, NULL, NULL, format, flags);
    %%%%%: 3793-block 2
call    0 never executed
        -: 3794:}
        -: 3795:
function _ZN5ImGui8InputIntEPKcPiiii called 0 returned 0% blocks executed 0%
    #####: 3796:bool ImGui::InputInt(const char* label, int* v, int step, int step_fast, ImGuiInputTextFlags flags)
        -: 3797:{
        -: 3798:    // Hexadecimal input provided as a convenience but the flag name is awkward. Typically you'd use InputText() to parse your own data, if you want to handle prefixes.
    #####: 3799:    const char* format = (flags & ImGuiInputTextFlags_CharsHexadecimal) ? "%08X" : "%d";
    %%%%%: 3799-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3799-block 3
    %%%%%: 3799-block 4
    #####: 3800:    return InputScalar(label, ImGuiDataType_S32, (void*)v, (void*)(step > 0 ? &step : NULL), (void*)(step_fast > 0 ? &step_fast : NULL), format, flags);
    %%%%%: 3800-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3800-block 6
    %%%%%: 3800-block 7
    %%%%%: 3800-block 8
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3800-block 9
    %%%%%: 3800-block 10
    %%%%%: 3800-block 11
call    4 never executed
        -: 3801:}
        -: 3802:
function _ZN5ImGui9InputInt2EPKcPii called 0 returned 0% blocks executed 0%
    #####: 3803:bool ImGui::InputInt2(const char* label, int v[2], ImGuiInputTextFlags flags)
        -: 3804:{
    #####: 3805:    return InputScalarN(label, ImGuiDataType_S32, v, 2, NULL, NULL, "%d", flags);
    %%%%%: 3805-block 2
call    0 never executed
        -: 3806:}
        -: 3807:
function _ZN5ImGui9InputInt3EPKcPii called 0 returned 0% blocks executed 0%
    #####: 3808:bool ImGui::InputInt3(const char* label, int v[3], ImGuiInputTextFlags flags)
        -: 3809:{
    #####: 3810:    return InputScalarN(label, ImGuiDataType_S32, v, 3, NULL, NULL, "%d", flags);
    %%%%%: 3810-block 2
call    0 never executed
        -: 3811:}
        -: 3812:
function _ZN5ImGui9InputInt4EPKcPii called 0 returned 0% blocks executed 0%
    #####: 3813:bool ImGui::InputInt4(const char* label, int v[4], ImGuiInputTextFlags flags)
        -: 3814:{
    #####: 3815:    return InputScalarN(label, ImGuiDataType_S32, v, 4, NULL, NULL, "%d", flags);
    %%%%%: 3815-block 2
call    0 never executed
        -: 3816:}
        -: 3817:
function _ZN5ImGui11InputDoubleEPKcPdddS1_i called 0 returned 0% blocks executed 0%
    #####: 3818:bool ImGui::InputDouble(const char* label, double* v, double step, double step_fast, const char* format, ImGuiInputTextFlags flags)
        -: 3819:{
    #####: 3820:    return InputScalar(label, ImGuiDataType_Double, (void*)v, (void*)(step > 0.0 ? &step : NULL), (void*)(step_fast > 0.0 ? &step_fast : NULL), format, flags);
    %%%%%: 3820-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3820-block 3
    %%%%%: 3820-block 4
    %%%%%: 3820-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3820-block 6
    %%%%%: 3820-block 7
    %%%%%: 3820-block 8
call    4 never executed
        -: 3821:}
        -: 3822:
        -: 3823://-------------------------------------------------------------------------
        -: 3824:// [SECTION] Widgets: InputText, InputTextMultiline, InputTextWithHint
        -: 3825://-------------------------------------------------------------------------
        -: 3826:// - imstb_textedit.h include
        -: 3827:// - InputText()
        -: 3828:// - InputTextWithHint()
        -: 3829:// - InputTextMultiline()
        -: 3830:// - InputTextGetCharInfo() [Internal]
        -: 3831:// - InputTextReindexLines() [Internal]
        -: 3832:// - InputTextReindexLinesRange() [Internal]
        -: 3833:// - InputTextEx() [Internal]
        -: 3834:// - DebugNodeInputTextState() [Internal]
        -: 3835://-------------------------------------------------------------------------
        -: 3836:
        -: 3837:namespace ImStb
        -: 3838:{
        -: 3839:#include "imstb_textedit.h"
        -: 3840:}
        -: 3841:
function _ZN5ImGui9InputTextEPKcPcmiPFiP26ImGuiInputTextCallbackDataEPv called 26925 returned 100% blocks executed 88%
    26925: 3842:bool ImGui::InputText(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data)
        -: 3843:{
   26925*: 3844:    IM_ASSERT(!(flags & ImGuiInputTextFlags_Multiline)); // call InputTextMultiline()
    26925: 3844-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 26925
    %%%%%: 3844-block 3
call    2 never executed
    26925: 3845:    return InputTextEx(label, NULL, buf, (int)buf_size, ImVec2(0, 0), flags, callback, user_data);
    26925: 3845-block 4
call    0 returned 26925
call    1 returned 26925
branch  2 taken 26925 (fallthrough)
branch  3 taken 0 (throw)
    26925: 3845-block 6
    26925: 3845-block 7
    26925: 3845-block 8
        -: 3846:}
        -: 3847:
function _ZN5ImGui18InputTextMultilineEPKcPcmRK6ImVec2iPFiP26ImGuiInputTextCallbackDataEPv called 0 returned 0% blocks executed 0%
    #####: 3848:bool ImGui::InputTextMultiline(const char* label, char* buf, size_t buf_size, const ImVec2& size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data)
        -: 3849:{
    #####: 3850:    return InputTextEx(label, NULL, buf, (int)buf_size, size, flags | ImGuiInputTextFlags_Multiline, callback, user_data);
    %%%%%: 3850-block 2
call    0 never executed
        -: 3851:}
        -: 3852:
function _ZN5ImGui17InputTextWithHintEPKcS1_PcmiPFiP26ImGuiInputTextCallbackDataEPv called 0 returned 0% blocks executed 0%
    #####: 3853:bool ImGui::InputTextWithHint(const char* label, const char* hint, char* buf, size_t buf_size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data)
        -: 3854:{
    #####: 3855:    IM_ASSERT(!(flags & ImGuiInputTextFlags_Multiline)); // call InputTextMultiline() or  InputTextEx() manually if you need multi-line + hint.
    %%%%%: 3855-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3855-block 3
call    2 never executed
    #####: 3856:    return InputTextEx(label, hint, buf, (int)buf_size, ImVec2(0, 0), flags, callback, user_data);
    %%%%%: 3856-block 4
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 3856-block 6
    %%%%%: 3856-block 7
    %%%%%: 3856-block 8
        -: 3857:}
        -: 3858:
        -: 3859:// This is only used in the path where the multiline widget is inactivate.
function _ZL32InputTextCalcTextLenAndLineCountPKcPS0_ called 0 returned 0% blocks executed 0%
    #####: 3860:static int InputTextCalcTextLenAndLineCount(const char* text_begin, const char** out_text_end)
        -: 3861:{
    #####: 3862:    int line_count = 0;
    #####: 3863:    const char* s = text_begin;
    %%%%%: 3863-block 2
        -: 3864:    while (true)
        -: 3865:    {
    #####: 3866:        const char* s_eol = strchr(s, '\n');
    #####: 3867:        line_count++;
    #####: 3868:        if (s_eol == NULL)
    %%%%%: 3868-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3869:        {
    #####: 3870:            s = s + strlen(s);
    #####: 3871:            break;
    %%%%%: 3871-block 4
        -: 3872:        }
    #####: 3873:        s = s_eol + 1;
    #####: 3874:    }
    %%%%%: 3874-block 5
    #####: 3875:    *out_text_end = s;
    #####: 3876:    return line_count;
    %%%%%: 3876-block 6
        -: 3877:}
        -: 3878:
        -: 3879:// FIXME: Ideally we'd share code with ImFont::CalcTextSizeA()
function _ZL21InputTextCalcTextSizeP12ImGuiContextPKcS2_PS2_P6ImVec2b called 0 returned 0% blocks executed 0%
    #####: 3880:static ImVec2 InputTextCalcTextSize(ImGuiContext* ctx, const char* text_begin, const char* text_end, const char** remaining, ImVec2* out_offset, bool stop_on_new_line)
        -: 3881:{
    #####: 3882:    ImGuiContext& g = *ctx;
    #####: 3883:    ImFont* font = g.Font;
    #####: 3884:    const float line_height = g.FontSize;
    #####: 3885:    const float scale = line_height / font->FontSize;
        -: 3886:
    #####: 3887:    ImVec2 text_size = ImVec2(0, 0);
    #####: 3888:    float line_width = 0.0f;
        -: 3889:
    #####: 3890:    const char* s = text_begin;
    #####: 3891:    while (s < text_end)
    %%%%%: 3891-block 2
    %%%%%: 3891-block 19
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 3892:    {
    #####: 3893:        unsigned int c = (unsigned int)*s;
    #####: 3894:        if (c < 0x80)
    %%%%%: 3894-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3895:            s += 1;
    %%%%%: 3895-block 4
        -: 3896:        else
    #####: 3897:            s += ImTextCharFromUtf8(&c, s, text_end);
    %%%%%: 3897-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 3897-block 6
        -: 3898:
    #####: 3899:        if (c == '\n')
    %%%%%: 3899-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3900:        {
    #####: 3901:            text_size.x = ImMax(text_size.x, line_width);
    %%%%%: 3901-block 8
call    0 never executed
    #####: 3902:            text_size.y += line_height;
    #####: 3903:            line_width = 0.0f;
    #####: 3904:            if (stop_on_new_line)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3905:                break;
    %%%%%: 3905-block 10
    #####: 3906:            continue;
    %%%%%: 3906-block 11
    %%%%%: 3906-block 18
        -: 3907:        }
    #####: 3908:        if (c == '\r')
    %%%%%: 3908-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3909:            continue;
    %%%%%: 3909-block 13
        -: 3910:
    #####: 3911:        const float char_width = ((int)c < font->IndexAdvanceX.Size ? font->IndexAdvanceX.Data[c] : font->FallbackAdvanceX) * scale;
    %%%%%: 3911-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3911-block 15
    %%%%%: 3911-block 16
    #####: 3912:        line_width += char_width;
    %%%%%: 3912-block 17
        -: 3913:    }
        -: 3914:
    #####: 3915:    if (text_size.x < line_width)
    %%%%%: 3915-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3916:        text_size.x = line_width;
    %%%%%: 3916-block 21
        -: 3917:
    #####: 3918:    if (out_offset)
    %%%%%: 3918-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3919:        *out_offset = ImVec2(line_width, text_size.y + line_height);  // offset allow for the possibility of sitting after a trailing \n
    %%%%%: 3919-block 23
call    0 never executed
        -: 3920:
    #####: 3921:    if (line_width > 0 || text_size.y == 0.0f)                        // whereas size.y will ignore the trailing \n
    %%%%%: 3921-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3921-block 26
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3922:        text_size.y += line_height;
    %%%%%: 3922-block 27
        -: 3923:
    #####: 3924:    if (remaining)
    %%%%%: 3924-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3925:        *remaining = s;
    %%%%%: 3925-block 29
        -: 3926:
    #####: 3927:    return text_size;
    %%%%%: 3927-block 30
    %%%%%: 3927-block 31
        -: 3928:}
        -: 3929:
        -: 3930:// Wrapper for stb_textedit.h to edit text (our wrapper is for: statically sized buffer, single-line, wchar characters. InputText converts between UTF-8 and wchar)
        -: 3931:// With our UTF-8 use of stb_textedit:
        -: 3932:// - STB_TEXTEDIT_GETCHAR is nothing more than a a "GETBYTE". It's only used to compare to ascii or to copy blocks of text so we are fine.
        -: 3933:// - One exception is the STB_TEXTEDIT_IS_SPACE feature which would expect a full char in order to handle full-width space such as 0x3000 (see ImCharIsBlankW).
        -: 3934:// - ...but we don't use that feature.
        -: 3935:namespace ImStb
        -: 3936:{
function _ZN5ImStbL22STB_TEXTEDIT_STRINGLENEPK19ImGuiInputTextState called 0 returned 0% blocks executed 0%
    #####: 3937:static int     STB_TEXTEDIT_STRINGLEN(const ImGuiInputTextState* obj)                             { return obj->CurLenA; }
    %%%%%: 3937-block 2
function _ZN5ImStbL20STB_TEXTEDIT_GETCHAREPK19ImGuiInputTextStatei called 0 returned 0% blocks executed 0%
    #####: 3938:static char    STB_TEXTEDIT_GETCHAR(const ImGuiInputTextState* obj, int idx)                      { IM_ASSERT(idx <= obj->CurLenA); return obj->TextA[idx]; }
    %%%%%: 3938-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3938-block 3
call    2 never executed
    %%%%%: 3938-block 4
call    3 never executed
function _ZN5ImStbL21STB_TEXTEDIT_GETWIDTHEP19ImGuiInputTextStateii called 0 returned 0% blocks executed 0%
    #####: 3939:static float   STB_TEXTEDIT_GETWIDTH(ImGuiInputTextState* obj, int line_start_idx, int char_idx)  { unsigned int c; ImTextCharFromUtf8(&c, obj->TextA.Data + line_start_idx + char_idx, obj->TextA.Data + obj->TextA.Size); if ((ImWchar)c == '\n') return IMSTB_TEXTEDIT_GETWIDTH_NEWLINE; ImGuiContext& g = *obj->Ctx; return g.Font->GetCharAdvance((ImWchar)c) * g.FontScale; }
    %%%%%: 3939-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 3939-block 3
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 3939-block 4
    %%%%%: 3939-block 5
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
    %%%%%: 3939-block 6
        -: 3940:static char    STB_TEXTEDIT_NEWLINE = '\n';
function _ZN5ImStbL22STB_TEXTEDIT_LAYOUTROWEPNS_14StbTexteditRowEP19ImGuiInputTextStatei called 0 returned 0% blocks executed 0%
    #####: 3941:static void    STB_TEXTEDIT_LAYOUTROW(StbTexteditRow* r, ImGuiInputTextState* obj, int line_start_idx)
        -: 3942:{
    #####: 3943:    const char* text = obj->TextA.Data;
    #####: 3944:    const char* text_remaining = NULL;
    #####: 3945:    const ImVec2 size = InputTextCalcTextSize(obj->Ctx, text + line_start_idx, text + obj->CurLenA, &text_remaining, NULL, true);
    %%%%%: 3945-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3946:    r->x0 = 0.0f;
    #####: 3947:    r->x1 = size.x;
    #####: 3948:    r->baseline_y_delta = size.y;
    #####: 3949:    r->ymin = 0.0f;
    #####: 3950:    r->ymax = size.y;
    #####: 3951:    r->num_chars = (int)(text_remaining - (text + line_start_idx));
    #####: 3952:}
    %%%%%: 3952-block 3
        -: 3953:
        -: 3954:#define IMSTB_TEXTEDIT_GETNEXTCHARINDEX  IMSTB_TEXTEDIT_GETNEXTCHARINDEX_IMPL
        -: 3955:#define IMSTB_TEXTEDIT_GETPREVCHARINDEX  IMSTB_TEXTEDIT_GETPREVCHARINDEX_IMPL
        -: 3956:
function _ZN5ImStbL36IMSTB_TEXTEDIT_GETNEXTCHARINDEX_IMPLEP19ImGuiInputTextStatei called 0 returned 0% blocks executed 0%
    #####: 3957:static int IMSTB_TEXTEDIT_GETNEXTCHARINDEX_IMPL(ImGuiInputTextState* obj, int idx)
        -: 3958:{
    #####: 3959:    if (idx >= obj->CurLenA)
    %%%%%: 3959-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3960:        return obj->CurLenA + 1;
    %%%%%: 3960-block 3
        -: 3961:    unsigned int c;
    #####: 3962:    return idx + ImTextCharFromUtf8(&c, obj->TextA.Data + idx, obj->TextA.Data + obj->TextA.Size);
    %%%%%: 3962-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 3962-block 5
        -: 3963:}
        -: 3964:
function _ZN5ImStbL36IMSTB_TEXTEDIT_GETPREVCHARINDEX_IMPLEP19ImGuiInputTextStatei called 0 returned 0% blocks executed 0%
    #####: 3965:static int IMSTB_TEXTEDIT_GETPREVCHARINDEX_IMPL(ImGuiInputTextState* obj, int idx)
        -: 3966:{
    #####: 3967:    if (idx <= 0)
    %%%%%: 3967-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3968:        return -1;
    %%%%%: 3968-block 3
    #####: 3969:    const char* p = ImTextFindPreviousUtf8Codepoint(obj->TextA.Data, obj->TextA.Data + idx);
    %%%%%: 3969-block 4
call    0 never executed
    #####: 3970:    return (int)(p - obj->TextA.Data);
        -: 3971:}
        -: 3972:
function _ZN5ImStbL18ImCharIsSeparatorWEj called 0 returned 0% blocks executed 0%
    #####: 3973:static bool ImCharIsSeparatorW(unsigned int c)
        -: 3974:{
        -: 3975:    static const unsigned int separator_list[] =
        -: 3976:    {
        -: 3977:        ',', 0x3001, '.', 0x3002, ';', 0xFF1B, '(', 0xFF08, ')', 0xFF09, '{', 0xFF5B, '}', 0xFF5D,
        -: 3978:        '[', 0x300C, ']', 0x300D, '|', 0xFF5C, '!', 0xFF01, '\\', 0xFFE5, '/', 0x30FB, 0xFF0F,
        -: 3979:        '\n', '\r',
        -: 3980:    };
    #####: 3981:    for (unsigned int separator : separator_list)
    %%%%%: 3981-block 2
    %%%%%: 3981-block 5
    %%%%%: 3981-block 6
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3982:        if (c == separator)
    %%%%%: 3982-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3983:            return true;
    %%%%%: 3983-block 4
    #####: 3984:    return false;
    %%%%%: 3984-block 7
        -: 3985:}
        -: 3986:
function _ZN5ImStbL27is_word_boundary_from_rightEP19ImGuiInputTextStatei called 0 returned 0% blocks executed 0%
    #####: 3987:static int is_word_boundary_from_right(ImGuiInputTextState* obj, int idx)
        -: 3988:{
        -: 3989:    // When ImGuiInputTextFlags_Password is set, we don't want actions such as CTRL+Arrow to leak the fact that underlying data are blanks or separators.
    #####: 3990:    if ((obj->Flags & ImGuiInputTextFlags_Password) || idx <= 0)
    %%%%%: 3990-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3990-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3991:        return 0;
    %%%%%: 3991-block 4
        -: 3992:
    #####: 3993:    const char* curr_p = obj->TextA.Data + idx;
    #####: 3994:    const char* prev_p = ImTextFindPreviousUtf8Codepoint(obj->TextA.Data, curr_p);
    %%%%%: 3994-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3995:    unsigned int curr_c; ImTextCharFromUtf8(&curr_c, curr_p, obj->TextA.Data + obj->TextA.Size);
    %%%%%: 3995-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3996:    unsigned int prev_c; ImTextCharFromUtf8(&prev_c, prev_p, obj->TextA.Data + obj->TextA.Size);
    %%%%%: 3996-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 3997:
    #####: 3998:    bool prev_white = ImCharIsBlankW(prev_c);
    %%%%%: 3998-block 8
call    0 never executed
    #####: 3999:    bool prev_separ = ImCharIsSeparatorW(prev_c);
call    0 never executed
    #####: 4000:    bool curr_white = ImCharIsBlankW(curr_c);
call    0 never executed
    #####: 4001:    bool curr_separ = ImCharIsSeparatorW(curr_c);
call    0 never executed
    #####: 4002:    return ((prev_white || prev_separ) && !(curr_separ || curr_white)) || (curr_separ && !prev_separ);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4002-block 13
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4002-block 14
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 4002-block 15
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 4002-block 16
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%: 4002-block 17
branch 10 never executed (fallthrough)
branch 11 never executed
    %%%%%: 4002-block 18
    %%%%%: 4002-block 19
    %%%%%: 4002-block 20
        -: 4003:}
function _ZN5ImStbL26is_word_boundary_from_leftEP19ImGuiInputTextStatei called 0 returned 0% blocks executed 0%
    #####: 4004:static int is_word_boundary_from_left(ImGuiInputTextState* obj, int idx)
        -: 4005:{
    #####: 4006:    if ((obj->Flags & ImGuiInputTextFlags_Password) || idx <= 0)
    %%%%%: 4006-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4006-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4007:        return 0;
    %%%%%: 4007-block 4
        -: 4008:
    #####: 4009:    const char* curr_p = obj->TextA.Data + idx;
    #####: 4010:    const char* prev_p = ImTextFindPreviousUtf8Codepoint(obj->TextA.Data, curr_p);
    %%%%%: 4010-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 4011:    unsigned int prev_c; ImTextCharFromUtf8(&prev_c, curr_p, obj->TextA.Data + obj->TextA.Size);
    %%%%%: 4011-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 4012:    unsigned int curr_c; ImTextCharFromUtf8(&curr_c, prev_p, obj->TextA.Data + obj->TextA.Size);
    %%%%%: 4012-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 4013:
    #####: 4014:    bool prev_white = ImCharIsBlankW(prev_c);
    %%%%%: 4014-block 8
call    0 never executed
    #####: 4015:    bool prev_separ = ImCharIsSeparatorW(prev_c);
call    0 never executed
    #####: 4016:    bool curr_white = ImCharIsBlankW(curr_c);
call    0 never executed
    #####: 4017:    bool curr_separ = ImCharIsSeparatorW(curr_c);
call    0 never executed
    #####: 4018:    return ((prev_white) && !(curr_separ || curr_white)) || (curr_separ && !prev_separ);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4018-block 13
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4018-block 14
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 4018-block 15
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 4018-block 16
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%: 4018-block 17
    %%%%%: 4018-block 18
    %%%%%: 4018-block 19
        -: 4019:}
function _ZN5ImStbL30STB_TEXTEDIT_MOVEWORDLEFT_IMPLEP19ImGuiInputTextStatei called 0 returned 0% blocks executed 0%
    #####: 4020:static int  STB_TEXTEDIT_MOVEWORDLEFT_IMPL(ImGuiInputTextState* obj, int idx)
        -: 4021:{
    #####: 4022:    idx = IMSTB_TEXTEDIT_GETPREVCHARINDEX(obj, idx);
    %%%%%: 4022-block 2
call    0 never executed
    #####: 4023:    while (idx >= 0 && !is_word_boundary_from_right(obj, idx))
    %%%%%: 4023-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4023-block 7
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 4023-block 9
    %%%%%: 4023-block 10
    %%%%%: 4023-block 11
branch  5 never executed
branch  6 never executed (fallthrough)
    #####: 4024:        idx = IMSTB_TEXTEDIT_GETPREVCHARINDEX(obj, idx);
    %%%%%: 4024-block 4
call    0 never executed
    #####: 4025:    return idx < 0 ? 0 : idx;
    %%%%%: 4025-block 12
        -: 4026:}
function _ZN5ImStbL30STB_TEXTEDIT_MOVEWORDRIGHT_MACEP19ImGuiInputTextStatei called 0 returned 0% blocks executed 0%
    #####: 4027:static int  STB_TEXTEDIT_MOVEWORDRIGHT_MAC(ImGuiInputTextState* obj, int idx)
        -: 4028:{
    #####: 4029:    int len = obj->CurLenA;
    #####: 4030:    idx = IMSTB_TEXTEDIT_GETNEXTCHARINDEX(obj, idx);
    %%%%%: 4030-block 2
call    0 never executed
    #####: 4031:    while (idx < len && !is_word_boundary_from_left(obj, idx))
    %%%%%: 4031-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4031-block 7
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 4031-block 9
    %%%%%: 4031-block 10
    %%%%%: 4031-block 11
branch  5 never executed
branch  6 never executed (fallthrough)
    #####: 4032:        idx = IMSTB_TEXTEDIT_GETNEXTCHARINDEX(obj, idx);
    %%%%%: 4032-block 4
call    0 never executed
    #####: 4033:    return idx > len ? len : idx;
    %%%%%: 4033-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4033-block 13
    %%%%%: 4033-block 14
    %%%%%: 4033-block 15
        -: 4034:}
function _ZN5ImStbL30STB_TEXTEDIT_MOVEWORDRIGHT_WINEP19ImGuiInputTextStatei called 0 returned 0% blocks executed 0%
    #####: 4035:static int  STB_TEXTEDIT_MOVEWORDRIGHT_WIN(ImGuiInputTextState* obj, int idx)
        -: 4036:{
    #####: 4037:    idx = IMSTB_TEXTEDIT_GETNEXTCHARINDEX(obj, idx);
    %%%%%: 4037-block 2
call    0 never executed
    #####: 4038:    int len = obj->CurLenA;
    #####: 4039:    while (idx < len && !is_word_boundary_from_right(obj, idx))
    %%%%%: 4039-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4039-block 7
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 4039-block 9
    %%%%%: 4039-block 10
    %%%%%: 4039-block 11
branch  5 never executed
branch  6 never executed (fallthrough)
    #####: 4040:        idx = IMSTB_TEXTEDIT_GETNEXTCHARINDEX(obj, idx);
    %%%%%: 4040-block 4
call    0 never executed
    #####: 4041:    return idx > len ? len : idx;
    %%%%%: 4041-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4041-block 13
    %%%%%: 4041-block 14
    %%%%%: 4041-block 15
        -: 4042:}
function _ZN5ImStbL31STB_TEXTEDIT_MOVEWORDRIGHT_IMPLEP19ImGuiInputTextStatei called 0 returned 0% blocks executed 0%
    #####: 4043:static int  STB_TEXTEDIT_MOVEWORDRIGHT_IMPL(ImGuiInputTextState* obj, int idx)  { ImGuiContext& g = *obj->Ctx; if (g.IO.ConfigMacOSXBehaviors) return STB_TEXTEDIT_MOVEWORDRIGHT_MAC(obj, idx); else return STB_TEXTEDIT_MOVEWORDRIGHT_WIN(obj, idx); }
    %%%%%: 4043-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4043-block 3
call    2 never executed
    %%%%%: 4043-block 5
call    3 never executed
        -: 4044:#define STB_TEXTEDIT_MOVEWORDLEFT       STB_TEXTEDIT_MOVEWORDLEFT_IMPL  // They need to be #define for stb_textedit.h
        -: 4045:#define STB_TEXTEDIT_MOVEWORDRIGHT      STB_TEXTEDIT_MOVEWORDRIGHT_IMPL
        -: 4046:
function _ZN5ImStbL24STB_TEXTEDIT_DELETECHARSEP19ImGuiInputTextStateii called 0 returned 0% blocks executed 0%
    #####: 4047:static void STB_TEXTEDIT_DELETECHARS(ImGuiInputTextState* obj, int pos, int n)
        -: 4048:{
    #####: 4049:    char* dst = obj->TextA.Data + pos;
        -: 4050:
    #####: 4051:    obj->Edited = true;
    #####: 4052:    obj->CurLenA -= n;
        -: 4053:
        -: 4054:    // Offset remaining text (FIXME-OPT: Use memmove)
    #####: 4055:    const char* src = obj->TextA.Data + pos + n;
    %%%%%: 4055-block 2
    #####: 4056:    while (char c = *src++)
    %%%%%: 4056-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4057:        *dst++ = c;
    %%%%%: 4057-block 4
    #####: 4058:    *dst = '\0';
    #####: 4059:}
        -: 4060:
function _ZN5ImStbL24STB_TEXTEDIT_INSERTCHARSEP19ImGuiInputTextStateiPKci called 0 returned 0% blocks executed 0%
    #####: 4061:static bool STB_TEXTEDIT_INSERTCHARS(ImGuiInputTextState* obj, int pos, const char* new_text, int new_text_len)
        -: 4062:{
    #####: 4063:    const bool is_resizable = (obj->Flags & ImGuiInputTextFlags_CallbackResize) != 0;
    #####: 4064:    const int text_len = obj->CurLenA;
    #####: 4065:    IM_ASSERT(pos <= text_len);
    %%%%%: 4065-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4065-block 3
call    2 never executed
        -: 4066:
    #####: 4067:    if (!is_resizable && (new_text_len + obj->CurLenA + 1 > obj->BufCapacityA))
    %%%%%: 4067-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4067-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4068:        return false;
    %%%%%: 4068-block 6
        -: 4069:
        -: 4070:    // Grow internal buffer if needed
    #####: 4071:    if (new_text_len + text_len + 1 > obj->TextA.Size)
    %%%%%: 4071-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4072:    {
    #####: 4073:        if (!is_resizable)
    %%%%%: 4073-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4074:            return false;
    %%%%%: 4074-block 9
    #####: 4075:        obj->TextA.resize(text_len + ImClamp(new_text_len, 32, ImMax(256, new_text_len)) + 1);
    %%%%%: 4075-block 10
call    0 never executed
call    1 never executed
call    2 never executed
        -: 4076:    }
        -: 4077:
    #####: 4078:    char* text = obj->TextA.Data;
    #####: 4079:    if (pos != text_len)
    %%%%%: 4079-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4080:        memmove(text + pos + new_text_len, text + pos, (size_t)(text_len - pos));
    %%%%%: 4080-block 14
    #####: 4081:    memcpy(text + pos, new_text, (size_t)new_text_len);
        -: 4082:
    #####: 4083:    obj->Edited = true;
    #####: 4084:    obj->CurLenA += new_text_len;
    #####: 4085:    obj->TextA[obj->CurLenA] = '\0';
    %%%%%: 4085-block 15
call    0 never executed
        -: 4086:
    #####: 4087:    return true;
        -: 4088:}
        -: 4089:
        -: 4090:// We don't use an enum so we can build even with conflicting symbols (if another user of stb_textedit.h leak their STB_TEXTEDIT_K_* symbols)
        -: 4091:#define STB_TEXTEDIT_K_LEFT         0x200000 // keyboard input to move cursor left
        -: 4092:#define STB_TEXTEDIT_K_RIGHT        0x200001 // keyboard input to move cursor right
        -: 4093:#define STB_TEXTEDIT_K_UP           0x200002 // keyboard input to move cursor up
        -: 4094:#define STB_TEXTEDIT_K_DOWN         0x200003 // keyboard input to move cursor down
        -: 4095:#define STB_TEXTEDIT_K_LINESTART    0x200004 // keyboard input to move cursor to start of line
        -: 4096:#define STB_TEXTEDIT_K_LINEEND      0x200005 // keyboard input to move cursor to end of line
        -: 4097:#define STB_TEXTEDIT_K_TEXTSTART    0x200006 // keyboard input to move cursor to start of text
        -: 4098:#define STB_TEXTEDIT_K_TEXTEND      0x200007 // keyboard input to move cursor to end of text
        -: 4099:#define STB_TEXTEDIT_K_DELETE       0x200008 // keyboard input to delete selection or character under cursor
        -: 4100:#define STB_TEXTEDIT_K_BACKSPACE    0x200009 // keyboard input to delete selection or character left of cursor
        -: 4101:#define STB_TEXTEDIT_K_UNDO         0x20000A // keyboard input to perform undo
        -: 4102:#define STB_TEXTEDIT_K_REDO         0x20000B // keyboard input to perform redo
        -: 4103:#define STB_TEXTEDIT_K_WORDLEFT     0x20000C // keyboard input to move cursor left one word
        -: 4104:#define STB_TEXTEDIT_K_WORDRIGHT    0x20000D // keyboard input to move cursor right one word
        -: 4105:#define STB_TEXTEDIT_K_PGUP         0x20000E // keyboard input to move cursor up a page
        -: 4106:#define STB_TEXTEDIT_K_PGDOWN       0x20000F // keyboard input to move cursor down a page
        -: 4107:#define STB_TEXTEDIT_K_SHIFT        0x400000
        -: 4108:
        -: 4109:#define IMSTB_TEXTEDIT_IMPLEMENTATION
        -: 4110:#define IMSTB_TEXTEDIT_memmove memmove
        -: 4111:#include "imstb_textedit.h"
        -: 4112:
        -: 4113:// stb_textedit internally allows for a single undo record to do addition and deletion, but somehow, calling
        -: 4114:// the stb_textedit_paste() function creates two separate records, so we perform it manually. (FIXME: Report to nothings/stb?)
function _ZN5ImStbL20stb_textedit_replaceEP19ImGuiInputTextStatePNS_17STB_TexteditStateEPKci called 0 returned 0% blocks executed 0%
    #####: 4115:static void stb_textedit_replace(ImGuiInputTextState* str, STB_TexteditState* state, const IMSTB_TEXTEDIT_CHARTYPE* text, int text_len)
        -: 4116:{
    #####: 4117:    stb_text_makeundo_replace(str, state, 0, str->CurLenA, text_len);
    %%%%%: 4117-block 2
call    0 never executed
    #####: 4118:    ImStb::STB_TEXTEDIT_DELETECHARS(str, 0, str->CurLenA);
call    0 never executed
    #####: 4119:    state->cursor = state->select_start = state->select_end = 0;
    #####: 4120:    if (text_len <= 0)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4121:        return;
    %%%%%: 4121-block 5
    #####: 4122:    if (ImStb::STB_TEXTEDIT_INSERTCHARS(str, 0, text, text_len))
    %%%%%: 4122-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -: 4123:    {
    #####: 4124:        state->cursor = state->select_start = state->select_end = text_len;
    #####: 4125:        state->has_preferred_x = 0;
    #####: 4126:        return;
    %%%%%: 4126-block 8
        -: 4127:    }
    #####: 4128:    IM_ASSERT(0); // Failed to insert character, normally shouldn't happen because of how we currently use stb_textedit_replace()
    %%%%%: 4128-block 9
call    0 never executed
        -: 4129:}
        -: 4130:
        -: 4131:} // namespace ImStb
        -: 4132:
        -: 4133:// We added an extra indirection where 'Stb' is heap-allocated, in order facilitate the work of bindings generators.
function _ZN19ImGuiInputTextStateC2Ev called 1 returned 100% blocks executed 62%
        1: 4134:ImGuiInputTextState::ImGuiInputTextState()
        1: 4134-block 2
call    0 returned 1
call    1 returned 1
call    2 returned 1
call    3 returned 1
        -: 4135:{
        1: 4136:    memset(this, 0, sizeof(*this));
        1: 4137:    Stb = IM_NEW(ImStbTexteditState);
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 4137-block 7
call    3 returned 1
        1: 4138:    memset(Stb, 0, sizeof(*Stb));
        1: 4139:}
    $$$$$: 4139-block 9
call    0 never executed
    $$$$$: 4139-block 11
call    1 never executed
    $$$$$: 4139-block 13
call    2 never executed
        -: 4140:
function _ZN19ImGuiInputTextStateD2Ev called 1 returned 100% blocks executed 100%
        1: 4141:ImGuiInputTextState::~ImGuiInputTextState()
        -: 4142:{
        1: 4143:    IM_DELETE(Stb);
        1: 4143-block 2
call    0 returned 1
        1: 4144:}
call    0 returned 1
call    1 returned 1
call    2 returned 1
        -: 4145:
function _ZN19ImGuiInputTextState12OnKeyPressedEi called 0 returned 0% blocks executed 0%
    #####: 4146:void ImGuiInputTextState::OnKeyPressed(int key)
        -: 4147:{
    #####: 4148:    stb_textedit_key(this, Stb, key);
    %%%%%: 4148-block 2
call    0 never executed
    #####: 4149:    CursorFollow = true;
    #####: 4150:    CursorAnimReset();
call    0 never executed
    #####: 4151:}
        -: 4152:
function _ZN19ImGuiInputTextState13OnCharPressedEj called 0 returned 0% blocks executed 0%
    #####: 4153:void ImGuiInputTextState::OnCharPressed(unsigned int c)
        -: 4154:{
        -: 4155:    // Convert the key to a UTF8 byte sequence.
        -: 4156:    // The changes we had to make to stb_textedit_key made it very much UTF-8 specific which is not too great.
        -: 4157:    char utf8[5];
    #####: 4158:    ImTextCharToUtf8(utf8, c);
    %%%%%: 4158-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 4159:    stb_textedit_text(this, Stb, utf8, (int)strlen(utf8));
    %%%%%: 4159-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 4160:    CursorFollow = true;
    #####: 4161:    CursorAnimReset();
    %%%%%: 4161-block 4
call    0 never executed
    #####: 4162:}
        -: 4163:
        -: 4164:// Those functions are not inlined in imgui_internal.h, allowing us to hide ImStbTexteditState from that header.
function _ZN19ImGuiInputTextState15CursorAnimResetEv called 0 returned 0% blocks executed 0%
    #####: 4165:void ImGuiInputTextState::CursorAnimReset()                 { CursorAnim = -0.30f; } // After a user-input the cursor stays on for a while without blinking
function _ZN19ImGuiInputTextState11CursorClampEv called 0 returned 0% blocks executed 0%
    #####: 4166:void ImGuiInputTextState::CursorClamp()                     { Stb->cursor = ImMin(Stb->cursor, CurLenA); Stb->select_start = ImMin(Stb->select_start, CurLenA); Stb->select_end = ImMin(Stb->select_end, CurLenA); }
    %%%%%: 4166-block 2
call    0 never executed
call    1 never executed
call    2 never executed
function _ZNK19ImGuiInputTextState12HasSelectionEv called 0 returned 0% blocks executed 0%
    #####: 4167:bool ImGuiInputTextState::HasSelection() const              { return Stb->select_start != Stb->select_end; }
    %%%%%: 4167-block 2
function _ZN19ImGuiInputTextState14ClearSelectionEv called 0 returned 0% blocks executed 0%
    #####: 4168:void ImGuiInputTextState::ClearSelection()                  { Stb->select_start = Stb->select_end = Stb->cursor; }
function _ZNK19ImGuiInputTextState12GetCursorPosEv called 0 returned 0% blocks executed 0%
    #####: 4169:int  ImGuiInputTextState::GetCursorPos() const              { return Stb->cursor; }
    %%%%%: 4169-block 2
function _ZNK19ImGuiInputTextState17GetSelectionStartEv called 0 returned 0% blocks executed 0%
    #####: 4170:int  ImGuiInputTextState::GetSelectionStart() const         { return Stb->select_start; }
    %%%%%: 4170-block 2
function _ZNK19ImGuiInputTextState15GetSelectionEndEv called 0 returned 0% blocks executed 0%
    #####: 4171:int  ImGuiInputTextState::GetSelectionEnd() const           { return Stb->select_end; }
    %%%%%: 4171-block 2
function _ZN19ImGuiInputTextState9SelectAllEv called 0 returned 0% blocks executed 0%
    #####: 4172:void ImGuiInputTextState::SelectAll()                       { Stb->select_start = 0; Stb->cursor = Stb->select_end = CurLenA; Stb->has_preferred_x = 0; }
function _ZN19ImGuiInputTextState25ReloadUserBufAndSelectAllEv called 0 returned 0% blocks executed 0%
    #####: 4173:void ImGuiInputTextState::ReloadUserBufAndSelectAll()       { ReloadUserBuf = true; ReloadSelectionStart = 0; ReloadSelectionEnd = INT_MAX; }
function _ZN19ImGuiInputTextState29ReloadUserBufAndKeepSelectionEv called 0 returned 0% blocks executed 0%
    #####: 4174:void ImGuiInputTextState::ReloadUserBufAndKeepSelection()   { ReloadUserBuf = true; ReloadSelectionStart = Stb->select_start; ReloadSelectionEnd = Stb->select_end; }
function _ZN19ImGuiInputTextState25ReloadUserBufAndMoveToEndEv called 0 returned 0% blocks executed 0%
    #####: 4175:void ImGuiInputTextState::ReloadUserBufAndMoveToEnd()       { ReloadUserBuf = true; ReloadSelectionStart = ReloadSelectionEnd = INT_MAX; }
        -: 4176:
function _ZN26ImGuiInputTextCallbackDataC2Ev called 0 returned 0% blocks executed 0%
    #####: 4177:ImGuiInputTextCallbackData::ImGuiInputTextCallbackData()
        -: 4178:{
    #####: 4179:    memset(this, 0, sizeof(*this));
    #####: 4180:}
        -: 4181:
        -: 4182:// Public API to manipulate UTF-8 text
        -: 4183:// We expose UTF-8 to the user (unlike the STB_TEXTEDIT_* functions which are manipulating wchar)
        -: 4184:// FIXME: The existence of this rarely exercised code path is a bit of a nuisance.
function _ZN26ImGuiInputTextCallbackData11DeleteCharsEii called 0 returned 0% blocks executed 0%
    #####: 4185:void ImGuiInputTextCallbackData::DeleteChars(int pos, int bytes_count)
        -: 4186:{
    #####: 4187:    IM_ASSERT(pos + bytes_count <= BufTextLen);
    %%%%%: 4187-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4187-block 3
call    2 never executed
    #####: 4188:    char* dst = Buf + pos;
    #####: 4189:    const char* src = Buf + pos + bytes_count;
    %%%%%: 4189-block 4
    #####: 4190:    while (char c = *src++)
    %%%%%: 4190-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4191:        *dst++ = c;
    %%%%%: 4191-block 6
    #####: 4192:    *dst = '\0';
        -: 4193:
    #####: 4194:    if (CursorPos >= pos + bytes_count)
    %%%%%: 4194-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4195:        CursorPos -= bytes_count;
    %%%%%: 4195-block 8
    #####: 4196:    else if (CursorPos >= pos)
    %%%%%: 4196-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4197:        CursorPos = pos;
    %%%%%: 4197-block 10
    #####: 4198:    SelectionStart = SelectionEnd = CursorPos;
    #####: 4199:    BufDirty = true;
    #####: 4200:    BufTextLen -= bytes_count;
    #####: 4201:}
        -: 4202:
function _ZN26ImGuiInputTextCallbackData11InsertCharsEiPKcS1_ called 0 returned 0% blocks executed 0%
    #####: 4203:void ImGuiInputTextCallbackData::InsertChars(int pos, const char* new_text, const char* new_text_end)
        -: 4204:{
        -: 4205:    // Accept null ranges
    #####: 4206:    if (new_text == new_text_end)
    %%%%%: 4206-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4207:        return;
    %%%%%: 4207-block 3
        -: 4208:
    #####: 4209:    const bool is_resizable = (Flags & ImGuiInputTextFlags_CallbackResize) != 0;
    #####: 4210:    const int new_text_len = new_text_end ? (int)(new_text_end - new_text) : (int)strlen(new_text);
    %%%%%: 4210-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4210-block 5
    %%%%%: 4210-block 6
    #####: 4211:    if (new_text_len + BufTextLen >= BufSize)
    %%%%%: 4211-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4212:    {
    #####: 4213:        if (!is_resizable)
    %%%%%: 4213-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4214:            return;
    %%%%%: 4214-block 9
        -: 4215:
        -: 4216:        // Contrary to STB_TEXTEDIT_INSERTCHARS() this is working in the UTF8 buffer, hence the mildly similar code (until we remove the U16 buffer altogether!)
    #####: 4217:        ImGuiContext& g = *Ctx;
    #####: 4218:        ImGuiInputTextState* edit_state = &g.InputTextState;
    #####: 4219:        IM_ASSERT(edit_state->ID != 0 && g.ActiveId == edit_state->ID);
    %%%%%: 4219-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4219-block 11
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4219-block 12
    %%%%%: 4219-block 13
call    4 never executed
    #####: 4220:        IM_ASSERT(Buf == edit_state->TextA.Data);
    %%%%%: 4220-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4220-block 15
call    2 never executed
    #####: 4221:        int new_buf_size = BufTextLen + ImClamp(new_text_len * 4, 32, ImMax(256, new_text_len)) + 1;
    %%%%%: 4221-block 16
call    0 never executed
call    1 never executed
    #####: 4222:        edit_state->TextA.reserve(new_buf_size + 1);
call    0 never executed
    #####: 4223:        Buf = edit_state->TextA.Data;
    #####: 4224:        BufSize = edit_state->BufCapacityA = new_buf_size;
        -: 4225:    }
        -: 4226:
    #####: 4227:    if (BufTextLen != pos)
    %%%%%: 4227-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4228:        memmove(Buf + pos + new_text_len, Buf + pos, (size_t)(BufTextLen - pos));
    %%%%%: 4228-block 21
    #####: 4229:    memcpy(Buf + pos, new_text, (size_t)new_text_len * sizeof(char));
    #####: 4230:    Buf[BufTextLen + new_text_len] = '\0';
        -: 4231:
    #####: 4232:    if (CursorPos >= pos)
    %%%%%: 4232-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4233:        CursorPos += new_text_len;
    %%%%%: 4233-block 23
    #####: 4234:    SelectionStart = SelectionEnd = CursorPos;
    #####: 4235:    BufDirty = true;
    #####: 4236:    BufTextLen += new_text_len;
    %%%%%: 4236-block 24
        -: 4237:}
        -: 4238:
        -: 4239:// Return false to discard a character.
function _ZL24InputTextFilterCharacterP12ImGuiContextPjiPFiP26ImGuiInputTextCallbackDataEPvb called 0 returned 0% blocks executed 0%
    #####: 4240:static bool InputTextFilterCharacter(ImGuiContext* ctx, unsigned int* p_char, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data, bool input_source_is_clipboard)
        -: 4241:{
    #####: 4242:    unsigned int c = *p_char;
        -: 4243:
        -: 4244:    // Filter non-printable (NB: isprint is unreliable! see #2467)
    #####: 4245:    bool apply_named_filters = true;
    #####: 4246:    if (c < 0x20)
    %%%%%: 4246-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4247:    {
    #####: 4248:        bool pass = false;
    #####: 4249:        pass |= (c == '\n') && (flags & ImGuiInputTextFlags_Multiline) != 0; // Note that an Enter KEY will emit \r and be ignored (we poll for KEY in InputText() code)
    %%%%%: 4249-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4249-block 4
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4249-block 5
    %%%%%: 4249-block 6
    #####: 4250:        pass |= (c == '\t') && (flags & ImGuiInputTextFlags_AllowTabInput) != 0;
    %%%%%: 4250-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4250-block 8
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4250-block 9
    %%%%%: 4250-block 10
    #####: 4251:        if (!pass)
    %%%%%: 4251-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4252:            return false;
    %%%%%: 4252-block 12
    #####: 4253:        apply_named_filters = false; // Override named filters below so newline and tabs can still be inserted.
    %%%%%: 4253-block 13
        -: 4254:    }
        -: 4255:
    #####: 4256:    if (input_source_is_clipboard == false)
    %%%%%: 4256-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4257:    {
        -: 4258:        // We ignore Ascii representation of delete (emitted from Backspace on OSX, see #2578, #2817)
    #####: 4259:        if (c == 127)
    %%%%%: 4259-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4260:            return false;
    %%%%%: 4260-block 16
        -: 4261:
        -: 4262:        // Filter private Unicode range. GLFW on OSX seems to send private characters for special keys like arrow keys (FIXME)
    #####: 4263:        if (c >= 0xE000 && c <= 0xF8FF)
    %%%%%: 4263-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4263-block 18
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4264:            return false;
    %%%%%: 4264-block 19
        -: 4265:    }
        -: 4266:
        -: 4267:    // Filter Unicode ranges we are not handling in this build
    #####: 4268:    if (c > IM_UNICODE_CODEPOINT_MAX)
    %%%%%: 4268-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4269:        return false;
    %%%%%: 4269-block 21
        -: 4270:
        -: 4271:    // Generic named filters
    #####: 4272:    if (apply_named_filters && (flags & (ImGuiInputTextFlags_CharsDecimal | ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsUppercase | ImGuiInputTextFlags_CharsNoBlank | ImGuiInputTextFlags_CharsScientific | (ImGuiInputTextFlags)ImGuiInputTextFlags_LocalizeDecimalPoint)))
    %%%%%: 4272-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4272-block 23
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 4273:    {
        -: 4274:        // The libc allows overriding locale, with e.g. 'setlocale(LC_NUMERIC, "de_DE.UTF-8");' which affect the output/input of printf/scanf to use e.g. ',' instead of '.'.
        -: 4275:        // The standard mandate that programs starts in the "C" locale where the decimal point is '.'.
        -: 4276:        // We don't really intend to provide widespread support for it, but out of empathy for people stuck with using odd API, we support the bare minimum aka overriding the decimal point.
        -: 4277:        // Change the default decimal_point with:
        -: 4278:        //   ImGui::GetPlatformIO()->Platform_LocaleDecimalPoint = *localeconv()->decimal_point;
        -: 4279:        // Users of non-default decimal point (in particular ',') may be affected by word-selection logic (is_word_boundary_from_right/is_word_boundary_from_left) functions.
    #####: 4280:        ImGuiContext& g = *ctx;
    #####: 4281:        const unsigned c_decimal_point = (unsigned int)g.PlatformIO.Platform_LocaleDecimalPoint;
    #####: 4282:        if (flags & (ImGuiInputTextFlags_CharsDecimal | ImGuiInputTextFlags_CharsScientific | (ImGuiInputTextFlags)ImGuiInputTextFlags_LocalizeDecimalPoint))
    %%%%%: 4282-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4283:            if (c == '.' || c == ',')
    %%%%%: 4283-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4283-block 26
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4284:                c = c_decimal_point;
    %%%%%: 4284-block 27
        -: 4285:
        -: 4286:        // Full-width -> half-width conversion for numeric fields (https://en.wikipedia.org/wiki/Halfwidth_and_Fullwidth_Forms_(Unicode_block)
        -: 4287:        // While this is mostly convenient, this has the side-effect for uninformed users accidentally inputting full-width characters that they may
        -: 4288:        // scratch their head as to why it works in numerical fields vs in generic text fields it would require support in the font.
    #####: 4289:        if (flags & (ImGuiInputTextFlags_CharsDecimal | ImGuiInputTextFlags_CharsScientific | ImGuiInputTextFlags_CharsHexadecimal))
    %%%%%: 4289-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4290:            if (c >= 0xFF01 && c <= 0xFF5E)
    %%%%%: 4290-block 29
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4290-block 30
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4291:                c = c - 0xFF01 + 0x21;
    %%%%%: 4291-block 31
        -: 4292:
        -: 4293:        // Allow 0-9 . - + * /
    #####: 4294:        if (flags & ImGuiInputTextFlags_CharsDecimal)
    %%%%%: 4294-block 32
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4295:            if (!(c >= '0' && c <= '9') && (c != c_decimal_point) && (c != '-') && (c != '+') && (c != '*') && (c != '/'))
    %%%%%: 4295-block 33
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4295-block 34
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4295-block 35
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 4295-block 36
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 4295-block 37
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%: 4295-block 38
branch 10 never executed (fallthrough)
branch 11 never executed
    %%%%%: 4295-block 39
branch 12 never executed (fallthrough)
branch 13 never executed
    #####: 4296:                return false;
    %%%%%: 4296-block 40
        -: 4297:
        -: 4298:        // Allow 0-9 . - + * / e E
    #####: 4299:        if (flags & ImGuiInputTextFlags_CharsScientific)
    %%%%%: 4299-block 41
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4300:            if (!(c >= '0' && c <= '9') && (c != c_decimal_point) && (c != '-') && (c != '+') && (c != '*') && (c != '/') && (c != 'e') && (c != 'E'))
    %%%%%: 4300-block 42
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4300-block 43
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4300-block 44
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 4300-block 45
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 4300-block 46
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%: 4300-block 47
branch 10 never executed (fallthrough)
branch 11 never executed
    %%%%%: 4300-block 48
branch 12 never executed (fallthrough)
branch 13 never executed
    %%%%%: 4300-block 49
branch 14 never executed (fallthrough)
branch 15 never executed
    %%%%%: 4300-block 50
branch 16 never executed (fallthrough)
branch 17 never executed
    #####: 4301:                return false;
    %%%%%: 4301-block 51
        -: 4302:
        -: 4303:        // Allow 0-9 a-F A-F
    #####: 4304:        if (flags & ImGuiInputTextFlags_CharsHexadecimal)
    %%%%%: 4304-block 52
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4305:            if (!(c >= '0' && c <= '9') && !(c >= 'a' && c <= 'f') && !(c >= 'A' && c <= 'F'))
    %%%%%: 4305-block 53
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4305-block 54
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4305-block 55
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 4305-block 56
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 4305-block 57
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%: 4305-block 58
branch 10 never executed (fallthrough)
branch 11 never executed
    #####: 4306:                return false;
    %%%%%: 4306-block 59
        -: 4307:
        -: 4308:        // Turn a-z into A-Z
    #####: 4309:        if (flags & ImGuiInputTextFlags_CharsUppercase)
    %%%%%: 4309-block 60
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4310:            if (c >= 'a' && c <= 'z')
    %%%%%: 4310-block 61
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4310-block 62
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4311:                c += (unsigned int)('A' - 'a');
    %%%%%: 4311-block 63
        -: 4312:
    #####: 4313:        if (flags & ImGuiInputTextFlags_CharsNoBlank)
    %%%%%: 4313-block 64
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4314:            if (ImCharIsBlankW(c))
    %%%%%: 4314-block 65
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 4315:                return false;
    %%%%%: 4315-block 67
        -: 4316:
    #####: 4317:        *p_char = c;
    %%%%%: 4317-block 68
        -: 4318:    }
        -: 4319:
        -: 4320:    // Custom callback filter
    #####: 4321:    if (flags & ImGuiInputTextFlags_CallbackCharFilter)
    %%%%%: 4321-block 69
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4322:    {
    #####: 4323:        ImGuiContext& g = *GImGui;
    #####: 4324:        ImGuiInputTextCallbackData callback_data;
    %%%%%: 4324-block 70
call    0 never executed
    #####: 4325:        callback_data.Ctx = &g;
    #####: 4326:        callback_data.EventFlag = ImGuiInputTextFlags_CallbackCharFilter;
    #####: 4327:        callback_data.EventChar = (ImWchar)c;
    #####: 4328:        callback_data.Flags = flags;
    #####: 4329:        callback_data.UserData = user_data;
    #####: 4330:        if (callback(&callback_data) != 0)
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 4330-block 72
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 4331:            return false;
    %%%%%: 4331-block 73
    %%%%%: 4331-block 77
    #####: 4332:        *p_char = callback_data.EventChar;
    #####: 4333:        if (!callback_data.EventChar)
    %%%%%: 4333-block 74
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4334:            return false;
    %%%%%: 4334-block 75
        -: 4335:    }
        -: 4336:
    #####: 4337:    return true;
    %%%%%: 4337-block 78
        -: 4338:}
        -: 4339:
        -: 4340:// Find the shortest single replacement we can make to get the new text from the old text.
        -: 4341:// Important: needs to be run before TextW is rewritten with the new characters because calling STB_TEXTEDIT_GETCHAR() at the end.
        -: 4342:// FIXME: Ideally we should transition toward (1) making InsertChars()/DeleteChars() update undo-stack (2) discourage (and keep reconcile) or obsolete (and remove reconcile) accessing buffer directly.
function _ZL44InputTextReconcileUndoStateAfterUserCallbackP19ImGuiInputTextStatePKci called 0 returned 0% blocks executed 0%
    #####: 4343:static void InputTextReconcileUndoStateAfterUserCallback(ImGuiInputTextState* state, const char* new_buf_a, int new_length_a)
        -: 4344:{
    #####: 4345:    const char* old_buf = state->CallbackTextBackup.Data;
    #####: 4346:    const int old_length = state->CallbackTextBackup.Size - 1;
        -: 4347:
    #####: 4348:    const int shorter_length = ImMin(old_length, new_length_a);
    %%%%%: 4348-block 2
call    0 never executed
        -: 4349:    int first_diff;
    #####: 4350:    for (first_diff = 0; first_diff < shorter_length; first_diff++)
    %%%%%: 4350-block 6
    %%%%%: 4350-block 7
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4351:        if (old_buf[first_diff] != new_buf_a[first_diff])
    %%%%%: 4351-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4352:            break;
    %%%%%: 4352-block 5
    #####: 4353:    if (first_diff == old_length && first_diff == new_length_a)
    %%%%%: 4353-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4353-block 9
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4354:        return;
    %%%%%: 4354-block 10
        -: 4355:
    #####: 4356:    int old_last_diff = old_length   - 1;
    #####: 4357:    int new_last_diff = new_length_a - 1;
    #####: 4358:    for (; old_last_diff >= first_diff && new_last_diff >= first_diff; old_last_diff--, new_last_diff--)
    %%%%%: 4358-block 11
    %%%%%: 4358-block 14
    %%%%%: 4358-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4358-block 16
branch  2 never executed
branch  3 never executed (fallthrough)
    #####: 4359:        if (old_buf[old_last_diff] != new_buf_a[new_last_diff])
    %%%%%: 4359-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4360:            break;
    %%%%%: 4360-block 13
        -: 4361:
    #####: 4362:    const int insert_len = new_last_diff - first_diff + 1;
    #####: 4363:    const int delete_len = old_last_diff - first_diff + 1;
    #####: 4364:    if (insert_len > 0 || delete_len > 0)
    %%%%%: 4364-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4364-block 18
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4365:        if (IMSTB_TEXTEDIT_CHARTYPE* p = stb_text_createundo(&state->Stb->undostate, first_diff, delete_len, insert_len))
    %%%%%: 4365-block 19
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 4366:            for (int i = 0; i < delete_len; i++)
    %%%%%: 4366-block 21
    %%%%%: 4366-block 23
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4367:                p[i] = old_buf[first_diff + i];
    %%%%%: 4367-block 22
        -: 4368:}
        -: 4369:
        -: 4370:// As InputText() retain textual data and we currently provide a path for user to not retain it (via local variables)
        -: 4371:// we need some form of hook to reapply data back to user buffer on deactivation frame. (#4714)
        -: 4372:// It would be more desirable that we discourage users from taking advantage of the "user not retaining data" trick,
        -: 4373:// but that more likely be attractive when we do have _NoLiveEdit flag available.
function _ZN5ImGui23InputTextDeactivateHookEj called 0 returned 0% blocks executed 0%
    #####: 4374:void ImGui::InputTextDeactivateHook(ImGuiID id)
        -: 4375:{
    #####: 4376:    ImGuiContext& g = *GImGui;
    #####: 4377:    ImGuiInputTextState* state = &g.InputTextState;
    #####: 4378:    if (id == 0 || state->ID != id)
    %%%%%: 4378-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4378-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4379:        return;
    %%%%%: 4379-block 4
    #####: 4380:    g.InputTextDeactivatedState.ID = state->ID;
    #####: 4381:    if (state->Flags & ImGuiInputTextFlags_ReadOnly)
    %%%%%: 4381-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4382:    {
    #####: 4383:        g.InputTextDeactivatedState.TextA.resize(0); // In theory this data won't be used, but clear to be neat.
    %%%%%: 4383-block 6
call    0 never executed
        -: 4384:    }
        -: 4385:    else
        -: 4386:    {
    #####: 4387:        IM_ASSERT(state->TextA.Data != 0);
    %%%%%: 4387-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4387-block 8
call    2 never executed
    #####: 4388:        g.InputTextDeactivatedState.TextA.resize(state->CurLenA + 1);
    %%%%%: 4388-block 9
call    0 never executed
    #####: 4389:        memcpy(g.InputTextDeactivatedState.TextA.Data, state->TextA.Data, state->CurLenA + 1);
        -: 4390:    }
        -: 4391:}
        -: 4392:
        -: 4393:// Edit a string of text
        -: 4394:// - buf_size account for the zero-terminator, so a buf_size of 6 can hold "Hello" but not "Hello!".
        -: 4395://   This is so we can easily call InputText() on static arrays using ARRAYSIZE() and to match
        -: 4396://   Note that in std::string world, capacity() would omit 1 byte used by the zero-terminator.
        -: 4397:// - When active, hold on a privately held copy of the text (and apply back to 'buf'). So changing 'buf' while the InputText is active has no effect.
        -: 4398:// - If you want to use ImGui::InputText() with std::string, see misc/cpp/imgui_stdlib.h
        -: 4399:// (FIXME: Rather confusing and messy function, among the worse part of our codebase, expecting to rewrite a V2 at some point.. Partly because we are
        -: 4400://  doing UTF8 > U16 > UTF8 conversions on the go to easily interface with stb_textedit. Ideally should stay in UTF-8 all the time. See https://github.com/nothings/stb/issues/188)
function _ZN5ImGui11InputTextExEPKcS1_PciRK6ImVec2iPFiP26ImGuiInputTextCallbackDataEPv called 29079 returned 100% blocks executed 13%
    29079: 4401:bool ImGui::InputTextEx(const char* label, const char* hint, char* buf, int buf_size, const ImVec2& size_arg, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* callback_user_data)
        -: 4402:{
    29079: 4403:    ImGuiWindow* window = GetCurrentWindow();
    29079: 4403-block 2
call    0 returned 29079
    29079: 4404:    if (window->SkipItems)
branch  0 taken 0 (fallthrough)
branch  1 taken 29079
    #####: 4405:        return false;
    %%%%%: 4405-block 4
        -: 4406:
   29079*: 4407:    IM_ASSERT(buf != NULL && buf_size >= 0);
    29079: 4407-block 5
branch  0 taken 29079 (fallthrough)
branch  1 taken 0
    29079: 4407-block 6
branch  2 taken 29079 (fallthrough)
branch  3 taken 0
    29079: 4407-block 7
    %%%%%: 4407-block 8
call    4 never executed
   29079*: 4408:    IM_ASSERT(!((flags & ImGuiInputTextFlags_CallbackHistory) && (flags & ImGuiInputTextFlags_Multiline)));        // Can't use both together (they both use up/down keys)
    29079: 4408-block 9
branch  0 taken 0 (fallthrough)
branch  1 taken 29079
    %%%%%: 4408-block 10
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4408-block 11
call    4 never executed
   29079*: 4409:    IM_ASSERT(!((flags & ImGuiInputTextFlags_CallbackCompletion) && (flags & ImGuiInputTextFlags_AllowTabInput))); // Can't use both together (they both use tab key)
    29079: 4409-block 12
branch  0 taken 0 (fallthrough)
branch  1 taken 29079
    %%%%%: 4409-block 13
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4409-block 14
call    4 never executed
        -: 4410:
    29079: 4411:    ImGuiContext& g = *GImGui;
    29079: 4412:    ImGuiIO& io = g.IO;
    29079: 4413:    const ImGuiStyle& style = g.Style;
        -: 4414:
    29079: 4415:    const bool RENDER_SELECTION_WHEN_INACTIVE = false;
    29079: 4416:    const bool is_multiline = (flags & ImGuiInputTextFlags_Multiline) != 0;
        -: 4417:
    29079: 4418:    if (is_multiline) // Open group before calling GetID() because groups tracks id created within their scope (including the scrollbar)
    29079: 4418-block 15
branch  0 taken 0 (fallthrough)
branch  1 taken 29079
    #####: 4419:        BeginGroup();
    %%%%%: 4419-block 16
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    29079: 4420:    const ImGuiID id = window->GetID(label);
    29079: 4420-block 17
call    0 returned 29079
branch  1 taken 29079 (fallthrough)
branch  2 taken 0 (throw)
    29079: 4421:    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    29079: 4421-block 18
call    0 returned 29079
branch  1 taken 29079 (fallthrough)
branch  2 taken 0 (throw)
   29079*: 4422:    const ImVec2 frame_size = CalcItemSize(size_arg, CalcItemWidth(), (is_multiline ? g.FontSize * 8.0f : label_size.y) + style.FramePadding.y * 2.0f); // Arbitrary default of 8 lines high for multi-line
    29079: 4422-block 19
branch  0 taken 0 (fallthrough)
branch  1 taken 29079
    %%%%%: 4422-block 20
    29079: 4422-block 21
    29079: 4422-block 22
call    2 returned 29079
branch  3 taken 29079 (fallthrough)
branch  4 taken 0 (throw)
    29079: 4422-block 23
call    5 returned 29079
branch  6 taken 29079 (fallthrough)
branch  7 taken 0 (throw)
   29079*: 4423:    const ImVec2 total_size = ImVec2(frame_size.x + (label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f), frame_size.y);
    29079: 4423-block 24
branch  0 taken 0 (fallthrough)
branch  1 taken 29079
    %%%%%: 4423-block 25
    29079: 4423-block 26
    29079: 4423-block 27
call    2 returned 29079
        -: 4424:
    29079: 4425:    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + frame_size);
call    0 returned 29079
call    1 returned 29079
    29079: 4426:    const ImRect total_bb(frame_bb.Min, frame_bb.Min + total_size);
call    0 returned 29079
call    1 returned 29079
        -: 4427:
    29079: 4428:    ImGuiWindow* draw_window = window;
    29079: 4429:    ImVec2 inner_size = frame_size;
    29079: 4430:    ImGuiLastItemData item_data_backup;
call    0 returned 29079
    29079: 4431:    if (is_multiline)
branch  0 taken 0 (fallthrough)
branch  1 taken 29079
        -: 4432:    {
    #####: 4433:        ImVec2 backup_pos = window->DC.CursorPos;
    #####: 4434:        ItemSize(total_bb, style.FramePadding.y);
    %%%%%: 4434-block 34
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 4435:        if (!ItemAdd(total_bb, id, &frame_bb, ImGuiItemFlags_Inputable))
    %%%%%: 4435-block 35
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 4435-block 36
branch  3 never executed (fallthrough)
branch  4 never executed
        -: 4436:        {
    #####: 4437:            EndGroup();
    %%%%%: 4437-block 37
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 4438:            return false;
    %%%%%: 4438-block 38
    %%%%%: 4438-block 60
        -: 4439:        }
    #####: 4440:        item_data_backup = g.LastItemData;
    #####: 4441:        window->DC.CursorPos = backup_pos;
        -: 4442:
        -: 4443:        // Prevent NavActivation from Tabbing when our widget accepts Tab inputs: this allows cycling through widgets without stopping.
    #####: 4444:        if (g.NavActivateId == id && (g.NavActivateFlags & ImGuiActivateFlags_FromTabbing) && (flags & ImGuiInputTextFlags_AllowTabInput))
    %%%%%: 4444-block 39
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4444-block 40
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4444-block 41
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 4445:            g.NavActivateId = 0;
    %%%%%: 4445-block 42
        -: 4446:
        -: 4447:        // Prevent NavActivate reactivating in BeginChild() when we are already active.
    #####: 4448:        const ImGuiID backup_activate_id = g.NavActivateId;
    #####: 4449:        if (g.ActiveId == id) // Prevent reactivation
    %%%%%: 4449-block 43
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4450:            g.NavActivateId = 0;
    %%%%%: 4450-block 44
        -: 4451:
        -: 4452:        // We reproduce the contents of BeginChildFrame() in order to provide 'label' so our window internal data are easier to read/debug.
    #####: 4453:        PushStyleColor(ImGuiCol_ChildBg, style.Colors[ImGuiCol_FrameBg]);
    %%%%%: 4453-block 45
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 4454:        PushStyleVar(ImGuiStyleVar_ChildRounding, style.FrameRounding);
    %%%%%: 4454-block 46
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 4455:        PushStyleVar(ImGuiStyleVar_ChildBorderSize, style.FrameBorderSize);
    %%%%%: 4455-block 47
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 4456:        PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0, 0)); // Ensure no clip rect so mouse hover can reach FramePadding edges
    %%%%%: 4456-block 48
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$: 4456-block 906
    #####: 4457:        bool child_visible = BeginChildEx(label, id, frame_bb.GetSize(), ImGuiChildFlags_Borders, ImGuiWindowFlags_NoMove);
    %%%%%: 4457-block 50
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$: 4457-block 907
    #####: 4458:        g.NavActivateId = backup_activate_id;
    #####: 4459:        PopStyleVar(3);
    %%%%%: 4459-block 52
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 4460:        PopStyleColor();
    %%%%%: 4460-block 53
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 4461:        if (!child_visible)
    %%%%%: 4461-block 54
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4462:        {
    #####: 4463:            EndChild();
    %%%%%: 4463-block 55
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 4464:            EndGroup();
    %%%%%: 4464-block 56
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 4465:            return false;
    %%%%%: 4465-block 57
        -: 4466:        }
    #####: 4467:        draw_window = g.CurrentWindow; // Child window
    #####: 4468:        draw_window->DC.NavLayersActiveMaskNext |= (1 << draw_window->DC.NavLayerCurrent); // This is to ensure that EndChild() will display a navigation highlight so we can "enter" into it.
    #####: 4469:        draw_window->DC.CursorPos += style.FramePadding;
    %%%%%: 4469-block 58
call    0 never executed
    #####: 4470:        inner_size.x -= draw_window->ScrollbarSizes.x;
        -: 4471:    }
        -: 4472:    else
        -: 4473:    {
        -: 4474:        // Support for internal ImGuiInputTextFlags_MergedItem flag, which could be redesigned as an ItemFlags if needed (with test performed in ItemAdd)
    29079: 4475:        ItemSize(total_bb, style.FramePadding.y);
    29079: 4475-block 61
call    0 returned 29079
branch  1 taken 29079 (fallthrough)
branch  2 taken 0 (throw)
    29079: 4476:        if (!(flags & ImGuiInputTextFlags_MergedItem))
    29079: 4476-block 62
branch  0 taken 29079 (fallthrough)
branch  1 taken 0
    29079: 4477:            if (!ItemAdd(total_bb, id, &frame_bb, ImGuiItemFlags_Inputable))
    29079: 4477-block 63
call    0 returned 29079
branch  1 taken 29079 (fallthrough)
branch  2 taken 0 (throw)
    29079: 4477-block 64
branch  3 taken 1102 (fallthrough)
branch  4 taken 27977
     1102: 4478:                return false;
     1102: 4478-block 65
        -: 4479:    }
        -: 4480:
        -: 4481:    // Ensure mouse cursor is set even after switching to keyboard/gamepad mode. May generalize further? (#6417)
    27977: 4482:    bool hovered = ItemHoverable(frame_bb, id, g.LastItemData.ItemFlags | ImGuiItemFlags_NoNavDisableMouseHover);
    27977: 4482-block 66
call    0 returned 27977
branch  1 taken 27977 (fallthrough)
branch  2 taken 0 (throw)
    27977: 4483:    if (hovered)
    27977: 4483-block 67
branch  0 taken 0 (fallthrough)
branch  1 taken 27977
    #####: 4484:        SetMouseCursor(ImGuiMouseCursor_TextInput);
    %%%%%: 4484-block 68
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
   27977*: 4485:    if (hovered && g.NavHighlightItemUnderNav)
    27977: 4485-block 69
branch  0 taken 0 (fallthrough)
branch  1 taken 27977
    %%%%%: 4485-block 70
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4486:        hovered = false;
    %%%%%: 4486-block 71
        -: 4487:
        -: 4488:    // We are only allowed to access the state if we are already the active widget.
    27977: 4489:    ImGuiInputTextState* state = GetInputTextState(id);
    27977: 4489-block 72
call    0 returned 27977
        -: 4490:
    27977: 4491:    if (g.LastItemData.ItemFlags & ImGuiItemFlags_ReadOnly)
branch  0 taken 0 (fallthrough)
branch  1 taken 27977
    #####: 4492:        flags |= ImGuiInputTextFlags_ReadOnly;
    %%%%%: 4492-block 74
    27977: 4493:    const bool is_readonly = (flags & ImGuiInputTextFlags_ReadOnly) != 0;
    27977: 4494:    const bool is_password = (flags & ImGuiInputTextFlags_Password) != 0;
    27977: 4495:    const bool is_undoable = (flags & ImGuiInputTextFlags_NoUndoRedo) == 0;
    27977: 4496:    const bool is_resizable = (flags & ImGuiInputTextFlags_CallbackResize) != 0;
    27977: 4497:    if (is_resizable)
    27977: 4497-block 75
branch  0 taken 0 (fallthrough)
branch  1 taken 27977
    #####: 4498:        IM_ASSERT(callback != NULL); // Must provide a callback if you set the ImGuiInputTextFlags_CallbackResize flag!
    %%%%%: 4498-block 76
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4498-block 77
call    2 never executed
        -: 4499:
   27977*: 4500:    const bool input_requested_by_nav = (g.ActiveId != id) && ((g.NavActivateId == id) && ((g.NavActivateFlags & ImGuiActivateFlags_PreferInput) || (g.NavInputSource == ImGuiInputSource_Keyboard)));
    27977: 4500-block 78
branch  0 taken 27977 (fallthrough)
branch  1 taken 0
    27977: 4500-block 79
branch  2 taken 0 (fallthrough)
branch  3 taken 27977
    %%%%%: 4500-block 80
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 4500-block 81
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 4500-block 82
    27977: 4500-block 83
        -: 4501:
   27977*: 4502:    const bool user_clicked = hovered && io.MouseClicked[0];
    27977: 4502-block 84
branch  0 taken 0 (fallthrough)
branch  1 taken 27977
    %%%%%: 4502-block 85
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4502-block 86
    27977: 4502-block 87
   27977*: 4503:    const bool user_scroll_finish = is_multiline && state != NULL && g.ActiveId == 0 && g.ActiveIdPreviousFrame == GetWindowScrollbarID(draw_window, ImGuiAxis_Y);
    27977: 4503-block 88
branch  0 taken 0 (fallthrough)
branch  1 taken 27977
    %%%%%: 4503-block 89
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4503-block 90
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 4503-block 91
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed (throw)
    %%%%%: 4503-block 92
branch  9 never executed (fallthrough)
branch 10 never executed
    %%%%%: 4503-block 93
    27977: 4503-block 94
   27977*: 4504:    const bool user_scroll_active = is_multiline && state != NULL && g.ActiveId == GetWindowScrollbarID(draw_window, ImGuiAxis_Y);
    27977: 4504-block 95
branch  0 taken 0 (fallthrough)
branch  1 taken 27977
    %%%%%: 4504-block 96
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4504-block 97
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    %%%%%: 4504-block 98
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 4504-block 99
    27977: 4504-block 100
    27977: 4505:    bool clear_active_id = false;
    27977: 4506:    bool select_all = false;
        -: 4507:
   27977*: 4508:    float scroll_y = is_multiline ? draw_window->Scroll.y : FLT_MAX;
    27977: 4508-block 101
branch  0 taken 0 (fallthrough)
branch  1 taken 27977
    %%%%%: 4508-block 102
    27977: 4508-block 103
        -: 4509:
   27977*: 4510:    const bool init_reload_from_user_buf = (state != NULL && state->ReloadUserBuf);
    27977: 4510-block 104
branch  0 taken 0 (fallthrough)
branch  1 taken 27977
    %%%%%: 4510-block 105
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4510-block 106
    27977: 4510-block 107
   27977*: 4511:    const bool init_changed_specs = (state != NULL && state->Stb->single_line != !is_multiline); // state != NULL means its our state.
    27977: 4511-block 108
branch  0 taken 0 (fallthrough)
branch  1 taken 27977
    %%%%%: 4511-block 109
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4511-block 110
    27977: 4511-block 111
   27977*: 4512:    const bool init_make_active = (user_clicked || user_scroll_finish || input_requested_by_nav);
    27977: 4512-block 112
branch  0 taken 27977 (fallthrough)
branch  1 taken 0
    27977: 4512-block 113
branch  2 taken 27977 (fallthrough)
branch  3 taken 0
    27977: 4512-block 114
branch  4 taken 0 (fallthrough)
branch  5 taken 27977
    %%%%%: 4512-block 115
    27977: 4512-block 116
   27977*: 4513:    const bool init_state = (init_make_active || user_scroll_active);
    27977: 4513-block 117
branch  0 taken 27977 (fallthrough)
branch  1 taken 0
    27977: 4513-block 118
branch  2 taken 0 (fallthrough)
branch  3 taken 27977
    %%%%%: 4513-block 119
    27977: 4513-block 120
   27977*: 4514:    if ((init_state && g.ActiveId != id) || init_changed_specs || init_reload_from_user_buf)
    27977: 4514-block 121
branch  0 taken 0 (fallthrough)
branch  1 taken 27977
    %%%%%: 4514-block 122
branch  2 never executed (fallthrough)
branch  3 never executed
    27977: 4514-block 123
branch  4 taken 27977 (fallthrough)
branch  5 taken 0
    27977: 4514-block 124
branch  6 taken 0 (fallthrough)
branch  7 taken 27977
        -: 4515:    {
        -: 4516:        // Access state even if we don't own it yet.
    #####: 4517:        state = &g.InputTextState;
    #####: 4518:        state->CursorAnimReset();
    %%%%%: 4518-block 125
call    0 never executed
    #####: 4519:        state->ReloadUserBuf = false;
        -: 4520:
        -: 4521:        // Backup state of deactivating item so they'll have a chance to do a write to output buffer on the same frame they report IsItemDeactivatedAfterEdit (#4714)
    #####: 4522:        InputTextDeactivateHook(state->ID);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 4523:
        -: 4524:        // From the moment we focused we are normally ignoring the content of 'buf' (unless we are in read-only mode)
    #####: 4525:        const int buf_len = (int)strlen(buf);
    #####: 4526:        if (!init_reload_from_user_buf)
    %%%%%: 4526-block 127
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4527:        {
        -: 4528:            // Take a copy of the initial buffer value.
    #####: 4529:            state->InitialTextA.resize(buf_len + 1);    // UTF-8. we use +1 to make sure that .Data is always pointing to at least an empty string.
    %%%%%: 4529-block 128
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 4530:            memcpy(state->InitialTextA.Data, buf, buf_len + 1);
    %%%%%: 4530-block 129
        -: 4531:        }
        -: 4532:
        -: 4533:        // Preserve cursor position and undo/redo stack if we come back to same widget
        -: 4534:        // FIXME: Since we reworked this on 2022/06, may want to differentiate recycle_cursor vs recycle_undostate?
    #####: 4535:        bool recycle_state = (state->ID == id && !init_changed_specs && !init_reload_from_user_buf);
    %%%%%: 4535-block 130
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4535-block 131
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4535-block 132
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 4535-block 133
    %%%%%: 4535-block 134
    #####: 4536:        if (recycle_state && (state->CurLenA != buf_len || (strncmp(state->TextA.Data, buf, buf_len) != 0)))
    %%%%%: 4536-block 135
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4536-block 136
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4536-block 137
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 4537:            recycle_state = false;
    %%%%%: 4537-block 138
        -: 4538:
        -: 4539:        // Start edition
    #####: 4540:        state->ID = id;
    #####: 4541:        state->TextA.resize(buf_size + 1);          // we use +1 to make sure that .Data is always pointing to at least an empty string.
    %%%%%: 4541-block 139
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 4542:        state->CurLenA = (int)strlen(buf);
    #####: 4543:        memcpy(state->TextA.Data, buf, state->CurLenA + 1);
        -: 4544:
    #####: 4545:        if (recycle_state)
    %%%%%: 4545-block 140
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4546:        {
        -: 4547:            // Recycle existing cursor/selection/undo stack but clamp position
        -: 4548:            // Note a single mouse click will override the cursor/position immediately by calling stb_textedit_click handler.
    #####: 4549:            state->CursorClamp();
    %%%%%: 4549-block 141
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 4550:        }
        -: 4551:        else
        -: 4552:        {
    #####: 4553:            state->Scroll = ImVec2(0.0f, 0.0f);
    %%%%%: 4553-block 142
call    0 never executed
    #####: 4554:            stb_textedit_initialize_state(state->Stb, !is_multiline);
call    0 never executed
        -: 4555:        }
        -: 4556:
    #####: 4557:        if (init_reload_from_user_buf)
    %%%%%: 4557-block 144
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4558:        {
    #####: 4559:            state->Stb->select_start = state->ReloadSelectionStart;
    #####: 4560:            state->Stb->cursor = state->Stb->select_end = state->ReloadSelectionEnd;
    #####: 4561:            state->CursorClamp();
    %%%%%: 4561-block 145
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 4562:        }
    #####: 4563:        else if (!is_multiline)
    %%%%%: 4563-block 146
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4564:        {
    #####: 4565:            if (flags & ImGuiInputTextFlags_AutoSelectAll)
    %%%%%: 4565-block 147
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4566:                select_all = true;
    %%%%%: 4566-block 148
    #####: 4567:            if (input_requested_by_nav && (!recycle_state || !(g.NavActivateFlags & ImGuiActivateFlags_TryToPreserveState)))
    %%%%%: 4567-block 149
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4567-block 150
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4567-block 151
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 4568:                select_all = true;
    %%%%%: 4568-block 152
    #####: 4569:            if (user_clicked && io.KeyCtrl)
    %%%%%: 4569-block 153
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4569-block 154
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4570:                select_all = true;
    %%%%%: 4570-block 155
        -: 4571:        }
        -: 4572:
    #####: 4573:        if (flags & ImGuiInputTextFlags_AlwaysOverwrite)
    %%%%%: 4573-block 156
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4574:            state->Stb->insert_mode = 1; // stb field name is indeed incorrect (see #2863)
    %%%%%: 4574-block 157
        -: 4575:    }
        -: 4576:
    27977: 4577:    const bool is_osx = io.ConfigMacOSXBehaviors;
    27977: 4578:    if (g.ActiveId != id && init_make_active)
    27977: 4578-block 158
branch  0 taken 27977 (fallthrough)
branch  1 taken 0
    27977: 4578-block 159
branch  2 taken 0 (fallthrough)
branch  3 taken 27977
        -: 4579:    {
    #####: 4580:        IM_ASSERT(state && state->ID == id);
    %%%%%: 4580-block 160
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4580-block 161
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4580-block 162
    %%%%%: 4580-block 163
call    4 never executed
    #####: 4581:        SetActiveID(id, window);
    %%%%%: 4581-block 164
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 4582:        SetFocusID(id, window);
    %%%%%: 4582-block 165
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 4583:        FocusWindow(window);
    %%%%%: 4583-block 166
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 4584:    }
    27977: 4585:    if (g.ActiveId == id)
    27977: 4585-block 167
branch  0 taken 0 (fallthrough)
branch  1 taken 27977
        -: 4586:    {
        -: 4587:        // Declare some inputs, the other are registered and polled via Shortcut() routing system.
        -: 4588:        // FIXME: The reason we don't use Shortcut() is we would need a routing flag to specify multiple mods, or to all mods combinaison into individual shortcuts.
    #####: 4589:        const ImGuiKey always_owned_keys[] = { ImGuiKey_LeftArrow, ImGuiKey_RightArrow, ImGuiKey_Enter, ImGuiKey_KeypadEnter, ImGuiKey_Delete, ImGuiKey_Backspace, ImGuiKey_Home, ImGuiKey_End };
    #####: 4590:        for (ImGuiKey key : always_owned_keys)
    %%%%%: 4590-block 168
    %%%%%: 4590-block 170
    %%%%%: 4590-block 171
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4591:            SetKeyOwner(key, id);
    %%%%%: 4591-block 169
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 4592:        if (user_clicked)
    %%%%%: 4592-block 172
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4593:            SetKeyOwner(ImGuiKey_MouseLeft, id);
    %%%%%: 4593-block 173
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 4594:        g.ActiveIdUsingNavDirMask |= (1 << ImGuiDir_Left) | (1 << ImGuiDir_Right);
    #####: 4595:        if (is_multiline || (flags & ImGuiInputTextFlags_CallbackHistory))
    %%%%%: 4595-block 174
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4595-block 175
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 4596:        {
    #####: 4597:            g.ActiveIdUsingNavDirMask |= (1 << ImGuiDir_Up) | (1 << ImGuiDir_Down);
    #####: 4598:            SetKeyOwner(ImGuiKey_UpArrow, id);
    %%%%%: 4598-block 176
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 4599:            SetKeyOwner(ImGuiKey_DownArrow, id);
    %%%%%: 4599-block 177
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 4600:        }
    #####: 4601:        if (is_multiline)
    %%%%%: 4601-block 178
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4602:        {
    #####: 4603:            SetKeyOwner(ImGuiKey_PageUp, id);
    %%%%%: 4603-block 179
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 4604:            SetKeyOwner(ImGuiKey_PageDown, id);
    %%%%%: 4604-block 180
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 4605:        }
        -: 4606:        // FIXME: May be a problem to always steal Alt on OSX, would ideally still allow an uninterrupted Alt down-up to toggle menu
    #####: 4607:        if (is_osx)
    %%%%%: 4607-block 181
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4608:            SetKeyOwner(ImGuiMod_Alt, id);
    %%%%%: 4608-block 182
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 4609:
        -: 4610:        // Expose scroll in a manner that is agnostic to us using a child window
    #####: 4611:        if (is_multiline && state != NULL)
    %%%%%: 4611-block 183
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4611-block 184
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4612:            state->Scroll.y = draw_window->Scroll.y;
    %%%%%: 4612-block 185
        -: 4613:    }
        -: 4614:
        -: 4615:    // We have an edge case if ActiveId was set through another widget (e.g. widget being swapped), clear id immediately (don't wait until the end of the function)
   27977*: 4616:    if (g.ActiveId == id && state == NULL)
    27977: 4616-block 187
branch  0 taken 0 (fallthrough)
branch  1 taken 27977
    %%%%%: 4616-block 188
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4617:        ClearActiveID();
    %%%%%: 4617-block 189
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 4618:
        -: 4619:    // Release focus when we click outside
   27977*: 4620:    if (g.ActiveId == id && io.MouseClicked[0] && !init_state && !init_make_active) //-V560
    27977: 4620-block 190
branch  0 taken 0 (fallthrough)
branch  1 taken 27977
    %%%%%: 4620-block 191
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4620-block 192
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 4620-block 193
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 4621:        clear_active_id = true;
    %%%%%: 4621-block 194
        -: 4622:
        -: 4623:    // Lock the decision of whether we are going to take the path displaying the cursor or selection
   27977*: 4624:    bool render_cursor = (g.ActiveId == id) || (state && user_scroll_active);
    27977: 4624-block 195
branch  0 taken 27977 (fallthrough)
branch  1 taken 0
    27977: 4624-block 196
branch  2 taken 0 (fallthrough)
branch  3 taken 27977
    %%%%%: 4624-block 197
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 4624-block 198
    27977: 4624-block 199
   27977*: 4625:    bool render_selection = state && (state->HasSelection() || select_all) && (RENDER_SELECTION_WHEN_INACTIVE || render_cursor);
    27977: 4625-block 200
branch  0 taken 0 (fallthrough)
branch  1 taken 27977
    %%%%%: 4625-block 201
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 4625-block 203
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 4625-block 204
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 4625-block 205
    27977: 4625-block 206
    27977: 4626:    bool value_changed = false;
    27977: 4627:    bool validated = false;
        -: 4628:
        -: 4629:    // Select the buffer to render.
   27977*: 4630:    const bool buf_display_from_state = (render_cursor || render_selection || g.ActiveId == id) && !is_readonly && state;
    27977: 4630-block 207
branch  0 taken 27977 (fallthrough)
branch  1 taken 0
    27977: 4630-block 208
branch  2 taken 27977 (fallthrough)
branch  3 taken 0
    27977: 4630-block 209
branch  4 taken 0 (fallthrough)
branch  5 taken 27977
    %%%%%: 4630-block 210
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 4630-block 211
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%: 4630-block 212
    27977: 4630-block 213
   27977*: 4631:    const bool is_displaying_hint = (hint != NULL && (buf_display_from_state ? state->TextA.Data : buf)[0] == 0);
    27977: 4631-block 214
branch  0 taken 0 (fallthrough)
branch  1 taken 27977
    %%%%%: 4631-block 215
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4631-block 216
    %%%%%: 4631-block 217
    %%%%%: 4631-block 218
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 4631-block 219
    27977: 4631-block 220
        -: 4632:
        -: 4633:    // Password pushes a temporary font with only a fallback glyph
   27977*: 4634:    if (is_password && !is_displaying_hint)
    27977: 4634-block 221
branch  0 taken 0 (fallthrough)
branch  1 taken 27977
    %%%%%: 4634-block 222
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 4635:    {
    #####: 4636:        const ImFontGlyph* glyph = g.Font->FindGlyph('*');
    %%%%%: 4636-block 223
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 4637:        ImFont* password_font = &g.InputTextPasswordFont;
    #####: 4638:        password_font->FontSize = g.Font->FontSize;
    #####: 4639:        password_font->Scale = g.Font->Scale;
    #####: 4640:        password_font->Ascent = g.Font->Ascent;
    #####: 4641:        password_font->Descent = g.Font->Descent;
    #####: 4642:        password_font->ContainerAtlas = g.Font->ContainerAtlas;
    #####: 4643:        password_font->FallbackGlyph = glyph;
    #####: 4644:        password_font->FallbackAdvanceX = glyph->AdvanceX;
    #####: 4645:        IM_ASSERT(password_font->Glyphs.empty() && password_font->IndexAdvanceX.empty() && password_font->IndexLookup.empty());
    %%%%%: 4645-block 224
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 4645-block 226
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 4645-block 228
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 4645-block 230
    %%%%%: 4645-block 231
call    9 never executed
    #####: 4646:        PushFont(password_font);
    %%%%%: 4646-block 232
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 4647:    }
        -: 4648:
        -: 4649:    // Process mouse inputs and character inputs
    27977: 4650:    if (g.ActiveId == id)
    27977: 4650-block 233
branch  0 taken 0 (fallthrough)
branch  1 taken 27977
        -: 4651:    {
    #####: 4652:        IM_ASSERT(state != NULL);
    %%%%%: 4652-block 234
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4652-block 235
call    2 never executed
    #####: 4653:        state->Edited = false;
    #####: 4654:        state->BufCapacityA = buf_size;
    #####: 4655:        state->Flags = flags;
        -: 4656:
        -: 4657:        // Although we are active we don't prevent mouse from hovering other elements unless we are interacting right now with the widget.
        -: 4658:        // Down the line we should have a cleaner library-wide concept of Selected vs Active.
    #####: 4659:        g.ActiveIdAllowOverlap = !io.MouseDown[0];
        -: 4660:
        -: 4661:        // Edit in progress
    #####: 4662:        const float mouse_x = (io.MousePos.x - frame_bb.Min.x - style.FramePadding.x) + state->Scroll.x;
    #####: 4663:        const float mouse_y = (is_multiline ? (io.MousePos.y - draw_window->DC.CursorPos.y) : (g.FontSize * 0.5f));
    %%%%%: 4663-block 236
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4663-block 237
    %%%%%: 4663-block 238
        -: 4664:
    #####: 4665:        if (select_all)
    %%%%%: 4665-block 239
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4666:        {
    #####: 4667:            state->SelectAll();
    %%%%%: 4667-block 240
call    0 never executed
    #####: 4668:            state->SelectedAllMouseLock = true;
        -: 4669:        }
    #####: 4670:        else if (hovered && io.MouseClickedCount[0] >= 2 && !io.KeyShift)
    %%%%%: 4670-block 242
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4670-block 243
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4670-block 244
branch  4 never executed (fallthrough)
branch  5 never executed
        -: 4671:        {
    #####: 4672:            stb_textedit_click(state, state->Stb, mouse_x, mouse_y);
    %%%%%: 4672-block 245
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 4673:            const int multiclick_count = (io.MouseClickedCount[0] - 2);
    #####: 4674:            if ((multiclick_count % 2) == 0)
    %%%%%: 4674-block 246
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4675:            {
        -: 4676:                // Double-click: Select word
        -: 4677:                // We always use the "Mac" word advance for double-click select vs CTRL+Right which use the platform dependent variant:
        -: 4678:                // FIXME: There are likely many ways to improve this behavior, but there's no "right" behavior (depends on use-case, software, OS)
    #####: 4679:                const bool is_bol = (state->Stb->cursor == 0) || ImStb::STB_TEXTEDIT_GETCHAR(state, state->Stb->cursor - 1) == '\n';
    %%%%%: 4679-block 247
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4679-block 248
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 4679-block 249
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 4679-block 250
    %%%%%: 4679-block 251
    #####: 4680:                if (STB_TEXT_HAS_SELECTION(state->Stb) || !is_bol)
    %%%%%: 4680-block 252
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4680-block 253
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4681:                    state->OnKeyPressed(STB_TEXTEDIT_K_WORDLEFT);
    %%%%%: 4681-block 254
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 4682:                //state->OnKeyPressed(STB_TEXTEDIT_K_WORDRIGHT | STB_TEXTEDIT_K_SHIFT);
    #####: 4683:                if (!STB_TEXT_HAS_SELECTION(state->Stb))
    %%%%%: 4683-block 255
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4684:                    ImStb::stb_textedit_prep_selection_at_cursor(state->Stb);
    %%%%%: 4684-block 256
call    0 never executed
    #####: 4685:                state->Stb->cursor = ImStb::STB_TEXTEDIT_MOVEWORDRIGHT_MAC(state, state->Stb->cursor);
    %%%%%: 4685-block 257
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 4686:                state->Stb->select_end = state->Stb->cursor;
    #####: 4687:                ImStb::stb_textedit_clamp(state, state->Stb);
    %%%%%: 4687-block 258
call    0 never executed
        -: 4688:            }
        -: 4689:            else
        -: 4690:            {
        -: 4691:                // Triple-click: Select line
    #####: 4692:                const bool is_eol = ImStb::STB_TEXTEDIT_GETCHAR(state, state->Stb->cursor) == '\n';
    %%%%%: 4692-block 259
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 4693:                state->OnKeyPressed(STB_TEXTEDIT_K_LINESTART);
    %%%%%: 4693-block 260
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 4694:                state->OnKeyPressed(STB_TEXTEDIT_K_LINEEND | STB_TEXTEDIT_K_SHIFT);
    %%%%%: 4694-block 261
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 4695:                state->OnKeyPressed(STB_TEXTEDIT_K_RIGHT | STB_TEXTEDIT_K_SHIFT);
    %%%%%: 4695-block 262
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 4696:                if (!is_eol && is_multiline)
    %%%%%: 4696-block 263
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4696-block 264
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 4697:                {
    #####: 4698:                    ImSwap(state->Stb->select_start, state->Stb->select_end);
    %%%%%: 4698-block 265
call    0 never executed
    #####: 4699:                    state->Stb->cursor = state->Stb->select_end;
        -: 4700:                }
    #####: 4701:                state->CursorFollow = false;
    %%%%%: 4701-block 267
        -: 4702:            }
    #####: 4703:            state->CursorAnimReset();
    %%%%%: 4703-block 268
call    0 never executed
    #####: 4704:        }
    #####: 4705:        else if (io.MouseClicked[0] && !state->SelectedAllMouseLock)
    %%%%%: 4705-block 270
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4705-block 271
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 4706:        {
    #####: 4707:            if (hovered)
    %%%%%: 4707-block 272
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4708:            {
    #####: 4709:                if (io.KeyShift)
    %%%%%: 4709-block 273
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4710:                    stb_textedit_drag(state, state->Stb, mouse_x, mouse_y);
    %%%%%: 4710-block 274
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 4711:                else
    #####: 4712:                    stb_textedit_click(state, state->Stb, mouse_x, mouse_y);
    %%%%%: 4712-block 275
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 4713:                state->CursorAnimReset();
    %%%%%: 4713-block 276
call    0 never executed
        -: 4714:            }
        -: 4715:        }
    #####: 4716:        else if (io.MouseDown[0] && !state->SelectedAllMouseLock && (io.MouseDelta.x != 0.0f || io.MouseDelta.y != 0.0f))
    %%%%%: 4716-block 278
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4716-block 279
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4716-block 280
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 4716-block 281
branch  6 never executed (fallthrough)
branch  7 never executed
        -: 4717:        {
    #####: 4718:            stb_textedit_drag(state, state->Stb, mouse_x, mouse_y);
    %%%%%: 4718-block 282
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 4719:            state->CursorAnimReset();
    %%%%%: 4719-block 283
call    0 never executed
    #####: 4720:            state->CursorFollow = true;
        -: 4721:        }
    #####: 4722:        if (state->SelectedAllMouseLock && !io.MouseDown[0])
    %%%%%: 4722-block 285
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4722-block 286
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4723:            state->SelectedAllMouseLock = false;
    %%%%%: 4723-block 287
        -: 4724:
        -: 4725:        // We expect backends to emit a Tab key but some also emit a Tab character which we ignore (#2467, #1336)
        -: 4726:        // (For Tab and Enter: Win32/SFML/Allegro are sending both keys and chars, GLFW and SDL are only sending keys. For Space they all send all threes)
    #####: 4727:        if ((flags & ImGuiInputTextFlags_AllowTabInput) && !is_readonly)
    %%%%%: 4727-block 288
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4727-block 289
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 4728:        {
    #####: 4729:            if (Shortcut(ImGuiKey_Tab, ImGuiInputFlags_Repeat, id))
    %%%%%: 4729-block 290
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 4729-block 291
branch  3 never executed (fallthrough)
branch  4 never executed
        -: 4730:            {
    #####: 4731:                unsigned int c = '\t'; // Insert TAB
    #####: 4732:                if (InputTextFilterCharacter(&g, &c, flags, callback, callback_user_data))
    %%%%%: 4732-block 292
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 4732-block 293
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 4733:                    state->OnCharPressed(c);
    %%%%%: 4733-block 294
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 4734:            }
        -: 4735:            // FIXME: Implement Shift+Tab
        -: 4736:            /*
        -: 4737:            if (Shortcut(ImGuiKey_Tab | ImGuiMod_Shift, ImGuiInputFlags_Repeat, id))
        -: 4738:            {
        -: 4739:            }
        -: 4740:            */
        -: 4741:        }
        -: 4742:
        -: 4743:        // Process regular text input (before we check for Return because using some IME will effectively send a Return?)
        -: 4744:        // We ignore CTRL inputs, but need to allow ALT+CTRL as some keyboards (e.g. German) use AltGR (which _is_ Alt+Ctrl) to input certain characters.
    #####: 4745:        const bool ignore_char_inputs = (io.KeyCtrl && !io.KeyAlt) || (is_osx && io.KeyCtrl);
    %%%%%: 4745-block 296
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4745-block 297
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4745-block 298
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 4745-block 299
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 4745-block 300
    %%%%%: 4745-block 301
    #####: 4746:        if (io.InputQueueCharacters.Size > 0)
    %%%%%: 4746-block 302
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4747:        {
    #####: 4748:            if (!ignore_char_inputs && !is_readonly && !input_requested_by_nav)
    %%%%%: 4748-block 303
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4748-block 304
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4748-block 305
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 4749:                for (int n = 0; n < io.InputQueueCharacters.Size; n++)
    %%%%%: 4749-block 306
    %%%%%: 4749-block 314
    %%%%%: 4749-block 315
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 4750:                {
        -: 4751:                    // Insert character if they pass filtering
    #####: 4752:                    unsigned int c = (unsigned int)io.InputQueueCharacters[n];
    %%%%%: 4752-block 307
call    0 never executed
    #####: 4753:                    if (c == '\t') // Skip Tab, see above.
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4754:                        continue;
    %%%%%: 4754-block 309
    #####: 4755:                    if (InputTextFilterCharacter(&g, &c, flags, callback, callback_user_data))
    %%%%%: 4755-block 310
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 4755-block 311
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 4756:                        state->OnCharPressed(c);
    %%%%%: 4756-block 312
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 4757:                }
        -: 4758:
        -: 4759:            // Consume characters
    #####: 4760:            io.InputQueueCharacters.resize(0);
    %%%%%: 4760-block 316
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 4761:        }
        -: 4762:    }
        -: 4763:
        -: 4764:    // Process other shortcuts/key-presses
    27977: 4765:    bool revert_edit = false;
   27977*: 4766:    if (g.ActiveId == id && !g.ActiveIdIsJustActivated && !clear_active_id)
    27977: 4766-block 317
branch  0 taken 0 (fallthrough)
branch  1 taken 27977
    %%%%%: 4766-block 318
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4766-block 319
branch  4 never executed (fallthrough)
branch  5 never executed
        -: 4767:    {
    #####: 4768:        IM_ASSERT(state != NULL);
    %%%%%: 4768-block 320
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4768-block 321
call    2 never executed
        -: 4769:
    #####: 4770:        const int row_count_per_page = ImMax((int)((inner_size.y - style.FramePadding.y) / g.FontSize), 1);
    %%%%%: 4770-block 322
call    0 never executed
    #####: 4771:        state->Stb->row_count_per_page = row_count_per_page;
        -: 4772:
    #####: 4773:        const int k_mask = (io.KeyShift ? STB_TEXTEDIT_K_SHIFT : 0);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4773-block 324
    %%%%%: 4773-block 325
    #####: 4774:        const bool is_wordmove_key_down = is_osx ? io.KeyAlt : io.KeyCtrl;                     // OS X style: Text editing cursor movement using Alt instead of Ctrl
    %%%%%: 4774-block 326
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4774-block 327
    %%%%%: 4774-block 328
    #####: 4775:        const bool is_startend_key_down = is_osx && io.KeyCtrl && !io.KeySuper && !io.KeyAlt;  // OS X style: Line/Text Start and End using Cmd+Arrows instead of Home/End
    %%%%%: 4775-block 329
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4775-block 330
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4775-block 331
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 4775-block 332
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 4775-block 333
    %%%%%: 4775-block 334
        -: 4776:
        -: 4777:        // Using Shortcut() with ImGuiInputFlags_RouteFocused (default policy) to allow routing operations for other code (e.g. calling window trying to use CTRL+A and CTRL+B: formet would be handled by InputText)
        -: 4778:        // Otherwise we could simply assume that we own the keys as we are active.
    #####: 4779:        const ImGuiInputFlags f_repeat = ImGuiInputFlags_Repeat;
    #####: 4780:        const bool is_cut   = (Shortcut(ImGuiMod_Ctrl | ImGuiKey_X, f_repeat, id) || Shortcut(ImGuiMod_Shift | ImGuiKey_Delete, f_repeat, id)) && !is_readonly && !is_password && (!is_multiline || state->HasSelection());
    %%%%%: 4780-block 335
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 4780-block 336
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 4780-block 337
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
    %%%%%: 4780-block 338
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%: 4780-block 339
branch 10 never executed (fallthrough)
branch 11 never executed
    %%%%%: 4780-block 340
branch 12 never executed (fallthrough)
branch 13 never executed
    %%%%%: 4780-block 341
branch 14 never executed (fallthrough)
branch 15 never executed
    %%%%%: 4780-block 342
call   16 never executed
branch 17 never executed (fallthrough)
branch 18 never executed
    %%%%%: 4780-block 344
    %%%%%: 4780-block 345
    #####: 4781:        const bool is_copy  = (Shortcut(ImGuiMod_Ctrl | ImGuiKey_C, 0,        id) || Shortcut(ImGuiMod_Ctrl  | ImGuiKey_Insert, 0,        id)) && !is_password && (!is_multiline || state->HasSelection());
    %%%%%: 4781-block 346
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 4781-block 347
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 4781-block 348
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
    %%%%%: 4781-block 349
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%: 4781-block 350
branch 10 never executed (fallthrough)
branch 11 never executed
    %%%%%: 4781-block 351
branch 12 never executed (fallthrough)
branch 13 never executed
    %%%%%: 4781-block 352
call   14 never executed
branch 15 never executed (fallthrough)
branch 16 never executed
    %%%%%: 4781-block 354
    %%%%%: 4781-block 355
    #####: 4782:        const bool is_paste = (Shortcut(ImGuiMod_Ctrl | ImGuiKey_V, f_repeat, id) || Shortcut(ImGuiMod_Shift | ImGuiKey_Insert, f_repeat, id)) && !is_readonly;
    %%%%%: 4782-block 356
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 4782-block 357
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 4782-block 358
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
    %%%%%: 4782-block 359
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%: 4782-block 360
branch 10 never executed (fallthrough)
branch 11 never executed
    %%%%%: 4782-block 361
    %%%%%: 4782-block 362
    #####: 4783:        const bool is_undo  = (Shortcut(ImGuiMod_Ctrl | ImGuiKey_Z, f_repeat, id)) && !is_readonly && is_undoable;
    %%%%%: 4783-block 363
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 4783-block 364
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 4783-block 365
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 4783-block 366
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 4783-block 367
    %%%%%: 4783-block 368
    #####: 4784:        const bool is_redo =  (Shortcut(ImGuiMod_Ctrl | ImGuiKey_Y, f_repeat, id) || (is_osx && Shortcut(ImGuiMod_Ctrl | ImGuiMod_Shift | ImGuiKey_Z, f_repeat, id))) && !is_readonly && is_undoable;
    %%%%%: 4784-block 369
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 4784-block 370
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 4784-block 371
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 4784-block 372
call    7 never executed
branch  8 never executed (fallthrough)
branch  9 never executed (throw)
    %%%%%: 4784-block 373
branch 10 never executed (fallthrough)
branch 11 never executed
    %%%%%: 4784-block 374
branch 12 never executed (fallthrough)
branch 13 never executed
    %%%%%: 4784-block 375
branch 14 never executed (fallthrough)
branch 15 never executed
    %%%%%: 4784-block 376
    %%%%%: 4784-block 377
    #####: 4785:        const bool is_select_all = Shortcut(ImGuiMod_Ctrl | ImGuiKey_A, 0, id);
    %%%%%: 4785-block 378
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 4786:
        -: 4787:        // We allow validate/cancel with Nav source (gamepad) to makes it easier to undo an accidental NavInput press with no keyboard wired, but otherwise it isn't very useful.
    #####: 4788:        const bool nav_gamepad_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (io.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
    %%%%%: 4788-block 379
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4788-block 380
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4788-block 381
    %%%%%: 4788-block 382
    #####: 4789:        const bool is_enter_pressed = IsKeyPressed(ImGuiKey_Enter, true) || IsKeyPressed(ImGuiKey_KeypadEnter, true);
    %%%%%: 4789-block 383
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 4789-block 384
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 4789-block 385
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
    %%%%%: 4789-block 386
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%: 4789-block 387
    %%%%%: 4789-block 388
    #####: 4790:        const bool is_gamepad_validate = nav_gamepad_active && (IsKeyPressed(ImGuiKey_NavGamepadActivate, false) || IsKeyPressed(ImGuiKey_NavGamepadInput, false));
    %%%%%: 4790-block 389
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4790-block 390
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4790-block 391
    %%%%%: 4790-block 392
    %%%%%: 4790-block 393
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    %%%%%: 4790-block 394
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 4790-block 395
call    9 never executed
branch 10 never executed (fallthrough)
branch 11 never executed (throw)
    %%%%%: 4790-block 396
branch 12 never executed (fallthrough)
branch 13 never executed
    %%%%%: 4790-block 397
    %%%%%: 4790-block 398
    #####: 4791:        const bool is_cancel = Shortcut(ImGuiKey_Escape, f_repeat, id) || (nav_gamepad_active && Shortcut(ImGuiKey_NavGamepadCancel, f_repeat, id));
    %%%%%: 4791-block 399
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 4791-block 400
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 4791-block 401
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 4791-block 402
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 4791-block 403
    %%%%%: 4791-block 404
    %%%%%: 4791-block 405
call    9 never executed
branch 10 never executed (fallthrough)
branch 11 never executed (throw)
    %%%%%: 4791-block 406
branch 12 never executed (fallthrough)
branch 13 never executed
    %%%%%: 4791-block 407
    %%%%%: 4791-block 408
        -: 4792:
        -: 4793:        // FIXME: Should use more Shortcut() and reduce IsKeyPressed()+SetKeyOwner(), but requires modifiers combination to be taken account of.
        -: 4794:        // FIXME-OSX: Missing support for Alt(option)+Right/Left = go to end of line, or next line if already in end of line.
    #####: 4795:        if (IsKeyPressed(ImGuiKey_LeftArrow))                        { state->OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_LINESTART : is_wordmove_key_down ? STB_TEXTEDIT_K_WORDLEFT : STB_TEXTEDIT_K_LEFT) | k_mask); }
    %%%%%: 4795-block 409
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 4795-block 410
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 4795-block 411
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 4795-block 412
    %%%%%: 4795-block 413
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 4795-block 414
    %%%%%: 4795-block 415
    %%%%%: 4795-block 416
    %%%%%: 4795-block 417
call    9 never executed
branch 10 never executed (fallthrough)
branch 11 never executed (throw)
    #####: 4796:        else if (IsKeyPressed(ImGuiKey_RightArrow))                  { state->OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_LINEEND : is_wordmove_key_down ? STB_TEXTEDIT_K_WORDRIGHT : STB_TEXTEDIT_K_RIGHT) | k_mask); }
    %%%%%: 4796-block 418
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 4796-block 419
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 4796-block 420
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 4796-block 421
    %%%%%: 4796-block 422
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 4796-block 423
    %%%%%: 4796-block 424
    %%%%%: 4796-block 425
    %%%%%: 4796-block 426
call    9 never executed
branch 10 never executed (fallthrough)
branch 11 never executed (throw)
    #####: 4797:        else if (IsKeyPressed(ImGuiKey_UpArrow) && is_multiline)     { if (io.KeyCtrl) SetScrollY(draw_window, ImMax(draw_window->Scroll.y - g.FontSize, 0.0f)); else state->OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_TEXTSTART : STB_TEXTEDIT_K_UP) | k_mask); }
    %%%%%: 4797-block 427
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 4797-block 428
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 4797-block 429
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 4797-block 430
    %%%%%: 4797-block 431
    %%%%%: 4797-block 432
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 4797-block 433
branch  9 never executed (fallthrough)
branch 10 never executed
    %%%%%: 4797-block 434
call   11 never executed
call   12 never executed
branch 13 never executed (fallthrough)
branch 14 never executed (throw)
    %%%%%: 4797-block 436
branch 15 never executed (fallthrough)
branch 16 never executed
    %%%%%: 4797-block 437
    %%%%%: 4797-block 438
    %%%%%: 4797-block 439
call   17 never executed
branch 18 never executed (fallthrough)
branch 19 never executed (throw)
    #####: 4798:        else if (IsKeyPressed(ImGuiKey_DownArrow) && is_multiline)   { if (io.KeyCtrl) SetScrollY(draw_window, ImMin(draw_window->Scroll.y + g.FontSize, GetScrollMaxY())); else state->OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_TEXTEND : STB_TEXTEDIT_K_DOWN) | k_mask); }
    %%%%%: 4798-block 440
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 4798-block 441
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 4798-block 442
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 4798-block 443
    %%%%%: 4798-block 444
    %%%%%: 4798-block 445
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 4798-block 446
branch  9 never executed (fallthrough)
branch 10 never executed
    %%%%%: 4798-block 447
call   11 never executed
branch 12 never executed (fallthrough)
branch 13 never executed (throw)
    %%%%%: 4798-block 448
call   14 never executed
call   15 never executed
branch 16 never executed (fallthrough)
branch 17 never executed (throw)
    %%%%%: 4798-block 450
branch 18 never executed (fallthrough)
branch 19 never executed
    %%%%%: 4798-block 451
    %%%%%: 4798-block 452
    %%%%%: 4798-block 453
call   20 never executed
branch 21 never executed (fallthrough)
branch 22 never executed (throw)
    #####: 4799:        else if (IsKeyPressed(ImGuiKey_PageUp) && is_multiline)      { state->OnKeyPressed(STB_TEXTEDIT_K_PGUP | k_mask); scroll_y -= row_count_per_page * g.FontSize; }
    %%%%%: 4799-block 454
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 4799-block 455
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 4799-block 456
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 4799-block 457
    %%%%%: 4799-block 458
    %%%%%: 4799-block 459
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 4799-block 460
call    9 never executed
branch 10 never executed (fallthrough)
branch 11 never executed (throw)
    %%%%%: 4799-block 461
    #####: 4800:        else if (IsKeyPressed(ImGuiKey_PageDown) && is_multiline)    { state->OnKeyPressed(STB_TEXTEDIT_K_PGDOWN | k_mask); scroll_y += row_count_per_page * g.FontSize; }
    %%%%%: 4800-block 462
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 4800-block 463
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 4800-block 464
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 4800-block 465
    %%%%%: 4800-block 466
    %%%%%: 4800-block 467
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 4800-block 468
call    9 never executed
branch 10 never executed (fallthrough)
branch 11 never executed (throw)
    %%%%%: 4800-block 469
    #####: 4801:        else if (IsKeyPressed(ImGuiKey_Home))                        { state->OnKeyPressed(io.KeyCtrl ? STB_TEXTEDIT_K_TEXTSTART | k_mask : STB_TEXTEDIT_K_LINESTART | k_mask); }
    %%%%%: 4801-block 470
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 4801-block 471
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 4801-block 472
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 4801-block 473
    %%%%%: 4801-block 474
    %%%%%: 4801-block 475
call    7 never executed
branch  8 never executed (fallthrough)
branch  9 never executed (throw)
    #####: 4802:        else if (IsKeyPressed(ImGuiKey_End))                         { state->OnKeyPressed(io.KeyCtrl ? STB_TEXTEDIT_K_TEXTEND | k_mask : STB_TEXTEDIT_K_LINEEND | k_mask); }
    %%%%%: 4802-block 476
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 4802-block 477
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 4802-block 478
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 4802-block 479
    %%%%%: 4802-block 480
    %%%%%: 4802-block 481
call    7 never executed
branch  8 never executed (fallthrough)
branch  9 never executed (throw)
    #####: 4803:        else if (IsKeyPressed(ImGuiKey_Delete) && !is_readonly && !is_cut)
    %%%%%: 4803-block 482
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 4803-block 483
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 4803-block 484
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 4803-block 485
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 4803-block 486
    %%%%%: 4803-block 487
    %%%%%: 4803-block 488
branch  9 never executed (fallthrough)
branch 10 never executed
        -: 4804:        {
    #####: 4805:            if (!state->HasSelection())
    %%%%%: 4805-block 489
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -: 4806:            {
        -: 4807:                // OSX doesn't seem to have Super+Delete to delete until end-of-line, so we don't emulate that (as opposed to Super+Backspace)
    #####: 4808:                if (is_wordmove_key_down)
    %%%%%: 4808-block 491
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4809:                    state->OnKeyPressed(STB_TEXTEDIT_K_WORDRIGHT | STB_TEXTEDIT_K_SHIFT);
    %%%%%: 4809-block 492
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 4810:            }
    #####: 4811:            state->OnKeyPressed(STB_TEXTEDIT_K_DELETE | k_mask);
    %%%%%: 4811-block 493
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 4812:        }
    #####: 4813:        else if (IsKeyPressed(ImGuiKey_Backspace) && !is_readonly)
    %%%%%: 4813-block 494
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 4813-block 495
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 4813-block 496
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 4813-block 497
    %%%%%: 4813-block 498
    %%%%%: 4813-block 499
branch  7 never executed (fallthrough)
branch  8 never executed
        -: 4814:        {
    #####: 4815:            if (!state->HasSelection())
    %%%%%: 4815-block 500
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -: 4816:            {
    #####: 4817:                if (is_wordmove_key_down)
    %%%%%: 4817-block 502
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4818:                    state->OnKeyPressed(STB_TEXTEDIT_K_WORDLEFT | STB_TEXTEDIT_K_SHIFT);
    %%%%%: 4818-block 503
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 4819:                else if (is_osx && io.KeyCtrl && !io.KeyAlt && !io.KeySuper)
    %%%%%: 4819-block 504
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4819-block 505
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4819-block 506
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 4819-block 507
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 4820:                    state->OnKeyPressed(STB_TEXTEDIT_K_LINESTART | STB_TEXTEDIT_K_SHIFT);
    %%%%%: 4820-block 508
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 4821:            }
    #####: 4822:            state->OnKeyPressed(STB_TEXTEDIT_K_BACKSPACE | k_mask);
    %%%%%: 4822-block 509
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 4823:        }
    #####: 4824:        else if (is_enter_pressed || is_gamepad_validate)
    %%%%%: 4824-block 510
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4824-block 511
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 4825:        {
        -: 4826:            // Determine if we turn Enter into a \n character
    #####: 4827:            bool ctrl_enter_for_new_line = (flags & ImGuiInputTextFlags_CtrlEnterForNewLine) != 0;
    #####: 4828:            if (!is_multiline || is_gamepad_validate || (ctrl_enter_for_new_line && !io.KeyCtrl) || (!ctrl_enter_for_new_line && io.KeyCtrl))
    %%%%%: 4828-block 512
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4828-block 513
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4828-block 514
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 4828-block 515
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 4828-block 516
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%: 4828-block 517
branch 10 never executed (fallthrough)
branch 11 never executed
        -: 4829:            {
    #####: 4830:                validated = true;
    #####: 4831:                if (io.ConfigInputTextEnterKeepActive && !is_multiline)
    %%%%%: 4831-block 518
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4831-block 519
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4832:                    state->SelectAll(); // No need to scroll
    %%%%%: 4832-block 520
call    0 never executed
        -: 4833:                else
    #####: 4834:                    clear_active_id = true;
    %%%%%: 4834-block 521
        -: 4835:            }
    #####: 4836:            else if (!is_readonly)
    %%%%%: 4836-block 523
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4837:            {
    #####: 4838:                unsigned int c = '\n'; // Insert new line
    #####: 4839:                if (InputTextFilterCharacter(&g, &c, flags, callback, callback_user_data))
    %%%%%: 4839-block 524
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 4839-block 525
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 4840:                    state->OnCharPressed(c);
    %%%%%: 4840-block 526
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 4841:            }
    #####: 4842:        }
    %%%%%: 4842-block 528
    #####: 4843:        else if (is_cancel)
    %%%%%: 4843-block 529
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4844:        {
    #####: 4845:            if (flags & ImGuiInputTextFlags_EscapeClearsAll)
    %%%%%: 4845-block 530
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4846:            {
    #####: 4847:                if (buf[0] != 0)
    %%%%%: 4847-block 531
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4848:                {
    #####: 4849:                    revert_edit = true;
    %%%%%: 4849-block 532
        -: 4850:                }
        -: 4851:                else
        -: 4852:                {
    #####: 4853:                    render_cursor = render_selection = false;
    #####: 4854:                    clear_active_id = true;
    %%%%%: 4854-block 533
        -: 4855:                }
        -: 4856:            }
        -: 4857:            else
        -: 4858:            {
    #####: 4859:                clear_active_id = revert_edit = true;
    #####: 4860:                render_cursor = render_selection = false;
    %%%%%: 4860-block 534
        -: 4861:            }
        -: 4862:        }
    #####: 4863:        else if (is_undo || is_redo)
    %%%%%: 4863-block 535
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4863-block 536
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 4864:        {
    #####: 4865:            state->OnKeyPressed(is_undo ? STB_TEXTEDIT_K_UNDO : STB_TEXTEDIT_K_REDO);
    %%%%%: 4865-block 537
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4865-block 538
    %%%%%: 4865-block 539
    %%%%%: 4865-block 540
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####: 4866:            state->ClearSelection();
    %%%%%: 4866-block 541
call    0 never executed
        -: 4867:        }
    #####: 4868:        else if (is_select_all)
    %%%%%: 4868-block 542
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4869:        {
    #####: 4870:            state->SelectAll();
    %%%%%: 4870-block 543
call    0 never executed
    #####: 4871:            state->CursorFollow = true;
        -: 4872:        }
    #####: 4873:        else if (is_cut || is_copy)
    %%%%%: 4873-block 545
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4873-block 546
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 4874:        {
        -: 4875:            // Cut, Copy
    #####: 4876:            if (g.PlatformIO.Platform_SetClipboardTextFn != NULL)
    %%%%%: 4876-block 547
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4877:            {
    #####: 4878:                const int ib = state->HasSelection() ? ImMin(state->Stb->select_start, state->Stb->select_end) : 0;
    %%%%%: 4878-block 548
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 4878-block 550
call    3 never executed
    %%%%%: 4878-block 551
    #####: 4879:                const int ie = state->HasSelection() ? ImMax(state->Stb->select_start, state->Stb->select_end) : state->CurLenA;
    %%%%%: 4879-block 552
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 4879-block 554
call    3 never executed
    %%%%%: 4879-block 555
        -: 4880:
    #####: 4881:                char backup = state->TextA.Data[ie];
    #####: 4882:                state->TextA.Data[ie] = 0; // A bit of a hack since SetClipboardText only takes null terminated strings
    #####: 4883:                SetClipboardText(state->TextA.Data + ib);
    %%%%%: 4883-block 556
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 4884:                state->TextA.Data[ie] = backup;
    %%%%%: 4884-block 557
        -: 4885:            }
    #####: 4886:            if (is_cut)
    %%%%%: 4886-block 558
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4887:            {
    #####: 4888:                if (!state->HasSelection())
    %%%%%: 4888-block 559
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 4889:                    state->SelectAll();
    %%%%%: 4889-block 561
call    0 never executed
    #####: 4890:                state->CursorFollow = true;
    #####: 4891:                stb_textedit_cut(state, state->Stb);
    %%%%%: 4891-block 562
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 4892:            }
    #####: 4893:        }
    %%%%%: 4893-block 563
    #####: 4894:        else if (is_paste)
    %%%%%: 4894-block 564
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4895:        {
    #####: 4896:            if (const char* clipboard = GetClipboardText())
    %%%%%: 4896-block 565
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 4896-block 566
branch  3 never executed (fallthrough)
branch  4 never executed
        -: 4897:            {
        -: 4898:                // Filter pasted buffer
    #####: 4899:                const int clipboard_len = (int)strlen(clipboard);
    #####: 4900:                char* clipboard_filtered = (char*)IM_ALLOC(clipboard_len + 1);
    %%%%%: 4900-block 567
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 4901:                int clipboard_filtered_len = 0;
    #####: 4902:                for (const char* s = clipboard; *s != 0; )
    %%%%%: 4902-block 568
    %%%%%: 4902-block 574
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 4903:                {
        -: 4904:                    unsigned int c;
    #####: 4905:                    int len = ImTextCharFromUtf8(&c, s, NULL);
    %%%%%: 4905-block 569
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 4906:                    s += len;
    #####: 4907:                    if (!InputTextFilterCharacter(&g, &c, flags, callback, callback_user_data, true))
    %%%%%: 4907-block 570
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 4907-block 571
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 4908:                        continue;
    %%%%%: 4908-block 572
    #####: 4909:                    memcpy(clipboard_filtered + clipboard_filtered_len, s - len, len);
    #####: 4910:                    clipboard_filtered_len += len;
    %%%%%: 4910-block 573
        -: 4911:                }
    #####: 4912:                clipboard_filtered[clipboard_filtered_len] = 0;
    #####: 4913:                if (clipboard_filtered_len > 0) // If everything was filtered, ignore the pasting operation
    %%%%%: 4913-block 575
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4914:                {
    #####: 4915:                    stb_textedit_paste(state, state->Stb, clipboard_filtered, clipboard_filtered_len);
    %%%%%: 4915-block 576
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 4916:                    state->CursorFollow = true;
    %%%%%: 4916-block 577
        -: 4917:                }
    #####: 4918:                MemFree(clipboard_filtered);
    %%%%%: 4918-block 578
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 4919:            }
        -: 4920:        }
        -: 4921:
        -: 4922:        // Update render selection flag after events have been handled, so selection highlight can be displayed during the same frame.
    #####: 4923:        render_selection |= state->HasSelection() && (RENDER_SELECTION_WHEN_INACTIVE || render_cursor);
    %%%%%: 4923-block 579
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 4923-block 581
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 4923-block 582
    %%%%%: 4923-block 583
    %%%%%: 4923-block 584
        -: 4924:    }
        -: 4925:
        -: 4926:    // Process callbacks and apply result back to user's buffer.
    27977: 4927:    const char* apply_new_text = NULL;
    27977: 4928:    int apply_new_text_length = 0;
    27977: 4929:    if (g.ActiveId == id)
    27977: 4929-block 585
branch  0 taken 0 (fallthrough)
branch  1 taken 27977
        -: 4930:    {
    #####: 4931:        IM_ASSERT(state != NULL);
    %%%%%: 4931-block 586
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4931-block 587
call    2 never executed
    #####: 4932:        if (revert_edit && !is_readonly)
    %%%%%: 4932-block 588
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4932-block 589
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 4933:        {
    #####: 4934:            if (flags & ImGuiInputTextFlags_EscapeClearsAll)
    %%%%%: 4934-block 590
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4935:            {
        -: 4936:                // Clear input
    #####: 4937:                IM_ASSERT(buf[0] != 0);
    %%%%%: 4937-block 591
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4937-block 592
call    2 never executed
    #####: 4938:                apply_new_text = "";
    #####: 4939:                apply_new_text_length = 0;
    #####: 4940:                value_changed = true;
        -: 4941:                IMSTB_TEXTEDIT_CHARTYPE empty_string;
    #####: 4942:                stb_textedit_replace(state, state->Stb, &empty_string, 0);
    %%%%%: 4942-block 593
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 4943:            }
    #####: 4944:            else if (strcmp(buf, state->InitialTextA.Data) != 0)
    %%%%%: 4944-block 595
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4945:            {
    #####: 4946:                apply_new_text = state->InitialTextA.Data;
    #####: 4947:                apply_new_text_length = state->InitialTextA.Size - 1;
        -: 4948:
        -: 4949:                // Restore initial value. Only return true if restoring to the initial value changes the current buffer contents.
        -: 4950:                // Push records into the undo stack so we can CTRL+Z the revert operation itself
    #####: 4951:                value_changed = true;
    #####: 4952:                stb_textedit_replace(state, state->Stb, state->InitialTextA.Data, state->InitialTextA.Size - 1);
    %%%%%: 4952-block 596
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 4953:            }
        -: 4954:        }
        -: 4955:
        -: 4956:        // When using 'ImGuiInputTextFlags_EnterReturnsTrue' as a special case we reapply the live buffer back to the input buffer
        -: 4957:        // before clearing ActiveId, even though strictly speaking it wasn't modified on this frame.
        -: 4958:        // If we didn't do that, code like InputInt() with ImGuiInputTextFlags_EnterReturnsTrue would fail.
        -: 4959:        // This also allows the user to use InputText() with ImGuiInputTextFlags_EnterReturnsTrue without maintaining any user-side storage
        -: 4960:        // (please note that if you use this property along ImGuiInputTextFlags_CallbackResize you can end up with your temporary string object
        -: 4961:        // unnecessarily allocating once a frame, either store your string data, either if you don't then don't use ImGuiInputTextFlags_CallbackResize).
    #####: 4962:        const bool apply_edit_back_to_user_buffer = !revert_edit || (validated && (flags & ImGuiInputTextFlags_EnterReturnsTrue) != 0);
    %%%%%: 4962-block 597
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4962-block 598
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4962-block 599
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 4962-block 600
    %%%%%: 4962-block 601
    #####: 4963:        if (apply_edit_back_to_user_buffer)
    %%%%%: 4963-block 602
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4964:        {
        -: 4965:            // Apply new value immediately - copy modified buffer back
        -: 4966:            // Note that as soon as the input box is active, the in-widget value gets priority over any underlying modification of the input buffer
        -: 4967:            // FIXME: We actually always render 'buf' when calling DrawList->AddText, making the comment above incorrect.
        -: 4968:            // FIXME-OPT: CPU waste to do this every time the widget is active, should mark dirty state from the stb_textedit callbacks.
        -: 4969:
        -: 4970:            // User callback
    #####: 4971:            if ((flags & (ImGuiInputTextFlags_CallbackCompletion | ImGuiInputTextFlags_CallbackHistory | ImGuiInputTextFlags_CallbackEdit | ImGuiInputTextFlags_CallbackAlways)) != 0)
    %%%%%: 4971-block 603
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4972:            {
    #####: 4973:                IM_ASSERT(callback != NULL);
    %%%%%: 4973-block 604
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4973-block 605
call    2 never executed
        -: 4974:
        -: 4975:                // The reason we specify the usage semantic (Completion/History) is that Completion needs to disable keyboard TABBING at the moment.
    #####: 4976:                ImGuiInputTextFlags event_flag = 0;
    #####: 4977:                ImGuiKey event_key = ImGuiKey_None;
    #####: 4978:                if ((flags & ImGuiInputTextFlags_CallbackCompletion) != 0 && Shortcut(ImGuiKey_Tab, 0, id))
    %%%%%: 4978-block 606
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4978-block 607
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 4978-block 608
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 4978-block 609
    %%%%%: 4978-block 610
    %%%%%: 4978-block 611
branch  7 never executed (fallthrough)
branch  8 never executed
        -: 4979:                {
    #####: 4980:                    event_flag = ImGuiInputTextFlags_CallbackCompletion;
    #####: 4981:                    event_key = ImGuiKey_Tab;
    %%%%%: 4981-block 612
        -: 4982:                }
    #####: 4983:                else if ((flags & ImGuiInputTextFlags_CallbackHistory) != 0 && IsKeyPressed(ImGuiKey_UpArrow))
    %%%%%: 4983-block 613
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4983-block 614
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 4983-block 615
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 4983-block 616
    %%%%%: 4983-block 617
    %%%%%: 4983-block 618
branch  7 never executed (fallthrough)
branch  8 never executed
        -: 4984:                {
    #####: 4985:                    event_flag = ImGuiInputTextFlags_CallbackHistory;
    #####: 4986:                    event_key = ImGuiKey_UpArrow;
    %%%%%: 4986-block 619
        -: 4987:                }
    #####: 4988:                else if ((flags & ImGuiInputTextFlags_CallbackHistory) != 0 && IsKeyPressed(ImGuiKey_DownArrow))
    %%%%%: 4988-block 620
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4988-block 621
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 4988-block 622
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 4988-block 623
    %%%%%: 4988-block 624
    %%%%%: 4988-block 625
branch  7 never executed (fallthrough)
branch  8 never executed
        -: 4989:                {
    #####: 4990:                    event_flag = ImGuiInputTextFlags_CallbackHistory;
    #####: 4991:                    event_key = ImGuiKey_DownArrow;
    %%%%%: 4991-block 626
        -: 4992:                }
    #####: 4993:                else if ((flags & ImGuiInputTextFlags_CallbackEdit) && state->Edited)
    %%%%%: 4993-block 627
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4993-block 628
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 4994:                {
    #####: 4995:                    event_flag = ImGuiInputTextFlags_CallbackEdit;
    %%%%%: 4995-block 629
        -: 4996:                }
    #####: 4997:                else if (flags & ImGuiInputTextFlags_CallbackAlways)
    %%%%%: 4997-block 630
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4998:                {
    #####: 4999:                    event_flag = ImGuiInputTextFlags_CallbackAlways;
    %%%%%: 4999-block 631
        -: 5000:                }
        -: 5001:
    #####: 5002:                if (event_flag)
    %%%%%: 5002-block 632
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5003:                {
    #####: 5004:                    ImGuiInputTextCallbackData callback_data;
    %%%%%: 5004-block 633
call    0 never executed
    #####: 5005:                    callback_data.Ctx = &g;
    #####: 5006:                    callback_data.EventFlag = event_flag;
    #####: 5007:                    callback_data.Flags = flags;
    #####: 5008:                    callback_data.UserData = callback_user_data;
        -: 5009:
        -: 5010:                    // FIXME-OPT: Undo stack reconcile needs a backup of the data until we rework API, see #7925
    #####: 5011:                    state->CallbackTextBackup.resize(state->CurLenA + 1);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5012:                    memcpy(state->CallbackTextBackup.Data, state->TextA.Data, state->CurLenA + 1);
        -: 5013:
    #####: 5014:                    char* callback_buf = is_readonly ? buf : state->TextA.Data;
    %%%%%: 5014-block 635
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5014-block 636
    %%%%%: 5014-block 637
    #####: 5015:                    callback_data.EventKey = event_key;
    #####: 5016:                    callback_data.Buf = callback_buf;
    #####: 5017:                    callback_data.BufTextLen = state->CurLenA;
    #####: 5018:                    callback_data.BufSize = state->BufCapacityA;
    #####: 5019:                    callback_data.BufDirty = false;
        -: 5020:
    #####: 5021:                    const int utf8_cursor_pos = callback_data.CursorPos = state->Stb->cursor;
    #####: 5022:                    const int utf8_selection_start = callback_data.SelectionStart = state->Stb->select_start;
    #####: 5023:                    const int utf8_selection_end = callback_data.SelectionEnd = state->Stb->select_end;
        -: 5024:
        -: 5025:                    // Call user code
    #####: 5026:                    callback(&callback_data);
    %%%%%: 5026-block 638
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5027:
        -: 5028:                    // Read back what user may have modified
    #####: 5029:                    callback_buf = is_readonly ? buf : state->TextA.Data; // Pointer may have been invalidated by a resize callback
    %%%%%: 5029-block 639
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5029-block 640
    %%%%%: 5029-block 641
    #####: 5030:                    IM_ASSERT(callback_data.Buf == callback_buf);         // Invalid to modify those fields
    %%%%%: 5030-block 642
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5030-block 643
call    2 never executed
    #####: 5031:                    IM_ASSERT(callback_data.BufSize == state->BufCapacityA);
    %%%%%: 5031-block 644
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5031-block 645
call    2 never executed
    #####: 5032:                    IM_ASSERT(callback_data.Flags == flags);
    %%%%%: 5032-block 646
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5032-block 647
call    2 never executed
    #####: 5033:                    const bool buf_dirty = callback_data.BufDirty;
    #####: 5034:                    if (callback_data.CursorPos != utf8_cursor_pos || buf_dirty)            { state->Stb->cursor = callback_data.CursorPos; state->CursorFollow = true; }
    %%%%%: 5034-block 648
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5034-block 649
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5034-block 650
    #####: 5035:                    if (callback_data.SelectionStart != utf8_selection_start || buf_dirty)  { state->Stb->select_start = (callback_data.SelectionStart == callback_data.CursorPos) ? state->Stb->cursor : callback_data.SelectionStart; }
    %%%%%: 5035-block 651
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5035-block 652
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5035-block 653
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 5035-block 654
    %%%%%: 5035-block 655
    %%%%%: 5035-block 656
    #####: 5036:                    if (callback_data.SelectionEnd != utf8_selection_end || buf_dirty)      { state->Stb->select_end = (callback_data.SelectionEnd == callback_data.SelectionStart) ? state->Stb->select_start : callback_data.SelectionEnd; }
    %%%%%: 5036-block 657
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5036-block 658
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5036-block 659
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 5036-block 660
    %%%%%: 5036-block 661
    %%%%%: 5036-block 662
    #####: 5037:                    if (buf_dirty)
    %%%%%: 5037-block 663
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5038:                    {
        -: 5039:                        // Callback may update buffer and thus set buf_dirty even in read-only mode.
    #####: 5040:                        IM_ASSERT(callback_data.BufTextLen == (int)strlen(callback_data.Buf)); // You need to maintain BufTextLen if you change the text!
    %%%%%: 5040-block 664
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5040-block 665
call    2 never executed
    #####: 5041:                        InputTextReconcileUndoStateAfterUserCallback(state, callback_data.Buf, callback_data.BufTextLen); // FIXME: Move the rest of this block inside function and rename to InputTextReconcileStateAfterUserCallback() ?
    %%%%%: 5041-block 666
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5042:                        state->CurLenA = callback_data.BufTextLen;  // Assume correct length and valid UTF-8 from user, saves us an extra strlen()
    #####: 5043:                        state->TextA.Size = state->CurLenA + 1;
    #####: 5044:                        state->CursorAnimReset();
    %%%%%: 5044-block 667
call    0 never executed
        -: 5045:                    }
        -: 5046:                }
        -: 5047:            }
        -: 5048:
        -: 5049:            // Will copy result string if modified
    #####: 5050:            if (!is_readonly && strcmp(state->TextA.Data, buf) != 0)
    %%%%%: 5050-block 669
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5050-block 670
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 5051:            {
    #####: 5052:                apply_new_text = state->TextA.Data;
    #####: 5053:                apply_new_text_length = state->CurLenA;
    #####: 5054:                value_changed = true;
    %%%%%: 5054-block 671
        -: 5055:            }
        -: 5056:        }
        -: 5057:    }
        -: 5058:
        -: 5059:    // Handle reapplying final data on deactivation (see InputTextDeactivateHook() for details)
    27977: 5060:    if (g.InputTextDeactivatedState.ID == id)
    27977: 5060-block 672
branch  0 taken 0 (fallthrough)
branch  1 taken 27977
        -: 5061:    {
    #####: 5062:        if (g.ActiveId != id && IsItemDeactivatedAfterEdit() && !is_readonly && strcmp(g.InputTextDeactivatedState.TextA.Data, buf) != 0)
    %%%%%: 5062-block 673
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5062-block 674
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 5062-block 675
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 5062-block 676
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 5062-block 677
branch  9 never executed (fallthrough)
branch 10 never executed
    %%%%%: 5062-block 678
    %%%%%: 5062-block 679
    %%%%%: 5062-block 680
branch 11 never executed (fallthrough)
branch 12 never executed
        -: 5063:        {
    #####: 5064:            apply_new_text = g.InputTextDeactivatedState.TextA.Data;
    #####: 5065:            apply_new_text_length = g.InputTextDeactivatedState.TextA.Size - 1;
    #####: 5066:            value_changed = true;
    %%%%%: 5066-block 681
        -: 5067:            //IMGUI_DEBUG_LOG("InputText(): apply Deactivated data for 0x%08X: \"%.*s\".\n", id, apply_new_text_length, apply_new_text);
        -: 5068:        }
    #####: 5069:        g.InputTextDeactivatedState.ID = 0;
    %%%%%: 5069-block 682
        -: 5070:    }
        -: 5071:
        -: 5072:    // Copy result to user buffer. This can currently only happen when (g.ActiveId == id)
    27977: 5073:    if (apply_new_text != NULL)
    27977: 5073-block 683
branch  0 taken 0 (fallthrough)
branch  1 taken 27977
        -: 5074:    {
        -: 5075:        //// We cannot test for 'backup_current_text_length != apply_new_text_length' here because we have no guarantee that the size
        -: 5076:        //// of our owned buffer matches the size of the string object held by the user, and by design we allow InputText() to be used
        -: 5077:        //// without any storage on user's side.
    #####: 5078:        IM_ASSERT(apply_new_text_length >= 0);
    %%%%%: 5078-block 684
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5078-block 685
call    2 never executed
    #####: 5079:        if (is_resizable)
    %%%%%: 5079-block 686
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5080:        {
    #####: 5081:            ImGuiInputTextCallbackData callback_data;
    %%%%%: 5081-block 687
call    0 never executed
    #####: 5082:            callback_data.Ctx = &g;
    #####: 5083:            callback_data.EventFlag = ImGuiInputTextFlags_CallbackResize;
    #####: 5084:            callback_data.Flags = flags;
    #####: 5085:            callback_data.Buf = buf;
    #####: 5086:            callback_data.BufTextLen = apply_new_text_length;
    #####: 5087:            callback_data.BufSize = ImMax(buf_size, apply_new_text_length + 1);
call    0 never executed
    #####: 5088:            callback_data.UserData = callback_user_data;
    #####: 5089:            callback(&callback_data);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5090:            buf = callback_data.Buf;
    #####: 5091:            buf_size = callback_data.BufSize;
    #####: 5092:            apply_new_text_length = ImMin(callback_data.BufTextLen, buf_size - 1);
    %%%%%: 5092-block 690
call    0 never executed
    #####: 5093:            IM_ASSERT(apply_new_text_length <= buf_size);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5093-block 692
call    2 never executed
        -: 5094:        }
        -: 5095:        //IMGUI_DEBUG_PRINT("InputText(\"%s\"): apply_new_text length %d\n", label, apply_new_text_length);
        -: 5096:
        -: 5097:        // If the underlying buffer resize was denied or not carried to the next frame, apply_new_text_length+1 may be >= buf_size.
    #####: 5098:        ImStrncpy(buf, apply_new_text, ImMin(apply_new_text_length + 1, buf_size));
    %%%%%: 5098-block 694
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
        -: 5099:    }
        -: 5100:
        -: 5101:    // Release active ID at the end of the function (so e.g. pressing Return still does a final application of the value)
        -: 5102:    // Otherwise request text input ahead for next frame.
   27977*: 5103:    if (g.ActiveId == id && clear_active_id)
    27977: 5103-block 696
branch  0 taken 0 (fallthrough)
branch  1 taken 27977
    %%%%%: 5103-block 697
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 5104:        ClearActiveID();
    %%%%%: 5104-block 698
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    27977: 5105:    else if (g.ActiveId == id)
    27977: 5105-block 700
branch  0 taken 0 (fallthrough)
branch  1 taken 27977
    #####: 5106:        g.WantTextInputNextFrame = 1;
    %%%%%: 5106-block 701
        -: 5107:
        -: 5108:    // Render frame
    27977: 5109:    if (!is_multiline)
    27977: 5109-block 702
branch  0 taken 27977 (fallthrough)
branch  1 taken 0
        -: 5110:    {
    27977: 5111:        RenderNavCursor(frame_bb, id);
    27977: 5111-block 703
call    0 returned 27977
branch  1 taken 27977 (fallthrough)
branch  2 taken 0 (throw)
    27977: 5112:        RenderFrame(frame_bb.Min, frame_bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);
    27977: 5112-block 704
call    0 returned 27977
branch  1 taken 27977 (fallthrough)
branch  2 taken 0 (throw)
    27977: 5112-block 705
call    3 returned 27977
branch  4 taken 27977 (fallthrough)
branch  5 taken 0 (throw)
        -: 5113:    }
        -: 5114:
    27977: 5115:    const ImVec4 clip_rect(frame_bb.Min.x, frame_bb.Min.y, frame_bb.Min.x + inner_size.x, frame_bb.Min.y + inner_size.y); // Not using frame_bb.Max because we have adjusted size
    27977: 5115-block 706
call    0 returned 27977
   27977*: 5116:    ImVec2 draw_pos = is_multiline ? draw_window->DC.CursorPos : frame_bb.Min + style.FramePadding;
branch  0 taken 0 (fallthrough)
branch  1 taken 27977
    %%%%%: 5116-block 708
    27977: 5116-block 709
call    2 returned 27977
    27977: 5117:    ImVec2 text_size(0.0f, 0.0f);
        -: 5118:
        -: 5119:    // Set upper limit of single-line InputTextEx() at 2 million characters strings. The current pathological worst case is a long line
        -: 5120:    // without any carriage return, which would makes ImFont::RenderText() reserve too many vertices and probably crash. Avoid it altogether.
        -: 5121:    // Note that we only use this limit on single-line InputText(), so a pathologically large line on a InputTextMultiline() would still crash.
    27977: 5122:    const int buf_display_max_length = 2 * 1024 * 1024;
   27977*: 5123:    const char* buf_display = buf_display_from_state ? state->TextA.Data : buf; //-V595
    27977: 5123-block 710
branch  0 taken 0 (fallthrough)
branch  1 taken 27977
    %%%%%: 5123-block 711
    27977: 5123-block 712
    27977: 5124:    const char* buf_display_end = NULL; // We have specialized paths below for setting the length
    27977: 5125:    if (is_displaying_hint)
    27977: 5125-block 713
branch  0 taken 0 (fallthrough)
branch  1 taken 27977
        -: 5126:    {
    #####: 5127:        buf_display = hint;
    #####: 5128:        buf_display_end = hint + strlen(hint);
    %%%%%: 5128-block 714
        -: 5129:    }
        -: 5130:
        -: 5131:    // Render text. We currently only render selection when the widget is active or while scrolling.
        -: 5132:    // FIXME: We could remove the '&& render_cursor' to keep rendering selection when inactive.
    27977: 5133:    if (render_cursor || render_selection)
    27977: 5133-block 715
branch  0 taken 27977 (fallthrough)
branch  1 taken 0
    27977: 5133-block 716
branch  2 taken 0 (fallthrough)
branch  3 taken 27977
        -: 5134:    {
    #####: 5135:        IM_ASSERT(state != NULL);
    %%%%%: 5135-block 717
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5135-block 718
call    2 never executed
    #####: 5136:        if (!is_displaying_hint)
    %%%%%: 5136-block 719
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5137:            buf_display_end = buf_display + state->CurLenA;
    %%%%%: 5137-block 720
        -: 5138:
        -: 5139:        // Render text (with cursor and selection)
        -: 5140:        // This is going to be messy. We need to:
        -: 5141:        // - Display the text (this alone can be more easily clipped)
        -: 5142:        // - Handle scrolling, highlight selection, display cursor (those all requires some form of 1d->2d cursor position calculation)
        -: 5143:        // - Measure text height (for scrollbar)
        -: 5144:        // We are attempting to do most of that in **one main pass** to minimize the computation cost (non-negligible for large amount of text) + 2nd pass for selection rendering (we could merge them by an extra refactoring effort)
        -: 5145:        // FIXME: This should occur on buf_display but we'd need to maintain cursor/select_start/select_end for UTF-8.
    #####: 5146:        const char* text_begin = state->TextA.Data;
    #####: 5147:        const char* text_end = text_begin + state->CurLenA;
    #####: 5148:        ImVec2 cursor_offset, select_start_offset;
        -: 5149:
        -: 5150:        {
        -: 5151:            // Find lines numbers straddling cursor and selection min position
    #####: 5152:            int cursor_line_no = render_cursor ? -1 : -1000;
    %%%%%: 5152-block 721
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5152-block 722
    %%%%%: 5152-block 723
    #####: 5153:            int selmin_line_no = render_selection ? -1 : -1000;
    %%%%%: 5153-block 724
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5153-block 725
    %%%%%: 5153-block 726
    #####: 5154:            const char* cursor_ptr = render_cursor ? text_begin + state->Stb->cursor : NULL;
    %%%%%: 5154-block 727
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5154-block 728
    %%%%%: 5154-block 729
    #####: 5155:            const char* selmin_ptr = render_selection ? text_begin + ImMin(state->Stb->select_start, state->Stb->select_end) : NULL;
    %%%%%: 5155-block 730
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5155-block 731
call    2 never executed
    %%%%%: 5155-block 733
        -: 5156:
        -: 5157:            // Count lines and find line number for cursor and selection ends
    #####: 5158:            int line_count = 1;
    #####: 5159:            if (is_multiline)
    %%%%%: 5159-block 734
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5160:            {
    #####: 5161:                for (const char* s = text_begin; (s = (const char*)memchr(s, '\n', (size_t)(text_end - s))) != NULL; s++)
    %%%%%: 5161-block 735
    %%%%%: 5161-block 743
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 5162:                {
    #####: 5163:                    if (cursor_line_no == -1 && s >= cursor_ptr) { cursor_line_no = line_count; }
    %%%%%: 5163-block 736
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5163-block 737
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5163-block 738
    #####: 5164:                    if (selmin_line_no == -1 && s >= selmin_ptr) { selmin_line_no = line_count; }
    %%%%%: 5164-block 739
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5164-block 740
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5164-block 741
    #####: 5165:                    line_count++;
    %%%%%: 5165-block 742
        -: 5166:                }
        -: 5167:            }
    #####: 5168:            if (cursor_line_no == -1)
    %%%%%: 5168-block 744
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5169:                cursor_line_no = line_count;
    %%%%%: 5169-block 745
    #####: 5170:            if (selmin_line_no == -1)
    %%%%%: 5170-block 746
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5171:                selmin_line_no = line_count;
    %%%%%: 5171-block 747
        -: 5172:
        -: 5173:            // Calculate 2d position by finding the beginning of the line and measuring distance
    #####: 5174:            cursor_offset.x = InputTextCalcTextSize(&g, ImStrbol(cursor_ptr, text_begin), cursor_ptr).x;
    %%%%%: 5174-block 748
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 5174-block 749
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    #####: 5175:            cursor_offset.y = cursor_line_no * g.FontSize;
    #####: 5176:            if (selmin_line_no >= 0)
    %%%%%: 5176-block 750
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5177:            {
    #####: 5178:                select_start_offset.x = InputTextCalcTextSize(&g, ImStrbol(selmin_ptr, text_begin), selmin_ptr).x;
    %%%%%: 5178-block 751
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 5178-block 752
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    #####: 5179:                select_start_offset.y = selmin_line_no * g.FontSize;
    %%%%%: 5179-block 753
        -: 5180:            }
        -: 5181:
        -: 5182:            // Store text height (note that we haven't calculated text width at all, see GitHub issues #383, #1224)
    #####: 5183:            if (is_multiline)
    %%%%%: 5183-block 754
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5184:                text_size = ImVec2(inner_size.x, line_count * g.FontSize);
    %%%%%: 5184-block 755
call    0 never executed
        -: 5185:        }
        -: 5186:
        -: 5187:        // Scroll
    #####: 5188:        if (render_cursor && state->CursorFollow)
    %%%%%: 5188-block 757
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5188-block 758
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 5189:        {
        -: 5190:            // Horizontal scroll in chunks of quarter width
    #####: 5191:            if (!(flags & ImGuiInputTextFlags_NoHorizontalScroll))
    %%%%%: 5191-block 759
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5192:            {
    #####: 5193:                const float scroll_increment_x = inner_size.x * 0.25f;
    #####: 5194:                const float visible_width = inner_size.x - style.FramePadding.x;
    #####: 5195:                if (cursor_offset.x < state->Scroll.x)
    %%%%%: 5195-block 760
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5196:                    state->Scroll.x = IM_TRUNC(ImMax(0.0f, cursor_offset.x - scroll_increment_x));
    %%%%%: 5196-block 761
call    0 never executed
    #####: 5197:                else if (cursor_offset.x - visible_width >= state->Scroll.x)
    %%%%%: 5197-block 763
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5198:                    state->Scroll.x = IM_TRUNC(cursor_offset.x - visible_width + scroll_increment_x);
    %%%%%: 5198-block 764
        -: 5199:            }
        -: 5200:            else
        -: 5201:            {
    #####: 5202:                state->Scroll.y = 0.0f;
    %%%%%: 5202-block 765
        -: 5203:            }
        -: 5204:
        -: 5205:            // Vertical scroll
    #####: 5206:            if (is_multiline)
    %%%%%: 5206-block 766
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5207:            {
        -: 5208:                // Test if cursor is vertically visible
    #####: 5209:                if (cursor_offset.y - g.FontSize < scroll_y)
    %%%%%: 5209-block 767
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5210:                    scroll_y = ImMax(0.0f, cursor_offset.y - g.FontSize);
    %%%%%: 5210-block 768
call    0 never executed
    #####: 5211:                else if (cursor_offset.y - (inner_size.y - style.FramePadding.y * 2.0f) >= scroll_y)
    %%%%%: 5211-block 769
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5212:                    scroll_y = cursor_offset.y - inner_size.y + style.FramePadding.y * 2.0f;
    %%%%%: 5212-block 770
    #####: 5213:                const float scroll_max_y = ImMax((text_size.y + style.FramePadding.y * 2.0f) - inner_size.y, 0.0f);
    %%%%%: 5213-block 771
call    0 never executed
    #####: 5214:                scroll_y = ImClamp(scroll_y, 0.0f, scroll_max_y);
call    0 never executed
    #####: 5215:                draw_pos.y += (draw_window->Scroll.y - scroll_y);   // Manipulate cursor pos immediately avoid a frame of lag
    #####: 5216:                draw_window->Scroll.y = scroll_y;
        -: 5217:            }
        -: 5218:
    #####: 5219:            state->CursorFollow = false;
    %%%%%: 5219-block 774
        -: 5220:        }
        -: 5221:
        -: 5222:        // Draw selection
    #####: 5223:        const ImVec2 draw_scroll = ImVec2(state->Scroll.x, 0.0f);
    %%%%%: 5223-block 775
call    0 never executed
    #####: 5224:        if (render_selection)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5225:        {
    #####: 5226:            const char* text_selected_begin = text_begin + ImMin(state->Stb->select_start, state->Stb->select_end);
    %%%%%: 5226-block 777
call    0 never executed
    #####: 5227:            const char* text_selected_end = text_begin + ImMax(state->Stb->select_start, state->Stb->select_end);
call    0 never executed
        -: 5228:
    #####: 5229:            ImU32 bg_color = GetColorU32(ImGuiCol_TextSelectedBg, render_cursor ? 1.0f : 0.6f); // FIXME: current code flow mandate that render_cursor is always true here, we are leaving the transparent one for tests.
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5229-block 780
    %%%%%: 5229-block 781
    %%%%%: 5229-block 782
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####: 5230:            float bg_offy_up = is_multiline ? 0.0f : -1.0f;    // FIXME: those offsets should be part of the style? they don't play so well with multi-line selection.
    %%%%%: 5230-block 783
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5230-block 784
    %%%%%: 5230-block 785
    #####: 5231:            float bg_offy_dn = is_multiline ? 0.0f : 2.0f;
    %%%%%: 5231-block 786
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5231-block 787
    %%%%%: 5231-block 788
    #####: 5232:            ImVec2 rect_pos = draw_pos + select_start_offset - draw_scroll;
    %%%%%: 5232-block 789
call    0 never executed
call    1 never executed
    #####: 5233:            for (const char* p = text_selected_begin; p < text_selected_end; )
    %%%%%: 5233-block 816
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 5234:            {
    #####: 5235:                if (rect_pos.y > clip_rect.w + g.FontSize)
    %%%%%: 5235-block 792
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5236:                    break;
    %%%%%: 5236-block 793
    #####: 5237:                if (rect_pos.y < clip_rect.y)
    %%%%%: 5237-block 794
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5238:                {
    #####: 5239:                    p = (const char*)memchr((void*)p, '\n', text_selected_end - p);
    #####: 5240:                    p = p ? p + 1 : text_selected_end;
    %%%%%: 5240-block 795
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5240-block 796
    %%%%%: 5240-block 797
    %%%%%: 5240-block 798
        -: 5241:                }
        -: 5242:                else
        -: 5243:                {
    #####: 5244:                    ImVec2 rect_size = InputTextCalcTextSize(&g, p, text_selected_end, &p, NULL, true);
    %%%%%: 5244-block 799
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5245:                    if (rect_size.x <= 0.0f) rect_size.x = IM_TRUNC(g.Font->GetCharAdvance((ImWchar)' ') * 0.50f); // So we can see selected empty lines
    %%%%%: 5245-block 800
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5245-block 801
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 5245-block 802
    #####: 5246:                    ImRect rect(rect_pos + ImVec2(0.0f, bg_offy_up - g.FontSize), rect_pos + ImVec2(rect_size.x, bg_offy_dn));
    %%%%%: 5246-block 803
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 5247:                    rect.ClipWith(clip_rect);
call    0 never executed
call    1 never executed
    #####: 5248:                    if (rect.Overlaps(clip_rect))
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 5249:                        draw_window->DrawList->AddRectFilled(rect.Min, rect.Max, bg_color);
    %%%%%: 5249-block 813
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5250:                    rect_pos.x = draw_pos.x - draw_scroll.x;
    %%%%%: 5250-block 814
        -: 5251:                }
    #####: 5252:                rect_pos.y += g.FontSize;
    %%%%%: 5252-block 815
        -: 5253:            }
        -: 5254:        }
        -: 5255:
        -: 5256:        // We test for 'buf_display_max_length' as a way to avoid some pathological cases (e.g. single-line 1 MB string) which would make ImDrawList crash.
        -: 5257:        // FIXME-OPT: Multiline could submit a smaller amount of contents to AddText() since we already iterated through it.
    #####: 5258:        if (is_multiline || (buf_display_end - buf_display) < buf_display_max_length)
    %%%%%: 5258-block 818
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5258-block 819
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 5259:        {
    #####: 5260:            ImU32 col = GetColorU32(is_displaying_hint ? ImGuiCol_TextDisabled : ImGuiCol_Text);
    %%%%%: 5260-block 820
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5260-block 821
    %%%%%: 5260-block 822
    %%%%%: 5260-block 823
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####: 5261:            draw_window->DrawList->AddText(g.Font, g.FontSize, draw_pos - draw_scroll, col, buf_display, buf_display_end, 0.0f, is_multiline ? NULL : &clip_rect);
    %%%%%: 5261-block 824
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5261-block 825
    %%%%%: 5261-block 826
    %%%%%: 5261-block 827
call    2 never executed
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    %%%%%: 5261-block 829
    $$$$$: 5261-block 920
        -: 5262:        }
        -: 5263:
        -: 5264:        // Draw blinking cursor
    #####: 5265:        if (render_cursor)
    %%%%%: 5265-block 830
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5266:        {
    #####: 5267:            state->CursorAnim += io.DeltaTime;
    #####: 5268:            bool cursor_is_visible = (!g.IO.ConfigInputTextCursorBlink) || (state->CursorAnim <= 0.0f) || ImFmod(state->CursorAnim, 1.20f) <= 0.80f;
    %%%%%: 5268-block 831
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5268-block 832
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5268-block 833
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 5268-block 834
    %%%%%: 5268-block 835
    #####: 5269:            ImVec2 cursor_screen_pos = ImTrunc(draw_pos + cursor_offset - draw_scroll);
    %%%%%: 5269-block 836
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 5270:            ImRect cursor_screen_rect(cursor_screen_pos.x, cursor_screen_pos.y - g.FontSize + 0.5f, cursor_screen_pos.x + 1.0f, cursor_screen_pos.y - 1.5f);
call    0 never executed
    #####: 5271:            if (cursor_is_visible && cursor_screen_rect.Overlaps(clip_rect))
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5271-block 841
call    2 never executed
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 5271-block 844
    %%%%%: 5271-block 845
    %%%%%: 5271-block 846
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 5272:                draw_window->DrawList->AddLine(cursor_screen_rect.Min, cursor_screen_rect.GetBL(), GetColorU32(ImGuiCol_Text));
    %%%%%: 5272-block 847
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 5272-block 848
call    3 never executed
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    %%%%%: 5272-block 850
    $$$$$: 5272-block 921
        -: 5273:
        -: 5274:            // Notify OS of text input position for advanced IME (-1 x offset so that Windows IME can cover our cursor. Bit of an extra nicety.)
    #####: 5275:            if (!is_readonly)
    %%%%%: 5275-block 851
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5276:            {
    #####: 5277:                g.PlatformImeData.WantVisible = true;
    #####: 5278:                g.PlatformImeData.InputPos = ImVec2(cursor_screen_pos.x - 1.0f, cursor_screen_pos.y - g.FontSize);
    %%%%%: 5278-block 852
call    0 never executed
    #####: 5279:                g.PlatformImeData.InputLineHeight = g.FontSize;
    #####: 5280:                g.PlatformImeViewport = window->Viewport->ID;
        -: 5281:            }
        -: 5282:        }
    #####: 5283:    }
    %%%%%: 5283-block 855
        -: 5284:    else
        -: 5285:    {
        -: 5286:        // Render text only (no selection, no cursor)
    27977: 5287:        if (is_multiline)
    27977: 5287-block 856
branch  0 taken 0 (fallthrough)
branch  1 taken 27977
    #####: 5288:            text_size = ImVec2(inner_size.x, InputTextCalcTextLenAndLineCount(buf_display, &buf_display_end) * g.FontSize); // We don't need width
    %%%%%: 5288-block 857
call    0 never executed
call    1 never executed
    27977: 5289:        else if (!is_displaying_hint && g.ActiveId == id)
    27977: 5289-block 860
branch  0 taken 27977 (fallthrough)
branch  1 taken 0
    27977: 5289-block 861
branch  2 taken 0 (fallthrough)
branch  3 taken 27977
    #####: 5290:            buf_display_end = buf_display + state->CurLenA;
    %%%%%: 5290-block 862
    27977: 5291:        else if (!is_displaying_hint)
    27977: 5291-block 863
branch  0 taken 27977 (fallthrough)
branch  1 taken 0
    27977: 5292:            buf_display_end = buf_display + strlen(buf_display);
    27977: 5292-block 864
        -: 5293:
    27977: 5294:        if (is_multiline || (buf_display_end - buf_display) < buf_display_max_length)
    27977: 5294-block 865
branch  0 taken 27977 (fallthrough)
branch  1 taken 0
    27977: 5294-block 866
branch  2 taken 27977 (fallthrough)
branch  3 taken 0
        -: 5295:        {
   27977*: 5296:            ImU32 col = GetColorU32(is_displaying_hint ? ImGuiCol_TextDisabled : ImGuiCol_Text);
    27977: 5296-block 867
branch  0 taken 0 (fallthrough)
branch  1 taken 27977
    %%%%%: 5296-block 868
    27977: 5296-block 869
    27977: 5296-block 870
call    2 returned 27977
branch  3 taken 27977 (fallthrough)
branch  4 taken 0 (throw)
   27977*: 5297:            draw_window->DrawList->AddText(g.Font, g.FontSize, draw_pos, col, buf_display, buf_display_end, 0.0f, is_multiline ? NULL : &clip_rect);
    27977: 5297-block 871
branch  0 taken 0 (fallthrough)
branch  1 taken 27977
    %%%%%: 5297-block 872
    27977: 5297-block 873
    27977: 5297-block 874
call    2 returned 27977
branch  3 taken 27977 (fallthrough)
branch  4 taken 0 (throw)
        -: 5298:        }
        -: 5299:    }
        -: 5300:
   27977*: 5301:    if (is_password && !is_displaying_hint)
    27977: 5301-block 875
branch  0 taken 0 (fallthrough)
branch  1 taken 27977
    %%%%%: 5301-block 876
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 5302:        PopFont();
    %%%%%: 5302-block 877
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5303:
    27977: 5304:    if (is_multiline)
    27977: 5304-block 878
branch  0 taken 0 (fallthrough)
branch  1 taken 27977
        -: 5305:    {
        -: 5306:        // For focus requests to work on our multiline we need to ensure our child ItemAdd() call specifies the ImGuiItemFlags_Inputable (see #4761, #7870)...
    #####: 5307:        Dummy(ImVec2(text_size.x, text_size.y + style.FramePadding.y));
    %%%%%: 5307-block 879
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$: 5307-block 924
    #####: 5308:        g.NextItemData.ItemFlags |= (ImGuiItemFlags)ImGuiItemFlags_Inputable | ImGuiItemFlags_NoTabStop;
    #####: 5309:        EndChild();
    %%%%%: 5309-block 881
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5310:        item_data_backup.StatusFlags |= (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_HoveredWindow);
        -: 5311:
        -: 5312:        // ...and then we need to undo the group overriding last item data, which gets a bit messy as EndGroup() tries to forward scrollbar being active...
        -: 5313:        // FIXME: This quite messy/tricky, should attempt to get rid of the child window.
    #####: 5314:        EndGroup();
    %%%%%: 5314-block 882
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5315:        if (g.LastItemData.ID == 0 || g.LastItemData.ID != GetWindowScrollbarID(draw_window, ImGuiAxis_Y))
    %%%%%: 5315-block 883
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5315-block 884
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 5315-block 885
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 5315-block 886
    %%%%%: 5315-block 887
    %%%%%: 5315-block 888
branch  7 never executed (fallthrough)
branch  8 never executed
        -: 5316:        {
    #####: 5317:            g.LastItemData.ID = id;
    #####: 5318:            g.LastItemData.ItemFlags = item_data_backup.ItemFlags;
    #####: 5319:            g.LastItemData.StatusFlags = item_data_backup.StatusFlags;
    %%%%%: 5319-block 889
        -: 5320:        }
        -: 5321:    }
        -: 5322:
        -: 5323:    // Log as text
   27977*: 5324:    if (g.LogEnabled && (!is_password || is_displaying_hint))
    27977: 5324-block 890
branch  0 taken 0 (fallthrough)
branch  1 taken 27977
    %%%%%: 5324-block 891
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5324-block 892
branch  4 never executed (fallthrough)
branch  5 never executed
        -: 5325:    {
    #####: 5326:        LogSetNextTextDecoration("{", "}");
    %%%%%: 5326-block 893
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5327:        LogRenderedText(&draw_pos, buf_display, buf_display_end);
    %%%%%: 5327-block 894
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5328:    }
        -: 5329:
    27977: 5330:    if (label_size.x > 0)
    27977: 5330-block 895
branch  0 taken 0 (fallthrough)
branch  1 taken 27977
    #####: 5331:        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);
    %%%%%: 5331-block 896
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 5331-block 898
    $$$$$: 5331-block 925
        -: 5332:
    27977: 5333:    if (value_changed)
    27977: 5333-block 899
branch  0 taken 0 (fallthrough)
branch  1 taken 27977
    #####: 5334:        MarkItemEdited(id);
    %%%%%: 5334-block 900
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5335:
        -: 5336:    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags | ImGuiItemStatusFlags_Inputable);
    27977: 5337:    if ((flags & ImGuiInputTextFlags_EnterReturnsTrue) != 0)
    27977: 5337-block 901
branch  0 taken 25824 (fallthrough)
branch  1 taken 2153
    25824: 5338:        return validated;
    25824: 5338-block 902
        -: 5339:    else
     2153: 5340:        return value_changed;
     2153: 5340-block 903
        -: 5341:}
        -: 5342:
function _ZN5ImGui23DebugNodeInputTextStateEP19ImGuiInputTextState called 0 returned 0% blocks executed 0%
    #####: 5343:void ImGui::DebugNodeInputTextState(ImGuiInputTextState* state)
        -: 5344:{
        -: 5345:#ifndef IMGUI_DISABLE_DEBUG_TOOLS
    #####: 5346:    ImGuiContext& g = *GImGui;
    #####: 5347:    ImStb::STB_TexteditState* stb_state = state->Stb;
    #####: 5348:    ImStb::StbUndoState* undo_state = &stb_state->undostate;
    #####: 5349:    Text("ID: 0x%08X, ActiveID: 0x%08X", state->ID, g.ActiveId);
    %%%%%: 5349-block 2
call    0 never executed
    #####: 5350:    DebugLocateItemOnHover(state->ID);
call    0 never executed
    #####: 5351:    Text("CurLenA: %d, Cursor: %d, Selection: %d..%d", state->CurLenA, stb_state->cursor, stb_state->select_start, stb_state->select_end);
call    0 never executed
    #####: 5352:    Text("has_preferred_x: %d (%.2f)", stb_state->has_preferred_x, stb_state->preferred_x);
call    0 never executed
    #####: 5353:    Text("undo_point: %d, redo_point: %d, undo_char_point: %d, redo_char_point: %d", undo_state->undo_point, undo_state->redo_point, undo_state->undo_char_point, undo_state->redo_char_point);
call    0 never executed
    #####: 5354:    if (BeginChild("undopoints", ImVec2(0.0f, GetTextLineHeight() * 10), ImGuiChildFlags_Borders | ImGuiChildFlags_ResizeY)) // Visualize undo state
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 5354-block 8
call    3 never executed
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    %%%%%: 5354-block 10
branch  7 never executed (fallthrough)
branch  8 never executed
    $$$$$: 5354-block 34
call    9 never executed
        -: 5355:    {
    #####: 5356:        PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0, 0));
    %%%%%: 5356-block 11
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####: 5357:        for (int n = 0; n < IMSTB_TEXTEDIT_UNDOSTATECOUNT; n++)
    %%%%%: 5357-block 13
    %%%%%: 5357-block 29
    %%%%%: 5357-block 30
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 5358:        {
    #####: 5359:            ImStb::StbUndoRecord* undo_rec = &undo_state->undo_rec[n];
    #####: 5360:            const char undo_rec_type = (n < undo_state->undo_point) ? 'u' : (n >= undo_state->redo_point) ? 'r' : ' ';
    %%%%%: 5360-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5360-block 15
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5360-block 16
    %%%%%: 5360-block 17
    %%%%%: 5360-block 18
    %%%%%: 5360-block 19
    #####: 5361:            if (undo_rec_type == ' ')
    %%%%%: 5361-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5362:                BeginDisabled();
    %%%%%: 5362-block 21
call    0 never executed
    #####: 5363:            const int buf_preview_len = (undo_rec_type != ' ' && undo_rec->char_storage != -1) ? undo_rec->insert_length : 0;
    %%%%%: 5363-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5363-block 23
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5363-block 24
    %%%%%: 5363-block 25
    #####: 5364:            const char* buf_preview_str = undo_state->undo_char + undo_rec->char_storage;
    #####: 5365:            Text("%c [%02d] where %03d, insert %03d, delete %03d, char_storage %03d \"%.*s\"",
    %%%%%: 5365-block 26
call    0 never executed
        -: 5366:                undo_rec_type, n, undo_rec->where, undo_rec->insert_length, undo_rec->delete_length, undo_rec->char_storage, buf_preview_len, buf_preview_str);
    #####: 5367:            if (undo_rec_type == ' ')
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5368:                EndDisabled();
    %%%%%: 5368-block 28
call    0 never executed
        -: 5369:        }
    #####: 5370:        PopStyleVar();
    %%%%%: 5370-block 31
call    0 never executed
        -: 5371:    }
    #####: 5372:    EndChild();
    %%%%%: 5372-block 32
call    0 never executed
        -: 5373:#else
        -: 5374:    IM_UNUSED(state);
        -: 5375:#endif
    #####: 5376:}
        -: 5377:
        -: 5378://-------------------------------------------------------------------------
        -: 5379:// [SECTION] Widgets: ColorEdit, ColorPicker, ColorButton, etc.
        -: 5380://-------------------------------------------------------------------------
        -: 5381:// - ColorEdit3()
        -: 5382:// - ColorEdit4()
        -: 5383:// - ColorPicker3()
        -: 5384:// - RenderColorRectWithAlphaCheckerboard() [Internal]
        -: 5385:// - ColorPicker4()
        -: 5386:// - ColorButton()
        -: 5387:// - SetColorEditOptions()
        -: 5388:// - ColorTooltip() [Internal]
        -: 5389:// - ColorEditOptionsPopup() [Internal]
        -: 5390:// - ColorPickerOptionsPopup() [Internal]
        -: 5391://-------------------------------------------------------------------------
        -: 5392:
function _ZN5ImGui10ColorEdit3EPKcPfi called 0 returned 0% blocks executed 0%
    #####: 5393:bool ImGui::ColorEdit3(const char* label, float col[3], ImGuiColorEditFlags flags)
        -: 5394:{
    #####: 5395:    return ColorEdit4(label, col, flags | ImGuiColorEditFlags_NoAlpha);
    %%%%%: 5395-block 2
call    0 never executed
        -: 5396:}
        -: 5397:
function _ZL17ColorEditRestoreHPKfPf called 0 returned 0% blocks executed 0%
    #####: 5398:static void ColorEditRestoreH(const float* col, float* H)
        -: 5399:{
    #####: 5400:    ImGuiContext& g = *GImGui;
    #####: 5401:    IM_ASSERT(g.ColorEditCurrentID != 0);
    %%%%%: 5401-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5401-block 3
call    2 never executed
    #####: 5402:    if (g.ColorEditSavedID != g.ColorEditCurrentID || g.ColorEditSavedColor != ImGui::ColorConvertFloat4ToU32(ImVec4(col[0], col[1], col[2], 0)))
    %%%%%: 5402-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5402-block 5
call    2 never executed
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    %%%%%: 5402-block 7
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 5402-block 8
    %%%%%: 5402-block 9
    %%%%%: 5402-block 10
branch  8 never executed (fallthrough)
branch  9 never executed
    #####: 5403:        return;
    %%%%%: 5403-block 11
    #####: 5404:    *H = g.ColorEditSavedHue;
    %%%%%: 5404-block 12
        -: 5405:}
        -: 5406:
        -: 5407:// ColorEdit supports RGB and HSV inputs. In case of RGB input resulting color may have undefined hue and/or saturation.
        -: 5408:// Since widget displays both RGB and HSV values we must preserve hue and saturation to prevent these values resetting.
function _ZL18ColorEditRestoreHSPKfPfS1_S1_ called 0 returned 0% blocks executed 0%
    #####: 5409:static void ColorEditRestoreHS(const float* col, float* H, float* S, float* V)
        -: 5410:{
    #####: 5411:    ImGuiContext& g = *GImGui;
    #####: 5412:    IM_ASSERT(g.ColorEditCurrentID != 0);
    %%%%%: 5412-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5412-block 3
call    2 never executed
    #####: 5413:    if (g.ColorEditSavedID != g.ColorEditCurrentID || g.ColorEditSavedColor != ImGui::ColorConvertFloat4ToU32(ImVec4(col[0], col[1], col[2], 0)))
    %%%%%: 5413-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5413-block 5
call    2 never executed
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    %%%%%: 5413-block 7
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 5413-block 8
    %%%%%: 5413-block 9
    %%%%%: 5413-block 10
branch  8 never executed (fallthrough)
branch  9 never executed
    #####: 5414:        return;
    %%%%%: 5414-block 11
        -: 5415:
        -: 5416:    // When S == 0, H is undefined.
        -: 5417:    // When H == 1 it wraps around to 0.
    #####: 5418:    if (*S == 0.0f || (*H == 0.0f && g.ColorEditSavedHue == 1))
    %%%%%: 5418-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5418-block 13
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5418-block 14
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 5419:        *H = g.ColorEditSavedHue;
    %%%%%: 5419-block 15
        -: 5420:
        -: 5421:    // When V == 0, S is undefined.
    #####: 5422:    if (*V == 0.0f)
    %%%%%: 5422-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5423:        *S = g.ColorEditSavedSat;
    %%%%%: 5423-block 17
        -: 5424:}
        -: 5425:
        -: 5426:// Edit colors components (each component in 0.0f..1.0f range).
        -: 5427:// See enum ImGuiColorEditFlags_ for available options. e.g. Only access 3 floats if ImGuiColorEditFlags_NoAlpha flag is set.
        -: 5428:// With typical options: Left-click on color square to open color picker. Right-click to open option menu. CTRL-Click over input fields to edit them and TAB to go to next item.
function _ZN5ImGui10ColorEdit4EPKcPfi called 0 returned 0% blocks executed 0%
    #####: 5429:bool ImGui::ColorEdit4(const char* label, float col[4], ImGuiColorEditFlags flags)
        -: 5430:{
    #####: 5431:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%: 5431-block 2
call    0 never executed
    #####: 5432:    if (window->SkipItems)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5433:        return false;
    %%%%%: 5433-block 4
        -: 5434:
    #####: 5435:    ImGuiContext& g = *GImGui;
    #####: 5436:    const ImGuiStyle& style = g.Style;
    #####: 5437:    const float square_sz = GetFrameHeight();
    %%%%%: 5437-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5438:    const char* label_display_end = FindRenderedTextEnd(label);
    %%%%%: 5438-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5439:    float w_full = CalcItemWidth();
    %%%%%: 5439-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5440:    g.NextItemData.ClearFlags();
    %%%%%: 5440-block 8
call    0 never executed
        -: 5441:
    #####: 5442:    BeginGroup();
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5443:    PushID(label);
    %%%%%: 5443-block 10
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5444:    const bool set_current_color_edit_id = (g.ColorEditCurrentID == 0);
    #####: 5445:    if (set_current_color_edit_id)
    %%%%%: 5445-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5446:        g.ColorEditCurrentID = window->IDStack.back();
    %%%%%: 5446-block 12
call    0 never executed
        -: 5447:
        -: 5448:    // If we're not showing any slider there's no point in doing any HSV conversions
    #####: 5449:    const ImGuiColorEditFlags flags_untouched = flags;
    #####: 5450:    if (flags & ImGuiColorEditFlags_NoInputs)
    %%%%%: 5450-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5451:        flags = (flags & (~ImGuiColorEditFlags_DisplayMask_)) | ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_NoOptions;
    %%%%%: 5451-block 15
        -: 5452:
        -: 5453:    // Context menu: display and modify options (before defaults are applied)
    #####: 5454:    if (!(flags & ImGuiColorEditFlags_NoOptions))
    %%%%%: 5454-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5455:        ColorEditOptionsPopup(col, flags);
    %%%%%: 5455-block 17
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5456:
        -: 5457:    // Read stored options
    #####: 5458:    if (!(flags & ImGuiColorEditFlags_DisplayMask_))
    %%%%%: 5458-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5459:        flags |= (g.ColorEditOptions & ImGuiColorEditFlags_DisplayMask_);
    %%%%%: 5459-block 19
    #####: 5460:    if (!(flags & ImGuiColorEditFlags_DataTypeMask_))
    %%%%%: 5460-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5461:        flags |= (g.ColorEditOptions & ImGuiColorEditFlags_DataTypeMask_);
    %%%%%: 5461-block 21
    #####: 5462:    if (!(flags & ImGuiColorEditFlags_PickerMask_))
    %%%%%: 5462-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5463:        flags |= (g.ColorEditOptions & ImGuiColorEditFlags_PickerMask_);
    %%%%%: 5463-block 23
    #####: 5464:    if (!(flags & ImGuiColorEditFlags_InputMask_))
    %%%%%: 5464-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5465:        flags |= (g.ColorEditOptions & ImGuiColorEditFlags_InputMask_);
    %%%%%: 5465-block 25
    #####: 5466:    flags |= (g.ColorEditOptions & ~(ImGuiColorEditFlags_DisplayMask_ | ImGuiColorEditFlags_DataTypeMask_ | ImGuiColorEditFlags_PickerMask_ | ImGuiColorEditFlags_InputMask_));
    #####: 5467:    IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags_DisplayMask_)); // Check that only 1 is selected
    %%%%%: 5467-block 26
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 5467-block 28
call    3 never executed
    #####: 5468:    IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags_InputMask_));   // Check that only 1 is selected
    %%%%%: 5468-block 29
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 5468-block 31
call    3 never executed
        -: 5469:
    #####: 5470:    const bool alpha = (flags & ImGuiColorEditFlags_NoAlpha) == 0;
    #####: 5471:    const bool hdr = (flags & ImGuiColorEditFlags_HDR) != 0;
    #####: 5472:    const int components = alpha ? 4 : 3;
    %%%%%: 5472-block 32
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5472-block 33
    %%%%%: 5472-block 34
    #####: 5473:    const float w_button = (flags & ImGuiColorEditFlags_NoSmallPreview) ? 0.0f : (square_sz + style.ItemInnerSpacing.x);
    %%%%%: 5473-block 35
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5473-block 36
    %%%%%: 5473-block 37
    #####: 5474:    const float w_inputs = ImMax(w_full - w_button, 1.0f);
    %%%%%: 5474-block 38
call    0 never executed
    #####: 5475:    w_full = w_inputs + w_button;
        -: 5476:
        -: 5477:    // Convert to the formats we need
    #####: 5478:    float f[4] = { col[0], col[1], col[2], alpha ? col[3] : 1.0f };
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5478-block 40
    %%%%%: 5478-block 41
    #####: 5479:    if ((flags & ImGuiColorEditFlags_InputHSV) && (flags & ImGuiColorEditFlags_DisplayRGB))
    %%%%%: 5479-block 42
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5479-block 43
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 5480:        ColorConvertHSVtoRGB(f[0], f[1], f[2], f[0], f[1], f[2]);
    %%%%%: 5480-block 44
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5481:    else if ((flags & ImGuiColorEditFlags_InputRGB) && (flags & ImGuiColorEditFlags_DisplayHSV))
    %%%%%: 5481-block 46
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5481-block 47
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 5482:    {
        -: 5483:        // Hue is lost when converting from grayscale rgb (saturation=0). Restore it.
    #####: 5484:        ColorConvertRGBtoHSV(f[0], f[1], f[2], f[0], f[1], f[2]);
    %%%%%: 5484-block 48
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5485:        ColorEditRestoreHS(col, &f[0], &f[1], &f[2]);
    %%%%%: 5485-block 49
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5486:    }
    #####: 5487:    int i[4] = { IM_F32_TO_INT8_UNBOUND(f[0]), IM_F32_TO_INT8_UNBOUND(f[1]), IM_F32_TO_INT8_UNBOUND(f[2]), IM_F32_TO_INT8_UNBOUND(f[3]) };
    %%%%%: 5487-block 50
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5487-block 51
    %%%%%: 5487-block 52
    %%%%%: 5487-block 53
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5487-block 54
    %%%%%: 5487-block 55
    %%%%%: 5487-block 56
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 5487-block 57
    %%%%%: 5487-block 58
    %%%%%: 5487-block 59
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 5487-block 60
    %%%%%: 5487-block 61
        -: 5488:
    #####: 5489:    bool value_changed = false;
    #####: 5490:    bool value_changed_as_float = false;
        -: 5491:
    #####: 5492:    const ImVec2 pos = window->DC.CursorPos;
    #####: 5493:    const float inputs_offset_x = (style.ColorButtonPosition == ImGuiDir_Left) ? w_button : 0.0f;
    %%%%%: 5493-block 62
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5493-block 63
    %%%%%: 5493-block 64
    #####: 5494:    window->DC.CursorPos.x = pos.x + inputs_offset_x;
        -: 5495:
    #####: 5496:    if ((flags & (ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_DisplayHSV)) != 0 && (flags & ImGuiColorEditFlags_NoInputs) == 0)
    %%%%%: 5496-block 65
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5496-block 66
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 5497:    {
        -: 5498:        // RGB/HSV 0..255 Sliders
    #####: 5499:        const float w_items = w_inputs - style.ItemInnerSpacing.x * (components - 1);
        -: 5500:
    #####: 5501:        const bool hide_prefix = (IM_TRUNC(w_items / components) <= CalcTextSize((flags & ImGuiColorEditFlags_Float) ? "M:0.000" : "M:000").x);
    %%%%%: 5501-block 67
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5501-block 68
    %%%%%: 5501-block 69
    %%%%%: 5501-block 70
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
        -: 5502:        static const char* ids[4] = { "##X", "##Y", "##Z", "##W" };
        -: 5503:        static const char* fmt_table_int[3][4] =
        -: 5504:        {
        -: 5505:            {   "%3d",   "%3d",   "%3d",   "%3d" }, // Short display
        -: 5506:            { "R:%3d", "G:%3d", "B:%3d", "A:%3d" }, // Long display for RGBA
        -: 5507:            { "H:%3d", "S:%3d", "V:%3d", "A:%3d" }  // Long display for HSVA
        -: 5508:        };
        -: 5509:        static const char* fmt_table_float[3][4] =
        -: 5510:        {
        -: 5511:            {   "%0.3f",   "%0.3f",   "%0.3f",   "%0.3f" }, // Short display
        -: 5512:            { "R:%0.3f", "G:%0.3f", "B:%0.3f", "A:%0.3f" }, // Long display for RGBA
        -: 5513:            { "H:%0.3f", "S:%0.3f", "V:%0.3f", "A:%0.3f" }  // Long display for HSVA
        -: 5514:        };
    #####: 5515:        const int fmt_idx = hide_prefix ? 0 : (flags & ImGuiColorEditFlags_DisplayHSV) ? 2 : 1;
    %%%%%: 5515-block 71
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5515-block 72
    %%%%%: 5515-block 73
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5515-block 74
    %%%%%: 5515-block 75
    %%%%%: 5515-block 76
        -: 5516:
    #####: 5517:        float prev_split = 0.0f;
    #####: 5518:        for (int n = 0; n < components; n++)
    %%%%%: 5518-block 77
    %%%%%: 5518-block 95
    %%%%%: 5518-block 96
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 5519:        {
    #####: 5520:            if (n > 0)
    %%%%%: 5520-block 78
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5521:                SameLine(0, style.ItemInnerSpacing.x);
    %%%%%: 5521-block 79
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5522:            float next_split = IM_TRUNC(w_items * (n + 1) / components);
    #####: 5523:            SetNextItemWidth(ImMax(next_split - prev_split, 1.0f));
    %%%%%: 5523-block 80
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####: 5524:            prev_split = next_split;
        -: 5525:
        -: 5526:            // FIXME: When ImGuiColorEditFlags_HDR flag is passed HS values snap in weird ways when SV values go below 0.
    #####: 5527:            if (flags & ImGuiColorEditFlags_Float)
    %%%%%: 5527-block 82
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5528:            {
    #####: 5529:                value_changed |= DragFloat(ids[n], &f[n], 1.0f / 255.0f, 0.0f, hdr ? 0.0f : 1.0f, fmt_table_float[fmt_idx][n]);
    %%%%%: 5529-block 83
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5529-block 84
    %%%%%: 5529-block 85
    %%%%%: 5529-block 86
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####: 5530:                value_changed_as_float |= value_changed;
    %%%%%: 5530-block 87
        -: 5531:            }
        -: 5532:            else
        -: 5533:            {
    #####: 5534:                value_changed |= DragInt(ids[n], &i[n], 1.0f, 0, hdr ? 0 : 255, fmt_table_int[fmt_idx][n]);
    %%%%%: 5534-block 88
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5534-block 89
    %%%%%: 5534-block 90
    %%%%%: 5534-block 91
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 5534-block 92
        -: 5535:            }
    #####: 5536:            if (!(flags & ImGuiColorEditFlags_NoOptions))
    %%%%%: 5536-block 93
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5537:                OpenPopupOnItemClick("context", ImGuiPopupFlags_MouseButtonRight);
    %%%%%: 5537-block 94
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5538:        }
    #####: 5539:    }
    %%%%%: 5539-block 97
    #####: 5540:    else if ((flags & ImGuiColorEditFlags_DisplayHex) != 0 && (flags & ImGuiColorEditFlags_NoInputs) == 0)
    %%%%%: 5540-block 98
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5540-block 99
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 5541:    {
        -: 5542:        // RGB Hexadecimal Input
        -: 5543:        char buf[64];
    #####: 5544:        if (alpha)
    %%%%%: 5544-block 100
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5545:            ImFormatString(buf, IM_ARRAYSIZE(buf), "#%02X%02X%02X%02X", ImClamp(i[0], 0, 255), ImClamp(i[1], 0, 255), ImClamp(i[2], 0, 255), ImClamp(i[3], 0, 255));
    %%%%%: 5545-block 101
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
        -: 5546:        else
    #####: 5547:            ImFormatString(buf, IM_ARRAYSIZE(buf), "#%02X%02X%02X", ImClamp(i[0], 0, 255), ImClamp(i[1], 0, 255), ImClamp(i[2], 0, 255));
    %%%%%: 5547-block 106
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    #####: 5548:        SetNextItemWidth(w_inputs);
    %%%%%: 5548-block 110
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5549:        if (InputText("##Text", buf, IM_ARRAYSIZE(buf), ImGuiInputTextFlags_CharsUppercase))
    %%%%%: 5549-block 111
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 5549-block 112
branch  3 never executed (fallthrough)
branch  4 never executed
        -: 5550:        {
    #####: 5551:            value_changed = true;
    #####: 5552:            char* p = buf;
    #####: 5553:            while (*p == '#' || ImCharIsBlankA(*p))
    %%%%%: 5553-block 113
    %%%%%: 5553-block 115
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5553-block 116
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 5553-block 118
    %%%%%: 5553-block 119
    %%%%%: 5553-block 120
branch  5 never executed
branch  6 never executed (fallthrough)
    #####: 5554:                p++;
    %%%%%: 5554-block 114
    #####: 5555:            i[0] = i[1] = i[2] = 0;
    #####: 5556:            i[3] = 0xFF; // alpha default to 255 is not parsed by scanf (e.g. inputting #FFFFFF omitting alpha)
        -: 5557:            int r;
    #####: 5558:            if (alpha)
    %%%%%: 5558-block 121
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5559:                r = sscanf(p, "%02X%02X%02X%02X", (unsigned int*)&i[0], (unsigned int*)&i[1], (unsigned int*)&i[2], (unsigned int*)&i[3]); // Treat at unsigned (%X is unsigned)
    %%%%%: 5559-block 122
        -: 5560:            else
    #####: 5561:                r = sscanf(p, "%02X%02X%02X", (unsigned int*)&i[0], (unsigned int*)&i[1], (unsigned int*)&i[2]);
    %%%%%: 5561-block 123
        -: 5562:            IM_UNUSED(r); // Fixes C6031: Return value ignored: 'sscanf'.
        -: 5563:        }
    #####: 5564:        if (!(flags & ImGuiColorEditFlags_NoOptions))
    %%%%%: 5564-block 124
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5565:            OpenPopupOnItemClick("context", ImGuiPopupFlags_MouseButtonRight);
    %%%%%: 5565-block 125
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5566:    }
        -: 5567:
    #####: 5568:    ImGuiWindow* picker_active_window = NULL;
    #####: 5569:    if (!(flags & ImGuiColorEditFlags_NoSmallPreview))
    %%%%%: 5569-block 127
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5570:    {
    #####: 5571:        const float button_offset_x = ((flags & ImGuiColorEditFlags_NoInputs) || (style.ColorButtonPosition == ImGuiDir_Left)) ? 0.0f : w_inputs + style.ItemInnerSpacing.x;
    %%%%%: 5571-block 128
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5571-block 129
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5571-block 130
    %%%%%: 5571-block 131
    #####: 5572:        window->DC.CursorPos = ImVec2(pos.x + button_offset_x, pos.y);
    %%%%%: 5572-block 132
call    0 never executed
        -: 5573:
    #####: 5574:        const ImVec4 col_v4(col[0], col[1], col[2], alpha ? col[3] : 1.0f);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5574-block 134
    %%%%%: 5574-block 135
    %%%%%: 5574-block 136
call    2 never executed
    #####: 5575:        if (ColorButton("##ColorButton", col_v4, flags))
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 5575-block 139
branch  4 never executed (fallthrough)
branch  5 never executed
    $$$$$: 5575-block 218
        -: 5576:        {
    #####: 5577:            if (!(flags & ImGuiColorEditFlags_NoPicker))
    %%%%%: 5577-block 140
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5578:            {
        -: 5579:                // Store current color and open a picker
    #####: 5580:                g.ColorPickerRef = col_v4;
    #####: 5581:                OpenPopup("picker");
    %%%%%: 5581-block 141
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5582:                SetNextWindowPos(g.LastItemData.Rect.GetBL() + ImVec2(0.0f, style.ItemSpacing.y));
    %%%%%: 5582-block 142
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    %%%%%: 5582-block 147
    $$$$$: 5582-block 219
    $$$$$: 5582-block 220
    $$$$$: 5582-block 221
    $$$$$: 5582-block 222
        -: 5583:            }
        -: 5584:        }
    #####: 5585:        if (!(flags & ImGuiColorEditFlags_NoOptions))
    %%%%%: 5585-block 148
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5586:            OpenPopupOnItemClick("context", ImGuiPopupFlags_MouseButtonRight);
    %%%%%: 5586-block 149
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5587:
    #####: 5588:        if (BeginPopup("picker"))
    %%%%%: 5588-block 150
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 5588-block 151
branch  3 never executed (fallthrough)
branch  4 never executed
        -: 5589:        {
    #####: 5590:            if (g.CurrentWindow->BeginCount == 1)
    %%%%%: 5590-block 152
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5591:            {
    #####: 5592:                picker_active_window = g.CurrentWindow;
    #####: 5593:                if (label != label_display_end)
    %%%%%: 5593-block 153
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5594:                {
    #####: 5595:                    TextEx(label, label_display_end);
    %%%%%: 5595-block 154
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5596:                    Spacing();
    %%%%%: 5596-block 155
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5597:                }
    #####: 5598:                ImGuiColorEditFlags picker_flags_to_forward = ImGuiColorEditFlags_DataTypeMask_ | ImGuiColorEditFlags_PickerMask_ | ImGuiColorEditFlags_InputMask_ | ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaBar;
    #####: 5599:                ImGuiColorEditFlags picker_flags = (flags_untouched & picker_flags_to_forward) | ImGuiColorEditFlags_DisplayMask_ | ImGuiColorEditFlags_NoLabel | ImGuiColorEditFlags_AlphaPreviewHalf;
    #####: 5600:                SetNextItemWidth(square_sz * 12.0f); // Use 256 + bar sizes?
    %%%%%: 5600-block 156
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5601:                value_changed |= ColorPicker4("##picker", col, picker_flags, &g.ColorPickerRef.x);
    %%%%%: 5601-block 157
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 5601-block 158
        -: 5602:            }
    #####: 5603:            EndPopup();
    %%%%%: 5603-block 159
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5604:        }
        -: 5605:    }
        -: 5606:
    #####: 5607:    if (label != label_display_end && !(flags & ImGuiColorEditFlags_NoLabel))
    %%%%%: 5607-block 161
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5607-block 162
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 5608:    {
        -: 5609:        // Position not necessarily next to last submitted button (e.g. if style.ColorButtonPosition == ImGuiDir_Left),
        -: 5610:        // but we need to use SameLine() to setup baseline correctly. Might want to refactor SameLine() to simplify this.
    #####: 5611:        SameLine(0.0f, style.ItemInnerSpacing.x);
    %%%%%: 5611-block 163
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5612:        window->DC.CursorPos.x = pos.x + ((flags & ImGuiColorEditFlags_NoInputs) ? w_button : w_full + style.ItemInnerSpacing.x);
    %%%%%: 5612-block 164
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5612-block 165
    %%%%%: 5612-block 166
    #####: 5613:        TextEx(label, label_display_end);
    %%%%%: 5613-block 167
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5614:    }
        -: 5615:
        -: 5616:    // Convert back
    #####: 5617:    if (value_changed && picker_active_window == NULL)
    %%%%%: 5617-block 168
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5617-block 169
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 5618:    {
    #####: 5619:        if (!value_changed_as_float)
    %%%%%: 5619-block 170
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5620:            for (int n = 0; n < 4; n++)
    %%%%%: 5620-block 171
    %%%%%: 5620-block 173
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 5621:                f[n] = i[n] / 255.0f;
    %%%%%: 5621-block 172
    #####: 5622:        if ((flags & ImGuiColorEditFlags_DisplayHSV) && (flags & ImGuiColorEditFlags_InputRGB))
    %%%%%: 5622-block 174
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5622-block 175
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 5623:        {
    #####: 5624:            g.ColorEditSavedHue = f[0];
    #####: 5625:            g.ColorEditSavedSat = f[1];
    #####: 5626:            ColorConvertHSVtoRGB(f[0], f[1], f[2], f[0], f[1], f[2]);
    %%%%%: 5626-block 176
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5627:            g.ColorEditSavedID = g.ColorEditCurrentID;
    #####: 5628:            g.ColorEditSavedColor = ColorConvertFloat4ToU32(ImVec4(f[0], f[1], f[2], 0));
    %%%%%: 5628-block 177
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 5628-block 179
    $$$$$: 5628-block 224
        -: 5629:        }
    #####: 5630:        if ((flags & ImGuiColorEditFlags_DisplayRGB) && (flags & ImGuiColorEditFlags_InputHSV))
    %%%%%: 5630-block 180
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5630-block 181
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 5631:            ColorConvertRGBtoHSV(f[0], f[1], f[2], f[0], f[1], f[2]);
    %%%%%: 5631-block 182
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5632:
    #####: 5633:        col[0] = f[0];
    #####: 5634:        col[1] = f[1];
    #####: 5635:        col[2] = f[2];
    #####: 5636:        if (alpha)
    %%%%%: 5636-block 183
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5637:            col[3] = f[3];
    %%%%%: 5637-block 184
        -: 5638:    }
        -: 5639:
    #####: 5640:    if (set_current_color_edit_id)
    %%%%%: 5640-block 185
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5641:        g.ColorEditCurrentID = 0;
    %%%%%: 5641-block 186
    #####: 5642:    PopID();
    %%%%%: 5642-block 187
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5643:    EndGroup();
    %%%%%: 5643-block 188
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5644:
        -: 5645:    // Drag and Drop Target
        -: 5646:    // NB: The flag test is merely an optional micro-optimization, BeginDragDropTarget() does the same test.
    #####: 5647:    if ((g.LastItemData.StatusFlags & ImGuiItemStatusFlags_HoveredRect) && !(g.LastItemData.ItemFlags & ImGuiItemFlags_ReadOnly) && !(flags & ImGuiColorEditFlags_NoDragDrop) && BeginDragDropTarget())
    %%%%%: 5647-block 189
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5647-block 190
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5647-block 191
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 5647-block 192
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed (throw)
    %%%%%: 5647-block 193
branch  9 never executed (fallthrough)
branch 10 never executed
    %%%%%: 5647-block 194
    %%%%%: 5647-block 195
    %%%%%: 5647-block 196
branch 11 never executed (fallthrough)
branch 12 never executed
        -: 5648:    {
    #####: 5649:        bool accepted_drag_drop = false;
    #####: 5650:        if (const ImGuiPayload* payload = AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_3F))
    %%%%%: 5650-block 197
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 5650-block 198
branch  3 never executed (fallthrough)
branch  4 never executed
        -: 5651:        {
    #####: 5652:            memcpy((float*)col, payload->Data, sizeof(float) * 3); // Preserve alpha if any //-V512 //-V1086
    #####: 5653:            value_changed = accepted_drag_drop = true;
    %%%%%: 5653-block 199
        -: 5654:        }
    #####: 5655:        if (const ImGuiPayload* payload = AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_4F))
    %%%%%: 5655-block 200
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 5655-block 201
branch  3 never executed (fallthrough)
branch  4 never executed
        -: 5656:        {
    #####: 5657:            memcpy((float*)col, payload->Data, sizeof(float) * components);
    #####: 5658:            value_changed = accepted_drag_drop = true;
    %%%%%: 5658-block 202
        -: 5659:        }
        -: 5660:
        -: 5661:        // Drag-drop payloads are always RGB
    #####: 5662:        if (accepted_drag_drop && (flags & ImGuiColorEditFlags_InputHSV))
    %%%%%: 5662-block 203
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5662-block 204
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 5663:            ColorConvertRGBtoHSV(col[0], col[1], col[2], col[0], col[1], col[2]);
    %%%%%: 5663-block 205
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5664:        EndDragDropTarget();
    %%%%%: 5664-block 206
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5665:    }
        -: 5666:
        -: 5667:    // When picker is being actively used, use its active id so IsItemActive() will function on ColorEdit4().
    #####: 5668:    if (picker_active_window && g.ActiveId != 0 && g.ActiveIdWindow == picker_active_window)
    %%%%%: 5668-block 207
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5668-block 208
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5668-block 209
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 5669:        g.LastItemData.ID = g.ActiveId;
    %%%%%: 5669-block 210
        -: 5670:
    #####: 5671:    if (value_changed && g.LastItemData.ID != 0) // In case of ID collision, the second EndGroup() won't catch g.ActiveId
    %%%%%: 5671-block 211
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5671-block 212
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 5672:        MarkItemEdited(g.LastItemData.ID);
    %%%%%: 5672-block 213
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5673:
    #####: 5674:    return value_changed;
    %%%%%: 5674-block 214
        -: 5675:}
        -: 5676:
function _ZN5ImGui12ColorPicker3EPKcPfi called 0 returned 0% blocks executed 0%
    #####: 5677:bool ImGui::ColorPicker3(const char* label, float col[3], ImGuiColorEditFlags flags)
        -: 5678:{
    #####: 5679:    float col4[4] = { col[0], col[1], col[2], 1.0f };
    #####: 5680:    if (!ColorPicker4(label, col4, flags | ImGuiColorEditFlags_NoAlpha))
    %%%%%: 5680-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 5680-block 3
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 5681:        return false;
    %%%%%: 5681-block 4
    #####: 5682:    col[0] = col4[0]; col[1] = col4[1]; col[2] = col4[2];
    #####: 5683:    return true;
    %%%%%: 5683-block 5
        -: 5684:}
        -: 5685:
        -: 5686:// Helper for ColorPicker4()
function _ZL26RenderArrowsForVerticalBarP10ImDrawList6ImVec2S1_ff called 0 returned 0% blocks executed 0%
    #####: 5687:static void RenderArrowsForVerticalBar(ImDrawList* draw_list, ImVec2 pos, ImVec2 half_sz, float bar_w, float alpha)
        -: 5688:{
    #####: 5689:    ImU32 alpha8 = IM_F32_TO_INT8_SAT(alpha);
    %%%%%: 5689-block 2
call    0 never executed
    #####: 5690:    ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + half_sz.x + 1,         pos.y), ImVec2(half_sz.x + 2, half_sz.y + 1), ImGuiDir_Right, IM_COL32(0,0,0,alpha8));
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    $$$$$: 5690-block 14
    $$$$$: 5690-block 15
call    5 never executed
    #####: 5691:    ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + half_sz.x,             pos.y), half_sz,                              ImGuiDir_Right, IM_COL32(255,255,255,alpha8));
    %%%%%: 5691-block 6
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$: 5691-block 16
call    4 never executed
    #####: 5692:    ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + bar_w - half_sz.x - 1, pos.y), ImVec2(half_sz.x + 2, half_sz.y + 1), ImGuiDir_Left,  IM_COL32(0,0,0,alpha8));
    %%%%%: 5692-block 8
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    $$$$$: 5692-block 17
    $$$$$: 5692-block 18
call    5 never executed
    #####: 5693:    ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + bar_w - half_sz.x,     pos.y), half_sz,                              ImGuiDir_Left,  IM_COL32(255,255,255,alpha8));
    %%%%%: 5693-block 11
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####: 5694:}
    %%%%%: 5694-block 13
        -: 5695:
        -: 5696:// Note: ColorPicker4() only accesses 3 floats if ImGuiColorEditFlags_NoAlpha flag is set.
        -: 5697:// (In C++ the 'float col[4]' notation for a function argument is equivalent to 'float* col', we only specify a size to facilitate understanding of the code.)
        -: 5698:// FIXME: we adjust the big color square height based on item width, which may cause a flickering feedback loop (if automatic height makes a vertical scrollbar appears, affecting automatic width..)
        -: 5699:// FIXME: this is trying to be aware of style.Alpha but not fully correct. Also, the color wheel will have overlapping glitches with (style.Alpha < 1.0)
function _ZN5ImGui12ColorPicker4EPKcPfiPKf called 0 returned 0% blocks executed 0%
    #####: 5700:bool ImGui::ColorPicker4(const char* label, float col[4], ImGuiColorEditFlags flags, const float* ref_col)
        -: 5701:{
    #####: 5702:    ImGuiContext& g = *GImGui;
    #####: 5703:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%: 5703-block 2
call    0 never executed
    #####: 5704:    if (window->SkipItems)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5705:        return false;
    %%%%%: 5705-block 4
        -: 5706:
    #####: 5707:    ImDrawList* draw_list = window->DrawList;
    #####: 5708:    ImGuiStyle& style = g.Style;
    #####: 5709:    ImGuiIO& io = g.IO;
        -: 5710:
    #####: 5711:    const float width = CalcItemWidth();
    %%%%%: 5711-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5712:    const bool is_readonly = ((g.NextItemData.ItemFlags | g.CurrentItemFlags) & ImGuiItemFlags_ReadOnly) != 0;
    #####: 5713:    g.NextItemData.ClearFlags();
    %%%%%: 5713-block 6
call    0 never executed
        -: 5714:
    #####: 5715:    PushID(label);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5716:    const bool set_current_color_edit_id = (g.ColorEditCurrentID == 0);
    #####: 5717:    if (set_current_color_edit_id)
    %%%%%: 5717-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5718:        g.ColorEditCurrentID = window->IDStack.back();
    %%%%%: 5718-block 9
call    0 never executed
    #####: 5719:    BeginGroup();
    %%%%%: 5719-block 11
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5720:
    #####: 5721:    if (!(flags & ImGuiColorEditFlags_NoSidePreview))
    %%%%%: 5721-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5722:        flags |= ImGuiColorEditFlags_NoSmallPreview;
    %%%%%: 5722-block 13
        -: 5723:
        -: 5724:    // Context menu: display and store options.
    #####: 5725:    if (!(flags & ImGuiColorEditFlags_NoOptions))
    %%%%%: 5725-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5726:        ColorPickerOptionsPopup(col, flags);
    %%%%%: 5726-block 15
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5727:
        -: 5728:    // Read stored options
    #####: 5729:    if (!(flags & ImGuiColorEditFlags_PickerMask_))
    %%%%%: 5729-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5730:        flags |= ((g.ColorEditOptions & ImGuiColorEditFlags_PickerMask_) ? g.ColorEditOptions : ImGuiColorEditFlags_DefaultOptions_) & ImGuiColorEditFlags_PickerMask_;
    %%%%%: 5730-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5730-block 18
    %%%%%: 5730-block 19
    %%%%%: 5730-block 20
    #####: 5731:    if (!(flags & ImGuiColorEditFlags_InputMask_))
    %%%%%: 5731-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5732:        flags |= ((g.ColorEditOptions & ImGuiColorEditFlags_InputMask_) ? g.ColorEditOptions : ImGuiColorEditFlags_DefaultOptions_) & ImGuiColorEditFlags_InputMask_;
    %%%%%: 5732-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5732-block 23
    %%%%%: 5732-block 24
    %%%%%: 5732-block 25
    #####: 5733:    IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags_PickerMask_)); // Check that only 1 is selected
    %%%%%: 5733-block 26
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 5733-block 28
call    3 never executed
    #####: 5734:    IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags_InputMask_));  // Check that only 1 is selected
    %%%%%: 5734-block 29
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 5734-block 31
call    3 never executed
    #####: 5735:    if (!(flags & ImGuiColorEditFlags_NoOptions))
    %%%%%: 5735-block 32
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5736:        flags |= (g.ColorEditOptions & ImGuiColorEditFlags_AlphaBar);
    %%%%%: 5736-block 33
        -: 5737:
        -: 5738:    // Setup
    #####: 5739:    int components = (flags & ImGuiColorEditFlags_NoAlpha) ? 3 : 4;
    %%%%%: 5739-block 34
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5739-block 35
    %%%%%: 5739-block 36
    #####: 5740:    bool alpha_bar = (flags & ImGuiColorEditFlags_AlphaBar) && !(flags & ImGuiColorEditFlags_NoAlpha);
    %%%%%: 5740-block 37
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5740-block 38
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5740-block 39
    %%%%%: 5740-block 40
    #####: 5741:    ImVec2 picker_pos = window->DC.CursorPos;
    #####: 5742:    float square_sz = GetFrameHeight();
    %%%%%: 5742-block 41
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5743:    float bars_width = square_sz; // Arbitrary smallish width of Hue/Alpha picking bars
    #####: 5744:    float sv_picker_size = ImMax(bars_width * 1, width - (alpha_bar ? 2 : 1) * (bars_width + style.ItemInnerSpacing.x)); // Saturation/Value picking box
    %%%%%: 5744-block 42
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5744-block 43
    %%%%%: 5744-block 44
    %%%%%: 5744-block 45
call    2 never executed
    #####: 5745:    float bar0_pos_x = picker_pos.x + sv_picker_size + style.ItemInnerSpacing.x;
    #####: 5746:    float bar1_pos_x = bar0_pos_x + bars_width + style.ItemInnerSpacing.x;
    #####: 5747:    float bars_triangles_half_sz = IM_TRUNC(bars_width * 0.20f);
        -: 5748:
        -: 5749:    float backup_initial_col[4];
    #####: 5750:    memcpy(backup_initial_col, col, components * sizeof(float));
        -: 5751:
    #####: 5752:    float wheel_thickness = sv_picker_size * 0.08f;
    #####: 5753:    float wheel_r_outer = sv_picker_size * 0.50f;
    #####: 5754:    float wheel_r_inner = wheel_r_outer - wheel_thickness;
    #####: 5755:    ImVec2 wheel_center(picker_pos.x + (sv_picker_size + bars_width)*0.5f, picker_pos.y + sv_picker_size * 0.5f);
call    0 never executed
        -: 5756:
        -: 5757:    // Note: the triangle is displayed rotated with triangle_pa pointing to Hue, but most coordinates stays unrotated for logic.
    #####: 5758:    float triangle_r = wheel_r_inner - (int)(sv_picker_size * 0.027f);
    #####: 5759:    ImVec2 triangle_pa = ImVec2(triangle_r, 0.0f); // Hue point.
call    0 never executed
    #####: 5760:    ImVec2 triangle_pb = ImVec2(triangle_r * -0.5f, triangle_r * -0.866025f); // Black point.
call    0 never executed
    #####: 5761:    ImVec2 triangle_pc = ImVec2(triangle_r * -0.5f, triangle_r * +0.866025f); // White point.
call    0 never executed
        -: 5762:
    #####: 5763:    float H = col[0], S = col[1], V = col[2];
    #####: 5764:    float R = col[0], G = col[1], B = col[2];
    #####: 5765:    if (flags & ImGuiColorEditFlags_InputRGB)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5766:    {
        -: 5767:        // Hue is lost when converting from grayscale rgb (saturation=0). Restore it.
    #####: 5768:        ColorConvertRGBtoHSV(R, G, B, H, S, V);
    %%%%%: 5768-block 51
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5769:        ColorEditRestoreHS(col, &H, &S, &V);
    %%%%%: 5769-block 52
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5770:    }
    #####: 5771:    else if (flags & ImGuiColorEditFlags_InputHSV)
    %%%%%: 5771-block 53
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5772:    {
    #####: 5773:        ColorConvertHSVtoRGB(H, S, V, R, G, B);
    %%%%%: 5773-block 54
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5774:    }
        -: 5775:
    #####: 5776:    bool value_changed = false, value_changed_h = false, value_changed_sv = false;
        -: 5777:
    #####: 5778:    PushItemFlag(ImGuiItemFlags_NoNav, true);
    %%%%%: 5778-block 55
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5779:    if (flags & ImGuiColorEditFlags_PickerHueWheel)
    %%%%%: 5779-block 56
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5780:    {
        -: 5781:        // Hue wheel + SV triangle logic
    #####: 5782:        InvisibleButton("hsv", ImVec2(sv_picker_size + style.ItemInnerSpacing.x + bars_width, sv_picker_size));
    %%%%%: 5782-block 57
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$: 5782-block 314
    #####: 5783:        if (IsItemActive() && !is_readonly)
    %%%%%: 5783-block 59
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 5783-block 60
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 5783-block 61
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 5783-block 62
    %%%%%: 5783-block 63
    %%%%%: 5783-block 64
branch  7 never executed (fallthrough)
branch  8 never executed
        -: 5784:        {
    #####: 5785:            ImVec2 initial_off = g.IO.MouseClickedPos[0] - wheel_center;
    %%%%%: 5785-block 65
call    0 never executed
    #####: 5786:            ImVec2 current_off = g.IO.MousePos - wheel_center;
call    0 never executed
    #####: 5787:            float initial_dist2 = ImLengthSqr(initial_off);
call    0 never executed
    #####: 5788:            if (initial_dist2 >= (wheel_r_inner - 1) * (wheel_r_inner - 1) && initial_dist2 <= (wheel_r_outer + 1) * (wheel_r_outer + 1))
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5788-block 69
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 5789:            {
        -: 5790:                // Interactive with Hue wheel
    #####: 5791:                H = ImAtan2(current_off.y, current_off.x) / IM_PI * 0.5f;
    #####: 5792:                if (H < 0.0f)
    %%%%%: 5792-block 70
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5793:                    H += 1.0f;
    %%%%%: 5793-block 71
    #####: 5794:                value_changed = value_changed_h = true;
    %%%%%: 5794-block 72
        -: 5795:            }
    #####: 5796:            float cos_hue_angle = ImCos(-H * 2.0f * IM_PI);
    #####: 5797:            float sin_hue_angle = ImSin(-H * 2.0f * IM_PI);
    #####: 5798:            if (ImTriangleContainsPoint(triangle_pa, triangle_pb, triangle_pc, ImRotate(initial_off, cos_hue_angle, sin_hue_angle)))
    %%%%%: 5798-block 73
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 5798-block 75
branch  4 never executed (fallthrough)
branch  5 never executed
    $$$$$: 5798-block 315
        -: 5799:            {
        -: 5800:                // Interacting with SV triangle
    #####: 5801:                ImVec2 current_off_unrotated = ImRotate(current_off, cos_hue_angle, sin_hue_angle);
    %%%%%: 5801-block 76
call    0 never executed
    #####: 5802:                if (!ImTriangleContainsPoint(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated))
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 5802-block 78
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 5803:                    current_off_unrotated = ImTriangleClosestPoint(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated);
    %%%%%: 5803-block 79
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5804:                float uu, vv, ww;
    #####: 5805:                ImTriangleBarycentricCoords(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated, uu, vv, ww);
    %%%%%: 5805-block 80
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5806:                V = ImClamp(1.0f - vv, 0.0001f, 1.0f);
    %%%%%: 5806-block 81
call    0 never executed
    #####: 5807:                S = ImClamp(uu / V, 0.0001f, 1.0f);
call    0 never executed
    #####: 5808:                value_changed = value_changed_sv = true;
        -: 5809:            }
        -: 5810:        }
    #####: 5811:        if (!(flags & ImGuiColorEditFlags_NoOptions))
    %%%%%: 5811-block 85
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5812:            OpenPopupOnItemClick("context", ImGuiPopupFlags_MouseButtonRight);
    %%%%%: 5812-block 86
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5813:    }
    #####: 5814:    else if (flags & ImGuiColorEditFlags_PickerHueBar)
    %%%%%: 5814-block 87
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5815:    {
        -: 5816:        // SV rectangle logic
    #####: 5817:        InvisibleButton("sv", ImVec2(sv_picker_size, sv_picker_size));
    %%%%%: 5817-block 88
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$: 5817-block 318
    #####: 5818:        if (IsItemActive() && !is_readonly)
    %%%%%: 5818-block 90
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 5818-block 91
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 5818-block 92
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 5818-block 93
    %%%%%: 5818-block 94
    %%%%%: 5818-block 95
branch  7 never executed (fallthrough)
branch  8 never executed
        -: 5819:        {
    #####: 5820:            S = ImSaturate((io.MousePos.x - picker_pos.x) / (sv_picker_size - 1));
    %%%%%: 5820-block 96
call    0 never executed
    #####: 5821:            V = 1.0f - ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size - 1));
call    0 never executed
    #####: 5822:            ColorEditRestoreH(col, &H); // Greatly reduces hue jitter and reset to 0 when hue == 255 and color is rapidly modified using SV square.
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5823:            value_changed = value_changed_sv = true;
    %%%%%: 5823-block 99
        -: 5824:        }
    #####: 5825:        if (!(flags & ImGuiColorEditFlags_NoOptions))
    %%%%%: 5825-block 100
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5826:            OpenPopupOnItemClick("context", ImGuiPopupFlags_MouseButtonRight);
    %%%%%: 5826-block 101
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5827:
        -: 5828:        // Hue bar logic
    #####: 5829:        SetCursorScreenPos(ImVec2(bar0_pos_x, picker_pos.y));
    %%%%%: 5829-block 102
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$: 5829-block 319
    #####: 5830:        InvisibleButton("hue", ImVec2(bars_width, sv_picker_size));
    %%%%%: 5830-block 104
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$: 5830-block 320
    #####: 5831:        if (IsItemActive() && !is_readonly)
    %%%%%: 5831-block 106
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 5831-block 107
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 5831-block 108
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 5831-block 109
    %%%%%: 5831-block 110
    %%%%%: 5831-block 111
branch  7 never executed (fallthrough)
branch  8 never executed
        -: 5832:        {
    #####: 5833:            H = ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size - 1));
    %%%%%: 5833-block 112
call    0 never executed
    #####: 5834:            value_changed = value_changed_h = true;
        -: 5835:        }
        -: 5836:    }
        -: 5837:
        -: 5838:    // Alpha bar logic
    #####: 5839:    if (alpha_bar)
    %%%%%: 5839-block 114
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5840:    {
    #####: 5841:        SetCursorScreenPos(ImVec2(bar1_pos_x, picker_pos.y));
    %%%%%: 5841-block 115
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$: 5841-block 321
    #####: 5842:        InvisibleButton("alpha", ImVec2(bars_width, sv_picker_size));
    %%%%%: 5842-block 117
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$: 5842-block 322
    #####: 5843:        if (IsItemActive())
    %%%%%: 5843-block 119
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 5843-block 120
branch  3 never executed (fallthrough)
branch  4 never executed
        -: 5844:        {
    #####: 5845:            col[3] = 1.0f - ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size - 1));
    %%%%%: 5845-block 121
call    0 never executed
    #####: 5846:            value_changed = true;
        -: 5847:        }
        -: 5848:    }
    #####: 5849:    PopItemFlag(); // ImGuiItemFlags_NoNav
    %%%%%: 5849-block 123
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5850:
    #####: 5851:    if (!(flags & ImGuiColorEditFlags_NoSidePreview))
    %%%%%: 5851-block 124
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5852:    {
    #####: 5853:        SameLine(0, style.ItemInnerSpacing.x);
    %%%%%: 5853-block 125
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5854:        BeginGroup();
    %%%%%: 5854-block 126
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5855:    }
        -: 5856:
    #####: 5857:    if (!(flags & ImGuiColorEditFlags_NoLabel))
    %%%%%: 5857-block 127
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5858:    {
    #####: 5859:        const char* label_display_end = FindRenderedTextEnd(label);
    %%%%%: 5859-block 128
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5860:        if (label != label_display_end)
    %%%%%: 5860-block 129
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5861:        {
    #####: 5862:            if ((flags & ImGuiColorEditFlags_NoSidePreview))
    %%%%%: 5862-block 130
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5863:                SameLine(0, style.ItemInnerSpacing.x);
    %%%%%: 5863-block 131
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5864:            TextEx(label, label_display_end);
    %%%%%: 5864-block 132
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5865:        }
        -: 5866:    }
        -: 5867:
    #####: 5868:    if (!(flags & ImGuiColorEditFlags_NoSidePreview))
    %%%%%: 5868-block 133
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5869:    {
    #####: 5870:        PushItemFlag(ImGuiItemFlags_NoNavDefaultFocus, true);
    %%%%%: 5870-block 134
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5871:        ImVec4 col_v4(col[0], col[1], col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : col[3]);
    %%%%%: 5871-block 135
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5871-block 136
    %%%%%: 5871-block 137
    %%%%%: 5871-block 138
call    2 never executed
    #####: 5872:        if ((flags & ImGuiColorEditFlags_NoLabel))
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5873:            Text("Current");
    %%%%%: 5873-block 140
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5874:
    #####: 5875:        ImGuiColorEditFlags sub_flags_to_forward = ImGuiColorEditFlags_InputMask_ | ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf | ImGuiColorEditFlags_NoTooltip;
    #####: 5876:        ColorButton("##current", col_v4, (flags & sub_flags_to_forward), ImVec2(square_sz * 3, square_sz * 2));
    %%%%%: 5876-block 141
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$: 5876-block 323
    #####: 5877:        if (ref_col != NULL)
    %%%%%: 5877-block 143
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5878:        {
    #####: 5879:            Text("Original");
    %%%%%: 5879-block 144
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5880:            ImVec4 ref_col_v4(ref_col[0], ref_col[1], ref_col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : ref_col[3]);
    %%%%%: 5880-block 145
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5880-block 146
    %%%%%: 5880-block 147
    %%%%%: 5880-block 148
call    2 never executed
    #####: 5881:            if (ColorButton("##original", ref_col_v4, (flags & sub_flags_to_forward), ImVec2(square_sz * 3, square_sz * 2)))
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 5881-block 151
branch  4 never executed (fallthrough)
branch  5 never executed
    $$$$$: 5881-block 324
        -: 5882:            {
    #####: 5883:                memcpy(col, ref_col, components * sizeof(float));
    #####: 5884:                value_changed = true;
    %%%%%: 5884-block 152
        -: 5885:            }
        -: 5886:        }
    #####: 5887:        PopItemFlag();
    %%%%%: 5887-block 154
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5888:        EndGroup();
    %%%%%: 5888-block 155
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5889:    }
        -: 5890:
        -: 5891:    // Convert back color to RGB
    #####: 5892:    if (value_changed_h || value_changed_sv)
    %%%%%: 5892-block 157
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5892-block 158
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 5893:    {
    #####: 5894:        if (flags & ImGuiColorEditFlags_InputRGB)
    %%%%%: 5894-block 159
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5895:        {
    #####: 5896:            ColorConvertHSVtoRGB(H, S, V, col[0], col[1], col[2]);
    %%%%%: 5896-block 160
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5897:            g.ColorEditSavedHue = H;
    #####: 5898:            g.ColorEditSavedSat = S;
    #####: 5899:            g.ColorEditSavedID = g.ColorEditCurrentID;
    #####: 5900:            g.ColorEditSavedColor = ColorConvertFloat4ToU32(ImVec4(col[0], col[1], col[2], 0));
    %%%%%: 5900-block 161
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 5900-block 163
    $$$$$: 5900-block 327
        -: 5901:        }
    #####: 5902:        else if (flags & ImGuiColorEditFlags_InputHSV)
    %%%%%: 5902-block 164
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5903:        {
    #####: 5904:            col[0] = H;
    #####: 5905:            col[1] = S;
    #####: 5906:            col[2] = V;
    %%%%%: 5906-block 165
        -: 5907:        }
        -: 5908:    }
        -: 5909:
        -: 5910:    // R,G,B and H,S,V slider color editor
    #####: 5911:    bool value_changed_fix_hue_wrap = false;
    #####: 5912:    if ((flags & ImGuiColorEditFlags_NoInputs) == 0)
    %%%%%: 5912-block 166
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5913:    {
    #####: 5914:        PushItemWidth((alpha_bar ? bar1_pos_x : bar0_pos_x) + bars_width - picker_pos.x);
    %%%%%: 5914-block 167
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5914-block 168
    %%%%%: 5914-block 169
    %%%%%: 5914-block 170
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####: 5915:        ImGuiColorEditFlags sub_flags_to_forward = ImGuiColorEditFlags_DataTypeMask_ | ImGuiColorEditFlags_InputMask_ | ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_NoOptions | ImGuiColorEditFlags_NoTooltip | ImGuiColorEditFlags_NoSmallPreview | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf;
    #####: 5916:        ImGuiColorEditFlags sub_flags = (flags & sub_flags_to_forward) | ImGuiColorEditFlags_NoPicker;
    #####: 5917:        if (flags & ImGuiColorEditFlags_DisplayRGB || (flags & ImGuiColorEditFlags_DisplayMask_) == 0)
    %%%%%: 5917-block 171
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5917-block 172
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 5918:            if (ColorEdit4("##rgb", col, sub_flags | ImGuiColorEditFlags_DisplayRGB))
    %%%%%: 5918-block 173
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 5918-block 174
branch  3 never executed (fallthrough)
branch  4 never executed
        -: 5919:            {
        -: 5920:                // FIXME: Hackily differentiating using the DragInt (ActiveId != 0 && !ActiveIdAllowOverlap) vs. using the InputText or DropTarget.
        -: 5921:                // For the later we don't want to run the hue-wrap canceling code. If you are well versed in HSV picker please provide your input! (See #2050)
    #####: 5922:                value_changed_fix_hue_wrap = (g.ActiveId != 0 && !g.ActiveIdAllowOverlap);
    %%%%%: 5922-block 175
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5922-block 176
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 5922-block 177
    %%%%%: 5922-block 178
    #####: 5923:                value_changed = true;
    %%%%%: 5923-block 179
        -: 5924:            }
    #####: 5925:        if (flags & ImGuiColorEditFlags_DisplayHSV || (flags & ImGuiColorEditFlags_DisplayMask_) == 0)
    %%%%%: 5925-block 180
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5925-block 181
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 5926:            value_changed |= ColorEdit4("##hsv", col, sub_flags | ImGuiColorEditFlags_DisplayHSV);
    %%%%%: 5926-block 182
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 5926-block 183
    #####: 5927:        if (flags & ImGuiColorEditFlags_DisplayHex || (flags & ImGuiColorEditFlags_DisplayMask_) == 0)
    %%%%%: 5927-block 184
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5927-block 185
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 5928:            value_changed |= ColorEdit4("##hex", col, sub_flags | ImGuiColorEditFlags_DisplayHex);
    %%%%%: 5928-block 186
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 5928-block 187
    #####: 5929:        PopItemWidth();
    %%%%%: 5929-block 188
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5930:    }
        -: 5931:
        -: 5932:    // Try to cancel hue wrap (after ColorEdit4 call), if any
    #####: 5933:    if (value_changed_fix_hue_wrap && (flags & ImGuiColorEditFlags_InputRGB))
    %%%%%: 5933-block 189
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5933-block 190
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 5934:    {
        -: 5935:        float new_H, new_S, new_V;
    #####: 5936:        ColorConvertRGBtoHSV(col[0], col[1], col[2], new_H, new_S, new_V);
    %%%%%: 5936-block 191
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5937:        if (new_H <= 0 && H > 0)
    %%%%%: 5937-block 192
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5937-block 193
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 5938:        {
    #####: 5939:            if (new_V <= 0 && V != new_V)
    %%%%%: 5939-block 194
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5939-block 195
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 5940:                ColorConvertHSVtoRGB(H, S, new_V <= 0 ? V * 0.5f : new_V, col[0], col[1], col[2]);
    %%%%%: 5940-block 196
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5940-block 197
    %%%%%: 5940-block 198
    %%%%%: 5940-block 199
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####: 5941:            else if (new_S <= 0)
    %%%%%: 5941-block 201
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 5942:                ColorConvertHSVtoRGB(H, new_S <= 0 ? S * 0.5f : new_S, new_V, col[0], col[1], col[2]);
    %%%%%: 5942-block 202
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 5942-block 203
    %%%%%: 5942-block 204
    %%%%%: 5942-block 205
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
        -: 5943:        }
        -: 5944:    }
        -: 5945:
    #####: 5946:    if (value_changed)
    %%%%%: 5946-block 208
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5947:    {
    #####: 5948:        if (flags & ImGuiColorEditFlags_InputRGB)
    %%%%%: 5948-block 209
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5949:        {
    #####: 5950:            R = col[0];
    #####: 5951:            G = col[1];
    #####: 5952:            B = col[2];
    #####: 5953:            ColorConvertRGBtoHSV(R, G, B, H, S, V);
    %%%%%: 5953-block 210
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5954:            ColorEditRestoreHS(col, &H, &S, &V);   // Fix local Hue as display below will use it immediately.
    %%%%%: 5954-block 211
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5955:        }
    #####: 5956:        else if (flags & ImGuiColorEditFlags_InputHSV)
    %%%%%: 5956-block 212
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5957:        {
    #####: 5958:            H = col[0];
    #####: 5959:            S = col[1];
    #####: 5960:            V = col[2];
    #####: 5961:            ColorConvertHSVtoRGB(H, S, V, R, G, B);
    %%%%%: 5961-block 213
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5962:        }
        -: 5963:    }
        -: 5964:
    #####: 5965:    const int style_alpha8 = IM_F32_TO_INT8_SAT(style.Alpha);
    %%%%%: 5965-block 214
call    0 never executed
    #####: 5966:    const ImU32 col_black = IM_COL32(0,0,0,style_alpha8);
    #####: 5967:    const ImU32 col_white = IM_COL32(255,255,255,style_alpha8);
    #####: 5968:    const ImU32 col_midgrey = IM_COL32(128,128,128,style_alpha8);
    #####: 5969:    const ImU32 col_hues[6 + 1] = { IM_COL32(255,0,0,style_alpha8), IM_COL32(255,255,0,style_alpha8), IM_COL32(0,255,0,style_alpha8), IM_COL32(0,255,255,style_alpha8), IM_COL32(0,0,255,style_alpha8), IM_COL32(255,0,255,style_alpha8), IM_COL32(255,0,0,style_alpha8) };
        -: 5970:
    #####: 5971:    ImVec4 hue_color_f(1, 1, 1, style.Alpha); ColorConvertHSVtoRGB(H, 1, 1, hue_color_f.x, hue_color_f.y, hue_color_f.z);
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####: 5972:    ImU32 hue_color32 = ColorConvertFloat4ToU32(hue_color_f);
    %%%%%: 5972-block 217
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5973:    ImU32 user_col32_striped_of_alpha = ColorConvertFloat4ToU32(ImVec4(R, G, B, style.Alpha)); // Important: this is still including the main rendering/style alpha!!
    %%%%%: 5973-block 218
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$: 5973-block 329
        -: 5974:
    #####: 5975:    ImVec2 sv_cursor_pos;
        -: 5976:
    #####: 5977:    if (flags & ImGuiColorEditFlags_PickerHueWheel)
    %%%%%: 5977-block 220
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 5978:    {
        -: 5979:        // Render Hue Wheel
    #####: 5980:        const float aeps = 0.5f / wheel_r_outer; // Half a pixel arc length in radians (2pi cancels out).
    #####: 5981:        const int segment_per_arc = ImMax(4, (int)wheel_r_outer / 12);
    %%%%%: 5981-block 221
call    0 never executed
    #####: 5982:        for (int n = 0; n < 6; n++)
    %%%%%: 5982-block 228
    %%%%%: 5982-block 229
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 5983:        {
    #####: 5984:            const float a0 = (n)     /6.0f * 2.0f * IM_PI - aeps;
    #####: 5985:            const float a1 = (n+1.0f)/6.0f * 2.0f * IM_PI + aeps;
    #####: 5986:            const int vert_start_idx = draw_list->VtxBuffer.Size;
    #####: 5987:            draw_list->PathArcTo(wheel_center, (wheel_r_inner + wheel_r_outer)*0.5f, a0, a1, segment_per_arc);
    %%%%%: 5987-block 223
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5988:            draw_list->PathStroke(col_white, 0, wheel_thickness);
    %%%%%: 5988-block 224
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 5989:            const int vert_end_idx = draw_list->VtxBuffer.Size;
        -: 5990:
        -: 5991:            // Paint colors over existing vertices
    #####: 5992:            ImVec2 gradient_p0(wheel_center.x + ImCos(a0) * wheel_r_inner, wheel_center.y + ImSin(a0) * wheel_r_inner);
    %%%%%: 5992-block 225
call    0 never executed
    #####: 5993:            ImVec2 gradient_p1(wheel_center.x + ImCos(a1) * wheel_r_inner, wheel_center.y + ImSin(a1) * wheel_r_inner);
call    0 never executed
    #####: 5994:            ShadeVertsLinearColorGradientKeepAlpha(draw_list, vert_start_idx, vert_end_idx, gradient_p0, gradient_p1, col_hues[n], col_hues[n + 1]);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 5995:        }
        -: 5996:
        -: 5997:        // Render Cursor + preview on Hue Wheel
    #####: 5998:        float cos_hue_angle = ImCos(H * 2.0f * IM_PI);
    #####: 5999:        float sin_hue_angle = ImSin(H * 2.0f * IM_PI);
    #####: 6000:        ImVec2 hue_cursor_pos(wheel_center.x + cos_hue_angle * (wheel_r_inner + wheel_r_outer) * 0.5f, wheel_center.y + sin_hue_angle * (wheel_r_inner + wheel_r_outer) * 0.5f);
    %%%%%: 6000-block 230
call    0 never executed
    #####: 6001:        float hue_cursor_rad = value_changed_h ? wheel_thickness * 0.65f : wheel_thickness * 0.55f;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6001-block 232
    %%%%%: 6001-block 233
    #####: 6002:        int hue_cursor_segments = draw_list->_CalcCircleAutoSegmentCount(hue_cursor_rad); // Lock segment count so the +1 one matches others.
    %%%%%: 6002-block 234
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6003:        draw_list->AddCircleFilled(hue_cursor_pos, hue_cursor_rad, hue_color32, hue_cursor_segments);
    %%%%%: 6003-block 235
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6004:        draw_list->AddCircle(hue_cursor_pos, hue_cursor_rad + 1, col_midgrey, hue_cursor_segments);
    %%%%%: 6004-block 236
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6005:        draw_list->AddCircle(hue_cursor_pos, hue_cursor_rad, col_white, hue_cursor_segments);
    %%%%%: 6005-block 237
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6006:
        -: 6007:        // Render SV triangle (rotated according to hue)
    #####: 6008:        ImVec2 tra = wheel_center + ImRotate(triangle_pa, cos_hue_angle, sin_hue_angle);
    %%%%%: 6008-block 238
call    0 never executed
call    1 never executed
    #####: 6009:        ImVec2 trb = wheel_center + ImRotate(triangle_pb, cos_hue_angle, sin_hue_angle);
call    0 never executed
call    1 never executed
    #####: 6010:        ImVec2 trc = wheel_center + ImRotate(triangle_pc, cos_hue_angle, sin_hue_angle);
call    0 never executed
call    1 never executed
    #####: 6011:        ImVec2 uv_white = GetFontTexUvWhitePixel();
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6012:        draw_list->PrimReserve(3, 3);
    %%%%%: 6012-block 245
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6013:        draw_list->PrimVtx(tra, uv_white, hue_color32);
    %%%%%: 6013-block 246
call    0 never executed
    #####: 6014:        draw_list->PrimVtx(trb, uv_white, col_black);
call    0 never executed
    #####: 6015:        draw_list->PrimVtx(trc, uv_white, col_white);
call    0 never executed
    #####: 6016:        draw_list->AddTriangle(tra, trb, trc, col_midgrey, 1.5f);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6017:        sv_cursor_pos = ImLerp(ImLerp(trc, tra, ImSaturate(S)), trb, ImSaturate(1 - V));
    %%%%%: 6017-block 250
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 6018:    }
    #####: 6019:    else if (flags & ImGuiColorEditFlags_PickerHueBar)
    %%%%%: 6019-block 255
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6020:    {
        -: 6021:        // Render SV Square
    #####: 6022:        draw_list->AddRectFilledMultiColor(picker_pos, picker_pos + ImVec2(sv_picker_size, sv_picker_size), col_white, hue_color32, hue_color32, col_white);
    %%%%%: 6022-block 256
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    $$$$$: 6022-block 332
    $$$$$: 6022-block 333
    #####: 6023:        draw_list->AddRectFilledMultiColor(picker_pos, picker_pos + ImVec2(sv_picker_size, sv_picker_size), 0, 0, col_black, col_black);
    %%%%%: 6023-block 259
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    $$$$$: 6023-block 334
    $$$$$: 6023-block 335
    #####: 6024:        RenderFrameBorder(picker_pos, picker_pos + ImVec2(sv_picker_size, sv_picker_size), 0.0f);
    %%%%%: 6024-block 262
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    $$$$$: 6024-block 336
    #####: 6025:        sv_cursor_pos.x = ImClamp(IM_ROUND(picker_pos.x + ImSaturate(S)     * sv_picker_size), picker_pos.x + 2, picker_pos.x + sv_picker_size - 2); // Sneakily prevent the circle to stick out too much
    %%%%%: 6025-block 265
call    0 never executed
call    1 never executed
    #####: 6026:        sv_cursor_pos.y = ImClamp(IM_ROUND(picker_pos.y + ImSaturate(1 - V) * sv_picker_size), picker_pos.y + 2, picker_pos.y + sv_picker_size - 2);
call    0 never executed
call    1 never executed
        -: 6027:
        -: 6028:        // Render Hue Bar
    #####: 6029:        for (int i = 0; i < 6; ++i)
    %%%%%: 6029-block 274
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 6030:            draw_list->AddRectFilledMultiColor(ImVec2(bar0_pos_x, picker_pos.y + i * (sv_picker_size / 6)), ImVec2(bar0_pos_x + bars_width, picker_pos.y + (i + 1) * (sv_picker_size / 6)), col_hues[i], col_hues[i], col_hues[i + 1], col_hues[i + 1]);
    %%%%%: 6030-block 270
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 6030-block 273
    $$$$$: 6030-block 337
    $$$$$: 6030-block 338
    #####: 6031:        float bar0_line_y = IM_ROUND(picker_pos.y + H * sv_picker_size);
    #####: 6032:        RenderFrameBorder(ImVec2(bar0_pos_x, picker_pos.y), ImVec2(bar0_pos_x + bars_width, picker_pos.y + sv_picker_size), 0.0f);
    %%%%%: 6032-block 275
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    $$$$$: 6032-block 339
    $$$$$: 6032-block 340
    #####: 6033:        RenderArrowsForVerticalBar(draw_list, ImVec2(bar0_pos_x - 1, bar0_line_y), ImVec2(bars_triangles_half_sz + 1, bars_triangles_half_sz), bars_width + 2.0f, style.Alpha);
    %%%%%: 6033-block 278
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 6033-block 281
    $$$$$: 6033-block 341
    $$$$$: 6033-block 342
        -: 6034:    }
        -: 6035:
        -: 6036:    // Render cursor/preview circle (clamp S/V within 0..1 range because floating points colors may lead HSV values to be out of range)
    #####: 6037:    float sv_cursor_rad = value_changed_sv ? wheel_thickness * 0.55f : wheel_thickness * 0.40f;
    %%%%%: 6037-block 282
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6037-block 283
    %%%%%: 6037-block 284
    #####: 6038:    int sv_cursor_segments = draw_list->_CalcCircleAutoSegmentCount(sv_cursor_rad); // Lock segment count so the +1 one matches others.
    %%%%%: 6038-block 285
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6039:    draw_list->AddCircleFilled(sv_cursor_pos, sv_cursor_rad, user_col32_striped_of_alpha, sv_cursor_segments);
    %%%%%: 6039-block 286
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6040:    draw_list->AddCircle(sv_cursor_pos, sv_cursor_rad + 1, col_midgrey, sv_cursor_segments);
    %%%%%: 6040-block 287
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6041:    draw_list->AddCircle(sv_cursor_pos, sv_cursor_rad, col_white, sv_cursor_segments);
    %%%%%: 6041-block 288
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6042:
        -: 6043:    // Render alpha bar
    #####: 6044:    if (alpha_bar)
    %%%%%: 6044-block 289
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6045:    {
    #####: 6046:        float alpha = ImSaturate(col[3]);
    %%%%%: 6046-block 290
call    0 never executed
    #####: 6047:        ImRect bar1_bb(bar1_pos_x, picker_pos.y, bar1_pos_x + bars_width, picker_pos.y + sv_picker_size);
call    0 never executed
    #####: 6048:        RenderColorRectWithAlphaCheckerboard(draw_list, bar1_bb.Min, bar1_bb.Max, 0, bar1_bb.GetWidth() / 2.0f, ImVec2(0.0f, 0.0f));
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    $$$$$: 6048-block 343
    #####: 6049:        draw_list->AddRectFilledMultiColor(bar1_bb.Min, bar1_bb.Max, user_col32_striped_of_alpha, user_col32_striped_of_alpha, user_col32_striped_of_alpha & ~IM_COL32_A_MASK, user_col32_striped_of_alpha & ~IM_COL32_A_MASK);
    %%%%%: 6049-block 295
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6050:        float bar1_line_y = IM_ROUND(picker_pos.y + (1.0f - alpha) * sv_picker_size);
    #####: 6051:        RenderFrameBorder(bar1_bb.Min, bar1_bb.Max, 0.0f);
    %%%%%: 6051-block 296
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6052:        RenderArrowsForVerticalBar(draw_list, ImVec2(bar1_pos_x - 1, bar1_line_y), ImVec2(bars_triangles_half_sz + 1, bars_triangles_half_sz), bars_width + 2.0f, style.Alpha);
    %%%%%: 6052-block 297
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 6052-block 300
    $$$$$: 6052-block 344
    $$$$$: 6052-block 345
        -: 6053:    }
        -: 6054:
    #####: 6055:    EndGroup();
    %%%%%: 6055-block 301
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6056:
    #####: 6057:    if (value_changed && memcmp(backup_initial_col, col, components * sizeof(float)) == 0)
    %%%%%: 6057-block 302
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6057-block 303
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 6058:        value_changed = false;
    %%%%%: 6058-block 304
    #####: 6059:    if (value_changed && g.LastItemData.ID != 0) // In case of ID collision, the second EndGroup() won't catch g.ActiveId
    %%%%%: 6059-block 305
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6059-block 306
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 6060:        MarkItemEdited(g.LastItemData.ID);
    %%%%%: 6060-block 307
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6061:
    #####: 6062:    if (set_current_color_edit_id)
    %%%%%: 6062-block 308
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6063:        g.ColorEditCurrentID = 0;
    %%%%%: 6063-block 309
    #####: 6064:    PopID();
    %%%%%: 6064-block 310
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6065:
    #####: 6066:    return value_changed;
    %%%%%: 6066-block 311
        -: 6067:}
        -: 6068:
        -: 6069:// A little color square. Return true when clicked.
        -: 6070:// FIXME: May want to display/ignore the alpha component in the color display? Yet show it in the tooltip.
        -: 6071:// 'desc_id' is not called 'label' because we don't display it next to the button, but only in the tooltip.
        -: 6072:// Note that 'col' may be encoded in HSV if ImGuiColorEditFlags_InputHSV is set.
function _ZN5ImGui11ColorButtonEPKcRK6ImVec4iRK6ImVec2 called 0 returned 0% blocks executed 0%
    #####: 6073:bool ImGui::ColorButton(const char* desc_id, const ImVec4& col, ImGuiColorEditFlags flags, const ImVec2& size_arg)
        -: 6074:{
    #####: 6075:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%: 6075-block 2
call    0 never executed
    #####: 6076:    if (window->SkipItems)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6077:        return false;
    %%%%%: 6077-block 4
        -: 6078:
    #####: 6079:    ImGuiContext& g = *GImGui;
    #####: 6080:    const ImGuiID id = window->GetID(desc_id);
    %%%%%: 6080-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6081:    const float default_size = GetFrameHeight();
    %%%%%: 6081-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6082:    const ImVec2 size(size_arg.x == 0.0f ? default_size : size_arg.x, size_arg.y == 0.0f ? default_size : size_arg.y);
    %%%%%: 6082-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6082-block 8
    %%%%%: 6082-block 9
    %%%%%: 6082-block 10
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6082-block 11
    %%%%%: 6082-block 12
    %%%%%: 6082-block 13
call    4 never executed
    #####: 6083:    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);
call    0 never executed
call    1 never executed
    #####: 6084:    ItemSize(bb, (size.y >= default_size) ? g.Style.FramePadding.y : 0.0f);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6084-block 17
    %%%%%: 6084-block 18
    %%%%%: 6084-block 19
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####: 6085:    if (!ItemAdd(bb, id))
    %%%%%: 6085-block 20
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 6085-block 21
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 6086:        return false;
    %%%%%: 6086-block 22
        -: 6087:
        -: 6088:    bool hovered, held;
    #####: 6089:    bool pressed = ButtonBehavior(bb, id, &hovered, &held);
    %%%%%: 6089-block 23
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6090:
    #####: 6091:    if (flags & ImGuiColorEditFlags_NoAlpha)
    %%%%%: 6091-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6092:        flags &= ~(ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf);
    %%%%%: 6092-block 25
        -: 6093:
    #####: 6094:    ImVec4 col_rgb = col;
    #####: 6095:    if (flags & ImGuiColorEditFlags_InputHSV)
    %%%%%: 6095-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6096:        ColorConvertHSVtoRGB(col_rgb.x, col_rgb.y, col_rgb.z, col_rgb.x, col_rgb.y, col_rgb.z);
    %%%%%: 6096-block 27
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6097:
    #####: 6098:    ImVec4 col_rgb_without_alpha(col_rgb.x, col_rgb.y, col_rgb.z, 1.0f);
    %%%%%: 6098-block 28
call    0 never executed
    #####: 6099:    float grid_step = ImMin(size.x, size.y) / 2.99f;
call    0 never executed
    #####: 6100:    float rounding = ImMin(g.Style.FrameRounding, grid_step * 0.5f);
call    0 never executed
    #####: 6101:    ImRect bb_inner = bb;
    #####: 6102:    float off = 0.0f;
    #####: 6103:    if ((flags & ImGuiColorEditFlags_NoBorder) == 0)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6104:    {
    #####: 6105:        off = -0.75f; // The border (using Col_FrameBg) tends to look off when color is near-opaque and rounding is enabled. This offset seemed like a good middle ground to reduce those artifacts.
    #####: 6106:        bb_inner.Expand(off);
    %%%%%: 6106-block 32
call    0 never executed
        -: 6107:    }
    #####: 6108:    if ((flags & ImGuiColorEditFlags_AlphaPreviewHalf) && col_rgb.w < 1.0f)
    %%%%%: 6108-block 33
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6108-block 34
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 6109:    {
    #####: 6110:        float mid_x = IM_ROUND((bb_inner.Min.x + bb_inner.Max.x) * 0.5f);
    #####: 6111:        RenderColorRectWithAlphaCheckerboard(window->DrawList, ImVec2(bb_inner.Min.x + grid_step, bb_inner.Min.y), bb_inner.Max, GetColorU32(col_rgb), grid_step, ImVec2(-grid_step + off, off), rounding, ImDrawFlags_RoundCornersRight);
    %%%%%: 6111-block 35
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 6111-block 37
call    4 never executed
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
    $$$$$: 6111-block 86
    $$$$$: 6111-block 87
    #####: 6112:        window->DrawList->AddRectFilled(bb_inner.Min, ImVec2(mid_x, bb_inner.Max.y), GetColorU32(col_rgb_without_alpha), rounding, ImDrawFlags_RoundCornersLeft);
    %%%%%: 6112-block 39
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 6112-block 40
call    3 never executed
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    $$$$$: 6112-block 88
    #####: 6113:    }
    %%%%%: 6113-block 42
        -: 6114:    else
        -: 6115:    {
        -: 6116:        // Because GetColorU32() multiplies by the global style Alpha and we don't want to display a checkerboard if the source code had no alpha
    #####: 6117:        ImVec4 col_source = (flags & ImGuiColorEditFlags_AlphaPreview) ? col_rgb : col_rgb_without_alpha;
    %%%%%: 6117-block 43
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6117-block 44
    %%%%%: 6117-block 45
    #####: 6118:        if (col_source.w < 1.0f)
    %%%%%: 6118-block 46
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6119:            RenderColorRectWithAlphaCheckerboard(window->DrawList, bb_inner.Min, bb_inner.Max, GetColorU32(col_source), grid_step, ImVec2(off, off), rounding);
    %%%%%: 6119-block 47
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 6119-block 49
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    %%%%%: 6119-block 50
    $$$$$: 6119-block 89
        -: 6120:        else
    #####: 6121:            window->DrawList->AddRectFilled(bb_inner.Min, bb_inner.Max, GetColorU32(col_source), rounding);
    %%%%%: 6121-block 51
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 6121-block 52
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
        -: 6122:    }
    #####: 6123:    RenderNavCursor(bb, id);
    %%%%%: 6123-block 54
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6124:    if ((flags & ImGuiColorEditFlags_NoBorder) == 0)
    %%%%%: 6124-block 55
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6125:    {
    #####: 6126:        if (g.Style.FrameBorderSize > 0.0f)
    %%%%%: 6126-block 56
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6127:            RenderFrameBorder(bb.Min, bb.Max, rounding);
    %%%%%: 6127-block 57
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6128:        else
    #####: 6129:            window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(ImGuiCol_FrameBg), rounding); // Color button are often in need of some sort of border
    %%%%%: 6129-block 58
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 6129-block 59
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
        -: 6130:    }
        -: 6131:
        -: 6132:    // Drag and Drop Source
        -: 6133:    // NB: The ActiveId test is merely an optional micro-optimization, BeginDragDropSource() does the same test.
    #####: 6134:    if (g.ActiveId == id && !(flags & ImGuiColorEditFlags_NoDragDrop) && BeginDragDropSource())
    %%%%%: 6134-block 60
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6134-block 61
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6134-block 62
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    %%%%%: 6134-block 63
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 6134-block 64
    %%%%%: 6134-block 65
    %%%%%: 6134-block 66
branch  9 never executed (fallthrough)
branch 10 never executed
        -: 6135:    {
    #####: 6136:        if (flags & ImGuiColorEditFlags_NoAlpha)
    %%%%%: 6136-block 67
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6137:            SetDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_3F, &col_rgb, sizeof(float) * 3, ImGuiCond_Once);
    %%%%%: 6137-block 68
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6138:        else
    #####: 6139:            SetDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_4F, &col_rgb, sizeof(float) * 4, ImGuiCond_Once);
    %%%%%: 6139-block 69
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6140:        ColorButton(desc_id, col, flags);
    %%%%%: 6140-block 70
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$: 6140-block 91
    #####: 6141:        SameLine();
    %%%%%: 6141-block 72
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6142:        TextEx("Color");
    %%%%%: 6142-block 73
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6143:        EndDragDropSource();
    %%%%%: 6143-block 74
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6144:    }
        -: 6145:
        -: 6146:    // Tooltip
    #####: 6147:    if (!(flags & ImGuiColorEditFlags_NoTooltip) && hovered && IsItemHovered(ImGuiHoveredFlags_ForTooltip))
    %%%%%: 6147-block 75
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6147-block 76
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6147-block 77
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    %%%%%: 6147-block 78
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 6147-block 79
    %%%%%: 6147-block 80
    %%%%%: 6147-block 81
branch  9 never executed (fallthrough)
branch 10 never executed
    #####: 6148:        ColorTooltip(desc_id, &col.x, flags & (ImGuiColorEditFlags_InputMask_ | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf));
    %%%%%: 6148-block 82
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6149:
    #####: 6150:    return pressed;
    %%%%%: 6150-block 83
        -: 6151:}
        -: 6152:
        -: 6153:// Initialize/override default color options
function _ZN5ImGui19SetColorEditOptionsEi called 0 returned 0% blocks executed 0%
    #####: 6154:void ImGui::SetColorEditOptions(ImGuiColorEditFlags flags)
        -: 6155:{
    #####: 6156:    ImGuiContext& g = *GImGui;
    #####: 6157:    if ((flags & ImGuiColorEditFlags_DisplayMask_) == 0)
    %%%%%: 6157-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6158:        flags |= ImGuiColorEditFlags_DefaultOptions_ & ImGuiColorEditFlags_DisplayMask_;
    %%%%%: 6158-block 3
    #####: 6159:    if ((flags & ImGuiColorEditFlags_DataTypeMask_) == 0)
    %%%%%: 6159-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6160:        flags |= ImGuiColorEditFlags_DefaultOptions_ & ImGuiColorEditFlags_DataTypeMask_;
    %%%%%: 6160-block 5
    #####: 6161:    if ((flags & ImGuiColorEditFlags_PickerMask_) == 0)
    %%%%%: 6161-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6162:        flags |= ImGuiColorEditFlags_DefaultOptions_ & ImGuiColorEditFlags_PickerMask_;
    %%%%%: 6162-block 7
    #####: 6163:    if ((flags & ImGuiColorEditFlags_InputMask_) == 0)
    %%%%%: 6163-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6164:        flags |= ImGuiColorEditFlags_DefaultOptions_ & ImGuiColorEditFlags_InputMask_;
    %%%%%: 6164-block 9
    #####: 6165:    IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags_DisplayMask_));    // Check only 1 option is selected
    %%%%%: 6165-block 10
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 6165-block 12
call    3 never executed
    #####: 6166:    IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags_DataTypeMask_));   // Check only 1 option is selected
    %%%%%: 6166-block 13
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 6166-block 15
call    3 never executed
    #####: 6167:    IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags_PickerMask_));     // Check only 1 option is selected
    %%%%%: 6167-block 16
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 6167-block 18
call    3 never executed
    #####: 6168:    IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags_InputMask_));      // Check only 1 option is selected
    %%%%%: 6168-block 19
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 6168-block 21
call    3 never executed
    #####: 6169:    g.ColorEditOptions = flags;
    #####: 6170:}
        -: 6171:
        -: 6172:// Note: only access 3 floats if ImGuiColorEditFlags_NoAlpha flag is set.
function _ZN5ImGui12ColorTooltipEPKcPKfi called 0 returned 0% blocks executed 0%
    #####: 6173:void ImGui::ColorTooltip(const char* text, const float* col, ImGuiColorEditFlags flags)
        -: 6174:{
    #####: 6175:    ImGuiContext& g = *GImGui;
        -: 6176:
    #####: 6177:    if (!BeginTooltipEx(ImGuiTooltipFlags_OverridePrevious, ImGuiWindowFlags_None))
    %%%%%: 6177-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 6177-block 3
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 6178:        return;
    %%%%%: 6178-block 4
    #####: 6179:    const char* text_end = text ? FindRenderedTextEnd(text, NULL) : text;
    %%%%%: 6179-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6179-block 6
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 6179-block 7
    %%%%%: 6179-block 8
    #####: 6180:    if (text_end > text)
    %%%%%: 6180-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6181:    {
    #####: 6182:        TextEx(text, text_end);
    %%%%%: 6182-block 10
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6183:        Separator();
    %%%%%: 6183-block 11
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6184:    }
        -: 6185:
    #####: 6186:    ImVec2 sz(g.FontSize * 3 + g.Style.FramePadding.y * 2, g.FontSize * 3 + g.Style.FramePadding.y * 2);
    %%%%%: 6186-block 12
call    0 never executed
    #####: 6187:    ImVec4 cf(col[0], col[1], col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : col[3]);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6187-block 14
    %%%%%: 6187-block 15
    %%%%%: 6187-block 16
call    2 never executed
    #####: 6188:    int cr = IM_F32_TO_INT8_SAT(col[0]), cg = IM_F32_TO_INT8_SAT(col[1]), cb = IM_F32_TO_INT8_SAT(col[2]), ca = (flags & ImGuiColorEditFlags_NoAlpha) ? 255 : IM_F32_TO_INT8_SAT(col[3]);
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 6188-block 21
call    5 never executed
    %%%%%: 6188-block 23
    #####: 6189:    ColorButton("##preview", cf, (flags & (ImGuiColorEditFlags_InputMask_ | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf)) | ImGuiColorEditFlags_NoTooltip, sz);
    %%%%%: 6189-block 24
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6190:    SameLine();
    %%%%%: 6190-block 25
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6191:    if ((flags & ImGuiColorEditFlags_InputRGB) || !(flags & ImGuiColorEditFlags_InputMask_))
    %%%%%: 6191-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6191-block 27
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 6192:    {
    #####: 6193:        if (flags & ImGuiColorEditFlags_NoAlpha)
    %%%%%: 6193-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6194:            Text("#%02X%02X%02X\nR: %d, G: %d, B: %d\n(%.3f, %.3f, %.3f)", cr, cg, cb, cr, cg, cb, col[0], col[1], col[2]);
    %%%%%: 6194-block 29
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6195:        else
    #####: 6196:            Text("#%02X%02X%02X%02X\nR:%d, G:%d, B:%d, A:%d\n(%.3f, %.3f, %.3f, %.3f)", cr, cg, cb, ca, cr, cg, cb, ca, col[0], col[1], col[2], col[3]);
    %%%%%: 6196-block 30
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6197:    }
    #####: 6198:    else if (flags & ImGuiColorEditFlags_InputHSV)
    %%%%%: 6198-block 32
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6199:    {
    #####: 6200:        if (flags & ImGuiColorEditFlags_NoAlpha)
    %%%%%: 6200-block 33
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6201:            Text("H: %.3f, S: %.3f, V: %.3f", col[0], col[1], col[2]);
    %%%%%: 6201-block 34
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6202:        else
    #####: 6203:            Text("H: %.3f, S: %.3f, V: %.3f, A: %.3f", col[0], col[1], col[2], col[3]);
    %%%%%: 6203-block 35
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6204:    }
    #####: 6205:    EndTooltip();
    %%%%%: 6205-block 36
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6206:}
        -: 6207:
function _ZN5ImGui21ColorEditOptionsPopupEPKfi called 0 returned 0% blocks executed 0%
    #####: 6208:void ImGui::ColorEditOptionsPopup(const float* col, ImGuiColorEditFlags flags)
        -: 6209:{
    #####: 6210:    bool allow_opt_inputs = !(flags & ImGuiColorEditFlags_DisplayMask_);
    #####: 6211:    bool allow_opt_datatype = !(flags & ImGuiColorEditFlags_DataTypeMask_);
    #####: 6212:    if ((!allow_opt_inputs && !allow_opt_datatype) || !BeginPopup("context"))
    %%%%%: 6212-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6212-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6212-block 4
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 6212-block 6
    %%%%%: 6212-block 7
    %%%%%: 6212-block 8
branch  7 never executed (fallthrough)
branch  8 never executed
    #####: 6213:        return;
    %%%%%: 6213-block 9
        -: 6214:
    #####: 6215:    ImGuiContext& g = *GImGui;
    #####: 6216:    PushItemFlag(ImGuiItemFlags_NoMarkEdited, true);
    %%%%%: 6216-block 10
call    0 never executed
    #####: 6217:    ImGuiColorEditFlags opts = g.ColorEditOptions;
    #####: 6218:    if (allow_opt_inputs)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6219:    {
    #####: 6220:        if (RadioButton("RGB", (opts & ImGuiColorEditFlags_DisplayRGB) != 0)) opts = (opts & ~ImGuiColorEditFlags_DisplayMask_) | ImGuiColorEditFlags_DisplayRGB;
    %%%%%: 6220-block 12
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 6220-block 14
    #####: 6221:        if (RadioButton("HSV", (opts & ImGuiColorEditFlags_DisplayHSV) != 0)) opts = (opts & ~ImGuiColorEditFlags_DisplayMask_) | ImGuiColorEditFlags_DisplayHSV;
    %%%%%: 6221-block 15
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 6221-block 17
    #####: 6222:        if (RadioButton("Hex", (opts & ImGuiColorEditFlags_DisplayHex) != 0)) opts = (opts & ~ImGuiColorEditFlags_DisplayMask_) | ImGuiColorEditFlags_DisplayHex;
    %%%%%: 6222-block 18
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 6222-block 20
        -: 6223:    }
    #####: 6224:    if (allow_opt_datatype)
    %%%%%: 6224-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6225:    {
    #####: 6226:        if (allow_opt_inputs) Separator();
    %%%%%: 6226-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6226-block 23
call    2 never executed
    #####: 6227:        if (RadioButton("0..255",     (opts & ImGuiColorEditFlags_Uint8) != 0)) opts = (opts & ~ImGuiColorEditFlags_DataTypeMask_) | ImGuiColorEditFlags_Uint8;
    %%%%%: 6227-block 24
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 6227-block 26
    #####: 6228:        if (RadioButton("0.00..1.00", (opts & ImGuiColorEditFlags_Float) != 0)) opts = (opts & ~ImGuiColorEditFlags_DataTypeMask_) | ImGuiColorEditFlags_Float;
    %%%%%: 6228-block 27
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 6228-block 29
        -: 6229:    }
        -: 6230:
    #####: 6231:    if (allow_opt_inputs || allow_opt_datatype)
    %%%%%: 6231-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6231-block 31
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 6232:        Separator();
    %%%%%: 6232-block 32
call    0 never executed
    #####: 6233:    if (Button("Copy as..", ImVec2(-1, 0)))
    %%%%%: 6233-block 33
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 6233-block 35
branch  4 never executed (fallthrough)
branch  5 never executed
    $$$$$: 6233-block 75
call    6 never executed
    #####: 6234:        OpenPopup("Copy");
    %%%%%: 6234-block 36
call    0 never executed
    #####: 6235:    if (BeginPopup("Copy"))
    %%%%%: 6235-block 37
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -: 6236:    {
    #####: 6237:        int cr = IM_F32_TO_INT8_SAT(col[0]), cg = IM_F32_TO_INT8_SAT(col[1]), cb = IM_F32_TO_INT8_SAT(col[2]), ca = (flags & ImGuiColorEditFlags_NoAlpha) ? 255 : IM_F32_TO_INT8_SAT(col[3]);
    %%%%%: 6237-block 39
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 6237-block 43
call    5 never executed
    %%%%%: 6237-block 45
        -: 6238:        char buf[64];
    #####: 6239:        ImFormatString(buf, IM_ARRAYSIZE(buf), "(%.3ff, %.3ff, %.3ff, %.3ff)", col[0], col[1], col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : col[3]);
    %%%%%: 6239-block 46
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6239-block 47
    %%%%%: 6239-block 48
    %%%%%: 6239-block 49
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####: 6240:        if (Selectable(buf))
    %%%%%: 6240-block 50
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 6240-block 52
branch  4 never executed (fallthrough)
branch  5 never executed
    $$$$$: 6240-block 76
    #####: 6241:            SetClipboardText(buf);
    %%%%%: 6241-block 53
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6242:        ImFormatString(buf, IM_ARRAYSIZE(buf), "(%d,%d,%d,%d)", cr, cg, cb, ca);
    %%%%%: 6242-block 54
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6243:        if (Selectable(buf))
    %%%%%: 6243-block 55
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 6243-block 57
branch  4 never executed (fallthrough)
branch  5 never executed
    $$$$$: 6243-block 77
    #####: 6244:            SetClipboardText(buf);
    %%%%%: 6244-block 58
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6245:        ImFormatString(buf, IM_ARRAYSIZE(buf), "#%02X%02X%02X", cr, cg, cb);
    %%%%%: 6245-block 59
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6246:        if (Selectable(buf))
    %%%%%: 6246-block 60
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 6246-block 62
branch  4 never executed (fallthrough)
branch  5 never executed
    $$$$$: 6246-block 78
    #####: 6247:            SetClipboardText(buf);
    %%%%%: 6247-block 63
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6248:        if (!(flags & ImGuiColorEditFlags_NoAlpha))
    %%%%%: 6248-block 64
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6249:        {
    #####: 6250:            ImFormatString(buf, IM_ARRAYSIZE(buf), "#%02X%02X%02X%02X", cr, cg, cb, ca);
    %%%%%: 6250-block 65
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6251:            if (Selectable(buf))
    %%%%%: 6251-block 66
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 6251-block 68
branch  4 never executed (fallthrough)
branch  5 never executed
    $$$$$: 6251-block 79
    #####: 6252:                SetClipboardText(buf);
    %%%%%: 6252-block 69
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6253:        }
    #####: 6254:        EndPopup();
    %%%%%: 6254-block 70
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6255:    }
        -: 6256:
    #####: 6257:    g.ColorEditOptions = opts;
    #####: 6258:    PopItemFlag();
    %%%%%: 6258-block 72
call    0 never executed
    #####: 6259:    EndPopup();
call    0 never executed
        -: 6260:}
        -: 6261:
function _ZN5ImGui23ColorPickerOptionsPopupEPKfi called 0 returned 0% blocks executed 0%
    #####: 6262:void ImGui::ColorPickerOptionsPopup(const float* ref_col, ImGuiColorEditFlags flags)
        -: 6263:{
    #####: 6264:    bool allow_opt_picker = !(flags & ImGuiColorEditFlags_PickerMask_);
    #####: 6265:    bool allow_opt_alpha_bar = !(flags & ImGuiColorEditFlags_NoAlpha) && !(flags & ImGuiColorEditFlags_AlphaBar);
    %%%%%: 6265-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6265-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6265-block 4
    %%%%%: 6265-block 5
    #####: 6266:    if ((!allow_opt_picker && !allow_opt_alpha_bar) || !BeginPopup("context"))
    %%%%%: 6266-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6266-block 7
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6266-block 8
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 6266-block 10
    %%%%%: 6266-block 11
    %%%%%: 6266-block 12
branch  7 never executed (fallthrough)
branch  8 never executed
    #####: 6267:        return;
    %%%%%: 6267-block 13
        -: 6268:
    #####: 6269:    ImGuiContext& g = *GImGui;
    #####: 6270:    PushItemFlag(ImGuiItemFlags_NoMarkEdited, true);
    %%%%%: 6270-block 14
call    0 never executed
    #####: 6271:    if (allow_opt_picker)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6272:    {
    #####: 6273:        ImVec2 picker_size(g.FontSize * 8, ImMax(g.FontSize * 8 - (GetFrameHeight() + g.Style.ItemInnerSpacing.x), 1.0f)); // FIXME: Picker size copied from main picker function
    %%%%%: 6273-block 16
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 6273-block 17
call    3 never executed
call    4 never executed
    #####: 6274:        PushItemWidth(picker_size.x);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6275:        for (int picker_type = 0; picker_type < 2; picker_type++)
    %%%%%: 6275-block 20
    %%%%%: 6275-block 38
    %%%%%: 6275-block 39
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 6276:        {
        -: 6277:            // Draw small/thumbnail version of each picker type (over an invisible button for selection)
    #####: 6278:            if (picker_type > 0) Separator();
    %%%%%: 6278-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6278-block 22
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####: 6279:            PushID(picker_type);
    %%%%%: 6279-block 23
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6280:            ImGuiColorEditFlags picker_flags = ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoOptions | ImGuiColorEditFlags_NoLabel | ImGuiColorEditFlags_NoSidePreview | (flags & ImGuiColorEditFlags_NoAlpha);
    #####: 6281:            if (picker_type == 0) picker_flags |= ImGuiColorEditFlags_PickerHueBar;
    %%%%%: 6281-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6281-block 25
    #####: 6282:            if (picker_type == 1) picker_flags |= ImGuiColorEditFlags_PickerHueWheel;
    %%%%%: 6282-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6282-block 27
    #####: 6283:            ImVec2 backup_pos = GetCursorScreenPos();
    %%%%%: 6283-block 28
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6284:            if (Selectable("##selectable", false, 0, picker_size)) // By default, Selectable() is closing popup
    %%%%%: 6284-block 29
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 6284-block 30
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 6285:                g.ColorEditOptions = (g.ColorEditOptions & ~ImGuiColorEditFlags_PickerMask_) | (picker_flags & ImGuiColorEditFlags_PickerMask_);
    %%%%%: 6285-block 31
    #####: 6286:            SetCursorScreenPos(backup_pos);
    %%%%%: 6286-block 32
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6287:            ImVec4 previewing_ref_col;
    #####: 6288:            memcpy(&previewing_ref_col, ref_col, sizeof(float) * ((picker_flags & ImGuiColorEditFlags_NoAlpha) ? 3 : 4));
    %%%%%: 6288-block 33
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6288-block 34
    %%%%%: 6288-block 35
    #####: 6289:            ColorPicker4("##previewing_picker", &previewing_ref_col.x, picker_flags);
    %%%%%: 6289-block 36
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6290:            PopID();
    %%%%%: 6290-block 37
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6291:        }
    #####: 6292:        PopItemWidth();
    %%%%%: 6292-block 40
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6293:    }
    #####: 6294:    if (allow_opt_alpha_bar)
    %%%%%: 6294-block 42
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6295:    {
    #####: 6296:        if (allow_opt_picker) Separator();
    %%%%%: 6296-block 43
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6296-block 44
call    2 never executed
    #####: 6297:        CheckboxFlags("Alpha Bar", &g.ColorEditOptions, ImGuiColorEditFlags_AlphaBar);
    %%%%%: 6297-block 45
call    0 never executed
        -: 6298:    }
    #####: 6299:    PopItemFlag();
    %%%%%: 6299-block 46
call    0 never executed
    #####: 6300:    EndPopup();
call    0 never executed
        -: 6301:}
        -: 6302:
        -: 6303://-------------------------------------------------------------------------
        -: 6304:// [SECTION] Widgets: TreeNode, CollapsingHeader, etc.
        -: 6305://-------------------------------------------------------------------------
        -: 6306:// - TreeNode()
        -: 6307:// - TreeNodeV()
        -: 6308:// - TreeNodeEx()
        -: 6309:// - TreeNodeExV()
        -: 6310:// - TreeNodeBehavior() [Internal]
        -: 6311:// - TreePush()
        -: 6312:// - TreePop()
        -: 6313:// - GetTreeNodeToLabelSpacing()
        -: 6314:// - SetNextItemOpen()
        -: 6315:// - CollapsingHeader()
        -: 6316://-------------------------------------------------------------------------
        -: 6317:
function _ZN5ImGui8TreeNodeEPKcS1_z called 0 returned 0% blocks executed 0%
    #####: 6318:bool ImGui::TreeNode(const char* str_id, const char* fmt, ...)
        -: 6319:{
        -: 6320:    va_list args;
    #####: 6321:    va_start(args, fmt);
    #####: 6322:    bool is_open = TreeNodeExV(str_id, 0, fmt, args);
    %%%%%: 6322-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6323:    va_end(args);
    #####: 6324:    return is_open;
    %%%%%: 6324-block 3
    %%%%%: 6324-block 4
        -: 6325:}
        -: 6326:
function _ZN5ImGui8TreeNodeEPKvPKcz called 0 returned 0% blocks executed 0%
    #####: 6327:bool ImGui::TreeNode(const void* ptr_id, const char* fmt, ...)
        -: 6328:{
        -: 6329:    va_list args;
    #####: 6330:    va_start(args, fmt);
    #####: 6331:    bool is_open = TreeNodeExV(ptr_id, 0, fmt, args);
    %%%%%: 6331-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6332:    va_end(args);
    #####: 6333:    return is_open;
    %%%%%: 6333-block 3
    %%%%%: 6333-block 4
        -: 6334:}
        -: 6335:
function _ZN5ImGui8TreeNodeEPKc called 0 returned 0% blocks executed 0%
    #####: 6336:bool ImGui::TreeNode(const char* label)
        -: 6337:{
    #####: 6338:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%: 6338-block 2
call    0 never executed
    #####: 6339:    if (window->SkipItems)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6340:        return false;
    %%%%%: 6340-block 4
    #####: 6341:    ImGuiID id = window->GetID(label);
    %%%%%: 6341-block 5
call    0 never executed
    #####: 6342:    return TreeNodeBehavior(id, ImGuiTreeNodeFlags_None, label, NULL);
call    0 never executed
        -: 6343:}
        -: 6344:
function _ZN5ImGui9TreeNodeVEPKcS1_P13__va_list_tag called 0 returned 0% blocks executed 0%
    #####: 6345:bool ImGui::TreeNodeV(const char* str_id, const char* fmt, va_list args)
        -: 6346:{
    #####: 6347:    return TreeNodeExV(str_id, 0, fmt, args);
    %%%%%: 6347-block 2
call    0 never executed
        -: 6348:}
        -: 6349:
function _ZN5ImGui9TreeNodeVEPKvPKcP13__va_list_tag called 0 returned 0% blocks executed 0%
    #####: 6350:bool ImGui::TreeNodeV(const void* ptr_id, const char* fmt, va_list args)
        -: 6351:{
    #####: 6352:    return TreeNodeExV(ptr_id, 0, fmt, args);
    %%%%%: 6352-block 2
call    0 never executed
        -: 6353:}
        -: 6354:
function _ZN5ImGui10TreeNodeExEPKci called 0 returned 0% blocks executed 0%
    #####: 6355:bool ImGui::TreeNodeEx(const char* label, ImGuiTreeNodeFlags flags)
        -: 6356:{
    #####: 6357:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%: 6357-block 2
call    0 never executed
    #####: 6358:    if (window->SkipItems)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6359:        return false;
    %%%%%: 6359-block 4
    #####: 6360:    ImGuiID id = window->GetID(label);
    %%%%%: 6360-block 5
call    0 never executed
    #####: 6361:    return TreeNodeBehavior(id, flags, label, NULL);
call    0 never executed
        -: 6362:}
        -: 6363:
function _ZN5ImGui10TreeNodeExEPKciS1_z called 0 returned 0% blocks executed 0%
    #####: 6364:bool ImGui::TreeNodeEx(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, ...)
        -: 6365:{
        -: 6366:    va_list args;
    #####: 6367:    va_start(args, fmt);
    #####: 6368:    bool is_open = TreeNodeExV(str_id, flags, fmt, args);
    %%%%%: 6368-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6369:    va_end(args);
    #####: 6370:    return is_open;
    %%%%%: 6370-block 3
    %%%%%: 6370-block 4
        -: 6371:}
        -: 6372:
function _ZN5ImGui10TreeNodeExEPKviPKcz called 0 returned 0% blocks executed 0%
    #####: 6373:bool ImGui::TreeNodeEx(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, ...)
        -: 6374:{
        -: 6375:    va_list args;
    #####: 6376:    va_start(args, fmt);
    #####: 6377:    bool is_open = TreeNodeExV(ptr_id, flags, fmt, args);
    %%%%%: 6377-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6378:    va_end(args);
    #####: 6379:    return is_open;
    %%%%%: 6379-block 3
    %%%%%: 6379-block 4
        -: 6380:}
        -: 6381:
function _ZN5ImGui11TreeNodeExVEPKciS1_P13__va_list_tag called 0 returned 0% blocks executed 0%
    #####: 6382:bool ImGui::TreeNodeExV(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args)
        -: 6383:{
    #####: 6384:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%: 6384-block 2
call    0 never executed
    #####: 6385:    if (window->SkipItems)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6386:        return false;
    %%%%%: 6386-block 4
        -: 6387:
    #####: 6388:    ImGuiID id = window->GetID(str_id);
    %%%%%: 6388-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6389:    const char* label, *label_end;
    #####: 6390:    ImFormatStringToTempBufferV(&label, &label_end, fmt, args);
    %%%%%: 6390-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6391:    return TreeNodeBehavior(id, flags, label, label_end);
    %%%%%: 6391-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 6391-block 8
        -: 6392:}
        -: 6393:
function _ZN5ImGui11TreeNodeExVEPKviPKcP13__va_list_tag called 0 returned 0% blocks executed 0%
    #####: 6394:bool ImGui::TreeNodeExV(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args)
        -: 6395:{
    #####: 6396:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%: 6396-block 2
call    0 never executed
    #####: 6397:    if (window->SkipItems)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6398:        return false;
    %%%%%: 6398-block 4
        -: 6399:
    #####: 6400:    ImGuiID id = window->GetID(ptr_id);
    %%%%%: 6400-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6401:    const char* label, *label_end;
    #####: 6402:    ImFormatStringToTempBufferV(&label, &label_end, fmt, args);
    %%%%%: 6402-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6403:    return TreeNodeBehavior(id, flags, label, label_end);
    %%%%%: 6403-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 6403-block 8
        -: 6404:}
        -: 6405:
function _ZN5ImGui15TreeNodeGetOpenEj called 0 returned 0% blocks executed 0%
    #####: 6406:bool ImGui::TreeNodeGetOpen(ImGuiID storage_id)
        -: 6407:{
    #####: 6408:    ImGuiContext& g = *GImGui;
    #####: 6409:    ImGuiStorage* storage = g.CurrentWindow->DC.StateStorage;
    #####: 6410:    return storage->GetInt(storage_id, 0) != 0;
    %%%%%: 6410-block 2
call    0 never executed
        -: 6411:}
        -: 6412:
function _ZN5ImGui15TreeNodeSetOpenEjb called 0 returned 0% blocks executed 0%
    #####: 6413:void ImGui::TreeNodeSetOpen(ImGuiID storage_id, bool open)
        -: 6414:{
    #####: 6415:    ImGuiContext& g = *GImGui;
    #####: 6416:    ImGuiStorage* storage = g.CurrentWindow->DC.StateStorage;
    #####: 6417:    storage->SetInt(storage_id, open ? 1 : 0);
    %%%%%: 6417-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6417-block 3
    %%%%%: 6417-block 4
    %%%%%: 6417-block 5
call    2 never executed
    #####: 6418:}
        -: 6419:
function _ZN5ImGui22TreeNodeUpdateNextOpenEji called 0 returned 0% blocks executed 0%
    #####: 6420:bool ImGui::TreeNodeUpdateNextOpen(ImGuiID storage_id, ImGuiTreeNodeFlags flags)
        -: 6421:{
    #####: 6422:    if (flags & ImGuiTreeNodeFlags_Leaf)
    %%%%%: 6422-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6423:        return true;
    %%%%%: 6423-block 3
        -: 6424:
        -: 6425:    // We only write to the tree storage if the user clicks, or explicitly use the SetNextItemOpen function
    #####: 6426:    ImGuiContext& g = *GImGui;
    #####: 6427:    ImGuiWindow* window = g.CurrentWindow;
    #####: 6428:    ImGuiStorage* storage = window->DC.StateStorage;
        -: 6429:
        -: 6430:    bool is_open;
    #####: 6431:    if (g.NextItemData.HasFlags & ImGuiNextItemDataFlags_HasOpen)
    %%%%%: 6431-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6432:    {
    #####: 6433:        if (g.NextItemData.OpenCond & ImGuiCond_Always)
    %%%%%: 6433-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6434:        {
    #####: 6435:            is_open = g.NextItemData.OpenVal;
    #####: 6436:            TreeNodeSetOpen(storage_id, is_open);
    %%%%%: 6436-block 6
call    0 never executed
        -: 6437:        }
        -: 6438:        else
        -: 6439:        {
        -: 6440:            // We treat ImGuiCond_Once and ImGuiCond_FirstUseEver the same because tree node state are not saved persistently.
    #####: 6441:            const int stored_value = storage->GetInt(storage_id, -1);
    %%%%%: 6441-block 7
call    0 never executed
    #####: 6442:            if (stored_value == -1)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6443:            {
    #####: 6444:                is_open = g.NextItemData.OpenVal;
    #####: 6445:                TreeNodeSetOpen(storage_id, is_open);
    %%%%%: 6445-block 9
call    0 never executed
        -: 6446:            }
        -: 6447:            else
        -: 6448:            {
    #####: 6449:                is_open = stored_value != 0;
    %%%%%: 6449-block 10
        -: 6450:            }
        -: 6451:        }
        -: 6452:    }
        -: 6453:    else
        -: 6454:    {
    #####: 6455:        is_open = storage->GetInt(storage_id, (flags & ImGuiTreeNodeFlags_DefaultOpen) ? 1 : 0) != 0;
    %%%%%: 6455-block 11
call    0 never executed
        -: 6456:    }
        -: 6457:
        -: 6458:    // When logging is enabled, we automatically expand tree nodes (but *NOT* collapsing headers.. seems like sensible behavior).
        -: 6459:    // NB- If we are above max depth we still allow manually opened nodes to be logged.
    #####: 6460:    if (g.LogEnabled && !(flags & ImGuiTreeNodeFlags_NoAutoOpenOnLog) && (window->DC.TreeDepth - g.LogDepthRef) < g.LogDepthToExpand)
    %%%%%: 6460-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6460-block 14
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6460-block 15
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 6461:        is_open = true;
    %%%%%: 6461-block 16
        -: 6462:
    #####: 6463:    return is_open;
    %%%%%: 6463-block 17
        -: 6464:}
        -: 6465:
        -: 6466:// Store ImGuiTreeNodeStackData for just submitted node.
        -: 6467:// Currently only supports 32 level deep and we are fine with (1 << Depth) overflowing into a zero, easy to increase.
function _ZL22TreeNodeStoreStackDatai called 0 returned 0% blocks executed 0%
    #####: 6468:static void TreeNodeStoreStackData(ImGuiTreeNodeFlags flags)
        -: 6469:{
    #####: 6470:    ImGuiContext& g = *GImGui;
    #####: 6471:    ImGuiWindow* window = g.CurrentWindow;
        -: 6472:
    #####: 6473:    g.TreeNodeStack.resize(g.TreeNodeStack.Size + 1);
    %%%%%: 6473-block 2
call    0 never executed
    #####: 6474:    ImGuiTreeNodeStackData* tree_node_data = &g.TreeNodeStack.back();
call    0 never executed
    #####: 6475:    tree_node_data->ID = g.LastItemData.ID;
    #####: 6476:    tree_node_data->TreeFlags = flags;
    #####: 6477:    tree_node_data->ItemFlags = g.LastItemData.ItemFlags;
    #####: 6478:    tree_node_data->NavRect = g.LastItemData.NavRect;
    #####: 6479:    window->DC.TreeHasStackDataDepthMask |= (1 << window->DC.TreeDepth);
    #####: 6480:}
        -: 6481:
        -: 6482:// When using public API, currently 'id == storage_id' is always true, but we separate the values to facilitate advanced user code doing storage queries outside of UI loop.
function _ZN5ImGui16TreeNodeBehaviorEjiPKcS1_ called 0 returned 0% blocks executed 0%
    #####: 6483:bool ImGui::TreeNodeBehavior(ImGuiID id, ImGuiTreeNodeFlags flags, const char* label, const char* label_end)
        -: 6484:{
    #####: 6485:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%: 6485-block 2
call    0 never executed
    #####: 6486:    if (window->SkipItems)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6487:        return false;
    %%%%%: 6487-block 4
        -: 6488:
    #####: 6489:    ImGuiContext& g = *GImGui;
    #####: 6490:    const ImGuiStyle& style = g.Style;
    #####: 6491:    const bool display_frame = (flags & ImGuiTreeNodeFlags_Framed) != 0;
    #####: 6492:    const ImVec2 padding = (display_frame || (flags & ImGuiTreeNodeFlags_FramePadding)) ? style.FramePadding : ImVec2(style.FramePadding.x, ImMin(window->DC.CurrLineTextBaseOffset, style.FramePadding.y));
    %%%%%: 6492-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6492-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6492-block 7
    %%%%%: 6492-block 8
call    4 never executed
call    5 never executed
        -: 6493:
    #####: 6494:    if (!label_end)
    %%%%%: 6494-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6495:        label_end = FindRenderedTextEnd(label);
    %%%%%: 6495-block 11
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 6495-block 12
    #####: 6496:    const ImVec2 label_size = CalcTextSize(label, label_end, false);
    %%%%%: 6496-block 13
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6497:
    #####: 6498:    const float text_offset_x = g.FontSize + (display_frame ? padding.x * 3 : padding.x * 2);   // Collapsing arrow width + Spacing
    %%%%%: 6498-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6498-block 15
    %%%%%: 6498-block 16
    #####: 6499:    const float text_offset_y = ImMax(padding.y, window->DC.CurrLineTextBaseOffset);            // Latch before ItemSize changes it
    %%%%%: 6499-block 17
call    0 never executed
    #####: 6500:    const float text_width = g.FontSize + label_size.x + padding.x * 2;                         // Include collapsing arrow
        -: 6501:
        -: 6502:    // We vertically grow up to current line height up the typical widget height.
    #####: 6503:    const float frame_height = ImMax(ImMin(window->DC.CurrLineSize.y, g.FontSize + style.FramePadding.y * 2), label_size.y + padding.y * 2);
call    0 never executed
call    1 never executed
    #####: 6504:    const bool span_all_columns = (flags & ImGuiTreeNodeFlags_SpanAllColumns) != 0 && (g.CurrentTable != NULL);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6504-block 21
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6504-block 22
    %%%%%: 6504-block 23
    #####: 6505:    ImRect frame_bb;
    #####: 6506:    frame_bb.Min.x = span_all_columns ? window->ParentWorkRect.Min.x : (flags & ImGuiTreeNodeFlags_SpanFullWidth) ? window->WorkRect.Min.x : window->DC.CursorPos.x;
    %%%%%: 6506-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6506-block 25
    %%%%%: 6506-block 26
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6506-block 27
    %%%%%: 6506-block 28
    %%%%%: 6506-block 29
    #####: 6507:    frame_bb.Min.y = window->DC.CursorPos.y;
    #####: 6508:    frame_bb.Max.x = span_all_columns ? window->ParentWorkRect.Max.x : (flags & ImGuiTreeNodeFlags_SpanTextWidth) ? window->DC.CursorPos.x + text_width + padding.x : window->WorkRect.Max.x;
    %%%%%: 6508-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6508-block 31
    %%%%%: 6508-block 32
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6508-block 33
    %%%%%: 6508-block 34
    %%%%%: 6508-block 35
    #####: 6509:    frame_bb.Max.y = window->DC.CursorPos.y + frame_height;
    #####: 6510:    if (display_frame)
    %%%%%: 6510-block 36
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6511:    {
    #####: 6512:        const float outer_extend = IM_TRUNC(window->WindowPadding.x * 0.5f); // Framed header expand a little outside of current limits
    #####: 6513:        frame_bb.Min.x -= outer_extend;
    #####: 6514:        frame_bb.Max.x += outer_extend;
    %%%%%: 6514-block 37
        -: 6515:    }
        -: 6516:
    #####: 6517:    ImVec2 text_pos(window->DC.CursorPos.x + text_offset_x, window->DC.CursorPos.y + text_offset_y);
    %%%%%: 6517-block 38
call    0 never executed
    #####: 6518:    ItemSize(ImVec2(text_width, frame_height), padding.y);
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$: 6518-block 230
        -: 6519:
        -: 6520:    // For regular tree nodes, we arbitrary allow to click past 2 worth of ItemSpacing
    #####: 6521:    ImRect interact_bb = frame_bb;
    #####: 6522:    if ((flags & (ImGuiTreeNodeFlags_Framed | ImGuiTreeNodeFlags_SpanAvailWidth | ImGuiTreeNodeFlags_SpanFullWidth | ImGuiTreeNodeFlags_SpanTextWidth | ImGuiTreeNodeFlags_SpanAllColumns)) == 0)
    %%%%%: 6522-block 41
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6523:        interact_bb.Max.x = frame_bb.Min.x + text_width + (label_size.x > 0.0f ? style.ItemSpacing.x * 2.0f : 0.0f);
    %%%%%: 6523-block 42
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6523-block 43
    %%%%%: 6523-block 44
    %%%%%: 6523-block 45
        -: 6524:
        -: 6525:    // Compute open and multi-select states before ItemAdd() as it clear NextItem data.
    #####: 6526:    ImGuiID storage_id = (g.NextItemData.HasFlags & ImGuiNextItemDataFlags_HasStorageID) ? g.NextItemData.StorageId : id;
    %%%%%: 6526-block 46
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6526-block 47
    %%%%%: 6526-block 48
    #####: 6527:    bool is_open = TreeNodeUpdateNextOpen(storage_id, flags);
    %%%%%: 6527-block 49
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6528:
        -: 6529:    bool is_visible;
    #####: 6530:    if (span_all_columns)
    %%%%%: 6530-block 50
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6531:    {
        -: 6532:        // Modify ClipRect for the ItemAdd(), faster than doing a PushColumnsBackground/PushTableBackgroundChannel for every Selectable..
    #####: 6533:        const float backup_clip_rect_min_x = window->ClipRect.Min.x;
    #####: 6534:        const float backup_clip_rect_max_x = window->ClipRect.Max.x;
    #####: 6535:        window->ClipRect.Min.x = window->ParentWorkRect.Min.x;
    #####: 6536:        window->ClipRect.Max.x = window->ParentWorkRect.Max.x;
    #####: 6537:        is_visible = ItemAdd(interact_bb, id);
    %%%%%: 6537-block 51
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6538:        window->ClipRect.Min.x = backup_clip_rect_min_x;
    #####: 6539:        window->ClipRect.Max.x = backup_clip_rect_max_x;
    %%%%%: 6539-block 52
        -: 6540:    }
        -: 6541:    else
        -: 6542:    {
    #####: 6543:        is_visible = ItemAdd(interact_bb, id);
    %%%%%: 6543-block 53
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 6543-block 54
        -: 6544:    }
    #####: 6545:    g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HasDisplayRect;
    #####: 6546:    g.LastItemData.DisplayRect = frame_bb;
        -: 6547:
        -: 6548:    // If a NavLeft request is happening and ImGuiTreeNodeFlags_NavLeftJumpsBackHere enabled:
        -: 6549:    // Store data for the current depth to allow returning to this node from any child item.
        -: 6550:    // For this purpose we essentially compare if g.NavIdIsAlive went from 0 to 1 between TreeNode() and TreePop().
        -: 6551:    // It will become tempting to enable ImGuiTreeNodeFlags_NavLeftJumpsBackHere by default or move it to ImGuiStyle.
    #####: 6552:    bool store_tree_node_stack_data = false;
    #####: 6553:    if (!(flags & ImGuiTreeNodeFlags_NoTreePushOnOpen))
    %%%%%: 6553-block 55
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6554:    {
    #####: 6555:        if ((flags & ImGuiTreeNodeFlags_NavLeftJumpsBackHere) && is_open && !g.NavIdIsAlive)
    %%%%%: 6555-block 56
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6555-block 57
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6555-block 58
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 6556:            if (g.NavMoveDir == ImGuiDir_Left && g.NavWindow == window && NavMoveRequestButNoResultYet())
    %%%%%: 6556-block 59
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6556-block 60
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6556-block 61
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    %%%%%: 6556-block 62
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 6556-block 63
    %%%%%: 6556-block 64
    %%%%%: 6556-block 65
branch  9 never executed (fallthrough)
branch 10 never executed
    #####: 6557:                store_tree_node_stack_data = true;
    %%%%%: 6557-block 66
        -: 6558:    }
        -: 6559:
    #####: 6560:    const bool is_leaf = (flags & ImGuiTreeNodeFlags_Leaf) != 0;
    #####: 6561:    if (!is_visible)
    %%%%%: 6561-block 67
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6562:    {
    #####: 6563:        if (store_tree_node_stack_data && is_open)
    %%%%%: 6563-block 68
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6563-block 69
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 6564:            TreeNodeStoreStackData(flags); // Call before TreePushOverrideID()
    %%%%%: 6564-block 70
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6565:        if (is_open && !(flags & ImGuiTreeNodeFlags_NoTreePushOnOpen))
    %%%%%: 6565-block 71
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6565-block 72
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 6566:            TreePushOverrideID(id);
    %%%%%: 6566-block 73
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6567:        IMGUI_TEST_ENGINE_ITEM_INFO(g.LastItemData.ID, label, g.LastItemData.StatusFlags | (is_leaf ? 0 : ImGuiItemStatusFlags_Openable) | (is_open ? ImGuiItemStatusFlags_Opened : 0));
    #####: 6568:        return is_open;
    %%%%%: 6568-block 74
        -: 6569:    }
        -: 6570:
    #####: 6571:    if (span_all_columns)
    %%%%%: 6571-block 75
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6572:    {
    #####: 6573:        TablePushBackgroundChannel();
    %%%%%: 6573-block 76
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6574:        g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HasClipRect;
    #####: 6575:        g.LastItemData.ClipRect = window->ClipRect;
    %%%%%: 6575-block 77
        -: 6576:    }
        -: 6577:
    #####: 6578:    ImGuiButtonFlags button_flags = ImGuiTreeNodeFlags_None;
    #####: 6579:    if ((flags & ImGuiTreeNodeFlags_AllowOverlap) || (g.LastItemData.ItemFlags & ImGuiItemFlags_AllowOverlap))
    %%%%%: 6579-block 78
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6579-block 79
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 6580:        button_flags |= ImGuiButtonFlags_AllowOverlap;
    %%%%%: 6580-block 80
    #####: 6581:    if (!is_leaf)
    %%%%%: 6581-block 81
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6582:        button_flags |= ImGuiButtonFlags_PressedOnDragDropHold;
    %%%%%: 6582-block 82
        -: 6583:
        -: 6584:    // We allow clicking on the arrow section with keyboard modifiers held, in order to easily
        -: 6585:    // allow browsing a tree while preserving selection with code implementing multi-selection patterns.
        -: 6586:    // When clicking on the rest of the tree node we always disallow keyboard modifiers.
    #####: 6587:    const float arrow_hit_x1 = (text_pos.x - text_offset_x) - style.TouchExtraPadding.x;
    #####: 6588:    const float arrow_hit_x2 = (text_pos.x - text_offset_x) + (g.FontSize + padding.x * 2.0f) + style.TouchExtraPadding.x;
    #####: 6589:    const bool is_mouse_x_over_arrow = (g.IO.MousePos.x >= arrow_hit_x1 && g.IO.MousePos.x < arrow_hit_x2);
    %%%%%: 6589-block 83
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6589-block 84
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6589-block 85
    %%%%%: 6589-block 86
        -: 6590:
    #####: 6591:    const bool is_multi_select = (g.LastItemData.ItemFlags & ImGuiItemFlags_IsMultiSelect) != 0;
    #####: 6592:    if (is_multi_select) // We absolutely need to distinguish open vs select so _OpenOnArrow comes by default
    %%%%%: 6592-block 87
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6593:        flags |= (flags & ImGuiTreeNodeFlags_OpenOnMask_) == 0 ? ImGuiTreeNodeFlags_OpenOnArrow | ImGuiTreeNodeFlags_OpenOnDoubleClick : ImGuiTreeNodeFlags_OpenOnArrow;
    %%%%%: 6593-block 88
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6593-block 89
    %%%%%: 6593-block 90
    %%%%%: 6593-block 91
        -: 6594:
        -: 6595:    // Open behaviors can be altered with the _OpenOnArrow and _OnOnDoubleClick flags.
        -: 6596:    // Some alteration have subtle effects (e.g. toggle on MouseUp vs MouseDown events) due to requirements for multi-selection and drag and drop support.
        -: 6597:    // - Single-click on label = Toggle on MouseUp (default, when _OpenOnArrow=0)
        -: 6598:    // - Single-click on arrow = Toggle on MouseDown (when _OpenOnArrow=0)
        -: 6599:    // - Single-click on arrow = Toggle on MouseDown (when _OpenOnArrow=1)
        -: 6600:    // - Double-click on label = Toggle on MouseDoubleClick (when _OpenOnDoubleClick=1)
        -: 6601:    // - Double-click on arrow = Toggle on MouseDoubleClick (when _OpenOnDoubleClick=1 and _OpenOnArrow=0)
        -: 6602:    // It is rather standard that arrow click react on Down rather than Up.
        -: 6603:    // We set ImGuiButtonFlags_PressedOnClickRelease on OpenOnDoubleClick because we want the item to be active on the initial MouseDown in order for drag and drop to work.
    #####: 6604:    if (is_mouse_x_over_arrow)
    %%%%%: 6604-block 92
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6605:        button_flags |= ImGuiButtonFlags_PressedOnClick;
    %%%%%: 6605-block 93
    #####: 6606:    else if (flags & ImGuiTreeNodeFlags_OpenOnDoubleClick)
    %%%%%: 6606-block 94
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6607:        button_flags |= ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnDoubleClick;
    %%%%%: 6607-block 95
        -: 6608:    else
    #####: 6609:        button_flags |= ImGuiButtonFlags_PressedOnClickRelease;
    %%%%%: 6609-block 96
        -: 6610:
    #####: 6611:    bool selected = (flags & ImGuiTreeNodeFlags_Selected) != 0;
    #####: 6612:    const bool was_selected = selected;
        -: 6613:
        -: 6614:    // Multi-selection support (header)
    #####: 6615:    if (is_multi_select)
    %%%%%: 6615-block 97
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6616:    {
        -: 6617:        // Handle multi-select + alter button flags for it
    #####: 6618:        MultiSelectItemHeader(id, &selected, &button_flags);
    %%%%%: 6618-block 98
call    0 never executed
    #####: 6619:        if (is_mouse_x_over_arrow)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6620:            button_flags = (button_flags | ImGuiButtonFlags_PressedOnClick) & ~ImGuiButtonFlags_PressedOnClickRelease;
    %%%%%: 6620-block 100
        -: 6621:    }
        -: 6622:    else
        -: 6623:    {
    #####: 6624:        if (window != g.HoveredWindow || !is_mouse_x_over_arrow)
    %%%%%: 6624-block 101
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6624-block 102
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 6625:            button_flags |= ImGuiButtonFlags_NoKeyModsAllowed;
    %%%%%: 6625-block 103
        -: 6626:    }
        -: 6627:
        -: 6628:    bool hovered, held;
    #####: 6629:    bool pressed = ButtonBehavior(interact_bb, id, &hovered, &held, button_flags);
    %%%%%: 6629-block 104
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6630:    bool toggled = false;
    #####: 6631:    if (!is_leaf)
    %%%%%: 6631-block 105
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6632:    {
    #####: 6633:        if (pressed && g.DragDropHoldJustPressedId != id)
    %%%%%: 6633-block 106
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6633-block 107
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 6634:        {
    #####: 6635:            if ((flags & ImGuiTreeNodeFlags_OpenOnMask_) == 0 || (g.NavActivateId == id && !is_multi_select))
    %%%%%: 6635-block 108
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6635-block 109
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6635-block 110
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 6636:                toggled = true; // Single click
    %%%%%: 6636-block 111
    #####: 6637:            if (flags & ImGuiTreeNodeFlags_OpenOnArrow)
    %%%%%: 6637-block 112
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6638:                toggled |= is_mouse_x_over_arrow && !g.NavHighlightItemUnderNav; // Lightweight equivalent of IsMouseHoveringRect() since ButtonBehavior() already did the job
    %%%%%: 6638-block 113
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6638-block 114
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6638-block 115
    %%%%%: 6638-block 116
    %%%%%: 6638-block 117
    #####: 6639:            if ((flags & ImGuiTreeNodeFlags_OpenOnDoubleClick) && g.IO.MouseClickedCount[0] == 2)
    %%%%%: 6639-block 118
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6639-block 119
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 6640:                toggled = true; // Double click
    %%%%%: 6640-block 120
        -: 6641:        }
    #####: 6642:        else if (pressed && g.DragDropHoldJustPressedId == id)
    %%%%%: 6642-block 122
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6642-block 123
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 6643:        {
    #####: 6644:            IM_ASSERT(button_flags & ImGuiButtonFlags_PressedOnDragDropHold);
    %%%%%: 6644-block 124
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6644-block 125
call    2 never executed
    #####: 6645:            if (!is_open) // When using Drag and Drop "hold to open" we keep the node highlighted after opening, but never close it again.
    %%%%%: 6645-block 126
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6646:                toggled = true;
    %%%%%: 6646-block 127
        -: 6647:            else
    #####: 6648:                pressed = false; // Cancel press so it doesn't trigger selection.
    %%%%%: 6648-block 128
        -: 6649:        }
        -: 6650:
    #####: 6651:        if (g.NavId == id && g.NavMoveDir == ImGuiDir_Left && is_open)
    %%%%%: 6651-block 129
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6651-block 130
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6651-block 131
branch  4 never executed (fallthrough)
branch  5 never executed
        -: 6652:        {
    #####: 6653:            toggled = true;
    #####: 6654:            NavClearPreferredPosForAxis(ImGuiAxis_X);
    %%%%%: 6654-block 132
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6655:            NavMoveRequestCancel();
    %%%%%: 6655-block 133
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6656:        }
    #####: 6657:        if (g.NavId == id && g.NavMoveDir == ImGuiDir_Right && !is_open) // If there's something upcoming on the line we may want to give it the priority?
    %%%%%: 6657-block 134
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6657-block 135
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6657-block 136
branch  4 never executed (fallthrough)
branch  5 never executed
        -: 6658:        {
    #####: 6659:            toggled = true;
    #####: 6660:            NavClearPreferredPosForAxis(ImGuiAxis_X);
    %%%%%: 6660-block 137
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6661:            NavMoveRequestCancel();
    %%%%%: 6661-block 138
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6662:        }
        -: 6663:
    #####: 6664:        if (toggled)
    %%%%%: 6664-block 139
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6665:        {
    #####: 6666:            is_open = !is_open;
    #####: 6667:            window->DC.StateStorage->SetInt(storage_id, is_open);
    %%%%%: 6667-block 140
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6668:            g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_ToggledOpen;
    %%%%%: 6668-block 141
        -: 6669:        }
        -: 6670:    }
        -: 6671:
        -: 6672:    // Multi-selection support (footer)
    #####: 6673:    if (is_multi_select)
    %%%%%: 6673-block 142
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6674:    {
    #####: 6675:        bool pressed_copy = pressed && !toggled;
    %%%%%: 6675-block 143
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6675-block 144
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6675-block 145
    %%%%%: 6675-block 146
    #####: 6676:        MultiSelectItemFooter(id, &selected, &pressed_copy);
    %%%%%: 6676-block 147
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6677:        if (pressed)
    %%%%%: 6677-block 148
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6678:            SetNavID(id, window->DC.NavLayerCurrent, g.CurrentFocusScopeId, interact_bb);
    %%%%%: 6678-block 149
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6679:    }
        -: 6680:
    #####: 6681:    if (selected != was_selected)
    %%%%%: 6681-block 151
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6682:        g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_ToggledSelection;
    %%%%%: 6682-block 152
        -: 6683:
        -: 6684:    // Render
        -: 6685:    {
    #####: 6686:        const ImU32 text_col = GetColorU32(ImGuiCol_Text);
    %%%%%: 6686-block 153
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6687:        ImGuiNavRenderCursorFlags nav_render_cursor_flags = ImGuiNavRenderCursorFlags_Compact;
    #####: 6688:        if (is_multi_select)
    %%%%%: 6688-block 154
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6689:            nav_render_cursor_flags |= ImGuiNavRenderCursorFlags_AlwaysDraw; // Always show the nav rectangle
    %%%%%: 6689-block 155
    #####: 6690:        if (display_frame)
    %%%%%: 6690-block 156
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6691:        {
        -: 6692:            // Framed type
    #####: 6693:            const ImU32 bg_col = GetColorU32((held && hovered) ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered : ImGuiCol_Header);
    %%%%%: 6693-block 157
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6693-block 158
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6693-block 159
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 6693-block 160
    %%%%%: 6693-block 161
    %%%%%: 6693-block 162
    %%%%%: 6693-block 163
    %%%%%: 6693-block 164
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed (throw)
    #####: 6694:            RenderFrame(frame_bb.Min, frame_bb.Max, bg_col, true, style.FrameRounding);
    %%%%%: 6694-block 165
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6695:            RenderNavCursor(frame_bb, id, nav_render_cursor_flags);
    %%%%%: 6695-block 166
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6696:            if (flags & ImGuiTreeNodeFlags_Bullet)
    %%%%%: 6696-block 167
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6697:                RenderBullet(window->DrawList, ImVec2(text_pos.x - text_offset_x * 0.60f, text_pos.y + g.FontSize * 0.5f), text_col);
    %%%%%: 6697-block 168
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 6697-block 170
    $$$$$: 6697-block 232
    #####: 6698:            else if (!is_leaf)
    %%%%%: 6698-block 171
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6699:                RenderArrow(window->DrawList, ImVec2(text_pos.x - text_offset_x + padding.x, text_pos.y), text_col, is_open ? ((flags & ImGuiTreeNodeFlags_UpsideDownArrow) ? ImGuiDir_Up : ImGuiDir_Down) : ImGuiDir_Right, 1.0f);
    %%%%%: 6699-block 172
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6699-block 173
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6699-block 174
    %%%%%: 6699-block 175
    %%%%%: 6699-block 176
    %%%%%: 6699-block 177
    %%%%%: 6699-block 178
call    4 never executed
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
    %%%%%: 6699-block 180
    $$$$$: 6699-block 233
        -: 6700:            else // Leaf without bullet, left-adjusted text
    #####: 6701:                text_pos.x -= text_offset_x - padding.x;
    %%%%%: 6701-block 181
    #####: 6702:            if (flags & ImGuiTreeNodeFlags_ClipLabelForTrailingButton)
    %%%%%: 6702-block 182
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6703:                frame_bb.Max.x -= g.FontSize + style.FramePadding.x;
    %%%%%: 6703-block 183
    #####: 6704:            if (g.LogEnabled)
    %%%%%: 6704-block 184
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6705:                LogSetNextTextDecoration("###", "###");
    %%%%%: 6705-block 185
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6706:        }
        -: 6707:        else
        -: 6708:        {
        -: 6709:            // Unframed typed for tree nodes
    #####: 6710:            if (hovered || selected)
    %%%%%: 6710-block 186
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6710-block 187
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 6711:            {
    #####: 6712:                const ImU32 bg_col = GetColorU32((held && hovered) ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered : ImGuiCol_Header);
    %%%%%: 6712-block 188
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6712-block 189
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6712-block 190
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 6712-block 191
    %%%%%: 6712-block 192
    %%%%%: 6712-block 193
    %%%%%: 6712-block 194
    %%%%%: 6712-block 195
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed (throw)
    #####: 6713:                RenderFrame(frame_bb.Min, frame_bb.Max, bg_col, false);
    %%%%%: 6713-block 196
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6714:            }
    #####: 6715:            RenderNavCursor(frame_bb, id, nav_render_cursor_flags);
    %%%%%: 6715-block 197
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6716:            if (flags & ImGuiTreeNodeFlags_Bullet)
    %%%%%: 6716-block 198
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6717:                RenderBullet(window->DrawList, ImVec2(text_pos.x - text_offset_x * 0.5f, text_pos.y + g.FontSize * 0.5f), text_col);
    %%%%%: 6717-block 199
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 6717-block 201
    $$$$$: 6717-block 234
    #####: 6718:            else if (!is_leaf)
    %%%%%: 6718-block 202
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6719:                RenderArrow(window->DrawList, ImVec2(text_pos.x - text_offset_x + padding.x, text_pos.y + g.FontSize * 0.15f), text_col, is_open ? ((flags & ImGuiTreeNodeFlags_UpsideDownArrow) ? ImGuiDir_Up : ImGuiDir_Down) : ImGuiDir_Right, 0.70f);
    %%%%%: 6719-block 203
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6719-block 204
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6719-block 205
    %%%%%: 6719-block 206
    %%%%%: 6719-block 207
    %%%%%: 6719-block 208
    %%%%%: 6719-block 209
call    4 never executed
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
    %%%%%: 6719-block 211
    $$$$$: 6719-block 235
    #####: 6720:            if (g.LogEnabled)
    %%%%%: 6720-block 212
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6721:                LogSetNextTextDecoration(">", NULL);
    %%%%%: 6721-block 213
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6722:        }
        -: 6723:
    #####: 6724:        if (span_all_columns)
    %%%%%: 6724-block 214
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6725:            TablePopBackgroundChannel();
    %%%%%: 6725-block 215
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6726:
        -: 6727:        // Label
    #####: 6728:        if (display_frame)
    %%%%%: 6728-block 216
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6729:            RenderTextClipped(text_pos, frame_bb.Max, label, label_end, &label_size);
    %%%%%: 6729-block 217
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 6729-block 219
    $$$$$: 6729-block 236
        -: 6730:        else
    #####: 6731:            RenderText(text_pos, label, label_end, false);
    %%%%%: 6731-block 220
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6732:    }
        -: 6733:
    #####: 6734:    if (store_tree_node_stack_data && is_open)
    %%%%%: 6734-block 221
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6734-block 222
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 6735:        TreeNodeStoreStackData(flags); // Call before TreePushOverrideID()
    %%%%%: 6735-block 223
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6736:    if (is_open && !(flags & ImGuiTreeNodeFlags_NoTreePushOnOpen))
    %%%%%: 6736-block 224
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6736-block 225
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 6737:        TreePushOverrideID(id); // Could use TreePush(label) but this avoid computing twice
    %%%%%: 6737-block 226
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6738:
        -: 6739:    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags | (is_leaf ? 0 : ImGuiItemStatusFlags_Openable) | (is_open ? ImGuiItemStatusFlags_Opened : 0));
    #####: 6740:    return is_open;
    %%%%%: 6740-block 227
        -: 6741:}
        -: 6742:
function _ZN5ImGui8TreePushEPKc called 0 returned 0% blocks executed 0%
    #####: 6743:void ImGui::TreePush(const char* str_id)
        -: 6744:{
    #####: 6745:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%: 6745-block 2
call    0 never executed
    #####: 6746:    Indent();
call    0 never executed
    #####: 6747:    window->DC.TreeDepth++;
    #####: 6748:    PushID(str_id);
call    0 never executed
    #####: 6749:}
        -: 6750:
function _ZN5ImGui8TreePushEPKv called 0 returned 0% blocks executed 0%
    #####: 6751:void ImGui::TreePush(const void* ptr_id)
        -: 6752:{
    #####: 6753:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%: 6753-block 2
call    0 never executed
    #####: 6754:    Indent();
call    0 never executed
    #####: 6755:    window->DC.TreeDepth++;
    #####: 6756:    PushID(ptr_id);
call    0 never executed
    #####: 6757:}
        -: 6758:
function _ZN5ImGui18TreePushOverrideIDEj called 0 returned 0% blocks executed 0%
    #####: 6759:void ImGui::TreePushOverrideID(ImGuiID id)
        -: 6760:{
    #####: 6761:    ImGuiContext& g = *GImGui;
    #####: 6762:    ImGuiWindow* window = g.CurrentWindow;
    #####: 6763:    Indent();
    %%%%%: 6763-block 2
call    0 never executed
    #####: 6764:    window->DC.TreeDepth++;
    #####: 6765:    PushOverrideID(id);
call    0 never executed
    #####: 6766:}
        -: 6767:
function _ZN5ImGui7TreePopEv called 0 returned 0% blocks executed 0%
    #####: 6768:void ImGui::TreePop()
        -: 6769:{
    #####: 6770:    ImGuiContext& g = *GImGui;
    #####: 6771:    ImGuiWindow* window = g.CurrentWindow;
    #####: 6772:    Unindent();
    %%%%%: 6772-block 2
call    0 never executed
        -: 6773:
    #####: 6774:    window->DC.TreeDepth--;
    #####: 6775:    ImU32 tree_depth_mask = (1 << window->DC.TreeDepth);
        -: 6776:
    #####: 6777:    if (window->DC.TreeHasStackDataDepthMask & tree_depth_mask) // Only set during request
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6778:    {
    #####: 6779:        ImGuiTreeNodeStackData* data = &g.TreeNodeStack.back();
    %%%%%: 6779-block 4
call    0 never executed
    #####: 6780:        IM_ASSERT(data->ID == window->IDStack.back());
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 6780-block 7
call    3 never executed
    #####: 6781:        if (data->TreeFlags & ImGuiTreeNodeFlags_NavLeftJumpsBackHere)
    %%%%%: 6781-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6782:        {
        -: 6783:            // Handle Left arrow to move to parent tree node (when ImGuiTreeNodeFlags_NavLeftJumpsBackHere is enabled)
    #####: 6784:            if (g.NavIdIsAlive && g.NavMoveDir == ImGuiDir_Left && g.NavWindow == window && NavMoveRequestButNoResultYet())
    %%%%%: 6784-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6784-block 10
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6784-block 11
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 6784-block 12
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 6784-block 14
    %%%%%: 6784-block 15
    %%%%%: 6784-block 16
branch  9 never executed (fallthrough)
branch 10 never executed
    #####: 6785:                NavMoveRequestResolveWithPastTreeNode(&g.NavMoveResultLocal, data);
    %%%%%: 6785-block 17
call    0 never executed
        -: 6786:        }
    #####: 6787:        g.TreeNodeStack.pop_back();
    %%%%%: 6787-block 18
call    0 never executed
    #####: 6788:        window->DC.TreeHasStackDataDepthMask &= ~tree_depth_mask;
        -: 6789:    }
        -: 6790:
    #####: 6791:    IM_ASSERT(window->IDStack.Size > 1); // There should always be 1 element in the IDStack (pushed during window creation). If this triggers you called TreePop/PopID too much.
    %%%%%: 6791-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6791-block 21
call    2 never executed
    #####: 6792:    PopID();
    %%%%%: 6792-block 22
call    0 never executed
    #####: 6793:}
        -: 6794:
        -: 6795:// Horizontal distance preceding label when using TreeNode() or Bullet()
function _ZN5ImGui25GetTreeNodeToLabelSpacingEv called 0 returned 0% blocks executed 0%
    #####: 6796:float ImGui::GetTreeNodeToLabelSpacing()
        -: 6797:{
    #####: 6798:    ImGuiContext& g = *GImGui;
    #####: 6799:    return g.FontSize + (g.Style.FramePadding.x * 2.0f);
    %%%%%: 6799-block 2
        -: 6800:}
        -: 6801:
        -: 6802:// Set next TreeNode/CollapsingHeader open state.
function _ZN5ImGui15SetNextItemOpenEbi called 0 returned 0% blocks executed 0%
    #####: 6803:void ImGui::SetNextItemOpen(bool is_open, ImGuiCond cond)
        -: 6804:{
    #####: 6805:    ImGuiContext& g = *GImGui;
    #####: 6806:    if (g.CurrentWindow->SkipItems)
    %%%%%: 6806-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6807:        return;
    %%%%%: 6807-block 3
    #####: 6808:    g.NextItemData.HasFlags |= ImGuiNextItemDataFlags_HasOpen;
    #####: 6809:    g.NextItemData.OpenVal = is_open;
    #####: 6810:    g.NextItemData.OpenCond = (ImU8)(cond ? cond : ImGuiCond_Always);
    %%%%%: 6810-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6810-block 5
    %%%%%: 6810-block 6
    %%%%%: 6810-block 7
        -: 6811:}
        -: 6812:
        -: 6813:// Set next TreeNode/CollapsingHeader storage id.
function _ZN5ImGui20SetNextItemStorageIDEj called 0 returned 0% blocks executed 0%
    #####: 6814:void ImGui::SetNextItemStorageID(ImGuiID storage_id)
        -: 6815:{
    #####: 6816:    ImGuiContext& g = *GImGui;
    #####: 6817:    if (g.CurrentWindow->SkipItems)
    %%%%%: 6817-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6818:        return;
    %%%%%: 6818-block 3
    #####: 6819:    g.NextItemData.HasFlags |= ImGuiNextItemDataFlags_HasStorageID;
    #####: 6820:    g.NextItemData.StorageId = storage_id;
    %%%%%: 6820-block 4
        -: 6821:}
        -: 6822:
        -: 6823:// CollapsingHeader returns true when opened but do not indent nor push into the ID stack (because of the ImGuiTreeNodeFlags_NoTreePushOnOpen flag).
        -: 6824:// This is basically the same as calling TreeNodeEx(label, ImGuiTreeNodeFlags_CollapsingHeader). You can remove the _NoTreePushOnOpen flag if you want behavior closer to normal TreeNode().
function _ZN5ImGui16CollapsingHeaderEPKci called 0 returned 0% blocks executed 0%
    #####: 6825:bool ImGui::CollapsingHeader(const char* label, ImGuiTreeNodeFlags flags)
        -: 6826:{
    #####: 6827:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%: 6827-block 2
call    0 never executed
    #####: 6828:    if (window->SkipItems)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6829:        return false;
    %%%%%: 6829-block 4
    #####: 6830:    ImGuiID id = window->GetID(label);
    %%%%%: 6830-block 5
call    0 never executed
    #####: 6831:    return TreeNodeBehavior(id, flags | ImGuiTreeNodeFlags_CollapsingHeader, label);
call    0 never executed
        -: 6832:}
        -: 6833:
        -: 6834:// p_visible == NULL                        : regular collapsing header
        -: 6835:// p_visible != NULL && *p_visible == true  : show a small close button on the corner of the header, clicking the button will set *p_visible = false
        -: 6836:// p_visible != NULL && *p_visible == false : do not show the header at all
        -: 6837:// Do not mistake this with the Open state of the header itself, which you can adjust with SetNextItemOpen() or ImGuiTreeNodeFlags_DefaultOpen.
function _ZN5ImGui16CollapsingHeaderEPKcPbi called 0 returned 0% blocks executed 0%
    #####: 6838:bool ImGui::CollapsingHeader(const char* label, bool* p_visible, ImGuiTreeNodeFlags flags)
        -: 6839:{
    #####: 6840:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%: 6840-block 2
call    0 never executed
    #####: 6841:    if (window->SkipItems)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6842:        return false;
    %%%%%: 6842-block 4
        -: 6843:
    #####: 6844:    if (p_visible && !*p_visible)
    %%%%%: 6844-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 6844-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 6845:        return false;
    %%%%%: 6845-block 7
        -: 6846:
    #####: 6847:    ImGuiID id = window->GetID(label);
    %%%%%: 6847-block 8
call    0 never executed
    #####: 6848:    flags |= ImGuiTreeNodeFlags_CollapsingHeader;
    #####: 6849:    if (p_visible)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6850:        flags |= ImGuiTreeNodeFlags_AllowOverlap | (ImGuiTreeNodeFlags)ImGuiTreeNodeFlags_ClipLabelForTrailingButton;
    %%%%%: 6850-block 10
    #####: 6851:    bool is_open = TreeNodeBehavior(id, flags, label);
    %%%%%: 6851-block 11
call    0 never executed
    #####: 6852:    if (p_visible != NULL)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 6853:    {
        -: 6854:        // Create a small overlapping close button
        -: 6855:        // FIXME: We can evolve this into user accessible helpers to add extra buttons on title bars, headers, etc.
        -: 6856:        // FIXME: CloseButton can overlap into text, need find a way to clip the text somehow.
    #####: 6857:        ImGuiContext& g = *GImGui;
    #####: 6858:        ImGuiLastItemData last_item_backup = g.LastItemData;
    #####: 6859:        float button_size = g.FontSize;
    #####: 6860:        float button_x = ImMax(g.LastItemData.Rect.Min.x, g.LastItemData.Rect.Max.x - g.Style.FramePadding.x - button_size);
    %%%%%: 6860-block 13
call    0 never executed
    #####: 6861:        float button_y = g.LastItemData.Rect.Min.y + g.Style.FramePadding.y;
    #####: 6862:        ImGuiID close_button_id = GetIDWithSeed("#CLOSE", NULL, id);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6863:        if (CloseButton(close_button_id, ImVec2(button_x, button_y)))
    %%%%%: 6863-block 15
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 6863-block 17
branch  4 never executed (fallthrough)
branch  5 never executed
    $$$$$: 6863-block 22
    #####: 6864:            *p_visible = false;
    %%%%%: 6864-block 18
    #####: 6865:        g.LastItemData = last_item_backup;
    %%%%%: 6865-block 19
        -: 6866:    }
        -: 6867:
    #####: 6868:    return is_open;
    %%%%%: 6868-block 20
        -: 6869:}
        -: 6870:
        -: 6871://-------------------------------------------------------------------------
        -: 6872:// [SECTION] Widgets: Selectable
        -: 6873://-------------------------------------------------------------------------
        -: 6874:// - Selectable()
        -: 6875://-------------------------------------------------------------------------
        -: 6876:
        -: 6877:// Tip: pass a non-visible label (e.g. "##hello") then you can use the space to draw other text or image.
        -: 6878:// But you need to make sure the ID is unique, e.g. enclose calls in PushID/PopID or use ##unique_id.
        -: 6879:// With this scheme, ImGuiSelectableFlags_SpanAllColumns and ImGuiSelectableFlags_AllowOverlap are also frequently used flags.
        -: 6880:// FIXME: Selectable() with (size.x == 0.0f) and (SelectableTextAlign.x > 0.0f) followed by SameLine() is currently not supported.
function _ZN5ImGui10SelectableEPKcbiRK6ImVec2 called 28002 returned 100% blocks executed 51%
    28002: 6881:bool ImGui::Selectable(const char* label, bool selected, ImGuiSelectableFlags flags, const ImVec2& size_arg)
        -: 6882:{
    28002: 6883:    ImGuiWindow* window = GetCurrentWindow();
    28002: 6883-block 2
call    0 returned 28002
    28002: 6884:    if (window->SkipItems)
branch  0 taken 0 (fallthrough)
branch  1 taken 28002
    #####: 6885:        return false;
    %%%%%: 6885-block 4
        -: 6886:
    28002: 6887:    ImGuiContext& g = *GImGui;
    28002: 6888:    const ImGuiStyle& style = g.Style;
        -: 6889:
        -: 6890:    // Submit label or explicit size to ItemSize(), whereas ItemAdd() will submit a larger/spanning rectangle.
    28002: 6891:    ImGuiID id = window->GetID(label);
    28002: 6891-block 5
call    0 returned 28002
branch  1 taken 28002 (fallthrough)
branch  2 taken 0 (throw)
    28002: 6892:    ImVec2 label_size = CalcTextSize(label, NULL, true);
    28002: 6892-block 6
call    0 returned 28002
branch  1 taken 28002 (fallthrough)
branch  2 taken 0 (throw)
    28002: 6893:    ImVec2 size(size_arg.x != 0.0f ? size_arg.x : label_size.x, size_arg.y != 0.0f ? size_arg.y : label_size.y);
    28002: 6893-block 7
branch  0 taken 3231 (fallthrough)
branch  1 taken 24771
     3231: 6893-block 8
    24771: 6893-block 9
    28002: 6893-block 10
branch  2 taken 3231 (fallthrough)
branch  3 taken 24771
     3231: 6893-block 11
    24771: 6893-block 12
    28002: 6893-block 13
call    4 returned 28002
    28002: 6894:    ImVec2 pos = window->DC.CursorPos;
    28002: 6895:    pos.y += window->DC.CurrLineTextBaseOffset;
    28002: 6896:    ItemSize(size, 0.0f);
call    0 returned 28002
branch  1 taken 28002 (fallthrough)
branch  2 taken 0 (throw)
        -: 6897:
        -: 6898:    // Fill horizontal space
        -: 6899:    // We don't support (size < 0.0f) in Selectable() because the ItemSpacing extension would make explicitly right-aligned sizes not visibly match other widgets.
    28002: 6900:    const bool span_all_columns = (flags & ImGuiSelectableFlags_SpanAllColumns) != 0;
   28002*: 6901:    const float min_x = span_all_columns ? window->ParentWorkRect.Min.x : pos.x;
    28002: 6901-block 15
branch  0 taken 0 (fallthrough)
branch  1 taken 28002
    %%%%%: 6901-block 16
    28002: 6901-block 17
   28002*: 6902:    const float max_x = span_all_columns ? window->ParentWorkRect.Max.x : window->WorkRect.Max.x;
    28002: 6902-block 18
branch  0 taken 0 (fallthrough)
branch  1 taken 28002
    %%%%%: 6902-block 19
    28002: 6902-block 20
    28002: 6903:    if (size_arg.x == 0.0f || (flags & ImGuiSelectableFlags_SpanAvailWidth))
    28002: 6903-block 21
branch  0 taken 3231 (fallthrough)
branch  1 taken 24771
     3231: 6903-block 22
branch  2 taken 0 (fallthrough)
branch  3 taken 3231
    24771: 6904:        size.x = ImMax(label_size.x, max_x - min_x);
    24771: 6904-block 23
call    0 returned 24771
        -: 6905:
        -: 6906:    // Text stays at the submission position, but bounding box may be extended on both sides
    28002: 6907:    const ImVec2 text_min = pos;
    28002: 6908:    const ImVec2 text_max(min_x + size.x, pos.y + size.y);
    28002: 6908-block 25
call    0 returned 28002
        -: 6909:
        -: 6910:    // Selectables are meant to be tightly packed together with no click-gap, so we extend their box to cover spacing between selectable.
        -: 6911:    // FIXME: Not part of layout so not included in clipper calculation, but ItemSize currently doesn't allow offsetting CursorPos.
    28002: 6912:    ImRect bb(min_x, pos.y, text_max.x, text_max.y);
call    0 returned 28002
    28002: 6913:    if ((flags & ImGuiSelectableFlags_NoPadWithHalfSpacing) == 0)
branch  0 taken 28002 (fallthrough)
branch  1 taken 0
        -: 6914:    {
   28002*: 6915:        const float spacing_x = span_all_columns ? 0.0f : style.ItemSpacing.x;
    28002: 6915-block 28
branch  0 taken 0 (fallthrough)
branch  1 taken 28002
    %%%%%: 6915-block 29
    28002: 6915-block 30
    28002: 6916:        const float spacing_y = style.ItemSpacing.y;
    28002: 6917:        const float spacing_L = IM_TRUNC(spacing_x * 0.50f);
    28002: 6918:        const float spacing_U = IM_TRUNC(spacing_y * 0.50f);
    28002: 6919:        bb.Min.x -= spacing_L;
    28002: 6920:        bb.Min.y -= spacing_U;
    28002: 6921:        bb.Max.x += (spacing_x - spacing_L);
    28002: 6922:        bb.Max.y += (spacing_y - spacing_U);
    28002: 6922-block 31
        -: 6923:    }
        -: 6924:    //if (g.IO.KeyCtrl) { GetForegroundDrawList()->AddRect(bb.Min, bb.Max, IM_COL32(0, 255, 0, 255)); }
        -: 6925:
    28002: 6926:    const bool disabled_item = (flags & ImGuiSelectableFlags_Disabled) != 0;
   28002*: 6927:    const ImGuiItemFlags extra_item_flags = disabled_item ? (ImGuiItemFlags)ImGuiItemFlags_Disabled : ImGuiItemFlags_None;
    28002: 6927-block 32
branch  0 taken 0 (fallthrough)
branch  1 taken 28002
    %%%%%: 6927-block 33
    28002: 6927-block 34
        -: 6928:    bool is_visible;
    28002: 6929:    if (span_all_columns)
    28002: 6929-block 35
branch  0 taken 0 (fallthrough)
branch  1 taken 28002
        -: 6930:    {
        -: 6931:        // Modify ClipRect for the ItemAdd(), faster than doing a PushColumnsBackground/PushTableBackgroundChannel for every Selectable..
    #####: 6932:        const float backup_clip_rect_min_x = window->ClipRect.Min.x;
    #####: 6933:        const float backup_clip_rect_max_x = window->ClipRect.Max.x;
    #####: 6934:        window->ClipRect.Min.x = window->ParentWorkRect.Min.x;
    #####: 6935:        window->ClipRect.Max.x = window->ParentWorkRect.Max.x;
    #####: 6936:        is_visible = ItemAdd(bb, id, NULL, extra_item_flags);
    %%%%%: 6936-block 36
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6937:        window->ClipRect.Min.x = backup_clip_rect_min_x;
    #####: 6938:        window->ClipRect.Max.x = backup_clip_rect_max_x;
    %%%%%: 6938-block 37
        -: 6939:    }
        -: 6940:    else
        -: 6941:    {
    28002: 6942:        is_visible = ItemAdd(bb, id, NULL, extra_item_flags);
    28002: 6942-block 38
call    0 returned 28002
branch  1 taken 28002 (fallthrough)
branch  2 taken 0 (throw)
    28002: 6942-block 39
        -: 6943:    }
        -: 6944:
    28002: 6945:    const bool is_multi_select = (g.LastItemData.ItemFlags & ImGuiItemFlags_IsMultiSelect) != 0;
    28002: 6946:    if (!is_visible)
    28002: 6946-block 40
branch  0 taken 23 (fallthrough)
branch  1 taken 27979
      23*: 6947:        if (!is_multi_select || !g.BoxSelectState.UnclipMode || !g.BoxSelectState.UnclipRect.Overlaps(bb)) // Extra layer of "no logic clip" for box-select support (would be more overhead to add to ItemAdd)
       23: 6947-block 41
branch  0 taken 0 (fallthrough)
branch  1 taken 23
    %%%%%: 6947-block 42
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 6947-block 43
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed
       23: 6947-block 45
    %%%%%: 6947-block 46
       23: 6947-block 47
branch  7 taken 23 (fallthrough)
branch  8 taken 0
       23: 6948:            return false;
       23: 6948-block 48
        -: 6949:
    27979: 6950:    const bool disabled_global = (g.CurrentItemFlags & ImGuiItemFlags_Disabled) != 0;
   27979*: 6951:    if (disabled_item && !disabled_global) // Only testing this as an optimization
    27979: 6951-block 49
branch  0 taken 0 (fallthrough)
branch  1 taken 27979
    %%%%%: 6951-block 50
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 6952:        BeginDisabled();
    %%%%%: 6952-block 51
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6953:
        -: 6954:    // FIXME: We can standardize the behavior of those two, we could also keep the fast path of override ClipRect + full push on render only,
        -: 6955:    // which would be advantageous since most selectable are not selected.
    27979: 6956:    if (span_all_columns)
    27979: 6956-block 52
branch  0 taken 0 (fallthrough)
branch  1 taken 27979
        -: 6957:    {
    #####: 6958:        if (g.CurrentTable)
    %%%%%: 6958-block 53
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6959:            TablePushBackgroundChannel();
    %%%%%: 6959-block 54
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6960:        else if (window->DC.CurrentColumns)
    %%%%%: 6960-block 55
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 6961:            PushColumnsBackground();
    %%%%%: 6961-block 56
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 6962:        g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HasClipRect;
    #####: 6963:        g.LastItemData.ClipRect = window->ClipRect;
    %%%%%: 6963-block 57
        -: 6964:    }
        -: 6965:
        -: 6966:    // We use NoHoldingActiveID on menus so user can click and _hold_ on a menu then drag to browse child entries
    27979: 6967:    ImGuiButtonFlags button_flags = 0;
    27979: 6968:    if (flags & ImGuiSelectableFlags_NoHoldingActiveID) { button_flags |= ImGuiButtonFlags_NoHoldingActiveId; }
    27979: 6968-block 58
branch  0 taken 3231 (fallthrough)
branch  1 taken 24748
     3231: 6968-block 59
    27979: 6969:    if (flags & ImGuiSelectableFlags_NoSetKeyOwner)     { button_flags |= ImGuiButtonFlags_NoSetKeyOwner; }
    27979: 6969-block 60
branch  0 taken 3231 (fallthrough)
branch  1 taken 24748
     3231: 6969-block 61
    27979: 6970:    if (flags & ImGuiSelectableFlags_SelectOnClick)     { button_flags |= ImGuiButtonFlags_PressedOnClick; }
    27979: 6970-block 62
branch  0 taken 3231 (fallthrough)
branch  1 taken 24748
     3231: 6970-block 63
   27979*: 6971:    if (flags & ImGuiSelectableFlags_SelectOnRelease)   { button_flags |= ImGuiButtonFlags_PressedOnRelease; }
    27979: 6971-block 64
branch  0 taken 0 (fallthrough)
branch  1 taken 27979
    %%%%%: 6971-block 65
   27979*: 6972:    if (flags & ImGuiSelectableFlags_AllowDoubleClick)  { button_flags |= ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnDoubleClick; }
    27979: 6972-block 66
branch  0 taken 0 (fallthrough)
branch  1 taken 27979
    %%%%%: 6972-block 67
   27979*: 6973:    if ((flags & ImGuiSelectableFlags_AllowOverlap) || (g.LastItemData.ItemFlags & ImGuiItemFlags_AllowOverlap)) { button_flags |= ImGuiButtonFlags_AllowOverlap; }
    27979: 6973-block 68
branch  0 taken 27979 (fallthrough)
branch  1 taken 0
    27979: 6973-block 69
branch  2 taken 0 (fallthrough)
branch  3 taken 27979
    %%%%%: 6973-block 70
        -: 6974:
        -: 6975:    // Multi-selection support (header)
    27979: 6976:    const bool was_selected = selected;
    27979: 6977:    if (is_multi_select)
    27979: 6977-block 71
branch  0 taken 0 (fallthrough)
branch  1 taken 27979
        -: 6978:    {
        -: 6979:        // Handle multi-select + alter button flags for it
    #####: 6980:        MultiSelectItemHeader(id, &selected, &button_flags);
    %%%%%: 6980-block 72
call    0 never executed
        -: 6981:    }
        -: 6982:
        -: 6983:    bool hovered, held;
    27979: 6984:    bool pressed = ButtonBehavior(bb, id, &hovered, &held, button_flags);
    27979: 6984-block 73
call    0 returned 27979
branch  1 taken 27979 (fallthrough)
branch  2 taken 0 (throw)
        -: 6985:
        -: 6986:    // Multi-selection support (footer)
    27979: 6987:    if (is_multi_select)
    27979: 6987-block 74
branch  0 taken 0 (fallthrough)
branch  1 taken 27979
        -: 6988:    {
    #####: 6989:        MultiSelectItemFooter(id, &selected, &pressed);
    %%%%%: 6989-block 75
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 6990:    }
        -: 6991:    else
        -: 6992:    {
        -: 6993:        // Auto-select when moved into
        -: 6994:        // - This will be more fully fleshed in the range-select branch
        -: 6995:        // - This is not exposed as it won't nicely work with some user side handling of shift/control
        -: 6996:        // - We cannot do 'if (g.NavJustMovedToId != id) { selected = false; pressed = was_selected; }' for two reasons
        -: 6997:        //   - (1) it would require focus scope to be set, need exposing PushFocusScope() or equivalent (e.g. BeginSelection() calling PushFocusScope())
        -: 6998:        //   - (2) usage will fail with clipped items
        -: 6999:        //   The multi-select API aim to fix those issues, e.g. may be replaced with a BeginSelection() API.
   27979*: 7000:        if ((flags & ImGuiSelectableFlags_SelectOnNav) && g.NavJustMovedToId != 0 && g.NavJustMovedToFocusScopeId == g.CurrentFocusScopeId)
    27979: 7000-block 76
branch  0 taken 0 (fallthrough)
branch  1 taken 27979
    %%%%%: 7000-block 77
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7000-block 78
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 7001:            if (g.NavJustMovedToId == id)
    %%%%%: 7001-block 79
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7002:                selected = pressed = true;
    %%%%%: 7002-block 80
        -: 7003:    }
        -: 7004:
        -: 7005:    // Update NavId when clicking or when Hovering (this doesn't happen on most widgets), so navigation can be resumed with keyboard/gamepad
   27979*: 7006:    if (pressed || (hovered && (flags & ImGuiSelectableFlags_SetNavIdOnHover)))
    27979: 7006-block 81
branch  0 taken 27979 (fallthrough)
branch  1 taken 0
    27979: 7006-block 82
branch  2 taken 0 (fallthrough)
branch  3 taken 27979
    %%%%%: 7006-block 83
branch  4 never executed (fallthrough)
branch  5 never executed
        -: 7007:    {
    #####: 7008:        if (!g.NavHighlightItemUnderNav && g.NavWindow == window && g.NavLayer == window->DC.NavLayerCurrent)
    %%%%%: 7008-block 84
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7008-block 85
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7008-block 86
branch  4 never executed (fallthrough)
branch  5 never executed
        -: 7009:        {
    #####: 7010:            SetNavID(id, window->DC.NavLayerCurrent, g.CurrentFocusScopeId, WindowRectAbsToRel(window, bb)); // (bb == NavRect)
    %%%%%: 7010-block 87
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$: 7010-block 141
    #####: 7011:            if (g.IO.ConfigNavCursorVisibleAuto)
    %%%%%: 7011-block 89
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7012:                g.NavCursorVisible = false;
    %%%%%: 7012-block 90
        -: 7013:        }
        -: 7014:    }
    27979: 7015:    if (pressed)
    27979: 7015-block 91
branch  0 taken 0 (fallthrough)
branch  1 taken 27979
    #####: 7016:        MarkItemEdited(id);
    %%%%%: 7016-block 92
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 7017:
    27979: 7018:    if (selected != was_selected)
    27979: 7018-block 93
branch  0 taken 0 (fallthrough)
branch  1 taken 27979
    #####: 7019:        g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_ToggledSelection;
    %%%%%: 7019-block 94
        -: 7020:
        -: 7021:    // Render
    27979: 7022:    if (is_visible)
    27979: 7022-block 95
branch  0 taken 27979 (fallthrough)
branch  1 taken 0
        -: 7023:    {
   27979*: 7024:        const bool highlighted = hovered || (flags & ImGuiSelectableFlags_Highlight);
    27979: 7024-block 96
branch  0 taken 27979 (fallthrough)
branch  1 taken 0
    27979: 7024-block 97
branch  2 taken 0 (fallthrough)
branch  3 taken 27979
    %%%%%: 7024-block 98
    27979: 7024-block 99
    27979: 7025:        if (highlighted || selected)
    27979: 7025-block 100
branch  0 taken 27979 (fallthrough)
branch  1 taken 0
    27979: 7025-block 101
branch  2 taken 0 (fallthrough)
branch  3 taken 27979
        -: 7026:        {
        -: 7027:            // FIXME-MULTISELECT: Styling: Color for 'selected' elements? ImGuiCol_HeaderSelected
        -: 7028:            ImU32 col;
    #####: 7029:            if (selected && !highlighted)
    %%%%%: 7029-block 102
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7029-block 103
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 7030:                col = GetColorU32(ImLerp(GetStyleColorVec4(ImGuiCol_Header), GetStyleColorVec4(ImGuiCol_HeaderHovered), 0.5f));
    %%%%%: 7030-block 104
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 7030-block 105
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    %%%%%: 7030-block 106
call    6 never executed
call    7 never executed
branch  8 never executed (fallthrough)
branch  9 never executed (throw)
    %%%%%: 7030-block 108
    $$$$$: 7030-block 142
        -: 7031:            else
    #####: 7032:                col = GetColorU32((held && highlighted) ? ImGuiCol_HeaderActive : highlighted ? ImGuiCol_HeaderHovered : ImGuiCol_Header);
    %%%%%: 7032-block 109
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7032-block 110
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7032-block 111
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 7032-block 112
    %%%%%: 7032-block 113
    %%%%%: 7032-block 114
    %%%%%: 7032-block 115
    %%%%%: 7032-block 116
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed (throw)
    %%%%%: 7032-block 117
    #####: 7033:            RenderFrame(bb.Min, bb.Max, col, false, 0.0f);
    %%%%%: 7033-block 118
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 7034:        }
    27979: 7035:        if (g.NavId == id)
    27979: 7035-block 119
branch  0 taken 0 (fallthrough)
branch  1 taken 27979
        -: 7036:        {
    #####: 7037:            ImGuiNavRenderCursorFlags nav_render_cursor_flags = ImGuiNavRenderCursorFlags_Compact | ImGuiNavRenderCursorFlags_NoRounding;
    #####: 7038:            if (is_multi_select)
    %%%%%: 7038-block 120
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7039:                nav_render_cursor_flags |= ImGuiNavRenderCursorFlags_AlwaysDraw; // Always show the nav rectangle
    %%%%%: 7039-block 121
    #####: 7040:            RenderNavCursor(bb, id, nav_render_cursor_flags);
    %%%%%: 7040-block 122
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 7041:        }
        -: 7042:    }
        -: 7043:
    27979: 7044:    if (span_all_columns)
    27979: 7044-block 123
branch  0 taken 0 (fallthrough)
branch  1 taken 27979
        -: 7045:    {
    #####: 7046:        if (g.CurrentTable)
    %%%%%: 7046-block 124
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7047:            TablePopBackgroundChannel();
    %%%%%: 7047-block 125
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7048:        else if (window->DC.CurrentColumns)
    %%%%%: 7048-block 126
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7049:            PopColumnsBackground();
    %%%%%: 7049-block 127
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 7050:    }
        -: 7051:
    27979: 7052:    if (is_visible)
    27979: 7052-block 128
branch  0 taken 27979 (fallthrough)
branch  1 taken 0
    27979: 7053:        RenderTextClipped(text_min, text_max, label, NULL, &label_size, style.SelectableTextAlign, &bb);
    27979: 7053-block 129
call    0 returned 27979
branch  1 taken 27979 (fallthrough)
branch  2 taken 0 (throw)
        -: 7054:
        -: 7055:    // Automatically close popups
   27979*: 7056:    if (pressed && (window->Flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiSelectableFlags_NoAutoClosePopups) && (g.LastItemData.ItemFlags & ImGuiItemFlags_AutoClosePopups))
    27979: 7056-block 130
branch  0 taken 0 (fallthrough)
branch  1 taken 27979
    %%%%%: 7056-block 131
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7056-block 132
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 7056-block 133
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 7057:        CloseCurrentPopup();
    %%%%%: 7057-block 134
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 7058:
   27979*: 7059:    if (disabled_item && !disabled_global)
    27979: 7059-block 135
branch  0 taken 0 (fallthrough)
branch  1 taken 27979
    %%%%%: 7059-block 136
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 7060:        EndDisabled();
    %%%%%: 7060-block 137
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 7061:
        -: 7062:    // Selectable() always returns a pressed state!
        -: 7063:    // Users of BeginMultiSelect()/EndMultiSelect() scope: you may call ImGui::IsItemToggledSelection() to retrieve
        -: 7064:    // selection toggle, only useful if you need that state updated (e.g. for rendering purpose) before reaching EndMultiSelect().
        -: 7065:    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags);
    27979: 7066:    return pressed; //-V1020
    27979: 7066-block 138
        -: 7067:}
        -: 7068:
function _ZN5ImGui10SelectableEPKcPbiRK6ImVec2 called 0 returned 0% blocks executed 0%
    #####: 7069:bool ImGui::Selectable(const char* label, bool* p_selected, ImGuiSelectableFlags flags, const ImVec2& size_arg)
        -: 7070:{
    #####: 7071:    if (Selectable(label, *p_selected, flags, size_arg))
    %%%%%: 7071-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -: 7072:    {
    #####: 7073:        *p_selected = !*p_selected;
    #####: 7074:        return true;
    %%%%%: 7074-block 4
        -: 7075:    }
    #####: 7076:    return false;
    %%%%%: 7076-block 5
        -: 7077:}
        -: 7078:
        -: 7079:
        -: 7080://-------------------------------------------------------------------------
        -: 7081:// [SECTION] Widgets: Typing-Select support
        -: 7082://-------------------------------------------------------------------------
        -: 7083:
        -: 7084:// [Experimental] Currently not exposed in public API.
        -: 7085:// Consume character inputs and return search request, if any.
        -: 7086:// This would typically only be called on the focused window or location you want to grab inputs for, e.g.
        -: 7087://   if (ImGui::IsWindowFocused(...))
        -: 7088://       if (ImGuiTypingSelectRequest* req = ImGui::GetTypingSelectRequest())
        -: 7089://           focus_idx = ImGui::TypingSelectFindMatch(req, my_items.size(), [](void*, int n) { return my_items[n]->Name; }, &my_items, -1);
        -: 7090:// However the code is written in a way where calling it from multiple locations is safe (e.g. to obtain buffer).
function _ZN5ImGui22GetTypingSelectRequestEi called 0 returned 0% blocks executed 0%
    #####: 7091:ImGuiTypingSelectRequest* ImGui::GetTypingSelectRequest(ImGuiTypingSelectFlags flags)
        -: 7092:{
    #####: 7093:    ImGuiContext& g = *GImGui;
    #####: 7094:    ImGuiTypingSelectState* data = &g.TypingSelectState;
    #####: 7095:    ImGuiTypingSelectRequest* out_request = &data->Request;
        -: 7096:
        -: 7097:    // Clear buffer
    #####: 7098:    const float TYPING_SELECT_RESET_TIMER = 1.80f;          // FIXME: Potentially move to IO config.
    #####: 7099:    const int TYPING_SELECT_SINGLE_CHAR_COUNT_FOR_LOCK = 4; // Lock single char matching when repeating same char 4 times
    #####: 7100:    if (data->SearchBuffer[0] != 0)
    %%%%%: 7100-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 7101:    {
    #####: 7102:        bool clear_buffer = false;
    #####: 7103:        clear_buffer |= (g.NavFocusScopeId != data->FocusScope);
    #####: 7104:        clear_buffer |= (data->LastRequestTime + TYPING_SELECT_RESET_TIMER < g.Time);
    #####: 7105:        clear_buffer |= g.NavAnyRequest;
    #####: 7106:        clear_buffer |= g.ActiveId != 0 && g.NavActivateId == 0; // Allow temporary SPACE activation to not interfere
    %%%%%: 7106-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7106-block 4
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7106-block 5
    %%%%%: 7106-block 6
    #####: 7107:        clear_buffer |= IsKeyPressed(ImGuiKey_Escape) || IsKeyPressed(ImGuiKey_Enter);
    %%%%%: 7107-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 7107-block 9
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 7107-block 11
    %%%%%: 7107-block 12
    #####: 7108:        clear_buffer |= IsKeyPressed(ImGuiKey_Backspace) && (flags & ImGuiTypingSelectFlags_AllowBackspace) == 0;
    %%%%%: 7108-block 13
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 7108-block 15
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 7108-block 16
    %%%%%: 7108-block 17
        -: 7109:        //if (clear_buffer) { IMGUI_DEBUG_LOG("GetTypingSelectRequest(): Clear SearchBuffer.\n"); }
    #####: 7110:        if (clear_buffer)
    %%%%%: 7110-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7111:            data->Clear();
    %%%%%: 7111-block 19
call    0 never executed
        -: 7112:    }
        -: 7113:
        -: 7114:    // Append to buffer
    #####: 7115:    const int buffer_max_len = IM_ARRAYSIZE(data->SearchBuffer) - 1;
    #####: 7116:    int buffer_len = (int)strlen(data->SearchBuffer);
    #####: 7117:    bool select_request = false;
    #####: 7118:    for (ImWchar w : g.IO.InputQueueCharacters)
    %%%%%: 7118-block 20
call    0 never executed
call    1 never executed
    %%%%%: 7118-block 42
    %%%%%: 7118-block 43
branch  2 never executed
branch  3 never executed (fallthrough)
        -: 7119:    {
    #####: 7120:        const int w_len = ImTextCountUtf8BytesFromStr(&w, &w + 1);
    %%%%%: 7120-block 22
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7121:        if (w < 32 || (buffer_len == 0 && ImCharIsBlankW(w)) || (buffer_len + w_len > buffer_max_len)) // Ignore leading blanks
    %%%%%: 7121-block 23
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7121-block 24
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7121-block 25
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 7121-block 27
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 7121-block 28
    %%%%%: 7121-block 29
    %%%%%: 7121-block 30
branch  9 never executed (fallthrough)
branch 10 never executed
    #####: 7122:            continue;
    %%%%%: 7122-block 31
    %%%%%: 7122-block 41
        -: 7123:        char w_buf[5];
    #####: 7124:        ImTextCharToUtf8(w_buf, (unsigned int)w);
    %%%%%: 7124-block 32
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7125:        if (data->SingleCharModeLock && w_len == out_request->SingleCharSize && memcmp(w_buf, data->SearchBuffer, w_len) == 0)
    %%%%%: 7125-block 33
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7125-block 34
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7125-block 35
branch  4 never executed (fallthrough)
branch  5 never executed
        -: 7126:        {
    #####: 7127:            select_request = true; // Same character: don't need to append to buffer.
    #####: 7128:            continue;
    %%%%%: 7128-block 36
        -: 7129:        }
    #####: 7130:        if (data->SingleCharModeLock)
    %%%%%: 7130-block 37
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 7131:        {
    #####: 7132:            data->Clear(); // Different character: clear
    %%%%%: 7132-block 38
call    0 never executed
    #####: 7133:            buffer_len = 0;
        -: 7134:        }
    #####: 7135:        memcpy(data->SearchBuffer + buffer_len, w_buf, w_len + 1); // Append
    #####: 7136:        buffer_len += w_len;
    #####: 7137:        select_request = true;
    %%%%%: 7137-block 40
        -: 7138:    }
    #####: 7139:    g.IO.InputQueueCharacters.resize(0);
    %%%%%: 7139-block 44
call    0 never executed
        -: 7140:
        -: 7141:    // Handle backspace
    #####: 7142:    if ((flags & ImGuiTypingSelectFlags_AllowBackspace) && IsKeyPressed(ImGuiKey_Backspace, ImGuiInputFlags_Repeat))
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7142-block 46
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 7142-block 48
    %%%%%: 7142-block 49
    %%%%%: 7142-block 50
branch  5 never executed (fallthrough)
branch  6 never executed
        -: 7143:    {
    #####: 7144:        char* p = (char*)(void*)ImTextFindPreviousUtf8Codepoint(data->SearchBuffer, data->SearchBuffer + buffer_len);
    %%%%%: 7144-block 51
call    0 never executed
    #####: 7145:        *p = 0;
    #####: 7146:        buffer_len = (int)(p - data->SearchBuffer);
        -: 7147:    }
        -: 7148:
        -: 7149:    // Return request if any
    #####: 7150:    if (buffer_len == 0)
    %%%%%: 7150-block 53
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7151:        return NULL;
    %%%%%: 7151-block 54
    #####: 7152:    if (select_request)
    %%%%%: 7152-block 55
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 7153:    {
    #####: 7154:        data->FocusScope = g.NavFocusScopeId;
    #####: 7155:        data->LastRequestFrame = g.FrameCount;
    #####: 7156:        data->LastRequestTime = (float)g.Time;
    %%%%%: 7156-block 56
        -: 7157:    }
    #####: 7158:    out_request->Flags = flags;
    #####: 7159:    out_request->SearchBufferLen = buffer_len;
    #####: 7160:    out_request->SearchBuffer = data->SearchBuffer;
    #####: 7161:    out_request->SelectRequest = (data->LastRequestFrame == g.FrameCount);
    #####: 7162:    out_request->SingleCharMode = false;
    #####: 7163:    out_request->SingleCharSize = 0;
        -: 7164:
        -: 7165:    // Calculate if buffer contains the same character repeated.
        -: 7166:    // - This can be used to implement a special search mode on first character.
        -: 7167:    // - Performed on UTF-8 codepoint for correctness.
        -: 7168:    // - SingleCharMode is always set for first input character, because it usually leads to a "next".
    #####: 7169:    if (flags & ImGuiTypingSelectFlags_AllowSingleCharMode)
    %%%%%: 7169-block 57
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 7170:    {
    #####: 7171:        const char* buf_begin = out_request->SearchBuffer;
    #####: 7172:        const char* buf_end = out_request->SearchBuffer + out_request->SearchBufferLen;
    #####: 7173:        const int c0_len = ImTextCountUtf8BytesFromChar(buf_begin, buf_end);
    %%%%%: 7173-block 58
call    0 never executed
    #####: 7174:        const char* p = buf_begin + c0_len;
    #####: 7175:        for (; p < buf_end; p += c0_len)
    %%%%%: 7175-block 62
    %%%%%: 7175-block 63
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 7176:            if (memcmp(buf_begin, p, (size_t)c0_len) != 0)
    %%%%%: 7176-block 60
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7177:                break;
    %%%%%: 7177-block 61
    #####: 7178:        const int single_char_count = (p == buf_end) ? (out_request->SearchBufferLen / c0_len) : 0;
    %%%%%: 7178-block 64
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7178-block 65
    %%%%%: 7178-block 66
    #####: 7179:        out_request->SingleCharMode = (single_char_count > 0 || data->SingleCharModeLock);
    %%%%%: 7179-block 67
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7179-block 68
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7179-block 69
    %%%%%: 7179-block 70
    #####: 7180:        out_request->SingleCharSize = (ImS8)c0_len;
    #####: 7181:        data->SingleCharModeLock |= (single_char_count >= TYPING_SELECT_SINGLE_CHAR_COUNT_FOR_LOCK); // From now on we stop search matching to lock to single char mode.
    %%%%%: 7181-block 71
        -: 7182:    }
        -: 7183:
    #####: 7184:    return out_request;
    %%%%%: 7184-block 72
        -: 7185:}
        -: 7186:
function _ZL14ImStrimatchlenPKcS0_S0_ called 0 returned 0% blocks executed 0%
    #####: 7187:static int ImStrimatchlen(const char* s1, const char* s1_end, const char* s2)
        -: 7188:{
    #####: 7189:    int match_len = 0;
    #####: 7190:    while (s1 < s1_end && ImToUpper(*s1++) == ImToUpper(*s2++))
    %%%%%: 7190-block 2
    %%%%%: 7190-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7190-block 5
call    2 never executed
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 7190-block 8
    %%%%%: 7190-block 9
    %%%%%: 7190-block 10
branch  6 never executed
branch  7 never executed (fallthrough)
    #####: 7191:        match_len++;
    %%%%%: 7191-block 3
    #####: 7192:    return match_len;
    %%%%%: 7192-block 11
        -: 7193:}
        -: 7194:
        -: 7195:// Default handler for finding a result for typing-select. You may implement your own.
        -: 7196:// You might want to display a tooltip to visualize the current request SearchBuffer
        -: 7197:// When SingleCharMode is set:
        -: 7198:// - it is better to NOT display a tooltip of other on-screen display indicator.
        -: 7199:// - the index of the currently focused item is required.
        -: 7200://   if your SetNextItemSelectionUserData() values are indices, you can obtain it from ImGuiMultiSelectIO::NavIdItem, otherwise from g.NavLastValidSelectionUserData.
function _ZN5ImGui21TypingSelectFindMatchEP24ImGuiTypingSelectRequestiPFPKcPviES4_i called 0 returned 0% blocks executed 0%
    #####: 7201:int ImGui::TypingSelectFindMatch(ImGuiTypingSelectRequest* req, int items_count, const char* (*get_item_name_func)(void*, int), void* user_data, int nav_item_idx)
        -: 7202:{
    #####: 7203:    if (req == NULL || req->SelectRequest == false) // Support NULL parameter so both calls can be done from same spot.
    %%%%%: 7203-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7203-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 7204:        return -1;
    %%%%%: 7204-block 4
    #####: 7205:    int idx = -1;
    #####: 7206:    if (req->SingleCharMode && (req->Flags & ImGuiTypingSelectFlags_AllowSingleCharMode))
    %%%%%: 7206-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7206-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 7207:        idx = TypingSelectFindNextSingleCharMatch(req, items_count, get_item_name_func, user_data, nav_item_idx);
    %%%%%: 7207-block 7
call    0 never executed
        -: 7208:    else
    #####: 7209:        idx = TypingSelectFindBestLeadingMatch(req, items_count, get_item_name_func, user_data);
    %%%%%: 7209-block 9
call    0 never executed
    #####: 7210:    if (idx != -1)
    %%%%%: 7210-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7211:        SetNavCursorVisibleAfterMove();
    %%%%%: 7211-block 12
call    0 never executed
    #####: 7212:    return idx;
    %%%%%: 7212-block 13
        -: 7213:}
        -: 7214:
        -: 7215:// Special handling when a single character is repeated: perform search on a single letter and goes to next.
function _ZN5ImGui35TypingSelectFindNextSingleCharMatchEP24ImGuiTypingSelectRequestiPFPKcPviES4_i called 0 returned 0% blocks executed 0%
    #####: 7216:int ImGui::TypingSelectFindNextSingleCharMatch(ImGuiTypingSelectRequest* req, int items_count, const char* (*get_item_name_func)(void*, int), void* user_data, int nav_item_idx)
        -: 7217:{
        -: 7218:    // FIXME: Assume selection user data is index. Would be extremely practical.
        -: 7219:    //if (nav_item_idx == -1)
        -: 7220:    //    nav_item_idx = (int)g.NavLastValidSelectionUserData;
        -: 7221:
    #####: 7222:    int first_match_idx = -1;
    #####: 7223:    bool return_next_match = false;
    #####: 7224:    for (int idx = 0; idx < items_count; idx++)
    %%%%%: 7224-block 2
    %%%%%: 7224-block 16
    %%%%%: 7224-block 17
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 7225:    {
    #####: 7226:        const char* item_name = get_item_name_func(user_data, idx);
    %%%%%: 7226-block 3
call    0 never executed
    #####: 7227:        if (ImStrimatchlen(req->SearchBuffer, req->SearchBuffer + req->SingleCharSize, item_name) < req->SingleCharSize)
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 7228:            continue;
    %%%%%: 7228-block 6
    #####: 7229:        if (return_next_match)                           // Return next matching item after current item.
    %%%%%: 7229-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7230:            return idx;
    %%%%%: 7230-block 8
    #####: 7231:        if (first_match_idx == -1 && nav_item_idx == -1) // Return first match immediately if we don't have a nav_item_idx value.
    %%%%%: 7231-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7231-block 10
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 7232:            return idx;
    %%%%%: 7232-block 11
    #####: 7233:        if (first_match_idx == -1)                       // Record first match for wrapping.
    %%%%%: 7233-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7234:            first_match_idx = idx;
    %%%%%: 7234-block 13
    #####: 7235:        if (nav_item_idx == idx)                         // Record that we encountering nav_item so we can return next match.
    %%%%%: 7235-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7236:            return_next_match = true;
    %%%%%: 7236-block 15
        -: 7237:    }
    #####: 7238:    return first_match_idx; // First result
    %%%%%: 7238-block 18
        -: 7239:}
        -: 7240:
function _ZN5ImGui32TypingSelectFindBestLeadingMatchEP24ImGuiTypingSelectRequestiPFPKcPviES4_ called 0 returned 0% blocks executed 0%
    #####: 7241:int ImGui::TypingSelectFindBestLeadingMatch(ImGuiTypingSelectRequest* req, int items_count, const char* (*get_item_name_func)(void*, int), void* user_data)
        -: 7242:{
    #####: 7243:    int longest_match_idx = -1;
    #####: 7244:    int longest_match_len = 0;
    #####: 7245:    for (int idx = 0; idx < items_count; idx++)
    %%%%%: 7245-block 2
    %%%%%: 7245-block 9
    %%%%%: 7245-block 10
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 7246:    {
    #####: 7247:        const char* item_name = get_item_name_func(user_data, idx);
    %%%%%: 7247-block 3
call    0 never executed
    #####: 7248:        const int match_len = ImStrimatchlen(req->SearchBuffer, req->SearchBuffer + req->SearchBufferLen, item_name);
call    0 never executed
    #####: 7249:        if (match_len <= longest_match_len)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7250:            continue;
    %%%%%: 7250-block 6
    #####: 7251:        longest_match_idx = idx;
    #####: 7252:        longest_match_len = match_len;
    #####: 7253:        if (match_len == req->SearchBufferLen)
    %%%%%: 7253-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7254:            break;
    %%%%%: 7254-block 8
        -: 7255:    }
    #####: 7256:    return longest_match_idx;
    %%%%%: 7256-block 11
        -: 7257:}
        -: 7258:
function _ZN5ImGui26DebugNodeTypingSelectStateEP22ImGuiTypingSelectState called 0 returned 0% blocks executed 0%
    #####: 7259:void ImGui::DebugNodeTypingSelectState(ImGuiTypingSelectState* data)
        -: 7260:{
        -: 7261:#ifndef IMGUI_DISABLE_DEBUG_TOOLS
    #####: 7262:    Text("SearchBuffer = \"%s\"", data->SearchBuffer);
    %%%%%: 7262-block 2
call    0 never executed
    #####: 7263:    Text("SingleCharMode = %d, Size = %d, Lock = %d", data->Request.SingleCharMode, data->Request.SingleCharSize, data->SingleCharModeLock);
call    0 never executed
    #####: 7264:    Text("LastRequest = time: %.2f, frame: %d", data->LastRequestTime, data->LastRequestFrame);
call    0 never executed
        -: 7265:#else
        -: 7266:    IM_UNUSED(data);
        -: 7267:#endif
    #####: 7268:}
        -: 7269:
        -: 7270://-------------------------------------------------------------------------
        -: 7271:// [SECTION] Widgets: Box-Select support
        -: 7272:// This has been extracted away from Multi-Select logic in the hope that it could eventually be used elsewhere, but hasn't been yet.
        -: 7273://-------------------------------------------------------------------------
        -: 7274:// Extra logic in MultiSelectItemFooter() and ImGuiListClipper::Step()
        -: 7275://-------------------------------------------------------------------------
        -: 7276:// - BoxSelectPreStartDrag() [Internal]
        -: 7277:// - BoxSelectActivateDrag() [Internal]
        -: 7278:// - BoxSelectDeactivateDrag() [Internal]
        -: 7279:// - BoxSelectScrollWithMouseDrag() [Internal]
        -: 7280:// - BeginBoxSelect() [Internal]
        -: 7281:// - EndBoxSelect() [Internal]
        -: 7282://-------------------------------------------------------------------------
        -: 7283:
        -: 7284:// Call on the initial click.
function _ZL21BoxSelectPreStartDragjx called 0 returned 0% blocks executed 0%
    #####: 7285:static void BoxSelectPreStartDrag(ImGuiID id, ImGuiSelectionUserData clicked_item)
        -: 7286:{
    #####: 7287:    ImGuiContext& g = *GImGui;
    #####: 7288:    ImGuiBoxSelectState* bs = &g.BoxSelectState;
    #####: 7289:    bs->ID = id;
    #####: 7290:    bs->IsStarting = true; // Consider starting box-select.
    #####: 7291:    bs->IsStartedFromVoid = (clicked_item == ImGuiSelectionUserData_Invalid);
    #####: 7292:    bs->IsStartedSetNavIdOnce = bs->IsStartedFromVoid;
    #####: 7293:    bs->KeyMods = g.IO.KeyMods;
    #####: 7294:    bs->StartPosRel = bs->EndPosRel = ImGui::WindowPosAbsToRel(g.CurrentWindow, g.IO.MousePos);
    %%%%%: 7294-block 2
call    0 never executed
    #####: 7295:    bs->ScrollAccum = ImVec2(0.0f, 0.0f);
call    0 never executed
    #####: 7296:}
        -: 7297:
function _ZL21BoxSelectActivateDragP19ImGuiBoxSelectStateP11ImGuiWindow called 0 returned 0% blocks executed 0%
    #####: 7298:static void BoxSelectActivateDrag(ImGuiBoxSelectState* bs, ImGuiWindow* window)
        -: 7299:{
    #####: 7300:    ImGuiContext& g = *GImGui;
    #####: 7301:    IMGUI_DEBUG_LOG_SELECTION("[selection] BeginBoxSelect() 0X%08X: Activate\n", bs->ID);
    %%%%%: 7301-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7301-block 3
call    2 never executed
    #####: 7302:    bs->IsActive = true;
    #####: 7303:    bs->Window = window;
    #####: 7304:    bs->IsStarting = false;
    #####: 7305:    ImGui::SetActiveID(bs->ID, window);
    %%%%%: 7305-block 4
call    0 never executed
    #####: 7306:    ImGui::SetActiveIdUsingAllKeyboardKeys();
call    0 never executed
    #####: 7307:    if (bs->IsStartedFromVoid && (bs->KeyMods & (ImGuiMod_Ctrl | ImGuiMod_Shift)) == 0)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7307-block 7
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 7308:        bs->RequestClear = true;
    %%%%%: 7308-block 8
    #####: 7309:}
        -: 7310:
function _ZL23BoxSelectDeactivateDragP19ImGuiBoxSelectState called 0 returned 0% blocks executed 0%
    #####: 7311:static void BoxSelectDeactivateDrag(ImGuiBoxSelectState* bs)
        -: 7312:{
    #####: 7313:    ImGuiContext& g = *GImGui;
    #####: 7314:    bs->IsActive = bs->IsStarting = false;
    #####: 7315:    if (g.ActiveId == bs->ID)
    %%%%%: 7315-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 7316:    {
    #####: 7317:        IMGUI_DEBUG_LOG_SELECTION("[selection] BeginBoxSelect() 0X%08X: Deactivate\n", bs->ID);
    %%%%%: 7317-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7317-block 4
call    2 never executed
    #####: 7318:        ImGui::ClearActiveID();
    %%%%%: 7318-block 5
call    0 never executed
        -: 7319:    }
    #####: 7320:    bs->ID = 0;
    #####: 7321:}
        -: 7322:
function _ZL28BoxSelectScrollWithMouseDragP19ImGuiBoxSelectStateP11ImGuiWindowRK6ImRect called 0 returned 0% blocks executed 0%
    #####: 7323:static void BoxSelectScrollWithMouseDrag(ImGuiBoxSelectState* bs, ImGuiWindow* window, const ImRect& inner_r)
        -: 7324:{
    #####: 7325:    ImGuiContext& g = *GImGui;
    #####: 7326:    IM_ASSERT(bs->Window == window);
    %%%%%: 7326-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7326-block 3
call    2 never executed
    #####: 7327:    for (int n = 0; n < 2; n++) // each axis
    %%%%%: 7327-block 4
    %%%%%: 7327-block 40
    %%%%%: 7327-block 41
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 7328:    {
    #####: 7329:        const float mouse_pos = g.IO.MousePos[n];
    %%%%%: 7329-block 5
call    0 never executed
    #####: 7330:        const float dist = (mouse_pos > inner_r.Max[n]) ? mouse_pos - inner_r.Max[n] : (mouse_pos < inner_r.Min[n]) ? mouse_pos - inner_r.Min[n] : 0.0f;
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 7330-block 8
call    3 never executed
    %%%%%: 7330-block 10
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 7330-block 12
call    7 never executed
    %%%%%: 7330-block 14
    %%%%%: 7330-block 15
    #####: 7331:        const float scroll_curr = window->Scroll[n];
    %%%%%: 7331-block 16
call    0 never executed
    #####: 7332:        if (dist == 0.0f || (dist < 0.0f && scroll_curr < 0.0f) || (dist > 0.0f && scroll_curr >= window->ScrollMax[n]))
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7332-block 18
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7332-block 19
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 7332-block 20
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 7332-block 21
call    8 never executed
branch  9 never executed (fallthrough)
branch 10 never executed
    %%%%%: 7332-block 23
    %%%%%: 7332-block 24
    %%%%%: 7332-block 25
branch 11 never executed (fallthrough)
branch 12 never executed
    #####: 7333:            continue;
    %%%%%: 7333-block 26
        -: 7334:
    #####: 7335:        const float speed_multiplier = ImLinearRemapClamp(g.FontSize, g.FontSize * 5.0f, 1.0f, 4.0f, ImAbs(dist)); // x1 to x4 depending on distance
    %%%%%: 7335-block 27
call    0 never executed
call    1 never executed
    #####: 7336:        const float scroll_step = g.FontSize * 35.0f * speed_multiplier * ImSign(dist) * g.IO.DeltaTime;
call    0 never executed
    #####: 7337:        bs->ScrollAccum[n] += scroll_step;
call    0 never executed
        -: 7338:
        -: 7339:        // Accumulate into a stored value so we can handle high-framerate
    #####: 7340:        const float scroll_step_i = ImFloor(bs->ScrollAccum[n]);
call    0 never executed
call    1 never executed
    #####: 7341:        if (scroll_step_i == 0.0f)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7342:            continue;
    %%%%%: 7342-block 34
    #####: 7343:        if (n == 0)
    %%%%%: 7343-block 35
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7344:            ImGui::SetScrollX(window, scroll_curr + scroll_step_i);
    %%%%%: 7344-block 36
call    0 never executed
        -: 7345:        else
    #####: 7346:            ImGui::SetScrollY(window, scroll_curr + scroll_step_i);
    %%%%%: 7346-block 37
call    0 never executed
    #####: 7347:        bs->ScrollAccum[n] -= scroll_step_i;
    %%%%%: 7347-block 38
call    0 never executed
        -: 7348:    }
    #####: 7349:}
        -: 7350:
function _ZN5ImGui14BeginBoxSelectERK6ImRectP11ImGuiWindowji called 0 returned 0% blocks executed 0%
    #####: 7351:bool ImGui::BeginBoxSelect(const ImRect& scope_rect, ImGuiWindow* window, ImGuiID box_select_id, ImGuiMultiSelectFlags ms_flags)
        -: 7352:{
    #####: 7353:    ImGuiContext& g = *GImGui;
    #####: 7354:    ImGuiBoxSelectState* bs = &g.BoxSelectState;
    #####: 7355:    KeepAliveID(box_select_id);
    %%%%%: 7355-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7356:    if (bs->ID != box_select_id)
    %%%%%: 7356-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7357:        return false;
    %%%%%: 7357-block 4
        -: 7358:
        -: 7359:    // IsStarting is set by MultiSelectItemFooter() when considering a possible box-select. We validate it here and lock geometry.
    #####: 7360:    bs->UnclipMode = false;
    #####: 7361:    bs->RequestClear = false;
    #####: 7362:    if (bs->IsStarting && IsMouseDragPastThreshold(0))
    %%%%%: 7362-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7362-block 6
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 7362-block 7
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 7362-block 8
    %%%%%: 7362-block 9
    %%%%%: 7362-block 10
branch  7 never executed (fallthrough)
branch  8 never executed
    #####: 7363:        BoxSelectActivateDrag(bs, window);
    %%%%%: 7363-block 11
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7364:    else if ((bs->IsStarting || bs->IsActive) && g.IO.MouseDown[0] == false)
    %%%%%: 7364-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7364-block 13
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7364-block 14
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 7365:        BoxSelectDeactivateDrag(bs);
    %%%%%: 7365-block 15
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7366:    if (!bs->IsActive)
    %%%%%: 7366-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7367:        return false;
    %%%%%: 7367-block 17
        -: 7368:
        -: 7369:    // Current frame absolute prev/current rectangles are used to toggle selection.
        -: 7370:    // They are derived from positions relative to scrolling space.
    #####: 7371:    ImVec2 start_pos_abs = WindowPosRelToAbs(window, bs->StartPosRel);
    %%%%%: 7371-block 18
call    0 never executed
    #####: 7372:    ImVec2 prev_end_pos_abs = WindowPosRelToAbs(window, bs->EndPosRel); // Clamped already
call    0 never executed
    #####: 7373:    ImVec2 curr_end_pos_abs = g.IO.MousePos;
    #####: 7374:    if (ms_flags & ImGuiMultiSelectFlags_ScopeWindow) // Box-select scrolling only happens with ScopeWindow
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7375:        curr_end_pos_abs = ImClamp(curr_end_pos_abs, scope_rect.Min, scope_rect.Max);
    %%%%%: 7375-block 21
call    0 never executed
    #####: 7376:    bs->BoxSelectRectPrev.Min = ImMin(start_pos_abs, prev_end_pos_abs);
    %%%%%: 7376-block 22
call    0 never executed
    #####: 7377:    bs->BoxSelectRectPrev.Max = ImMax(start_pos_abs, prev_end_pos_abs);
call    0 never executed
    #####: 7378:    bs->BoxSelectRectCurr.Min = ImMin(start_pos_abs, curr_end_pos_abs);
call    0 never executed
    #####: 7379:    bs->BoxSelectRectCurr.Max = ImMax(start_pos_abs, curr_end_pos_abs);
call    0 never executed
        -: 7380:
        -: 7381:    // Box-select 2D mode detects horizontal changes (vertical ones are already picked by Clipper)
        -: 7382:    // Storing an extra rect used by widgets supporting box-select.
    #####: 7383:    if (ms_flags & ImGuiMultiSelectFlags_BoxSelect2d)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7384:        if (bs->BoxSelectRectPrev.Min.x != bs->BoxSelectRectCurr.Min.x || bs->BoxSelectRectPrev.Max.x != bs->BoxSelectRectCurr.Max.x)
    %%%%%: 7384-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7384-block 28
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 7385:        {
    #####: 7386:            bs->UnclipMode = true;
    #####: 7387:            bs->UnclipRect = bs->BoxSelectRectPrev; // FIXME-OPT: UnclipRect x coordinates could be intersection of Prev and Curr rect on X axis.
    #####: 7388:            bs->UnclipRect.Add(bs->BoxSelectRectCurr);
    %%%%%: 7388-block 29
call    0 never executed
        -: 7389:        }
        -: 7390:
        -: 7391:    //GetForegroundDrawList()->AddRect(bs->UnclipRect.Min, bs->UnclipRect.Max, IM_COL32(255,0,0,200), 0.0f, 0, 3.0f);
        -: 7392:    //GetForegroundDrawList()->AddRect(bs->BoxSelectRectPrev.Min, bs->BoxSelectRectPrev.Max, IM_COL32(255,0,0,200), 0.0f, 0, 3.0f);
        -: 7393:    //GetForegroundDrawList()->AddRect(bs->BoxSelectRectCurr.Min, bs->BoxSelectRectCurr.Max, IM_COL32(0,255,0,200), 0.0f, 0, 1.0f);
    #####: 7394:    return true;
    %%%%%: 7394-block 30
        -: 7395:}
        -: 7396:
function _ZN5ImGui12EndBoxSelectERK6ImRecti called 0 returned 0% blocks executed 0%
    #####: 7397:void ImGui::EndBoxSelect(const ImRect& scope_rect, ImGuiMultiSelectFlags ms_flags)
        -: 7398:{
    #####: 7399:    ImGuiContext& g = *GImGui;
    #####: 7400:    ImGuiWindow* window = g.CurrentWindow;
    #####: 7401:    ImGuiBoxSelectState* bs = &g.BoxSelectState;
    #####: 7402:    IM_ASSERT(bs->IsActive);
    %%%%%: 7402-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7402-block 3
call    2 never executed
    #####: 7403:    bs->UnclipMode = false;
        -: 7404:
        -: 7405:    // Render selection rectangle
    #####: 7406:    bs->EndPosRel = WindowPosAbsToRel(window, ImClamp(g.IO.MousePos, scope_rect.Min, scope_rect.Max)); // Clamp stored position according to current scrolling view
    %%%%%: 7406-block 4
call    0 never executed
call    1 never executed
    #####: 7407:    ImRect box_select_r = bs->BoxSelectRectCurr;
    #####: 7408:    box_select_r.ClipWith(scope_rect);
call    0 never executed
    #####: 7409:    window->DrawList->AddRectFilled(box_select_r.Min, box_select_r.Max, GetColorU32(ImGuiCol_SeparatorHovered, 0.30f)); // FIXME-MULTISELECT: Styling
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 7409-block 8
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    #####: 7410:    window->DrawList->AddRect(box_select_r.Min, box_select_r.Max, GetColorU32(ImGuiCol_NavCursor)); // FIXME-MULTISELECT: Styling
    %%%%%: 7410-block 9
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 7410-block 10
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
        -: 7411:
        -: 7412:    // Scroll
    #####: 7413:    const bool enable_scroll = (ms_flags & ImGuiMultiSelectFlags_ScopeWindow) && (ms_flags & ImGuiMultiSelectFlags_BoxSelectNoScroll) == 0;
    %%%%%: 7413-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7413-block 12
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7413-block 13
    %%%%%: 7413-block 14
    #####: 7414:    if (enable_scroll)
    %%%%%: 7414-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 7415:    {
    #####: 7416:        ImRect scroll_r = scope_rect;
    #####: 7417:        scroll_r.Expand(-g.FontSize);
    %%%%%: 7417-block 16
call    0 never executed
        -: 7418:        //GetForegroundDrawList()->AddRect(scroll_r.Min, scroll_r.Max, IM_COL32(0, 255, 0, 255));
    #####: 7419:        if (!scroll_r.Contains(g.IO.MousePos))
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 7420:            BoxSelectScrollWithMouseDrag(bs, window, scroll_r);
    %%%%%: 7420-block 19
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 7421:    }
    #####: 7422:}
    %%%%%: 7422-block 21
        -: 7423:
        -: 7424://-------------------------------------------------------------------------
        -: 7425:// [SECTION] Widgets: Multi-Select support
        -: 7426://-------------------------------------------------------------------------
        -: 7427:// - DebugLogMultiSelectRequests() [Internal]
        -: 7428:// - CalcScopeRect() [Internal]
        -: 7429:// - BeginMultiSelect()
        -: 7430:// - EndMultiSelect()
        -: 7431:// - SetNextItemSelectionUserData()
        -: 7432:// - MultiSelectItemHeader() [Internal]
        -: 7433:// - MultiSelectItemFooter() [Internal]
        -: 7434:// - DebugNodeMultiSelectState() [Internal]
        -: 7435://-------------------------------------------------------------------------
        -: 7436:
function _ZL27DebugLogMultiSelectRequestsPKcPK18ImGuiMultiSelectIO called 0 returned 0% blocks executed 0%
    #####: 7437:static void DebugLogMultiSelectRequests(const char* function, const ImGuiMultiSelectIO* io)
        -: 7438:{
    #####: 7439:    ImGuiContext& g = *GImGui;
        -: 7440:    IM_UNUSED(function);
    #####: 7441:    for (const ImGuiSelectionRequest& req : io->Requests)
    %%%%%: 7441-block 2
call    0 never executed
call    1 never executed
    %%%%%: 7441-block 13
    %%%%%: 7441-block 14
branch  2 never executed
branch  3 never executed (fallthrough)
        -: 7442:    {
    #####: 7443:        if (req.Type == ImGuiSelectionRequestType_SetAll)    IMGUI_DEBUG_LOG_SELECTION("[selection] %s: Request: SetAll %d (= %s)\n", function, req.Selected, req.Selected ? "SelectAll" : "Clear");
    %%%%%: 7443-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7443-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7443-block 6
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 7443-block 7
    %%%%%: 7443-block 8
    %%%%%: 7443-block 9
call    6 never executed
    #####: 7444:        if (req.Type == ImGuiSelectionRequestType_SetRange)  IMGUI_DEBUG_LOG_SELECTION("[selection] %s: Request: SetRange %" IM_PRId64 "..%" IM_PRId64 " (0x%" IM_PRIX64 "..0x%" IM_PRIX64 ") = %d (dir %d)\n", function, req.RangeFirstItem, req.RangeLastItem, req.RangeFirstItem, req.RangeLastItem, req.Selected, req.RangeDirection);
    %%%%%: 7444-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7444-block 11
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7444-block 12
call    4 never executed
        -: 7445:    }
    #####: 7446:}
        -: 7447:
function _ZL13CalcScopeRectP24ImGuiMultiSelectTempDataP11ImGuiWindow called 0 returned 0% blocks executed 0%
    #####: 7448:static ImRect CalcScopeRect(ImGuiMultiSelectTempData* ms, ImGuiWindow* window)
        -: 7449:{
    #####: 7450:    ImGuiContext& g = *GImGui;
    #####: 7451:    if (ms->Flags & ImGuiMultiSelectFlags_ScopeRect)
    %%%%%: 7451-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 7452:    {
        -: 7453:        // Warning: this depends on CursorMaxPos so it means to be called by EndMultiSelect() only
    #####: 7454:        return ImRect(ms->ScopeRectMin, ImMax(window->DC.CursorMaxPos, ms->ScopeRectMin));
    %%%%%: 7454-block 3
call    0 never executed
call    1 never executed
    %%%%%: 7454-block 6
        -: 7455:    }
        -: 7456:    else
        -: 7457:    {
        -: 7458:        // When a table, pull HostClipRect, which allows us to predict ClipRect before first row/layout is performed. (#7970)
    #####: 7459:        ImRect scope_rect = window->InnerClipRect;
    #####: 7460:        if (g.CurrentTable != NULL)
    %%%%%: 7460-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7461:            scope_rect = g.CurrentTable->HostClipRect;
    %%%%%: 7461-block 8
        -: 7462:
        -: 7463:        // Add inner table decoration (#7821) // FIXME: Why not baking in InnerClipRect?
    #####: 7464:        scope_rect.Min = ImMin(scope_rect.Min + ImVec2(window->DecoInnerSizeX1, window->DecoInnerSizeY1), scope_rect.Max);
    %%%%%: 7464-block 9
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 7465:        return scope_rect;
        -: 7466:    }
        -: 7467:}
        -: 7468:
        -: 7469:// Return ImGuiMultiSelectIO structure.
        -: 7470:// Lifetime: don't hold on ImGuiMultiSelectIO* pointers over multiple frames or past any subsequent call to BeginMultiSelect() or EndMultiSelect().
        -: 7471:// Passing 'selection_size' and 'items_count' parameters is currently optional.
        -: 7472:// - 'selection_size' is useful to disable some shortcut routing: e.g. ImGuiMultiSelectFlags_ClearOnEscape won't claim Escape key when selection_size 0,
        -: 7473://    allowing a first press to clear selection THEN the second press to leave child window and return to parent.
        -: 7474:// - 'items_count' is stored in ImGuiMultiSelectIO which makes it a convenient way to pass the information to your ApplyRequest() handler (but you may pass it differently).
        -: 7475:// - If they are costly for you to compute (e.g. external intrusive selection without maintaining size), you may avoid them and pass -1.
        -: 7476://   - If you can easily tell if your selection is empty or not, you may pass 0/1, or you may enable ImGuiMultiSelectFlags_ClearOnEscape flag dynamically.
function _ZN5ImGui16BeginMultiSelectEiii called 0 returned 0% blocks executed 0%
    #####: 7477:ImGuiMultiSelectIO* ImGui::BeginMultiSelect(ImGuiMultiSelectFlags flags, int selection_size, int items_count)
        -: 7478:{
    #####: 7479:    ImGuiContext& g = *GImGui;
    #####: 7480:    ImGuiWindow* window = g.CurrentWindow;
        -: 7481:
    #####: 7482:    if (++g.MultiSelectTempDataStacked > g.MultiSelectTempData.Size)
    %%%%%: 7482-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7483:        g.MultiSelectTempData.resize(g.MultiSelectTempDataStacked, ImGuiMultiSelectTempData());
    %%%%%: 7483-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 7483-block 4
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    %%%%%: 7483-block 5
call    6 never executed
    $$$$$: 7483-block 82
call    7 never executed
    $$$$$: 7483-block 84
call    8 never executed
    #####: 7484:    ImGuiMultiSelectTempData* ms = &g.MultiSelectTempData[g.MultiSelectTempDataStacked - 1];
    %%%%%: 7484-block 7
call    0 never executed
        -: 7485:    IM_STATIC_ASSERT(offsetof(ImGuiMultiSelectTempData, IO) == 0); // Clear() relies on that.
    #####: 7486:    g.CurrentMultiSelect = ms;
    #####: 7487:    if ((flags & (ImGuiMultiSelectFlags_ScopeWindow | ImGuiMultiSelectFlags_ScopeRect)) == 0)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7488:        flags |= ImGuiMultiSelectFlags_ScopeWindow;
    %%%%%: 7488-block 9
    #####: 7489:    if (flags & ImGuiMultiSelectFlags_SingleSelect)
    %%%%%: 7489-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7490:        flags &= ~(ImGuiMultiSelectFlags_BoxSelect2d | ImGuiMultiSelectFlags_BoxSelect1d);
    %%%%%: 7490-block 11
    #####: 7491:    if (flags & ImGuiMultiSelectFlags_BoxSelect2d)
    %%%%%: 7491-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7492:        flags &= ~ImGuiMultiSelectFlags_BoxSelect1d;
    %%%%%: 7492-block 13
        -: 7493:
        -: 7494:    // FIXME: BeginFocusScope()
    #####: 7495:    const ImGuiID id = window->IDStack.back();
    %%%%%: 7495-block 14
call    0 never executed
    #####: 7496:    ms->Clear();
call    0 never executed
    #####: 7497:    ms->FocusScopeId = id;
    #####: 7498:    ms->Flags = flags;
    #####: 7499:    ms->IsFocused = (ms->FocusScopeId == g.NavFocusScopeId);
    #####: 7500:    ms->BackupCursorMaxPos = window->DC.CursorMaxPos;
    #####: 7501:    ms->ScopeRectMin = window->DC.CursorMaxPos = window->DC.CursorPos;
    #####: 7502:    PushFocusScope(ms->FocusScopeId);
call    0 never executed
    #####: 7503:    if (flags & ImGuiMultiSelectFlags_ScopeWindow) // Mark parent child window as navigable into, with highlight. Assume user will always submit interactive items.
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7504:        window->DC.NavLayersActiveMask |= 1 << ImGuiNavLayer_Main;
    %%%%%: 7504-block 18
        -: 7505:
        -: 7506:    // Use copy of keyboard mods at the time of the request, otherwise we would requires mods to be held for an extra frame.
    #####: 7507:    ms->KeyMods = g.NavJustMovedToId ? (g.NavJustMovedToIsTabbing ? 0 : g.NavJustMovedToKeyMods) : g.IO.KeyMods;
    %%%%%: 7507-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7507-block 20
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7507-block 21
    %%%%%: 7507-block 22
    %%%%%: 7507-block 23
    %%%%%: 7507-block 24
    #####: 7508:    if (flags & ImGuiMultiSelectFlags_NoRangeSelect)
    %%%%%: 7508-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7509:        ms->KeyMods &= ~ImGuiMod_Shift;
    %%%%%: 7509-block 26
        -: 7510:
        -: 7511:    // Bind storage
    #####: 7512:    ImGuiMultiSelectState* storage = g.MultiSelectStorage.GetOrAddByKey(id);
    %%%%%: 7512-block 27
call    0 never executed
    #####: 7513:    storage->ID = id;
    #####: 7514:    storage->LastFrameActive = g.FrameCount;
    #####: 7515:    storage->LastSelectionSize = selection_size;
    #####: 7516:    storage->Window = window;
    #####: 7517:    ms->Storage = storage;
        -: 7518:
        -: 7519:    // Output to user
    #####: 7520:    ms->IO.Requests.resize(0);
call    0 never executed
    #####: 7521:    ms->IO.RangeSrcItem = storage->RangeSrcItem;
    #####: 7522:    ms->IO.NavIdItem = storage->NavIdItem;
    #####: 7523:    ms->IO.NavIdSelected = (storage->NavIdSelected == 1) ? true : false;
    #####: 7524:    ms->IO.ItemsCount = items_count;
        -: 7525:
        -: 7526:    // Clear when using Navigation to move within the scope
        -: 7527:    // (we compare FocusScopeId so it possible to use multiple selections inside a same window)
    #####: 7528:    bool request_clear = false;
    #####: 7529:    bool request_select_all = false;
    #####: 7530:    if (g.NavJustMovedToId != 0 && g.NavJustMovedToFocusScopeId == ms->FocusScopeId && g.NavJustMovedToHasSelectionData)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7530-block 30
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7530-block 31
branch  4 never executed (fallthrough)
branch  5 never executed
        -: 7531:    {
    #####: 7532:        if (ms->KeyMods & ImGuiMod_Shift)
    %%%%%: 7532-block 32
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7533:            ms->IsKeyboardSetRange = true;
    %%%%%: 7533-block 33
    #####: 7534:        if (ms->IsKeyboardSetRange)
    %%%%%: 7534-block 34
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7535:            IM_ASSERT(storage->RangeSrcItem != ImGuiSelectionUserData_Invalid); // Not ready -> could clear?
    %%%%%: 7535-block 35
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7535-block 36
call    2 never executed
    #####: 7536:        if ((ms->KeyMods & (ImGuiMod_Ctrl | ImGuiMod_Shift)) == 0 && (flags & (ImGuiMultiSelectFlags_NoAutoClear | ImGuiMultiSelectFlags_NoAutoSelect)) == 0)
    %%%%%: 7536-block 37
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7536-block 38
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 7537:            request_clear = true;
    %%%%%: 7537-block 39
        -: 7538:    }
    #####: 7539:    else if (g.NavJustMovedFromFocusScopeId == ms->FocusScopeId)
    %%%%%: 7539-block 41
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 7540:    {
        -: 7541:        // Also clear on leaving scope (may be optional?)
    #####: 7542:        if ((ms->KeyMods & (ImGuiMod_Ctrl | ImGuiMod_Shift)) == 0 && (flags & (ImGuiMultiSelectFlags_NoAutoClear | ImGuiMultiSelectFlags_NoAutoSelect)) == 0)
    %%%%%: 7542-block 42
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7542-block 43
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 7543:            request_clear = true;
    %%%%%: 7543-block 44
        -: 7544:    }
        -: 7545:
        -: 7546:    // Box-select handling: update active state.
    #####: 7547:    ImGuiBoxSelectState* bs = &g.BoxSelectState;
    #####: 7548:    if (flags & (ImGuiMultiSelectFlags_BoxSelect1d | ImGuiMultiSelectFlags_BoxSelect2d))
    %%%%%: 7548-block 45
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 7549:    {
    #####: 7550:        ms->BoxSelectId = GetID("##BoxSelect");
    %%%%%: 7550-block 46
call    0 never executed
    #####: 7551:        if (BeginBoxSelect(CalcScopeRect(ms, window), window, ms->BoxSelectId, flags))
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 7551-block 49
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 7552:            request_clear |= bs->RequestClear;
    %%%%%: 7552-block 50
        -: 7553:    }
        -: 7554:
    #####: 7555:    if (ms->IsFocused)
    %%%%%: 7555-block 51
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 7556:    {
        -: 7557:        // Shortcut: Clear selection (Escape)
        -: 7558:        // - Only claim shortcut if selection is not empty, allowing further presses on Escape to e.g. leave current child window.
        -: 7559:        // - Box select also handle Escape and needs to pass an id to bypass ActiveIdUsingAllKeyboardKeys lock.
    #####: 7560:        if (flags & ImGuiMultiSelectFlags_ClearOnEscape)
    %%%%%: 7560-block 52
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 7561:        {
    #####: 7562:            if (selection_size != 0 || bs->IsActive)
    %%%%%: 7562-block 53
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7562-block 54
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 7563:                if (Shortcut(ImGuiKey_Escape, ImGuiInputFlags_None, bs->IsActive ? bs->ID : 0))
    %%%%%: 7563-block 55
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7563-block 56
    %%%%%: 7563-block 57
    %%%%%: 7563-block 58
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
        -: 7564:                {
    #####: 7565:                    request_clear = true;
    #####: 7566:                    if (bs->IsActive)
    %%%%%: 7566-block 60
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7567:                        BoxSelectDeactivateDrag(bs);
    %%%%%: 7567-block 61
call    0 never executed
        -: 7568:                }
        -: 7569:        }
        -: 7570:
        -: 7571:        // Shortcut: Select all (CTRL+A)
    #####: 7572:        if (!(flags & ImGuiMultiSelectFlags_SingleSelect) && !(flags & ImGuiMultiSelectFlags_NoSelectAll))
    %%%%%: 7572-block 62
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7572-block 63
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 7573:            if (Shortcut(ImGuiMod_Ctrl | ImGuiKey_A))
    %%%%%: 7573-block 64
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 7574:                request_select_all = true;
    %%%%%: 7574-block 66
        -: 7575:    }
        -: 7576:
    #####: 7577:    if (request_clear || request_select_all)
    %%%%%: 7577-block 67
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7577-block 68
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 7578:    {
    #####: 7579:        MultiSelectAddSetAll(ms, request_select_all);
    %%%%%: 7579-block 69
call    0 never executed
    #####: 7580:        if (!request_select_all)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7581:            storage->LastSelectionSize = 0;
    %%%%%: 7581-block 71
        -: 7582:    }
    #####: 7583:    ms->LoopRequestSetAll = request_select_all ? 1 : request_clear ? 0 : -1;
    %%%%%: 7583-block 72
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7583-block 73
    %%%%%: 7583-block 74
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7583-block 75
    %%%%%: 7583-block 76
    %%%%%: 7583-block 77
    #####: 7584:    ms->LastSubmittedItem = ImGuiSelectionUserData_Invalid;
        -: 7585:
    #####: 7586:    if (g.DebugLogFlags & ImGuiDebugLogFlags_EventSelection)
    %%%%%: 7586-block 78
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7587:        DebugLogMultiSelectRequests("BeginMultiSelect", &ms->IO);
    %%%%%: 7587-block 79
call    0 never executed
        -: 7588:
    #####: 7589:    return &ms->IO;
    %%%%%: 7589-block 80
    %%%%%: 7589-block 81
        -: 7590:}
        -: 7591:
        -: 7592:// Return updated ImGuiMultiSelectIO structure.
        -: 7593:// Lifetime: don't hold on ImGuiMultiSelectIO* pointers over multiple frames or past any subsequent call to BeginMultiSelect() or EndMultiSelect().
function _ZN5ImGui14EndMultiSelectEv called 0 returned 0% blocks executed 0%
    #####: 7594:ImGuiMultiSelectIO* ImGui::EndMultiSelect()
        -: 7595:{
    #####: 7596:    ImGuiContext& g = *GImGui;
    #####: 7597:    ImGuiMultiSelectTempData* ms = g.CurrentMultiSelect;
    #####: 7598:    ImGuiMultiSelectState* storage = ms->Storage;
    #####: 7599:    ImGuiWindow* window = g.CurrentWindow;
    #####: 7600:    IM_ASSERT_USER_ERROR(ms->FocusScopeId == g.CurrentFocusScopeId, "EndMultiSelect() FocusScope mismatch!");
    %%%%%: 7600-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7600-block 3
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 7600-block 4
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 7600-block 5
    %%%%%: 7600-block 6
    %%%%%: 7600-block 7
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 7600-block 8
branch  9 never executed (fallthrough)
branch 10 never executed
    %%%%%: 7600-block 9
call   11 never executed
    #####: 7601:    IM_ASSERT(g.CurrentMultiSelect != NULL && storage->Window == g.CurrentWindow);
    %%%%%: 7601-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7601-block 11
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7601-block 12
    %%%%%: 7601-block 13
call    4 never executed
    #####: 7602:    IM_ASSERT(g.MultiSelectTempDataStacked > 0 && &g.MultiSelectTempData[g.MultiSelectTempDataStacked - 1] == g.CurrentMultiSelect);
    %%%%%: 7602-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7602-block 15
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 7602-block 17
    %%%%%: 7602-block 18
call    5 never executed
        -: 7603:
    #####: 7604:    ImRect scope_rect = CalcScopeRect(ms, window);
    %%%%%: 7604-block 19
call    0 never executed
    #####: 7605:    if (ms->IsFocused)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 7606:    {
        -: 7607:        // We currently don't allow user code to modify RangeSrcItem by writing to BeginIO's version, but that would be an easy change here.
    #####: 7608:        if (ms->IO.RangeSrcReset || (ms->RangeSrcPassedBy == false && ms->IO.RangeSrcItem != ImGuiSelectionUserData_Invalid)) // Can't read storage->RangeSrcItem here -> we want the state at begining of the scope (see tests for easy failure)
    %%%%%: 7608-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7608-block 22
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7608-block 23
branch  4 never executed (fallthrough)
branch  5 never executed
        -: 7609:        {
    #####: 7610:            IMGUI_DEBUG_LOG_SELECTION("[selection] EndMultiSelect: Reset RangeSrcItem.\n"); // Will set be to NavId.
    %%%%%: 7610-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7610-block 25
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####: 7611:            storage->RangeSrcItem = ImGuiSelectionUserData_Invalid;
    %%%%%: 7611-block 26
        -: 7612:        }
    #####: 7613:        if (ms->NavIdPassedBy == false && storage->NavIdItem != ImGuiSelectionUserData_Invalid)
    %%%%%: 7613-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7613-block 28
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 7614:        {
    #####: 7615:            IMGUI_DEBUG_LOG_SELECTION("[selection] EndMultiSelect: Reset NavIdItem.\n");
    %%%%%: 7615-block 29
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7615-block 30
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####: 7616:            storage->NavIdItem = ImGuiSelectionUserData_Invalid;
    #####: 7617:            storage->NavIdSelected = -1;
    %%%%%: 7617-block 31
        -: 7618:        }
        -: 7619:
    #####: 7620:        if ((ms->Flags & (ImGuiMultiSelectFlags_BoxSelect1d | ImGuiMultiSelectFlags_BoxSelect2d)) && GetBoxSelectState(ms->BoxSelectId))
    %%%%%: 7620-block 32
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7620-block 33
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 7620-block 35
    %%%%%: 7620-block 36
    %%%%%: 7620-block 37
branch  5 never executed (fallthrough)
branch  6 never executed
    #####: 7621:            EndBoxSelect(scope_rect, ms->Flags);
    %%%%%: 7621-block 38
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 7622:    }
        -: 7623:
    #####: 7624:    if (ms->IsEndIO == false)
    %%%%%: 7624-block 39
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7625:        ms->IO.Requests.resize(0);
    %%%%%: 7625-block 40
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 7626:
        -: 7627:    // Clear selection when clicking void?
        -: 7628:    // We specifically test for IsMouseDragPastThreshold(0) == false to allow box-selection!
        -: 7629:    // The InnerRect test is necessary for non-child/decorated windows.
    #####: 7630:    bool scope_hovered = IsWindowHovered() && window->InnerRect.Contains(g.IO.MousePos);
    %%%%%: 7630-block 41
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 7630-block 42
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 7630-block 43
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 7630-block 45
    %%%%%: 7630-block 46
    #####: 7631:    if (scope_hovered && (ms->Flags & ImGuiMultiSelectFlags_ScopeRect))
    %%%%%: 7631-block 47
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7631-block 48
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 7632:        scope_hovered &= scope_rect.Contains(g.IO.MousePos);
    %%%%%: 7632-block 49
call    0 never executed
    #####: 7633:    if (scope_hovered && g.HoveredId == 0 && g.ActiveId == 0)
    %%%%%: 7633-block 51
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7633-block 52
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7633-block 53
branch  4 never executed (fallthrough)
branch  5 never executed
        -: 7634:    {
    #####: 7635:        if (ms->Flags & (ImGuiMultiSelectFlags_BoxSelect1d | ImGuiMultiSelectFlags_BoxSelect2d))
    %%%%%: 7635-block 54
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 7636:        {
    #####: 7637:            if (!g.BoxSelectState.IsActive && !g.BoxSelectState.IsStarting && g.IO.MouseClickedCount[0] == 1)
    %%%%%: 7637-block 55
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7637-block 56
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7637-block 57
branch  4 never executed (fallthrough)
branch  5 never executed
        -: 7638:            {
    #####: 7639:                BoxSelectPreStartDrag(ms->BoxSelectId, ImGuiSelectionUserData_Invalid);
    %%%%%: 7639-block 58
call    0 never executed
    #####: 7640:                FocusWindow(window, ImGuiFocusRequestFlags_UnlessBelowModal);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7641:                SetHoveredID(ms->BoxSelectId);
    %%%%%: 7641-block 60
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7642:                if (ms->Flags & ImGuiMultiSelectFlags_ScopeRect)
    %%%%%: 7642-block 61
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7643:                    SetNavID(0, ImGuiNavLayer_Main, ms->FocusScopeId, ImRect(g.IO.MousePos, g.IO.MousePos)); // Automatically switch FocusScope for initial click from void to box-select.
    %%%%%: 7643-block 62
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 7643-block 64
    $$$$$: 7643-block 89
        -: 7644:            }
        -: 7645:        }
        -: 7646:
    #####: 7647:        if (ms->Flags & ImGuiMultiSelectFlags_ClearOnClickVoid)
    %%%%%: 7647-block 65
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7648:            if (IsMouseReleased(0) && IsMouseDragPastThreshold(0) == false && g.IO.KeyMods == ImGuiMod_None)
    %%%%%: 7648-block 66
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 7648-block 67
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 7648-block 68
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
    %%%%%: 7648-block 69
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%: 7648-block 70
branch 10 never executed (fallthrough)
branch 11 never executed
    %%%%%: 7648-block 71
    %%%%%: 7648-block 72
    %%%%%: 7648-block 73
branch 12 never executed (fallthrough)
branch 13 never executed
    #####: 7649:                MultiSelectAddSetAll(ms, false);
    %%%%%: 7649-block 74
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 7650:    }
        -: 7651:
        -: 7652:    // Courtesy nav wrapping helper flag
    #####: 7653:    if (ms->Flags & ImGuiMultiSelectFlags_NavWrapX)
    %%%%%: 7653-block 75
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 7654:    {
    #####: 7655:        IM_ASSERT(ms->Flags & ImGuiMultiSelectFlags_ScopeWindow); // Only supported at window scope
    %%%%%: 7655-block 76
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7655-block 77
call    2 never executed
    #####: 7656:        ImGui::NavMoveRequestTryWrapping(ImGui::GetCurrentWindow(), ImGuiNavMoveFlags_WrapX);
    %%%%%: 7656-block 78
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
        -: 7657:    }
        -: 7658:
        -: 7659:    // Unwind
    #####: 7660:    window->DC.CursorMaxPos = ImMax(ms->BackupCursorMaxPos, window->DC.CursorMaxPos);
    %%%%%: 7660-block 80
call    0 never executed
    #####: 7661:    PopFocusScope();
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 7662:
    #####: 7663:    if (g.DebugLogFlags & ImGuiDebugLogFlags_EventSelection)
    %%%%%: 7663-block 82
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7664:        DebugLogMultiSelectRequests("EndMultiSelect", &ms->IO);
    %%%%%: 7664-block 83
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 7665:
    #####: 7666:    ms->FocusScopeId = 0;
    #####: 7667:    ms->Flags = ImGuiMultiSelectFlags_None;
    #####: 7668:    g.CurrentMultiSelect = (--g.MultiSelectTempDataStacked > 0) ? &g.MultiSelectTempData[g.MultiSelectTempDataStacked - 1] : NULL;
    %%%%%: 7668-block 84
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7668-block 85
call    2 never executed
    %%%%%: 7668-block 86
        -: 7669:
    #####: 7670:    return &ms->IO;
    %%%%%: 7670-block 87
    %%%%%: 7670-block 88
        -: 7671:}
        -: 7672:
function _ZN5ImGui28SetNextItemSelectionUserDataEx called 0 returned 0% blocks executed 0%
    #####: 7673:void ImGui::SetNextItemSelectionUserData(ImGuiSelectionUserData selection_user_data)
        -: 7674:{
        -: 7675:    // Note that flags will be cleared by ItemAdd(), so it's only useful for Navigation code!
        -: 7676:    // This designed so widgets can also cheaply set this before calling ItemAdd(), so we are not tied to MultiSelect api.
    #####: 7677:    ImGuiContext& g = *GImGui;
    #####: 7678:    g.NextItemData.SelectionUserData = selection_user_data;
    #####: 7679:    g.NextItemData.FocusScopeId = g.CurrentFocusScopeId;
        -: 7680:
    #####: 7681:    if (ImGuiMultiSelectTempData* ms = g.CurrentMultiSelect)
    %%%%%: 7681-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 7682:    {
        -: 7683:        // Auto updating RangeSrcPassedBy for cases were clipper is not used (done before ItemAdd() clipping)
    #####: 7684:        g.NextItemData.ItemFlags |= ImGuiItemFlags_HasSelectionUserData | ImGuiItemFlags_IsMultiSelect;
    #####: 7685:        if (ms->IO.RangeSrcItem == selection_user_data)
    %%%%%: 7685-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7686:            ms->RangeSrcPassedBy = true;
    %%%%%: 7686-block 4
        -: 7687:    }
        -: 7688:    else
        -: 7689:    {
    #####: 7690:        g.NextItemData.ItemFlags |= ImGuiItemFlags_HasSelectionUserData;
    %%%%%: 7690-block 5
        -: 7691:    }
    #####: 7692:}
        -: 7693:
        -: 7694:// In charge of:
        -: 7695:// - Applying SetAll for submitted items.
        -: 7696:// - Applying SetRange for submitted items and record end points.
        -: 7697:// - Altering button behavior flags to facilitate use with drag and drop.
function _ZN5ImGui21MultiSelectItemHeaderEjPbPi called 0 returned 0% blocks executed 0%
    #####: 7698:void ImGui::MultiSelectItemHeader(ImGuiID id, bool* p_selected, ImGuiButtonFlags* p_button_flags)
        -: 7699:{
    #####: 7700:    ImGuiContext& g = *GImGui;
    #####: 7701:    ImGuiMultiSelectTempData* ms = g.CurrentMultiSelect;
        -: 7702:
    #####: 7703:    bool selected = *p_selected;
    #####: 7704:    if (ms->IsFocused)
    %%%%%: 7704-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 7705:    {
    #####: 7706:        ImGuiMultiSelectState* storage = ms->Storage;
    #####: 7707:        ImGuiSelectionUserData item_data = g.NextItemData.SelectionUserData;
    #####: 7708:        IM_ASSERT(g.NextItemData.FocusScopeId == g.CurrentFocusScopeId && "Forgot to call SetNextItemSelectionUserData() prior to item, required in BeginMultiSelect()/EndMultiSelect() scope");
    %%%%%: 7708-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7708-block 4
call    2 never executed
        -: 7709:
        -: 7710:        // Apply SetAll (Clear/SelectAll) requests requested by BeginMultiSelect().
        -: 7711:        // This is only useful if the user hasn't processed them already, and this only works if the user isn't using the clipper.
        -: 7712:        // If you are using a clipper you need to process the SetAll request after calling BeginMultiSelect()
    #####: 7713:        if (ms->LoopRequestSetAll != -1)
    %%%%%: 7713-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7714:            selected = (ms->LoopRequestSetAll == 1);
    %%%%%: 7714-block 6
        -: 7715:
        -: 7716:        // When using SHIFT+Nav: because it can incur scrolling we cannot afford a frame of lag with the selection highlight (otherwise scrolling would happen before selection)
        -: 7717:        // For this to work, we need someone to set 'RangeSrcPassedBy = true' at some point (either clipper either SetNextItemSelectionUserData() function)
    #####: 7718:        if (ms->IsKeyboardSetRange)
    %%%%%: 7718-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 7719:        {
    #####: 7720:            IM_ASSERT(id != 0 && (ms->KeyMods & ImGuiMod_Shift) != 0);
    %%%%%: 7720-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7720-block 9
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7720-block 10
    %%%%%: 7720-block 11
call    4 never executed
    #####: 7721:            const bool is_range_dst = (ms->RangeDstPassedBy == false) && g.NavJustMovedToId == id;     // Assume that g.NavJustMovedToId is not clipped.
    %%%%%: 7721-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7721-block 13
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7721-block 14
    %%%%%: 7721-block 15
    #####: 7722:            if (is_range_dst)
    %%%%%: 7722-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7723:                ms->RangeDstPassedBy = true;
    %%%%%: 7723-block 17
    #####: 7724:            if (is_range_dst && storage->RangeSrcItem == ImGuiSelectionUserData_Invalid) // If we don't have RangeSrc, assign RangeSrc = RangeDst
    %%%%%: 7724-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7724-block 19
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 7725:            {
    #####: 7726:                storage->RangeSrcItem = item_data;
    #####: 7727:                storage->RangeSelected = selected ? 1 : 0;
    %%%%%: 7727-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7727-block 21
    %%%%%: 7727-block 22
    %%%%%: 7727-block 23
        -: 7728:            }
    #####: 7729:            const bool is_range_src = storage->RangeSrcItem == item_data;
    #####: 7730:            if (is_range_src || is_range_dst || ms->RangeSrcPassedBy != ms->RangeDstPassedBy)
    %%%%%: 7730-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7730-block 25
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7730-block 26
branch  4 never executed (fallthrough)
branch  5 never executed
        -: 7731:            {
        -: 7732:                // Apply range-select value to visible items
    #####: 7733:                IM_ASSERT(storage->RangeSrcItem != ImGuiSelectionUserData_Invalid && storage->RangeSelected != -1);
    %%%%%: 7733-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7733-block 28
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7733-block 29
    %%%%%: 7733-block 30
call    4 never executed
    #####: 7734:                selected = (storage->RangeSelected != 0);
    %%%%%: 7734-block 31
        -: 7735:            }
    #####: 7736:            else if ((ms->KeyMods & ImGuiMod_Ctrl) == 0 && (ms->Flags & ImGuiMultiSelectFlags_NoAutoClear) == 0)
    %%%%%: 7736-block 32
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7736-block 33
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 7737:            {
        -: 7738:                // Clear other items
    #####: 7739:                selected = false;
    %%%%%: 7739-block 34
        -: 7740:            }
        -: 7741:        }
    #####: 7742:        *p_selected = selected;
    %%%%%: 7742-block 36
        -: 7743:    }
        -: 7744:
        -: 7745:    // Alter button behavior flags
        -: 7746:    // To handle drag and drop of multiple items we need to avoid clearing selection on click.
        -: 7747:    // Enabling this test makes actions using CTRL+SHIFT delay their effect on MouseUp which is annoying, but it allows drag and drop of multiple items.
    #####: 7748:    if (p_button_flags != NULL)
    %%%%%: 7748-block 37
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 7749:    {
    #####: 7750:        ImGuiButtonFlags button_flags = *p_button_flags;
    #####: 7751:        button_flags |= ImGuiButtonFlags_NoHoveredOnFocus;
    #####: 7752:        if ((!selected || (g.ActiveId == id && g.ActiveIdHasBeenPressedBefore)) && !(ms->Flags & ImGuiMultiSelectFlags_SelectOnClickRelease))
    %%%%%: 7752-block 38
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7752-block 39
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7752-block 40
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 7752-block 41
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 7753:            button_flags = (button_flags | ImGuiButtonFlags_PressedOnClick) & ~ImGuiButtonFlags_PressedOnClickRelease;
    %%%%%: 7753-block 42
        -: 7754:        else
    #####: 7755:            button_flags |= ImGuiButtonFlags_PressedOnClickRelease;
    %%%%%: 7755-block 43
    #####: 7756:        *p_button_flags = button_flags;
    %%%%%: 7756-block 44
        -: 7757:    }
    #####: 7758:}
        -: 7759:
        -: 7760:// In charge of:
        -: 7761:// - Auto-select on navigation.
        -: 7762:// - Box-select toggle handling.
        -: 7763:// - Right-click handling.
        -: 7764:// - Altering selection based on Ctrl/Shift modifiers, both for keyboard and mouse.
        -: 7765:// - Record current selection state for RangeSrc
        -: 7766:// This is all rather complex, best to run and refer to "widgets_multiselect_xxx" tests in imgui_test_suite.
function _ZN5ImGui21MultiSelectItemFooterEjPbS0_ called 0 returned 0% blocks executed 0%
    #####: 7767:void ImGui::MultiSelectItemFooter(ImGuiID id, bool* p_selected, bool* p_pressed)
        -: 7768:{
    #####: 7769:    ImGuiContext& g = *GImGui;
    #####: 7770:    ImGuiWindow* window = g.CurrentWindow;
        -: 7771:
    #####: 7772:    bool selected = *p_selected;
    #####: 7773:    bool pressed = *p_pressed;
    #####: 7774:    ImGuiMultiSelectTempData* ms = g.CurrentMultiSelect;
    #####: 7775:    ImGuiMultiSelectState* storage = ms->Storage;
    #####: 7776:    if (pressed)
    %%%%%: 7776-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7777:        ms->IsFocused = true;
    %%%%%: 7777-block 3
        -: 7778:
    #####: 7779:    bool hovered = false;
    #####: 7780:    if (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_HoveredRect)
    %%%%%: 7780-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7781:        hovered = IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup);
    %%%%%: 7781-block 5
call    0 never executed
    #####: 7782:    if (!ms->IsFocused && !hovered)
    %%%%%: 7782-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7782-block 8
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 7783:        return;
    %%%%%: 7783-block 9
        -: 7784:
    #####: 7785:    ImGuiSelectionUserData item_data = g.NextItemData.SelectionUserData;
        -: 7786:
    #####: 7787:    ImGuiMultiSelectFlags flags = ms->Flags;
    #####: 7788:    const bool is_singleselect = (flags & ImGuiMultiSelectFlags_SingleSelect) != 0;
    #####: 7789:    bool is_ctrl = (ms->KeyMods & ImGuiMod_Ctrl) != 0;
    #####: 7790:    bool is_shift = (ms->KeyMods & ImGuiMod_Shift) != 0;
        -: 7791:
    #####: 7792:    bool apply_to_range_src = false;
        -: 7793:
    #####: 7794:    if (g.NavId == id && storage->RangeSrcItem == ImGuiSelectionUserData_Invalid)
    %%%%%: 7794-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7794-block 11
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 7795:        apply_to_range_src = true;
    %%%%%: 7795-block 12
    #####: 7796:    if (ms->IsEndIO == false)
    %%%%%: 7796-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 7797:    {
    #####: 7798:        ms->IO.Requests.resize(0);
    %%%%%: 7798-block 14
call    0 never executed
    #####: 7799:        ms->IsEndIO = true;
        -: 7800:    }
        -: 7801:
        -: 7802:    // Auto-select as you navigate a list
    #####: 7803:    if (g.NavJustMovedToId == id)
    %%%%%: 7803-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 7804:    {
    #####: 7805:        if ((flags & ImGuiMultiSelectFlags_NoAutoSelect) == 0)
    %%%%%: 7805-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 7806:        {
    #####: 7807:            if (is_ctrl && is_shift)
    %%%%%: 7807-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7807-block 19
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 7808:                pressed = true;
    %%%%%: 7808-block 20
    #####: 7809:            else if (!is_ctrl)
    %%%%%: 7809-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7810:                selected = pressed = true;
    %%%%%: 7810-block 22
        -: 7811:        }
        -: 7812:        else
        -: 7813:        {
        -: 7814:            // With NoAutoSelect, using Shift+keyboard performs a write/copy
    #####: 7815:            if (is_shift)
    %%%%%: 7815-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7816:                pressed = true;
    %%%%%: 7816-block 25
    #####: 7817:            else if (!is_ctrl)
    %%%%%: 7817-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7818:                apply_to_range_src = true; // Since if (pressed) {} main block is not running we update this
    %%%%%: 7818-block 27
        -: 7819:        }
        -: 7820:    }
        -: 7821:
    #####: 7822:    if (apply_to_range_src)
    %%%%%: 7822-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 7823:    {
    #####: 7824:        storage->RangeSrcItem = item_data;
    #####: 7825:        storage->RangeSelected = selected; // Will be updated at the end of this function anyway.
    %%%%%: 7825-block 29
        -: 7826:    }
        -: 7827:
        -: 7828:    // Box-select toggle handling
    #####: 7829:    if (ms->BoxSelectId != 0)
    %%%%%: 7829-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7830:        if (ImGuiBoxSelectState* bs = GetBoxSelectState(ms->BoxSelectId))
    %%%%%: 7830-block 31
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -: 7831:        {
    #####: 7832:            const bool rect_overlap_curr = bs->BoxSelectRectCurr.Overlaps(g.LastItemData.Rect);
    %%%%%: 7832-block 33
call    0 never executed
    #####: 7833:            const bool rect_overlap_prev = bs->BoxSelectRectPrev.Overlaps(g.LastItemData.Rect);
call    0 never executed
    #####: 7834:            if ((rect_overlap_curr && !rect_overlap_prev && !selected) || (rect_overlap_prev && !rect_overlap_curr))
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7834-block 36
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7834-block 37
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 7834-block 38
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 7834-block 39
branch  8 never executed (fallthrough)
branch  9 never executed
        -: 7835:            {
    #####: 7836:                if (storage->LastSelectionSize <= 0 && bs->IsStartedSetNavIdOnce)
    %%%%%: 7836-block 40
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7836-block 41
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 7837:                {
    #####: 7838:                    pressed = true; // First item act as a pressed: code below will emit selection request and set NavId (whatever we emit here will be overridden anyway)
    #####: 7839:                    bs->IsStartedSetNavIdOnce = false;
    %%%%%: 7839-block 42
        -: 7840:                }
        -: 7841:                else
        -: 7842:                {
    #####: 7843:                    selected = !selected;
    #####: 7844:                    MultiSelectAddSetRange(ms, selected, +1, item_data, item_data);
    %%%%%: 7844-block 43
call    0 never executed
        -: 7845:                }
    #####: 7846:                storage->LastSelectionSize = ImMax(storage->LastSelectionSize + 1, 1);
    %%%%%: 7846-block 44
call    0 never executed
        -: 7847:            }
        -: 7848:        }
        -: 7849:
        -: 7850:    // Right-click handling.
        -: 7851:    // FIXME-MULTISELECT: Currently filtered out by ImGuiMultiSelectFlags_NoAutoSelect but maybe should be moved to Selectable(). See https://github.com/ocornut/imgui/pull/5816
    #####: 7852:    if (hovered && IsMouseClicked(1) && (flags & ImGuiMultiSelectFlags_NoAutoSelect) == 0)
    %%%%%: 7852-block 46
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7852-block 47
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 7852-block 49
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 7852-block 50
    %%%%%: 7852-block 51
    %%%%%: 7852-block 52
branch  7 never executed (fallthrough)
branch  8 never executed
        -: 7853:    {
    #####: 7854:        if (g.ActiveId != 0 && g.ActiveId != id)
    %%%%%: 7854-block 53
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7854-block 54
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 7855:            ClearActiveID();
    %%%%%: 7855-block 55
call    0 never executed
    #####: 7856:        SetFocusID(id, window);
    %%%%%: 7856-block 56
call    0 never executed
    #####: 7857:        if (!pressed && !selected)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7857-block 58
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 7858:        {
    #####: 7859:            pressed = true;
    #####: 7860:            is_ctrl = is_shift = false;
    %%%%%: 7860-block 59
        -: 7861:        }
        -: 7862:    }
        -: 7863:
        -: 7864:    // Unlike Space, Enter doesn't alter selection (but can still return a press) unless current item is not selected.
        -: 7865:    // The later, "unless current item is not select", may become optional? It seems like a better default if Enter doesn't necessarily open something
        -: 7866:    // (unlike e.g. Windows explorer). For use case where Enter always open something, we might decide to make this optional?
    #####: 7867:    const bool enter_pressed = pressed && (g.NavActivateId == id) && (g.NavActivateFlags & ImGuiActivateFlags_PreferInput);
    %%%%%: 7867-block 60
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7867-block 61
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7867-block 62
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 7867-block 63
    %%%%%: 7867-block 64
        -: 7868:
        -: 7869:    // Alter selection
    #####: 7870:    if (pressed && (!enter_pressed || !selected))
    %%%%%: 7870-block 65
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7870-block 66
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7870-block 67
branch  4 never executed (fallthrough)
branch  5 never executed
        -: 7871:    {
        -: 7872:        // Box-select
    #####: 7873:        ImGuiInputSource input_source = (g.NavJustMovedToId == id || g.NavActivateId == id) ? g.NavInputSource : ImGuiInputSource_Mouse;
    %%%%%: 7873-block 68
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7873-block 69
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7873-block 70
    %%%%%: 7873-block 71
    #####: 7874:        if (flags & (ImGuiMultiSelectFlags_BoxSelect1d | ImGuiMultiSelectFlags_BoxSelect2d))
    %%%%%: 7874-block 72
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7875:            if (selected == false && !g.BoxSelectState.IsActive && !g.BoxSelectState.IsStarting && input_source == ImGuiInputSource_Mouse && g.IO.MouseClickedCount[0] == 1)
    %%%%%: 7875-block 73
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7875-block 74
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7875-block 75
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 7875-block 76
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 7875-block 77
branch  8 never executed (fallthrough)
branch  9 never executed
    #####: 7876:                BoxSelectPreStartDrag(ms->BoxSelectId, item_data);
    %%%%%: 7876-block 78
call    0 never executed
        -: 7877:
        -: 7878:        //----------------------------------------------------------------------------------------
        -: 7879:        // ACTION                      | Begin  | Pressed/Activated  | End
        -: 7880:        //----------------------------------------------------------------------------------------
        -: 7881:        // Keys Navigated:             | Clear  | Src=item, Sel=1               SetRange 1
        -: 7882:        // Keys Navigated: Ctrl        | n/a    | n/a
        -: 7883:        // Keys Navigated:      Shift  | n/a    | Dst=item, Sel=1,   => Clear + SetRange 1
        -: 7884:        // Keys Navigated: Ctrl+Shift  | n/a    | Dst=item, Sel=Src  => Clear + SetRange Src-Dst
        -: 7885:        // Keys Activated:             | n/a    | Src=item, Sel=1    => Clear + SetRange 1
        -: 7886:        // Keys Activated: Ctrl        | n/a    | Src=item, Sel=!Sel =>         SetSange 1
        -: 7887:        // Keys Activated:      Shift  | n/a    | Dst=item, Sel=1    => Clear + SetSange 1
        -: 7888:        //----------------------------------------------------------------------------------------
        -: 7889:        // Mouse Pressed:              | n/a    | Src=item, Sel=1,   => Clear + SetRange 1
        -: 7890:        // Mouse Pressed:  Ctrl        | n/a    | Src=item, Sel=!Sel =>         SetRange 1
        -: 7891:        // Mouse Pressed:       Shift  | n/a    | Dst=item, Sel=1,   => Clear + SetRange 1
        -: 7892:        // Mouse Pressed:  Ctrl+Shift  | n/a    | Dst=item, Sel=!Sel =>         SetRange Src-Dst
        -: 7893:        //----------------------------------------------------------------------------------------
        -: 7894:
    #####: 7895:        if ((flags & ImGuiMultiSelectFlags_NoAutoClear) == 0)
    %%%%%: 7895-block 79
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 7896:        {
    #####: 7897:            bool request_clear = false;
    #####: 7898:            if (is_singleselect)
    %%%%%: 7898-block 80
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7899:                request_clear = true;
    %%%%%: 7899-block 81
    #####: 7900:            else if ((input_source == ImGuiInputSource_Mouse || g.NavActivateId == id) && !is_ctrl)
    %%%%%: 7900-block 82
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7900-block 83
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7900-block 84
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 7901:                request_clear = (flags & ImGuiMultiSelectFlags_NoAutoClearOnReselect) ? !selected : true;
    %%%%%: 7901-block 85
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7901-block 86
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7901-block 87
    %%%%%: 7901-block 88
    %%%%%: 7901-block 89
    #####: 7902:            else if ((input_source == ImGuiInputSource_Keyboard || input_source == ImGuiInputSource_Gamepad) && is_shift && !is_ctrl)
    %%%%%: 7902-block 90
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7902-block 91
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7902-block 92
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 7902-block 93
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 7903:                request_clear = true; // With is_shift==false the RequestClear was done in BeginIO, not necessary to do again.
    %%%%%: 7903-block 94
    #####: 7904:            if (request_clear)
    %%%%%: 7904-block 95
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7905:                MultiSelectAddSetAll(ms, false);
    %%%%%: 7905-block 96
call    0 never executed
        -: 7906:        }
        -: 7907:
        -: 7908:        int range_direction;
        -: 7909:        bool range_selected;
    #####: 7910:        if (is_shift && !is_singleselect)
    %%%%%: 7910-block 97
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7910-block 98
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 7911:        {
        -: 7912:            //IM_ASSERT(storage->HasRangeSrc && storage->HasRangeValue);
    #####: 7913:            if (storage->RangeSrcItem == ImGuiSelectionUserData_Invalid)
    %%%%%: 7913-block 99
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7914:                storage->RangeSrcItem = item_data;
    %%%%%: 7914-block 100
    #####: 7915:            if ((flags & ImGuiMultiSelectFlags_NoAutoSelect) == 0)
    %%%%%: 7915-block 101
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 7916:            {
        -: 7917:                // Shift+Arrow always select
        -: 7918:                // Ctrl+Shift+Arrow copy source selection state (already stored by BeginMultiSelect() in storage->RangeSelected)
    #####: 7919:                range_selected = (is_ctrl && storage->RangeSelected != -1) ? (storage->RangeSelected != 0) : true;
    %%%%%: 7919-block 102
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7919-block 103
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7919-block 104
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 7919-block 105
    %%%%%: 7919-block 106
    %%%%%: 7919-block 107
        -: 7920:            }
        -: 7921:            else
        -: 7922:            {
        -: 7923:                // Shift+Arrow copy source selection state
        -: 7924:                // Shift+Click always copy from target selection state
    #####: 7925:                if (ms->IsKeyboardSetRange)
    %%%%%: 7925-block 108
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7926:                    range_selected = (storage->RangeSelected != -1) ? (storage->RangeSelected != 0) : true;
    %%%%%: 7926-block 109
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7926-block 110
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7926-block 111
    %%%%%: 7926-block 112
    %%%%%: 7926-block 113
        -: 7927:                else
    #####: 7928:                    range_selected = !selected;
    %%%%%: 7928-block 114
        -: 7929:            }
    #####: 7930:            range_direction = ms->RangeSrcPassedBy ? +1 : -1;
    %%%%%: 7930-block 115
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7930-block 116
    %%%%%: 7930-block 117
    %%%%%: 7930-block 118
        -: 7931:        }
        -: 7932:        else
        -: 7933:        {
        -: 7934:            // Ctrl inverts selection, otherwise always select
    #####: 7935:            if ((flags & ImGuiMultiSelectFlags_NoAutoSelect) == 0)
    %%%%%: 7935-block 119
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7936:                selected = is_ctrl ? !selected : true;
    %%%%%: 7936-block 120
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7936-block 121
    %%%%%: 7936-block 122
    %%%%%: 7936-block 123
        -: 7937:            else
    #####: 7938:                selected = !selected;
    %%%%%: 7938-block 124
    #####: 7939:            storage->RangeSrcItem = item_data;
    #####: 7940:            range_selected = selected;
    #####: 7941:            range_direction = +1;
    %%%%%: 7941-block 125
        -: 7942:        }
    #####: 7943:        MultiSelectAddSetRange(ms, range_selected, range_direction, storage->RangeSrcItem, item_data);
    %%%%%: 7943-block 126
call    0 never executed
        -: 7944:    }
        -: 7945:
        -: 7946:    // Update/store the selection state of the Source item (used by CTRL+SHIFT, when Source is unselected we perform a range unselect)
    #####: 7947:    if (storage->RangeSrcItem == item_data)
    %%%%%: 7947-block 127
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7948:        storage->RangeSelected = selected ? 1 : 0;
    %%%%%: 7948-block 128
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7948-block 129
    %%%%%: 7948-block 130
    %%%%%: 7948-block 131
        -: 7949:
        -: 7950:    // Update/store the selection state of focused item
    #####: 7951:    if (g.NavId == id)
    %%%%%: 7951-block 132
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 7952:    {
    #####: 7953:        storage->NavIdItem = item_data;
    #####: 7954:        storage->NavIdSelected = selected ? 1 : 0;
    %%%%%: 7954-block 133
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7954-block 134
    %%%%%: 7954-block 135
    %%%%%: 7954-block 136
        -: 7955:    }
    #####: 7956:    if (storage->NavIdItem == item_data)
    %%%%%: 7956-block 137
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7957:        ms->NavIdPassedBy = true;
    %%%%%: 7957-block 138
    #####: 7958:    ms->LastSubmittedItem = item_data;
        -: 7959:
    #####: 7960:    *p_selected = selected;
    #####: 7961:    *p_pressed = pressed;
    %%%%%: 7961-block 139
        -: 7962:}
        -: 7963:
function _ZN5ImGui20MultiSelectAddSetAllEP24ImGuiMultiSelectTempDatab called 0 returned 0% blocks executed 0%
    #####: 7964:void ImGui::MultiSelectAddSetAll(ImGuiMultiSelectTempData* ms, bool selected)
        -: 7965:{
    #####: 7966:    ImGuiSelectionRequest req = { ImGuiSelectionRequestType_SetAll, selected, 0, ImGuiSelectionUserData_Invalid, ImGuiSelectionUserData_Invalid };
    #####: 7967:    ms->IO.Requests.resize(0);      // Can always clear previous requests
    %%%%%: 7967-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7968:    ms->IO.Requests.push_back(req); // Add new request
    %%%%%: 7968-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 7969:}
    %%%%%: 7969-block 4
        -: 7970:
function _ZN5ImGui22MultiSelectAddSetRangeEP24ImGuiMultiSelectTempDatabixx called 0 returned 0% blocks executed 0%
    #####: 7971:void ImGui::MultiSelectAddSetRange(ImGuiMultiSelectTempData* ms, bool selected, int range_dir, ImGuiSelectionUserData first_item, ImGuiSelectionUserData last_item)
        -: 7972:{
        -: 7973:    // Merge contiguous spans into same request (unless NoRangeSelect is set which guarantees single-item ranges)
    #####: 7974:    if (ms->IO.Requests.Size > 0 && first_item == last_item && (ms->Flags & ImGuiMultiSelectFlags_NoRangeSelect) == 0)
    %%%%%: 7974-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7974-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7974-block 4
branch  4 never executed (fallthrough)
branch  5 never executed
        -: 7975:    {
    #####: 7976:        ImGuiSelectionRequest* prev = &ms->IO.Requests.Data[ms->IO.Requests.Size - 1];
    #####: 7977:        if (prev->Type == ImGuiSelectionRequestType_SetRange && prev->RangeLastItem == ms->LastSubmittedItem && prev->Selected == selected)
    %%%%%: 7977-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7977-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7977-block 7
branch  4 never executed (fallthrough)
branch  5 never executed
        -: 7978:        {
    #####: 7979:            prev->RangeLastItem = last_item;
    #####: 7980:            return;
    %%%%%: 7980-block 8
        -: 7981:        }
        -: 7982:    }
        -: 7983:
    #####: 7984:    ImGuiSelectionRequest req = { ImGuiSelectionRequestType_SetRange, selected, (ImS8)range_dir, (range_dir > 0) ? first_item : last_item, (range_dir > 0) ? last_item : first_item };
    %%%%%: 7984-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7984-block 10
    %%%%%: 7984-block 11
    %%%%%: 7984-block 12
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7984-block 13
    %%%%%: 7984-block 14
    #####: 7985:    ms->IO.Requests.push_back(req); // Add new request
    %%%%%: 7985-block 15
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 7986:}
        -: 7987:
function _ZN5ImGui25DebugNodeMultiSelectStateEP21ImGuiMultiSelectState called 0 returned 0% blocks executed 0%
    #####: 7988:void ImGui::DebugNodeMultiSelectState(ImGuiMultiSelectState* storage)
        -: 7989:{
        -: 7990:#ifndef IMGUI_DISABLE_DEBUG_TOOLS
    #####: 7991:    const bool is_active = (storage->LastFrameActive >= GetFrameCount() - 2); // Note that fully clipped early out scrolling tables will appear as inactive here.
    %%%%%: 7991-block 2
call    0 never executed
    #####: 7992:    if (!is_active) { PushStyleColor(ImGuiCol_Text, GetStyleColorVec4(ImGuiCol_TextDisabled)); }
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7992-block 4
call    2 never executed
call    3 never executed
    #####: 7993:    bool open = TreeNode((void*)(intptr_t)storage->ID, "MultiSelect 0x%08X in '%s'%s", storage->ID, storage->Window ? storage->Window->Name : "N/A", is_active ? "" : " *Inactive*");
    %%%%%: 7993-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7993-block 7
    %%%%%: 7993-block 8
    %%%%%: 7993-block 9
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 7993-block 10
    %%%%%: 7993-block 11
    %%%%%: 7993-block 12
call    4 never executed
    #####: 7994:    if (!is_active) { PopStyleColor(); }
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 7994-block 14
call    2 never executed
    #####: 7995:    if (!open)
    %%%%%: 7995-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 7996:        return;
    %%%%%: 7996-block 16
    #####: 7997:    Text("RangeSrcItem = %" IM_PRId64 " (0x%" IM_PRIX64 "), RangeSelected = %d", storage->RangeSrcItem, storage->RangeSrcItem, storage->RangeSelected);
    %%%%%: 7997-block 17
call    0 never executed
    #####: 7998:    Text("NavIdItem = %" IM_PRId64 " (0x%" IM_PRIX64 "), NavIdSelected = %d", storage->NavIdItem, storage->NavIdItem, storage->NavIdSelected);
call    0 never executed
    #####: 7999:    Text("LastSelectionSize = %d", storage->LastSelectionSize); // Provided by user
call    0 never executed
    #####: 8000:    TreePop();
call    0 never executed
        -: 8001:#else
        -: 8002:    IM_UNUSED(storage);
        -: 8003:#endif
        -: 8004:}
        -: 8005:
        -: 8006://-------------------------------------------------------------------------
        -: 8007:// [SECTION] Widgets: Multi-Select helpers
        -: 8008://-------------------------------------------------------------------------
        -: 8009:// - ImGuiSelectionBasicStorage
        -: 8010:// - ImGuiSelectionExternalStorage
        -: 8011://-------------------------------------------------------------------------
        -: 8012:
function _ZN26ImGuiSelectionBasicStorageC2Ev called 0 returned 0% blocks executed 0%
    #####: 8013:ImGuiSelectionBasicStorage::ImGuiSelectionBasicStorage()
    %%%%%: 8013-block 2
call    0 never executed
        -: 8014:{
    #####: 8015:    Size = 0;
    #####: 8016:    PreserveOrder = false;
    #####: 8017:    UserData = NULL;
function _ZZN26ImGuiSelectionBasicStorageC4EvENKUlPS_iE_clES0_i called 0 returned 0% blocks executed 0%
    #####: 8018:    AdapterIndexToStorageId = [](ImGuiSelectionBasicStorage*, int idx) { return (ImGuiID)idx; };
call    0 never executed
    %%%%%: 8018-block 2
    #####: 8019:    _SelectionOrder = 1; // Always >0
    #####: 8020:}
        -: 8021:
function _ZN26ImGuiSelectionBasicStorage5ClearEv called 0 returned 0% blocks executed 0%
    #####: 8022:void ImGuiSelectionBasicStorage::Clear()
        -: 8023:{
    #####: 8024:    Size = 0;
    #####: 8025:    _SelectionOrder = 1; // Always >0
    #####: 8026:    _Storage.Data.resize(0);
    %%%%%: 8026-block 2
call    0 never executed
    #####: 8027:}
        -: 8028:
function _ZN26ImGuiSelectionBasicStorage4SwapERS_ called 0 returned 0% blocks executed 0%
    #####: 8029:void ImGuiSelectionBasicStorage::Swap(ImGuiSelectionBasicStorage& r)
        -: 8030:{
    #####: 8031:    ImSwap(Size, r.Size);
    %%%%%: 8031-block 2
call    0 never executed
    #####: 8032:    ImSwap(_SelectionOrder, r._SelectionOrder);
call    0 never executed
    #####: 8033:    _Storage.Data.swap(r._Storage.Data);
call    0 never executed
    #####: 8034:}
        -: 8035:
function _ZNK26ImGuiSelectionBasicStorage8ContainsEj called 0 returned 0% blocks executed 0%
    #####: 8036:bool ImGuiSelectionBasicStorage::Contains(ImGuiID id) const
        -: 8037:{
    #####: 8038:    return _Storage.GetInt(id, 0) != 0;
    %%%%%: 8038-block 2
call    0 never executed
        -: 8039:}
        -: 8040:
function _ZL22PairComparerByValueIntPKvS0_ called 0 returned 0% blocks executed 0%
    #####: 8041:static int IMGUI_CDECL PairComparerByValueInt(const void* lhs, const void* rhs)
        -: 8042:{
    #####: 8043:    int lhs_v = ((const ImGuiStoragePair*)lhs)->val_i;
    #####: 8044:    int rhs_v = ((const ImGuiStoragePair*)rhs)->val_i;
    #####: 8045:    return (lhs_v > rhs_v ? +1 : lhs_v < rhs_v ? -1 : 0);
    %%%%%: 8045-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8045-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 8045-block 4
    %%%%%: 8045-block 5
    %%%%%: 8045-block 6
    %%%%%: 8045-block 7
    %%%%%: 8045-block 8
        -: 8046:}
        -: 8047:
        -: 8048:// GetNextSelectedItem() is an abstraction allowing us to change our underlying actual storage system without impacting user.
        -: 8049:// (e.g. store unselected vs compact down, compact down on demand, use raw ImVector<ImGuiID> instead of ImGuiStorage...)
function _ZN26ImGuiSelectionBasicStorage19GetNextSelectedItemEPPvPj called 0 returned 0% blocks executed 0%
    #####: 8050:bool ImGuiSelectionBasicStorage::GetNextSelectedItem(void** opaque_it, ImGuiID* out_id)
        -: 8051:{
    #####: 8052:    ImGuiStoragePair* it = (ImGuiStoragePair*)*opaque_it;
    #####: 8053:    ImGuiStoragePair* it_end = _Storage.Data.Data + _Storage.Data.Size;
    #####: 8054:    if (PreserveOrder && it == NULL && it_end != NULL)
    %%%%%: 8054-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8054-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 8054-block 4
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 8055:        ImQsort(_Storage.Data.Data, (size_t)_Storage.Data.Size, sizeof(ImGuiStoragePair), PairComparerByValueInt); // ~ImGuiStorage::BuildSortByValueInt()
    %%%%%: 8055-block 5
call    0 never executed
    #####: 8056:    if (it == NULL)
    %%%%%: 8056-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 8057:        it = _Storage.Data.Data;
    %%%%%: 8057-block 7
    #####: 8058:    IM_ASSERT(it >= _Storage.Data.Data && it <= it_end);
    %%%%%: 8058-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8058-block 9
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 8058-block 10
    %%%%%: 8058-block 11
call    4 never executed
    #####: 8059:    if (it != it_end)
    %%%%%: 8059-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 8060:        while (it->val_i == 0 && it < it_end)
    %%%%%: 8060-block 13
    %%%%%: 8060-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8060-block 16
branch  2 never executed
branch  3 never executed (fallthrough)
    #####: 8061:            it++;
    %%%%%: 8061-block 14
    #####: 8062:    const bool has_more = (it != it_end);
    #####: 8063:    *opaque_it = has_more ? (void**)(it + 1) : (void**)(it);
    %%%%%: 8063-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8063-block 18
    %%%%%: 8063-block 19
    #####: 8064:    *out_id = has_more ? it->key : 0;
    %%%%%: 8064-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8064-block 21
    %%%%%: 8064-block 22
    #####: 8065:    if (PreserveOrder && !has_more)
    %%%%%: 8065-block 23
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8065-block 24
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 8066:        _Storage.BuildSortByKey();
    %%%%%: 8066-block 25
call    0 never executed
    #####: 8067:    return has_more;
    %%%%%: 8067-block 26
        -: 8068:}
        -: 8069:
function _ZN26ImGuiSelectionBasicStorage15SetItemSelectedEjb called 0 returned 0% blocks executed 0%
    #####: 8070:void ImGuiSelectionBasicStorage::SetItemSelected(ImGuiID id, bool selected)
        -: 8071:{
    #####: 8072:    int* p_int = _Storage.GetIntRef(id, 0);
    %%%%%: 8072-block 2
call    0 never executed
    #####: 8073:    if (selected && *p_int == 0) { *p_int = _SelectionOrder++; Size++; }
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8073-block 4
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 8073-block 5
    #####: 8074:    else if (!selected && *p_int != 0) { *p_int = 0; Size--; }
    %%%%%: 8074-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8074-block 7
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 8074-block 8
    #####: 8075:}
        -: 8076:
        -: 8077:// Optimized for batch edits (with same value of 'selected')
function _ZL47ImGuiSelectionBasicStorage_BatchSetItemSelectedP26ImGuiSelectionBasicStoragejbii called 0 returned 0% blocks executed 0%
    #####: 8078:static void ImGuiSelectionBasicStorage_BatchSetItemSelected(ImGuiSelectionBasicStorage* selection, ImGuiID id, bool selected, int size_before_amends, int selection_order)
        -: 8079:{
    #####: 8080:    ImGuiStorage* storage = &selection->_Storage;
    #####: 8081:    ImGuiStoragePair* it = ImLowerBound(storage->Data.Data, storage->Data.Data + size_before_amends, id);
    %%%%%: 8081-block 2
call    0 never executed
    #####: 8082:    const bool is_contained = (it != storage->Data.Data + size_before_amends) && (it->key == id);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8082-block 4
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 8082-block 5
    %%%%%: 8082-block 6
    #####: 8083:    if (selected == (is_contained && it->val_i != 0))
    %%%%%: 8083-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8083-block 8
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 8083-block 9
    %%%%%: 8083-block 10
    %%%%%: 8083-block 11
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 8084:        return;
    %%%%%: 8084-block 12
    #####: 8085:    if (selected && !is_contained)
    %%%%%: 8085-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8085-block 14
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 8086:        storage->Data.push_back(ImGuiStoragePair(id, selection_order)); // Push unsorted at end of vector, will be sorted in SelectionMultiAmendsFinish()
    %%%%%: 8086-block 15
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 8086-block 17
    #####: 8087:    else if (is_contained)
    %%%%%: 8087-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 8088:        it->val_i = selected ? selection_order : 0; // Modify in-place.
    %%%%%: 8088-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8088-block 20
    %%%%%: 8088-block 21
    %%%%%: 8088-block 22
    #####: 8089:    selection->Size += selected ? +1 : -1;
    %%%%%: 8089-block 23
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8089-block 24
    %%%%%: 8089-block 25
    %%%%%: 8089-block 26
        -: 8090:}
        -: 8091:
function _ZL38ImGuiSelectionBasicStorage_BatchFinishP26ImGuiSelectionBasicStoragebi called 0 returned 0% blocks executed 0%
    #####: 8092:static void ImGuiSelectionBasicStorage_BatchFinish(ImGuiSelectionBasicStorage* selection, bool selected, int size_before_amends)
        -: 8093:{
    #####: 8094:    ImGuiStorage* storage = &selection->_Storage;
    #####: 8095:    if (selected && selection->Size != size_before_amends)
    %%%%%: 8095-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8095-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 8096:        storage->BuildSortByKey(); // When done selecting: sort everything
    %%%%%: 8096-block 4
call    0 never executed
    #####: 8097:}
        -: 8098:
        -: 8099:// Apply requests coming from BeginMultiSelect() and EndMultiSelect().
        -: 8100:// - Enable 'Demo->Tools->Debug Log->Selection' to see selection requests as they happen.
        -: 8101:// - Honoring SetRange requests requires that you can iterate/interpolate between RangeFirstItem and RangeLastItem.
        -: 8102://   - In this demo we often submit indices to SetNextItemSelectionUserData() + store the same indices in persistent selection.
        -: 8103://   - Your code may do differently. If you store pointers or objects ID in ImGuiSelectionUserData you may need to perform
        -: 8104://     a lookup in order to have some way to iterate/interpolate between two items.
        -: 8105:// - A full-featured application is likely to allow search/filtering which is likely to lead to using indices
        -: 8106://   and constructing a view index <> object id/ptr data structure anyway.
        -: 8107:// WHEN YOUR APPLICATION SETTLES ON A CHOICE, YOU WILL PROBABLY PREFER TO GET RID OF THIS UNNECESSARY 'ImGuiSelectionBasicStorage' INDIRECTION LOGIC.
        -: 8108:// Notice that with the simplest adapter (using indices everywhere), all functions return their parameters.
        -: 8109:// The most simple implementation (using indices everywhere) would look like:
        -: 8110://   for (ImGuiSelectionRequest& req : ms_io->Requests)
        -: 8111://   {
        -: 8112://      if (req.Type == ImGuiSelectionRequestType_SetAll)    { Clear(); if (req.Selected) { for (int n = 0; n < items_count; n++) { SetItemSelected(n, true); } }
        -: 8113://      if (req.Type == ImGuiSelectionRequestType_SetRange)  { for (int n = (int)ms_io->RangeFirstItem; n <= (int)ms_io->RangeLastItem; n++) { SetItemSelected(n, ms_io->Selected); } }
        -: 8114://   }
function _ZN26ImGuiSelectionBasicStorage13ApplyRequestsEP18ImGuiMultiSelectIO called 0 returned 0% blocks executed 0%
    #####: 8115:void ImGuiSelectionBasicStorage::ApplyRequests(ImGuiMultiSelectIO* ms_io)
        -: 8116:{
        -: 8117:    // For convenience we obtain ItemsCount as passed to BeginMultiSelect(), which is optional.
        -: 8118:    // It makes sense when using ImGuiSelectionBasicStorage to simply pass your items count to BeginMultiSelect().
        -: 8119:    // Other scheme may handle SetAll differently.
    #####: 8120:    IM_ASSERT(ms_io->ItemsCount != -1 && "Missing value for items_count in BeginMultiSelect() call!");
    %%%%%: 8120-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8120-block 3
call    2 never executed
    #####: 8121:    IM_ASSERT(AdapterIndexToStorageId != NULL);
    %%%%%: 8121-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8121-block 5
call    2 never executed
        -: 8122:
        -: 8123:    // This is optimized/specialized to cope with very large selections (e.g. 100k+ items)
        -: 8124:    // - A simpler version could call SetItemSelected() directly instead of ImGuiSelectionBasicStorage_BatchSetItemSelected() + ImGuiSelectionBasicStorage_BatchFinish().
        -: 8125:    // - Optimized select can append unsorted, then sort in a second pass. Optimized unselect can clear in-place then compact in a second pass.
        -: 8126:    // - A more optimal version wouldn't even use ImGuiStorage but directly a ImVector<ImGuiID> to reduce bandwidth, but this is a reasonable trade off to reuse code.
        -: 8127:    // - There are many ways this could be better optimized. The worse case scenario being: using BoxSelect2d in a grid, box-select scrolling down while wiggling
        -: 8128:    //   left and right: it affects coarse clipping + can emit multiple SetRange with 1 item each.)
        -: 8129:    // FIXME-OPT: For each block of consecutive SetRange request:
        -: 8130:    // - add all requests to a sorted list, store ID, selected, offset in ImGuiStorage.
        -: 8131:    // - rewrite sorted storage a single time.
    #####: 8132:    for (ImGuiSelectionRequest& req : ms_io->Requests)
    %%%%%: 8132-block 6
call    0 never executed
call    1 never executed
    %%%%%: 8132-block 39
    %%%%%: 8132-block 40
branch  2 never executed
branch  3 never executed (fallthrough)
        -: 8133:    {
    #####: 8134:        if (req.Type == ImGuiSelectionRequestType_SetAll)
    %%%%%: 8134-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 8135:        {
    #####: 8136:            Clear();
    %%%%%: 8136-block 9
call    0 never executed
    #####: 8137:            if (req.Selected)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 8138:            {
    #####: 8139:                _Storage.Data.reserve(ms_io->ItemsCount);
    %%%%%: 8139-block 11
call    0 never executed
    #####: 8140:                const int size_before_amends = _Storage.Data.Size;
    #####: 8141:                for (int idx = 0; idx < ms_io->ItemsCount; idx++, _SelectionOrder++)
    %%%%%: 8141-block 16
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 8142:                    ImGuiSelectionBasicStorage_BatchSetItemSelected(this, GetStorageIdFromIndex(idx), req.Selected, size_before_amends, _SelectionOrder);
    %%%%%: 8142-block 13
call    0 never executed
call    1 never executed
    #####: 8143:                ImGuiSelectionBasicStorage_BatchFinish(this, req.Selected, size_before_amends);
    %%%%%: 8143-block 17
call    0 never executed
        -: 8144:            }
        -: 8145:        }
    #####: 8146:        else if (req.Type == ImGuiSelectionRequestType_SetRange)
    %%%%%: 8146-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 8147:        {
    #####: 8148:            const int selection_changes = (int)req.RangeLastItem - (int)req.RangeFirstItem + 1;
        -: 8149:            //ImGuiContext& g = *GImGui; IMGUI_DEBUG_LOG_SELECTION("Req %d/%d: set %d to %d\n", ms_io->Requests.index_from_ptr(&req), ms_io->Requests.Size, selection_changes, req.Selected);
    #####: 8150:            if (selection_changes == 1 || (selection_changes < Size / 100))
    %%%%%: 8150-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8150-block 20
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 8151:            {
        -: 8152:                // Multiple sorted insertion + copy likely to be faster.
        -: 8153:                // Technically we could do a single copy with a little more work (sort sequential SetRange requests)
    #####: 8154:                for (int idx = (int)req.RangeFirstItem; idx <= (int)req.RangeLastItem; idx++)
    %%%%%: 8154-block 21
    %%%%%: 8154-block 25
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 8155:                    SetItemSelected(GetStorageIdFromIndex(idx), req.Selected);
    %%%%%: 8155-block 22
call    0 never executed
call    1 never executed
    #####: 8156:            }
    %%%%%: 8156-block 26
        -: 8157:            else
        -: 8158:            {
        -: 8159:                // Append insertion + single sort likely be faster.
        -: 8160:                // Use req.RangeDirection to set order field so that shift+clicking from 1 to 5 is different than shift+clicking from 5 to 1
    #####: 8161:                const int size_before_amends = _Storage.Data.Size;
    #####: 8162:                int selection_order = _SelectionOrder + ((req.RangeDirection < 0) ? selection_changes - 1 : 0);
    %%%%%: 8162-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8162-block 28
    %%%%%: 8162-block 29
    #####: 8163:                for (int idx = (int)req.RangeFirstItem; idx <= (int)req.RangeLastItem; idx++, selection_order += req.RangeDirection)
    %%%%%: 8163-block 30
    %%%%%: 8163-block 34
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 8164:                    ImGuiSelectionBasicStorage_BatchSetItemSelected(this, GetStorageIdFromIndex(idx), req.Selected, size_before_amends, selection_order);
    %%%%%: 8164-block 31
call    0 never executed
call    1 never executed
    #####: 8165:                if (req.Selected)
    %%%%%: 8165-block 35
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 8166:                    _SelectionOrder += selection_changes;
    %%%%%: 8166-block 36
    #####: 8167:                ImGuiSelectionBasicStorage_BatchFinish(this, req.Selected, size_before_amends);
    %%%%%: 8167-block 37
call    0 never executed
        -: 8168:            }
        -: 8169:        }
        -: 8170:    }
    #####: 8171:}
        -: 8172:
        -: 8173://-------------------------------------------------------------------------
        -: 8174:
function _ZN29ImGuiSelectionExternalStorageC2Ev called 0 returned 0% blocks executed 0%
    #####: 8175:ImGuiSelectionExternalStorage::ImGuiSelectionExternalStorage()
        -: 8176:{
    #####: 8177:    UserData = NULL;
    #####: 8178:    AdapterSetItemSelected = NULL;
    #####: 8179:}
        -: 8180:
        -: 8181:// Apply requests coming from BeginMultiSelect() and EndMultiSelect().
        -: 8182:// We also pull 'ms_io->ItemsCount' as passed for BeginMultiSelect() for consistency with ImGuiSelectionBasicStorage
        -: 8183:// This makes no assumption about underlying storage.
function _ZN29ImGuiSelectionExternalStorage13ApplyRequestsEP18ImGuiMultiSelectIO called 0 returned 0% blocks executed 0%
    #####: 8184:void ImGuiSelectionExternalStorage::ApplyRequests(ImGuiMultiSelectIO* ms_io)
        -: 8185:{
    #####: 8186:    IM_ASSERT(AdapterSetItemSelected);
    %%%%%: 8186-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8186-block 3
call    2 never executed
    #####: 8187:    for (ImGuiSelectionRequest& req : ms_io->Requests)
    %%%%%: 8187-block 4
call    0 never executed
call    1 never executed
    %%%%%: 8187-block 16
    %%%%%: 8187-block 17
branch  2 never executed
branch  3 never executed (fallthrough)
        -: 8188:    {
    #####: 8189:        if (req.Type == ImGuiSelectionRequestType_SetAll)
    %%%%%: 8189-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 8190:            for (int idx = 0; idx < ms_io->ItemsCount; idx++)
    %%%%%: 8190-block 7
    %%%%%: 8190-block 10
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 8191:                AdapterSetItemSelected(this, idx, req.Selected);
    %%%%%: 8191-block 8
call    0 never executed
    #####: 8192:        if (req.Type == ImGuiSelectionRequestType_SetRange)
    %%%%%: 8192-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 8193:            for (int idx = (int)req.RangeFirstItem; idx <= (int)req.RangeLastItem; idx++)
    %%%%%: 8193-block 12
    %%%%%: 8193-block 15
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 8194:                AdapterSetItemSelected(this, idx, req.Selected);
    %%%%%: 8194-block 13
call    0 never executed
        -: 8195:    }
    #####: 8196:}
        -: 8197:
        -: 8198://-------------------------------------------------------------------------
        -: 8199:// [SECTION] Widgets: ListBox
        -: 8200://-------------------------------------------------------------------------
        -: 8201:// - BeginListBox()
        -: 8202:// - EndListBox()
        -: 8203:// - ListBox()
        -: 8204://-------------------------------------------------------------------------
        -: 8205:
        -: 8206:// This is essentially a thin wrapper to using BeginChild/EndChild with the ImGuiChildFlags_FrameStyle flag for stylistic changes + displaying a label.
        -: 8207:// This handle some subtleties with capturing info from the label, but for 99% uses it could essentially be rewritten as:
        -: 8208://    if (ImGui::BeginChild("...", ImVec2(ImGui::CalcItemWidth(), ImGui::GetTextLineHeight() * 7.5f), ImGuiChildFlags_FrameStyle))
        -: 8209://        { .... }
        -: 8210://    ImGui::EndChild();
        -: 8211://    ImGui::SameLine();
        -: 8212://    ImGui::AlignTextToFramePadding();
        -: 8213://    ImGui::Text("Label");
        -: 8214:// Tip: To have a list filling the entire window width, use size.x = -FLT_MIN and pass an non-visible label e.g. "##empty"
        -: 8215:// Tip: If your vertical size is calculated from an item count (e.g. 10 * item_height) consider adding a fractional part to facilitate seeing scrolling boundaries (e.g. 10.25 * item_height).
function _ZN5ImGui12BeginListBoxEPKcRK6ImVec2 called 0 returned 0% blocks executed 0%
    #####: 8216:bool ImGui::BeginListBox(const char* label, const ImVec2& size_arg)
        -: 8217:{
    #####: 8218:    ImGuiContext& g = *GImGui;
    #####: 8219:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%: 8219-block 2
call    0 never executed
    #####: 8220:    if (window->SkipItems)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 8221:        return false;
    %%%%%: 8221-block 4
        -: 8222:
    #####: 8223:    const ImGuiStyle& style = g.Style;
    #####: 8224:    const ImGuiID id = GetID(label);
    %%%%%: 8224-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 8225:    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    %%%%%: 8225-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 8226:
        -: 8227:    // Size default to hold ~7.25 items.
        -: 8228:    // Fractional number of items helps seeing that we can scroll down/up without looking at scrollbar.
    #####: 8229:    ImVec2 size = ImTrunc(CalcItemSize(size_arg, CalcItemWidth(), GetTextLineHeightWithSpacing() * 7.25f + style.FramePadding.y * 2.0f));
    %%%%%: 8229-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 8229-block 8
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    %%%%%: 8229-block 9
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed (throw)
    %%%%%: 8229-block 10
call    9 never executed
    $$$$$: 8229-block 42
    #####: 8230:    ImVec2 frame_size = ImVec2(size.x, ImMax(size.y, label_size.y));
call    0 never executed
call    1 never executed
    #####: 8231:    ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + frame_size);
call    0 never executed
call    1 never executed
    #####: 8232:    ImRect bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8232-block 16
    %%%%%: 8232-block 17
    %%%%%: 8232-block 18
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 8233:    g.NextItemData.ClearFlags();
call    0 never executed
        -: 8234:
    #####: 8235:    if (!IsRectVisible(bb.Min, bb.Max))
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 8235-block 23
branch  3 never executed (fallthrough)
branch  4 never executed
        -: 8236:    {
    #####: 8237:        ItemSize(bb.GetSize(), style.FramePadding.y);
    %%%%%: 8237-block 24
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$: 8237-block 43
    #####: 8238:        ItemAdd(bb, 0, &frame_bb);
    %%%%%: 8238-block 26
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 8239:        g.NextWindowData.ClearFlags(); // We behave like Begin() and need to consume those values
    %%%%%: 8239-block 27
call    0 never executed
    #####: 8240:        return false;
        -: 8241:    }
        -: 8242:
        -: 8243:    // FIXME-OPT: We could omit the BeginGroup() if label_size.x == 0.0f but would need to omit the EndGroup() as well.
    #####: 8244:    BeginGroup();
    %%%%%: 8244-block 29
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 8245:    if (label_size.x > 0.0f)
    %%%%%: 8245-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 8246:    {
    #####: 8247:        ImVec2 label_pos = ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y);
    %%%%%: 8247-block 31
call    0 never executed
    #####: 8248:        RenderText(label_pos, label);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 8249:        window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, label_pos + label_size);
    %%%%%: 8249-block 33
call    0 never executed
call    1 never executed
    #####: 8250:        AlignTextToFramePadding();
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 8251:    }
        -: 8252:
    #####: 8253:    BeginChild(id, frame_bb.GetSize(), ImGuiChildFlags_FrameStyle);
    %%%%%: 8253-block 37
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$: 8253-block 45
    #####: 8254:    return true;
    %%%%%: 8254-block 39
        -: 8255:}
        -: 8256:
function _ZN5ImGui10EndListBoxEv called 0 returned 0% blocks executed 0%
    #####: 8257:void ImGui::EndListBox()
        -: 8258:{
    #####: 8259:    ImGuiContext& g = *GImGui;
    #####: 8260:    ImGuiWindow* window = g.CurrentWindow;
    #####: 8261:    IM_ASSERT((window->Flags & ImGuiWindowFlags_ChildWindow) && "Mismatched BeginListBox/EndListBox calls. Did you test the return value of BeginListBox?");
    %%%%%: 8261-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8261-block 3
call    2 never executed
        -: 8262:    IM_UNUSED(window);
        -: 8263:
    #####: 8264:    EndChild();
    %%%%%: 8264-block 4
call    0 never executed
    #####: 8265:    EndGroup(); // This is only required to be able to do IsItemXXX query on the whole ListBox including label
call    0 never executed
    #####: 8266:}
        -: 8267:
function _ZN5ImGui7ListBoxEPKcPiPKS1_ii called 0 returned 0% blocks executed 0%
    #####: 8268:bool ImGui::ListBox(const char* label, int* current_item, const char* const items[], int items_count, int height_items)
        -: 8269:{
    #####: 8270:    const bool value_changed = ListBox(label, current_item, Items_ArrayGetter, (void*)items, items_count, height_items);
    %%%%%: 8270-block 2
call    0 never executed
    #####: 8271:    return value_changed;
        -: 8272:}
        -: 8273:
        -: 8274:// This is merely a helper around BeginListBox(), EndListBox().
        -: 8275:// Considering using those directly to submit custom data or store selection differently.
function _ZN5ImGui7ListBoxEPKcPiPFS1_PviES3_ii called 0 returned 0% blocks executed 0%
    #####: 8276:bool ImGui::ListBox(const char* label, int* current_item, const char* (*getter)(void* user_data, int idx), void* user_data, int items_count, int height_in_items)
        -: 8277:{
    #####: 8278:    ImGuiContext& g = *GImGui;
        -: 8279:
        -: 8280:    // Calculate size from "height_in_items"
    #####: 8281:    if (height_in_items < 0)
    %%%%%: 8281-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 8282:        height_in_items = ImMin(items_count, 7);
    %%%%%: 8282-block 3
call    0 never executed
    #####: 8283:    float height_in_items_f = height_in_items + 0.25f;
    #####: 8284:    ImVec2 size(0.0f, ImTrunc(GetTextLineHeightWithSpacing() * height_in_items_f + g.Style.FramePadding.y * 2.0f));
    %%%%%: 8284-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 8284-block 5
call    3 never executed
call    4 never executed
        -: 8285:
    #####: 8286:    if (!BeginListBox(label, size))
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 8286-block 8
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 8287:        return false;
    %%%%%: 8287-block 9
        -: 8288:
        -: 8289:    // Assume all items have even height (= 1 line of text). If you need items of different height,
        -: 8290:    // you can create a custom version of ListBox() in your code without using the clipper.
    #####: 8291:    bool value_changed = false;
    #####: 8292:    ImGuiListClipper clipper;
    %%%%%: 8292-block 10
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 8293:    clipper.Begin(items_count, GetTextLineHeightWithSpacing()); // We know exactly our line height here so we pass it as a minor optimization, but generally you don't need to.
    %%%%%: 8293-block 11
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 8293-block 12
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    #####: 8294:    clipper.IncludeItemByIndex(*current_item);
    %%%%%: 8294-block 13
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 8295:    while (clipper.Step())
    %%%%%: 8295-block 14
    %%%%%: 8295-block 29
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 8295-block 30
branch  3 never executed
branch  4 never executed (fallthrough)
    #####: 8296:        for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)
    %%%%%: 8296-block 15
    %%%%%: 8296-block 27
    %%%%%: 8296-block 28
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 8297:        {
    #####: 8298:            const char* item_text = getter(user_data, i);
    %%%%%: 8298-block 16
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 8299:            if (item_text == NULL)
    %%%%%: 8299-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 8300:                item_text = "*Unknown item*";
    %%%%%: 8300-block 18
        -: 8301:
    #####: 8302:            PushID(i);
    %%%%%: 8302-block 19
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 8303:            const bool item_selected = (i == *current_item);
    #####: 8304:            if (Selectable(item_text, item_selected))
    %%%%%: 8304-block 20
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 8304-block 22
branch  4 never executed (fallthrough)
branch  5 never executed
    $$$$$: 8304-block 37
        -: 8305:            {
    #####: 8306:                *current_item = i;
    #####: 8307:                value_changed = true;
    %%%%%: 8307-block 23
        -: 8308:            }
    #####: 8309:            if (item_selected)
    %%%%%: 8309-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 8310:                SetItemDefaultFocus();
    %%%%%: 8310-block 25
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 8311:            PopID();
    %%%%%: 8311-block 26
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 8312:        }
    #####: 8313:    EndListBox();
    %%%%%: 8313-block 31
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 8314:
    #####: 8315:    if (value_changed)
    %%%%%: 8315-block 32
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 8316:        MarkItemEdited(g.LastItemData.ID);
    %%%%%: 8316-block 33
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 8317:
    #####: 8318:    return value_changed;
    #####: 8319:}
    %%%%%: 8319-block 34
call    0 never executed
    $$$$$: 8319-block 38
call    1 never executed
        -: 8320:
        -: 8321://-------------------------------------------------------------------------
        -: 8322:// [SECTION] Widgets: PlotLines, PlotHistogram
        -: 8323://-------------------------------------------------------------------------
        -: 8324:// - PlotEx() [Internal]
        -: 8325:// - PlotLines()
        -: 8326:// - PlotHistogram()
        -: 8327://-------------------------------------------------------------------------
        -: 8328:// Plot/Graph widgets are not very good.
        -: 8329:// Consider writing your own, or using a third-party one, see:
        -: 8330:// - ImPlot https://github.com/epezent/implot
        -: 8331:// - others https://github.com/ocornut/imgui/wiki/Useful-Extensions
        -: 8332://-------------------------------------------------------------------------
        -: 8333:
function _ZN5ImGui6PlotExE13ImGuiPlotTypePKcPFfPviES3_iiS2_ffRK6ImVec2 called 0 returned 0% blocks executed 0%
    #####: 8334:int ImGui::PlotEx(ImGuiPlotType plot_type, const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, const ImVec2& size_arg)
        -: 8335:{
    #####: 8336:    ImGuiContext& g = *GImGui;
    #####: 8337:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%: 8337-block 2
call    0 never executed
    #####: 8338:    if (window->SkipItems)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 8339:        return -1;
    %%%%%: 8339-block 4
        -: 8340:
    #####: 8341:    const ImGuiStyle& style = g.Style;
    #####: 8342:    const ImGuiID id = window->GetID(label);
    %%%%%: 8342-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 8343:
    #####: 8344:    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    %%%%%: 8344-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 8345:    const ImVec2 frame_size = CalcItemSize(size_arg, CalcItemWidth(), label_size.y + style.FramePadding.y * 2.0f);
    %%%%%: 8345-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 8345-block 8
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
        -: 8346:
    #####: 8347:    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + frame_size);
    %%%%%: 8347-block 9
call    0 never executed
call    1 never executed
    #####: 8348:    const ImRect inner_bb(frame_bb.Min + style.FramePadding, frame_bb.Max - style.FramePadding);
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 8349:    const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0));
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8349-block 15
    %%%%%: 8349-block 16
    %%%%%: 8349-block 17
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 8350:    ItemSize(total_bb, style.FramePadding.y);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 8351:    if (!ItemAdd(total_bb, id, &frame_bb, ImGuiItemFlags_NoNav))
    %%%%%: 8351-block 21
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 8351-block 22
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 8352:        return -1;
    %%%%%: 8352-block 23
        -: 8353:    bool hovered;
    #####: 8354:    ButtonBehavior(frame_bb, id, &hovered, NULL);
    %%%%%: 8354-block 24
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 8355:
        -: 8356:    // Determine scale from values if not specified
    #####: 8357:    if (scale_min == FLT_MAX || scale_max == FLT_MAX)
    %%%%%: 8357-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8357-block 26
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 8358:    {
    #####: 8359:        float v_min = FLT_MAX;
    #####: 8360:        float v_max = -FLT_MAX;
    #####: 8361:        for (int i = 0; i < values_count; i++)
    %%%%%: 8361-block 27
    %%%%%: 8361-block 33
    %%%%%: 8361-block 34
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 8362:        {
    #####: 8363:            const float v = values_getter(data, i);
    %%%%%: 8363-block 28
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 8364:            if (v != v) // Ignore NaN values
    %%%%%: 8364-block 29
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 8365:                continue;
    %%%%%: 8365-block 30
    #####: 8366:            v_min = ImMin(v_min, v);
    %%%%%: 8366-block 31
call    0 never executed
    #####: 8367:            v_max = ImMax(v_max, v);
call    0 never executed
        -: 8368:        }
    #####: 8369:        if (scale_min == FLT_MAX)
    %%%%%: 8369-block 35
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 8370:            scale_min = v_min;
    %%%%%: 8370-block 36
    #####: 8371:        if (scale_max == FLT_MAX)
    %%%%%: 8371-block 37
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 8372:            scale_max = v_max;
    %%%%%: 8372-block 38
        -: 8373:    }
        -: 8374:
    #####: 8375:    RenderFrame(frame_bb.Min, frame_bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);
    %%%%%: 8375-block 39
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 8375-block 40
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
        -: 8376:
    #####: 8377:    const int values_count_min = (plot_type == ImGuiPlotType_Lines) ? 2 : 1;
    %%%%%: 8377-block 41
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8377-block 42
    %%%%%: 8377-block 43
    #####: 8378:    int idx_hovered = -1;
    #####: 8379:    if (values_count >= values_count_min)
    %%%%%: 8379-block 44
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 8380:    {
    #####: 8381:        int res_w = ImMin((int)frame_size.x, values_count) + ((plot_type == ImGuiPlotType_Lines) ? -1 : 0);
    %%%%%: 8381-block 45
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 8381-block 47
    %%%%%: 8381-block 48
    #####: 8382:        int item_count = values_count + ((plot_type == ImGuiPlotType_Lines) ? -1 : 0);
    %%%%%: 8382-block 49
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8382-block 50
    %%%%%: 8382-block 51
        -: 8383:
        -: 8384:        // Tooltip on hover
    #####: 8385:        if (hovered && inner_bb.Contains(g.IO.MousePos))
    %%%%%: 8385-block 52
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8385-block 53
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 8385-block 55
    %%%%%: 8385-block 56
    %%%%%: 8385-block 57
branch  5 never executed (fallthrough)
branch  6 never executed
        -: 8386:        {
    #####: 8387:            const float t = ImClamp((g.IO.MousePos.x - inner_bb.Min.x) / (inner_bb.Max.x - inner_bb.Min.x), 0.0f, 0.9999f);
    %%%%%: 8387-block 58
call    0 never executed
    #####: 8388:            const int v_idx = (int)(t * item_count);
    #####: 8389:            IM_ASSERT(v_idx >= 0 && v_idx < values_count);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8389-block 60
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 8389-block 61
    %%%%%: 8389-block 62
call    4 never executed
        -: 8390:
    #####: 8391:            const float v0 = values_getter(data, (v_idx + values_offset) % values_count);
    %%%%%: 8391-block 63
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 8392:            const float v1 = values_getter(data, (v_idx + 1 + values_offset) % values_count);
    %%%%%: 8392-block 64
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 8393:            if (plot_type == ImGuiPlotType_Lines)
    %%%%%: 8393-block 65
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 8394:                SetTooltip("%d: %8.4g\n%d: %8.4g", v_idx, v0, v_idx + 1, v1);
    %%%%%: 8394-block 66
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 8395:            else if (plot_type == ImGuiPlotType_Histogram)
    %%%%%: 8395-block 67
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 8396:                SetTooltip("%d: %8.4g", v_idx, v0);
    %%%%%: 8396-block 68
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 8397:            idx_hovered = v_idx;
    %%%%%: 8397-block 69
        -: 8398:        }
        -: 8399:
    #####: 8400:        const float t_step = 1.0f / (float)res_w;
    #####: 8401:        const float inv_scale = (scale_min == scale_max) ? 0.0f : (1.0f / (scale_max - scale_min));
    %%%%%: 8401-block 70
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8401-block 71
    %%%%%: 8401-block 72
        -: 8402:
    #####: 8403:        float v0 = values_getter(data, (0 + values_offset) % values_count);
    %%%%%: 8403-block 73
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 8404:        float t0 = 0.0f;
    #####: 8405:        ImVec2 tp0 = ImVec2( t0, 1.0f - ImSaturate((v0 - scale_min) * inv_scale) );                       // Point in the normalized space of our target rectangle
    %%%%%: 8405-block 74
call    0 never executed
call    1 never executed
    #####: 8406:        float histogram_zero_line_t = (scale_min * scale_max < 0.0f) ? (1 + scale_min * inv_scale) : (scale_min < 0.0f ? 0.0f : 1.0f);   // Where does the zero line stands
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8406-block 77
    %%%%%: 8406-block 78
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 8406-block 79
    %%%%%: 8406-block 80
    %%%%%: 8406-block 81
        -: 8407:
    #####: 8408:        const ImU32 col_base = GetColorU32((plot_type == ImGuiPlotType_Lines) ? ImGuiCol_PlotLines : ImGuiCol_PlotHistogram);
    %%%%%: 8408-block 82
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8408-block 83
    %%%%%: 8408-block 84
    %%%%%: 8408-block 85
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####: 8409:        const ImU32 col_hovered = GetColorU32((plot_type == ImGuiPlotType_Lines) ? ImGuiCol_PlotLinesHovered : ImGuiCol_PlotHistogramHovered);
    %%%%%: 8409-block 86
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8409-block 87
    %%%%%: 8409-block 88
    %%%%%: 8409-block 89
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
        -: 8410:
    #####: 8411:        for (int n = 0; n < res_w; n++)
    %%%%%: 8411-block 90
    %%%%%: 8411-block 116
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 8412:        {
    #####: 8413:            const float t1 = t0 + t_step;
    #####: 8414:            const int v1_idx = (int)(t0 * item_count + 0.5f);
    #####: 8415:            IM_ASSERT(v1_idx >= 0 && v1_idx < values_count);
    %%%%%: 8415-block 91
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8415-block 92
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 8415-block 93
    %%%%%: 8415-block 94
call    4 never executed
    #####: 8416:            const float v1 = values_getter(data, (v1_idx + values_offset + 1) % values_count);
    %%%%%: 8416-block 95
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 8417:            const ImVec2 tp1 = ImVec2( t1, 1.0f - ImSaturate((v1 - scale_min) * inv_scale) );
    %%%%%: 8417-block 96
call    0 never executed
call    1 never executed
        -: 8418:
        -: 8419:            // NB: Draw calls are merged together by the DrawList system. Still, we should render our batch are lower level to save a bit of CPU.
    #####: 8420:            ImVec2 pos0 = ImLerp(inner_bb.Min, inner_bb.Max, tp0);
call    0 never executed
    #####: 8421:            ImVec2 pos1 = ImLerp(inner_bb.Min, inner_bb.Max, (plot_type == ImGuiPlotType_Lines) ? tp1 : ImVec2(tp1.x, histogram_zero_line_t));
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8421-block 100
    %%%%%: 8421-block 101
call    2 never executed
    %%%%%: 8421-block 102
call    3 never executed
    #####: 8422:            if (plot_type == ImGuiPlotType_Lines)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 8423:            {
    #####: 8424:                window->DrawList->AddLine(pos0, pos1, idx_hovered == v1_idx ? col_hovered : col_base);
    %%%%%: 8424-block 104
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8424-block 105
    %%%%%: 8424-block 106
    %%%%%: 8424-block 107
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
        -: 8425:            }
    #####: 8426:            else if (plot_type == ImGuiPlotType_Histogram)
    %%%%%: 8426-block 108
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 8427:            {
    #####: 8428:                if (pos1.x >= pos0.x + 2.0f)
    %%%%%: 8428-block 109
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 8429:                    pos1.x -= 1.0f;
    %%%%%: 8429-block 110
    #####: 8430:                window->DrawList->AddRectFilled(pos0, pos1, idx_hovered == v1_idx ? col_hovered : col_base);
    %%%%%: 8430-block 111
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8430-block 112
    %%%%%: 8430-block 113
    %%%%%: 8430-block 114
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
        -: 8431:            }
        -: 8432:
    #####: 8433:            t0 = t1;
    #####: 8434:            tp0 = tp1;
    %%%%%: 8434-block 115
        -: 8435:        }
        -: 8436:    }
        -: 8437:
        -: 8438:    // Text overlay
    #####: 8439:    if (overlay_text)
    %%%%%: 8439-block 118
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 8440:        RenderTextClipped(ImVec2(frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y), frame_bb.Max, overlay_text, NULL, NULL, ImVec2(0.5f, 0.0f));
    %%%%%: 8440-block 119
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 8440-block 122
    $$$$$: 8440-block 132
    $$$$$: 8440-block 133
        -: 8441:
    #####: 8442:    if (label_size.x > 0.0f)
    %%%%%: 8442-block 123
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 8443:        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, inner_bb.Min.y), label);
    %%%%%: 8443-block 124
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 8443-block 126
    $$$$$: 8443-block 134
        -: 8444:
        -: 8445:    // Return hovered index or -1 if none are hovered.
        -: 8446:    // This is currently not exposed in the public API because we need a larger redesign of the whole thing, but in the short-term we are making it available in PlotEx().
    #####: 8447:    return idx_hovered;
    %%%%%: 8447-block 127
        -: 8448:}
        -: 8449:
        -: 8450:struct ImGuiPlotArrayGetterData
        -: 8451:{
        -: 8452:    const float* Values;
        -: 8453:    int Stride;
        -: 8454:
function _ZN24ImGuiPlotArrayGetterDataC2EPKfi called 0 returned 0% blocks executed 0%
    #####: 8455:    ImGuiPlotArrayGetterData(const float* values, int stride) { Values = values; Stride = stride; }
        -: 8456:};
        -: 8457:
function _ZL16Plot_ArrayGetterPvi called 0 returned 0% blocks executed 0%
    #####: 8458:static float Plot_ArrayGetter(void* data, int idx)
        -: 8459:{
    #####: 8460:    ImGuiPlotArrayGetterData* plot_data = (ImGuiPlotArrayGetterData*)data;
    #####: 8461:    const float v = *(const float*)(const void*)((const unsigned char*)plot_data->Values + (size_t)idx * plot_data->Stride);
    #####: 8462:    return v;
    %%%%%: 8462-block 2
        -: 8463:}
        -: 8464:
function _ZN5ImGui9PlotLinesEPKcPKfiiS1_ff6ImVec2i called 0 returned 0% blocks executed 0%
    #####: 8465:void ImGui::PlotLines(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)
        -: 8466:{
    #####: 8467:    ImGuiPlotArrayGetterData data(values, stride);
    %%%%%: 8467-block 2
call    0 never executed
    #####: 8468:    PlotEx(ImGuiPlotType_Lines, label, &Plot_ArrayGetter, (void*)&data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 8469:}
    %%%%%: 8469-block 4
        -: 8470:
function _ZN5ImGui9PlotLinesEPKcPFfPviES2_iiS1_ff6ImVec2 called 0 returned 0% blocks executed 0%
    #####: 8471:void ImGui::PlotLines(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)
        -: 8472:{
    #####: 8473:    PlotEx(ImGuiPlotType_Lines, label, values_getter, data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);
    %%%%%: 8473-block 2
call    0 never executed
    #####: 8474:}
        -: 8475:
function _ZN5ImGui13PlotHistogramEPKcPKfiiS1_ff6ImVec2i called 0 returned 0% blocks executed 0%
    #####: 8476:void ImGui::PlotHistogram(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)
        -: 8477:{
    #####: 8478:    ImGuiPlotArrayGetterData data(values, stride);
    %%%%%: 8478-block 2
call    0 never executed
    #####: 8479:    PlotEx(ImGuiPlotType_Histogram, label, &Plot_ArrayGetter, (void*)&data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 8480:}
    %%%%%: 8480-block 4
        -: 8481:
function _ZN5ImGui13PlotHistogramEPKcPFfPviES2_iiS1_ff6ImVec2 called 0 returned 0% blocks executed 0%
    #####: 8482:void ImGui::PlotHistogram(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)
        -: 8483:{
    #####: 8484:    PlotEx(ImGuiPlotType_Histogram, label, values_getter, data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);
    %%%%%: 8484-block 2
call    0 never executed
    #####: 8485:}
        -: 8486:
        -: 8487://-------------------------------------------------------------------------
        -: 8488:// [SECTION] Widgets: Value helpers
        -: 8489:// Those is not very useful, legacy API.
        -: 8490://-------------------------------------------------------------------------
        -: 8491:// - Value()
        -: 8492://-------------------------------------------------------------------------
        -: 8493:
function _ZN5ImGui5ValueEPKcb called 0 returned 0% blocks executed 0%
    #####: 8494:void ImGui::Value(const char* prefix, bool b)
        -: 8495:{
    #####: 8496:    Text("%s: %s", prefix, (b ? "true" : "false"));
    %%%%%: 8496-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8496-block 3
    %%%%%: 8496-block 4
    %%%%%: 8496-block 5
call    2 never executed
    #####: 8497:}
        -: 8498:
function _ZN5ImGui5ValueEPKci called 0 returned 0% blocks executed 0%
    #####: 8499:void ImGui::Value(const char* prefix, int v)
        -: 8500:{
    #####: 8501:    Text("%s: %d", prefix, v);
    %%%%%: 8501-block 2
call    0 never executed
    #####: 8502:}
        -: 8503:
function _ZN5ImGui5ValueEPKcj called 0 returned 0% blocks executed 0%
    #####: 8504:void ImGui::Value(const char* prefix, unsigned int v)
        -: 8505:{
    #####: 8506:    Text("%s: %d", prefix, v);
    %%%%%: 8506-block 2
call    0 never executed
    #####: 8507:}
        -: 8508:
function _ZN5ImGui5ValueEPKcfS1_ called 0 returned 0% blocks executed 0%
    #####: 8509:void ImGui::Value(const char* prefix, float v, const char* float_format)
        -: 8510:{
    #####: 8511:    if (float_format)
    %%%%%: 8511-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 8512:    {
        -: 8513:        char fmt[64];
    #####: 8514:        ImFormatString(fmt, IM_ARRAYSIZE(fmt), "%%s: %s", float_format);
    %%%%%: 8514-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 8515:        Text(fmt, prefix, v);
    %%%%%: 8515-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 8516:    }
        -: 8517:    else
        -: 8518:    {
    #####: 8519:        Text("%s: %.3f", prefix, v);
    %%%%%: 8519-block 6
call    0 never executed
        -: 8520:    }
    #####: 8521:}
    %%%%%: 8521-block 7
        -: 8522:
        -: 8523://-------------------------------------------------------------------------
        -: 8524:// [SECTION] MenuItem, BeginMenu, EndMenu, etc.
        -: 8525://-------------------------------------------------------------------------
        -: 8526:// - ImGuiMenuColumns [Internal]
        -: 8527:// - BeginMenuBar()
        -: 8528:// - EndMenuBar()
        -: 8529:// - BeginMainMenuBar()
        -: 8530:// - EndMainMenuBar()
        -: 8531:// - BeginMenu()
        -: 8532:// - EndMenu()
        -: 8533:// - MenuItemEx() [Internal]
        -: 8534:// - MenuItem()
        -: 8535://-------------------------------------------------------------------------
        -: 8536:
        -: 8537:// Helpers for internal use
function _ZN16ImGuiMenuColumns6UpdateEfb called 16368 returned 100% blocks executed 100%
    16368: 8538:void ImGuiMenuColumns::Update(float spacing, bool window_reappearing)
        -: 8539:{
    16368: 8540:    if (window_reappearing)
    16368: 8540-block 2
branch  0 taken 24 (fallthrough)
branch  1 taken 16344
       24: 8541:        memset(Widths, 0, sizeof(Widths));
       24: 8541-block 3
    16368: 8542:    Spacing = (ImU16)spacing;
    16368: 8543:    CalcNextTotalWidth(true);
    16368: 8543-block 4
call    0 returned 16368
    16368: 8544:    memset(Widths, 0, sizeof(Widths));
    16368: 8545:    TotalWidth = NextTotalWidth;
    16368: 8546:    NextTotalWidth = 0;
    16368: 8547:}
        -: 8548:
function _ZN16ImGuiMenuColumns18CalcNextTotalWidthEb called 16368 returned 100% blocks executed 86%
    16368: 8549:void ImGuiMenuColumns::CalcNextTotalWidth(bool update_offsets)
        -: 8550:{
    16368: 8551:    ImU16 offset = 0;
    16368: 8552:    bool want_spacing = false;
    81840: 8553:    for (int i = 0; i < IM_ARRAYSIZE(Widths); i++)
    16368: 8553-block 2
    81840: 8553-block 14
branch  0 taken 65472
branch  1 taken 16368 (fallthrough)
        -: 8554:    {
    65472: 8555:        ImU16 width = Widths[i];
   65472*: 8556:        if (want_spacing && width > 0)
    65472: 8556-block 3
branch  0 taken 0 (fallthrough)
branch  1 taken 65472
    %%%%%: 8556-block 4
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 8557:            offset += Spacing;
    %%%%%: 8557-block 5
    65472: 8558:        want_spacing |= (width > 0);
    65472: 8559:        if (update_offsets)
    65472: 8559-block 6
branch  0 taken 65472 (fallthrough)
branch  1 taken 0
        -: 8560:        {
    65472: 8561:            if (i == 1) { OffsetLabel = offset; }
    65472: 8561-block 7
branch  0 taken 16368 (fallthrough)
branch  1 taken 49104
    16368: 8561-block 8
    65472: 8562:            if (i == 2) { OffsetShortcut = offset; }
    65472: 8562-block 9
branch  0 taken 16368 (fallthrough)
branch  1 taken 49104
    16368: 8562-block 10
    65472: 8563:            if (i == 3) { OffsetMark = offset; }
    65472: 8563-block 11
branch  0 taken 16368 (fallthrough)
branch  1 taken 49104
    16368: 8563-block 12
        -: 8564:        }
    65472: 8565:        offset += width;
    65472: 8565-block 13
        -: 8566:    }
    16368: 8567:    NextTotalWidth = offset;
    16368: 8568:}
        -: 8569:
function _ZN16ImGuiMenuColumns11DeclColumnsEffff called 0 returned 0% blocks executed 0%
    #####: 8570:float ImGuiMenuColumns::DeclColumns(float w_icon, float w_label, float w_shortcut, float w_mark)
        -: 8571:{
    #####: 8572:    Widths[0] = ImMax(Widths[0], (ImU16)w_icon);
    %%%%%: 8572-block 2
call    0 never executed
    #####: 8573:    Widths[1] = ImMax(Widths[1], (ImU16)w_label);
call    0 never executed
    #####: 8574:    Widths[2] = ImMax(Widths[2], (ImU16)w_shortcut);
call    0 never executed
    #####: 8575:    Widths[3] = ImMax(Widths[3], (ImU16)w_mark);
call    0 never executed
    #####: 8576:    CalcNextTotalWidth(false);
call    0 never executed
    #####: 8577:    return (float)ImMax(TotalWidth, NextTotalWidth);
call    0 never executed
        -: 8578:}
        -: 8579:
        -: 8580:// FIXME: Provided a rectangle perhaps e.g. a BeginMenuBarEx() could be used anywhere..
        -: 8581:// Currently the main responsibility of this function being to setup clip-rect + horizontal layout + menu navigation layer.
        -: 8582:// Ideally we also want this to be responsible for claiming space out of the main window scrolling rectangle, in which case ImGuiWindowFlags_MenuBar will become unnecessary.
        -: 8583:// Then later the same system could be used for multiple menu-bars, scrollbars, side-bars.
function _ZN5ImGui12BeginMenuBarEv called 1077 returned 100% blocks executed 88%
     1077: 8584:bool ImGui::BeginMenuBar()
        -: 8585:{
     1077: 8586:    ImGuiWindow* window = GetCurrentWindow();
     1077: 8586-block 2
call    0 returned 1077
     1077: 8587:    if (window->SkipItems)
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####: 8588:        return false;
    %%%%%: 8588-block 4
     1077: 8589:    if (!(window->Flags & ImGuiWindowFlags_MenuBar))
     1077: 8589-block 5
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####: 8590:        return false;
    %%%%%: 8590-block 6
        -: 8591:
    1077*: 8592:    IM_ASSERT(!window->DC.MenuBarAppending);
     1077: 8592-block 7
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 8592-block 8
call    2 never executed
     1077: 8593:    BeginGroup(); // Backup position on layer 0 // FIXME: Misleading to use a group for that backup/restore
     1077: 8593-block 9
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077: 8594:    PushID("##menubar");
     1077: 8594-block 10
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -: 8595:
        -: 8596:    // We don't clip with current window clipping rectangle as it is already set to the area below. However we clip with window full rect.
        -: 8597:    // We remove 1 worth of rounding to Max.x to that text in long menus and small windows don't tend to display over the lower-right rounded area, which looks particularly glitchy.
     1077: 8598:    ImRect bar_rect = window->MenuBarRect();
     1077: 8598-block 11
call    0 returned 1077
     1077: 8599:    ImRect clip_rect(ImFloor(bar_rect.Min.x + window->WindowBorderSize), ImFloor(bar_rect.Min.y + window->WindowBorderSize), ImFloor(ImMax(bar_rect.Min.x, bar_rect.Max.x - ImMax(window->WindowRounding, window->WindowBorderSize))), ImFloor(bar_rect.Max.y));
call    0 returned 1077
call    1 returned 1077
call    2 returned 1077
call    3 returned 1077
call    4 returned 1077
call    5 returned 1077
call    6 returned 1077
     1077: 8600:    clip_rect.ClipWith(window->OuterRectClipped);
call    0 returned 1077
     1077: 8601:    PushClipRect(clip_rect.Min, clip_rect.Max, false);
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -: 8602:
        -: 8603:    // We overwrite CursorMaxPos because BeginGroup sets it to CursorPos (essentially the .EmitItem hack in EndMenuBar() would need something analogous here, maybe a BeginGroupEx() with flags).
     1077: 8604:    window->DC.CursorPos = window->DC.CursorMaxPos = ImVec2(bar_rect.Min.x + window->DC.MenuBarOffset.x, bar_rect.Min.y + window->DC.MenuBarOffset.y);
     1077: 8604-block 21
call    0 returned 1077
     1077: 8605:    window->DC.LayoutType = ImGuiLayoutType_Horizontal;
     1077: 8606:    window->DC.IsSameLine = false;
     1077: 8607:    window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;
     1077: 8608:    window->DC.MenuBarAppending = true;
     1077: 8609:    AlignTextToFramePadding();
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077: 8610:    return true;
     1077: 8610-block 23
        -: 8611:}
        -: 8612:
function _ZN5ImGui10EndMenuBarEv called 1077 returned 100% blocks executed 43%
     1077: 8613:void ImGui::EndMenuBar()
        -: 8614:{
     1077: 8615:    ImGuiWindow* window = GetCurrentWindow();
     1077: 8615-block 2
call    0 returned 1077
     1077: 8616:    if (window->SkipItems)
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####: 8617:        return;
    %%%%%: 8617-block 4
     1077: 8618:    ImGuiContext& g = *GImGui;
        -: 8619:
        -: 8620:    // Nav: When a move request within one of our child menu failed, capture the request to navigate among our siblings.
    1077*: 8621:    if (NavMoveRequestButNoResultYet() && (g.NavMoveDir == ImGuiDir_Left || g.NavMoveDir == ImGuiDir_Right) && (g.NavWindow->Flags & ImGuiWindowFlags_ChildMenu))
     1077: 8621-block 5
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077: 8621-block 6
branch  3 taken 0 (fallthrough)
branch  4 taken 1077
    %%%%%: 8621-block 7
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 8621-block 8
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 8621-block 9
branch  9 never executed (fallthrough)
branch 10 never executed
    %%%%%: 8621-block 10
     1077: 8621-block 11
     1077: 8621-block 12
branch 11 taken 0 (fallthrough)
branch 12 taken 1077
        -: 8622:    {
        -: 8623:        // Try to find out if the request is for one of our child menu
    #####: 8624:        ImGuiWindow* nav_earliest_child = g.NavWindow;
    #####: 8625:        while (nav_earliest_child->ParentWindow && (nav_earliest_child->ParentWindow->Flags & ImGuiWindowFlags_ChildMenu))
    %%%%%: 8625-block 13
    %%%%%: 8625-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8625-block 16
branch  2 never executed
branch  3 never executed (fallthrough)
    #####: 8626:            nav_earliest_child = nav_earliest_child->ParentWindow;
    %%%%%: 8626-block 14
    #####: 8627:        if (nav_earliest_child->ParentWindow == window && nav_earliest_child->DC.ParentLayoutType == ImGuiLayoutType_Horizontal && (g.NavMoveFlags & ImGuiNavMoveFlags_Forwarded) == 0)
    %%%%%: 8627-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8627-block 18
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 8627-block 19
branch  4 never executed (fallthrough)
branch  5 never executed
        -: 8628:        {
        -: 8629:            // To do so we claim focus back, restore NavId and then process the movement request for yet another frame.
        -: 8630:            // This involve a one-frame delay which isn't very problematic in this situation. We could remove it by scoring in advance for multiple window (probably not worth bothering)
    #####: 8631:            const ImGuiNavLayer layer = ImGuiNavLayer_Menu;
    #####: 8632:            IM_ASSERT(window->DC.NavLayersActiveMaskNext & (1 << layer)); // Sanity check (FIXME: Seems unnecessary)
    %%%%%: 8632-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8632-block 21
call    2 never executed
    #####: 8633:            FocusWindow(window);
    %%%%%: 8633-block 22
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 8634:            SetNavID(window->NavLastIds[layer], layer, 0, window->NavRectRel[layer]);
    %%%%%: 8634-block 23
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 8635:            // FIXME-NAV: How to deal with this when not using g.IO.ConfigNavCursorVisibleAuto?
    #####: 8636:            if (g.NavCursorVisible)
    %%%%%: 8636-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 8637:            {
    #####: 8638:                g.NavCursorVisible = false; // Hide nav cursor for the current frame so we don't see the intermediary selection. Will be set again
    #####: 8639:                g.NavCursorHideFrames = 2;
    %%%%%: 8639-block 25
        -: 8640:            }
    #####: 8641:            g.NavHighlightItemUnderNav = g.NavMousePosDirty = true;
    #####: 8642:            NavMoveRequestForward(g.NavMoveDir, g.NavMoveClipDir, g.NavMoveFlags, g.NavMoveScrollFlags); // Repeat
    %%%%%: 8642-block 26
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 8643:        }
        -: 8644:    }
        -: 8645:
        -: 8646:    IM_MSVC_WARNING_SUPPRESS(6011); // Static Analysis false positive "warning C6011: Dereferencing NULL pointer 'window'"
    1077*: 8647:    IM_ASSERT(window->Flags & ImGuiWindowFlags_MenuBar);
     1077: 8647-block 27
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 8647-block 28
call    2 never executed
    1077*: 8648:    IM_ASSERT(window->DC.MenuBarAppending);
     1077: 8648-block 29
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 8648-block 30
call    2 never executed
     1077: 8649:    PopClipRect();
     1077: 8649-block 31
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077: 8650:    PopID();
     1077: 8650-block 32
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077: 8651:    window->DC.MenuBarOffset.x = window->DC.CursorPos.x - window->Pos.x; // Save horizontal position so next append can reuse it. This is kinda equivalent to a per-layer CursorPos.
        -: 8652:
        -: 8653:    // FIXME: Extremely confusing, cleanup by (a) working on WorkRect stack system (b) not using a Group confusingly here.
     1077: 8654:    ImGuiGroupData& group_data = g.GroupStack.back();
     1077: 8654-block 33
call    0 returned 1077
     1077: 8655:    group_data.EmitItem = false;
     1077: 8656:    ImVec2 restore_cursor_max_pos = group_data.BackupCursorMaxPos;
     1077: 8657:    window->DC.IdealMaxPos.x = ImMax(window->DC.IdealMaxPos.x, window->DC.CursorMaxPos.x - window->Scroll.x); // Convert ideal extents for scrolling layer equivalent.
call    0 returned 1077
     1077: 8658:    EndGroup(); // Restore position on layer 0 // FIXME: Misleading to use a group for that backup/restore
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077: 8659:    window->DC.LayoutType = ImGuiLayoutType_Vertical;
     1077: 8660:    window->DC.IsSameLine = false;
     1077: 8661:    window->DC.NavLayerCurrent = ImGuiNavLayer_Main;
     1077: 8662:    window->DC.MenuBarAppending = false;
     1077: 8663:    window->DC.CursorMaxPos = restore_cursor_max_pos;
     1077: 8663-block 36
        -: 8664:}
        -: 8665:
        -: 8666:// Important: calling order matters!
        -: 8667:// FIXME: Somehow overlapping with docking tech.
        -: 8668:// FIXME: The "rect-cut" aspect of this could be formalized into a lower-level helper (rect-cut: https://halt.software/dead-simple-layouts)
function _ZN5ImGui20BeginViewportSideBarEPKcP13ImGuiViewport8ImGuiDirfi called 1077 returned 100% blocks executed 66%
     1077: 8669:bool ImGui::BeginViewportSideBar(const char* name, ImGuiViewport* viewport_p, ImGuiDir dir, float axis_size, ImGuiWindowFlags window_flags)
        -: 8670:{
    1077*: 8671:    IM_ASSERT(dir != ImGuiDir_None);
     1077: 8671-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 8671-block 3
call    2 never executed
        -: 8672:
     1077: 8673:    ImGuiWindow* bar_window = FindWindowByName(name);
     1077: 8673-block 4
call    0 returned 1077
    1077*: 8674:    ImGuiViewportP* viewport = (ImGuiViewportP*)(void*)(viewport_p ? viewport_p : GetMainViewport());
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 8674-block 6
call    2 never executed
     1077: 8674-block 8
     1077: 8675:    if (bar_window == NULL || bar_window->BeginCount == 0)
     1077: 8675-block 9
branch  0 taken 1076 (fallthrough)
branch  1 taken 1
     1076: 8675-block 10
branch  2 taken 1076 (fallthrough)
branch  3 taken 0
        -: 8676:    {
        -: 8677:        // Calculate and set window size/position
     1077: 8678:        ImRect avail_rect = viewport->GetBuildWorkRect();
     1077: 8678-block 11
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
    1077*: 8679:        ImGuiAxis axis = (dir == ImGuiDir_Up || dir == ImGuiDir_Down) ? ImGuiAxis_Y : ImGuiAxis_X;
     1077: 8679-block 12
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 8679-block 13
branch  2 never executed (fallthrough)
branch  3 never executed
     1077: 8679-block 14
    %%%%%: 8679-block 15
     1077: 8680:        ImVec2 pos = avail_rect.Min;
     1077: 8681:        if (dir == ImGuiDir_Right || dir == ImGuiDir_Down)
     1077: 8681-block 16
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 8681-block 17
branch  2 taken 0 (fallthrough)
branch  3 taken 1077
    #####: 8682:            pos[axis] = avail_rect.Max[axis] - axis_size;
    %%%%%: 8682-block 18
call    0 never executed
call    1 never executed
     1077: 8683:        ImVec2 size = avail_rect.GetSize();
     1077: 8683-block 21
call    0 returned 1077
     1077: 8684:        size[axis] = axis_size;
call    0 returned 1077
     1077: 8685:        SetNextWindowPos(pos);
call    0 returned 1077
call    1 returned 1077
branch  2 taken 1077 (fallthrough)
branch  3 taken 0 (throw)
    $$$$$: 8685-block 43
     1077: 8686:        SetNextWindowSize(size);
     1077: 8686-block 25
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -: 8687:
        -: 8688:        // Report our size into work area (for next frame) using actual window size
    1077*: 8689:        if (dir == ImGuiDir_Up || dir == ImGuiDir_Left)
     1077: 8689-block 26
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 8689-block 27
branch  2 never executed (fallthrough)
branch  3 never executed
     1077: 8690:            viewport->BuildWorkInsetMin[axis] += axis_size;
     1077: 8690-block 28
call    0 returned 1077
    #####: 8691:        else if (dir == ImGuiDir_Down || dir == ImGuiDir_Right)
    %%%%%: 8691-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8691-block 31
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 8692:            viewport->BuildWorkInsetMax[axis] += axis_size;
    %%%%%: 8692-block 32
call    0 never executed
        -: 8693:    }
        -: 8694:
     1077: 8695:    window_flags |= ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoDocking;
     1077: 8696:    SetNextWindowViewport(viewport->ID); // Enforce viewport so we don't create our own viewport when ImGuiConfigFlags_ViewportsNoMerge is set.
     1077: 8696-block 35
call    0 returned 1077
     1077: 8697:    PushStyleVar(ImGuiStyleVar_WindowRounding, 0.0f);
call    0 returned 1077
     1077: 8698:    PushStyleVar(ImGuiStyleVar_WindowMinSize, ImVec2(0, 0)); // Lift normal size constraint
call    0 returned 1077
call    1 returned 1077
branch  2 taken 1077 (fallthrough)
branch  3 taken 0 (throw)
     1077: 8699:    bool is_open = Begin(name, NULL, window_flags);
     1077: 8699-block 39
call    0 returned 1077
     1077: 8700:    PopStyleVar(2);
call    0 returned 1077
        -: 8701:
     1077: 8702:    return is_open;
     1077: 8702-block 42
        -: 8703:}
        -: 8704:
function _ZN5ImGui16BeginMainMenuBarEv called 1077 returned 100% blocks executed 92%
     1077: 8705:bool ImGui::BeginMainMenuBar()
        -: 8706:{
     1077: 8707:    ImGuiContext& g = *GImGui;
     1077: 8708:    ImGuiViewportP* viewport = (ImGuiViewportP*)(void*)GetMainViewport();
     1077: 8708-block 2
call    0 returned 1077
        -: 8709:
        -: 8710:    // Notify of viewport change so GetFrameHeight() can be accurate in case of DPI change
     1077: 8711:    SetCurrentViewport(NULL, viewport);
call    0 returned 1077
        -: 8712:
        -: 8713:    // For the main menu bar, which cannot be moved, we honor g.Style.DisplaySafeAreaPadding to ensure text can be visible on a TV set.
        -: 8714:    // FIXME: This could be generalized as an opt-in way to clamp window->DC.CursorStartPos to avoid SafeArea?
        -: 8715:    // FIXME: Consider removing support for safe area down the line... it's messy. Nowadays consoles have support for TV calibration in OS settings.
     1077: 8716:    g.NextWindowData.MenuBarOffsetMinVal = ImVec2(g.Style.DisplaySafeAreaPadding.x, ImMax(g.Style.DisplaySafeAreaPadding.y - g.Style.FramePadding.y, 0.0f));
call    0 returned 1077
call    1 returned 1077
     1077: 8717:    ImGuiWindowFlags window_flags = ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_MenuBar;
     1077: 8718:    float height = GetFrameHeight();
call    0 returned 1077
     1077: 8719:    bool is_open = BeginViewportSideBar("##MainMenuBar", viewport, ImGuiDir_Up, height, window_flags);
call    0 returned 1077
     1077: 8720:    g.NextWindowData.MenuBarOffsetMinVal = ImVec2(0.0f, 0.0f);
call    0 returned 1077
        -: 8721:
     1077: 8722:    if (is_open)
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 8723:        BeginMenuBar();
     1077: 8723-block 10
call    0 returned 1077
        -: 8724:    else
    #####: 8725:        End();
    %%%%%: 8725-block 11
call    0 never executed
     1077: 8726:    return is_open;
     1077: 8726-block 12
        -: 8727:}
        -: 8728:
function _ZN5ImGui14EndMainMenuBarEv called 1077 returned 100% blocks executed 86%
     1077: 8729:void ImGui::EndMainMenuBar()
        -: 8730:{
     1077: 8731:    EndMenuBar();
     1077: 8731-block 2
call    0 returned 1077
        -: 8732:
        -: 8733:    // When the user has left the menu layer (typically: closed menus through activation of an item), we restore focus to the previous window
        -: 8734:    // FIXME: With this strategy we won't be able to restore a NULL focus.
     1077: 8735:    ImGuiContext& g = *GImGui;
     1077: 8736:    if (g.CurrentWindow == g.NavWindow && g.NavLayer == ImGuiNavLayer_Main && !g.NavAnyRequest)
branch  0 taken 1 (fallthrough)
branch  1 taken 1076
        1: 8736-block 4
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1: 8736-block 5
branch  4 taken 0 (fallthrough)
branch  5 taken 1
    #####: 8737:        FocusTopMostWindowUnderOne(g.NavWindow, NULL, NULL, ImGuiFocusRequestFlags_UnlessBelowModal | ImGuiFocusRequestFlags_RestoreFocusedChild);
    %%%%%: 8737-block 6
call    0 never executed
        -: 8738:
     1077: 8739:    End();
     1077: 8739-block 7
call    0 returned 1077
     1077: 8740:}
        -: 8741:
function _ZL19IsRootOfOpenMenuSetv called 3231 returned 100% blocks executed 21%
     3231: 8742:static bool IsRootOfOpenMenuSet()
        -: 8743:{
     3231: 8744:    ImGuiContext& g = *GImGui;
     3231: 8745:    ImGuiWindow* window = g.CurrentWindow;
    3231*: 8746:    if ((g.OpenPopupStack.Size <= g.BeginPopupStack.Size) || (window->Flags & ImGuiWindowFlags_ChildMenu))
     3231: 8746-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 3231
    %%%%%: 8746-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
     3231: 8747:        return false;
     3231: 8747-block 4
        -: 8748:
        -: 8749:    // Initially we used 'upper_popup->OpenParentId == window->IDStack.back()' to differentiate multiple menu sets from each others
        -: 8750:    // (e.g. inside menu bar vs loose menu items) based on parent ID.
        -: 8751:    // This would however prevent the use of e.g. PushID() user code submitting menus.
        -: 8752:    // Previously this worked between popup and a first child menu because the first child menu always had the _ChildWindow flag,
        -: 8753:    // making hovering on parent popup possible while first child menu was focused - but this was generally a bug with other side effects.
        -: 8754:    // Instead we don't treat Popup specifically (in order to consistently support menu features in them), maybe the first child menu of a Popup
        -: 8755:    // doesn't have the _ChildWindow flag, and we rely on this IsRootOfOpenMenuSet() check to allow hovering between root window/popup and first child menu.
        -: 8756:    // In the end, lack of ID check made it so we could no longer differentiate between separate menu sets. To compensate for that, we at least check parent window nav layer.
        -: 8757:    // This fixes the most common case of menu opening on hover when moving between window content and menu bar. Multiple different menu sets in same nav layer would still
        -: 8758:    // open on hover, but that should be a lesser problem, because if such menus are close in proximity in window content then it won't feel weird and if they are far apart
        -: 8759:    // it likely won't be a problem anyone runs into.
    #####: 8760:    const ImGuiPopupData* upper_popup = &g.OpenPopupStack[g.BeginPopupStack.Size];
    %%%%%: 8760-block 5
call    0 never executed
    #####: 8761:    if (window->DC.NavLayerCurrent != upper_popup->ParentNavLayer)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 8762:        return false;
    %%%%%: 8762-block 7
    #####: 8763:    return upper_popup->Window && (upper_popup->Window->Flags & ImGuiWindowFlags_ChildMenu) && ImGui::IsWindowChildOf(upper_popup->Window, window, true, false);
    %%%%%: 8763-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8763-block 9
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 8763-block 10
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 8763-block 12
    %%%%%: 8763-block 13
    %%%%%: 8763-block 14
        -: 8764:}
        -: 8765:
function _ZN5ImGui11BeginMenuExEPKcS1_b called 3231 returned 100% blocks executed 26%
     3231: 8766:bool ImGui::BeginMenuEx(const char* label, const char* icon, bool enabled)
        -: 8767:{
     3231: 8768:    ImGuiWindow* window = GetCurrentWindow();
     3231: 8768-block 2
call    0 returned 3231
     3231: 8769:    if (window->SkipItems)
branch  0 taken 0 (fallthrough)
branch  1 taken 3231
    #####: 8770:        return false;
    %%%%%: 8770-block 4
        -: 8771:
     3231: 8772:    ImGuiContext& g = *GImGui;
     3231: 8773:    const ImGuiStyle& style = g.Style;
     3231: 8774:    const ImGuiID id = window->GetID(label);
     3231: 8774-block 5
call    0 returned 3231
branch  1 taken 3231 (fallthrough)
branch  2 taken 0 (throw)
     3231: 8775:    bool menu_is_open = IsPopupOpen(id, ImGuiPopupFlags_None);
     3231: 8775-block 6
call    0 returned 3231
branch  1 taken 3231 (fallthrough)
branch  2 taken 0 (throw)
        -: 8776:
        -: 8777:    // Sub-menus are ChildWindow so that mouse can be hovering across them (otherwise top-most popup menu would steal focus and not allow hovering on parent menu)
        -: 8778:    // The first menu in a hierarchy isn't so hovering doesn't get across (otherwise e.g. resizing borders with ImGuiButtonFlags_FlattenChildren would react), but top-most BeginMenu() will bypass that limitation.
     3231: 8779:    ImGuiWindowFlags window_flags = ImGuiWindowFlags_ChildMenu | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoNavFocus;
     3231: 8780:    if (window->Flags & ImGuiWindowFlags_ChildMenu)
     3231: 8780-block 7
branch  0 taken 0 (fallthrough)
branch  1 taken 3231
    #####: 8781:        window_flags |= ImGuiWindowFlags_ChildWindow;
    %%%%%: 8781-block 8
        -: 8782:
        -: 8783:    // If a menu with same the ID was already submitted, we will append to it, matching the behavior of Begin().
        -: 8784:    // We are relying on a O(N) search - so O(N log N) over the frame - which seems like the most efficient for the expected small amount of BeginMenu() calls per frame.
        -: 8785:    // If somehow this is ever becoming a problem we can switch to use e.g. ImGuiStorage mapping key to last frame used.
     3231: 8786:    if (g.MenusIdSubmittedThisFrame.contains(id))
     3231: 8786-block 9
call    0 returned 3231
branch  1 taken 0 (fallthrough)
branch  2 taken 3231
        -: 8787:    {
    #####: 8788:        if (menu_is_open)
    %%%%%: 8788-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 8789:            menu_is_open = BeginPopupEx(id, window_flags); // menu_is_open can be 'false' when the popup is completely clipped (e.g. zero size display)
    %%%%%: 8789-block 12
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 8789-block 13
        -: 8790:        else
    #####: 8791:            g.NextWindowData.ClearFlags();          // we behave like Begin() and need to consume those values
    %%%%%: 8791-block 14
call    0 never executed
    #####: 8792:        return menu_is_open;
    %%%%%: 8792-block 15
        -: 8793:    }
        -: 8794:
        -: 8795:    // Tag menu as used. Next time BeginMenu() with same ID is called it will append to existing menu
     3231: 8796:    g.MenusIdSubmittedThisFrame.push_back(id);
     3231: 8796-block 16
call    0 returned 3231
branch  1 taken 3231 (fallthrough)
branch  2 taken 0 (throw)
        -: 8797:
     3231: 8798:    ImVec2 label_size = CalcTextSize(label, NULL, true);
     3231: 8798-block 17
call    0 returned 3231
branch  1 taken 3231 (fallthrough)
branch  2 taken 0 (throw)
        -: 8799:
        -: 8800:    // Odd hack to allow hovering across menus of a same menu-set (otherwise we wouldn't be able to hover parent without always being a Child window)
        -: 8801:    // This is only done for items for the menu set and not the full parent window.
     3231: 8802:    const bool menuset_is_open = IsRootOfOpenMenuSet();
     3231: 8802-block 18
call    0 returned 3231
branch  1 taken 3231 (fallthrough)
branch  2 taken 0 (throw)
     3231: 8803:    if (menuset_is_open)
     3231: 8803-block 19
branch  0 taken 0 (fallthrough)
branch  1 taken 3231
    #####: 8804:        PushItemFlag(ImGuiItemFlags_NoWindowHoverableCheck, true);
    %%%%%: 8804-block 20
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 8805:
        -: 8806:    // The reference position stored in popup_pos will be used by Begin() to find a suitable position for the child menu,
        -: 8807:    // However the final position is going to be different! It is chosen by FindBestWindowPosForPopup().
        -: 8808:    // e.g. Menus tend to overlap each other horizontally to amplify relative Z-ordering.
     3231: 8809:    ImVec2 popup_pos, pos = window->DC.CursorPos;
     3231: 8810:    PushID(label);
     3231: 8810-block 21
call    0 returned 3231
branch  1 taken 3231 (fallthrough)
branch  2 taken 0 (throw)
     3231: 8811:    if (!enabled)
     3231: 8811-block 22
branch  0 taken 0 (fallthrough)
branch  1 taken 3231
    #####: 8812:        BeginDisabled();
    %%%%%: 8812-block 23
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
     3231: 8813:    const ImGuiMenuColumns* offsets = &window->DC.MenuColumns;
        -: 8814:    bool pressed;
        -: 8815:
        -: 8816:    // We use ImGuiSelectableFlags_NoSetKeyOwner to allow down on one menu item, move, up on another.
     3231: 8817:    const ImGuiSelectableFlags selectable_flags = ImGuiSelectableFlags_NoHoldingActiveID | ImGuiSelectableFlags_NoSetKeyOwner | ImGuiSelectableFlags_SelectOnClick | ImGuiSelectableFlags_NoAutoClosePopups;
     3231: 8818:    if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)
     3231: 8818-block 24
branch  0 taken 3231 (fallthrough)
branch  1 taken 0
        -: 8819:    {
        -: 8820:        // Menu inside an horizontal menu bar
        -: 8821:        // Selectable extend their highlight by half ItemSpacing in each direction.
        -: 8822:        // For ChildMenu, the popup position will be overwritten by the call to FindBestWindowPosForPopup() in Begin()
     3231: 8823:        popup_pos = ImVec2(pos.x - 1.0f - IM_TRUNC(style.ItemSpacing.x * 0.5f), pos.y - style.FramePadding.y + window->MenuBarHeight);
     3231: 8823-block 25
call    0 returned 3231
     3231: 8824:        window->DC.CursorPos.x += IM_TRUNC(style.ItemSpacing.x * 0.5f);
     3231: 8825:        PushStyleVarX(ImGuiStyleVar_ItemSpacing, style.ItemSpacing.x * 2.0f);
call    0 returned 3231
branch  1 taken 3231 (fallthrough)
branch  2 taken 0 (throw)
     3231: 8826:        float w = label_size.x;
     3231: 8827:        ImVec2 text_pos(window->DC.CursorPos.x + offsets->OffsetLabel, window->DC.CursorPos.y + window->DC.CurrLineTextBaseOffset);
     3231: 8827-block 27
call    0 returned 3231
     3231: 8828:        pressed = Selectable("", menu_is_open, selectable_flags, ImVec2(w, label_size.y));
call    0 returned 3231
call    1 returned 3231
branch  2 taken 3231 (fallthrough)
branch  3 taken 0 (throw)
    $$$$$: 8828-block 163
     3231: 8829:        RenderText(text_pos, label);
     3231: 8829-block 30
call    0 returned 3231
branch  1 taken 3231 (fallthrough)
branch  2 taken 0 (throw)
     3231: 8830:        PopStyleVar();
     3231: 8830-block 31
call    0 returned 3231
branch  1 taken 3231 (fallthrough)
branch  2 taken 0 (throw)
     3231: 8831:        window->DC.CursorPos.x += IM_TRUNC(style.ItemSpacing.x * (-1.0f + 0.5f)); // -1 spacing to compensate the spacing added when Selectable() did a SameLine(). It would also work to call SameLine() ourselves after the PopStyleVar().
     3231: 8831-block 32
        -: 8832:    }
        -: 8833:    else
        -: 8834:    {
        -: 8835:        // Menu inside a regular/vertical menu
        -: 8836:        // (In a typical menu window where all items are BeginMenu() or MenuItem() calls, extra_w will always be 0.0f.
        -: 8837:        //  Only when they are other items sticking out we're going to add spacing, yet only register minimum width into the layout system.
    #####: 8838:        popup_pos = ImVec2(pos.x, pos.y - style.WindowPadding.y);
    %%%%%: 8838-block 33
call    0 never executed
    #####: 8839:        float icon_w = (icon && icon[0]) ? CalcTextSize(icon, NULL).x : 0.0f;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8839-block 35
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 8839-block 36
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    %%%%%: 8839-block 37
    %%%%%: 8839-block 38
    #####: 8840:        float checkmark_w = IM_TRUNC(g.FontSize * 1.20f);
    #####: 8841:        float min_w = window->DC.MenuColumns.DeclColumns(icon_w, label_size.x, 0.0f, checkmark_w); // Feedback to next frame
    %%%%%: 8841-block 39
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 8842:        float extra_w = ImMax(0.0f, GetContentRegionAvail().x - min_w);
    %%%%%: 8842-block 40
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 8842-block 41
call    3 never executed
    #####: 8843:        ImVec2 text_pos(window->DC.CursorPos.x + offsets->OffsetLabel, window->DC.CursorPos.y + window->DC.CurrLineTextBaseOffset);
call    0 never executed
    #####: 8844:        pressed = Selectable("", menu_is_open, selectable_flags | ImGuiSelectableFlags_SpanAvailWidth, ImVec2(min_w, label_size.y));
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$: 8844-block 165
    #####: 8845:        RenderText(text_pos, label);
    %%%%%: 8845-block 45
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 8846:        if (icon_w > 0.0f)
    %%%%%: 8846-block 46
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 8847:            RenderText(pos + ImVec2(offsets->OffsetIcon, 0.0f), icon);
    %%%%%: 8847-block 47
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 8847-block 50
    $$$$$: 8847-block 166
    #####: 8848:        RenderArrow(window->DrawList, pos + ImVec2(offsets->OffsetMark + extra_w + g.FontSize * 0.30f, 0.0f), GetColorU32(ImGuiCol_Text), ImGuiDir_Right);
    %%%%%: 8848-block 51
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 8848-block 52
call    3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
    %%%%%: 8848-block 55
    $$$$$: 8848-block 167
        -: 8849:    }
     3231: 8850:    if (!enabled)
     3231: 8850-block 56
branch  0 taken 0 (fallthrough)
branch  1 taken 3231
    #####: 8851:        EndDisabled();
    %%%%%: 8851-block 57
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 8852:
    3231*: 8853:    const bool hovered = (g.HoveredId == id) && enabled && !g.NavHighlightItemUnderNav;
     3231: 8853-block 58
branch  0 taken 0 (fallthrough)
branch  1 taken 3231
    %%%%%: 8853-block 59
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 8853-block 60
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 8853-block 61
     3231: 8853-block 62
     3231: 8854:    if (menuset_is_open)
     3231: 8854-block 63
branch  0 taken 0 (fallthrough)
branch  1 taken 3231
    #####: 8855:        PopItemFlag();
    %%%%%: 8855-block 64
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 8856:
     3231: 8857:    bool want_open = false;
     3231: 8858:    bool want_open_nav_init = false;
     3231: 8859:    bool want_close = false;
     3231: 8860:    if (window->DC.LayoutType == ImGuiLayoutType_Vertical) // (window->Flags & (ImGuiWindowFlags_Popup|ImGuiWindowFlags_ChildMenu))
     3231: 8860-block 65
branch  0 taken 0 (fallthrough)
branch  1 taken 3231
        -: 8861:    {
        -: 8862:        // Close menu when not hovering it anymore unless we are moving roughly in the direction of the menu
        -: 8863:        // Implement http://bjk5.com/post/44698559168/breaking-down-amazons-mega-dropdown to avoid using timers, so menus feels more reactive.
    #####: 8864:        bool moving_toward_child_menu = false;
    #####: 8865:        ImGuiPopupData* child_popup = (g.BeginPopupStack.Size < g.OpenPopupStack.Size) ? &g.OpenPopupStack[g.BeginPopupStack.Size] : NULL; // Popup candidate (testing below)
    %%%%%: 8865-block 66
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8865-block 67
call    2 never executed
    %%%%%: 8865-block 68
    #####: 8866:        ImGuiWindow* child_menu_window = (child_popup && child_popup->Window && child_popup->Window->ParentWindow == window) ? child_popup->Window : NULL;
    %%%%%: 8866-block 69
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8866-block 70
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 8866-block 71
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 8866-block 72
    %%%%%: 8866-block 73
    #####: 8867:        if (g.HoveredWindow == window && child_menu_window != NULL)
    %%%%%: 8867-block 74
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8867-block 75
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 8868:        {
    #####: 8869:            const float ref_unit = g.FontSize; // FIXME-DPI
    #####: 8870:            const float child_dir = (window->Pos.x < child_menu_window->Pos.x) ? 1.0f : -1.0f;
    %%%%%: 8870-block 76
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8870-block 77
    %%%%%: 8870-block 78
    #####: 8871:            const ImRect next_window_rect = child_menu_window->Rect();
    %%%%%: 8871-block 79
call    0 never executed
    #####: 8872:            ImVec2 ta = (g.IO.MousePos - g.IO.MouseDelta);
call    0 never executed
    #####: 8873:            ImVec2 tb = (child_dir > 0.0f) ? next_window_rect.GetTL() : next_window_rect.GetTR();
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8873-block 82
call    2 never executed
    %%%%%: 8873-block 83
call    3 never executed
    #####: 8874:            ImVec2 tc = (child_dir > 0.0f) ? next_window_rect.GetBL() : next_window_rect.GetBR();
    %%%%%: 8874-block 84
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8874-block 85
call    2 never executed
    %%%%%: 8874-block 86
call    3 never executed
    #####: 8875:            const float pad_farmost_h = ImClamp(ImFabs(ta.x - tb.x) * 0.30f, ref_unit * 0.5f, ref_unit * 2.5f); // Add a bit of extra slack.
    %%%%%: 8875-block 87
call    0 never executed
    #####: 8876:            ta.x += child_dir * -0.5f;
    #####: 8877:            tb.x += child_dir * ref_unit;
    #####: 8878:            tc.x += child_dir * ref_unit;
    #####: 8879:            tb.y = ta.y + ImMax((tb.y - pad_farmost_h) - ta.y, -ref_unit * 8.0f); // Triangle has maximum height to limit the slope and the bias toward large sub-menus
call    0 never executed
    #####: 8880:            tc.y = ta.y + ImMin((tc.y + pad_farmost_h) - ta.y, +ref_unit * 8.0f);
call    0 never executed
    #####: 8881:            moving_toward_child_menu = ImTriangleContainsPoint(ta, tb, tc, g.IO.MousePos);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 8881-block 91
        -: 8882:            //GetForegroundDrawList()->AddTriangleFilled(ta, tb, tc, moving_toward_child_menu ? IM_COL32(0,128,0,128) : IM_COL32(128,0,0,128)); // [DEBUG]
        -: 8883:        }
        -: 8884:
        -: 8885:        // The 'HovereWindow == window' check creates an inconsistency (e.g. moving away from menu slowly tends to hit same window, whereas moving away fast does not)
        -: 8886:        // But we also need to not close the top-menu menu when moving over void. Perhaps we should extend the triangle check to a larger polygon.
        -: 8887:        // (Remember to test this on BeginPopup("A")->BeginMenu("B") sequence which behaves slightly differently as B isn't a Child of A and hovering isn't shared.)
    #####: 8888:        if (menu_is_open && !hovered && g.HoveredWindow == window && !moving_toward_child_menu && !g.NavHighlightItemUnderNav && g.ActiveId == 0)
    %%%%%: 8888-block 92
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8888-block 93
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 8888-block 94
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 8888-block 95
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 8888-block 96
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%: 8888-block 97
branch 10 never executed (fallthrough)
branch 11 never executed
    #####: 8889:            want_close = true;
    %%%%%: 8889-block 98
        -: 8890:
        -: 8891:        // Open
        -: 8892:        // (note: at this point 'hovered' actually includes the NavDisableMouseHover == false test)
    #####: 8893:        if (!menu_is_open && pressed) // Click/activate to open
    %%%%%: 8893-block 99
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8893-block 100
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 8894:            want_open = true;
    %%%%%: 8894-block 101
    #####: 8895:        else if (!menu_is_open && hovered && !moving_toward_child_menu) // Hover to open
    %%%%%: 8895-block 102
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8895-block 103
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 8895-block 104
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 8896:            want_open = true;
    %%%%%: 8896-block 105
    #####: 8897:        else if (!menu_is_open && hovered && g.HoveredIdTimer >= 0.30f && g.MouseStationaryTimer >= 0.30f) // Hover to open (timer fallback)
    %%%%%: 8897-block 106
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8897-block 107
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 8897-block 108
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 8897-block 109
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 8898:            want_open = true;
    %%%%%: 8898-block 110
    #####: 8899:        if (g.NavId == id && g.NavMoveDir == ImGuiDir_Right) // Nav-Right to open
    %%%%%: 8899-block 111
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8899-block 112
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 8900:        {
    #####: 8901:            want_open = want_open_nav_init = true;
    #####: 8902:            NavMoveRequestCancel();
    %%%%%: 8902-block 113
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 8903:            SetNavCursorVisibleAfterMove();
    %%%%%: 8903-block 114
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 8904:        }
        -: 8905:    }
        -: 8906:    else
        -: 8907:    {
        -: 8908:        // Menu bar
    3231*: 8909:        if (menu_is_open && pressed && menuset_is_open) // Click an open menu again to close it
     3231: 8909-block 115
branch  0 taken 0 (fallthrough)
branch  1 taken 3231
    %%%%%: 8909-block 116
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 8909-block 117
branch  4 never executed (fallthrough)
branch  5 never executed
        -: 8910:        {
    #####: 8911:            want_close = true;
    #####: 8912:            want_open = menu_is_open = false;
    %%%%%: 8912-block 118
        -: 8913:        }
    3231*: 8914:        else if (pressed || (hovered && menuset_is_open && !menu_is_open)) // First click to open, then hover to open others
     3231: 8914-block 119
branch  0 taken 3231 (fallthrough)
branch  1 taken 0
     3231: 8914-block 120
branch  2 taken 0 (fallthrough)
branch  3 taken 3231
    %%%%%: 8914-block 121
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 8914-block 122
branch  6 never executed (fallthrough)
branch  7 never executed
        -: 8915:        {
    #####: 8916:            want_open = true;
    %%%%%: 8916-block 123
        -: 8917:        }
    3231*: 8918:        else if (g.NavId == id && g.NavMoveDir == ImGuiDir_Down) // Nav-Down to open
     3231: 8918-block 124
branch  0 taken 0 (fallthrough)
branch  1 taken 3231
    %%%%%: 8918-block 125
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 8919:        {
    #####: 8920:            want_open = true;
    #####: 8921:            NavMoveRequestCancel();
    %%%%%: 8921-block 126
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 8922:        }
        -: 8923:    }
        -: 8924:
     3231: 8925:    if (!enabled) // explicitly close if an open menu becomes disabled, facilitate users code a lot in pattern such as 'if (BeginMenu("options", has_object)) { ..use object.. }'
     3231: 8925-block 127
branch  0 taken 0 (fallthrough)
branch  1 taken 3231
    #####: 8926:        want_close = true;
    %%%%%: 8926-block 128
    3231*: 8927:    if (want_close && IsPopupOpen(id, ImGuiPopupFlags_None))
     3231: 8927-block 129
branch  0 taken 0 (fallthrough)
branch  1 taken 3231
    %%%%%: 8927-block 130
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 8927-block 131
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 8927-block 132
     3231: 8927-block 133
     3231: 8927-block 134
branch  7 taken 0 (fallthrough)
branch  8 taken 3231
    #####: 8928:        ClosePopupToLevel(g.BeginPopupStack.Size, true);
    %%%%%: 8928-block 135
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 8929:
        -: 8930:    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags | ImGuiItemStatusFlags_Openable | (menu_is_open ? ImGuiItemStatusFlags_Opened : 0));
     3231: 8931:    PopID();
     3231: 8931-block 136
call    0 returned 3231
branch  1 taken 3231 (fallthrough)
branch  2 taken 0 (throw)
        -: 8932:
    3231*: 8933:    if (want_open && !menu_is_open && g.OpenPopupStack.Size > g.BeginPopupStack.Size)
     3231: 8933-block 137
branch  0 taken 0 (fallthrough)
branch  1 taken 3231
    %%%%%: 8933-block 138
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 8933-block 139
branch  4 never executed (fallthrough)
branch  5 never executed
        -: 8934:    {
        -: 8935:        // Don't reopen/recycle same menu level in the same frame if it is a different menu ID, first close the other menu and yield for a frame.
    #####: 8936:        OpenPopup(label);
    %%%%%: 8936-block 140
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 8937:    }
     3231: 8938:    else if (want_open)
     3231: 8938-block 142
branch  0 taken 0 (fallthrough)
branch  1 taken 3231
        -: 8939:    {
    #####: 8940:        menu_is_open = true;
    #####: 8941:        OpenPopup(label, ImGuiPopupFlags_NoReopen);// | (want_open_nav_init ? ImGuiPopupFlags_NoReopenAlwaysNavInit : 0));
    %%%%%: 8941-block 143
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 8942:    }
        -: 8943:
     3231: 8944:    if (menu_is_open)
     3231: 8944-block 144
branch  0 taken 0 (fallthrough)
branch  1 taken 3231
        -: 8945:    {
    #####: 8946:        ImGuiLastItemData last_item_in_parent = g.LastItemData;
    #####: 8947:        SetNextWindowPos(popup_pos, ImGuiCond_Always);                  // Note: misleading: the value will serve as reference for FindBestWindowPosForPopup(), not actual pos.
    %%%%%: 8947-block 145
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$: 8947-block 170
    #####: 8948:        PushStyleVar(ImGuiStyleVar_ChildRounding, style.PopupRounding); // First level will use _PopupRounding, subsequent will use _ChildRounding
    %%%%%: 8948-block 147
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 8949:        menu_is_open = BeginPopupEx(id, window_flags);                  // menu_is_open can be 'false' when the popup is completely clipped (e.g. zero size display)
    %%%%%: 8949-block 148
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 8950:        PopStyleVar();
    %%%%%: 8950-block 149
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 8951:        if (menu_is_open)
    %%%%%: 8951-block 150
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 8952:        {
        -: 8953:            // Implement what ImGuiPopupFlags_NoReopenAlwaysNavInit would do:
        -: 8954:            // Perform an init request in the case the popup was already open (via a previous mouse hover)
    #####: 8955:            if (want_open && want_open_nav_init && !g.NavInitRequest)
    %%%%%: 8955-block 151
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8955-block 152
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 8955-block 153
branch  4 never executed (fallthrough)
branch  5 never executed
        -: 8956:            {
    #####: 8957:                FocusWindow(g.CurrentWindow, ImGuiFocusRequestFlags_UnlessBelowModal);
    %%%%%: 8957-block 154
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 8958:                NavInitWindow(g.CurrentWindow, false);
    %%%%%: 8958-block 155
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 8959:            }
        -: 8960:
        -: 8961:            // Restore LastItemData so IsItemXXXX functions can work after BeginMenu()/EndMenu()
        -: 8962:            // (This fixes using IsItemClicked() and IsItemHovered(), but IsItemHovered() also relies on its support for ImGuiItemFlags_NoWindowHoverableCheck)
    #####: 8963:            g.LastItemData = last_item_in_parent;
    #####: 8964:            if (g.HoveredWindow == window)
    %%%%%: 8964-block 156
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 8965:                g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredWindow;
    %%%%%: 8965-block 157
        -: 8966:        }
        -: 8967:    }
        -: 8968:    else
        -: 8969:    {
     3231: 8970:        g.NextWindowData.ClearFlags(); // We behave like Begin() and need to consume those values
     3231: 8970-block 159
call    0 returned 3231
        -: 8971:    }
        -: 8972:
     3231: 8973:    return menu_is_open;
     3231: 8973-block 160
        -: 8974:}
        -: 8975:
function _ZN5ImGui9BeginMenuEPKcb called 3231 returned 100% blocks executed 100%
     3231: 8976:bool ImGui::BeginMenu(const char* label, bool enabled)
        -: 8977:{
     3231: 8978:    return BeginMenuEx(label, NULL, enabled);
     3231: 8978-block 2
call    0 returned 3231
        -: 8979:}
        -: 8980:
function _ZN5ImGui7EndMenuEv called 0 returned 0% blocks executed 0%
    #####: 8981:void ImGui::EndMenu()
        -: 8982:{
        -: 8983:    // Nav: When a left move request our menu failed, close ourselves.
    #####: 8984:    ImGuiContext& g = *GImGui;
    #####: 8985:    ImGuiWindow* window = g.CurrentWindow;
    #####: 8986:    IM_ASSERT(window->Flags & ImGuiWindowFlags_Popup);  // Mismatched BeginMenu()/EndMenu() calls
    %%%%%: 8986-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8986-block 3
call    2 never executed
    #####: 8987:    ImGuiWindow* parent_window = window->ParentWindow;  // Should always be != NULL is we passed assert.
    #####: 8988:    if (window->BeginCount == window->BeginCountPreviousFrame)
    %%%%%: 8988-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 8989:        if (g.NavMoveDir == ImGuiDir_Left && NavMoveRequestButNoResultYet())
    %%%%%: 8989-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8989-block 6
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 8989-block 8
    %%%%%: 8989-block 9
    %%%%%: 8989-block 10
branch  5 never executed (fallthrough)
branch  6 never executed
    #####: 8990:            if (g.NavWindow && (g.NavWindow->RootWindowForNav == window) && parent_window->DC.LayoutType == ImGuiLayoutType_Vertical)
    %%%%%: 8990-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 8990-block 12
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 8990-block 13
branch  4 never executed (fallthrough)
branch  5 never executed
        -: 8991:            {
    #####: 8992:                ClosePopupToLevel(g.BeginPopupStack.Size - 1, true);
    %%%%%: 8992-block 14
call    0 never executed
    #####: 8993:                NavMoveRequestCancel();
call    0 never executed
        -: 8994:            }
        -: 8995:
    #####: 8996:    EndPopup();
    %%%%%: 8996-block 16
call    0 never executed
    #####: 8997:}
        -: 8998:
function _ZN5ImGui10MenuItemExEPKcS1_S1_bb called 0 returned 0% blocks executed 0%
    #####: 8999:bool ImGui::MenuItemEx(const char* label, const char* icon, const char* shortcut, bool selected, bool enabled)
        -: 9000:{
    #####: 9001:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%: 9001-block 2
call    0 never executed
    #####: 9002:    if (window->SkipItems)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9003:        return false;
    %%%%%: 9003-block 4
        -: 9004:
    #####: 9005:    ImGuiContext& g = *GImGui;
    #####: 9006:    ImGuiStyle& style = g.Style;
    #####: 9007:    ImVec2 pos = window->DC.CursorPos;
    #####: 9008:    ImVec2 label_size = CalcTextSize(label, NULL, true);
    %%%%%: 9008-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 9009:
        -: 9010:    // See BeginMenuEx() for comments about this.
    #####: 9011:    const bool menuset_is_open = IsRootOfOpenMenuSet();
    %%%%%: 9011-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 9012:    if (menuset_is_open)
    %%%%%: 9012-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9013:        PushItemFlag(ImGuiItemFlags_NoWindowHoverableCheck, true);
    %%%%%: 9013-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 9014:
        -: 9015:    // We've been using the equivalent of ImGuiSelectableFlags_SetNavIdOnHover on all Selectable() since early Nav system days (commit 43ee5d73),
        -: 9016:    // but I am unsure whether this should be kept at all. For now moved it to be an opt-in feature used by menus only.
        -: 9017:    bool pressed;
    #####: 9018:    PushID(label);
    %%%%%: 9018-block 9
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 9019:    if (!enabled)
    %%%%%: 9019-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9020:        BeginDisabled();
    %%%%%: 9020-block 11
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 9021:
        -: 9022:    // We use ImGuiSelectableFlags_NoSetKeyOwner to allow down on one menu item, move, up on another.
    #####: 9023:    const ImGuiSelectableFlags selectable_flags = ImGuiSelectableFlags_SelectOnRelease | ImGuiSelectableFlags_NoSetKeyOwner | ImGuiSelectableFlags_SetNavIdOnHover;
    #####: 9024:    const ImGuiMenuColumns* offsets = &window->DC.MenuColumns;
    #####: 9025:    if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)
    %%%%%: 9025-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 9026:    {
        -: 9027:        // Mimic the exact layout spacing of BeginMenu() to allow MenuItem() inside a menu bar, which is a little misleading but may be useful
        -: 9028:        // Note that in this situation: we don't render the shortcut, we render a highlight instead of the selected tick mark.
    #####: 9029:        float w = label_size.x;
    #####: 9030:        window->DC.CursorPos.x += IM_TRUNC(style.ItemSpacing.x * 0.5f);
    #####: 9031:        ImVec2 text_pos(window->DC.CursorPos.x + offsets->OffsetLabel, window->DC.CursorPos.y + window->DC.CurrLineTextBaseOffset);
    %%%%%: 9031-block 13
call    0 never executed
    #####: 9032:        PushStyleVarX(ImGuiStyleVar_ItemSpacing, style.ItemSpacing.x * 2.0f);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 9033:        pressed = Selectable("", selected, selectable_flags, ImVec2(w, 0.0f));
    %%%%%: 9033-block 15
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$: 9033-block 65
    #####: 9034:        PopStyleVar();
    %%%%%: 9034-block 17
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 9035:        if (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_Visible)
    %%%%%: 9035-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9036:            RenderText(text_pos, label);
    %%%%%: 9036-block 19
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 9037:        window->DC.CursorPos.x += IM_TRUNC(style.ItemSpacing.x * (-1.0f + 0.5f)); // -1 spacing to compensate the spacing added when Selectable() did a SameLine(). It would also work to call SameLine() ourselves after the PopStyleVar().
    %%%%%: 9037-block 20
        -: 9038:    }
        -: 9039:    else
        -: 9040:    {
        -: 9041:        // Menu item inside a vertical menu
        -: 9042:        // (In a typical menu window where all items are BeginMenu() or MenuItem() calls, extra_w will always be 0.0f.
        -: 9043:        //  Only when they are other items sticking out we're going to add spacing, yet only register minimum width into the layout system.
    #####: 9044:        float icon_w = (icon && icon[0]) ? CalcTextSize(icon, NULL).x : 0.0f;
    %%%%%: 9044-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9044-block 22
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 9044-block 23
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    %%%%%: 9044-block 24
    %%%%%: 9044-block 25
    #####: 9045:        float shortcut_w = (shortcut && shortcut[0]) ? CalcTextSize(shortcut, NULL).x : 0.0f;
    %%%%%: 9045-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9045-block 27
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 9045-block 28
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    %%%%%: 9045-block 29
    %%%%%: 9045-block 30
    #####: 9046:        float checkmark_w = IM_TRUNC(g.FontSize * 1.20f);
    #####: 9047:        float min_w = window->DC.MenuColumns.DeclColumns(icon_w, label_size.x, shortcut_w, checkmark_w); // Feedback for next frame
    %%%%%: 9047-block 31
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 9048:        float stretch_w = ImMax(0.0f, GetContentRegionAvail().x - min_w);
    %%%%%: 9048-block 32
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 9048-block 33
call    3 never executed
    #####: 9049:        pressed = Selectable("", false, selectable_flags | ImGuiSelectableFlags_SpanAvailWidth, ImVec2(min_w, label_size.y));
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$: 9049-block 67
    #####: 9050:        if (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_Visible)
    %%%%%: 9050-block 36
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 9051:        {
    #####: 9052:            RenderText(pos + ImVec2(offsets->OffsetLabel, 0.0f), label);
    %%%%%: 9052-block 37
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    $$$$$: 9052-block 68
    #####: 9053:            if (icon_w > 0.0f)
    %%%%%: 9053-block 40
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9054:                RenderText(pos + ImVec2(offsets->OffsetIcon, 0.0f), icon);
    %%%%%: 9054-block 41
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 9054-block 44
    $$$$$: 9054-block 69
    #####: 9055:            if (shortcut_w > 0.0f)
    %%%%%: 9055-block 45
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 9056:            {
    #####: 9057:                PushStyleColor(ImGuiCol_Text, style.Colors[ImGuiCol_TextDisabled]);
    %%%%%: 9057-block 46
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 9058:                RenderText(pos + ImVec2(offsets->OffsetShortcut + stretch_w, 0.0f), shortcut, NULL, false);
    %%%%%: 9058-block 47
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    $$$$$: 9058-block 70
    #####: 9059:                PopStyleColor();
    %%%%%: 9059-block 50
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 9060:            }
    #####: 9061:            if (selected)
    %%%%%: 9061-block 51
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9062:                RenderCheckMark(window->DrawList, pos + ImVec2(offsets->OffsetMark + stretch_w + g.FontSize * 0.40f, g.FontSize * 0.134f * 0.5f), GetColorU32(ImGuiCol_Text), g.FontSize * 0.866f);
    %%%%%: 9062-block 52
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 9062-block 53
call    3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
    %%%%%: 9062-block 56
    $$$$$: 9062-block 71
        -: 9063:        }
        -: 9064:    }
        -: 9065:    IMGUI_TEST_ENGINE_ITEM_INFO(g.LastItemData.ID, label, g.LastItemData.StatusFlags | ImGuiItemStatusFlags_Checkable | (selected ? ImGuiItemStatusFlags_Checked : 0));
    #####: 9066:    if (!enabled)
    %%%%%: 9066-block 57
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9067:        EndDisabled();
    %%%%%: 9067-block 58
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 9068:    PopID();
    %%%%%: 9068-block 59
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 9069:    if (menuset_is_open)
    %%%%%: 9069-block 60
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9070:        PopItemFlag();
    %%%%%: 9070-block 61
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 9071:
    #####: 9072:    return pressed;
    %%%%%: 9072-block 62
        -: 9073:}
        -: 9074:
function _ZN5ImGui8MenuItemEPKcS1_bb called 0 returned 0% blocks executed 0%
    #####: 9075:bool ImGui::MenuItem(const char* label, const char* shortcut, bool selected, bool enabled)
        -: 9076:{
    #####: 9077:    return MenuItemEx(label, NULL, shortcut, selected, enabled);
    %%%%%: 9077-block 2
call    0 never executed
        -: 9078:}
        -: 9079:
function _ZN5ImGui8MenuItemEPKcS1_Pbb called 0 returned 0% blocks executed 0%
    #####: 9080:bool ImGui::MenuItem(const char* label, const char* shortcut, bool* p_selected, bool enabled)
        -: 9081:{
    #####: 9082:    if (MenuItemEx(label, NULL, shortcut, p_selected ? *p_selected : false, enabled))
    %%%%%: 9082-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9082-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 9082-block 4
    %%%%%: 9082-block 5
    %%%%%: 9082-block 6
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed
        -: 9083:    {
    #####: 9084:        if (p_selected)
    %%%%%: 9084-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9085:            *p_selected = !*p_selected;
    %%%%%: 9085-block 9
    #####: 9086:        return true;
    %%%%%: 9086-block 10
        -: 9087:    }
    #####: 9088:    return false;
    %%%%%: 9088-block 11
        -: 9089:}
        -: 9090:
        -: 9091://-------------------------------------------------------------------------
        -: 9092:// [SECTION] Widgets: BeginTabBar, EndTabBar, etc.
        -: 9093://-------------------------------------------------------------------------
        -: 9094:// - BeginTabBar()
        -: 9095:// - BeginTabBarEx() [Internal]
        -: 9096:// - EndTabBar()
        -: 9097:// - TabBarLayout() [Internal]
        -: 9098:// - TabBarCalcTabID() [Internal]
        -: 9099:// - TabBarCalcMaxTabWidth() [Internal]
        -: 9100:// - TabBarFindTabById() [Internal]
        -: 9101:// - TabBarFindTabByOrder() [Internal]
        -: 9102:// - TabBarFindMostRecentlySelectedTabForActiveWindow() [Internal]
        -: 9103:// - TabBarGetCurrentTab() [Internal]
        -: 9104:// - TabBarGetTabName() [Internal]
        -: 9105:// - TabBarAddTab() [Internal]
        -: 9106:// - TabBarRemoveTab() [Internal]
        -: 9107:// - TabBarCloseTab() [Internal]
        -: 9108:// - TabBarScrollClamp() [Internal]
        -: 9109:// - TabBarScrollToTab() [Internal]
        -: 9110:// - TabBarQueueFocus() [Internal]
        -: 9111:// - TabBarQueueReorder() [Internal]
        -: 9112:// - TabBarProcessReorderFromMousePos() [Internal]
        -: 9113:// - TabBarProcessReorder() [Internal]
        -: 9114:// - TabBarScrollingButtons() [Internal]
        -: 9115:// - TabBarTabListPopupButton() [Internal]
        -: 9116://-------------------------------------------------------------------------
        -: 9117:
        -: 9118:struct ImGuiTabBarSection
        -: 9119:{
        -: 9120:    int                 TabCount;               // Number of tabs in this section.
        -: 9121:    float               Width;                  // Sum of width of tabs in this section (after shrinking down)
        -: 9122:    float               Spacing;                // Horizontal spacing at the end of the section.
        -: 9123:
function _ZN18ImGuiTabBarSectionC2Ev called 16140 returned 100% blocks executed 100%
    16140: 9124:    ImGuiTabBarSection() { memset(this, 0, sizeof(*this)); }
        -: 9125:};
        -: 9126:
        -: 9127:namespace ImGui
        -: 9128:{
        -: 9129:    static void             TabBarLayout(ImGuiTabBar* tab_bar);
        -: 9130:    static ImU32            TabBarCalcTabID(ImGuiTabBar* tab_bar, const char* label, ImGuiWindow* docked_window);
        -: 9131:    static float            TabBarCalcMaxTabWidth();
        -: 9132:    static float            TabBarScrollClamp(ImGuiTabBar* tab_bar, float scrolling);
        -: 9133:    static void             TabBarScrollToTab(ImGuiTabBar* tab_bar, ImGuiID tab_id, ImGuiTabBarSection* sections);
        -: 9134:    static ImGuiTabItem*    TabBarScrollingButtons(ImGuiTabBar* tab_bar);
        -: 9135:    static ImGuiTabItem*    TabBarTabListPopupButton(ImGuiTabBar* tab_bar);
        -: 9136:}
        -: 9137:
function _ZN11ImGuiTabBarC2Ev called 5 returned 100% blocks executed 88%
        5: 9138:ImGuiTabBar::ImGuiTabBar()
        5: 9138-block 2
call    0 returned 5
call    1 returned 5
call    2 returned 5
call    3 returned 5
call    4 returned 5
branch  5 taken 5 (fallthrough)
branch  6 taken 0 (throw)
        -: 9139:{
        5: 9140:    memset(this, 0, sizeof(*this));
        5: 9141:    CurrFrameVisible = PrevFrameVisible = -1;
        5: 9142:    LastTabItemIdx = -1;
        5: 9143:}
        5: 9143-block 7
    $$$$$: 9143-block 8
call    0 never executed
        -: 9144:
function _ZL20TabItemGetSectionIdxPK12ImGuiTabItem called 11836 returned 100% blocks executed 75%
    11836: 9145:static inline int TabItemGetSectionIdx(const ImGuiTabItem* tab)
        -: 9146:{
   11836*: 9147:    return (tab->Flags & ImGuiTabItemFlags_Leading) ? 0 : (tab->Flags & ImGuiTabItemFlags_Trailing) ? 2 : 1;
    11836: 9147-block 2
branch  0 taken 11836 (fallthrough)
branch  1 taken 0
    11836: 9147-block 3
branch  2 taken 0 (fallthrough)
branch  3 taken 11836
    %%%%%: 9147-block 4
    11836: 9147-block 5
    11836: 9147-block 6
    %%%%%: 9147-block 7
    11836: 9147-block 8
        -: 9148:}
        -: 9149:
function _ZL24TabItemComparerBySectionPKvS0_ called 0 returned 0% blocks executed 0%
    #####: 9150:static int IMGUI_CDECL TabItemComparerBySection(const void* lhs, const void* rhs)
        -: 9151:{
    #####: 9152:    const ImGuiTabItem* a = (const ImGuiTabItem*)lhs;
    #####: 9153:    const ImGuiTabItem* b = (const ImGuiTabItem*)rhs;
    #####: 9154:    const int a_section = TabItemGetSectionIdx(a);
    %%%%%: 9154-block 2
call    0 never executed
    #####: 9155:    const int b_section = TabItemGetSectionIdx(b);
call    0 never executed
    #####: 9156:    if (a_section != b_section)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9157:        return a_section - b_section;
    %%%%%: 9157-block 5
    #####: 9158:    return (int)(a->IndexDuringLayout - b->IndexDuringLayout);
    %%%%%: 9158-block 6
        -: 9159:}
        -: 9160:
function _ZL27TabItemComparerByBeginOrderPKvS0_ called 0 returned 0% blocks executed 0%
    #####: 9161:static int IMGUI_CDECL TabItemComparerByBeginOrder(const void* lhs, const void* rhs)
        -: 9162:{
    #####: 9163:    const ImGuiTabItem* a = (const ImGuiTabItem*)lhs;
    #####: 9164:    const ImGuiTabItem* b = (const ImGuiTabItem*)rhs;
    #####: 9165:    return (int)(a->BeginOrder - b->BeginOrder);
    %%%%%: 9165-block 2
        -: 9166:}
        -: 9167:
function _ZL22GetTabBarFromTabBarRefRK15ImGuiPtrOrIndex called 0 returned 0% blocks executed 0%
    #####: 9168:static ImGuiTabBar* GetTabBarFromTabBarRef(const ImGuiPtrOrIndex& ref)
        -: 9169:{
    #####: 9170:    ImGuiContext& g = *GImGui;
    #####: 9171:    return ref.Ptr ? (ImGuiTabBar*)ref.Ptr : g.TabBars.GetByIndex(ref.Index);
    %%%%%: 9171-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9171-block 3
    %%%%%: 9171-block 4
call    2 never executed
    %%%%%: 9171-block 6
        -: 9172:}
        -: 9173:
function _ZL22GetTabBarRefFromTabBarP11ImGuiTabBar called 5380 returned 100% blocks executed 60%
     5380: 9174:static ImGuiPtrOrIndex GetTabBarRefFromTabBar(ImGuiTabBar* tab_bar)
        -: 9175:{
     5380: 9176:    ImGuiContext& g = *GImGui;
     5380: 9177:    if (g.TabBars.Contains(tab_bar))
     5380: 9177-block 2
call    0 returned 5380
branch  1 taken 0 (fallthrough)
branch  2 taken 5380
    #####: 9178:        return ImGuiPtrOrIndex(g.TabBars.GetIndex(tab_bar));
    %%%%%: 9178-block 4
call    0 never executed
call    1 never executed
    %%%%%: 9178-block 7
     5380: 9179:    return ImGuiPtrOrIndex(tab_bar);
     5380: 9179-block 8
call    0 returned 5380
     5380: 9179-block 10
        -: 9180:}
        -: 9181:
function _ZN5ImGui11BeginTabBarEPKci called 0 returned 0% blocks executed 0%
    #####: 9182:bool    ImGui::BeginTabBar(const char* str_id, ImGuiTabBarFlags flags)
        -: 9183:{
    #####: 9184:    ImGuiContext& g = *GImGui;
    #####: 9185:    ImGuiWindow* window = g.CurrentWindow;
    #####: 9186:    if (window->SkipItems)
    %%%%%: 9186-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9187:        return false;
    %%%%%: 9187-block 3
        -: 9188:
    #####: 9189:    ImGuiID id = window->GetID(str_id);
    %%%%%: 9189-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 9190:    ImGuiTabBar* tab_bar = g.TabBars.GetOrAddByKey(id);
    %%%%%: 9190-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 9191:    ImRect tab_bar_bb = ImRect(window->DC.CursorPos.x, window->DC.CursorPos.y, window->WorkRect.Max.x, window->DC.CursorPos.y + g.FontSize + g.Style.FramePadding.y * 2);
    %%%%%: 9191-block 6
call    0 never executed
    #####: 9192:    tab_bar->ID = id;
    #####: 9193:    tab_bar->SeparatorMinX = tab_bar->BarRect.Min.x - IM_TRUNC(window->WindowPadding.x * 0.5f);
    #####: 9194:    tab_bar->SeparatorMaxX = tab_bar->BarRect.Max.x + IM_TRUNC(window->WindowPadding.x * 0.5f);
        -: 9195:    //if (g.NavWindow && IsWindowChildOf(g.NavWindow, window, false, false))
    #####: 9196:    flags |= ImGuiTabBarFlags_IsFocused;
    #####: 9197:    return BeginTabBarEx(tab_bar, tab_bar_bb, flags);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 9197-block 8
        -: 9198:}
        -: 9199:
function _ZN5ImGui13BeginTabBarExEP11ImGuiTabBarRK6ImRecti called 5380 returned 100% blocks executed 73%
     5380: 9200:bool    ImGui::BeginTabBarEx(ImGuiTabBar* tab_bar, const ImRect& tab_bar_bb, ImGuiTabBarFlags flags)
        -: 9201:{
     5380: 9202:    ImGuiContext& g = *GImGui;
     5380: 9203:    ImGuiWindow* window = g.CurrentWindow;
     5380: 9204:    if (window->SkipItems)
     5380: 9204-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    #####: 9205:        return false;
    %%%%%: 9205-block 3
        -: 9206:
    5380*: 9207:    IM_ASSERT(tab_bar->ID != 0);
     5380: 9207-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    %%%%%: 9207-block 5
call    2 never executed
     5380: 9208:    if ((flags & ImGuiTabBarFlags_DockNode) == 0)
     5380: 9208-block 6
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    #####: 9209:        PushOverrideID(tab_bar->ID);
    %%%%%: 9209-block 7
call    0 never executed
        -: 9210:
        -: 9211:    // Add to stack
     5380: 9212:    g.CurrentTabBarStack.push_back(GetTabBarRefFromTabBar(tab_bar));
     5380: 9212-block 8
call    0 returned 5380
branch  1 taken 5380 (fallthrough)
branch  2 taken 0 (throw)
     5380: 9212-block 9
call    3 returned 5380
branch  4 taken 5380 (fallthrough)
branch  5 taken 0 (throw)
    $$$$$: 9212-block 32
call    6 never executed
     5380: 9213:    g.CurrentTabBar = tab_bar;
     5380: 9214:    tab_bar->Window = window;
        -: 9215:
        -: 9216:    // Append with multiple BeginTabBar()/EndTabBar() pairs.
     5380: 9217:    tab_bar->BackupCursorPos = window->DC.CursorPos;
     5380: 9218:    if (tab_bar->CurrFrameVisible == g.FrameCount)
     5380: 9218-block 10
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
        -: 9219:    {
    #####: 9220:        window->DC.CursorPos = ImVec2(tab_bar->BarRect.Min.x, tab_bar->BarRect.Max.y + tab_bar->ItemSpacingY);
    %%%%%: 9220-block 11
call    0 never executed
    #####: 9221:        tab_bar->BeginCount++;
    #####: 9222:        return true;
        -: 9223:    }
        -: 9224:
        -: 9225:    // Ensure correct ordering when toggling ImGuiTabBarFlags_Reorderable flag, or when a new tab was added while being not reorderable
    5380*: 9226:    if ((flags & ImGuiTabBarFlags_Reorderable) != (tab_bar->Flags & ImGuiTabBarFlags_Reorderable) || (tab_bar->TabsAddedNew && !(flags & ImGuiTabBarFlags_Reorderable)))
     5380: 9226-block 13
branch  0 taken 5375 (fallthrough)
branch  1 taken 5
     5375: 9226-block 14
branch  2 taken 0 (fallthrough)
branch  3 taken 5375
    %%%%%: 9226-block 15
branch  4 never executed (fallthrough)
branch  5 never executed
        5: 9227:        if ((flags & ImGuiTabBarFlags_DockNode) == 0) // FIXME: TabBar with DockNode can now be hybrid
        5: 9227-block 16
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    #####: 9228:            ImQsort(tab_bar->Tabs.Data, tab_bar->Tabs.Size, sizeof(ImGuiTabItem), TabItemComparerByBeginOrder);
    %%%%%: 9228-block 17
call    0 never executed
     5380: 9229:    tab_bar->TabsAddedNew = false;
        -: 9230:
        -: 9231:    // Flags
     5380: 9232:    if ((flags & ImGuiTabBarFlags_FittingPolicyMask_) == 0)
     5380: 9232-block 18
branch  0 taken 5380 (fallthrough)
branch  1 taken 0
     5380: 9233:        flags |= ImGuiTabBarFlags_FittingPolicyDefault_;
     5380: 9233-block 19
        -: 9234:
     5380: 9235:    tab_bar->Flags = flags;
     5380: 9236:    tab_bar->BarRect = tab_bar_bb;
     5380: 9237:    tab_bar->WantLayout = true; // Layout will be done on the first call to ItemTab()
     5380: 9238:    tab_bar->PrevFrameVisible = tab_bar->CurrFrameVisible;
     5380: 9239:    tab_bar->CurrFrameVisible = g.FrameCount;
     5380: 9240:    tab_bar->PrevTabsContentsHeight = tab_bar->CurrTabsContentsHeight;
     5380: 9241:    tab_bar->CurrTabsContentsHeight = 0.0f;
     5380: 9242:    tab_bar->ItemSpacingY = g.Style.ItemSpacing.y;
     5380: 9243:    tab_bar->FramePadding = g.Style.FramePadding;
     5380: 9244:    tab_bar->TabsActiveCount = 0;
     5380: 9245:    tab_bar->LastTabItemIdx = -1;
     5380: 9246:    tab_bar->BeginCount = 1;
        -: 9247:
        -: 9248:    // Set cursor pos in a way which only be used in the off-chance the user erroneously submits item before BeginTabItem(): items will overlap
     5380: 9249:    window->DC.CursorPos = ImVec2(tab_bar->BarRect.Min.x, tab_bar->BarRect.Max.y + tab_bar->ItemSpacingY);
     5380: 9249-block 20
call    0 returned 5380
        -: 9250:
        -: 9251:    // Draw separator
        -: 9252:    // (it would be misleading to draw this in EndTabBar() suggesting that it may be drawn over tabs, as tab bar are appendable)
     5380: 9253:    const ImU32 col = GetColorU32((flags & ImGuiTabBarFlags_IsFocused) ? ImGuiCol_TabSelected : ImGuiCol_TabDimmedSelected);
branch  0 taken 1076 (fallthrough)
branch  1 taken 4304
     1076: 9253-block 22
     4304: 9253-block 23
     5380: 9253-block 24
call    2 returned 5380
     5380: 9254:    if (g.Style.TabBarBorderSize > 0.0f)
branch  0 taken 5380 (fallthrough)
branch  1 taken 0
        -: 9255:    {
     5380: 9256:        const float y = tab_bar->BarRect.Max.y;
     5380: 9257:        window->DrawList->AddRectFilled(ImVec2(tab_bar->SeparatorMinX, y - g.Style.TabBarBorderSize), ImVec2(tab_bar->SeparatorMaxX, y), col);
     5380: 9257-block 26
call    0 returned 5380
call    1 returned 5380
call    2 returned 5380
branch  3 taken 5380 (fallthrough)
branch  4 taken 0 (throw)
     5380: 9257-block 29
    $$$$$: 9257-block 33
        -: 9258:    }
     5380: 9259:    return true;
     5380: 9259-block 30
        -: 9260:}
        -: 9261:
function _ZN5ImGui9EndTabBarEv called 5380 returned 100% blocks executed 42%
     5380: 9262:void    ImGui::EndTabBar()
        -: 9263:{
     5380: 9264:    ImGuiContext& g = *GImGui;
     5380: 9265:    ImGuiWindow* window = g.CurrentWindow;
     5380: 9266:    if (window->SkipItems)
     5380: 9266-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    #####: 9267:        return;
    %%%%%: 9267-block 3
        -: 9268:
     5380: 9269:    ImGuiTabBar* tab_bar = g.CurrentTabBar;
     5380: 9270:    if (tab_bar == NULL)
     5380: 9270-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
        -: 9271:    {
    #####: 9272:        IM_ASSERT_USER_ERROR(tab_bar != NULL, "Mismatched BeginTabBar()/EndTabBar()!");
    %%%%%: 9272-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9272-block 6
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 9272-block 8
    %%%%%: 9272-block 9
    %%%%%: 9272-block 10
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 9272-block 11
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 9272-block 12
call    9 never executed
    #####: 9273:        return;
    %%%%%: 9273-block 13
        -: 9274:    }
        -: 9275:
        -: 9276:    // Fallback in case no TabItem have been submitted
     5380: 9277:    if (tab_bar->WantLayout)
     5380: 9277-block 14
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    #####: 9278:        TabBarLayout(tab_bar);
    %%%%%: 9278-block 15
call    0 never executed
        -: 9279:
        -: 9280:    // Restore the last visible height if no tab is visible, this reduce vertical flicker/movement when a tabs gets removed without calling SetTabItemClosed().
     5380: 9281:    const bool tab_bar_appearing = (tab_bar->PrevFrameVisible + 1 < g.FrameCount);
    5380*: 9282:    if (tab_bar->VisibleTabWasSubmitted || tab_bar->VisibleTabId == 0 || tab_bar_appearing)
     5380: 9282-block 16
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    %%%%%: 9282-block 17
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 9282-block 18
branch  4 never executed (fallthrough)
branch  5 never executed
        -: 9283:    {
     5380: 9284:        tab_bar->CurrTabsContentsHeight = ImMax(window->DC.CursorPos.y - tab_bar->BarRect.Max.y, tab_bar->CurrTabsContentsHeight);
     5380: 9284-block 19
call    0 returned 5380
     5380: 9285:        window->DC.CursorPos.y = tab_bar->BarRect.Max.y + tab_bar->CurrTabsContentsHeight;
        -: 9286:    }
        -: 9287:    else
        -: 9288:    {
    #####: 9289:        window->DC.CursorPos.y = tab_bar->BarRect.Max.y + tab_bar->PrevTabsContentsHeight;
    %%%%%: 9289-block 21
        -: 9290:    }
     5380: 9291:    if (tab_bar->BeginCount > 1)
     5380: 9291-block 22
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    #####: 9292:        window->DC.CursorPos = tab_bar->BackupCursorPos;
    %%%%%: 9292-block 23
        -: 9293:
     5380: 9294:    tab_bar->LastTabItemIdx = -1;
     5380: 9295:    if ((tab_bar->Flags & ImGuiTabBarFlags_DockNode) == 0)
     5380: 9295-block 24
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    #####: 9296:        PopID();
    %%%%%: 9296-block 25
call    0 never executed
        -: 9297:
     5380: 9298:    g.CurrentTabBarStack.pop_back();
     5380: 9298-block 26
call    0 returned 5380
    5380*: 9299:    g.CurrentTabBar = g.CurrentTabBarStack.empty() ? NULL : GetTabBarFromTabBarRef(g.CurrentTabBarStack.back());
call    0 returned 5380
branch  1 taken 5380 (fallthrough)
branch  2 taken 0
     5380: 9299-block 29
    %%%%%: 9299-block 30
call    3 never executed
call    4 never executed
     5380: 9299-block 33
        -: 9300:}
        -: 9301:
        -: 9302:// Scrolling happens only in the central section (leading/trailing sections are not scrolling)
function _ZL25TabBarCalcScrollableWidthP11ImGuiTabBarP18ImGuiTabBarSection called 5 returned 100% blocks executed 100%
        5: 9303:static float TabBarCalcScrollableWidth(ImGuiTabBar* tab_bar, ImGuiTabBarSection* sections)
        -: 9304:{
        5: 9305:    return tab_bar->BarRect.GetWidth() - sections[0].Width - sections[2].Width - sections[1].Spacing;
        5: 9305-block 2
call    0 returned 5
        -: 9306:}
        -: 9307:
        -: 9308:// This is called only once a frame before by the first call to ItemTab()
        -: 9309:// The reason we're not calling it in BeginTabBar() is to leave a chance to the user to call the SetTabItemClosed() functions.
function _ZN5ImGuiL12TabBarLayoutEP11ImGuiTabBar called 5380 returned 100% blocks executed 58%
     5380: 9310:static void ImGui::TabBarLayout(ImGuiTabBar* tab_bar)
        -: 9311:{
     5380: 9312:    ImGuiContext& g = *GImGui;
     5380: 9313:    tab_bar->WantLayout = false;
        -: 9314:
        -: 9315:    // Garbage collect by compacting list
        -: 9316:    // Detect if we need to sort out tab list (e.g. in rare case where a tab changed section)
     5380: 9317:    int tab_dst_n = 0;
     5380: 9318:    bool need_sort_by_section = false;
    21520: 9319:    ImGuiTabBarSection sections[3]; // Layout sections: Leading, Central, Trailing
     5380: 9319-block 2
    16140: 9319-block 3
call    0 returned 16140
    21520: 9319-block 5
branch  1 taken 16140
branch  2 taken 5380 (fallthrough)
    10760: 9320:    for (int tab_src_n = 0; tab_src_n < tab_bar->Tabs.Size; tab_src_n++)
     5380: 9320-block 6
     5380: 9320-block 33
    10760: 9320-block 34
branch  0 taken 5380
branch  1 taken 5380 (fallthrough)
        -: 9321:    {
     5380: 9322:        ImGuiTabItem* tab = &tab_bar->Tabs[tab_src_n];
     5380: 9322-block 7
call    0 returned 5380
    5380*: 9323:        if (tab->LastFrameVisible < tab_bar->PrevFrameVisible || tab->WantClose)
branch  0 taken 5380 (fallthrough)
branch  1 taken 0
     5380: 9323-block 9
branch  2 taken 0 (fallthrough)
branch  3 taken 5380
        -: 9324:        {
        -: 9325:            // Remove tab
    #####: 9326:            if (tab_bar->VisibleTabId == tab->ID) { tab_bar->VisibleTabId = 0; }
    %%%%%: 9326-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9326-block 11
    #####: 9327:            if (tab_bar->SelectedTabId == tab->ID) { tab_bar->SelectedTabId = 0; }
    %%%%%: 9327-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9327-block 13
    #####: 9328:            if (tab_bar->NextSelectedTabId == tab->ID) { tab_bar->NextSelectedTabId = 0; }
    %%%%%: 9328-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9328-block 15
    #####: 9329:            continue;
    %%%%%: 9329-block 16
        -: 9330:        }
     5380: 9331:        if (tab_dst_n != tab_src_n)
     5380: 9331-block 17
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    #####: 9332:            tab_bar->Tabs[tab_dst_n] = tab_bar->Tabs[tab_src_n];
    %%%%%: 9332-block 18
call    0 never executed
call    1 never executed
        -: 9333:
     5380: 9334:        tab = &tab_bar->Tabs[tab_dst_n];
     5380: 9334-block 21
call    0 returned 5380
     5380: 9335:        tab->IndexDuringLayout = (ImS16)tab_dst_n;
        -: 9336:
        -: 9337:        // We will need sorting if tabs have changed section (e.g. moved from one of Leading/Central/Trailing to another)
     5380: 9338:        int curr_tab_section_n = TabItemGetSectionIdx(tab);
call    0 returned 5380
     5380: 9339:        if (tab_dst_n > 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
        -: 9340:        {
    #####: 9341:            ImGuiTabItem* prev_tab = &tab_bar->Tabs[tab_dst_n - 1];
    %%%%%: 9341-block 24
call    0 never executed
    #####: 9342:            int prev_tab_section_n = TabItemGetSectionIdx(prev_tab);
call    0 never executed
    #####: 9343:            if (curr_tab_section_n == 0 && prev_tab_section_n != 0)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9343-block 27
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 9344:                need_sort_by_section = true;
    %%%%%: 9344-block 28
    #####: 9345:            if (prev_tab_section_n == 2 && curr_tab_section_n != 2)
    %%%%%: 9345-block 29
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9345-block 30
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 9346:                need_sort_by_section = true;
    %%%%%: 9346-block 31
        -: 9347:        }
        -: 9348:
     5380: 9349:        sections[curr_tab_section_n].TabCount++;
     5380: 9350:        tab_dst_n++;
     5380: 9350-block 32
        -: 9351:    }
     5380: 9352:    if (tab_bar->Tabs.Size != tab_dst_n)
     5380: 9352-block 35
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    #####: 9353:        tab_bar->Tabs.resize(tab_dst_n);
    %%%%%: 9353-block 36
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 9354:
     5380: 9355:    if (need_sort_by_section)
     5380: 9355-block 37
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    #####: 9356:        ImQsort(tab_bar->Tabs.Data, tab_bar->Tabs.Size, sizeof(ImGuiTabItem), TabItemComparerBySection);
    %%%%%: 9356-block 38
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 9357:
        -: 9358:    // Calculate spacing between sections
    5380*: 9359:    sections[0].Spacing = sections[0].TabCount > 0 && (sections[1].TabCount + sections[2].TabCount) > 0 ? g.Style.ItemInnerSpacing.x : 0.0f;
     5380: 9359-block 39
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    %%%%%: 9359-block 40
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 9359-block 41
     5380: 9359-block 42
    5380*: 9360:    sections[1].Spacing = sections[1].TabCount > 0 && sections[2].TabCount > 0 ? g.Style.ItemInnerSpacing.x : 0.0f;
     5380: 9360-block 43
branch  0 taken 5380 (fallthrough)
branch  1 taken 0
     5380: 9360-block 44
branch  2 taken 0 (fallthrough)
branch  3 taken 5380
    %%%%%: 9360-block 45
     5380: 9360-block 46
        -: 9361:
        -: 9362:    // Setup next selected tab
     5380: 9363:    ImGuiID scroll_to_tab_id = 0;
     5380: 9364:    if (tab_bar->NextSelectedTabId)
     5380: 9364-block 47
branch  0 taken 5 (fallthrough)
branch  1 taken 5375
        -: 9365:    {
        5: 9366:        tab_bar->SelectedTabId = tab_bar->NextSelectedTabId;
        5: 9367:        tab_bar->NextSelectedTabId = 0;
        5: 9368:        scroll_to_tab_id = tab_bar->SelectedTabId;
        5: 9368-block 48
        -: 9369:    }
        -: 9370:
        -: 9371:    // Process order change request (we could probably process it when requested but it's just saner to do it in a single spot).
     5380: 9372:    if (tab_bar->ReorderRequestTabId != 0)
     5380: 9372-block 49
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
        -: 9373:    {
    #####: 9374:        if (TabBarProcessReorder(tab_bar))
    %%%%%: 9374-block 50
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 9374-block 51
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 9375:            if (tab_bar->ReorderRequestTabId == tab_bar->SelectedTabId)
    %%%%%: 9375-block 52
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9376:                scroll_to_tab_id = tab_bar->ReorderRequestTabId;
    %%%%%: 9376-block 53
    #####: 9377:        tab_bar->ReorderRequestTabId = 0;
    %%%%%: 9377-block 54
        -: 9378:    }
        -: 9379:
        -: 9380:    // Tab List Popup (will alter tab_bar->BarRect and therefore the available width!)
     5380: 9381:    const bool tab_list_popup_button = (tab_bar->Flags & ImGuiTabBarFlags_TabListPopupButton) != 0;
     5380: 9382:    if (tab_list_popup_button)
     5380: 9382-block 55
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    #####: 9383:        if (ImGuiTabItem* tab_to_select = TabBarTabListPopupButton(tab_bar)) // NB: Will alter BarRect.Min.x!
    %%%%%: 9383-block 56
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 9383-block 57
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 9384:            scroll_to_tab_id = tab_bar->SelectedTabId = tab_to_select->ID;
    %%%%%: 9384-block 58
        -: 9385:
        -: 9386:    // Leading/Trailing tabs will be shrink only if central one aren't visible anymore, so layout the shrink data as: leading, trailing, central
        -: 9387:    // (whereas our tabs are stored as: leading, central, trailing)
     5380: 9388:    int shrink_buffer_indexes[3] = { 0, sections[0].TabCount + sections[2].TabCount, sections[0].TabCount };
     5380: 9389:    g.ShrinkWidthBuffer.resize(tab_bar->Tabs.Size);
     5380: 9389-block 59
call    0 returned 5380
branch  1 taken 5380 (fallthrough)
branch  2 taken 0 (throw)
        -: 9390:
        -: 9391:    // Compute ideal tabs widths + store them into shrink buffer
     5380: 9392:    ImGuiTabItem* most_recently_selected_tab = NULL;
     5380: 9393:    int curr_section_n = -1;
     5380: 9394:    bool found_selected_tab_id = false;
    10760: 9395:    for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)
     5380: 9395-block 60
    10760: 9395-block 89
branch  0 taken 5380
branch  1 taken 5380 (fallthrough)
        -: 9396:    {
     5380: 9397:        ImGuiTabItem* tab = &tab_bar->Tabs[tab_n];
     5380: 9397-block 61
call    0 returned 5380
    5380*: 9398:        IM_ASSERT(tab->LastFrameVisible >= tab_bar->PrevFrameVisible);
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    %%%%%: 9398-block 63
call    2 never executed
        -: 9399:
    5380*: 9400:        if ((most_recently_selected_tab == NULL || most_recently_selected_tab->LastFrameSelected < tab->LastFrameSelected) && !(tab->Flags & ImGuiTabItemFlags_Button))
     5380: 9400-block 64
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    %%%%%: 9400-block 65
branch  2 never executed (fallthrough)
branch  3 never executed
     5380: 9400-block 66
branch  4 taken 5380 (fallthrough)
branch  5 taken 0
     5380: 9401:            most_recently_selected_tab = tab;
     5380: 9401-block 67
     5380: 9402:        if (tab->ID == tab_bar->SelectedTabId)
     5380: 9402-block 68
branch  0 taken 5380 (fallthrough)
branch  1 taken 0
     5380: 9403:            found_selected_tab_id = true;
     5380: 9403-block 69
     5380: 9404:        if (scroll_to_tab_id == 0 && g.NavJustMovedToId == tab->ID)
     5380: 9404-block 70
branch  0 taken 5375 (fallthrough)
branch  1 taken 5
     5375: 9404-block 71
branch  2 taken 0 (fallthrough)
branch  3 taken 5375
    #####: 9405:            scroll_to_tab_id = tab->ID;
    %%%%%: 9405-block 72
        -: 9406:
        -: 9407:        // Refresh tab width immediately, otherwise changes of style e.g. style.FramePadding.x would noticeably lag in the tab bar.
        -: 9408:        // Additionally, when using TabBarAddTab() to manipulate tab bar order we occasionally insert new tabs that don't have a width yet,
        -: 9409:        // and we cannot wait for the next BeginTabItem() call. We cannot compute this width within TabBarAddTab() because font size depends on the active window.
     5380: 9410:        const char* tab_name = TabBarGetTabName(tab_bar, tab);
     5380: 9410-block 73
call    0 returned 5380
     5380: 9411:        const bool has_close_button_or_unsaved_marker = (tab->Flags & ImGuiTabItemFlags_NoCloseButton) == 0 || (tab->Flags & ImGuiTabItemFlags_UnsavedDocument);
branch  0 taken 5 (fallthrough)
branch  1 taken 5375
        5: 9411-block 75
branch  2 taken 0 (fallthrough)
branch  3 taken 5
     5375: 9411-block 76
        5: 9411-block 77
    5380*: 9412:        tab->ContentWidth = (tab->RequestedWidth >= 0.0f) ? tab->RequestedWidth : TabItemCalcSize(tab_name, has_close_button_or_unsaved_marker).x;
     5380: 9412-block 78
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    %%%%%: 9412-block 79
     5380: 9412-block 80
call    2 returned 5380
branch  3 taken 5380 (fallthrough)
branch  4 taken 0 (throw)
     5380: 9412-block 81
        -: 9413:
     5380: 9414:        int section_n = TabItemGetSectionIdx(tab);
     5380: 9414-block 82
call    0 returned 5380
     5380: 9415:        ImGuiTabBarSection* section = &sections[section_n];
    5380*: 9416:        section->Width += tab->ContentWidth + (section_n == curr_section_n ? g.Style.ItemInnerSpacing.x : 0.0f);
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    %%%%%: 9416-block 84
     5380: 9416-block 85
     5380: 9417:        curr_section_n = section_n;
        -: 9418:
        -: 9419:        // Store data so we can build an array sorted by width if we need to shrink tabs down
        -: 9420:        IM_MSVC_WARNING_SUPPRESS(6385);
     5380: 9421:        ImGuiShrinkWidthItem* shrink_width_item = &g.ShrinkWidthBuffer[shrink_buffer_indexes[section_n]++];
     5380: 9421-block 86
call    0 returned 5380
     5380: 9422:        shrink_width_item->Index = tab_n;
     5380: 9423:        shrink_width_item->Width = shrink_width_item->InitialWidth = tab->ContentWidth;
     5380: 9424:        tab->Width = ImMax(tab->ContentWidth, 1.0f);
call    0 returned 5380
        -: 9425:    }
        -: 9426:
        -: 9427:    // Compute total ideal width (used for e.g. auto-resizing a window)
     5380: 9428:    tab_bar->WidthAllTabsIdeal = 0.0f;
    21520: 9429:    for (int section_n = 0; section_n < 3; section_n++)
     5380: 9429-block 90
    21520: 9429-block 92
branch  0 taken 16140
branch  1 taken 5380 (fallthrough)
    16140: 9430:        tab_bar->WidthAllTabsIdeal += sections[section_n].Width + sections[section_n].Spacing;
    16140: 9430-block 91
        -: 9431:
        -: 9432:    // Horizontal scrolling buttons
        -: 9433:    // (note that TabBarScrollButtons() will alter BarRect.Max.x)
    5380*: 9434:    if ((tab_bar->WidthAllTabsIdeal > tab_bar->BarRect.GetWidth() && tab_bar->Tabs.Size > 1) && !(tab_bar->Flags & ImGuiTabBarFlags_NoTabListScrollingButtons) && (tab_bar->Flags & ImGuiTabBarFlags_FittingPolicyScroll))
     5380: 9434-block 93
call    0 returned 5380
branch  1 taken 2152 (fallthrough)
branch  2 taken 3228
     2152: 9434-block 95
branch  3 taken 0 (fallthrough)
branch  4 taken 2152
    %%%%%: 9434-block 96
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 9434-block 97
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 9434-block 98
     5380: 9434-block 99
     5380: 9434-block 100
branch  9 taken 0 (fallthrough)
branch 10 taken 5380
    #####: 9435:        if (ImGuiTabItem* scroll_and_select_tab = TabBarScrollingButtons(tab_bar))
    %%%%%: 9435-block 101
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 9435-block 102
branch  3 never executed (fallthrough)
branch  4 never executed
        -: 9436:        {
    #####: 9437:            scroll_to_tab_id = scroll_and_select_tab->ID;
    #####: 9438:            if ((scroll_and_select_tab->Flags & ImGuiTabItemFlags_Button) == 0)
    %%%%%: 9438-block 103
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9439:                tab_bar->SelectedTabId = scroll_to_tab_id;
    %%%%%: 9439-block 104
        -: 9440:        }
        -: 9441:
        -: 9442:    // Shrink widths if full tabs don't fit in their allocated space
     5380: 9443:    float section_0_w = sections[0].Width + sections[0].Spacing;
     5380: 9444:    float section_1_w = sections[1].Width + sections[1].Spacing;
     5380: 9445:    float section_2_w = sections[2].Width + sections[2].Spacing;
     5380: 9446:    bool central_section_is_visible = (section_0_w + section_2_w) < tab_bar->BarRect.GetWidth();
     5380: 9446-block 105
call    0 returned 5380
        -: 9447:    float width_excess;
     5380: 9448:    if (central_section_is_visible)
branch  0 taken 4304 (fallthrough)
branch  1 taken 1076
     4304: 9449:        width_excess = ImMax(section_1_w - (tab_bar->BarRect.GetWidth() - section_0_w - section_2_w), 0.0f); // Excess used to shrink central section
     4304: 9449-block 107
call    0 returned 4304
call    1 returned 4304
        -: 9450:    else
     1076: 9451:        width_excess = (section_0_w + section_2_w) - tab_bar->BarRect.GetWidth(); // Excess used to shrink leading/trailing section
     1076: 9451-block 109
call    0 returned 1076
        -: 9452:
        -: 9453:    // With ImGuiTabBarFlags_FittingPolicyScroll policy, we will only shrink leading/trailing if the central section is not visible anymore
    5380*: 9454:    if (width_excess >= 1.0f && ((tab_bar->Flags & ImGuiTabBarFlags_FittingPolicyResizeDown) || !central_section_is_visible))
     5380: 9454-block 111
branch  0 taken 2152 (fallthrough)
branch  1 taken 3228
     2152: 9454-block 112
branch  2 taken 0 (fallthrough)
branch  3 taken 2152
    %%%%%: 9454-block 113
branch  4 never executed (fallthrough)
branch  5 never executed
        -: 9455:    {
     2152: 9456:        int shrink_data_count = (central_section_is_visible ? sections[1].TabCount : sections[0].TabCount + sections[2].TabCount);
     2152: 9456-block 114
branch  0 taken 1076 (fallthrough)
branch  1 taken 1076
     1076: 9456-block 115
     1076: 9456-block 116
     2152: 9457:        int shrink_data_offset = (central_section_is_visible ? sections[0].TabCount + sections[2].TabCount : 0);
     2152: 9457-block 117
branch  0 taken 1076 (fallthrough)
branch  1 taken 1076
     1076: 9457-block 118
     1076: 9457-block 119
     2152: 9458:        ShrinkWidths(g.ShrinkWidthBuffer.Data + shrink_data_offset, shrink_data_count, width_excess);
     2152: 9458-block 120
call    0 returned 2152
branch  1 taken 2152 (fallthrough)
branch  2 taken 0 (throw)
        -: 9459:
        -: 9460:        // Apply shrunk values into tabs and sections
     3228: 9461:        for (int tab_n = shrink_data_offset; tab_n < shrink_data_offset + shrink_data_count; tab_n++)
     2152: 9461-block 121
     1076: 9461-block 130
     3228: 9461-block 131
branch  0 taken 1076
branch  1 taken 2152 (fallthrough)
        -: 9462:        {
     1076: 9463:            ImGuiTabItem* tab = &tab_bar->Tabs[g.ShrinkWidthBuffer[tab_n].Index];
     1076: 9463-block 122
call    0 returned 1076
call    1 returned 1076
     1076: 9464:            float shrinked_width = IM_TRUNC(g.ShrinkWidthBuffer[tab_n].Width);
call    0 returned 1076
    1076*: 9465:            if (shrinked_width < 0.0f)
branch  0 taken 0 (fallthrough)
branch  1 taken 1076
    #####: 9466:                continue;
    %%%%%: 9466-block 126
        -: 9467:
     1076: 9468:            shrinked_width = ImMax(1.0f, shrinked_width);
     1076: 9468-block 127
call    0 returned 1076
     1076: 9469:            int section_n = TabItemGetSectionIdx(tab);
call    0 returned 1076
     1076: 9470:            sections[section_n].Width -= (tab->Width - shrinked_width);
     1076: 9471:            tab->Width = shrinked_width;
        -: 9472:        }
        -: 9473:    }
        -: 9474:
        -: 9475:    // Layout all active tabs
     5380: 9476:    int section_tab_index = 0;
     5380: 9477:    float tab_offset = 0.0f;
     5380: 9478:    tab_bar->WidthAllTabs = 0.0f;
    21520: 9479:    for (int section_n = 0; section_n < 3; section_n++)
     5380: 9479-block 132
    21520: 9479-block 146
branch  0 taken 16140
branch  1 taken 5380 (fallthrough)
        -: 9480:    {
    16140: 9481:        ImGuiTabBarSection* section = &sections[section_n];
    16140: 9482:        if (section_n == 2)
    16140: 9482-block 133
branch  0 taken 5380 (fallthrough)
branch  1 taken 10760
     5380: 9483:            tab_offset = ImMin(ImMax(0.0f, tab_bar->BarRect.GetWidth() - section->Width), tab_offset);
     5380: 9483-block 134
call    0 returned 5380
call    1 returned 5380
call    2 returned 5380
        -: 9484:
    21520: 9485:        for (int tab_n = 0; tab_n < section->TabCount; tab_n++)
    16140: 9485-block 137
    21520: 9485-block 143
branch  0 taken 5380
branch  1 taken 16140 (fallthrough)
        -: 9486:        {
     5380: 9487:            ImGuiTabItem* tab = &tab_bar->Tabs[section_tab_index + tab_n];
     5380: 9487-block 138
call    0 returned 5380
     5380: 9488:            tab->Offset = tab_offset;
     5380: 9489:            tab->NameOffset = -1;
    5380*: 9490:            tab_offset += tab->Width + (tab_n < section->TabCount - 1 ? g.Style.ItemInnerSpacing.x : 0.0f);
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    %%%%%: 9490-block 140
     5380: 9490-block 141
     5380: 9490-block 142
        -: 9491:        }
    16140: 9492:        tab_bar->WidthAllTabs += ImMax(section->Width + section->Spacing, 0.0f);
    16140: 9492-block 144
call    0 returned 16140
    16140: 9493:        tab_offset += section->Spacing;
    16140: 9494:        section_tab_index += section->TabCount;
        -: 9495:    }
        -: 9496:
        -: 9497:    // Clear name buffers
     5380: 9498:    tab_bar->TabsNames.Buf.resize(0);
     5380: 9498-block 147
call    0 returned 5380
branch  1 taken 5380 (fallthrough)
branch  2 taken 0 (throw)
        -: 9499:
        -: 9500:    // If we have lost the selected tab, select the next most recently active one
     5380: 9501:    if (found_selected_tab_id == false)
     5380: 9501-block 148
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    #####: 9502:        tab_bar->SelectedTabId = 0;
    %%%%%: 9502-block 149
    5380*: 9503:    if (tab_bar->SelectedTabId == 0 && tab_bar->NextSelectedTabId == 0 && most_recently_selected_tab != NULL)
     5380: 9503-block 150
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    %%%%%: 9503-block 151
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 9503-block 152
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 9504:        scroll_to_tab_id = tab_bar->SelectedTabId = most_recently_selected_tab->ID;
    %%%%%: 9504-block 153
        -: 9505:
        -: 9506:    // Lock in visible tab
     5380: 9507:    tab_bar->VisibleTabId = tab_bar->SelectedTabId;
     5380: 9508:    tab_bar->VisibleTabWasSubmitted = false;
        -: 9509:
        -: 9510:    // CTRL+TAB can override visible tab temporarily
    5380*: 9511:    if (g.NavWindowingTarget != NULL && g.NavWindowingTarget->DockNode && g.NavWindowingTarget->DockNode->TabBar == tab_bar)
     5380: 9511-block 154
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    %%%%%: 9511-block 155
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 9511-block 156
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 9512:        tab_bar->VisibleTabId = scroll_to_tab_id = g.NavWindowingTarget->TabId;
    %%%%%: 9512-block 157
        -: 9513:
        -: 9514:    // Apply request requests
     5380: 9515:    if (scroll_to_tab_id != 0)
     5380: 9515-block 158
branch  0 taken 5 (fallthrough)
branch  1 taken 5375
        5: 9516:        TabBarScrollToTab(tab_bar, scroll_to_tab_id, sections);
        5: 9516-block 159
call    0 returned 5
branch  1 taken 5 (fallthrough)
branch  2 taken 0 (throw)
    5375*: 9517:    else if ((tab_bar->Flags & ImGuiTabBarFlags_FittingPolicyScroll) && IsMouseHoveringRect(tab_bar->BarRect.Min, tab_bar->BarRect.Max, true) && IsWindowContentHoverable(g.CurrentWindow))
     5375: 9517-block 160
branch  0 taken 0 (fallthrough)
branch  1 taken 5375
    %%%%%: 9517-block 161
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 9517-block 162
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 9517-block 163
call    7 never executed
branch  8 never executed (fallthrough)
branch  9 never executed (throw)
    %%%%%: 9517-block 164
branch 10 never executed (fallthrough)
branch 11 never executed
    %%%%%: 9517-block 165
     5375: 9517-block 166
     5375: 9517-block 167
branch 12 taken 0 (fallthrough)
branch 13 taken 5375
        -: 9518:    {
    #####: 9519:        const float wheel = g.IO.MouseWheelRequestAxisSwap ? g.IO.MouseWheel : g.IO.MouseWheelH;
    %%%%%: 9519-block 168
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9519-block 169
    %%%%%: 9519-block 170
    #####: 9520:        const ImGuiKey wheel_key = g.IO.MouseWheelRequestAxisSwap ? ImGuiKey_MouseWheelY : ImGuiKey_MouseWheelX;
    %%%%%: 9520-block 171
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9520-block 172
    %%%%%: 9520-block 173
    #####: 9521:        if (TestKeyOwner(wheel_key, tab_bar->ID) && wheel != 0.0f)
    %%%%%: 9521-block 174
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 9521-block 175
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 9521-block 176
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 9521-block 177
    %%%%%: 9521-block 178
    %%%%%: 9521-block 179
branch  7 never executed (fallthrough)
branch  8 never executed
        -: 9522:        {
    #####: 9523:            const float scroll_step = wheel * TabBarCalcScrollableWidth(tab_bar, sections) / 3.0f;
    %%%%%: 9523-block 180
call    0 never executed
    #####: 9524:            tab_bar->ScrollingTargetDistToVisibility = 0.0f;
    #####: 9525:            tab_bar->ScrollingTarget = TabBarScrollClamp(tab_bar, tab_bar->ScrollingTarget - scroll_step);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 9525-block 182
        -: 9526:        }
    #####: 9527:        SetKeyOwner(wheel_key, tab_bar->ID);
    %%%%%: 9527-block 183
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 9528:    }
        -: 9529:
        -: 9530:    // Update scrolling
     5380: 9531:    tab_bar->ScrollingAnim = TabBarScrollClamp(tab_bar, tab_bar->ScrollingAnim);
     5380: 9531-block 184
call    0 returned 5380
branch  1 taken 5380 (fallthrough)
branch  2 taken 0 (throw)
     5380: 9532:    tab_bar->ScrollingTarget = TabBarScrollClamp(tab_bar, tab_bar->ScrollingTarget);
     5380: 9532-block 185
call    0 returned 5380
branch  1 taken 5380 (fallthrough)
branch  2 taken 0 (throw)
     5380: 9533:    if (tab_bar->ScrollingAnim != tab_bar->ScrollingTarget)
     5380: 9533-block 186
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
        -: 9534:    {
        -: 9535:        // Scrolling speed adjust itself so we can always reach our target in 1/3 seconds.
        -: 9536:        // Teleport if we are aiming far off the visible line
    #####: 9537:        tab_bar->ScrollingSpeed = ImMax(tab_bar->ScrollingSpeed, 70.0f * g.FontSize);
    %%%%%: 9537-block 187
call    0 never executed
    #####: 9538:        tab_bar->ScrollingSpeed = ImMax(tab_bar->ScrollingSpeed, ImFabs(tab_bar->ScrollingTarget - tab_bar->ScrollingAnim) / 0.3f);
call    0 never executed
    #####: 9539:        const bool teleport = (tab_bar->PrevFrameVisible + 1 < g.FrameCount) || (tab_bar->ScrollingTargetDistToVisibility > 10.0f * g.FontSize);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9539-block 190
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 9539-block 191
    %%%%%: 9539-block 192
    #####: 9540:        tab_bar->ScrollingAnim = teleport ? tab_bar->ScrollingTarget : ImLinearSweep(tab_bar->ScrollingAnim, tab_bar->ScrollingTarget, g.IO.DeltaTime * tab_bar->ScrollingSpeed);
    %%%%%: 9540-block 193
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9540-block 194
    %%%%%: 9540-block 195
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 9540-block 196
    %%%%%: 9540-block 197
        -: 9541:    }
        -: 9542:    else
        -: 9543:    {
     5380: 9544:        tab_bar->ScrollingSpeed = 0.0f;
     5380: 9544-block 198
        -: 9545:    }
     5380: 9546:    tab_bar->ScrollingRectMinX = tab_bar->BarRect.Min.x + sections[0].Width + sections[0].Spacing;
     5380: 9547:    tab_bar->ScrollingRectMaxX = tab_bar->BarRect.Max.x - sections[2].Width - sections[1].Spacing;
        -: 9548:
        -: 9549:    // Actual layout in host window (we don't do it in BeginTabBar() so as not to waste an extra frame)
     5380: 9550:    ImGuiWindow* window = g.CurrentWindow;
     5380: 9551:    window->DC.CursorPos = tab_bar->BarRect.Min;
     5380: 9552:    ItemSize(ImVec2(tab_bar->WidthAllTabs, tab_bar->BarRect.GetHeight()), tab_bar->FramePadding.y);
     5380: 9552-block 199
call    0 returned 5380
call    1 returned 5380
call    2 returned 5380
branch  3 taken 5380 (fallthrough)
branch  4 taken 0 (throw)
    $$$$$: 9552-block 204
     5380: 9553:    window->DC.IdealMaxPos.x = ImMax(window->DC.IdealMaxPos.x, tab_bar->BarRect.Min.x + tab_bar->WidthAllTabsIdeal);
     5380: 9553-block 202
call    0 returned 5380
     5380: 9554:}
        -: 9555:
        -: 9556:// Dockable windows uses Name/ID in the global namespace. Non-dockable items use the ID stack.
function _ZN5ImGuiL15TabBarCalcTabIDEP11ImGuiTabBarPKcP11ImGuiWindow called 5380 returned 100% blocks executed 62%
     5380: 9557:static ImU32   ImGui::TabBarCalcTabID(ImGuiTabBar* tab_bar, const char* label, ImGuiWindow* docked_window)
        -: 9558:{
     5380: 9559:    if (docked_window != NULL)
     5380: 9559-block 2
branch  0 taken 5380 (fallthrough)
branch  1 taken 0
        -: 9560:    {
        -: 9561:        IM_UNUSED(tab_bar);
    5380*: 9562:        IM_ASSERT(tab_bar->Flags & ImGuiTabBarFlags_DockNode);
     5380: 9562-block 3
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    %%%%%: 9562-block 4
call    2 never executed
     5380: 9563:        ImGuiID id = docked_window->TabId;
     5380: 9564:        KeepAliveID(id);
     5380: 9564-block 5
call    0 returned 5380
     5380: 9565:        return id;
        -: 9566:    }
        -: 9567:    else
        -: 9568:    {
    #####: 9569:        ImGuiWindow* window = GImGui->CurrentWindow;
    #####: 9570:        return window->GetID(label);
    %%%%%: 9570-block 7
call    0 never executed
        -: 9571:    }
        -: 9572:}
        -: 9573:
function _ZN5ImGuiL21TabBarCalcMaxTabWidthEv called 10760 returned 100% blocks executed 100%
    10760: 9574:static float ImGui::TabBarCalcMaxTabWidth()
        -: 9575:{
    10760: 9576:    ImGuiContext& g = *GImGui;
    10760: 9577:    return g.FontSize * 20.0f;
    10760: 9577-block 2
        -: 9578:}
        -: 9579:
function _ZN5ImGui17TabBarFindTabByIDEP11ImGuiTabBarj called 16150 returned 100% blocks executed 89%
    16150: 9580:ImGuiTabItem* ImGui::TabBarFindTabByID(ImGuiTabBar* tab_bar, ImGuiID tab_id)
        -: 9581:{
    16150: 9582:    if (tab_id != 0)
    16150: 9582-block 2
branch  0 taken 16150 (fallthrough)
branch  1 taken 0
   16150*: 9583:        for (int n = 0; n < tab_bar->Tabs.Size; n++)
    16150: 9583-block 3
    %%%%%: 9583-block 7
    16150: 9583-block 8
branch  0 taken 16145
branch  1 taken 5 (fallthrough)
    16145: 9584:            if (tab_bar->Tabs[n].ID == tab_id)
    16145: 9584-block 4
call    0 returned 16145
branch  1 taken 16145 (fallthrough)
branch  2 taken 0
    16145: 9585:                return &tab_bar->Tabs[n];
    16145: 9585-block 6
call    0 returned 16145
        5: 9586:    return NULL;
        5: 9586-block 9
        -: 9587:}
        -: 9588:
        -: 9589:// Order = visible order, not submission order! (which is tab->BeginOrder)
function _ZN5ImGui20TabBarFindTabByOrderEP11ImGuiTabBari called 0 returned 0% blocks executed 0%
    #####: 9590:ImGuiTabItem* ImGui::TabBarFindTabByOrder(ImGuiTabBar* tab_bar, int order)
        -: 9591:{
    #####: 9592:    if (order < 0 || order >= tab_bar->Tabs.Size)
    %%%%%: 9592-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9592-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 9593:        return NULL;
    %%%%%: 9593-block 4
    #####: 9594:    return &tab_bar->Tabs[order];
    %%%%%: 9594-block 5
call    0 never executed
        -: 9595:}
        -: 9596:
        -: 9597:// FIXME: See references to #2304 in TODO.txt
function _ZN5ImGui48TabBarFindMostRecentlySelectedTabForActiveWindowEP11ImGuiTabBar called 0 returned 0% blocks executed 0%
    #####: 9598:ImGuiTabItem* ImGui::TabBarFindMostRecentlySelectedTabForActiveWindow(ImGuiTabBar* tab_bar)
        -: 9599:{
    #####: 9600:    ImGuiTabItem* most_recently_selected_tab = NULL;
    #####: 9601:    for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)
    %%%%%: 9601-block 2
    %%%%%: 9601-block 9
    %%%%%: 9601-block 10
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 9602:    {
    #####: 9603:        ImGuiTabItem* tab = &tab_bar->Tabs[tab_n];
    %%%%%: 9603-block 3
call    0 never executed
    #####: 9604:        if (most_recently_selected_tab == NULL || most_recently_selected_tab->LastFrameSelected < tab->LastFrameSelected)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9604-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 9605:            if (tab->Window && tab->Window->WasActive)
    %%%%%: 9605-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9605-block 7
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 9606:                most_recently_selected_tab = tab;
    %%%%%: 9606-block 8
        -: 9607:    }
    #####: 9608:    return most_recently_selected_tab;
    %%%%%: 9608-block 11
        -: 9609:}
        -: 9610:
function _ZN5ImGui19TabBarGetCurrentTabEP11ImGuiTabBar called 0 returned 0% blocks executed 0%
    #####: 9611:ImGuiTabItem* ImGui::TabBarGetCurrentTab(ImGuiTabBar* tab_bar)
        -: 9612:{
    #####: 9613:    if (tab_bar->LastTabItemIdx < 0 || tab_bar->LastTabItemIdx >= tab_bar->Tabs.Size)
    %%%%%: 9613-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9613-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 9614:        return NULL;
    %%%%%: 9614-block 4
    #####: 9615:    return &tab_bar->Tabs[tab_bar->LastTabItemIdx];
    %%%%%: 9615-block 5
call    0 never executed
        -: 9616:}
        -: 9617:
function _ZN5ImGui16TabBarGetTabNameEP11ImGuiTabBarP12ImGuiTabItem called 5380 returned 100% blocks executed 38%
     5380: 9618:const char* ImGui::TabBarGetTabName(ImGuiTabBar* tab_bar, ImGuiTabItem* tab)
        -: 9619:{
     5380: 9620:    if (tab->Window)
     5380: 9620-block 2
branch  0 taken 5380 (fallthrough)
branch  1 taken 0
     5380: 9621:        return tab->Window->Name;
     5380: 9621-block 3
    #####: 9622:    if (tab->NameOffset == -1)
    %%%%%: 9622-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9623:        return "N/A";
    %%%%%: 9623-block 5
    #####: 9624:    IM_ASSERT(tab->NameOffset < tab_bar->TabsNames.Buf.Size);
    %%%%%: 9624-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9624-block 7
call    2 never executed
    #####: 9625:    return tab_bar->TabsNames.Buf.Data + tab->NameOffset;
    %%%%%: 9625-block 8
        -: 9626:}
        -: 9627:
        -: 9628:// The purpose of this call is to register tab in advance so we can control their order at the time they appear.
        -: 9629:// Otherwise calling this is unnecessary as tabs are appending as needed by the BeginTabItem() function.
function _ZN5ImGui12TabBarAddTabEP11ImGuiTabBariP11ImGuiWindow called 5 returned 100% blocks executed 85%
        5: 9630:void ImGui::TabBarAddTab(ImGuiTabBar* tab_bar, ImGuiTabItemFlags tab_flags, ImGuiWindow* window)
        -: 9631:{
        5: 9632:    ImGuiContext& g = *GImGui;
       5*: 9633:    IM_ASSERT(TabBarFindTabByID(tab_bar, window->TabId) == NULL);
        5: 9633-block 2
call    0 returned 5
branch  1 taken 5 (fallthrough)
branch  2 taken 0 (throw)
        5: 9633-block 3
branch  3 taken 0 (fallthrough)
branch  4 taken 5
    %%%%%: 9633-block 4
call    5 never executed
       5*: 9634:    IM_ASSERT(g.CurrentTabBar != tab_bar);  // Can't work while the tab bar is active as our tab doesn't have an X offset yet, in theory we could/should test something like (tab_bar->CurrFrameVisible < g.FrameCount) but we'd need to solve why triggers the commented early-out assert in BeginTabBarEx() (probably dock node going from implicit to explicit in same frame)
        5: 9634-block 5
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    %%%%%: 9634-block 6
call    2 never executed
        -: 9635:
        5: 9636:    if (!window->HasCloseButton)
        5: 9636-block 7
branch  0 taken 5 (fallthrough)
branch  1 taken 0
        5: 9637:        tab_flags |= ImGuiTabItemFlags_NoCloseButton;       // Set _NoCloseButton immediately because it will be used for first-frame width calculation.
        5: 9637-block 8
        -: 9638:
        5: 9639:    ImGuiTabItem new_tab;
        5: 9639-block 9
call    0 returned 5
        5: 9640:    new_tab.ID = window->TabId;
        5: 9641:    new_tab.Flags = tab_flags;
        5: 9642:    new_tab.LastFrameVisible = tab_bar->CurrFrameVisible;   // Required so BeginTabBar() doesn't ditch the tab
        5: 9643:    if (new_tab.LastFrameVisible == -1)
branch  0 taken 5 (fallthrough)
branch  1 taken 0
        5: 9644:        new_tab.LastFrameVisible = g.FrameCount - 1;
        5: 9644-block 11
        5: 9645:    new_tab.Window = window;                                // Required so tab bar layout can compute the tab width before tab submission
        5: 9646:    tab_bar->Tabs.push_back(new_tab);
        5: 9646-block 12
call    0 returned 5
branch  1 taken 5 (fallthrough)
branch  2 taken 0 (throw)
        5: 9647:}
        5: 9647-block 13
        -: 9648:
        -: 9649:// The *TabId fields are already set by the docking system _before_ the actual TabItem was created, so we clear them regardless.
function _ZN5ImGui15TabBarRemoveTabEP11ImGuiTabBarj called 0 returned 0% blocks executed 0%
    #####: 9650:void ImGui::TabBarRemoveTab(ImGuiTabBar* tab_bar, ImGuiID tab_id)
        -: 9651:{
    #####: 9652:    if (ImGuiTabItem* tab = TabBarFindTabByID(tab_bar, tab_id))
    %%%%%: 9652-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 9653:        tab_bar->Tabs.erase(tab);
    %%%%%: 9653-block 4
call    0 never executed
    #####: 9654:    if (tab_bar->VisibleTabId == tab_id)      { tab_bar->VisibleTabId = 0; }
    %%%%%: 9654-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9654-block 6
    #####: 9655:    if (tab_bar->SelectedTabId == tab_id)     { tab_bar->SelectedTabId = 0; }
    %%%%%: 9655-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9655-block 8
    #####: 9656:    if (tab_bar->NextSelectedTabId == tab_id) { tab_bar->NextSelectedTabId = 0; }
    %%%%%: 9656-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9656-block 10
    #####: 9657:}
        -: 9658:
        -: 9659:// Called on manual closure attempt
function _ZN5ImGui14TabBarCloseTabEP11ImGuiTabBarP12ImGuiTabItem called 0 returned 0% blocks executed 0%
    #####: 9660:void ImGui::TabBarCloseTab(ImGuiTabBar* tab_bar, ImGuiTabItem* tab)
        -: 9661:{
    #####: 9662:    if (tab->Flags & ImGuiTabItemFlags_Button)
    %%%%%: 9662-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9663:        return; // A button appended with TabItemButton().
    %%%%%: 9663-block 3
        -: 9664:
    #####: 9665:    if ((tab->Flags & (ImGuiTabItemFlags_UnsavedDocument | ImGuiTabItemFlags_NoAssumedClosure)) == 0)
    %%%%%: 9665-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 9666:    {
        -: 9667:        // This will remove a frame of lag for selecting another tab on closure.
        -: 9668:        // However we don't run it in the case where the 'Unsaved' flag is set, so user gets a chance to fully undo the closure
    #####: 9669:        tab->WantClose = true;
    #####: 9670:        if (tab_bar->VisibleTabId == tab->ID)
    %%%%%: 9670-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 9671:        {
    #####: 9672:            tab->LastFrameVisible = -1;
    #####: 9673:            tab_bar->SelectedTabId = tab_bar->NextSelectedTabId = 0;
    %%%%%: 9673-block 6
        -: 9674:        }
        -: 9675:    }
        -: 9676:    else
        -: 9677:    {
        -: 9678:        // Actually select before expecting closure attempt (on an UnsavedDocument tab user is expect to e.g. show a popup)
    #####: 9679:        if (tab_bar->VisibleTabId != tab->ID)
    %%%%%: 9679-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9680:            TabBarQueueFocus(tab_bar, tab);
    %%%%%: 9680-block 8
call    0 never executed
        -: 9681:    }
        -: 9682:}
        -: 9683:
function _ZN5ImGuiL17TabBarScrollClampEP11ImGuiTabBarf called 10760 returned 100% blocks executed 100%
    10760: 9684:static float ImGui::TabBarScrollClamp(ImGuiTabBar* tab_bar, float scrolling)
        -: 9685:{
    10760: 9686:    scrolling = ImMin(scrolling, tab_bar->WidthAllTabs - tab_bar->BarRect.GetWidth());
    10760: 9686-block 2
call    0 returned 10760
call    1 returned 10760
    10760: 9687:    return ImMax(scrolling, 0.0f);
call    0 returned 10760
        -: 9688:}
        -: 9689:
        -: 9690:// Note: we may scroll to tab that are not selected! e.g. using keyboard arrow keys
function _ZN5ImGuiL17TabBarScrollToTabEP11ImGuiTabBarjP18ImGuiTabBarSection called 5 returned 100% blocks executed 62%
        5: 9691:static void ImGui::TabBarScrollToTab(ImGuiTabBar* tab_bar, ImGuiID tab_id, ImGuiTabBarSection* sections)
        -: 9692:{
        5: 9693:    ImGuiTabItem* tab = TabBarFindTabByID(tab_bar, tab_id);
        5: 9693-block 2
call    0 returned 5
        5: 9694:    if (tab == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    #####: 9695:        return;
    %%%%%: 9695-block 4
        5: 9696:    if (tab->Flags & ImGuiTabItemFlags_SectionMask_)
        5: 9696-block 5
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    #####: 9697:        return;
    %%%%%: 9697-block 6
        -: 9698:
        5: 9699:    ImGuiContext& g = *GImGui;
        5: 9700:    float margin = g.FontSize * 1.0f; // When to scroll to make Tab N+1 visible always make a bit of N visible to suggest more scrolling area (since we don't have a scrollbar)
        5: 9701:    int order = TabBarGetTabOrder(tab_bar, tab);
        5: 9701-block 7
call    0 returned 5
        -: 9702:
        -: 9703:    // Scrolling happens only in the central section (leading/trailing sections are not scrolling)
        5: 9704:    float scrollable_width = TabBarCalcScrollableWidth(tab_bar, sections);
call    0 returned 5
        -: 9705:
        -: 9706:    // We make all tabs positions all relative Sections[0].Width to make code simpler
       5*: 9707:    float tab_x1 = tab->Offset - sections[0].Width + (order > sections[0].TabCount - 1 ? -margin : 0.0f);
branch  0 taken 5 (fallthrough)
branch  1 taken 0
        5: 9707-block 10
    %%%%%: 9707-block 11
       5*: 9708:    float tab_x2 = tab->Offset - sections[0].Width + tab->Width + (order + 1 < tab_bar->Tabs.Size - sections[2].TabCount ? margin : 1.0f);
        5: 9708-block 12
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    %%%%%: 9708-block 13
        5: 9708-block 14
        5: 9709:    tab_bar->ScrollingTargetDistToVisibility = 0.0f;
       5*: 9710:    if (tab_bar->ScrollingTarget > tab_x1 || (tab_x2 - tab_x1 >= scrollable_width))
        5: 9710-block 15
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    %%%%%: 9710-block 16
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 9711:    {
        -: 9712:        // Scroll to the left
        5: 9713:        tab_bar->ScrollingTargetDistToVisibility = ImMax(tab_bar->ScrollingAnim - tab_x2, 0.0f);
        5: 9713-block 17
call    0 returned 5
        5: 9714:        tab_bar->ScrollingTarget = tab_x1;
        -: 9715:    }
    #####: 9716:    else if (tab_bar->ScrollingTarget < tab_x2 - scrollable_width)
    %%%%%: 9716-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 9717:    {
        -: 9718:        // Scroll to the right
    #####: 9719:        tab_bar->ScrollingTargetDistToVisibility = ImMax((tab_x1 - scrollable_width) - tab_bar->ScrollingAnim, 0.0f);
    %%%%%: 9719-block 20
call    0 never executed
    #####: 9720:        tab_bar->ScrollingTarget = tab_x2 - scrollable_width;
        -: 9721:    }
        -: 9722:}
        -: 9723:
function _ZN5ImGui16TabBarQueueFocusEP11ImGuiTabBarP12ImGuiTabItem called 0 returned 0% blocks executed 0%
    #####: 9724:void ImGui::TabBarQueueFocus(ImGuiTabBar* tab_bar, ImGuiTabItem* tab)
        -: 9725:{
    #####: 9726:    tab_bar->NextSelectedTabId = tab->ID;
    #####: 9727:}
        -: 9728:
function _ZN5ImGui16TabBarQueueFocusEP11ImGuiTabBarPKc called 0 returned 0% blocks executed 0%
    #####: 9729:void ImGui::TabBarQueueFocus(ImGuiTabBar* tab_bar, const char* tab_name)
        -: 9730:{
    #####: 9731:    IM_ASSERT((tab_bar->Flags & ImGuiTabBarFlags_DockNode) == 0); // Only supported for manual/explicit tab bars
    %%%%%: 9731-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9731-block 3
call    2 never executed
    #####: 9732:    ImGuiID tab_id = TabBarCalcTabID(tab_bar, tab_name, NULL);
    %%%%%: 9732-block 4
call    0 never executed
    #####: 9733:    tab_bar->NextSelectedTabId = tab_id;
    #####: 9734:}
        -: 9735:
function _ZN5ImGui18TabBarQueueReorderEP11ImGuiTabBarP12ImGuiTabItemi called 0 returned 0% blocks executed 0%
    #####: 9736:void ImGui::TabBarQueueReorder(ImGuiTabBar* tab_bar, ImGuiTabItem* tab, int offset)
        -: 9737:{
    #####: 9738:    IM_ASSERT(offset != 0);
    %%%%%: 9738-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9738-block 3
call    2 never executed
    #####: 9739:    IM_ASSERT(tab_bar->ReorderRequestTabId == 0);
    %%%%%: 9739-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9739-block 5
call    2 never executed
    #####: 9740:    tab_bar->ReorderRequestTabId = tab->ID;
    #####: 9741:    tab_bar->ReorderRequestOffset = (ImS16)offset;
    #####: 9742:}
        -: 9743:
function _ZN5ImGui30TabBarQueueReorderFromMousePosEP11ImGuiTabBarP12ImGuiTabItem6ImVec2 called 0 returned 0% blocks executed 0%
    #####: 9744:void ImGui::TabBarQueueReorderFromMousePos(ImGuiTabBar* tab_bar, ImGuiTabItem* src_tab, ImVec2 mouse_pos)
        -: 9745:{
    #####: 9746:    ImGuiContext& g = *GImGui;
    #####: 9747:    IM_ASSERT(tab_bar->ReorderRequestTabId == 0);
    %%%%%: 9747-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9747-block 3
call    2 never executed
    #####: 9748:    if ((tab_bar->Flags & ImGuiTabBarFlags_Reorderable) == 0)
    %%%%%: 9748-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9749:        return;
    %%%%%: 9749-block 5
        -: 9750:
    #####: 9751:    const bool is_central_section = (src_tab->Flags & ImGuiTabItemFlags_SectionMask_) == 0;
    #####: 9752:    const float bar_offset = tab_bar->BarRect.Min.x - (is_central_section ? tab_bar->ScrollingTarget : 0);
    %%%%%: 9752-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9752-block 7
    %%%%%: 9752-block 8
        -: 9753:
        -: 9754:    // Count number of contiguous tabs we are crossing over
    #####: 9755:    const int dir = (bar_offset + src_tab->Offset) > mouse_pos.x ? -1 : +1;
    %%%%%: 9755-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9755-block 10
    %%%%%: 9755-block 11
    #####: 9756:    const int src_idx = tab_bar->Tabs.index_from_ptr(src_tab);
    %%%%%: 9756-block 12
call    0 never executed
    #####: 9757:    int dst_idx = src_idx;
    #####: 9758:    for (int i = src_idx; i >= 0 && i < tab_bar->Tabs.Size; i += dir)
    %%%%%: 9758-block 23
    %%%%%: 9758-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9758-block 25
branch  2 never executed
branch  3 never executed (fallthrough)
        -: 9759:    {
        -: 9760:        // Reordered tabs must share the same section
    #####: 9761:        const ImGuiTabItem* dst_tab = &tab_bar->Tabs[i];
    %%%%%: 9761-block 14
call    0 never executed
    #####: 9762:        if (dst_tab->Flags & ImGuiTabItemFlags_NoReorder)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9763:            break;
    %%%%%: 9763-block 16
    #####: 9764:        if ((dst_tab->Flags & ImGuiTabItemFlags_SectionMask_) != (src_tab->Flags & ImGuiTabItemFlags_SectionMask_))
    %%%%%: 9764-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9765:            break;
    %%%%%: 9765-block 18
    #####: 9766:        dst_idx = i;
        -: 9767:
        -: 9768:        // Include spacing after tab, so when mouse cursor is between tabs we would not continue checking further tabs that are not hovered.
    #####: 9769:        const float x1 = bar_offset + dst_tab->Offset - g.Style.ItemInnerSpacing.x;
    #####: 9770:        const float x2 = bar_offset + dst_tab->Offset + dst_tab->Width + g.Style.ItemInnerSpacing.x;
        -: 9771:        //GetForegroundDrawList()->AddRect(ImVec2(x1, tab_bar->BarRect.Min.y), ImVec2(x2, tab_bar->BarRect.Max.y), IM_COL32(255, 0, 0, 255));
    #####: 9772:        if ((dir < 0 && mouse_pos.x > x1) || (dir > 0 && mouse_pos.x < x2))
    %%%%%: 9772-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9772-block 20
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 9772-block 21
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 9772-block 22
branch  6 never executed (fallthrough)
branch  7 never executed
        -: 9773:            break;
        -: 9774:    }
        -: 9775:
    #####: 9776:    if (dst_idx != src_idx)
    %%%%%: 9776-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9777:        TabBarQueueReorder(tab_bar, src_tab, dst_idx - src_idx);
    %%%%%: 9777-block 27
call    0 never executed
        -: 9778:}
        -: 9779:
function _ZN5ImGui20TabBarProcessReorderEP11ImGuiTabBar called 0 returned 0% blocks executed 0%
    #####: 9780:bool ImGui::TabBarProcessReorder(ImGuiTabBar* tab_bar)
        -: 9781:{
    #####: 9782:    ImGuiTabItem* tab1 = TabBarFindTabByID(tab_bar, tab_bar->ReorderRequestTabId);
    %%%%%: 9782-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 9783:    if (tab1 == NULL || (tab1->Flags & ImGuiTabItemFlags_NoReorder))
    %%%%%: 9783-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9783-block 4
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 9784:        return false;
    %%%%%: 9784-block 5
        -: 9785:
        -: 9786:    //IM_ASSERT(tab_bar->Flags & ImGuiTabBarFlags_Reorderable); // <- this may happen when using debug tools
    #####: 9787:    int tab2_order = TabBarGetTabOrder(tab_bar, tab1) + tab_bar->ReorderRequestOffset;
    %%%%%: 9787-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 9788:    if (tab2_order < 0 || tab2_order >= tab_bar->Tabs.Size)
    %%%%%: 9788-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9788-block 8
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 9789:        return false;
    %%%%%: 9789-block 9
        -: 9790:
        -: 9791:    // Reordered tabs must share the same section
        -: 9792:    // (Note: TabBarQueueReorderFromMousePos() also has a similar test but since we allow direct calls to TabBarQueueReorder() we do it here too)
    #####: 9793:    ImGuiTabItem* tab2 = &tab_bar->Tabs[tab2_order];
    %%%%%: 9793-block 10
call    0 never executed
    #####: 9794:    if (tab2->Flags & ImGuiTabItemFlags_NoReorder)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9795:        return false;
    %%%%%: 9795-block 12
    #####: 9796:    if ((tab1->Flags & ImGuiTabItemFlags_SectionMask_) != (tab2->Flags & ImGuiTabItemFlags_SectionMask_))
    %%%%%: 9796-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9797:        return false;
    %%%%%: 9797-block 14
        -: 9798:
    #####: 9799:    ImGuiTabItem item_tmp = *tab1;
    #####: 9800:    ImGuiTabItem* src_tab = (tab_bar->ReorderRequestOffset > 0) ? tab1 + 1 : tab2;
    %%%%%: 9800-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9800-block 16
    %%%%%: 9800-block 17
    #####: 9801:    ImGuiTabItem* dst_tab = (tab_bar->ReorderRequestOffset > 0) ? tab1 : tab2 + 1;
    %%%%%: 9801-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9801-block 19
    %%%%%: 9801-block 20
    #####: 9802:    const int move_count = (tab_bar->ReorderRequestOffset > 0) ? tab_bar->ReorderRequestOffset : -tab_bar->ReorderRequestOffset;
    #####: 9803:    memmove(dst_tab, src_tab, move_count * sizeof(ImGuiTabItem));
    #####: 9804:    *tab2 = item_tmp;
        -: 9805:
    #####: 9806:    if (tab_bar->Flags & ImGuiTabBarFlags_SaveSettings)
    %%%%%: 9806-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9807:        MarkIniSettingsDirty();
    %%%%%: 9807-block 22
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 9808:    return true;
    %%%%%: 9808-block 23
        -: 9809:}
        -: 9810:
function _ZN5ImGuiL22TabBarScrollingButtonsEP11ImGuiTabBar called 0 returned 0% blocks executed 0%
    #####: 9811:static ImGuiTabItem* ImGui::TabBarScrollingButtons(ImGuiTabBar* tab_bar)
        -: 9812:{
    #####: 9813:    ImGuiContext& g = *GImGui;
    #####: 9814:    ImGuiWindow* window = g.CurrentWindow;
        -: 9815:
    #####: 9816:    const ImVec2 arrow_button_size(g.FontSize - 2.0f, g.FontSize + g.Style.FramePadding.y * 2.0f);
    %%%%%: 9816-block 2
call    0 never executed
    #####: 9817:    const float scrolling_buttons_width = arrow_button_size.x * 2.0f;
        -: 9818:
    #####: 9819:    const ImVec2 backup_cursor_pos = window->DC.CursorPos;
        -: 9820:    //window->DrawList->AddRect(ImVec2(tab_bar->BarRect.Max.x - scrolling_buttons_width, tab_bar->BarRect.Min.y), ImVec2(tab_bar->BarRect.Max.x, tab_bar->BarRect.Max.y), IM_COL32(255,0,0,255));
        -: 9821:
    #####: 9822:    int select_dir = 0;
    #####: 9823:    ImVec4 arrow_col = g.Style.Colors[ImGuiCol_Text];
    #####: 9824:    arrow_col.w *= 0.5f;
        -: 9825:
    #####: 9826:    PushStyleColor(ImGuiCol_Text, arrow_col);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 9827:    PushStyleColor(ImGuiCol_Button, ImVec4(0, 0, 0, 0));
    %%%%%: 9827-block 4
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$: 9827-block 37
    #####: 9828:    PushItemFlag(ImGuiItemFlags_ButtonRepeat, true);
    %%%%%: 9828-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 9829:    const float backup_repeat_delay = g.IO.KeyRepeatDelay;
    #####: 9830:    const float backup_repeat_rate = g.IO.KeyRepeatRate;
    #####: 9831:    g.IO.KeyRepeatDelay = 0.250f;
    #####: 9832:    g.IO.KeyRepeatRate = 0.200f;
    #####: 9833:    float x = ImMax(tab_bar->BarRect.Min.x, tab_bar->BarRect.Max.x - scrolling_buttons_width);
    %%%%%: 9833-block 7
call    0 never executed
    #####: 9834:    window->DC.CursorPos = ImVec2(x, tab_bar->BarRect.Min.y);
call    0 never executed
    #####: 9835:    if (ArrowButtonEx("##<", ImGuiDir_Left, arrow_button_size, ImGuiButtonFlags_PressedOnClick))
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 9835-block 10
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 9836:        select_dir = -1;
    %%%%%: 9836-block 11
    #####: 9837:    window->DC.CursorPos = ImVec2(x + arrow_button_size.x, tab_bar->BarRect.Min.y);
    %%%%%: 9837-block 12
call    0 never executed
    #####: 9838:    if (ArrowButtonEx("##>", ImGuiDir_Right, arrow_button_size, ImGuiButtonFlags_PressedOnClick))
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 9838-block 14
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 9839:        select_dir = +1;
    %%%%%: 9839-block 15
    #####: 9840:    PopItemFlag();
    %%%%%: 9840-block 16
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 9841:    PopStyleColor(2);
    %%%%%: 9841-block 17
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 9842:    g.IO.KeyRepeatRate = backup_repeat_rate;
    #####: 9843:    g.IO.KeyRepeatDelay = backup_repeat_delay;
        -: 9844:
    #####: 9845:    ImGuiTabItem* tab_to_scroll_to = NULL;
    #####: 9846:    if (select_dir != 0)
    %%%%%: 9846-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9847:        if (ImGuiTabItem* tab_item = TabBarFindTabByID(tab_bar, tab_bar->SelectedTabId))
    %%%%%: 9847-block 19
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 9847-block 20
branch  3 never executed (fallthrough)
branch  4 never executed
        -: 9848:        {
    #####: 9849:            int selected_order = TabBarGetTabOrder(tab_bar, tab_item);
    %%%%%: 9849-block 21
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 9850:            int target_order = selected_order + select_dir;
        -: 9851:
        -: 9852:            // Skip tab item buttons until another tab item is found or end is reached
    #####: 9853:            while (tab_to_scroll_to == NULL)
    %%%%%: 9853-block 22
    %%%%%: 9853-block 34
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 9854:            {
        -: 9855:                // If we are at the end of the list, still scroll to make our tab visible
    #####: 9856:                tab_to_scroll_to = &tab_bar->Tabs[(target_order >= 0 && target_order < tab_bar->Tabs.Size) ? target_order : selected_order];
    %%%%%: 9856-block 23
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9856-block 24
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 9856-block 25
    %%%%%: 9856-block 26
    %%%%%: 9856-block 27
call    4 never executed
        -: 9857:
        -: 9858:                // Cross through buttons
        -: 9859:                // (even if first/last item is a button, return it so we can update the scroll)
    #####: 9860:                if (tab_to_scroll_to->Flags & ImGuiTabItemFlags_Button)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 9861:                {
    #####: 9862:                    target_order += select_dir;
    #####: 9863:                    selected_order += select_dir;
    #####: 9864:                    tab_to_scroll_to = (target_order < 0 || target_order >= tab_bar->Tabs.Size) ? tab_to_scroll_to : NULL;
    %%%%%: 9864-block 29
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9864-block 30
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 9864-block 31
    %%%%%: 9864-block 32
    %%%%%: 9864-block 33
        -: 9865:                }
        -: 9866:            }
        -: 9867:        }
    #####: 9868:    window->DC.CursorPos = backup_cursor_pos;
    #####: 9869:    tab_bar->BarRect.Max.x -= scrolling_buttons_width + 1.0f;
        -: 9870:
    #####: 9871:    return tab_to_scroll_to;
    %%%%%: 9871-block 35
    %%%%%: 9871-block 36
        -: 9872:}
        -: 9873:
function _ZN5ImGuiL24TabBarTabListPopupButtonEP11ImGuiTabBar called 0 returned 0% blocks executed 0%
    #####: 9874:static ImGuiTabItem* ImGui::TabBarTabListPopupButton(ImGuiTabBar* tab_bar)
        -: 9875:{
    #####: 9876:    ImGuiContext& g = *GImGui;
    #####: 9877:    ImGuiWindow* window = g.CurrentWindow;
        -: 9878:
        -: 9879:    // We use g.Style.FramePadding.y to match the square ArrowButton size
    #####: 9880:    const float tab_list_popup_button_width = g.FontSize + g.Style.FramePadding.y;
    #####: 9881:    const ImVec2 backup_cursor_pos = window->DC.CursorPos;
    #####: 9882:    window->DC.CursorPos = ImVec2(tab_bar->BarRect.Min.x - g.Style.FramePadding.y, tab_bar->BarRect.Min.y);
    %%%%%: 9882-block 2
call    0 never executed
    #####: 9883:    tab_bar->BarRect.Min.x += tab_list_popup_button_width;
        -: 9884:
    #####: 9885:    ImVec4 arrow_col = g.Style.Colors[ImGuiCol_Text];
    #####: 9886:    arrow_col.w *= 0.5f;
    #####: 9887:    PushStyleColor(ImGuiCol_Text, arrow_col);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 9888:    PushStyleColor(ImGuiCol_Button, ImVec4(0, 0, 0, 0));
    %%%%%: 9888-block 4
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$: 9888-block 23
    #####: 9889:    bool open = BeginCombo("##v", NULL, ImGuiComboFlags_NoPreview | ImGuiComboFlags_HeightLargest);
    %%%%%: 9889-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 9890:    PopStyleColor(2);
    %%%%%: 9890-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 9891:
    #####: 9892:    ImGuiTabItem* tab_to_select = NULL;
    #####: 9893:    if (open)
    %%%%%: 9893-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 9894:    {
    #####: 9895:        for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)
    %%%%%: 9895-block 9
    %%%%%: 9895-block 18
    %%%%%: 9895-block 19
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 9896:        {
    #####: 9897:            ImGuiTabItem* tab = &tab_bar->Tabs[tab_n];
    %%%%%: 9897-block 10
call    0 never executed
    #####: 9898:            if (tab->Flags & ImGuiTabItemFlags_Button)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9899:                continue;
    %%%%%: 9899-block 12
        -: 9900:
    #####: 9901:            const char* tab_name = TabBarGetTabName(tab_bar, tab);
    %%%%%: 9901-block 13
call    0 never executed
    #####: 9902:            if (Selectable(tab_name, tab_bar->SelectedTabId == tab->ID))
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 9902-block 16
branch  4 never executed (fallthrough)
branch  5 never executed
    $$$$$: 9902-block 24
    #####: 9903:                tab_to_select = tab;
    %%%%%: 9903-block 17
        -: 9904:        }
    #####: 9905:        EndCombo();
    %%%%%: 9905-block 20
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 9906:    }
        -: 9907:
    #####: 9908:    window->DC.CursorPos = backup_cursor_pos;
    #####: 9909:    return tab_to_select;
    %%%%%: 9909-block 21
    %%%%%: 9909-block 22
        -: 9910:}
        -: 9911:
        -: 9912://-------------------------------------------------------------------------
        -: 9913:// [SECTION] Widgets: BeginTabItem, EndTabItem, etc.
        -: 9914://-------------------------------------------------------------------------
        -: 9915:// - BeginTabItem()
        -: 9916:// - EndTabItem()
        -: 9917:// - TabItemButton()
        -: 9918:// - TabItemEx() [Internal]
        -: 9919:// - SetTabItemClosed()
        -: 9920:// - TabItemCalcSize() [Internal]
        -: 9921:// - TabItemBackground() [Internal]
        -: 9922:// - TabItemLabelAndCloseButton() [Internal]
        -: 9923://-------------------------------------------------------------------------
        -: 9924:
function _ZN5ImGui12BeginTabItemEPKcPbi called 0 returned 0% blocks executed 0%
    #####: 9925:bool    ImGui::BeginTabItem(const char* label, bool* p_open, ImGuiTabItemFlags flags)
        -: 9926:{
    #####: 9927:    ImGuiContext& g = *GImGui;
    #####: 9928:    ImGuiWindow* window = g.CurrentWindow;
    #####: 9929:    if (window->SkipItems)
    %%%%%: 9929-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9930:        return false;
    %%%%%: 9930-block 3
        -: 9931:
    #####: 9932:    ImGuiTabBar* tab_bar = g.CurrentTabBar;
    #####: 9933:    if (tab_bar == NULL)
    %%%%%: 9933-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 9934:    {
    #####: 9935:        IM_ASSERT_USER_ERROR(tab_bar, "Needs to be called between BeginTabBar() and EndTabBar()!");
    %%%%%: 9935-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9935-block 6
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 9935-block 8
    %%%%%: 9935-block 9
    %%%%%: 9935-block 10
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 9935-block 11
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 9935-block 12
call    9 never executed
    #####: 9936:        return false;
    %%%%%: 9936-block 13
        -: 9937:    }
    #####: 9938:    IM_ASSERT((flags & ImGuiTabItemFlags_Button) == 0);             // BeginTabItem() Can't be used with button flags, use TabItemButton() instead!
    %%%%%: 9938-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9938-block 15
call    2 never executed
        -: 9939:
    #####: 9940:    bool ret = TabItemEx(tab_bar, label, p_open, flags, NULL);
    %%%%%: 9940-block 16
call    0 never executed
    #####: 9941:    if (ret && !(flags & ImGuiTabItemFlags_NoPushId))
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9941-block 18
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 9942:    {
    #####: 9943:        ImGuiTabItem* tab = &tab_bar->Tabs[tab_bar->LastTabItemIdx];
    %%%%%: 9943-block 19
call    0 never executed
    #####: 9944:        PushOverrideID(tab->ID); // We already hashed 'label' so push into the ID stack directly instead of doing another hash through PushID(label)
call    0 never executed
        -: 9945:    }
    #####: 9946:    return ret;
    %%%%%: 9946-block 21
        -: 9947:}
        -: 9948:
function _ZN5ImGui10EndTabItemEv called 0 returned 0% blocks executed 0%
    #####: 9949:void    ImGui::EndTabItem()
        -: 9950:{
    #####: 9951:    ImGuiContext& g = *GImGui;
    #####: 9952:    ImGuiWindow* window = g.CurrentWindow;
    #####: 9953:    if (window->SkipItems)
    %%%%%: 9953-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9954:        return;
    %%%%%: 9954-block 3
        -: 9955:
    #####: 9956:    ImGuiTabBar* tab_bar = g.CurrentTabBar;
    #####: 9957:    if (tab_bar == NULL)
    %%%%%: 9957-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 9958:    {
    #####: 9959:        IM_ASSERT_USER_ERROR(tab_bar != NULL, "Needs to be called between BeginTabBar() and EndTabBar()!");
    %%%%%: 9959-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9959-block 6
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 9959-block 8
    %%%%%: 9959-block 9
    %%%%%: 9959-block 10
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 9959-block 11
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 9959-block 12
call    9 never executed
    #####: 9960:        return;
    %%%%%: 9960-block 13
        -: 9961:    }
    #####: 9962:    IM_ASSERT(tab_bar->LastTabItemIdx >= 0);
    %%%%%: 9962-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9962-block 15
call    2 never executed
    #####: 9963:    ImGuiTabItem* tab = &tab_bar->Tabs[tab_bar->LastTabItemIdx];
    %%%%%: 9963-block 16
call    0 never executed
    #####: 9964:    if (!(tab->Flags & ImGuiTabItemFlags_NoPushId))
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9965:        PopID();
    %%%%%: 9965-block 18
call    0 never executed
        -: 9966:}
        -: 9967:
function _ZN5ImGui13TabItemButtonEPKci called 0 returned 0% blocks executed 0%
    #####: 9968:bool    ImGui::TabItemButton(const char* label, ImGuiTabItemFlags flags)
        -: 9969:{
    #####: 9970:    ImGuiContext& g = *GImGui;
    #####: 9971:    ImGuiWindow* window = g.CurrentWindow;
    #####: 9972:    if (window->SkipItems)
    %%%%%: 9972-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 9973:        return false;
    %%%%%: 9973-block 3
        -: 9974:
    #####: 9975:    ImGuiTabBar* tab_bar = g.CurrentTabBar;
    #####: 9976:    if (tab_bar == NULL)
    %%%%%: 9976-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 9977:    {
    #####: 9978:        IM_ASSERT_USER_ERROR(tab_bar != NULL, "Needs to be called between BeginTabBar() and EndTabBar()!");
    %%%%%: 9978-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 9978-block 6
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 9978-block 8
    %%%%%: 9978-block 9
    %%%%%: 9978-block 10
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 9978-block 11
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 9978-block 12
call    9 never executed
    #####: 9979:        return false;
    %%%%%: 9979-block 13
        -: 9980:    }
    #####: 9981:    return TabItemEx(tab_bar, label, NULL, flags | ImGuiTabItemFlags_Button | ImGuiTabItemFlags_NoReorder, NULL);
    %%%%%: 9981-block 14
call    0 never executed
        -: 9982:}
        -: 9983:
function _ZN5ImGui9TabItemExEP11ImGuiTabBarPKcPbiP11ImGuiWindow called 5380 returned 100% blocks executed 48%
     5380: 9984:bool    ImGui::TabItemEx(ImGuiTabBar* tab_bar, const char* label, bool* p_open, ImGuiTabItemFlags flags, ImGuiWindow* docked_window)
        -: 9985:{
        -: 9986:    // Layout whole tab bar if not already done
     5380: 9987:    ImGuiContext& g = *GImGui;
     5380: 9988:    if (tab_bar->WantLayout)
     5380: 9988-block 2
branch  0 taken 5380 (fallthrough)
branch  1 taken 0
        -: 9989:    {
     5380: 9990:        ImGuiNextItemData backup_next_item_data = g.NextItemData;
     5380: 9991:        TabBarLayout(tab_bar);
     5380: 9991-block 3
call    0 returned 5380
branch  1 taken 5380 (fallthrough)
branch  2 taken 0 (throw)
     5380: 9992:        g.NextItemData = backup_next_item_data;
     5380: 9992-block 4
        -: 9993:    }
     5380: 9994:    ImGuiWindow* window = g.CurrentWindow;
     5380: 9995:    if (window->SkipItems)
     5380: 9995-block 5
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    #####: 9996:        return false;
    %%%%%: 9996-block 6
        -: 9997:
     5380: 9998:    const ImGuiStyle& style = g.Style;
     5380: 9999:    const ImGuiID id = TabBarCalcTabID(tab_bar, label, docked_window);
     5380: 9999-block 7
call    0 returned 5380
branch  1 taken 5380 (fallthrough)
branch  2 taken 0 (throw)
        -:10000:
        -:10001:    // If the user called us with *p_open == false, we early out and don't render.
        -:10002:    // We make a call to ItemAdd() so that attempts to use a contextual popup menu with an implicit ID won't use an older ID.
        -:10003:    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags);
     5380:10004:    if (p_open && !*p_open)
     5380:10004-block 8
branch  0 taken 5380 (fallthrough)
branch  1 taken 0
     5380:10004-block 9
branch  2 taken 0 (fallthrough)
branch  3 taken 5380
        -:10005:    {
    #####:10006:        ItemAdd(ImRect(), id, NULL, ImGuiItemFlags_NoNav);
    %%%%%:10006-block 10
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$:10006-block 274
    #####:10007:        return false;
    %%%%%:10007-block 12
        -:10008:    }
        -:10009:
    5380*:10010:    IM_ASSERT(!p_open || !(flags & ImGuiTabItemFlags_Button));
     5380:10010-block 13
branch  0 taken 5380 (fallthrough)
branch  1 taken 0
     5380:10010-block 14
branch  2 taken 0 (fallthrough)
branch  3 taken 5380
    %%%%%:10010-block 15
call    4 never executed
    5380*:10011:    IM_ASSERT((flags & (ImGuiTabItemFlags_Leading | ImGuiTabItemFlags_Trailing)) != (ImGuiTabItemFlags_Leading | ImGuiTabItemFlags_Trailing)); // Can't use both Leading and Trailing
     5380:10011-block 16
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    %%%%%:10011-block 17
call    2 never executed
        -:10012:
        -:10013:    // Store into ImGuiTabItemFlags_NoCloseButton, also honor ImGuiTabItemFlags_NoCloseButton passed by user (although not documented)
     5380:10014:    if (flags & ImGuiTabItemFlags_NoCloseButton)
     5380:10014-block 18
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    #####:10015:        p_open = NULL;
    %%%%%:10015-block 19
     5380:10016:    else if (p_open == NULL)
     5380:10016-block 20
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    #####:10017:        flags |= ImGuiTabItemFlags_NoCloseButton;
    %%%%%:10017-block 21
        -:10018:
        -:10019:    // Acquire tab data
     5380:10020:    ImGuiTabItem* tab = TabBarFindTabByID(tab_bar, id);
     5380:10020-block 22
call    0 returned 5380
branch  1 taken 5380 (fallthrough)
branch  2 taken 0 (throw)
     5380:10021:    bool tab_is_new = false;
     5380:10022:    if (tab == NULL)
     5380:10022-block 23
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
        -:10023:    {
    #####:10024:        tab_bar->Tabs.push_back(ImGuiTabItem());
    %%%%%:10024-block 24
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$:10024-block 275
    #####:10025:        tab = &tab_bar->Tabs.back();
    %%%%%:10025-block 26
call    0 never executed
    #####:10026:        tab->ID = id;
    #####:10027:        tab_bar->TabsAddedNew = tab_is_new = true;
        -:10028:    }
     5380:10029:    tab_bar->LastTabItemIdx = (ImS16)tab_bar->Tabs.index_from_ptr(tab);
     5380:10029-block 28
call    0 returned 5380
        -:10030:
        -:10031:    // Calculate tab contents size
    5380*:10032:    ImVec2 size = TabItemCalcSize(label, (p_open != NULL) || (flags & ImGuiTabItemFlags_UnsavedDocument));
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    %%%%%:10032-block 30
branch  2 never executed (fallthrough)
branch  3 never executed
     5380:10032-block 31
    %%%%%:10032-block 32
     5380:10032-block 33
call    4 returned 5380
branch  5 taken 5380 (fallthrough)
branch  6 taken 0 (throw)
     5380:10033:    tab->RequestedWidth = -1.0f;
     5380:10034:    if (g.NextItemData.HasFlags & ImGuiNextItemDataFlags_HasWidth)
     5380:10034-block 34
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    #####:10035:        size.x = tab->RequestedWidth = g.NextItemData.Width;
    %%%%%:10035-block 35
     5380:10036:    if (tab_is_new)
     5380:10036-block 36
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    #####:10037:        tab->Width = ImMax(1.0f, size.x);
    %%%%%:10037-block 37
call    0 never executed
     5380:10038:    tab->ContentWidth = size.x;
     5380:10039:    tab->BeginOrder = tab_bar->TabsActiveCount++;
        -:10040:
     5380:10041:    const bool tab_bar_appearing = (tab_bar->PrevFrameVisible + 1 < g.FrameCount);
     5380:10042:    const bool tab_bar_focused = (tab_bar->Flags & ImGuiTabBarFlags_IsFocused) != 0;
     5380:10043:    const bool tab_appearing = (tab->LastFrameVisible + 1 < g.FrameCount);
    5380*:10044:    const bool tab_just_unsaved = (flags & ImGuiTabItemFlags_UnsavedDocument) && !(tab->Flags & ImGuiTabItemFlags_UnsavedDocument);
     5380:10044-block 39
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    %%%%%:10044-block 40
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:10044-block 41
     5380:10044-block 42
     5380:10045:    const bool is_tab_button = (flags & ImGuiTabItemFlags_Button) != 0;
     5380:10046:    tab->LastFrameVisible = g.FrameCount;
     5380:10047:    tab->Flags = flags;
     5380:10048:    tab->Window = docked_window;
        -:10049:
        -:10050:    // Append name _WITH_ the zero-terminator
        -:10051:    // (regular tabs are permitted in a DockNode tab bar, but window tabs not permitted in a non-DockNode tab bar)
     5380:10052:    if (docked_window != NULL)
     5380:10052-block 43
branch  0 taken 5380 (fallthrough)
branch  1 taken 0
        -:10053:    {
    5380*:10054:        IM_ASSERT(tab_bar->Flags & ImGuiTabBarFlags_DockNode);
     5380:10054-block 44
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    %%%%%:10054-block 45
call    2 never executed
     5380:10055:        tab->NameOffset = -1;
     5380:10055-block 46
        -:10056:    }
        -:10057:    else
        -:10058:    {
    #####:10059:        tab->NameOffset = (ImS32)tab_bar->TabsNames.size();
    %%%%%:10059-block 47
call    0 never executed
    #####:10060:        tab_bar->TabsNames.append(label, label + strlen(label) + 1);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:10061:    }
        -:10062:
        -:10063:    // Update selected tab
     5380:10064:    if (!is_tab_button)
     5380:10064-block 49
branch  0 taken 5380 (fallthrough)
branch  1 taken 0
        -:10065:    {
     5380:10066:        if (tab_appearing && (tab_bar->Flags & ImGuiTabBarFlags_AutoSelectNewTabs) && tab_bar->NextSelectedTabId == 0)
     5380:10066-block 50
branch  0 taken 5 (fallthrough)
branch  1 taken 5375
        5:10066-block 51
branch  2 taken 5 (fallthrough)
branch  3 taken 0
        5:10066-block 52
branch  4 taken 5 (fallthrough)
branch  5 taken 0
        5:10067:            if (!tab_bar_appearing || tab_bar->SelectedTabId == 0)
        5:10067-block 53
branch  0 taken 5 (fallthrough)
branch  1 taken 0
        5:10067-block 54
branch  2 taken 0 (fallthrough)
branch  3 taken 5
    #####:10068:                TabBarQueueFocus(tab_bar, tab); // New tabs gets activated
    %%%%%:10068-block 55
call    0 never executed
    5380*:10069:        if ((flags & ImGuiTabItemFlags_SetSelected) && (tab_bar->SelectedTabId != id)) // _SetSelected can only be passed on explicit tab bar
     5380:10069-block 56
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    %%%%%:10069-block 57
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:10070:            TabBarQueueFocus(tab_bar, tab);
    %%%%%:10070-block 58
call    0 never executed
        -:10071:    }
        -:10072:
        -:10073:    // Lock visibility
        -:10074:    // (Note: tab_contents_visible != tab_selected... because CTRL+TAB operations may preview some tabs without selecting them!)
     5380:10075:    bool tab_contents_visible = (tab_bar->VisibleTabId == id);
     5380:10076:    if (tab_contents_visible)
     5380:10076-block 59
branch  0 taken 5380 (fallthrough)
branch  1 taken 0
     5380:10077:        tab_bar->VisibleTabWasSubmitted = true;
     5380:10077-block 60
        -:10078:
        -:10079:    // On the very first frame of a tab bar we let first tab contents be visible to minimize appearing glitches
    5380*:10080:    if (!tab_contents_visible && tab_bar->SelectedTabId == 0 && tab_bar_appearing && docked_window == NULL)
     5380:10080-block 61
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    %%%%%:10080-block 62
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:10080-block 63
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:10080-block 64
branch  6 never executed (fallthrough)
branch  7 never executed
    #####:10081:        if (tab_bar->Tabs.Size == 1 && !(tab_bar->Flags & ImGuiTabBarFlags_AutoSelectNewTabs))
    %%%%%:10081-block 65
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10081-block 66
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:10082:            tab_contents_visible = true;
    %%%%%:10082-block 67
        -:10083:
        -:10084:    // Note that tab_is_new is not necessarily the same as tab_appearing! When a tab bar stops being submitted
        -:10085:    // and then gets submitted again, the tabs will have 'tab_appearing=true' but 'tab_is_new=false'.
     5380:10086:    if (tab_appearing && (!tab_bar_appearing || tab_is_new))
     5380:10086-block 68
branch  0 taken 5 (fallthrough)
branch  1 taken 5375
        5:10086-block 69
branch  2 taken 5 (fallthrough)
branch  3 taken 0
        5:10086-block 70
branch  4 taken 0 (fallthrough)
branch  5 taken 5
        -:10087:    {
    #####:10088:        ItemAdd(ImRect(), id, NULL, ImGuiItemFlags_NoNav);
    %%%%%:10088-block 71
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$:10088-block 276
    #####:10089:        if (is_tab_button)
    %%%%%:10089-block 73
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:10090:            return false;
    %%%%%:10090-block 74
    #####:10091:        return tab_contents_visible;
    %%%%%:10091-block 75
        -:10092:    }
        -:10093:
     5380:10094:    if (tab_bar->SelectedTabId == id)
     5380:10094-block 76
branch  0 taken 5380 (fallthrough)
branch  1 taken 0
     5380:10095:        tab->LastFrameSelected = g.FrameCount;
     5380:10095-block 77
        -:10096:
        -:10097:    // Backup current layout position
     5380:10098:    const ImVec2 backup_main_cursor_pos = window->DC.CursorPos;
        -:10099:
        -:10100:    // Layout
     5380:10101:    const bool is_central_section = (tab->Flags & ImGuiTabItemFlags_SectionMask_) == 0;
     5380:10102:    size.x = tab->Width;
     5380:10103:    if (is_central_section)
     5380:10103-block 78
branch  0 taken 5380 (fallthrough)
branch  1 taken 0
     5380:10104:        window->DC.CursorPos = tab_bar->BarRect.Min + ImVec2(IM_TRUNC(tab->Offset - tab_bar->ScrollingAnim), 0.0f);
     5380:10104-block 79
call    0 returned 5380
call    1 returned 5380
        -:10105:    else
    #####:10106:        window->DC.CursorPos = tab_bar->BarRect.Min + ImVec2(tab->Offset, 0.0f);
    %%%%%:10106-block 82
call    0 never executed
call    1 never executed
     5380:10107:    ImVec2 pos = window->DC.CursorPos;
     5380:10108:    ImRect bb(pos, pos + size);
     5380:10108-block 85
call    0 returned 5380
call    1 returned 5380
        -:10109:
        -:10110:    // We don't have CPU clipping primitives to clip the CloseButton (until it becomes a texture), so need to add an extra draw call (temporary in the case of vertical animation)
     5380:10111:    const bool want_clip_rect = is_central_section && (bb.Min.x < tab_bar->ScrollingRectMinX || bb.Max.x > tab_bar->ScrollingRectMaxX);
branch  0 taken 5380 (fallthrough)
branch  1 taken 0
     5380:10111-block 88
branch  2 taken 5380 (fallthrough)
branch  3 taken 0
     5380:10111-block 89
branch  4 taken 1076 (fallthrough)
branch  5 taken 4304
     1076:10111-block 90
     4304:10111-block 91
     5380:10112:    if (want_clip_rect)
     5380:10112-block 92
branch  0 taken 1076 (fallthrough)
branch  1 taken 4304
     1076:10113:        PushClipRect(ImVec2(ImMax(bb.Min.x, tab_bar->ScrollingRectMinX), bb.Min.y - 1), ImVec2(tab_bar->ScrollingRectMaxX, bb.Max.y), true);
     1076:10113-block 93
call    0 returned 1076
call    1 returned 1076
call    2 returned 1076
call    3 returned 1076
branch  4 taken 1076 (fallthrough)
branch  5 taken 0 (throw)
     1076:10113-block 97
    $$$$$:10113-block 277
    $$$$$:10113-block 278
        -:10114:
     5380:10115:    ImVec2 backup_cursor_max_pos = window->DC.CursorMaxPos;
     5380:10116:    ItemSize(bb.GetSize(), style.FramePadding.y);
     5380:10116-block 98
call    0 returned 5380
call    1 returned 5380
branch  2 taken 5380 (fallthrough)
branch  3 taken 0 (throw)
    $$$$$:10116-block 279
     5380:10117:    window->DC.CursorMaxPos = backup_cursor_max_pos;
        -:10118:
     5380:10119:    if (!ItemAdd(bb, id))
     5380:10119-block 100
call    0 returned 5380
branch  1 taken 5380 (fallthrough)
branch  2 taken 0 (throw)
     5380:10119-block 101
branch  3 taken 1076 (fallthrough)
branch  4 taken 4304
        -:10120:    {
     1076:10121:        if (want_clip_rect)
     1076:10121-block 102
branch  0 taken 1076 (fallthrough)
branch  1 taken 0
     1076:10122:            PopClipRect();
     1076:10122-block 103
call    0 returned 1076
branch  1 taken 1076 (fallthrough)
branch  2 taken 0 (throw)
     1076:10123:        window->DC.CursorPos = backup_main_cursor_pos;
     1076:10124:        return tab_contents_visible;
     1076:10124-block 104
        -:10125:    }
        -:10126:
        -:10127:    // Click to Select a tab
    4304*:10128:    ImGuiButtonFlags button_flags = ((is_tab_button ? ImGuiButtonFlags_PressedOnClickRelease : ImGuiButtonFlags_PressedOnClick) | ImGuiButtonFlags_AllowOverlap);
     4304:10128-block 105
branch  0 taken 0 (fallthrough)
branch  1 taken 4304
    %%%%%:10128-block 106
     4304:10128-block 107
    4304*:10129:    if (g.DragDropActive && !g.DragDropPayload.IsDataType(IMGUI_PAYLOAD_TYPE_WINDOW)) // FIXME: May be an opt-in property of the payload to disable this
     4304:10129-block 108
branch  0 taken 0 (fallthrough)
branch  1 taken 4304
    %%%%%:10129-block 109
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%:10129-block 111
     4304:10129-block 112
     4304:10129-block 113
branch  5 taken 0 (fallthrough)
branch  6 taken 4304
    #####:10130:        button_flags |= ImGuiButtonFlags_PressedOnDragDropHold;
    %%%%%:10130-block 114
        -:10131:    bool hovered, held;
     4304:10132:    bool pressed = ButtonBehavior(bb, id, &hovered, &held, button_flags);
     4304:10132-block 115
call    0 returned 4304
branch  1 taken 4304 (fallthrough)
branch  2 taken 0 (throw)
    4304*:10133:    if (pressed && !is_tab_button)
     4304:10133-block 116
branch  0 taken 0 (fallthrough)
branch  1 taken 4304
    %%%%%:10133-block 117
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:10134:        TabBarQueueFocus(tab_bar, tab);
    %%%%%:10134-block 118
call    0 never executed
        -:10135:
        -:10136:    // Transfer active id window so the active id is not owned by the dock host (as StartMouseMovingWindow()
        -:10137:    // will only do it on the drag). This allows FocusWindow() to be more conservative in how it clears active id.
    4304*:10138:    if (held && docked_window && g.ActiveId == id && g.ActiveIdIsJustActivated)
     4304:10138-block 119
branch  0 taken 0 (fallthrough)
branch  1 taken 4304
    %%%%%:10138-block 120
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:10138-block 121
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:10138-block 122
branch  6 never executed (fallthrough)
branch  7 never executed
    #####:10139:        g.ActiveIdWindow = docked_window;
    %%%%%:10139-block 123
        -:10140:
        -:10141:    // Drag and drop a single floating window node moves it
    4304*:10142:    ImGuiDockNode* node = docked_window ? docked_window->DockNode : NULL;
     4304:10142-block 124
branch  0 taken 4304 (fallthrough)
branch  1 taken 0
     4304:10142-block 125
    %%%%%:10142-block 126
    4304*:10143:    const bool single_floating_window_node = node && node->IsFloatingNode() && (node->Windows.Size == 1);
     4304:10143-block 127
branch  0 taken 4304 (fallthrough)
branch  1 taken 0
     4304:10143-block 128
call    2 returned 4304
branch  3 taken 0 (fallthrough)
branch  4 taken 4304
    %%%%%:10143-block 130
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:10143-block 131
     4304:10143-block 132
    4304*:10144:    if (held && single_floating_window_node && IsMouseDragging(0, 0.0f))
     4304:10144-block 133
branch  0 taken 0 (fallthrough)
branch  1 taken 4304
    %%%%%:10144-block 134
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:10144-block 135
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    %%%%%:10144-block 136
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%:10144-block 137
     4304:10144-block 138
     4304:10144-block 139
branch  9 taken 0 (fallthrough)
branch 10 taken 4304
        -:10145:    {
        -:10146:        // Move
    #####:10147:        StartMouseMovingWindow(docked_window);
    %%%%%:10147-block 140
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:10148:    }
    4304*:10149:    else if (held && !tab_appearing && IsMouseDragging(0))
     4304:10149-block 141
branch  0 taken 0 (fallthrough)
branch  1 taken 4304
    %%%%%:10149-block 142
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:10149-block 143
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    %%%%%:10149-block 144
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%:10149-block 145
     4304:10149-block 146
     4304:10149-block 147
branch  9 taken 0 (fallthrough)
branch 10 taken 4304
        -:10150:    {
        -:10151:        // Drag and drop: re-order tabs
    #####:10152:        int drag_dir = 0;
    #####:10153:        float drag_distance_from_edge_x = 0.0f;
    #####:10154:        if (!g.DragDropActive && ((tab_bar->Flags & ImGuiTabBarFlags_Reorderable) || (docked_window != NULL)))
    %%%%%:10154-block 148
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10154-block 149
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:10154-block 150
branch  4 never executed (fallthrough)
branch  5 never executed
        -:10155:        {
        -:10156:            // While moving a tab it will jump on the other side of the mouse, so we also test for MouseDelta.x
    #####:10157:            if (g.IO.MouseDelta.x < 0.0f && g.IO.MousePos.x < bb.Min.x)
    %%%%%:10157-block 151
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10157-block 152
branch  2 never executed (fallthrough)
branch  3 never executed
        -:10158:            {
    #####:10159:                drag_dir = -1;
    #####:10160:                drag_distance_from_edge_x = bb.Min.x - g.IO.MousePos.x;
    #####:10161:                TabBarQueueReorderFromMousePos(tab_bar, tab, g.IO.MousePos);
    %%%%%:10161-block 153
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:10162:            }
    #####:10163:            else if (g.IO.MouseDelta.x > 0.0f && g.IO.MousePos.x > bb.Max.x)
    %%%%%:10163-block 155
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10163-block 156
branch  2 never executed (fallthrough)
branch  3 never executed
        -:10164:            {
    #####:10165:                drag_dir = +1;
    #####:10166:                drag_distance_from_edge_x = g.IO.MousePos.x - bb.Max.x;
    #####:10167:                TabBarQueueReorderFromMousePos(tab_bar, tab, g.IO.MousePos);
    %%%%%:10167-block 157
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:10168:            }
        -:10169:        }
        -:10170:
        -:10171:        // Extract a Dockable window out of it's tab bar
    #####:10172:        const bool can_undock = docked_window != NULL && !(docked_window->Flags & ImGuiWindowFlags_NoMove) && !(node->MergedFlags & ImGuiDockNodeFlags_NoUndocking);
    %%%%%:10172-block 158
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10172-block 159
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:10172-block 160
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:10172-block 161
    %%%%%:10172-block 162
    #####:10173:        if (can_undock)
    %%%%%:10173-block 163
branch  0 never executed (fallthrough)
branch  1 never executed
        -:10174:        {
        -:10175:            // We use a variable threshold to distinguish dragging tabs within a tab bar and extracting them out of the tab bar
    #####:10176:            bool undocking_tab = (g.DragDropActive && g.DragDropPayload.SourceId == id);
    %%%%%:10176-block 164
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10176-block 165
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:10176-block 166
    %%%%%:10176-block 167
    #####:10177:            if (!undocking_tab) //&& (!g.IO.ConfigDockingWithShift || g.IO.KeyShift)
    %%%%%:10177-block 168
branch  0 never executed (fallthrough)
branch  1 never executed
        -:10178:            {
    #####:10179:                float threshold_base = g.FontSize;
    #####:10180:                float threshold_x = (threshold_base * 2.2f);
    #####:10181:                float threshold_y = (threshold_base * 1.5f) + ImClamp((ImFabs(g.IO.MouseDragMaxDistanceAbs[0].x) - threshold_base * 2.0f) * 0.20f, 0.0f, threshold_base * 4.0f);
    %%%%%:10181-block 169
call    0 never executed
        -:10182:                //GetForegroundDrawList()->AddRect(ImVec2(bb.Min.x - threshold_x, bb.Min.y - threshold_y), ImVec2(bb.Max.x + threshold_x, bb.Max.y + threshold_y), IM_COL32_WHITE); // [DEBUG]
        -:10183:
    #####:10184:                float distance_from_edge_y = ImMax(bb.Min.y - g.IO.MousePos.y, g.IO.MousePos.y - bb.Max.y);
call    0 never executed
    #####:10185:                if (distance_from_edge_y >= threshold_y)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:10186:                    undocking_tab = true;
    %%%%%:10186-block 172
    #####:10187:                if (drag_distance_from_edge_x > threshold_x)
    %%%%%:10187-block 173
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:10188:                    if ((drag_dir < 0 && TabBarGetTabOrder(tab_bar, tab) == 0) || (drag_dir > 0 && TabBarGetTabOrder(tab_bar, tab) == tab_bar->Tabs.Size - 1))
    %%%%%:10188-block 174
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10188-block 175
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%:10188-block 176
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:10188-block 177
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%:10188-block 178
call    9 never executed
branch 10 never executed (fallthrough)
branch 11 never executed (throw)
    %%%%%:10188-block 179
branch 12 never executed (fallthrough)
branch 13 never executed
    %%%%%:10188-block 180
    %%%%%:10188-block 181
    %%%%%:10188-block 182
branch 14 never executed (fallthrough)
branch 15 never executed
    #####:10189:                        undocking_tab = true;
    %%%%%:10189-block 183
        -:10190:            }
        -:10191:
    #####:10192:            if (undocking_tab)
    %%%%%:10192-block 184
branch  0 never executed (fallthrough)
branch  1 never executed
        -:10193:            {
        -:10194:                // Undock
        -:10195:                // FIXME: refactor to share more code with e.g. StartMouseMovingWindow
    #####:10196:                DockContextQueueUndockWindow(&g, docked_window);
    %%%%%:10196-block 185
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:10197:                g.MovingWindow = docked_window;
    #####:10198:                SetActiveID(g.MovingWindow->MoveId, g.MovingWindow);
    %%%%%:10198-block 186
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:10199:                g.ActiveIdClickOffset -= g.MovingWindow->Pos - bb.Min;
    %%%%%:10199-block 187
call    0 never executed
call    1 never executed
    #####:10200:                g.ActiveIdNoClearOnFocusLoss = true;
    #####:10201:                SetActiveIdUsingAllKeyboardKeys();
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:10202:            }
        -:10203:        }
        -:10204:    }
        -:10205:
        -:10206:#if 0
        -:10207:    if (hovered && g.HoveredIdNotActiveTimer > TOOLTIP_DELAY && bb.GetWidth() < tab->ContentWidth)
        -:10208:    {
        -:10209:        // Enlarge tab display when hovering
        -:10210:        bb.Max.x = bb.Min.x + IM_TRUNC(ImLerp(bb.GetWidth(), tab->ContentWidth, ImSaturate((g.HoveredIdNotActiveTimer - 0.40f) * 6.0f)));
        -:10211:        display_draw_list = GetForegroundDrawList(window);
        -:10212:        TabItemBackground(display_draw_list, bb, flags, GetColorU32(ImGuiCol_TitleBgActive));
        -:10213:    }
        -:10214:#endif
        -:10215:
        -:10216:    // Render tab shape
     4304:10217:    ImDrawList* display_draw_list = window->DrawList;
    4304*:10218:    const ImU32 tab_col = GetColorU32((held || hovered) ? ImGuiCol_TabHovered : tab_contents_visible ? (tab_bar_focused ? ImGuiCol_TabSelected : ImGuiCol_TabDimmedSelected) : (tab_bar_focused ? ImGuiCol_Tab : ImGuiCol_TabDimmed));
     4304:10218-block 190
branch  0 taken 4304 (fallthrough)
branch  1 taken 0
     4304:10218-block 191
branch  2 taken 4304 (fallthrough)
branch  3 taken 0
     4304:10218-block 192
branch  4 taken 4304 (fallthrough)
branch  5 taken 0
     4304:10218-block 193
branch  6 taken 1076 (fallthrough)
branch  7 taken 3228
     1076:10218-block 194
     3228:10218-block 195
     4304:10218-block 196
    %%%%%:10218-block 197
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%:10218-block 198
    %%%%%:10218-block 199
    %%%%%:10218-block 200
     4304:10218-block 201
    %%%%%:10218-block 202
     4304:10218-block 203
call   10 returned 4304
branch 11 taken 4304 (fallthrough)
branch 12 taken 0 (throw)
     4304:10219:    TabItemBackground(display_draw_list, bb, flags, tab_col);
     4304:10219-block 204
call    0 returned 4304
branch  1 taken 4304 (fallthrough)
branch  2 taken 0 (throw)
     4304:10220:    if (tab_contents_visible && (tab_bar->Flags & ImGuiTabBarFlags_DrawSelectedOverline) && style.TabBarOverlineSize > 0.0f)
     4304:10220-block 205
branch  0 taken 4304 (fallthrough)
branch  1 taken 0
     4304:10220-block 206
branch  2 taken 4304 (fallthrough)
branch  3 taken 0
     4304:10220-block 207
branch  4 taken 4304 (fallthrough)
branch  5 taken 0
        -:10221:    {
     4304:10222:        float x_offset = IM_TRUNC(0.4f * style.TabRounding);
     4304:10223:        if (x_offset < 2.0f * g.CurrentDpiScale)
     4304:10223-block 208
branch  0 taken 4304 (fallthrough)
branch  1 taken 0
     4304:10224:            x_offset = 0.0f;
     4304:10224-block 209
     4304:10225:        float y_offset = 1.0f * g.CurrentDpiScale;
     4304:10226:        display_draw_list->AddLine(bb.GetTL() + ImVec2(x_offset, y_offset), bb.GetTR() + ImVec2(-x_offset, y_offset), GetColorU32(tab_bar_focused ? ImGuiCol_TabSelectedOverline : ImGuiCol_TabDimmedSelectedOverline), style.TabBarOverlineSize);
     4304:10226-block 210
branch  0 taken 1076 (fallthrough)
branch  1 taken 3228
     1076:10226-block 211
     3228:10226-block 212
     4304:10226-block 213
call    2 returned 4304
branch  3 taken 4304 (fallthrough)
branch  4 taken 0 (throw)
     4304:10226-block 214
call    5 returned 4304
call    6 returned 4304
call    7 returned 4304
call    8 returned 4304
call    9 returned 4304
call   10 returned 4304
call   11 returned 4304
branch 12 taken 4304 (fallthrough)
branch 13 taken 0 (throw)
     4304:10226-block 221
    $$$$$:10226-block 280
    $$$$$:10226-block 281
    $$$$$:10226-block 282
    $$$$$:10226-block 283
    $$$$$:10226-block 284
    $$$$$:10226-block 285
        -:10227:    }
     4304:10228:    RenderNavCursor(bb, id);
     4304:10228-block 222
call    0 returned 4304
branch  1 taken 4304 (fallthrough)
branch  2 taken 0 (throw)
        -:10229:
        -:10230:    // Select with right mouse button. This is so the common idiom for context menu automatically highlight the current widget.
     4304:10231:    const bool hovered_unblocked = IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup);
     4304:10231-block 223
call    0 returned 4304
branch  1 taken 4304 (fallthrough)
branch  2 taken 0 (throw)
    4304*:10232:    if (tab_bar->SelectedTabId != tab->ID && hovered_unblocked && (IsMouseClicked(1) || IsMouseReleased(1)) && !is_tab_button)
     4304:10232-block 224
branch  0 taken 0 (fallthrough)
branch  1 taken 4304
    %%%%%:10232-block 225
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:10232-block 226
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    %%%%%:10232-block 227
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%:10232-block 228
call    9 never executed
branch 10 never executed (fallthrough)
branch 11 never executed (throw)
    %%%%%:10232-block 229
branch 12 never executed (fallthrough)
branch 13 never executed
    %%%%%:10232-block 230
branch 14 never executed (fallthrough)
branch 15 never executed
    %%%%%:10232-block 231
     4304:10232-block 232
     4304:10232-block 233
branch 16 taken 0 (fallthrough)
branch 17 taken 4304
    #####:10233:        TabBarQueueFocus(tab_bar, tab);
    %%%%%:10233-block 234
call    0 never executed
        -:10234:
     4304:10235:    if (tab_bar->Flags & ImGuiTabBarFlags_NoCloseWithMiddleMouseButton)
     4304:10235-block 235
branch  0 taken 0 (fallthrough)
branch  1 taken 4304
    #####:10236:        flags |= ImGuiTabItemFlags_NoCloseWithMiddleMouseButton;
    %%%%%:10236-block 236
        -:10237:
        -:10238:    // Render tab label, process close button
    4304*:10239:    const ImGuiID close_button_id = p_open ? GetIDWithSeed("#CLOSE", NULL, docked_window ? docked_window->ID : id) : 0;
     4304:10239-block 237
branch  0 taken 4304 (fallthrough)
branch  1 taken 0
     4304:10239-block 238
branch  2 taken 4304 (fallthrough)
branch  3 taken 0
     4304:10239-block 239
    %%%%%:10239-block 240
     4304:10239-block 241
call    4 returned 4304
branch  5 taken 4304 (fallthrough)
branch  6 taken 0 (throw)
     4304:10239-block 242
    %%%%%:10239-block 243
        -:10240:    bool just_closed;
        -:10241:    bool text_clipped;
    4304*:10242:    TabItemLabelAndCloseButton(display_draw_list, bb, tab_just_unsaved ? (flags & ~ImGuiTabItemFlags_UnsavedDocument) : flags, tab_bar->FramePadding, label, id, close_button_id, tab_contents_visible, &just_closed, &text_clipped);
     4304:10242-block 244
branch  0 taken 0 (fallthrough)
branch  1 taken 4304
    %%%%%:10242-block 245
     4304:10242-block 246
     4304:10242-block 247
call    2 returned 4304
branch  3 taken 4304 (fallthrough)
branch  4 taken 0 (throw)
    4304*:10243:    if (just_closed && p_open != NULL)
     4304:10243-block 248
branch  0 taken 0 (fallthrough)
branch  1 taken 4304
    %%%%%:10243-block 249
branch  2 never executed (fallthrough)
branch  3 never executed
        -:10244:    {
    #####:10245:        *p_open = false;
    #####:10246:        TabBarCloseTab(tab_bar, tab);
    %%%%%:10246-block 250
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:10247:    }
        -:10248:
        -:10249:    // Forward Hovered state so IsItemHovered() after Begin() can work (even though we are technically hovering our parent)
        -:10250:    // That state is copied to window->DockTabItemStatusFlags by our caller.
     4304:10251:    if (docked_window && (hovered || g.HoveredId == close_button_id))
     4304:10251-block 251
branch  0 taken 4304 (fallthrough)
branch  1 taken 0
     4304:10251-block 252
branch  2 taken 4304 (fallthrough)
branch  3 taken 0
     4304:10251-block 253
branch  4 taken 0 (fallthrough)
branch  5 taken 4304
    #####:10252:        g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredWindow;
    %%%%%:10252-block 254
        -:10253:
        -:10254:    // Restore main window position so user can draw there
     4304:10255:    if (want_clip_rect)
     4304:10255-block 255
branch  0 taken 0 (fallthrough)
branch  1 taken 4304
    #####:10256:        PopClipRect();
    %%%%%:10256-block 256
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
     4304:10257:    window->DC.CursorPos = backup_main_cursor_pos;
        -:10258:
        -:10259:    // Tooltip
        -:10260:    // (Won't work over the close button because ItemOverlap systems messes up with HoveredIdTimer-> seems ok)
        -:10261:    // (We test IsItemHovered() to discard e.g. when another item is active or drag and drop over the tab bar, which g.HoveredId ignores)
        -:10262:    // FIXME: This is a mess.
        -:10263:    // FIXME: We may want disabled tab to still display the tooltip?
    4304*:10264:    if (text_clipped && g.HoveredId == id && !held)
     4304:10264-block 257
branch  0 taken 1076 (fallthrough)
branch  1 taken 3228
     1076:10264-block 258
branch  2 taken 0 (fallthrough)
branch  3 taken 1076
    %%%%%:10264-block 259
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:10265:        if (!(tab_bar->Flags & ImGuiTabBarFlags_NoTooltip) && !(tab->Flags & ImGuiTabItemFlags_NoTooltip))
    %%%%%:10265-block 260
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10265-block 261
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:10266:            SetItemTooltip("%.*s", (int)(FindRenderedTextEnd(label) - label), label);
    %%%%%:10266-block 262
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:10266-block 263
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
        -:10267:
    4304*:10268:    IM_ASSERT(!is_tab_button || !(tab_bar->SelectedTabId == tab->ID && is_tab_button)); // TabItemButton should not be selected
     4304:10268-block 264
branch  0 taken 0 (fallthrough)
branch  1 taken 4304
    %%%%%:10268-block 265
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:10268-block 266
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:10268-block 267
call    6 never executed
     4304:10269:    if (is_tab_button)
     4304:10269-block 268
branch  0 taken 0 (fallthrough)
branch  1 taken 4304
    #####:10270:        return pressed;
    %%%%%:10270-block 269
     4304:10271:    return tab_contents_visible;
     4304:10271-block 270
        -:10272:}
        -:10273:
        -:10274:// [Public] This is call is 100% optional but it allows to remove some one-frame glitches when a tab has been unexpectedly removed.
        -:10275:// To use it to need to call the function SetTabItemClosed() between BeginTabBar() and EndTabBar().
        -:10276:// Tabs closed by the close button will automatically be flagged to avoid this issue.
function _ZN5ImGui16SetTabItemClosedEPKc called 0 returned 0% blocks executed 0%
    #####:10277:void    ImGui::SetTabItemClosed(const char* label)
        -:10278:{
    #####:10279:    ImGuiContext& g = *GImGui;
    #####:10280:    bool is_within_manual_tab_bar = g.CurrentTabBar && !(g.CurrentTabBar->Flags & ImGuiTabBarFlags_DockNode);
    %%%%%:10280-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10280-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:10280-block 4
    %%%%%:10280-block 5
    #####:10281:    if (is_within_manual_tab_bar)
    %%%%%:10281-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
        -:10282:    {
    #####:10283:        ImGuiTabBar* tab_bar = g.CurrentTabBar;
    #####:10284:        ImGuiID tab_id = TabBarCalcTabID(tab_bar, label, NULL);
    %%%%%:10284-block 7
call    0 never executed
    #####:10285:        if (ImGuiTabItem* tab = TabBarFindTabByID(tab_bar, tab_id))
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:10286:            tab->WantClose = true; // Will be processed by next call to TabBarLayout()
    %%%%%:10286-block 10
        -:10287:    }
    #####:10288:    else if (ImGuiWindow* window = FindWindowByName(label))
    %%%%%:10288-block 11
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -:10289:    {
    #####:10290:        if (window->DockIsActive)
    %%%%%:10290-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:10291:            if (ImGuiDockNode* node = window->DockNode)
    %%%%%:10291-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
        -:10292:            {
    #####:10293:                ImGuiID tab_id = TabBarCalcTabID(node->TabBar, label, window);
    %%%%%:10293-block 15
call    0 never executed
    #####:10294:                TabBarRemoveTab(node->TabBar, tab_id);
call    0 never executed
    #####:10295:                window->DockTabWantClose = true;
        -:10296:            }
        -:10297:    }
    #####:10298:}
        -:10299:
function _ZN5ImGui15TabItemCalcSizeEPKcb called 10760 returned 100% blocks executed 100%
    10760:10300:ImVec2 ImGui::TabItemCalcSize(const char* label, bool has_close_button_or_unsaved_marker)
        -:10301:{
    10760:10302:    ImGuiContext& g = *GImGui;
    10760:10303:    ImVec2 label_size = CalcTextSize(label, NULL, true);
    10760:10303-block 2
call    0 returned 10760
branch  1 taken 10760 (fallthrough)
branch  2 taken 0 (throw)
    10760:10304:    ImVec2 size = ImVec2(label_size.x + g.Style.FramePadding.x, label_size.y + g.Style.FramePadding.y * 2.0f);
    10760:10304-block 3
call    0 returned 10760
    10760:10305:    if (has_close_button_or_unsaved_marker)
branch  0 taken 10755 (fallthrough)
branch  1 taken 5
    10755:10306:        size.x += g.Style.FramePadding.x + (g.Style.ItemInnerSpacing.x + g.FontSize); // We use Y intentionally to fit the close button circle.
    10755:10306-block 5
        -:10307:    else
        5:10308:        size.x += g.Style.FramePadding.x + 1.0f;
        5:10308-block 6
    10760:10309:    return ImVec2(ImMin(size.x, TabBarCalcMaxTabWidth()), size.y);
    10760:10309-block 7
call    0 returned 10760
call    1 returned 10760
call    2 returned 10760
    10760:10309-block 11
    10760:10309-block 12
        -:10310:}
        -:10311:
function _ZN5ImGui15TabItemCalcSizeEP11ImGuiWindow called 0 returned 0% blocks executed 0%
    #####:10312:ImVec2 ImGui::TabItemCalcSize(ImGuiWindow* window)
        -:10313:{
    #####:10314:    return TabItemCalcSize(window->Name, window->HasCloseButton || (window->Flags & ImGuiWindowFlags_UnsavedDocument));
    %%%%%:10314-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10314-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:10314-block 4
    %%%%%:10314-block 5
    %%%%%:10314-block 6
call    4 never executed
        -:10315:}
        -:10316:
function _ZN5ImGui17TabItemBackgroundEP10ImDrawListRK6ImRectij called 4304 returned 100% blocks executed 49%
     4304:10317:void ImGui::TabItemBackground(ImDrawList* draw_list, const ImRect& bb, ImGuiTabItemFlags flags, ImU32 col)
        -:10318:{
        -:10319:    // While rendering tabs, we trim 1 pixel off the top of our bounding box so they can fit within a regular frame height while looking "detached" from it.
     4304:10320:    ImGuiContext& g = *GImGui;
     4304:10321:    const float width = bb.GetWidth();
     4304:10321-block 2
call    0 returned 4304
        -:10322:    IM_UNUSED(flags);
    4304*:10323:    IM_ASSERT(width > 0.0f);
branch  0 taken 0 (fallthrough)
branch  1 taken 4304
    %%%%%:10323-block 4
call    2 never executed
    4304*:10324:    const float rounding = ImMax(0.0f, ImMin((flags & ImGuiTabItemFlags_Button) ? g.Style.FrameRounding : g.Style.TabRounding, width * 0.5f - 1.0f));
     4304:10324-block 5
branch  0 taken 0 (fallthrough)
branch  1 taken 4304
    %%%%%:10324-block 6
     4304:10324-block 7
     4304:10324-block 8
call    2 returned 4304
call    3 returned 4304
     4304:10325:    const float y1 = bb.Min.y + 1.0f;
     4304:10326:    const float y2 = bb.Max.y - g.Style.TabBarBorderSize;
     4304:10327:    draw_list->PathLineTo(ImVec2(bb.Min.x, y2));
call    0 returned 4304
call    1 returned 4304
branch  2 taken 4304 (fallthrough)
branch  3 taken 0 (throw)
    $$$$$:10327-block 31
call    4 never executed
     4304:10328:    draw_list->PathArcToFast(ImVec2(bb.Min.x + rounding, y1 + rounding), rounding, 6, 9);
     4304:10328-block 12
call    0 returned 4304
call    1 returned 4304
branch  2 taken 4304 (fallthrough)
branch  3 taken 0 (throw)
    $$$$$:10328-block 32
call    4 never executed
     4304:10329:    draw_list->PathArcToFast(ImVec2(bb.Max.x - rounding, y1 + rounding), rounding, 9, 12);
     4304:10329-block 14
call    0 returned 4304
call    1 returned 4304
branch  2 taken 4304 (fallthrough)
branch  3 taken 0 (throw)
    $$$$$:10329-block 33
call    4 never executed
     4304:10330:    draw_list->PathLineTo(ImVec2(bb.Max.x, y2));
     4304:10330-block 16
call    0 returned 4304
call    1 returned 4304
branch  2 taken 4304 (fallthrough)
branch  3 taken 0 (throw)
    $$$$$:10330-block 34
call    4 never executed
     4304:10331:    draw_list->PathFillConvex(col);
     4304:10331-block 18
call    0 returned 4304
     4304:10332:    if (g.Style.TabBorderSize > 0.0f)
branch  0 taken 0 (fallthrough)
branch  1 taken 4304
        -:10333:    {
    #####:10334:        draw_list->PathLineTo(ImVec2(bb.Min.x + 0.5f, y2));
    %%%%%:10334-block 20
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$:10334-block 35
call    4 never executed
    #####:10335:        draw_list->PathArcToFast(ImVec2(bb.Min.x + rounding + 0.5f, y1 + rounding + 0.5f), rounding, 6, 9);
    %%%%%:10335-block 22
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$:10335-block 36
call    4 never executed
    #####:10336:        draw_list->PathArcToFast(ImVec2(bb.Max.x - rounding - 0.5f, y1 + rounding + 0.5f), rounding, 9, 12);
    %%%%%:10336-block 24
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$:10336-block 37
call    4 never executed
    #####:10337:        draw_list->PathLineTo(ImVec2(bb.Max.x - 0.5f, y2));
    %%%%%:10337-block 26
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####:10338:        draw_list->PathStroke(GetColorU32(ImGuiCol_Border), 0, g.Style.TabBorderSize);
    %%%%%:10338-block 28
call    0 never executed
call    1 never executed
        -:10339:    }
     4304:10340:}
     4304:10340-block 30
        -:10341:
        -:10342:// Render text label (with custom clipping) + Unsaved Document marker + Close Button logic
        -:10343:// We tend to lock style.FramePadding for a given tab-bar, hence the 'frame_padding' parameter.
function _ZN5ImGui26TabItemLabelAndCloseButtonEP10ImDrawListRK6ImRecti6ImVec2PKcjjbPbS8_ called 4304 returned 100% blocks executed 49%
     4304:10344:void ImGui::TabItemLabelAndCloseButton(ImDrawList* draw_list, const ImRect& bb, ImGuiTabItemFlags flags, ImVec2 frame_padding, const char* label, ImGuiID tab_id, ImGuiID close_button_id, bool is_contents_visible, bool* out_just_closed, bool* out_text_clipped)
        -:10345:{
     4304:10346:    ImGuiContext& g = *GImGui;
     4304:10347:    ImVec2 label_size = CalcTextSize(label, NULL, true);
     4304:10347-block 2
call    0 returned 4304
branch  1 taken 4304 (fallthrough)
branch  2 taken 0 (throw)
        -:10348:
     4304:10349:    if (out_just_closed)
     4304:10349-block 3
branch  0 taken 4304 (fallthrough)
branch  1 taken 0
     4304:10350:        *out_just_closed = false;
     4304:10350-block 4
     4304:10351:    if (out_text_clipped)
     4304:10351-block 5
branch  0 taken 4304 (fallthrough)
branch  1 taken 0
     4304:10352:        *out_text_clipped = false;
     4304:10352-block 6
        -:10353:
     4304:10354:    if (bb.GetWidth() <= 1.0f)
     4304:10354-block 7
call    0 returned 4304
branch  1 taken 0 (fallthrough)
branch  2 taken 4304
    #####:10355:        return;
    %%%%%:10355-block 9
        -:10356:
        -:10357:    // In Style V2 we'll have full override of all colors per state (e.g. focused, selected)
        -:10358:    // But right now if you want to alter text color of tabs this is what you need to do.
        -:10359:#if 0
        -:10360:    const float backup_alpha = g.Style.Alpha;
        -:10361:    if (!is_contents_visible)
        -:10362:        g.Style.Alpha *= 0.7f;
        -:10363:#endif
        -:10364:
        -:10365:    // Render text label (with clipping + alpha gradient) + unsaved marker
     4304:10366:    ImRect text_pixel_clip_bb(bb.Min.x + frame_padding.x, bb.Min.y + frame_padding.y, bb.Max.x - frame_padding.x, bb.Max.y);
     4304:10366-block 10
call    0 returned 4304
     4304:10367:    ImRect text_ellipsis_clip_bb = text_pixel_clip_bb;
        -:10368:
        -:10369:    // Return clipped state ignoring the close button
     4304:10370:    if (out_text_clipped)
branch  0 taken 4304 (fallthrough)
branch  1 taken 0
        -:10371:    {
     4304:10372:        *out_text_clipped = (text_ellipsis_clip_bb.Min.x + label_size.x) > text_pixel_clip_bb.Max.x;
     4304:10372-block 12
        -:10373:        //draw_list->AddCircle(text_ellipsis_clip_bb.Min, 3.0f, *out_text_clipped ? IM_COL32(255, 0, 0, 255) : IM_COL32(0, 255, 0, 255));
        -:10374:    }
        -:10375:
     4304:10376:    const float button_sz = g.FontSize;
     4304:10377:    const ImVec2 button_pos(ImMax(bb.Min.x, bb.Max.x - frame_padding.x - button_sz), bb.Min.y + frame_padding.y);
     4304:10377-block 13
call    0 returned 4304
call    1 returned 4304
        -:10378:
        -:10379:    // Close Button & Unsaved Marker
        -:10380:    // We are relying on a subtle and confusing distinction between 'hovered' and 'g.HoveredId' which happens because we are using ImGuiButtonFlags_AllowOverlapMode + SetItemAllowOverlap()
        -:10381:    //  'hovered' will be true when hovering the Tab but NOT when hovering the close button
        -:10382:    //  'g.HoveredId==id' will be true when hovering the Tab including when hovering the close button
        -:10383:    //  'g.ActiveId==close_button_id' will be true when we are holding on the close button, in which case both hovered booleans are false
     4304:10384:    bool close_button_pressed = false;
     4304:10385:    bool close_button_visible = false;
     4304:10386:    if (close_button_id != 0)
branch  0 taken 4304 (fallthrough)
branch  1 taken 0
    4304*:10387:        if (is_contents_visible || bb.GetWidth() >= ImMax(button_sz, g.Style.TabMinWidthForCloseButton))
     4304:10387-block 16
branch  0 taken 0 (fallthrough)
branch  1 taken 4304
    %%%%%:10387-block 17
call    2 never executed
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
     4304:10387-block 20
    %%%%%:10387-block 21
     4304:10387-block 22
branch  6 taken 4304 (fallthrough)
branch  7 taken 0
     4304:10388:            if (g.HoveredId == tab_id || g.HoveredId == close_button_id || g.ActiveId == tab_id || g.ActiveId == close_button_id)
     4304:10388-block 23
branch  0 taken 4304 (fallthrough)
branch  1 taken 0
     4304:10388-block 24
branch  2 taken 4304 (fallthrough)
branch  3 taken 0
     4304:10388-block 25
branch  4 taken 4304 (fallthrough)
branch  5 taken 0
     4304:10388-block 26
branch  6 taken 0 (fallthrough)
branch  7 taken 4304
    #####:10389:                close_button_visible = true;
    %%%%%:10389-block 27
    4304*:10390:    bool unsaved_marker_visible = (flags & ImGuiTabItemFlags_UnsavedDocument) != 0 && (button_pos.x + button_sz <= bb.Max.x);
     4304:10390-block 28
branch  0 taken 0 (fallthrough)
branch  1 taken 4304
    %%%%%:10390-block 29
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:10390-block 30
     4304:10390-block 31
        -:10391:
     4304:10392:    if (close_button_visible)
     4304:10392-block 32
branch  0 taken 0 (fallthrough)
branch  1 taken 4304
        -:10393:    {
    #####:10394:        ImGuiLastItemData last_item_backup = g.LastItemData;
    #####:10395:        if (CloseButton(close_button_id, button_pos))
    %%%%%:10395-block 33
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:10395-block 34
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:10396:            close_button_pressed = true;
    %%%%%:10396-block 35
    #####:10397:        g.LastItemData = last_item_backup;
        -:10398:
        -:10399:        // Close with middle mouse button
    #####:10400:        if (!(flags & ImGuiTabItemFlags_NoCloseWithMiddleMouseButton) && IsMouseClicked(2))
    %%%%%:10400-block 36
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10400-block 37
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%:10400-block 38
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:10400-block 39
    %%%%%:10400-block 40
    %%%%%:10400-block 41
branch  7 never executed (fallthrough)
branch  8 never executed
    #####:10401:            close_button_pressed = true;
    %%%%%:10401-block 42
        -:10402:    }
     4304:10403:    else if (unsaved_marker_visible)
     4304:10403-block 44
branch  0 taken 0 (fallthrough)
branch  1 taken 4304
        -:10404:    {
    #####:10405:        const ImRect bullet_bb(button_pos, button_pos + ImVec2(button_sz, button_sz));
    %%%%%:10405-block 45
call    0 never executed
call    1 never executed
call    2 never executed
    #####:10406:        RenderBullet(draw_list, bullet_bb.GetCenter(), GetColorU32(ImGuiCol_Text));
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:10406-block 49
call    3 never executed
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
        -:10407:    }
        -:10408:
        -:10409:    // This is all rather complicated
        -:10410:    // (the main idea is that because the close button only appears on hover, we don't want it to alter the ellipsis position)
        -:10411:    // FIXME: if FramePadding is noticeably large, ellipsis_max_x will be wrong here (e.g. #3497), maybe for consistency that parameter of RenderTextEllipsis() shouldn't exist..
    4304*:10412:    float ellipsis_max_x = close_button_visible ? text_pixel_clip_bb.Max.x : bb.Max.x - 1.0f;
     4304:10412-block 52
branch  0 taken 0 (fallthrough)
branch  1 taken 4304
    %%%%%:10412-block 53
     4304:10412-block 54
     4304:10413:    if (close_button_visible || unsaved_marker_visible)
     4304:10413-block 55
branch  0 taken 4304 (fallthrough)
branch  1 taken 0
     4304:10413-block 56
branch  2 taken 0 (fallthrough)
branch  3 taken 4304
        -:10414:    {
    #####:10415:        text_pixel_clip_bb.Max.x -= close_button_visible ? (button_sz) : (button_sz * 0.80f);
    %%%%%:10415-block 57
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10415-block 58
    %%%%%:10415-block 59
    #####:10416:        text_ellipsis_clip_bb.Max.x -= unsaved_marker_visible ? (button_sz * 0.80f) : 0.0f;
    %%%%%:10416-block 60
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:10416-block 61
    %%%%%:10416-block 62
    #####:10417:        ellipsis_max_x = text_pixel_clip_bb.Max.x;
    %%%%%:10417-block 63
        -:10418:    }
     4304:10419:    RenderTextEllipsis(draw_list, text_ellipsis_clip_bb.Min, text_ellipsis_clip_bb.Max, text_pixel_clip_bb.Max.x, ellipsis_max_x, label, NULL, &label_size);
     4304:10419-block 64
call    0 returned 4304
branch  1 taken 4304 (fallthrough)
branch  2 taken 0 (throw)
        -:10420:
        -:10421:#if 0
        -:10422:    if (!is_contents_visible)
        -:10423:        g.Style.Alpha = backup_alpha;
        -:10424:#endif
        -:10425:
     4304:10426:    if (out_just_closed)
     4304:10426-block 65
branch  0 taken 4304 (fallthrough)
branch  1 taken 0
     4304:10427:        *out_just_closed = close_button_pressed;
     4304:10427-block 66
        -:10428:}
        -:10429:
        -:10430:
        -:10431:#endif // #ifndef IMGUI_DISABLE
