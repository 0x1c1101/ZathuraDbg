        -:    0:Source:/home/rc/ZathuraDbg/vendor/imgui/imgui_tables.cpp
        -:    0:Graph:/home/rc/ZathuraDbg/src/cmake-build-debug-coverage/CMakeFiles/Zathura.dir/home/rc/ZathuraDbg/vendor/imgui/imgui_tables.cpp.gcno
        -:    0:Data:/home/rc/ZathuraDbg/src/cmake-build-debug-coverage/CMakeFiles/Zathura.dir/home/rc/ZathuraDbg/vendor/imgui/imgui_tables.cpp.gcda
        -:    0:Runs:1
        -:    1:// dear imgui, v1.91.4
        -:    2:// (tables and columns code)
        -:    3:
        -:    4:/*
        -:    5:
        -:    6:Index of this file:
        -:    7:
        -:    8:// [SECTION] Commentary
        -:    9:// [SECTION] Header mess
        -:   10:// [SECTION] Tables: Main code
        -:   11:// [SECTION] Tables: Simple accessors
        -:   12:// [SECTION] Tables: Row changes
        -:   13:// [SECTION] Tables: Columns changes
        -:   14:// [SECTION] Tables: Columns width management
        -:   15:// [SECTION] Tables: Drawing
        -:   16:// [SECTION] Tables: Sorting
        -:   17:// [SECTION] Tables: Headers
        -:   18:// [SECTION] Tables: Context Menu
        -:   19:// [SECTION] Tables: Settings (.ini data)
        -:   20:// [SECTION] Tables: Garbage Collection
        -:   21:// [SECTION] Tables: Debugging
        -:   22:// [SECTION] Columns, BeginColumns, EndColumns, etc.
        -:   23:
        -:   24:*/
        -:   25:
        -:   26:// Navigating this file:
        -:   27:// - In Visual Studio: CTRL+comma ("Edit.GoToAll") can follow symbols inside comments, whereas CTRL+F12 ("Edit.GoToImplementation") cannot.
        -:   28:// - In Visual Studio w/ Visual Assist installed: ALT+G ("VAssistX.GoToImplementation") can also follow symbols inside comments.
        -:   29:// - In VS Code, CLion, etc.: CTRL+click can follow symbols inside comments.
        -:   30:
        -:   31://-----------------------------------------------------------------------------
        -:   32:// [SECTION] Commentary
        -:   33://-----------------------------------------------------------------------------
        -:   34:
        -:   35://-----------------------------------------------------------------------------
        -:   36:// Typical tables call flow: (root level is generally public API):
        -:   37://-----------------------------------------------------------------------------
        -:   38:// - BeginTable()                               user begin into a table
        -:   39://    | BeginChild()                            - (if ScrollX/ScrollY is set)
        -:   40://    | TableBeginInitMemory()                  - first time table is used
        -:   41://    | TableResetSettings()                    - on settings reset
        -:   42://    | TableLoadSettings()                     - on settings load
        -:   43://    | TableBeginApplyRequests()               - apply queued resizing/reordering/hiding requests
        -:   44://    | - TableSetColumnWidth()                 - apply resizing width (for mouse resize, often requested by previous frame)
        -:   45://    |    - TableUpdateColumnsWeightFromWidth()- recompute columns weights (of stretch columns) from their respective width
        -:   46:// - TableSetupColumn()                         user submit columns details (optional)
        -:   47:// - TableSetupScrollFreeze()                   user submit scroll freeze information (optional)
        -:   48://-----------------------------------------------------------------------------
        -:   49:// - TableUpdateLayout() [Internal]             followup to BeginTable(): setup everything: widths, columns positions, clipping rectangles. Automatically called by the FIRST call to TableNextRow() or TableHeadersRow().
        -:   50://    | TableSetupDrawChannels()                - setup ImDrawList channels
        -:   51://    | TableUpdateBorders()                    - detect hovering columns for resize, ahead of contents submission
        -:   52://    | TableBeginContextMenuPopup()
        -:   53://    | - TableDrawDefaultContextMenu()         - draw right-click context menu contents
        -:   54://-----------------------------------------------------------------------------
        -:   55:// - TableHeadersRow() or TableHeader()         user submit a headers row (optional)
        -:   56://    | TableSortSpecsClickColumn()             - when left-clicked: alter sort order and sort direction
        -:   57://    | TableOpenContextMenu()                  - when right-clicked: trigger opening of the default context menu
        -:   58:// - TableGetSortSpecs()                        user queries updated sort specs (optional, generally after submitting headers)
        -:   59:// - TableNextRow()                             user begin into a new row (also automatically called by TableHeadersRow())
        -:   60://    | TableEndRow()                           - finish existing row
        -:   61://    | TableBeginRow()                         - add a new row
        -:   62:// - TableSetColumnIndex() / TableNextColumn()  user begin into a cell
        -:   63://    | TableEndCell()                          - close existing column/cell
        -:   64://    | TableBeginCell()                        - enter into current column/cell
        -:   65:// - [...]                                      user emit contents
        -:   66://-----------------------------------------------------------------------------
        -:   67:// - EndTable()                                 user ends the table
        -:   68://    | TableDrawBorders()                      - draw outer borders, inner vertical borders
        -:   69://    | TableMergeDrawChannels()                - merge draw channels if clipping isn't required
        -:   70://    | EndChild()                              - (if ScrollX/ScrollY is set)
        -:   71://-----------------------------------------------------------------------------
        -:   72:
        -:   73://-----------------------------------------------------------------------------
        -:   74:// TABLE SIZING
        -:   75://-----------------------------------------------------------------------------
        -:   76:// (Read carefully because this is subtle but it does make sense!)
        -:   77://-----------------------------------------------------------------------------
        -:   78:// About 'outer_size':
        -:   79:// Its meaning needs to differ slightly depending on if we are using ScrollX/ScrollY flags.
        -:   80:// Default value is ImVec2(0.0f, 0.0f).
        -:   81://   X
        -:   82://   - outer_size.x <= 0.0f  ->  Right-align from window/work-rect right-most edge. With -FLT_MIN or 0.0f will align exactly on right-most edge.
        -:   83://   - outer_size.x  > 0.0f  ->  Set Fixed width.
        -:   84://   Y with ScrollX/ScrollY disabled: we output table directly in current window
        -:   85://   - outer_size.y  < 0.0f  ->  Bottom-align (but will auto extend, unless _NoHostExtendY is set). Not meaningful if parent window can vertically scroll.
        -:   86://   - outer_size.y  = 0.0f  ->  No minimum height (but will auto extend, unless _NoHostExtendY is set)
        -:   87://   - outer_size.y  > 0.0f  ->  Set Minimum height (but will auto extend, unless _NoHostExtendY is set)
        -:   88://   Y with ScrollX/ScrollY enabled: using a child window for scrolling
        -:   89://   - outer_size.y  < 0.0f  ->  Bottom-align. Not meaningful if parent window can vertically scroll.
        -:   90://   - outer_size.y  = 0.0f  ->  Bottom-align, consistent with BeginChild(). Not recommended unless table is last item in parent window.
        -:   91://   - outer_size.y  > 0.0f  ->  Set Exact height. Recommended when using Scrolling on any axis.
        -:   92://-----------------------------------------------------------------------------
        -:   93:// Outer size is also affected by the NoHostExtendX/NoHostExtendY flags.
        -:   94:// Important to note how the two flags have slightly different behaviors!
        -:   95://   - ImGuiTableFlags_NoHostExtendX -> Make outer width auto-fit to columns (overriding outer_size.x value). Only available when ScrollX/ScrollY are disabled and Stretch columns are not used.
        -:   96://   - ImGuiTableFlags_NoHostExtendY -> Make outer height stop exactly at outer_size.y (prevent auto-extending table past the limit). Only available when ScrollX/ScrollY is disabled. Data below the limit will be clipped and not visible.
        -:   97:// In theory ImGuiTableFlags_NoHostExtendY could be the default and any non-scrolling tables with outer_size.y != 0.0f would use exact height.
        -:   98:// This would be consistent but perhaps less useful and more confusing (as vertically clipped items are not useful and not easily noticeable).
        -:   99://-----------------------------------------------------------------------------
        -:  100:// About 'inner_width':
        -:  101://   With ScrollX disabled:
        -:  102://   - inner_width          ->  *ignored*
        -:  103://   With ScrollX enabled:
        -:  104://   - inner_width  < 0.0f  ->  *illegal* fit in known width (right align from outer_size.x) <-- weird
        -:  105://   - inner_width  = 0.0f  ->  fit in outer_width: Fixed size columns will take space they need (if avail, otherwise shrink down), Stretch columns becomes Fixed columns.
        -:  106://   - inner_width  > 0.0f  ->  override scrolling width, generally to be larger than outer_size.x. Fixed column take space they need (if avail, otherwise shrink down), Stretch columns share remaining space!
        -:  107://-----------------------------------------------------------------------------
        -:  108:// Details:
        -:  109:// - If you want to use Stretch columns with ScrollX, you generally need to specify 'inner_width' otherwise the concept
        -:  110://   of "available space" doesn't make sense.
        -:  111:// - Even if not really useful, we allow 'inner_width < outer_size.x' for consistency and to facilitate understanding
        -:  112://   of what the value does.
        -:  113://-----------------------------------------------------------------------------
        -:  114:
        -:  115://-----------------------------------------------------------------------------
        -:  116:// COLUMNS SIZING POLICIES
        -:  117:// (Reference: ImGuiTableFlags_SizingXXX flags and ImGuiTableColumnFlags_WidthXXX flags)
        -:  118://-----------------------------------------------------------------------------
        -:  119:// About overriding column sizing policy and width/weight with TableSetupColumn():
        -:  120:// We use a default parameter of -1 for 'init_width'/'init_weight'.
        -:  121://   - with ImGuiTableColumnFlags_WidthFixed,    init_width  <= 0 (default)  --> width is automatic
        -:  122://   - with ImGuiTableColumnFlags_WidthFixed,    init_width  >  0 (explicit) --> width is custom
        -:  123://   - with ImGuiTableColumnFlags_WidthStretch,  init_weight <= 0 (default)  --> weight is 1.0f
        -:  124://   - with ImGuiTableColumnFlags_WidthStretch,  init_weight >  0 (explicit) --> weight is custom
        -:  125:// Widths are specified _without_ CellPadding. If you specify a width of 100.0f, the column will be cover (100.0f + Padding * 2.0f)
        -:  126:// and you can fit a 100.0f wide item in it without clipping and with padding honored.
        -:  127://-----------------------------------------------------------------------------
        -:  128:// About default sizing policy (if you don't specify a ImGuiTableColumnFlags_WidthXXXX flag)
        -:  129://   - with Table policy ImGuiTableFlags_SizingFixedFit      --> default Column policy is ImGuiTableColumnFlags_WidthFixed, default Width is equal to contents width
        -:  130://   - with Table policy ImGuiTableFlags_SizingFixedSame     --> default Column policy is ImGuiTableColumnFlags_WidthFixed, default Width is max of all contents width
        -:  131://   - with Table policy ImGuiTableFlags_SizingStretchSame   --> default Column policy is ImGuiTableColumnFlags_WidthStretch, default Weight is 1.0f
        -:  132://   - with Table policy ImGuiTableFlags_SizingStretchWeight --> default Column policy is ImGuiTableColumnFlags_WidthStretch, default Weight is proportional to contents
        -:  133:// Default Width and default Weight can be overridden when calling TableSetupColumn().
        -:  134://-----------------------------------------------------------------------------
        -:  135:// About mixing Fixed/Auto and Stretch columns together:
        -:  136://   - the typical use of mixing sizing policies is: any number of LEADING Fixed columns, followed by one or two TRAILING Stretch columns.
        -:  137://   - using mixed policies with ScrollX does not make much sense, as using Stretch columns with ScrollX does not make much sense in the first place!
        -:  138://     that is, unless 'inner_width' is passed to BeginTable() to explicitly provide a total width to layout columns in.
        -:  139://   - when using ImGuiTableFlags_SizingFixedSame with mixed columns, only the Fixed/Auto columns will match their widths to the width of the maximum contents.
        -:  140://   - when using ImGuiTableFlags_SizingStretchSame with mixed columns, only the Stretch columns will match their weights/widths.
        -:  141://-----------------------------------------------------------------------------
        -:  142:// About using column width:
        -:  143:// If a column is manually resizable or has a width specified with TableSetupColumn():
        -:  144://   - you may use GetContentRegionAvail().x to query the width available in a given column.
        -:  145://   - right-side alignment features such as SetNextItemWidth(-x) or PushItemWidth(-x) will rely on this width.
        -:  146:// If the column is not resizable and has no width specified with TableSetupColumn():
        -:  147://   - its width will be automatic and be set to the max of items submitted.
        -:  148://   - therefore you generally cannot have ALL items of the columns use e.g. SetNextItemWidth(-FLT_MIN).
        -:  149://   - but if the column has one or more items of known/fixed size, this will become the reference width used by SetNextItemWidth(-FLT_MIN).
        -:  150://-----------------------------------------------------------------------------
        -:  151:
        -:  152:
        -:  153://-----------------------------------------------------------------------------
        -:  154:// TABLES CLIPPING/CULLING
        -:  155://-----------------------------------------------------------------------------
        -:  156:// About clipping/culling of Rows in Tables:
        -:  157:// - For large numbers of rows, it is recommended you use ImGuiListClipper to submit only visible rows.
        -:  158://   ImGuiListClipper is reliant on the fact that rows are of equal height.
        -:  159://   See 'Demo->Tables->Vertical Scrolling' or 'Demo->Tables->Advanced' for a demo of using the clipper.
        -:  160:// - Note that auto-resizing columns don't play well with using the clipper.
        -:  161://   By default a table with _ScrollX but without _Resizable will have column auto-resize.
        -:  162://   So, if you want to use the clipper, make sure to either enable _Resizable, either setup columns width explicitly with _WidthFixed.
        -:  163://-----------------------------------------------------------------------------
        -:  164:// About clipping/culling of Columns in Tables:
        -:  165:// - Both TableSetColumnIndex() and TableNextColumn() return true when the column is visible or performing
        -:  166://   width measurements. Otherwise, you may skip submitting the contents of a cell/column, BUT ONLY if you know
        -:  167://   it is not going to contribute to row height.
        -:  168://   In many situations, you may skip submitting contents for every column but one (e.g. the first one).
        -:  169:// - Case A: column is not hidden by user, and at least partially in sight (most common case).
        -:  170:// - Case B: column is clipped / out of sight (because of scrolling or parent ClipRect): TableNextColumn() return false as a hint but we still allow layout output.
        -:  171:// - Case C: column is hidden explicitly by the user (e.g. via the context menu, or _DefaultHide column flag, etc.).
        -:  172://
        -:  173://                        [A]         [B]          [C]
        -:  174://  TableNextColumn():    true        false        false       -> [userland] when TableNextColumn() / TableSetColumnIndex() returns false, user can skip submitting items but only if the column doesn't contribute to row height.
        -:  175://          SkipItems:    false       false        true        -> [internal] when SkipItems is true, most widgets will early out if submitted, resulting is no layout output.
        -:  176://           ClipRect:    normal      zero-width   zero-width  -> [internal] when ClipRect is zero, ItemAdd() will return false and most widgets will early out mid-way.
        -:  177://  ImDrawList output:    normal      dummy        dummy       -> [internal] when using the dummy channel, ImDrawList submissions (if any) will be wasted (because cliprect is zero-width anyway).
        -:  178://
        -:  179:// - We need to distinguish those cases because non-hidden columns that are clipped outside of scrolling bounds should still contribute their height to the row.
        -:  180://   However, in the majority of cases, the contribution to row height is the same for all columns, or the tallest cells are known by the programmer.
        -:  181://-----------------------------------------------------------------------------
        -:  182:// About clipping/culling of whole Tables:
        -:  183:// - Scrolling tables with a known outer size can be clipped earlier as BeginTable() will return false.
        -:  184://-----------------------------------------------------------------------------
        -:  185:
        -:  186://-----------------------------------------------------------------------------
        -:  187:// [SECTION] Header mess
        -:  188://-----------------------------------------------------------------------------
        -:  189:
        -:  190:#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
        -:  191:#define _CRT_SECURE_NO_WARNINGS
        -:  192:#endif
        -:  193:
        -:  194:#ifndef IMGUI_DEFINE_MATH_OPERATORS
        -:  195:#define IMGUI_DEFINE_MATH_OPERATORS
        -:  196:#endif
        -:  197:
        -:  198:#include "imgui.h"
        -:  199:#ifndef IMGUI_DISABLE
        -:  200:#include "imgui_internal.h"
        -:  201:
        -:  202:// System includes
        -:  203:#include <stdint.h>     // intptr_t
        -:  204:
        -:  205:// Visual Studio warnings
        -:  206:#ifdef _MSC_VER
        -:  207:#pragma warning (disable: 4127)     // condition expression is constant
        -:  208:#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen
        -:  209:#if defined(_MSC_VER) && _MSC_VER >= 1922 // MSVC 2019 16.2 or later
        -:  210:#pragma warning (disable: 5054)     // operator '|': deprecated between enumerations of different types
        -:  211:#endif
        -:  212:#pragma warning (disable: 26451)    // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to a 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).
        -:  213:#pragma warning (disable: 26812)    // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3).
        -:  214:#endif
        -:  215:
        -:  216:// Clang/GCC warnings with -Weverything
        -:  217:#if defined(__clang__)
        -:  218:#if __has_warning("-Wunknown-warning-option")
        -:  219:#pragma clang diagnostic ignored "-Wunknown-warning-option"         // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!
        -:  220:#endif
        -:  221:#pragma clang diagnostic ignored "-Wunknown-pragmas"                // warning: unknown warning group 'xxx'
        -:  222:#pragma clang diagnostic ignored "-Wold-style-cast"                 // warning: use of old-style cast                            // yes, they are more terse.
        -:  223:#pragma clang diagnostic ignored "-Wfloat-equal"                    // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants (typically 0.0f) is ok.
        -:  224:#pragma clang diagnostic ignored "-Wformat-nonliteral"              // warning: format string is not a string literal            // passing non-literal to vsnformat(). yes, user passing incorrect format strings can crash the code.
        -:  225:#pragma clang diagnostic ignored "-Wsign-conversion"                // warning: implicit conversion changes signedness
        -:  226:#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"  // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0
        -:  227:#pragma clang diagnostic ignored "-Wdouble-promotion"               // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.
        -:  228:#pragma clang diagnostic ignored "-Wenum-enum-conversion"           // warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_')
        -:  229:#pragma clang diagnostic ignored "-Wdeprecated-enum-enum-conversion"// warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_') is deprecated
        -:  230:#pragma clang diagnostic ignored "-Wimplicit-int-float-conversion"  // warning: implicit conversion from 'xxx' to 'float' may lose precision
        -:  231:#pragma clang diagnostic ignored "-Wunsafe-buffer-usage"            // warning: 'xxx' is an unsafe pointer used for buffer access
        -:  232:#elif defined(__GNUC__)
        -:  233:#pragma GCC diagnostic ignored "-Wpragmas"                          // warning: unknown option after '#pragma GCC diagnostic' kind
        -:  234:#pragma GCC diagnostic ignored "-Wformat-nonliteral"                // warning: format not a string literal, format string not checked
        -:  235:#pragma GCC diagnostic ignored "-Wclass-memaccess"                  // [__GNUC__ >= 8] warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead
        -:  236:#endif
        -:  237:
        -:  238://-----------------------------------------------------------------------------
        -:  239:// [SECTION] Tables: Main code
        -:  240://-----------------------------------------------------------------------------
        -:  241:// - TableFixFlags() [Internal]
        -:  242:// - TableFindByID() [Internal]
        -:  243:// - BeginTable()
        -:  244:// - BeginTableEx() [Internal]
        -:  245:// - TableBeginInitMemory() [Internal]
        -:  246:// - TableBeginApplyRequests() [Internal]
        -:  247:// - TableSetupColumnFlags() [Internal]
        -:  248:// - TableUpdateLayout() [Internal]
        -:  249:// - TableUpdateBorders() [Internal]
        -:  250:// - EndTable()
        -:  251:// - TableSetupColumn()
        -:  252:// - TableSetupScrollFreeze()
        -:  253://-----------------------------------------------------------------------------
        -:  254:
        -:  255:// Configuration
        -:  256:static const int TABLE_DRAW_CHANNEL_BG0 = 0;
        -:  257:static const int TABLE_DRAW_CHANNEL_BG2_FROZEN = 1;
        -:  258:static const int TABLE_DRAW_CHANNEL_NOCLIP = 2;                     // When using ImGuiTableFlags_NoClip (this becomes the last visible channel)
        -:  259:static const float TABLE_BORDER_SIZE                     = 1.0f;    // FIXME-TABLE: Currently hard-coded because of clipping assumptions with outer borders rendering.
        -:  260:static const float TABLE_RESIZE_SEPARATOR_HALF_THICKNESS = 4.0f;    // Extend outside inner borders.
        -:  261:static const float TABLE_RESIZE_SEPARATOR_FEEDBACK_TIMER = 0.06f;   // Delay/timer before making the hover feedback (color+cursor) visible because tables/columns tends to be more cramped.
        -:  262:
        -:  263:// Helper
function _Z13TableFixFlagsiP11ImGuiWindow called 1077 returned 100% blocks executed 70%
     1077:  264:inline ImGuiTableFlags TableFixFlags(ImGuiTableFlags flags, ImGuiWindow* outer_window)
        -:  265:{
        -:  266:    // Adjust flags: set default sizing policy
     1077:  267:    if ((flags & ImGuiTableFlags_SizingMask_) == 0)
     1077:  267-block 2
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
    1077*:  268:        flags |= ((flags & ImGuiTableFlags_ScrollX) || (outer_window->Flags & ImGuiWindowFlags_AlwaysAutoResize)) ? ImGuiTableFlags_SizingFixedFit : ImGuiTableFlags_SizingStretchSame;
     1077:  268-block 3
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:  268-block 4
branch  2 taken 0 (fallthrough)
branch  3 taken 1077
    %%%%%:  268-block 5
     1077:  268-block 6
     1077:  268-block 7
        -:  269:
        -:  270:    // Adjust flags: enable NoKeepColumnsVisible when using ImGuiTableFlags_SizingFixedSame
     1077:  271:    if ((flags & ImGuiTableFlags_SizingMask_) == ImGuiTableFlags_SizingFixedSame)
     1077:  271-block 8
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####:  272:        flags |= ImGuiTableFlags_NoKeepColumnsVisible;
    %%%%%:  272-block 9
        -:  273:
        -:  274:    // Adjust flags: enforce borders when resizable
     1077:  275:    if (flags & ImGuiTableFlags_Resizable)
     1077:  275-block 10
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:  276:        flags |= ImGuiTableFlags_BordersInnerV;
     1077:  276-block 11
        -:  277:
        -:  278:    // Adjust flags: disable NoHostExtendX/NoHostExtendY if we have any scrolling going on
     1077:  279:    if (flags & (ImGuiTableFlags_ScrollX | ImGuiTableFlags_ScrollY))
     1077:  279-block 12
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####:  280:        flags &= ~(ImGuiTableFlags_NoHostExtendX | ImGuiTableFlags_NoHostExtendY);
    %%%%%:  280-block 13
        -:  281:
        -:  282:    // Adjust flags: NoBordersInBodyUntilResize takes priority over NoBordersInBody
     1077:  283:    if (flags & ImGuiTableFlags_NoBordersInBodyUntilResize)
     1077:  283-block 14
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####:  284:        flags &= ~ImGuiTableFlags_NoBordersInBody;
    %%%%%:  284-block 15
        -:  285:
        -:  286:    // Adjust flags: disable saved settings if there's nothing to save
     1077:  287:    if ((flags & (ImGuiTableFlags_Resizable | ImGuiTableFlags_Hideable | ImGuiTableFlags_Reorderable | ImGuiTableFlags_Sortable)) == 0)
     1077:  287-block 16
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####:  288:        flags |= ImGuiTableFlags_NoSavedSettings;
    %%%%%:  288-block 17
        -:  289:
        -:  290:    // Inherit _NoSavedSettings from top-level window (child windows always have _NoSavedSettings set)
     1077:  291:    if (outer_window->RootWindow->Flags & ImGuiWindowFlags_NoSavedSettings)
     1077:  291-block 18
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####:  292:        flags |= ImGuiTableFlags_NoSavedSettings;
    %%%%%:  292-block 19
        -:  293:
     1077:  294:    return flags;
     1077:  294-block 20
        -:  295:}
        -:  296:
function _ZN5ImGui13TableFindByIDEj called 0 returned 0% blocks executed 0%
    #####:  297:ImGuiTable* ImGui::TableFindByID(ImGuiID id)
        -:  298:{
    #####:  299:    ImGuiContext& g = *GImGui;
    #####:  300:    return g.Tables.GetByKey(id);
    %%%%%:  300-block 2
call    0 never executed
        -:  301:}
        -:  302:
        -:  303:// Read about "TABLE SIZING" at the top of this file.
function _ZN5ImGui10BeginTableEPKciiRK6ImVec2f called 1077 returned 100% blocks executed 100%
     1077:  304:bool    ImGui::BeginTable(const char* str_id, int columns_count, ImGuiTableFlags flags, const ImVec2& outer_size, float inner_width)
        -:  305:{
     1077:  306:    ImGuiID id = GetID(str_id);
     1077:  306-block 2
call    0 returned 1077
     1077:  307:    return BeginTableEx(str_id, id, columns_count, flags, outer_size, inner_width);
call    0 returned 1077
        -:  308:}
        -:  309:
function _ZN5ImGui12BeginTableExEPKcjiiRK6ImVec2f called 1077 returned 100% blocks executed 51%
     1077:  310:bool    ImGui::BeginTableEx(const char* name, ImGuiID id, int columns_count, ImGuiTableFlags flags, const ImVec2& outer_size, float inner_width)
        -:  311:{
     1077:  312:    ImGuiContext& g = *GImGui;
     1077:  313:    ImGuiWindow* outer_window = GetCurrentWindow();
     1077:  313-block 2
call    0 returned 1077
     1077:  314:    if (outer_window->SkipItems) // Consistent with other tables + beneficial side effect that assert on miscalling EndTable() will be more visible.
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####:  315:        return false;
    %%%%%:  315-block 4
        -:  316:
        -:  317:    // Sanity checks
    1077*:  318:    IM_ASSERT(columns_count > 0 && columns_count < IMGUI_TABLE_MAX_COLUMNS);
     1077:  318-block 5
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:  318-block 6
branch  2 taken 1077 (fallthrough)
branch  3 taken 0
     1077:  318-block 7
    %%%%%:  318-block 8
call    4 never executed
     1077:  319:    if (flags & ImGuiTableFlags_ScrollX)
     1077:  319-block 9
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####:  320:        IM_ASSERT(inner_width >= 0.0f);
    %%%%%:  320-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  320-block 11
call    2 never executed
        -:  321:
        -:  322:    // If an outer size is specified ahead we will be able to early out when not visible. Exact clipping criteria may evolve.
        -:  323:    // FIXME: coarse clipping because access to table data causes two issues:
        -:  324:    // - instance numbers varying/unstable. may not be a direct problem for users, but could make outside access broken or confusing, e.g. TestEngine.
        -:  325:    // - can't implement support for ImGuiChildFlags_ResizeY as we need to somehow pull the height data from somewhere. this also needs stable instance numbers.
        -:  326:    // The side-effects of accessing table data on coarse clip would be:
        -:  327:    // - always reserving the pooled ImGuiTable data ahead for a fully clipped table (minor IMHO). Also the 'outer_window_is_measuring_size' criteria may already be defeating this in some situations.
        -:  328:    // - always performing the GetOrAddByKey() O(log N) query in g.Tables.Map[].
     1077:  329:    const bool use_child_window = (flags & (ImGuiTableFlags_ScrollX | ImGuiTableFlags_ScrollY)) != 0;
     1077:  330:    const ImVec2 avail_size = GetContentRegionAvail();
     1077:  330-block 12
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
    1077*:  331:    const ImVec2 actual_outer_size = ImTrunc(CalcItemSize(outer_size, ImMax(avail_size.x, 1.0f), use_child_window ? ImMax(avail_size.y, 1.0f) : 0.0f));
     1077:  331-block 13
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:  331-block 14
call    2 never executed
     1077:  331-block 15
     1077:  331-block 16
call    3 returned 1077
call    4 returned 1077
branch  5 taken 1077 (fallthrough)
branch  6 taken 0 (throw)
     1077:  331-block 18
call    7 returned 1077
    $$$$$:  331-block 194
     1077:  332:    const ImRect outer_rect(outer_window->DC.CursorPos, outer_window->DC.CursorPos + actual_outer_size);
call    0 returned 1077
call    1 returned 1077
     1077:  333:    const bool outer_window_is_measuring_size = (outer_window->AutoFitFramesX > 0) || (outer_window->AutoFitFramesY > 0); // Doesn't apply to AlwaysAutoResize windows!
branch  0 taken 1076 (fallthrough)
branch  1 taken 1
     1076:  333-block 22
branch  2 taken 0 (fallthrough)
branch  3 taken 1076
        1:  333-block 23
     1076:  333-block 24
    1077*:  334:    if (use_child_window && IsClippedEx(outer_rect, 0) && !outer_window_is_measuring_size)
     1077:  334-block 25
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:  334-block 26
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%:  334-block 27
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:  334-block 28
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%:  334-block 29
     1077:  334-block 30
     1077:  334-block 31
branch  9 taken 0 (fallthrough)
branch 10 taken 1077
        -:  335:    {
    #####:  336:        ItemSize(outer_rect);
    %%%%%:  336-block 32
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  337:        ItemAdd(outer_rect, id);
    %%%%%:  337-block 33
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  338:        return false;
    %%%%%:  338-block 34
        -:  339:    }
        -:  340:
        -:  341:    // [DEBUG] Debug break requested by user
     1077:  342:    if (g.DebugBreakInTable == id)
     1077:  342-block 35
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####:  343:        IM_DEBUG_BREAK();
    %%%%%:  343-block 36
call    0 never executed
        -:  344:
        -:  345:    // Acquire storage for the table
     1077:  346:    ImGuiTable* table = g.Tables.GetOrAddByKey(id);
     1077:  346-block 37
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -:  347:
        -:  348:    // Acquire temporary buffers
     1077:  349:    const int table_idx = g.Tables.GetIndex(table);
     1077:  349-block 38
call    0 returned 1077
     1077:  350:    if (++g.TablesTempDataStacked > g.TablesTempData.Size)
branch  0 taken 1 (fallthrough)
branch  1 taken 1076
        1:  351:        g.TablesTempData.resize(g.TablesTempDataStacked, ImGuiTableTempData());
        1:  351-block 40
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  351-block 41
call    3 returned 1
branch  4 taken 1 (fallthrough)
branch  5 taken 0 (throw)
        1:  351-block 42
call    6 returned 1
    $$$$$:  351-block 195
call    7 never executed
    $$$$$:  351-block 197
     1077:  352:    ImGuiTableTempData* temp_data = table->TempData = &g.TablesTempData[g.TablesTempDataStacked - 1];
     1077:  352-block 44
call    0 returned 1077
     1077:  353:    temp_data->TableIndex = table_idx;
     1077:  354:    table->DrawSplitter = &table->TempData->DrawSplitter;
     1077:  355:    table->DrawSplitter->Clear();
call    0 returned 1077
        -:  356:
        -:  357:    // Fix flags
     1077:  358:    table->IsDefaultSizingPolicy = (flags & ImGuiTableFlags_SizingMask_) == 0;
     1077:  359:    flags = TableFixFlags(flags, outer_window);
call    0 returned 1077
        -:  360:
        -:  361:    // Initialize
     1077:  362:    const int previous_frame_active = table->LastFrameActive;
    1077*:  363:    const int instance_no = (previous_frame_active != g.FrameCount) ? 0 : table->InstanceCurrent + 1;
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:  363-block 48
     1077:  363-block 49
     1077:  364:    const ImGuiTableFlags previous_flags = table->Flags;
     1077:  365:    table->ID = id;
     1077:  366:    table->Flags = flags;
     1077:  367:    table->LastFrameActive = g.FrameCount;
     1077:  368:    table->OuterWindow = table->InnerWindow = outer_window;
     1077:  369:    table->ColumnsCount = columns_count;
     1077:  370:    table->IsLayoutLocked = false;
     1077:  371:    table->InnerWidth = inner_width;
     1077:  372:    temp_data->UserOuterSize = outer_size;
        -:  373:
        -:  374:    // Instance data (for instance 0, TableID == TableInstanceID)
        -:  375:    ImGuiID instance_id;
     1077:  376:    table->InstanceCurrent = (ImS16)instance_no;
     1077:  377:    if (instance_no > 0)
     1077:  377-block 50
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
        -:  378:    {
    #####:  379:        IM_ASSERT(table->ColumnsCount == columns_count && "BeginTable(): Cannot change columns count mid-frame while preserving same ID");
    %%%%%:  379-block 51
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  379-block 52
call    2 never executed
    #####:  380:        if (table->InstanceDataExtra.Size < instance_no)
    %%%%%:  380-block 53
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  381:            table->InstanceDataExtra.push_back(ImGuiTableInstanceData());
    %%%%%:  381-block 54
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:  381-block 56
    $$$$$:  381-block 198
    #####:  382:        instance_id = GetIDWithSeed(instance_no, GetIDWithSeed("##Instances", NULL, id)); // Push "##Instances" followed by (int)instance_no in ID stack.
    %%%%%:  382-block 57
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:  382-block 58
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    %%%%%:  382-block 59
        -:  383:    }
        -:  384:    else
        -:  385:    {
     1077:  386:        instance_id = id;
     1077:  386-block 60
        -:  387:    }
     1077:  388:    ImGuiTableInstanceData* table_instance = TableGetInstanceData(table, table->InstanceCurrent);
     1077:  388-block 61
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:  389:    table_instance->TableInstanceID = instance_id;
        -:  390:
        -:  391:    // When not using a child window, WorkRect.Max will grow as we append contents.
     1077:  392:    if (use_child_window)
     1077:  392-block 62
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
        -:  393:    {
        -:  394:        // Ensure no vertical scrollbar appears if we only want horizontal one, to make flag consistent
        -:  395:        // (we have no other way to disable vertical scrollbar of a window while keeping the horizontal one showing)
    #####:  396:        ImVec2 override_content_size(FLT_MAX, FLT_MAX);
    #####:  397:        if ((flags & ImGuiTableFlags_ScrollX) && !(flags & ImGuiTableFlags_ScrollY))
    %%%%%:  397-block 63
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  397-block 64
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:  398:            override_content_size.y = FLT_MIN;
    %%%%%:  398-block 65
        -:  399:
        -:  400:        // Ensure specified width (when not specified, Stretched columns will act as if the width == OuterWidth and
        -:  401:        // never lead to any scrolling). We don't handle inner_width < 0.0f, we could potentially use it to right-align
        -:  402:        // based on the right side of the child window work rect, which would require knowing ahead if we are going to
        -:  403:        // have decoration taking horizontal spaces (typically a vertical scrollbar).
    #####:  404:        if ((flags & ImGuiTableFlags_ScrollX) && inner_width > 0.0f)
    %%%%%:  404-block 66
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  404-block 67
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:  405:            override_content_size.x = inner_width;
    %%%%%:  405-block 68
        -:  406:
    #####:  407:        if (override_content_size.x != FLT_MAX || override_content_size.y != FLT_MAX)
    %%%%%:  407-block 69
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  407-block 70
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:  408:            SetNextWindowContentSize(ImVec2(override_content_size.x != FLT_MAX ? override_content_size.x : 0.0f, override_content_size.y != FLT_MAX ? override_content_size.y : 0.0f));
    %%%%%:  408-block 71
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  408-block 72
    %%%%%:  408-block 73
    %%%%%:  408-block 74
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:  408-block 75
    %%%%%:  408-block 76
    %%%%%:  408-block 77
call    4 never executed
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
    %%%%%:  408-block 79
    $$$$$:  408-block 199
        -:  409:
        -:  410:        // Reset scroll if we are reactivating it
    #####:  411:        if ((previous_flags & (ImGuiTableFlags_ScrollX | ImGuiTableFlags_ScrollY)) == 0)
    %%%%%:  411-block 80
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  412:            SetNextWindowScroll(ImVec2(0.0f, 0.0f));
    %%%%%:  412-block 81
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:  412-block 83
    $$$$$:  412-block 200
        -:  413:
        -:  414:        // Create scrolling region (without border and zero window padding)
    #####:  415:        ImGuiWindowFlags child_window_flags = (flags & ImGuiTableFlags_ScrollX) ? ImGuiWindowFlags_HorizontalScrollbar : ImGuiWindowFlags_None;
    #####:  416:        BeginChildEx(name, instance_id, outer_rect.GetSize(), ImGuiChildFlags_None, child_window_flags);
    %%%%%:  416-block 84
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$:  416-block 201
    #####:  417:        table->InnerWindow = g.CurrentWindow;
    #####:  418:        table->WorkRect = table->InnerWindow->WorkRect;
    #####:  419:        table->OuterRect = table->InnerWindow->Rect();
    %%%%%:  419-block 86
call    0 never executed
    #####:  420:        table->InnerRect = table->InnerWindow->InnerRect;
    #####:  421:        IM_ASSERT(table->InnerWindow->WindowPadding.x == 0.0f && table->InnerWindow->WindowPadding.y == 0.0f && table->InnerWindow->WindowBorderSize == 0.0f);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  421-block 88
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:  421-block 89
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:  421-block 90
    %%%%%:  421-block 91
call    6 never executed
        -:  422:
        -:  423:        // Allow submitting when host is measuring
    #####:  424:        if (table->InnerWindow->SkipItems && outer_window_is_measuring_size)
    %%%%%:  424-block 92
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  424-block 93
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:  425:            table->InnerWindow->SkipItems = false;
    %%%%%:  425-block 94
        -:  426:
        -:  427:        // When using multiple instances, ensure they have the same amount of horizontal decorations (aka vertical scrollbar) so stretched columns can be aligned)
    #####:  428:        if (instance_no == 0)
    %%%%%:  428-block 95
branch  0 never executed (fallthrough)
branch  1 never executed
        -:  429:        {
    #####:  430:            table->HasScrollbarYPrev = table->HasScrollbarYCurr;
    #####:  431:            table->HasScrollbarYCurr = false;
    %%%%%:  431-block 96
        -:  432:        }
    #####:  433:        table->HasScrollbarYCurr |= table->InnerWindow->ScrollbarY;
    %%%%%:  433-block 97
        -:  434:    }
        -:  435:    else
        -:  436:    {
        -:  437:        // For non-scrolling tables, WorkRect == OuterRect == InnerRect.
        -:  438:        // But at this point we do NOT have a correct value for .Max.y (unless a height has been explicitly passed in). It will only be updated in EndTable().
     1077:  439:        table->WorkRect = table->OuterRect = table->InnerRect = outer_rect;
     1077:  440:        table->HasScrollbarYPrev = table->HasScrollbarYCurr = false;
     1077:  440-block 98
        -:  441:    }
        -:  442:
        -:  443:    // Push a standardized ID for both child-using and not-child-using tables
     1077:  444:    PushOverrideID(id);
     1077:  444-block 99
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:  445:    if (instance_no > 0)
     1077:  445-block 100
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####:  446:        PushOverrideID(instance_id); // FIXME: Somehow this is not resolved by stack-tool, even tho GetIDWithSeed() submitted the symbol.
    %%%%%:  446-block 101
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:  447:
        -:  448:    // Backup a copy of host window members we will modify
     1077:  449:    ImGuiWindow* inner_window = table->InnerWindow;
     1077:  450:    table->HostIndentX = inner_window->DC.Indent.x;
     1077:  451:    table->HostClipRect = inner_window->ClipRect;
     1077:  452:    table->HostSkipItems = inner_window->SkipItems;
     1077:  453:    temp_data->HostBackupWorkRect = inner_window->WorkRect;
     1077:  454:    temp_data->HostBackupParentWorkRect = inner_window->ParentWorkRect;
     1077:  455:    temp_data->HostBackupColumnsOffset = outer_window->DC.ColumnsOffset;
     1077:  456:    temp_data->HostBackupPrevLineSize = inner_window->DC.PrevLineSize;
     1077:  457:    temp_data->HostBackupCurrLineSize = inner_window->DC.CurrLineSize;
     1077:  458:    temp_data->HostBackupCursorMaxPos = inner_window->DC.CursorMaxPos;
     1077:  459:    temp_data->HostBackupItemWidth = outer_window->DC.ItemWidth;
     1077:  460:    temp_data->HostBackupItemWidthStackSize = outer_window->DC.ItemWidthStack.Size;
     1077:  461:    inner_window->DC.PrevLineSize = inner_window->DC.CurrLineSize = ImVec2(0.0f, 0.0f);
     1077:  461-block 102
call    0 returned 1077
        -:  462:
        -:  463:    // Make borders not overlap our contents by offsetting HostClipRect (#6765, #7428, #3752)
        -:  464:    // (we normally shouldn't alter HostClipRect as we rely on TableMergeDrawChannels() expanding non-clipped column toward the
        -:  465:    // limits of that rectangle, in order for ImDrawListSplitter::Merge() to merge the draw commands. However since the overlap
        -:  466:    // problem only affect scrolling tables in this case we can get away with doing it without extra cost).
     1077:  467:    if (inner_window != outer_window)
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
        -:  468:    {
        -:  469:        // FIXME: Because inner_window's Scrollbar doesn't know about border size, since it's not encoded in window->WindowBorderSize,
        -:  470:        // it already overlaps it and doesn't need an extra offset. Ideally we should be able to pass custom border size with
        -:  471:        // different x/y values to BeginChild().
    #####:  472:        if (flags & ImGuiTableFlags_BordersOuterV)
    %%%%%:  472-block 104
branch  0 never executed (fallthrough)
branch  1 never executed
        -:  473:        {
    #####:  474:            table->HostClipRect.Min.x = ImMin(table->HostClipRect.Min.x + TABLE_BORDER_SIZE, table->HostClipRect.Max.x);
    %%%%%:  474-block 105
call    0 never executed
    #####:  475:            if (inner_window->DecoOuterSizeX2 == 0.0f)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  476:                table->HostClipRect.Max.x = ImMax(table->HostClipRect.Max.x - TABLE_BORDER_SIZE, table->HostClipRect.Min.x);
    %%%%%:  476-block 107
call    0 never executed
        -:  477:        }
    #####:  478:        if (flags & ImGuiTableFlags_BordersOuterH)
    %%%%%:  478-block 109
branch  0 never executed (fallthrough)
branch  1 never executed
        -:  479:        {
    #####:  480:            table->HostClipRect.Min.y = ImMin(table->HostClipRect.Min.y + TABLE_BORDER_SIZE, table->HostClipRect.Max.y);
    %%%%%:  480-block 110
call    0 never executed
    #####:  481:            if (inner_window->DecoOuterSizeY2 == 0.0f)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  482:                table->HostClipRect.Max.y = ImMax(table->HostClipRect.Max.y - TABLE_BORDER_SIZE, table->HostClipRect.Min.y);
    %%%%%:  482-block 112
call    0 never executed
        -:  483:        }
        -:  484:    }
        -:  485:
        -:  486:    // Padding and Spacing
        -:  487:    // - None               ........Content..... Pad .....Content........
        -:  488:    // - PadOuter           | Pad ..Content..... Pad .....Content.. Pad |
        -:  489:    // - PadInner           ........Content.. Pad | Pad ..Content........
        -:  490:    // - PadOuter+PadInner  | Pad ..Content.. Pad | Pad ..Content.. Pad |
    1077*:  491:    const bool pad_outer_x = (flags & ImGuiTableFlags_NoPadOuterX) ? false : (flags & ImGuiTableFlags_PadOuterX) ? true : (flags & ImGuiTableFlags_BordersOuterV) != 0;
     1077:  491-block 114
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:  491-block 115
branch  2 taken 1077 (fallthrough)
branch  3 taken 0
     1077:  491-block 116
branch  4 taken 1077 (fallthrough)
branch  5 taken 0
     1077:  491-block 117
    %%%%%:  491-block 118
     1077:  492:    const bool pad_inner_x = (flags & ImGuiTableFlags_NoPadInnerX) ? false : true;
    1077*:  493:    const float inner_spacing_for_border = (flags & ImGuiTableFlags_BordersInnerV) ? TABLE_BORDER_SIZE : 0.0f;
     1077:  493-block 119
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:  493-block 120
    %%%%%:  493-block 121
    1077*:  494:    const float inner_spacing_explicit = (pad_inner_x && (flags & ImGuiTableFlags_BordersInnerV) == 0) ? g.Style.CellPadding.x : 0.0f;
     1077:  494-block 122
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:  494-block 123
branch  2 taken 0 (fallthrough)
branch  3 taken 1077
    %%%%%:  494-block 124
     1077:  494-block 125
    1077*:  495:    const float inner_padding_explicit = (pad_inner_x && (flags & ImGuiTableFlags_BordersInnerV) != 0) ? g.Style.CellPadding.x : 0.0f;
     1077:  495-block 126
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:  495-block 127
branch  2 taken 1077 (fallthrough)
branch  3 taken 0
     1077:  495-block 128
    %%%%%:  495-block 129
     1077:  496:    table->CellSpacingX1 = inner_spacing_explicit + inner_spacing_for_border;
     1077:  497:    table->CellSpacingX2 = inner_spacing_explicit;
     1077:  498:    table->CellPaddingX = inner_padding_explicit;
        -:  499:
    1077*:  500:    const float outer_padding_for_border = (flags & ImGuiTableFlags_BordersOuterV) ? TABLE_BORDER_SIZE : 0.0f;
     1077:  500-block 130
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:  500-block 131
    %%%%%:  500-block 132
    1077*:  501:    const float outer_padding_explicit = pad_outer_x ? g.Style.CellPadding.x : 0.0f;
     1077:  501-block 133
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:  501-block 134
    %%%%%:  501-block 135
     1077:  502:    table->OuterPaddingX = (outer_padding_for_border + outer_padding_explicit) - table->CellPaddingX;
        -:  503:
     1077:  504:    table->CurrentColumn = -1;
     1077:  505:    table->CurrentRow = -1;
     1077:  506:    table->RowBgColorCounter = 0;
     1077:  507:    table->LastRowFlags = ImGuiTableRowFlags_None;
    1077*:  508:    table->InnerClipRect = (inner_window == outer_window) ? table->WorkRect : inner_window->ClipRect;
     1077:  508-block 136
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:  508-block 137
    %%%%%:  508-block 138
     1077:  509:    table->InnerClipRect.ClipWith(table->WorkRect);     // We need this to honor inner_width
     1077:  509-block 139
call    0 returned 1077
     1077:  510:    table->InnerClipRect.ClipWithFull(table->HostClipRect);
call    0 returned 1077
    1077*:  511:    table->InnerClipRect.Max.y = (flags & ImGuiTableFlags_NoHostExtendY) ? ImMin(table->InnerClipRect.Max.y, inner_window->WorkRect.Max.y) : table->HostClipRect.Max.y;
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:  511-block 142
call    2 never executed
     1077:  511-block 143
        -:  512:
     1077:  513:    table->RowPosY1 = table->RowPosY2 = table->WorkRect.Min.y; // This is needed somehow
     1077:  514:    table->RowTextBaseline = 0.0f; // This will be cleared again by TableBeginRow()
     1077:  515:    table->RowCellPaddingY = 0.0f;
     1077:  516:    table->FreezeRowsRequest = table->FreezeRowsCount = 0; // This will be setup by TableSetupScrollFreeze(), if any
     1077:  517:    table->FreezeColumnsRequest = table->FreezeColumnsCount = 0;
     1077:  518:    table->IsUnfrozenRows = true;
     1077:  519:    table->DeclColumnsCount = table->AngledHeadersCount = 0;
     1077:  520:    if (previous_frame_active + 1 < g.FrameCount)
     1077:  520-block 144
branch  0 taken 1 (fallthrough)
branch  1 taken 1076
        1:  521:        table->IsActiveIdInTable = false;
        1:  521-block 145
     1077:  522:    table->AngledHeadersHeight = 0.0f;
     1077:  523:    temp_data->AngledHeadersExtraWidth = 0.0f;
        -:  524:
        -:  525:    // Using opaque colors facilitate overlapping lines of the grid, otherwise we'd need to improve TableDrawBorders()
     1077:  526:    table->BorderColorStrong = GetColorU32(ImGuiCol_TableBorderStrong);
     1077:  526-block 146
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:  527:    table->BorderColorLight = GetColorU32(ImGuiCol_TableBorderLight);
     1077:  527-block 147
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -:  528:
        -:  529:    // Make table current
     1077:  530:    g.CurrentTable = table;
     1077:  531:    outer_window->DC.NavIsScrollPushableX = false; // Shortcut for NavUpdateCurrentWindowIsScrollPushableX();
     1077:  532:    outer_window->DC.CurrentTableIdx = table_idx;
     1077:  533:    if (inner_window != outer_window) // So EndChild() within the inner window can restore the table properly.
     1077:  533-block 148
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####:  534:        inner_window->DC.CurrentTableIdx = table_idx;
    %%%%%:  534-block 149
        -:  535:
    1077*:  536:    if ((previous_flags & ImGuiTableFlags_Reorderable) && (flags & ImGuiTableFlags_Reorderable) == 0)
     1077:  536-block 150
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:  536-block 151
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:  537:        table->IsResetDisplayOrderRequest = true;
    %%%%%:  537-block 152
        -:  538:
        -:  539:    // Mark as used to avoid GC
     1077:  540:    if (table_idx >= g.TablesLastTimeActive.Size)
     1077:  540-block 153
branch  0 taken 1 (fallthrough)
branch  1 taken 1076
        1:  541:        g.TablesLastTimeActive.resize(table_idx + 1, -1.0f);
        1:  541-block 154
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  541-block 155
    $$$$$:  541-block 203
     1077:  542:    g.TablesLastTimeActive[table_idx] = (float)g.Time;
     1077:  542-block 156
call    0 returned 1077
     1077:  543:    temp_data->LastTimeActive = (float)g.Time;
     1077:  544:    table->MemoryCompacted = false;
        -:  545:
        -:  546:    // Setup memory buffer (clear data if columns count changed)
     1077:  547:    ImGuiTableColumn* old_columns_to_preserve = NULL;
     1077:  548:    void* old_columns_raw_data = NULL;
     1077:  549:    const int old_columns_count = table->Columns.size();
call    0 returned 1077
     1077:  550:    if (old_columns_count != 0 && old_columns_count != columns_count)
branch  0 taken 1076 (fallthrough)
branch  1 taken 1
     1076:  550-block 159
branch  2 taken 0 (fallthrough)
branch  3 taken 1076
        -:  551:    {
        -:  552:        // Attempt to preserve width on column count change (#4046)
    #####:  553:        old_columns_to_preserve = table->Columns.Data;
    #####:  554:        old_columns_raw_data = table->RawData;
    #####:  555:        table->RawData = NULL;
    %%%%%:  555-block 160
        -:  556:    }
     1077:  557:    if (table->RawData == NULL)
     1077:  557-block 161
branch  0 taken 1 (fallthrough)
branch  1 taken 1076
        -:  558:    {
        1:  559:        TableBeginInitMemory(table, columns_count);
        1:  559-block 162
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  560:        table->IsInitializing = table->IsSettingsRequestLoad = true;
        1:  560-block 163
        -:  561:    }
     1077:  562:    if (table->IsResetAllRequest)
     1077:  562-block 164
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####:  563:        TableResetSettings(table);
    %%%%%:  563-block 165
call    0 never executed
     1077:  564:    if (table->IsInitializing)
     1077:  564-block 166
branch  0 taken 1 (fallthrough)
branch  1 taken 1076
        -:  565:    {
        -:  566:        // Initialize
        1:  567:        table->SettingsOffset = -1;
        1:  568:        table->IsSortSpecsDirty = true;
        1:  569:        table->InstanceInteracted = -1;
        1:  570:        table->ContextPopupColumn = -1;
        1:  571:        table->ReorderColumn = table->ResizedColumn = table->LastResizedColumn = -1;
        1:  572:        table->AutoFitSingleColumn = -1;
        1:  573:        table->HoveredColumnBody = table->HoveredColumnBorder = -1;
        5:  574:        for (int n = 0; n < columns_count; n++)
        1:  574-block 167
        5:  574-block 176
branch  0 taken 4
branch  1 taken 1 (fallthrough)
        -:  575:        {
        4:  576:            ImGuiTableColumn* column = &table->Columns[n];
        4:  576-block 168
call    0 returned 4
       4*:  577:            if (old_columns_to_preserve && n < old_columns_count)
branch  0 taken 0 (fallthrough)
branch  1 taken 4
    %%%%%:  577-block 170
branch  2 never executed (fallthrough)
branch  3 never executed
        -:  578:            {
        -:  579:                // FIXME: We don't attempt to preserve column order in this path.
    #####:  580:                *column = old_columns_to_preserve[n];
    %%%%%:  580-block 171
        -:  581:            }
        -:  582:            else
        -:  583:            {
        4:  584:                float width_auto = column->WidthAuto;
        4:  585:                *column = ImGuiTableColumn();
        4:  585-block 172
call    0 returned 4
        4:  586:                column->WidthAuto = width_auto;
        4:  587:                column->IsPreserveWidthAuto = true; // Preserve WidthAuto when reinitializing a live table: not technically necessary but remove a visible flicker
        4:  588:                column->IsEnabled = column->IsUserEnabled = column->IsUserEnabledNextFrame = true;
        -:  589:            }
        4:  590:            column->DisplayOrder = table->DisplayOrderToIndex[n] = (ImGuiTableColumnIdx)n;
        4:  590-block 174
call    0 returned 4
        -:  591:        }
        -:  592:    }
     1077:  593:    if (old_columns_raw_data)
     1077:  593-block 177
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####:  594:        IM_FREE(old_columns_raw_data);
    %%%%%:  594-block 178
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:  595:
        -:  596:    // Load settings
     1077:  597:    if (table->IsSettingsRequestLoad)
     1077:  597-block 179
branch  0 taken 1 (fallthrough)
branch  1 taken 1076
        1:  598:        TableLoadSettings(table);
        1:  598-block 180
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:  599:
        -:  600:    // Handle DPI/font resize
        -:  601:    // This is designed to facilitate DPI changes with the assumption that e.g. style.CellPadding has been scaled as well.
        -:  602:    // It will also react to changing fonts with mixed results. It doesn't need to be perfect but merely provide a decent transition.
        -:  603:    // FIXME-DPI: Provide consistent standards for reference size. Perhaps using g.CurrentDpiScale would be more self explanatory.
        -:  604:    // This is will lead us to non-rounded WidthRequest in columns, which should work but is a poorly tested path.
     1077:  605:    const float new_ref_scale_unit = g.FontSize; // g.Font->GetCharAdvance('A') ?
     1077:  606:    if (table->RefScale != 0.0f && table->RefScale != new_ref_scale_unit)
     1077:  606-block 181
branch  0 taken 1076 (fallthrough)
branch  1 taken 1
     1076:  606-block 182
branch  2 taken 0 (fallthrough)
branch  3 taken 1076
        -:  607:    {
    #####:  608:        const float scale_factor = new_ref_scale_unit / table->RefScale;
        -:  609:        //IMGUI_DEBUG_PRINT("[table] %08X RefScaleUnit %.3f -> %.3f, scaling width by %.3f\n", table->ID, table->RefScaleUnit, new_ref_scale_unit, scale_factor);
    #####:  610:        for (int n = 0; n < columns_count; n++)
    %%%%%:  610-block 183
    %%%%%:  610-block 187
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:  611:            table->Columns[n].WidthRequest = table->Columns[n].WidthRequest * scale_factor;
    %%%%%:  611-block 184
call    0 never executed
call    1 never executed
        -:  612:    }
     1077:  613:    table->RefScale = new_ref_scale_unit;
        -:  614:
        -:  615:    // Disable output until user calls TableNextRow() or TableNextColumn() leading to the TableUpdateLayout() call..
        -:  616:    // This is not strictly necessary but will reduce cases were "out of table" output will be misleading to the user.
        -:  617:    // Because we cannot safely assert in EndTable() when no rows have been created, this seems like our best option.
     1077:  618:    inner_window->SkipItems = true;
        -:  619:
        -:  620:    // Clear names
        -:  621:    // At this point the ->NameOffset field of each column will be invalid until TableUpdateLayout() or the first call to TableSetupColumn()
     1077:  622:    if (table->ColumnsNames.Buf.Size > 0)
     1077:  622-block 188
branch  0 taken 1076 (fallthrough)
branch  1 taken 1
     1076:  623:        table->ColumnsNames.Buf.resize(0);
     1076:  623-block 189
call    0 returned 1076
branch  1 taken 1076 (fallthrough)
branch  2 taken 0 (throw)
        -:  624:
        -:  625:    // Apply queued resizing/reordering/hiding requests
     1077:  626:    TableBeginApplyRequests(table);
     1077:  626-block 190
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -:  627:
     1077:  628:    return true;
     1077:  628-block 191
        -:  629:}
        -:  630:
        -:  631:// For reference, the average total _allocation count_ for a table is:
        -:  632:// + 0 (for ImGuiTable instance, we are pooling allocations in g.Tables[])
        -:  633:// + 1 (for table->RawData allocated below)
        -:  634:// + 1 (for table->ColumnsNames, if names are used)
        -:  635:// Shared allocations for the maximum number of simultaneously nested tables (generally a very small number)
        -:  636:// + 1 (for table->Splitter._Channels)
        -:  637:// + 2 * active_channels_count (for ImDrawCmd and ImDrawIdx buffers inside channels)
        -:  638:// Where active_channels_count is variable but often == columns_count or == columns_count + 1, see TableSetupDrawChannels() for details.
        -:  639:// Unused channels don't perform their +2 allocations.
function _ZN5ImGui20TableBeginInitMemoryEP10ImGuiTablei called 1 returned 100% blocks executed 100%
        1:  640:void ImGui::TableBeginInitMemory(ImGuiTable* table, int columns_count)
        -:  641:{
        -:  642:    // Allocate single buffer for our arrays
        1:  643:    const int columns_bit_array_size = (int)ImBitArrayGetStorageSizeInBytes(columns_count);
        1:  643-block 2
call    0 returned 1
        1:  644:    ImSpanAllocator<6> span_allocator;
call    0 returned 1
        1:  645:    span_allocator.Reserve(0, columns_count * sizeof(ImGuiTableColumn));
call    0 returned 1
        1:  646:    span_allocator.Reserve(1, columns_count * sizeof(ImGuiTableColumnIdx));
call    0 returned 1
        1:  647:    span_allocator.Reserve(2, columns_count * sizeof(ImGuiTableCellData), 4);
call    0 returned 1
        4:  648:    for (int n = 3; n < 6; n++)
        4:  648-block 10
branch  0 taken 3
branch  1 taken 1 (fallthrough)
        3:  649:        span_allocator.Reserve(n, columns_bit_array_size);
        3:  649-block 8
call    0 returned 3
        1:  650:    table->RawData = IM_ALLOC(span_allocator.GetArenaSizeInBytes());
        1:  650-block 11
call    0 returned 1
call    1 returned 1
branch  2 taken 1 (fallthrough)
branch  3 taken 0 (throw)
        1:  651:    memset(table->RawData, 0, span_allocator.GetArenaSizeInBytes());
        1:  651-block 13
call    0 returned 1
        1:  652:    span_allocator.SetArenaBasePtr(table->RawData);
call    0 returned 1
        1:  653:    span_allocator.GetSpan(0, &table->Columns);
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  654:    span_allocator.GetSpan(1, &table->DisplayOrderToIndex);
        1:  654-block 16
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  655:    span_allocator.GetSpan(2, &table->RowCellData);
        1:  655-block 17
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  656:    table->EnabledMaskByDisplayOrder = (ImU32*)span_allocator.GetSpanPtrBegin(3);
        1:  656-block 18
call    0 returned 1
        1:  657:    table->EnabledMaskByIndex = (ImU32*)span_allocator.GetSpanPtrBegin(4);
call    0 returned 1
        1:  658:    table->VisibleMaskByIndex = (ImU32*)span_allocator.GetSpanPtrBegin(5);
call    0 returned 1
        1:  659:}
        -:  660:
        -:  661:// Apply queued resizing/reordering/hiding requests
function _ZN5ImGui23TableBeginApplyRequestsEP10ImGuiTable called 1077 returned 100% blocks executed 20%
     1077:  662:void ImGui::TableBeginApplyRequests(ImGuiTable* table)
        -:  663:{
        -:  664:    // Handle resizing request
        -:  665:    // (We process this in the TableBegin() of the first instance of each table)
        -:  666:    // FIXME-TABLE: Contains columns if our work area doesn't allow for scrolling?
     1077:  667:    if (table->InstanceCurrent == 0)
     1077:  667-block 2
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
        -:  668:    {
    1077*:  669:        if (table->ResizedColumn != -1 && table->ResizedColumnNextWidth != FLT_MAX)
     1077:  669-block 3
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:  669-block 4
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:  670:            TableSetColumnWidth(table->ResizedColumn, table->ResizedColumnNextWidth);
    %%%%%:  670-block 5
call    0 never executed
     1077:  671:        table->LastResizedColumn = table->ResizedColumn;
     1077:  672:        table->ResizedColumnNextWidth = FLT_MAX;
     1077:  673:        table->ResizedColumn = -1;
        -:  674:
        -:  675:        // Process auto-fit for single column, which is a special case for stretch columns and fixed columns with FixedSame policy.
        -:  676:        // FIXME-TABLE: Would be nice to redistribute available stretch space accordingly to other weights, instead of giving it all to siblings.
     1077:  677:        if (table->AutoFitSingleColumn != -1)
     1077:  677-block 6
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
        -:  678:        {
    #####:  679:            TableSetColumnWidth(table->AutoFitSingleColumn, table->Columns[table->AutoFitSingleColumn].WidthAuto);
    %%%%%:  679-block 7
call    0 never executed
call    1 never executed
    #####:  680:            table->AutoFitSingleColumn = -1;
        -:  681:        }
        -:  682:    }
        -:  683:
        -:  684:    // Handle reordering request
        -:  685:    // Note: we don't clear ReorderColumn after handling the request.
     1077:  686:    if (table->InstanceCurrent == 0)
     1077:  686-block 10
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
        -:  687:    {
     1077:  688:        if (table->HeldHeaderColumn == -1 && table->ReorderColumn != -1)
     1077:  688-block 11
branch  0 taken 1076 (fallthrough)
branch  1 taken 1
     1076:  688-block 12
branch  2 taken 0 (fallthrough)
branch  3 taken 1076
    #####:  689:            table->ReorderColumn = -1;
    %%%%%:  689-block 13
     1077:  690:        table->HeldHeaderColumn = -1;
    1077*:  691:        if (table->ReorderColumn != -1 && table->ReorderColumnDir != 0)
     1077:  691-block 14
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:  691-block 15
branch  2 never executed (fallthrough)
branch  3 never executed
        -:  692:        {
        -:  693:            // We need to handle reordering across hidden columns.
        -:  694:            // In the configuration below, moving C to the right of E will lead to:
        -:  695:            //    ... C [D] E  --->  ... [D] E  C   (Column name/index)
        -:  696:            //    ... 2  3  4        ...  2  3  4   (Display order)
    #####:  697:            const int reorder_dir = table->ReorderColumnDir;
    #####:  698:            IM_ASSERT(reorder_dir == -1 || reorder_dir == +1);
    %%%%%:  698-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  698-block 17
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:  698-block 18
call    4 never executed
    #####:  699:            IM_ASSERT(table->Flags & ImGuiTableFlags_Reorderable);
    %%%%%:  699-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  699-block 20
call    2 never executed
    #####:  700:            ImGuiTableColumn* src_column = &table->Columns[table->ReorderColumn];
    %%%%%:  700-block 21
call    0 never executed
    #####:  701:            ImGuiTableColumn* dst_column = &table->Columns[(reorder_dir == -1) ? src_column->PrevEnabledColumn : src_column->NextEnabledColumn];
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  701-block 23
    %%%%%:  701-block 24
    %%%%%:  701-block 25
call    2 never executed
        -:  702:            IM_UNUSED(dst_column);
    #####:  703:            const int src_order = src_column->DisplayOrder;
    #####:  704:            const int dst_order = dst_column->DisplayOrder;
    #####:  705:            src_column->DisplayOrder = (ImGuiTableColumnIdx)dst_order;
    #####:  706:            for (int order_n = src_order + reorder_dir; order_n != dst_order + reorder_dir; order_n += reorder_dir)
    %%%%%:  706-block 30
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:  707:                table->Columns[table->DisplayOrderToIndex[order_n]].DisplayOrder -= (ImGuiTableColumnIdx)reorder_dir;
    %%%%%:  707-block 27
call    0 never executed
call    1 never executed
    #####:  708:            IM_ASSERT(dst_column->DisplayOrder == dst_order - reorder_dir);
    %%%%%:  708-block 31
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  708-block 32
call    2 never executed
        -:  709:
        -:  710:            // Display order is stored in both columns->IndexDisplayOrder and table->DisplayOrder[]. Rebuild later from the former.
    #####:  711:            for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
    %%%%%:  711-block 33
    %%%%%:  711-block 37
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:  712:                table->DisplayOrderToIndex[table->Columns[column_n].DisplayOrder] = (ImGuiTableColumnIdx)column_n;
    %%%%%:  712-block 34
call    0 never executed
call    1 never executed
    #####:  713:            table->ReorderColumnDir = 0;
    #####:  714:            table->IsSettingsDirty = true;
    %%%%%:  714-block 38
        -:  715:        }
        -:  716:    }
        -:  717:
        -:  718:    // Handle display order reset request
     1077:  719:    if (table->IsResetDisplayOrderRequest)
     1077:  719-block 39
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
        -:  720:    {
    #####:  721:        for (int n = 0; n < table->ColumnsCount; n++)
    %%%%%:  721-block 40
    %%%%%:  721-block 44
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:  722:            table->DisplayOrderToIndex[n] = table->Columns[n].DisplayOrder = (ImGuiTableColumnIdx)n;
    %%%%%:  722-block 41
call    0 never executed
call    1 never executed
    #####:  723:        table->IsResetDisplayOrderRequest = false;
    #####:  724:        table->IsSettingsDirty = true;
    %%%%%:  724-block 45
        -:  725:    }
     1077:  726:}
        -:  727:
        -:  728:// Adjust flags: default width mode + stretch columns are not allowed when auto extending
function _ZL21TableSetupColumnFlagsP10ImGuiTableP16ImGuiTableColumni called 4308 returned 100% blocks executed 34%
     4308:  729:static void TableSetupColumnFlags(ImGuiTable* table, ImGuiTableColumn* column, ImGuiTableColumnFlags flags_in)
        -:  730:{
     4308:  731:    ImGuiTableColumnFlags flags = flags_in;
        -:  732:
        -:  733:    // Sizing Policy
     4308:  734:    if ((flags & ImGuiTableColumnFlags_WidthMask_) == 0)
     4308:  734-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
        -:  735:    {
    #####:  736:        const ImGuiTableFlags table_sizing_policy = (table->Flags & ImGuiTableFlags_SizingMask_);
    #####:  737:        if (table_sizing_policy == ImGuiTableFlags_SizingFixedFit || table_sizing_policy == ImGuiTableFlags_SizingFixedSame)
    %%%%%:  737-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  737-block 4
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:  738:            flags |= ImGuiTableColumnFlags_WidthFixed;
    %%%%%:  738-block 5
        -:  739:        else
    #####:  740:            flags |= ImGuiTableColumnFlags_WidthStretch;
    %%%%%:  740-block 6
        -:  741:    }
        -:  742:    else
        -:  743:    {
    4308*:  744:        IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiTableColumnFlags_WidthMask_)); // Check that only 1 of each set is used.
     4308:  744-block 8
call    0 returned 4308
branch  1 taken 0 (fallthrough)
branch  2 taken 4308
    %%%%%:  744-block 10
call    3 never executed
        -:  745:    }
        -:  746:
        -:  747:    // Resize
     4308:  748:    if ((table->Flags & ImGuiTableFlags_Resizable) == 0)
     4308:  748-block 11
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
    #####:  749:        flags |= ImGuiTableColumnFlags_NoResize;
    %%%%%:  749-block 12
        -:  750:
        -:  751:    // Sorting
    4308*:  752:    if ((flags & ImGuiTableColumnFlags_NoSortAscending) && (flags & ImGuiTableColumnFlags_NoSortDescending))
     4308:  752-block 13
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
    %%%%%:  752-block 14
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:  753:        flags |= ImGuiTableColumnFlags_NoSort;
    %%%%%:  753-block 15
        -:  754:
        -:  755:    // Indentation
     4308:  756:    if ((flags & ImGuiTableColumnFlags_IndentMask_) == 0)
     4308:  756-block 16
branch  0 taken 4308 (fallthrough)
branch  1 taken 0
     4308:  757:        flags |= (table->Columns.index_from_ptr(column) == 0) ? ImGuiTableColumnFlags_IndentEnable : ImGuiTableColumnFlags_IndentDisable;
     4308:  757-block 17
call    0 returned 4308
branch  1 taken 1077 (fallthrough)
branch  2 taken 3231
     1077:  757-block 19
     3231:  757-block 20
     4308:  757-block 21
        -:  758:
        -:  759:    // Alignment
        -:  760:    //if ((flags & ImGuiTableColumnFlags_AlignMask_) == 0)
        -:  761:    //    flags |= ImGuiTableColumnFlags_AlignCenter;
        -:  762:    //IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiTableColumnFlags_AlignMask_)); // Check that only 1 of each set is used.
        -:  763:
        -:  764:    // Preserve status flags
     4308:  765:    column->Flags = flags | (column->Flags & ImGuiTableColumnFlags_StatusMask_);
        -:  766:
        -:  767:    // Build an ordered list of available sort directions
     4308:  768:    column->SortDirectionsAvailCount = column->SortDirectionsAvailMask = column->SortDirectionsAvailList = 0;
     4308:  769:    if (table->Flags & ImGuiTableFlags_Sortable)
     4308:  769-block 22
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
        -:  770:    {
    #####:  771:        int count = 0, mask = 0, list = 0;
    #####:  772:        if ((flags & ImGuiTableColumnFlags_PreferSortAscending)  != 0 && (flags & ImGuiTableColumnFlags_NoSortAscending)  == 0) { mask |= 1 << ImGuiSortDirection_Ascending;  list |= ImGuiSortDirection_Ascending  << (count << 1); count++; }
    %%%%%:  772-block 23
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  772-block 24
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:  772-block 25
    #####:  773:        if ((flags & ImGuiTableColumnFlags_PreferSortDescending) != 0 && (flags & ImGuiTableColumnFlags_NoSortDescending) == 0) { mask |= 1 << ImGuiSortDirection_Descending; list |= ImGuiSortDirection_Descending << (count << 1); count++; }
    %%%%%:  773-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  773-block 27
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:  773-block 28
    #####:  774:        if ((flags & ImGuiTableColumnFlags_PreferSortAscending)  == 0 && (flags & ImGuiTableColumnFlags_NoSortAscending)  == 0) { mask |= 1 << ImGuiSortDirection_Ascending;  list |= ImGuiSortDirection_Ascending  << (count << 1); count++; }
    %%%%%:  774-block 29
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  774-block 30
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:  774-block 31
    #####:  775:        if ((flags & ImGuiTableColumnFlags_PreferSortDescending) == 0 && (flags & ImGuiTableColumnFlags_NoSortDescending) == 0) { mask |= 1 << ImGuiSortDirection_Descending; list |= ImGuiSortDirection_Descending << (count << 1); count++; }
    %%%%%:  775-block 32
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  775-block 33
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:  775-block 34
    #####:  776:        if ((table->Flags & ImGuiTableFlags_SortTristate) || count == 0) { mask |= 1 << ImGuiSortDirection_None; count++; }
    %%%%%:  776-block 35
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  776-block 36
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:  776-block 37
    #####:  777:        column->SortDirectionsAvailList = (ImU8)list;
    #####:  778:        column->SortDirectionsAvailMask = (ImU8)mask;
    #####:  779:        column->SortDirectionsAvailCount = (ImU8)count;
    #####:  780:        ImGui::TableFixColumnSortDirection(table, column);
    %%%%%:  780-block 38
call    0 never executed
        -:  781:    }
     4308:  782:}
        -:  783:
        -:  784:// Layout columns for the frame. This is in essence the followup to BeginTable() and this is our largest function.
        -:  785:// Runs on the first call to TableNextRow(), to give a chance for TableSetupColumn() and other TableSetupXXXXX() functions to be called first.
        -:  786:// FIXME-TABLE: Our width (and therefore our WorkRect) will be minimal in the first frame for _WidthAuto columns.
        -:  787:// Increase feedback side-effect with widgets relying on WorkRect.Max.x... Maybe provide a default distribution for _WidthAuto columns?
function _ZN5ImGui17TableUpdateLayoutEP10ImGuiTable called 1077 returned 100% blocks executed 62%
     1077:  788:void ImGui::TableUpdateLayout(ImGuiTable* table)
        -:  789:{
     1077:  790:    ImGuiContext& g = *GImGui;
    1077*:  791:    IM_ASSERT(table->IsLayoutLocked == false);
     1077:  791-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:  791-block 3
call    2 never executed
        -:  792:
     1077:  793:    const ImGuiTableFlags table_sizing_policy = (table->Flags & ImGuiTableFlags_SizingMask_);
     1077:  794:    table->IsDefaultDisplayOrder = true;
     1077:  795:    table->ColumnsEnabledCount = 0;
     1077:  796:    ImBitArrayClearAllBits(table->EnabledMaskByIndex, table->ColumnsCount);
     1077:  796-block 4
call    0 returned 1077
     1077:  797:    ImBitArrayClearAllBits(table->EnabledMaskByDisplayOrder, table->ColumnsCount);
call    0 returned 1077
     1077:  798:    table->LeftMostEnabledColumn = -1;
     1077:  799:    table->MinColumnWidth = ImMax(1.0f, g.Style.FramePadding.x * 1.0f); // g.Style.ColumnsMinSpacing; // FIXME-TABLE
call    0 returned 1077
        -:  800:
        -:  801:    // [Part 1] Apply/lock Enabled and Order states. Calculate auto/ideal width for columns. Count fixed/stretch columns.
        -:  802:    // Process columns in their visible orders as we are building the Prev/Next indices.
     1077:  803:    int count_fixed = 0;                // Number of columns that have fixed sizing policies
     1077:  804:    int count_stretch = 0;              // Number of columns that have stretch sizing policies
     1077:  805:    int prev_visible_column_idx = -1;
     1077:  806:    bool has_auto_fit_request = false;
     1077:  807:    bool has_resizable = false;
     1077:  808:    float stretch_sum_width_auto = 0.0f;
     1077:  809:    float fixed_max_width_auto = 0.0f;
     5385:  810:    for (int order_n = 0; order_n < table->ColumnsCount; order_n++)
     4308:  810-block 61
     5385:  810-block 62
branch  0 taken 4308
branch  1 taken 1077 (fallthrough)
        -:  811:    {
     4308:  812:        const int column_n = table->DisplayOrderToIndex[order_n];
     4308:  812-block 8
call    0 returned 4308
     4308:  813:        if (column_n != order_n)
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
    #####:  814:            table->IsDefaultDisplayOrder = false;
    %%%%%:  814-block 10
     4308:  815:        ImGuiTableColumn* column = &table->Columns[column_n];
     4308:  815-block 11
call    0 returned 4308
        -:  816:
        -:  817:        // Clear column setup if not submitted by user. Currently we make it mandatory to call TableSetupColumn() every frame.
        -:  818:        // It would easily work without but we're not ready to guarantee it since e.g. names need resubmission anyway.
        -:  819:        // We take a slight shortcut but in theory we could be calling TableSetupColumn() here with dummy values, it should yield the same effect.
     4308:  820:        if (table->DeclColumnsCount <= column_n)
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
        -:  821:        {
    #####:  822:            TableSetupColumnFlags(table, column, ImGuiTableColumnFlags_None);
    %%%%%:  822-block 13
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  823:            column->NameOffset = -1;
    #####:  824:            column->UserID = 0;
    #####:  825:            column->InitStretchWeightOrWidth = -1.0f;
    %%%%%:  825-block 14
        -:  826:        }
        -:  827:
        -:  828:        // Update Enabled state, mark settings and sort specs dirty
    4308*:  829:        if (!(table->Flags & ImGuiTableFlags_Hideable) || (column->Flags & ImGuiTableColumnFlags_NoHide))
     4308:  829-block 15
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
    %%%%%:  829-block 16
branch  2 never executed (fallthrough)
branch  3 never executed
     4308:  830:            column->IsUserEnabledNextFrame = true;
     4308:  830-block 17
     4308:  831:        if (column->IsUserEnabled != column->IsUserEnabledNextFrame)
     4308:  831-block 18
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
        -:  832:        {
    #####:  833:            column->IsUserEnabled = column->IsUserEnabledNextFrame;
    #####:  834:            table->IsSettingsDirty = true;
    %%%%%:  834-block 19
        -:  835:        }
    4308*:  836:        column->IsEnabled = column->IsUserEnabled && (column->Flags & ImGuiTableColumnFlags_Disabled) == 0;
     4308:  836-block 20
branch  0 taken 4308 (fallthrough)
branch  1 taken 0
     4308:  836-block 21
branch  2 taken 4308 (fallthrough)
branch  3 taken 0
     4308:  836-block 22
    %%%%%:  836-block 23
        -:  837:
    4308*:  838:        if (column->SortOrder != -1 && !column->IsEnabled)
     4308:  838-block 24
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
    %%%%%:  838-block 25
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:  839:            table->IsSortSpecsDirty = true;
    %%%%%:  839-block 26
    4308*:  840:        if (column->SortOrder > 0 && !(table->Flags & ImGuiTableFlags_SortMulti))
     4308:  840-block 27
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
    %%%%%:  840-block 28
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:  841:            table->IsSortSpecsDirty = true;
    %%%%%:  841-block 29
        -:  842:
        -:  843:        // Auto-fit unsized columns
    4308*:  844:        const bool start_auto_fit = (column->Flags & ImGuiTableColumnFlags_WidthFixed) ? (column->WidthRequest < 0.0f) : (column->StretchWeight < 0.0f);
     4308:  844-block 30
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
    %%%%%:  844-block 31
     4308:  844-block 32
     4308:  845:        if (start_auto_fit)
     4308:  845-block 33
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
    #####:  846:            column->AutoFitQueue = column->CannotSkipItemsQueue = (1 << 3) - 1; // Fit for three frames
    %%%%%:  846-block 34
        -:  847:
    4308*:  848:        if (!column->IsEnabled)
     4308:  848-block 35
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
        -:  849:        {
    #####:  850:            column->IndexWithinEnabledSet = -1;
    #####:  851:            continue;
    %%%%%:  851-block 36
        -:  852:        }
        -:  853:
        -:  854:        // Mark as enabled and link to previous/next enabled column
     4308:  855:        column->PrevEnabledColumn = (ImGuiTableColumnIdx)prev_visible_column_idx;
     4308:  856:        column->NextEnabledColumn = -1;
     4308:  857:        if (prev_visible_column_idx != -1)
     4308:  857-block 37
branch  0 taken 3231 (fallthrough)
branch  1 taken 1077
     3231:  858:            table->Columns[prev_visible_column_idx].NextEnabledColumn = (ImGuiTableColumnIdx)column_n;
     3231:  858-block 38
call    0 returned 3231
        -:  859:        else
     1077:  860:            table->LeftMostEnabledColumn = (ImGuiTableColumnIdx)column_n;
     1077:  860-block 40
     4308:  861:        column->IndexWithinEnabledSet = table->ColumnsEnabledCount++;
     4308:  862:        ImBitArraySetBit(table->EnabledMaskByIndex, column_n);
     4308:  862-block 41
call    0 returned 4308
     4308:  863:        ImBitArraySetBit(table->EnabledMaskByDisplayOrder, column->DisplayOrder);
call    0 returned 4308
     4308:  864:        prev_visible_column_idx = column_n;
    4308*:  865:        IM_ASSERT(column->IndexWithinEnabledSet <= column->DisplayOrder);
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
    %%%%%:  865-block 44
call    2 never executed
        -:  866:
        -:  867:        // Calculate ideal/auto column width (that's the width required for all contents to be visible without clipping)
        -:  868:        // Combine width from regular rows + width from headers unless requested not to.
     4308:  869:        if (!column->IsPreserveWidthAuto && table->InstanceCurrent == 0)
     4308:  869-block 45
branch  0 taken 4304 (fallthrough)
branch  1 taken 4
     4304:  869-block 46
branch  2 taken 4304 (fallthrough)
branch  3 taken 0
     4304:  870:            column->WidthAuto = TableGetColumnWidthAuto(table, column);
     4304:  870-block 47
call    0 returned 4304
branch  1 taken 4304 (fallthrough)
branch  2 taken 0 (throw)
     4304:  870-block 48
        -:  871:
        -:  872:        // Non-resizable columns keep their requested width (apply user value regardless of IsPreserveWidthAuto)
     4308:  873:        const bool column_is_resizable = (column->Flags & ImGuiTableColumnFlags_NoResize) == 0;
     4308:  874:        if (column_is_resizable)
     4308:  874-block 49
branch  0 taken 4308 (fallthrough)
branch  1 taken 0
     4308:  875:            has_resizable = true;
     4308:  875-block 50
    4308*:  876:        if ((column->Flags & ImGuiTableColumnFlags_WidthFixed) && column->InitStretchWeightOrWidth > 0.0f && !column_is_resizable)
     4308:  876-block 51
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
    %%%%%:  876-block 52
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:  876-block 53
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:  877:            column->WidthAuto = column->InitStretchWeightOrWidth;
    %%%%%:  877-block 54
        -:  878:
     4308:  879:        if (column->AutoFitQueue != 0x00)
     4308:  879-block 55
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
    #####:  880:            has_auto_fit_request = true;
    %%%%%:  880-block 56
     4308:  881:        if (column->Flags & ImGuiTableColumnFlags_WidthStretch)
     4308:  881-block 57
branch  0 taken 4308 (fallthrough)
branch  1 taken 0
        -:  882:        {
     4308:  883:            stretch_sum_width_auto += column->WidthAuto;
     4308:  884:            count_stretch++;
     4308:  884-block 58
        -:  885:        }
        -:  886:        else
        -:  887:        {
    #####:  888:            fixed_max_width_auto = ImMax(fixed_max_width_auto, column->WidthAuto);
    %%%%%:  888-block 59
call    0 never executed
    #####:  889:            count_fixed++;
        -:  890:        }
        -:  891:    }
    1077*:  892:    if ((table->Flags & ImGuiTableFlags_Sortable) && table->SortSpecsCount == 0 && !(table->Flags & ImGuiTableFlags_SortTristate))
     1077:  892-block 63
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:  892-block 64
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:  892-block 65
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:  893:        table->IsSortSpecsDirty = true;
    %%%%%:  893-block 66
     1077:  894:    table->RightMostEnabledColumn = (ImGuiTableColumnIdx)prev_visible_column_idx;
    1077*:  895:    IM_ASSERT(table->LeftMostEnabledColumn >= 0 && table->RightMostEnabledColumn >= 0);
     1077:  895-block 67
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:  895-block 68
branch  2 taken 1077 (fallthrough)
branch  3 taken 0
     1077:  895-block 69
    %%%%%:  895-block 70
call    4 never executed
        -:  896:
        -:  897:    // [Part 2] Disable child window clipping while fitting columns. This is not strictly necessary but makes it possible to avoid
        -:  898:    // the column fitting having to wait until the first visible frame of the child container (may or not be a good thing). Also see #6510.
        -:  899:    // FIXME-TABLE: for always auto-resizing columns may not want to do that all the time.
    1077*:  900:    if (has_auto_fit_request && table->OuterWindow != table->InnerWindow)
     1077:  900-block 71
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:  900-block 72
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:  901:        table->InnerWindow->SkipItems = false;
    %%%%%:  901-block 73
     1077:  902:    if (has_auto_fit_request)
     1077:  902-block 74
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####:  903:        table->IsSettingsDirty = true;
    %%%%%:  903-block 75
        -:  904:
        -:  905:    // [Part 3] Fix column flags and record a few extra information.
     1077:  906:    float sum_width_requests = 0.0f;    // Sum of all width for fixed and auto-resize columns, excluding width contributed by Stretch columns but including spacing/padding.
     1077:  907:    float stretch_sum_weights = 0.0f;   // Sum of all weights for stretch columns.
     1077:  908:    table->LeftMostStretchedColumn = table->RightMostStretchedColumn = -1;
     5385:  909:    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
     1077:  909-block 76
     4308:  909-block 120
     5385:  909-block 121
branch  0 taken 4308
branch  1 taken 1077 (fallthrough)
        -:  910:    {
    4308*:  911:        if (!IM_BITARRAY_TESTBIT(table->EnabledMaskByIndex, column_n))
     4308:  911-block 77
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
    #####:  912:            continue;
    %%%%%:  912-block 78
     4308:  913:        ImGuiTableColumn* column = &table->Columns[column_n];
     4308:  913-block 79
call    0 returned 4308
        -:  914:
     4308:  915:        const bool column_is_resizable = (column->Flags & ImGuiTableColumnFlags_NoResize) == 0;
     4308:  916:        if (column->Flags & ImGuiTableColumnFlags_WidthFixed)
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
        -:  917:        {
        -:  918:            // Apply same widths policy
    #####:  919:            float width_auto = column->WidthAuto;
    #####:  920:            if (table_sizing_policy == ImGuiTableFlags_SizingFixedSame && (column->AutoFitQueue != 0x00 || !column_is_resizable))
    %%%%%:  920-block 81
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  920-block 82
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:  920-block 83
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:  921:                width_auto = fixed_max_width_auto;
    %%%%%:  921-block 84
        -:  922:
        -:  923:            // Apply automatic width
        -:  924:            // Latch initial size for fixed columns and update it constantly for auto-resizing column (unless clipped!)
    #####:  925:            if (column->AutoFitQueue != 0x00)
    %%%%%:  925-block 85
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  926:                column->WidthRequest = width_auto;
    %%%%%:  926-block 86
    #####:  927:            else if ((column->Flags & ImGuiTableColumnFlags_WidthFixed) && !column_is_resizable && column->IsRequestOutput)
    %%%%%:  927-block 87
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  927-block 88
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:  927-block 89
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:  928:                column->WidthRequest = width_auto;
    %%%%%:  928-block 90
        -:  929:
        -:  930:            // FIXME-TABLE: Increase minimum size during init frame to avoid biasing auto-fitting widgets
        -:  931:            // (e.g. TextWrapped) too much. Otherwise what tends to happen is that TextWrapped would output a very
        -:  932:            // large height (= first frame scrollbar display very off + clipper would skip lots of items).
        -:  933:            // This is merely making the side-effect less extreme, but doesn't properly fixes it.
        -:  934:            // FIXME: Move this to ->WidthGiven to avoid temporary lossyless?
        -:  935:            // FIXME: This break IsPreserveWidthAuto from not flickering if the stored WidthAuto was smaller.
    #####:  936:            if (column->AutoFitQueue > 0x01 && table->IsInitializing && !column->IsPreserveWidthAuto)
    %%%%%:  936-block 91
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  936-block 92
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:  936-block 93
branch  4 never executed (fallthrough)
branch  5 never executed
    #####:  937:                column->WidthRequest = ImMax(column->WidthRequest, table->MinColumnWidth * 4.0f); // FIXME-TABLE: Another constant/scale?
    %%%%%:  937-block 94
call    0 never executed
    #####:  938:            sum_width_requests += column->WidthRequest;
    %%%%%:  938-block 96
        -:  939:        }
        -:  940:        else
        -:  941:        {
        -:  942:            // Initialize stretch weight
     4308:  943:            if (column->AutoFitQueue != 0x00 || column->StretchWeight < 0.0f || !column_is_resizable)
     4308:  943-block 97
branch  0 taken 4308 (fallthrough)
branch  1 taken 0
     4308:  943-block 98
branch  2 taken 4308 (fallthrough)
branch  3 taken 0
     4308:  943-block 99
branch  4 taken 0 (fallthrough)
branch  5 taken 4308
        -:  944:            {
    #####:  945:                if (column->InitStretchWeightOrWidth > 0.0f)
    %%%%%:  945-block 100
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  946:                    column->StretchWeight = column->InitStretchWeightOrWidth;
    %%%%%:  946-block 101
    #####:  947:                else if (table_sizing_policy == ImGuiTableFlags_SizingStretchProp)
    %%%%%:  947-block 102
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  948:                    column->StretchWeight = (column->WidthAuto / stretch_sum_width_auto) * count_stretch;
    %%%%%:  948-block 103
        -:  949:                else
    #####:  950:                    column->StretchWeight = 1.0f;
    %%%%%:  950-block 104
        -:  951:            }
        -:  952:
     4308:  953:            stretch_sum_weights += column->StretchWeight;
     4308:  954:            if (table->LeftMostStretchedColumn == -1 || table->Columns[table->LeftMostStretchedColumn].DisplayOrder > column->DisplayOrder)
     4308:  954-block 105
branch  0 taken 3231 (fallthrough)
branch  1 taken 1077
     3231:  954-block 106
call    2 returned 3231
branch  3 taken 0 (fallthrough)
branch  4 taken 3231
     1077:  954-block 108
     3231:  954-block 109
     4308:  954-block 110
branch  5 taken 1077 (fallthrough)
branch  6 taken 3231
     1077:  955:                table->LeftMostStretchedColumn = (ImGuiTableColumnIdx)column_n;
     1077:  955-block 111
    4308*:  956:            if (table->RightMostStretchedColumn == -1 || table->Columns[table->RightMostStretchedColumn].DisplayOrder < column->DisplayOrder)
     4308:  956-block 112
branch  0 taken 3231 (fallthrough)
branch  1 taken 1077
     3231:  956-block 113
call    2 returned 3231
branch  3 taken 3231 (fallthrough)
branch  4 taken 0
     4308:  956-block 115
    %%%%%:  956-block 116
     4308:  956-block 117
branch  5 taken 4308 (fallthrough)
branch  6 taken 0
     4308:  957:                table->RightMostStretchedColumn = (ImGuiTableColumnIdx)column_n;
     4308:  957-block 118
        -:  958:        }
     4308:  959:        column->IsPreserveWidthAuto = false;
     4308:  960:        sum_width_requests += table->CellPaddingX * 2.0f;
     4308:  960-block 119
        -:  961:    }
     1077:  962:    table->ColumnsEnabledFixedCount = (ImGuiTableColumnIdx)count_fixed;
     1077:  963:    table->ColumnsStretchSumWeights = stretch_sum_weights;
        -:  964:
        -:  965:    // [Part 4] Apply final widths based on requested widths
     1077:  966:    const ImRect work_rect = table->WorkRect;
     1077:  967:    const float width_spacings = (table->OuterPaddingX * 2.0f) + (table->CellSpacingX1 + table->CellSpacingX2) * (table->ColumnsEnabledCount - 1);
    1077*:  968:    const float width_removed = (table->HasScrollbarYPrev && !table->InnerWindow->ScrollbarY) ? g.Style.ScrollbarSize : 0.0f; // To synchronize decoration width of synched tables with mismatching scrollbar state (#5920)
     1077:  968-block 122
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:  968-block 123
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:  968-block 124
     1077:  968-block 125
    1077*:  969:    const float width_avail = ImMax(1.0f, (((table->Flags & ImGuiTableFlags_ScrollX) && table->InnerWidth == 0.0f) ? table->InnerClipRect.GetWidth() : work_rect.GetWidth()) - width_removed);
     1077:  969-block 126
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:  969-block 127
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:  969-block 128
call    4 never executed
     1077:  969-block 129
call    5 returned 1077
     1077:  969-block 130
call    6 returned 1077
     1077:  970:    const float width_avail_for_stretched_columns = width_avail - width_spacings - sum_width_requests;
     1077:  971:    float width_remaining_for_stretched_columns = width_avail_for_stretched_columns;
     1077:  972:    table->ColumnsGivenWidth = width_spacings + (table->CellPaddingX * 2.0f) * table->ColumnsEnabledCount;
     5385:  973:    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
     4308:  973-block 144
     5385:  973-block 145
branch  0 taken 4308
branch  1 taken 1077 (fallthrough)
        -:  974:    {
    4308*:  975:        if (!IM_BITARRAY_TESTBIT(table->EnabledMaskByIndex, column_n))
     4308:  975-block 132
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
    #####:  976:            continue;
    %%%%%:  976-block 133
     4308:  977:        ImGuiTableColumn* column = &table->Columns[column_n];
     4308:  977-block 134
call    0 returned 4308
        -:  978:
        -:  979:        // Allocate width for stretched/weighted columns (StretchWeight gets converted into WidthRequest)
     4308:  980:        if (column->Flags & ImGuiTableColumnFlags_WidthStretch)
branch  0 taken 4308 (fallthrough)
branch  1 taken 0
        -:  981:        {
     4308:  982:            float weight_ratio = column->StretchWeight / stretch_sum_weights;
     4308:  983:            column->WidthRequest = IM_TRUNC(ImMax(width_avail_for_stretched_columns * weight_ratio, table->MinColumnWidth) + 0.01f);
     4308:  983-block 136
call    0 returned 4308
     4308:  984:            width_remaining_for_stretched_columns -= column->WidthRequest;
        -:  985:        }
        -:  986:
        -:  987:        // [Resize Rule 1] The right-most Visible column is not resizable if there is at least one Stretch column
        -:  988:        // See additional comments in TableSetColumnWidth().
     4308:  989:        if (column->NextEnabledColumn == -1 && table->LeftMostStretchedColumn != -1)
     4308:  989-block 138
branch  0 taken 1077 (fallthrough)
branch  1 taken 3231
     1077:  989-block 139
branch  2 taken 1077 (fallthrough)
branch  3 taken 0
     1077:  990:            column->Flags |= ImGuiTableColumnFlags_NoDirectResize_;
     1077:  990-block 140
        -:  991:
        -:  992:        // Assign final width, record width in case we will need to shrink
     4308:  993:        column->WidthGiven = ImTrunc(ImMax(column->WidthRequest, table->MinColumnWidth));
     4308:  993-block 141
call    0 returned 4308
call    1 returned 4308
     4308:  994:        table->ColumnsGivenWidth += column->WidthGiven;
        -:  995:    }
        -:  996:
        -:  997:    // [Part 5] Redistribute stretch remainder width due to rounding (remainder width is < 1.0f * number of Stretch column).
        -:  998:    // Using right-to-left distribution (more likely to match resizing cursor).
     1077:  999:    if (width_remaining_for_stretched_columns >= 1.0f && !(table->Flags & ImGuiTableFlags_PreciseWidths))
     1077:  999-block 146
branch  0 taken 1076 (fallthrough)
branch  1 taken 1
     1076:  999-block 147
branch  2 taken 1076 (fallthrough)
branch  3 taken 0
     2152: 1000:        for (int order_n = table->ColumnsCount - 1; stretch_sum_weights > 0.0f && width_remaining_for_stretched_columns >= 1.0f && order_n >= 0; order_n--)
     1076: 1000-block 148
     1076: 1000-block 156
     2152: 1000-block 157
branch  0 taken 2152 (fallthrough)
branch  1 taken 0
     2152: 1000-block 158
branch  2 taken 1076 (fallthrough)
branch  3 taken 1076
     1076: 1000-block 159
branch  4 taken 1076
branch  5 taken 0 (fallthrough)
        -: 1001:        {
    1076*: 1002:            if (!IM_BITARRAY_TESTBIT(table->EnabledMaskByDisplayOrder, order_n))
     1076: 1002-block 149
branch  0 taken 0 (fallthrough)
branch  1 taken 1076
    #####: 1003:                continue;
    %%%%%: 1003-block 150
     1076: 1004:            ImGuiTableColumn* column = &table->Columns[table->DisplayOrderToIndex[order_n]];
     1076: 1004-block 151
call    0 returned 1076
call    1 returned 1076
    1076*: 1005:            if (!(column->Flags & ImGuiTableColumnFlags_WidthStretch))
branch  0 taken 0 (fallthrough)
branch  1 taken 1076
    #####: 1006:                continue;
    %%%%%: 1006-block 154
     1076: 1007:            column->WidthRequest += 1.0f;
     1076: 1008:            column->WidthGiven += 1.0f;
     1076: 1009:            width_remaining_for_stretched_columns -= 1.0f;
     1076: 1009-block 155
        -: 1010:        }
        -: 1011:
        -: 1012:    // Determine if table is hovered which will be used to flag columns as hovered.
        -: 1013:    // - In principle we'd like to use the equivalent of IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem),
        -: 1014:    //   but because our item is partially submitted at this point we use ItemHoverable() and a workaround (temporarily
        -: 1015:    //   clear ActiveId, which is equivalent to the change provided by _AllowWhenBLockedByActiveItem).
        -: 1016:    // - This allows columns to be marked as hovered when e.g. clicking a button inside the column, or using drag and drop.
     1077: 1017:    ImGuiTableInstanceData* table_instance = TableGetInstanceData(table, table->InstanceCurrent);
     1077: 1017-block 160
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077: 1018:    table_instance->HoveredRowLast = table_instance->HoveredRowNext;
     1077: 1019:    table_instance->HoveredRowNext = -1;
     1077: 1020:    table->HoveredColumnBody = table->HoveredColumnBorder = -1;
     1077: 1021:    const ImRect mouse_hit_rect(table->OuterRect.Min.x, table->OuterRect.Min.y, table->OuterRect.Max.x, ImMax(table->OuterRect.Max.y, table->OuterRect.Min.y + table_instance->LastOuterHeight));
     1077: 1021-block 161
call    0 returned 1077
call    1 returned 1077
     1077: 1022:    const ImGuiID backup_active_id = g.ActiveId;
     1077: 1023:    g.ActiveId = 0;
     1077: 1024:    const bool is_hovering_table = ItemHoverable(mouse_hit_rect, 0, ImGuiItemFlags_None);
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077: 1025:    g.ActiveId = backup_active_id;
        -: 1026:
        -: 1027:    // Determine skewed MousePos.x to support angled headers.
     1077: 1028:    float mouse_skewed_x = g.IO.MousePos.x;
     1077: 1029:    if (table->AngledHeadersHeight > 0.0f)
     1077: 1029-block 164
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####: 1030:        if (g.IO.MousePos.y >= table->OuterRect.Min.y && g.IO.MousePos.y <= table->OuterRect.Min.y + table->AngledHeadersHeight)
    %%%%%: 1030-block 165
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1030-block 166
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 1031:            mouse_skewed_x += ImTrunc((table->OuterRect.Min.y + table->AngledHeadersHeight - g.IO.MousePos.y) * table->AngledHeadersSlope);
    %%%%%: 1031-block 167
call    0 never executed
        -: 1032:
        -: 1033:    // [Part 6] Setup final position, offset, skip/clip states and clipping rectangles, detect hovered column
        -: 1034:    // Process columns in their visible orders as we are comparing the visible order and adjusting host_clip_rect while looping.
     1077: 1035:    int visible_n = 0;
     1077: 1036:    bool has_at_least_one_column_requesting_output = false;
     1077: 1037:    bool offset_x_frozen = (table->FreezeColumnsCount > 0);
    1077*: 1038:    float offset_x = ((table->FreezeColumnsCount > 0) ? table->OuterRect.Min.x : work_rect.Min.x) + table->OuterPaddingX - table->CellSpacingX1;
     1077: 1038-block 169
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 1038-block 170
     1077: 1038-block 171
     1077: 1039:    ImRect host_clip_rect = table->InnerClipRect;
        -: 1040:    //host_clip_rect.Max.x += table->CellPaddingX + table->CellSpacingX2;
     1077: 1041:    ImBitArrayClearAllBits(table->VisibleMaskByIndex, table->ColumnsCount);
     1077: 1041-block 172
call    0 returned 1077
     5385: 1042:    for (int order_n = 0; order_n < table->ColumnsCount; order_n++)
     4308: 1042-block 226
     5385: 1042-block 227
branch  0 taken 4308
branch  1 taken 1077 (fallthrough)
        -: 1043:    {
     4308: 1044:        const int column_n = table->DisplayOrderToIndex[order_n];
     4308: 1044-block 174
call    0 returned 4308
     4308: 1045:        ImGuiTableColumn* column = &table->Columns[column_n];
call    0 returned 4308
        -: 1046:
    4308*: 1047:        column->NavLayerCurrent = (ImS8)(table->FreezeRowsCount > 0 ? ImGuiNavLayer_Menu : ImGuiNavLayer_Main); // Use Count NOT request so Header line changes layer when frozen
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
    %%%%%: 1047-block 177
     4308: 1047-block 178
        -: 1048:
    4308*: 1049:        if (offset_x_frozen && table->FreezeColumnsCount == visible_n)
     4308: 1049-block 179
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
    %%%%%: 1049-block 180
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 1050:        {
    #####: 1051:            offset_x += work_rect.Min.x - table->OuterRect.Min.x;
    #####: 1052:            offset_x_frozen = false;
    %%%%%: 1052-block 181
        -: 1053:        }
        -: 1054:
        -: 1055:        // Clear status flags
     4308: 1056:        column->Flags &= ~ImGuiTableColumnFlags_StatusMask_;
        -: 1057:
    4308*: 1058:        if (!IM_BITARRAY_TESTBIT(table->EnabledMaskByDisplayOrder, order_n))
     4308: 1058-block 182
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
        -: 1059:        {
        -: 1060:            // Hidden column: clear a few fields and we are done with it for the remainder of the function.
        -: 1061:            // We set a zero-width clip rect but set Min.y/Max.y properly to not interfere with the clipper.
    #####: 1062:            column->MinX = column->MaxX = column->WorkMinX = column->ClipRect.Min.x = column->ClipRect.Max.x = offset_x;
    #####: 1063:            column->WidthGiven = 0.0f;
    #####: 1064:            column->ClipRect.Min.y = work_rect.Min.y;
    #####: 1065:            column->ClipRect.Max.y = FLT_MAX;
    #####: 1066:            column->ClipRect.ClipWithFull(host_clip_rect);
    %%%%%: 1066-block 183
call    0 never executed
    #####: 1067:            column->IsVisibleX = column->IsVisibleY = column->IsRequestOutput = false;
    #####: 1068:            column->IsSkipItems = true;
    #####: 1069:            column->ItemWidth = 1.0f;
    #####: 1070:            continue;
        -: 1071:        }
        -: 1072:
        -: 1073:        // Lock start position
     4308: 1074:        column->MinX = offset_x;
        -: 1075:
        -: 1076:        // Lock width based on start position and minimum/maximum width for this position
     4308: 1077:        column->WidthMax = TableCalcMaxColumnWidth(table, column_n);
     4308: 1077-block 185
call    0 returned 4308
branch  1 taken 4308 (fallthrough)
branch  2 taken 0 (throw)
     4308: 1078:        column->WidthGiven = ImMin(column->WidthGiven, column->WidthMax);
     4308: 1078-block 186
call    0 returned 4308
     4308: 1079:        column->WidthGiven = ImMax(column->WidthGiven, ImMin(column->WidthRequest, table->MinColumnWidth));
call    0 returned 4308
call    1 returned 4308
     4308: 1080:        column->MaxX = offset_x + column->WidthGiven + table->CellSpacingX1 + table->CellSpacingX2 + table->CellPaddingX * 2.0f;
        -: 1081:
        -: 1082:        // Lock other positions
        -: 1083:        // - ClipRect.Min.x: Because merging draw commands doesn't compare min boundaries, we make ClipRect.Min.x match left bounds to be consistent regardless of merging.
        -: 1084:        // - ClipRect.Max.x: using WorkMaxX instead of MaxX (aka including padding) makes things more consistent when resizing down, tho slightly detrimental to visibility in very-small column.
        -: 1085:        // - ClipRect.Max.x: using MaxX makes it easier for header to receive hover highlight with no discontinuity and display sorting arrow.
        -: 1086:        // - FIXME-TABLE: We want equal width columns to have equal (ClipRect.Max.x - WorkMinX) width, which means ClipRect.max.x cannot stray off host_clip_rect.Max.x else right-most column may appear shorter.
     4308: 1087:        const float previous_instance_work_min_x = column->WorkMinX;
     4308: 1088:        column->WorkMinX = column->MinX + table->CellPaddingX + table->CellSpacingX1;
     4308: 1089:        column->WorkMaxX = column->MaxX - table->CellPaddingX - table->CellSpacingX2; // Expected max
     4308: 1090:        column->ItemWidth = ImTrunc(column->WidthGiven * 0.65f);
call    0 returned 4308
     4308: 1091:        column->ClipRect.Min.x = column->MinX;
     4308: 1092:        column->ClipRect.Min.y = work_rect.Min.y;
     4308: 1093:        column->ClipRect.Max.x = column->MaxX; //column->WorkMaxX;
     4308: 1094:        column->ClipRect.Max.y = FLT_MAX;
     4308: 1095:        column->ClipRect.ClipWithFull(host_clip_rect);
call    0 returned 4308
        -: 1096:
        -: 1097:        // Mark column as Clipped (not in sight)
        -: 1098:        // Note that scrolling tables (where inner_window != outer_window) handle Y clipped earlier in BeginTable() so IsVisibleY really only applies to non-scrolling tables.
        -: 1099:        // FIXME-TABLE: Because InnerClipRect.Max.y is conservatively ==outer_window->ClipRect.Max.y, we never can mark columns _Above_ the scroll line as not IsVisibleY.
        -: 1100:        // Taking advantage of LastOuterHeight would yield good results there...
        -: 1101:        // FIXME-TABLE: Y clipping is disabled because it effectively means not submitting will reduce contents width which is fed to outer_window->DC.CursorMaxPos.x,
        -: 1102:        // and this may be used (e.g. typically by outer_window using AlwaysAutoResize or outer_window's horizontal scrollbar, but could be something else).
        -: 1103:        // Possible solution to preserve last known content width for clipped column. Test 'table_reported_size' fails when enabling Y clipping and window is resized small.
     4308: 1104:        column->IsVisibleX = (column->ClipRect.Max.x > column->ClipRect.Min.x);
     4308: 1105:        column->IsVisibleY = true; // (column->ClipRect.Max.y > column->ClipRect.Min.y);
     4308: 1106:        const bool is_visible = column->IsVisibleX; //&& column->IsVisibleY;
     4308: 1107:        if (is_visible)
branch  0 taken 4305 (fallthrough)
branch  1 taken 3
     4305: 1108:            ImBitArraySetBit(table->VisibleMaskByIndex, column_n);
     4305: 1108-block 192
call    0 returned 4305
        -: 1109:
        -: 1110:        // Mark column as requesting output from user. Note that fixed + non-resizable sets are auto-fitting at all times and therefore always request output.
     4308: 1111:        column->IsRequestOutput = is_visible || column->AutoFitQueue != 0 || column->CannotSkipItemsQueue != 0;
     4308: 1111-block 193
branch  0 taken 3 (fallthrough)
branch  1 taken 4305
        3: 1111-block 194
branch  2 taken 3 (fallthrough)
branch  3 taken 0
        3: 1111-block 195
branch  4 taken 0 (fallthrough)
branch  5 taken 3
     4305: 1111-block 196
        3: 1111-block 197
        -: 1112:
        -: 1113:        // Mark column as SkipItems (ignoring all items/layout)
        -: 1114:        // (table->HostSkipItems is a copy of inner_window->SkipItems before we cleared it above in Part 2)
    4308*: 1115:        column->IsSkipItems = !column->IsEnabled || table->HostSkipItems;
     4308: 1115-block 198
branch  0 taken 4308 (fallthrough)
branch  1 taken 0
     4308: 1115-block 199
branch  2 taken 0 (fallthrough)
branch  3 taken 4308
    %%%%%: 1115-block 200
     4308: 1115-block 201
     4308: 1116:        if (column->IsSkipItems)
     4308: 1116-block 202
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
    #####: 1117:            IM_ASSERT(!is_visible);
    %%%%%: 1117-block 203
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1117-block 204
call    2 never executed
     4308: 1118:        if (column->IsRequestOutput && !column->IsSkipItems)
     4308: 1118-block 205
branch  0 taken 4305 (fallthrough)
branch  1 taken 3
     4305: 1118-block 206
branch  2 taken 4305 (fallthrough)
branch  3 taken 0
     4305: 1119:            has_at_least_one_column_requesting_output = true;
     4305: 1119-block 207
        -: 1120:
        -: 1121:        // Update status flags
     4308: 1122:        column->Flags |= ImGuiTableColumnFlags_IsEnabled;
     4308: 1123:        if (is_visible)
     4308: 1123-block 208
branch  0 taken 4305 (fallthrough)
branch  1 taken 3
     4305: 1124:            column->Flags |= ImGuiTableColumnFlags_IsVisible;
     4305: 1124-block 209
     4308: 1125:        if (column->SortOrder != -1)
     4308: 1125-block 210
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
    #####: 1126:            column->Flags |= ImGuiTableColumnFlags_IsSorted;
    %%%%%: 1126-block 211
        -: 1127:
        -: 1128:        // Detect hovered column
    4308*: 1129:        if (is_hovering_table && mouse_skewed_x >= column->ClipRect.Min.x && mouse_skewed_x < column->ClipRect.Max.x)
     4308: 1129-block 212
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
    %%%%%: 1129-block 213
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1129-block 214
branch  4 never executed (fallthrough)
branch  5 never executed
        -: 1130:        {
    #####: 1131:            column->Flags |= ImGuiTableColumnFlags_IsHovered;
    #####: 1132:            table->HoveredColumnBody = (ImGuiTableColumnIdx)column_n;
    %%%%%: 1132-block 215
        -: 1133:        }
        -: 1134:
        -: 1135:        // Alignment
        -: 1136:        // FIXME-TABLE: This align based on the whole column width, not per-cell, and therefore isn't useful in
        -: 1137:        // many cases (to be able to honor this we might be able to store a log of cells width, per row, for
        -: 1138:        // visible rows, but nav/programmatic scroll would have visible artifacts.)
        -: 1139:        //if (column->Flags & ImGuiTableColumnFlags_AlignRight)
        -: 1140:        //    column->WorkMinX = ImMax(column->WorkMinX, column->MaxX - column->ContentWidthRowsUnfrozen);
        -: 1141:        //else if (column->Flags & ImGuiTableColumnFlags_AlignCenter)
        -: 1142:        //    column->WorkMinX = ImLerp(column->WorkMinX, ImMax(column->StartX, column->MaxX - column->ContentWidthRowsUnfrozen), 0.5f);
        -: 1143:
        -: 1144:        // Reset content width variables
     4308: 1145:        if (table->InstanceCurrent == 0)
     4308: 1145-block 216
branch  0 taken 4308 (fallthrough)
branch  1 taken 0
        -: 1146:        {
     4308: 1147:            column->ContentMaxXFrozen = column->WorkMinX;
     4308: 1148:            column->ContentMaxXUnfrozen = column->WorkMinX;
     4308: 1149:            column->ContentMaxXHeadersUsed = column->WorkMinX;
     4308: 1150:            column->ContentMaxXHeadersIdeal = column->WorkMinX;
     4308: 1150-block 217
        -: 1151:        }
        -: 1152:        else
        -: 1153:        {
        -: 1154:            // As we store an absolute value to make per-cell updates faster, we need to offset values used for width computation.
    #####: 1155:            const float offset_from_previous_instance = column->WorkMinX - previous_instance_work_min_x;
    #####: 1156:            column->ContentMaxXFrozen += offset_from_previous_instance;
    #####: 1157:            column->ContentMaxXUnfrozen += offset_from_previous_instance;
    #####: 1158:            column->ContentMaxXHeadersUsed += offset_from_previous_instance;
    #####: 1159:            column->ContentMaxXHeadersIdeal += offset_from_previous_instance;
    %%%%%: 1159-block 218
        -: 1160:        }
        -: 1161:
        -: 1162:        // Don't decrement auto-fit counters until container window got a chance to submit its items
     4308: 1163:        if (table->HostSkipItems == false && table->InstanceCurrent == 0)
     4308: 1163-block 219
branch  0 taken 4308 (fallthrough)
branch  1 taken 0
     4308: 1163-block 220
branch  2 taken 4308 (fallthrough)
branch  3 taken 0
        -: 1164:        {
     4308: 1165:            column->AutoFitQueue >>= 1;
     4308: 1166:            column->CannotSkipItemsQueue >>= 1;
     4308: 1166-block 221
        -: 1167:        }
        -: 1168:
     4308: 1169:        if (visible_n < table->FreezeColumnsCount)
     4308: 1169-block 222
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
    #####: 1170:            host_clip_rect.Min.x = ImClamp(column->MaxX + TABLE_BORDER_SIZE, host_clip_rect.Min.x, host_clip_rect.Max.x);
    %%%%%: 1170-block 223
call    0 never executed
        -: 1171:
     4308: 1172:        offset_x += column->WidthGiven + table->CellSpacingX1 + table->CellSpacingX2 + table->CellPaddingX * 2.0f;
     4308: 1173:        visible_n++;
     4308: 1173-block 225
        -: 1174:    }
        -: 1175:
        -: 1176:    // In case the table is visible (e.g. decorations) but all columns clipped, we keep a column visible.
        -: 1177:    // Else if give no chance to a clipper-savy user to submit rows and therefore total contents height used by scrollbar.
     1077: 1178:    if (has_at_least_one_column_requesting_output == false)
     1077: 1178-block 228
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
        -: 1179:    {
    #####: 1180:        table->Columns[table->LeftMostEnabledColumn].IsRequestOutput = true;
    %%%%%: 1180-block 229
call    0 never executed
    #####: 1181:        table->Columns[table->LeftMostEnabledColumn].IsSkipItems = false;
call    0 never executed
        -: 1182:    }
        -: 1183:
        -: 1184:    // [Part 7] Detect/store when we are hovering the unused space after the right-most column (so e.g. context menus can react on it)
        -: 1185:    // Clear Resizable flag if none of our column are actually resizable (either via an explicit _NoResize flag, either
        -: 1186:    // because of using _WidthAuto/_WidthStretch). This will hide the resizing option from the context menu.
     1077: 1187:    const float unused_x1 = ImMax(table->WorkRect.Min.x, table->Columns[table->RightMostEnabledColumn].ClipRect.Max.x);
     1077: 1187-block 232
call    0 returned 1077
call    1 returned 1077
    1077*: 1188:    if (is_hovering_table && table->HoveredColumnBody == -1)
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 1188-block 235
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 1189:        if (mouse_skewed_x >= unused_x1)
    %%%%%: 1189-block 236
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1190:            table->HoveredColumnBody = (ImGuiTableColumnIdx)table->ColumnsCount;
    %%%%%: 1190-block 237
    1077*: 1191:    if (has_resizable == false && (table->Flags & ImGuiTableFlags_Resizable))
     1077: 1191-block 238
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 1191-block 239
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 1192:        table->Flags &= ~ImGuiTableFlags_Resizable;
    %%%%%: 1192-block 240
        -: 1193:
     1077: 1194:    table->IsActiveIdAliveBeforeTable = (g.ActiveIdIsAlive != 0);
        -: 1195:
        -: 1196:    // [Part 8] Lock actual OuterRect/WorkRect right-most position.
        -: 1197:    // This is done late to handle the case of fixed-columns tables not claiming more widths that they need.
        -: 1198:    // Because of this we are careful with uses of WorkRect and InnerClipRect before this point.
     1077: 1199:    if (table->RightMostStretchedColumn != -1)
     1077: 1199-block 241
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 1200:        table->Flags &= ~ImGuiTableFlags_NoHostExtendX;
     1077: 1200-block 242
     1077: 1201:    if (table->Flags & ImGuiTableFlags_NoHostExtendX)
     1077: 1201-block 243
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
        -: 1202:    {
    #####: 1203:        table->OuterRect.Max.x = table->WorkRect.Max.x = unused_x1;
    #####: 1204:        table->InnerClipRect.Max.x = ImMin(table->InnerClipRect.Max.x, unused_x1);
    %%%%%: 1204-block 244
call    0 never executed
        -: 1205:    }
     1077: 1206:    table->InnerWindow->ParentWorkRect = table->WorkRect;
     1077: 1207:    table->BorderX1 = table->InnerClipRect.Min.x;
     1077: 1208:    table->BorderX2 = table->InnerClipRect.Max.x;
        -: 1209:
        -: 1210:    // Setup window's WorkRect.Max.y for GetContentRegionAvail(). Other values will be updated in each TableBeginCell() call.
        -: 1211:    float window_content_max_y;
     1077: 1212:    if (table->Flags & ImGuiTableFlags_NoHostExtendY)
     1077: 1212-block 246
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####: 1213:        window_content_max_y = table->OuterRect.Max.y;
    %%%%%: 1213-block 247
        -: 1214:    else
    1077*: 1215:        window_content_max_y = ImMax(table->InnerWindow->ContentRegionRect.Max.y, (table->Flags & ImGuiTableFlags_ScrollY) ? 0.0f : table->OuterRect.Max.y);
     1077: 1215-block 248
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 1215-block 249
    %%%%%: 1215-block 250
     1077: 1215-block 251
call    2 returned 1077
     1077: 1216:    table->InnerWindow->WorkRect.Max.y = ImClamp(window_content_max_y - g.Style.CellPadding.y, table->InnerWindow->WorkRect.Min.y, table->InnerWindow->WorkRect.Max.y);
     1077: 1216-block 252
call    0 returned 1077
        -: 1217:
        -: 1218:    // [Part 9] Allocate draw channels and setup background cliprect
     1077: 1219:    TableSetupDrawChannels(table);
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -: 1220:
        -: 1221:    // [Part 10] Hit testing on borders
     1077: 1222:    if (table->Flags & ImGuiTableFlags_Resizable)
     1077: 1222-block 254
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 1223:        TableUpdateBorders(table);
     1077: 1223-block 255
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077: 1224:    table_instance->LastTopHeadersRowHeight = 0.0f;
     1077: 1225:    table->IsLayoutLocked = true;
     1077: 1226:    table->IsUsingHeaders = false;
        -: 1227:
        -: 1228:    // Highlight header
     1077: 1229:    table->HighlightColumnHeader = -1;
    1077*: 1230:    if (table->IsContextPopupOpen && table->ContextPopupColumn != -1 && table->InstanceInteracted == table->InstanceCurrent)
     1077: 1230-block 256
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 1230-block 257
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1230-block 258
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 1231:        table->HighlightColumnHeader = table->ContextPopupColumn;
    %%%%%: 1231-block 259
    1077*: 1232:    else if ((table->Flags & ImGuiTableFlags_HighlightHoveredColumn) && table->HoveredColumnBody != -1 && table->HoveredColumnBody != table->ColumnsCount && table->HoveredColumnBorder == -1)
     1077: 1232-block 260
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 1232-block 261
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1232-block 262
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 1232-block 263
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 1233:        if (g.ActiveId == 0 || (table->IsActiveIdInTable || g.DragDropActive))
    %%%%%: 1233-block 264
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1233-block 265
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1233-block 266
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 1234:            table->HighlightColumnHeader = table->HoveredColumnBody;
    %%%%%: 1234-block 267
        -: 1235:
        -: 1236:    // [Part 11] Default context menu
        -: 1237:    // - To append to this menu: you can call TableBeginContextMenuPopup()/.../EndPopup().
        -: 1238:    // - To modify or replace this: set table->IsContextPopupNoDefaultContents = true, then call TableBeginContextMenuPopup()/.../EndPopup().
        -: 1239:    // - You may call TableDrawDefaultContextMenu() with selected flags to display specific sections of the default menu,
        -: 1240:    //   e.g. TableDrawDefaultContextMenu(table, table->Flags & ~ImGuiTableFlags_Hideable) will display everything EXCEPT columns visibility options.
    1077*: 1241:    if (table->DisableDefaultContextMenu == false && TableBeginContextMenuPopup(table))
     1077: 1241-block 268
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 1241-block 269
call    2 returned 1077
branch  3 taken 1077 (fallthrough)
branch  4 taken 0 (throw)
     1077: 1241-block 270
branch  5 taken 0 (fallthrough)
branch  6 taken 1077
    %%%%%: 1241-block 271
     1077: 1241-block 272
     1077: 1241-block 273
branch  7 taken 0 (fallthrough)
branch  8 taken 1077
        -: 1242:    {
    #####: 1243:        TableDrawDefaultContextMenu(table, table->Flags);
    %%%%%: 1243-block 274
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1244:        EndPopup();
    %%%%%: 1244-block 275
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 1245:    }
        -: 1246:
        -: 1247:    // [Part 12] Sanitize and build sort specs before we have a chance to use them for display.
        -: 1248:    // This path will only be exercised when sort specs are modified before header rows (e.g. init or visibility change)
     1077: 1249:    if (table->IsSortSpecsDirty && (table->Flags & ImGuiTableFlags_Sortable))
     1077: 1249-block 276
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 1249-block 277
branch  2 taken 0 (fallthrough)
branch  3 taken 1077
    #####: 1250:        TableSortSpecsBuild(table);
    %%%%%: 1250-block 278
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 1251:
        -: 1252:    // [Part 13] Setup inner window decoration size (for scrolling / nav tracking to properly take account of frozen rows/columns)
     1077: 1253:    if (table->FreezeColumnsRequest > 0)
     1077: 1253-block 279
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####: 1254:        table->InnerWindow->DecoInnerSizeX1 = table->Columns[table->DisplayOrderToIndex[table->FreezeColumnsRequest - 1]].MaxX - table->OuterRect.Min.x;
    %%%%%: 1254-block 280
call    0 never executed
call    1 never executed
     1077: 1255:    if (table->FreezeRowsRequest > 0)
     1077: 1255-block 283
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####: 1256:        table->InnerWindow->DecoInnerSizeY1 = table_instance->LastFrozenHeight;
    %%%%%: 1256-block 284
     1077: 1257:    table_instance->LastFrozenHeight = 0.0f;
        -: 1258:
        -: 1259:    // Initial state
     1077: 1260:    ImGuiWindow* inner_window = table->InnerWindow;
     1077: 1261:    if (table->Flags & ImGuiTableFlags_NoClip)
     1077: 1261-block 285
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####: 1262:        table->DrawSplitter->SetCurrentChannel(inner_window->DrawList, TABLE_DRAW_CHANNEL_NOCLIP);
    %%%%%: 1262-block 286
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 1263:    else
     1077: 1264:        inner_window->DrawList->PushClipRect(inner_window->InnerClipRect.Min, inner_window->InnerClipRect.Max, false); // FIXME: use table->InnerClipRect?
     1077: 1264-block 287
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077: 1265:}
     1077: 1265-block 288
        -: 1266:
        -: 1267:// Process hit-testing on resizing borders. Actual size change will be applied in EndTable()
        -: 1268:// - Set table->HoveredColumnBorder with a short delay/timer to reduce visual feedback noise.
function _ZN5ImGui18TableUpdateBordersEP10ImGuiTable called 1077 returned 100% blocks executed 62%
     1077: 1269:void ImGui::TableUpdateBorders(ImGuiTable* table)
        -: 1270:{
     1077: 1271:    ImGuiContext& g = *GImGui;
    1077*: 1272:    IM_ASSERT(table->Flags & ImGuiTableFlags_Resizable);
     1077: 1272-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 1272-block 3
call    2 never executed
        -: 1273:
        -: 1274:    // At this point OuterRect height may be zero or under actual final height, so we rely on temporal coherency and
        -: 1275:    // use the final height from last frame. Because this is only affecting _interaction_ with columns, it is not
        -: 1276:    // really problematic (whereas the actual visual will be displayed in EndTable() and using the current frame height).
        -: 1277:    // Actual columns highlight/render will be performed in EndTable() and not be affected.
     1077: 1278:    ImGuiTableInstanceData* table_instance = TableGetInstanceData(table, table->InstanceCurrent);
     1077: 1278-block 4
call    0 returned 1077
     1077: 1279:    const float hit_half_width = ImTrunc(TABLE_RESIZE_SEPARATOR_HALF_THICKNESS * g.CurrentDpiScale);
call    0 returned 1077
    1077*: 1280:    const float hit_y1 = (table->FreezeRowsCount >= 1 ? table->OuterRect.Min.y : table->WorkRect.Min.y) + table->AngledHeadersHeight;
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 1280-block 7
     1077: 1280-block 8
     1077: 1281:    const float hit_y2_body = ImMax(table->OuterRect.Max.y, hit_y1 + table_instance->LastOuterHeight - table->AngledHeadersHeight);
     1077: 1281-block 9
call    0 returned 1077
     1077: 1282:    const float hit_y2_head = hit_y1 + table_instance->LastTopHeadersRowHeight;
        -: 1283:
     5385: 1284:    for (int order_n = 0; order_n < table->ColumnsCount; order_n++)
     4308: 1284-block 53
     5385: 1284-block 54
branch  0 taken 4308
branch  1 taken 1077 (fallthrough)
        -: 1285:    {
    4308*: 1286:        if (!IM_BITARRAY_TESTBIT(table->EnabledMaskByDisplayOrder, order_n))
     4308: 1286-block 11
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
    1079*: 1287:            continue;
    %%%%%: 1287-block 12
     1079: 1287-block 52
        -: 1288:
     4308: 1289:        const int column_n = table->DisplayOrderToIndex[order_n];
     4308: 1289-block 13
call    0 returned 4308
     4308: 1290:        ImGuiTableColumn* column = &table->Columns[column_n];
call    0 returned 4308
     4308: 1291:        if (column->Flags & (ImGuiTableColumnFlags_NoResize | ImGuiTableColumnFlags_NoDirectResize_))
branch  0 taken 1077 (fallthrough)
branch  1 taken 3231
     1077: 1292:            continue;
     1077: 1292-block 16
        -: 1293:
        -: 1294:        // ImGuiTableFlags_NoBordersInBodyUntilResize will be honored in TableDrawBorders()
    3231*: 1295:        const float border_y2_hit = (table->Flags & ImGuiTableFlags_NoBordersInBody) ? hit_y2_head : hit_y2_body;
     3231: 1295-block 17
branch  0 taken 0 (fallthrough)
branch  1 taken 3231
    %%%%%: 1295-block 18
     3231: 1295-block 19
    3231*: 1296:        if ((table->Flags & ImGuiTableFlags_NoBordersInBody) && table->IsUsingHeaders == false)
     3231: 1296-block 20
branch  0 taken 0 (fallthrough)
branch  1 taken 3231
    %%%%%: 1296-block 21
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 1297:            continue;
    %%%%%: 1297-block 22
        -: 1298:
     3231: 1299:        if (!column->IsVisibleX && table->LastResizedColumn != column_n)
     3231: 1299-block 23
branch  0 taken 2 (fallthrough)
branch  1 taken 3229
        2: 1299-block 24
branch  2 taken 2 (fallthrough)
branch  3 taken 0
        2: 1300:            continue;
        2: 1300-block 25
        -: 1301:
     3229: 1302:        ImGuiID column_id = TableGetColumnResizeID(table, column_n, table->InstanceCurrent);
     3229: 1302-block 26
call    0 returned 3229
branch  1 taken 3229 (fallthrough)
branch  2 taken 0 (throw)
     3229: 1303:        ImRect hit_rect(column->MaxX - hit_half_width, hit_y1, column->MaxX + hit_half_width, border_y2_hit);
     3229: 1303-block 27
call    0 returned 3229
     3229: 1304:        ItemAdd(hit_rect, column_id, NULL, ImGuiItemFlags_NoNav);
call    0 returned 3229
branch  1 taken 3229 (fallthrough)
branch  2 taken 0 (throw)
        -: 1305:        //GetForegroundDrawList()->AddRect(hit_rect.Min, hit_rect.Max, IM_COL32(255, 0, 0, 100));
        -: 1306:
     3229: 1307:        bool hovered = false, held = false;
     3229: 1308:        bool pressed = ButtonBehavior(hit_rect, column_id, &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_PressedOnDoubleClick | ImGuiButtonFlags_NoNavFocus);
     3229: 1308-block 29
call    0 returned 3229
branch  1 taken 3229 (fallthrough)
branch  2 taken 0 (throw)
    3229*: 1309:        if (pressed && IsMouseDoubleClicked(0))
     3229: 1309-block 30
branch  0 taken 0 (fallthrough)
branch  1 taken 3229
    %%%%%: 1309-block 31
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 1309-block 32
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 1309-block 33
     3229: 1309-block 34
     3229: 1309-block 35
branch  7 taken 0 (fallthrough)
branch  8 taken 3229
        -: 1310:        {
    #####: 1311:            TableSetColumnWidthAutoSingle(table, column_n);
    %%%%%: 1311-block 36
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1312:            ClearActiveID();
    %%%%%: 1312-block 37
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1313:            held = false;
    %%%%%: 1313-block 38
        -: 1314:        }
     3229: 1315:        if (held)
     3229: 1315-block 39
branch  0 taken 0 (fallthrough)
branch  1 taken 3229
        -: 1316:        {
    #####: 1317:            if (table->LastResizedColumn == -1)
    %%%%%: 1317-block 40
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1318:                table->ResizeLockMinContentsX2 = table->RightMostEnabledColumn != -1 ? table->Columns[table->RightMostEnabledColumn].MaxX : -FLT_MAX;
    %%%%%: 1318-block 41
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1318-block 42
call    2 never executed
    %%%%%: 1318-block 44
    %%%%%: 1318-block 45
    #####: 1319:            table->ResizedColumn = (ImGuiTableColumnIdx)column_n;
    #####: 1320:            table->InstanceInteracted = table->InstanceCurrent;
    %%%%%: 1320-block 46
        -: 1321:        }
    3229*: 1322:        if ((hovered && g.HoveredIdTimer > TABLE_RESIZE_SEPARATOR_FEEDBACK_TIMER) || held)
     3229: 1322-block 47
branch  0 taken 0 (fallthrough)
branch  1 taken 3229
    %%%%%: 1322-block 48
branch  2 never executed (fallthrough)
branch  3 never executed
     3229: 1322-block 49
branch  4 taken 0 (fallthrough)
branch  5 taken 3229
        -: 1323:        {
    #####: 1324:            table->HoveredColumnBorder = (ImGuiTableColumnIdx)column_n;
    #####: 1325:            SetMouseCursor(ImGuiMouseCursor_ResizeEW);
    %%%%%: 1325-block 50
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 1326:        }
        -: 1327:    }
     1077: 1328:}
     1077: 1328-block 55
        -: 1329:
function _ZN5ImGui8EndTableEv called 1077 returned 100% blocks executed 53%
     1077: 1330:void    ImGui::EndTable()
        -: 1331:{
     1077: 1332:    ImGuiContext& g = *GImGui;
     1077: 1333:    ImGuiTable* table = g.CurrentTable;
    1077*: 1334:    IM_ASSERT(table != NULL && "Only call EndTable() if BeginTable() returns true!");
     1077: 1334-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 1334-block 3
call    2 never executed
        -: 1335:
        -: 1336:    // This assert would be very useful to catch a common error... unfortunately it would probably trigger in some
        -: 1337:    // cases, and for consistency user may sometimes output empty tables (and still benefit from e.g. outer border)
        -: 1338:    //IM_ASSERT(table->IsLayoutLocked && "Table unused: never called TableNextRow(), is that the intent?");
        -: 1339:
        -: 1340:    // If the user never got to call TableNextRow() or TableNextColumn(), we call layout ourselves to ensure all our
        -: 1341:    // code paths are consistent (instead of just hoping that TableBegin/TableEnd will work), get borders drawn, etc.
     1077: 1342:    if (!table->IsLayoutLocked)
     1077: 1342-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####: 1343:        TableUpdateLayout(table);
    %%%%%: 1343-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 1344:
     1077: 1345:    const ImGuiTableFlags flags = table->Flags;
     1077: 1346:    ImGuiWindow* inner_window = table->InnerWindow;
     1077: 1347:    ImGuiWindow* outer_window = table->OuterWindow;
     1077: 1348:    ImGuiTableTempData* temp_data = table->TempData;
    1077*: 1349:    IM_ASSERT(inner_window == g.CurrentWindow);
     1077: 1349-block 6
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 1349-block 7
call    2 never executed
    1077*: 1350:    IM_ASSERT(outer_window == inner_window || outer_window == inner_window->ParentWindow);
     1077: 1350-block 8
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 1350-block 9
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1350-block 10
call    4 never executed
        -: 1351:
     1077: 1352:    if (table->IsInsideRow)
     1077: 1352-block 11
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 1353:        TableEndRow(table);
     1077: 1353-block 12
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -: 1354:
        -: 1355:    // Context menu in columns body
     1077: 1356:    if (flags & ImGuiTableFlags_ContextMenuInBody)
     1077: 1356-block 13
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####: 1357:        if (table->HoveredColumnBody != -1 && !IsAnyItemHovered() && IsMouseReleased(ImGuiMouseButton_Right))
    %%%%%: 1357-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1357-block 15
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 1357-block 16
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 1357-block 17
call    7 never executed
branch  8 never executed (fallthrough)
branch  9 never executed (throw)
    %%%%%: 1357-block 18
branch 10 never executed (fallthrough)
branch 11 never executed
    %%%%%: 1357-block 19
    %%%%%: 1357-block 20
    %%%%%: 1357-block 21
branch 12 never executed (fallthrough)
branch 13 never executed
    #####: 1358:            TableOpenContextMenu((int)table->HoveredColumnBody);
    %%%%%: 1358-block 22
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 1359:
        -: 1360:    // Finalize table height
     1077: 1361:    ImGuiTableInstanceData* table_instance = TableGetInstanceData(table, table->InstanceCurrent);
     1077: 1361-block 23
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077: 1362:    inner_window->DC.PrevLineSize = temp_data->HostBackupPrevLineSize;
     1077: 1363:    inner_window->DC.CurrLineSize = temp_data->HostBackupCurrLineSize;
     1077: 1364:    inner_window->DC.CursorMaxPos = temp_data->HostBackupCursorMaxPos;
     1077: 1365:    const float inner_content_max_y = table->RowPosY2;
    1077*: 1366:    IM_ASSERT(table->RowPosY2 == inner_window->DC.CursorPos.y);
     1077: 1366-block 24
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 1366-block 25
call    2 never executed
     1077: 1367:    if (inner_window != outer_window)
     1077: 1367-block 26
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####: 1368:        inner_window->DC.CursorMaxPos.y = inner_content_max_y;
    %%%%%: 1368-block 27
     1077: 1369:    else if (!(flags & ImGuiTableFlags_NoHostExtendY))
     1077: 1369-block 28
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 1370:        table->OuterRect.Max.y = table->InnerRect.Max.y = ImMax(table->OuterRect.Max.y, inner_content_max_y); // Patch OuterRect/InnerRect height
     1077: 1370-block 29
call    0 returned 1077
     1077: 1371:    table->WorkRect.Max.y = ImMax(table->WorkRect.Max.y, table->OuterRect.Max.y);
     1077: 1371-block 31
call    0 returned 1077
     1077: 1372:    table_instance->LastOuterHeight = table->OuterRect.GetHeight();
call    0 returned 1077
        -: 1373:
        -: 1374:    // Setup inner scrolling range
        -: 1375:    // FIXME: This ideally should be done earlier, in BeginTable() SetNextWindowContentSize call, just like writing to inner_window->DC.CursorMaxPos.y,
        -: 1376:    // but since the later is likely to be impossible to do we'd rather update both axises together.
     1077: 1377:    if (table->Flags & ImGuiTableFlags_ScrollX)
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
        -: 1378:    {
    #####: 1379:        const float outer_padding_for_border = (table->Flags & ImGuiTableFlags_BordersOuterV) ? TABLE_BORDER_SIZE : 0.0f;
    %%%%%: 1379-block 34
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1379-block 35
    %%%%%: 1379-block 36
    #####: 1380:        float max_pos_x = table->InnerWindow->DC.CursorMaxPos.x;
    #####: 1381:        if (table->RightMostEnabledColumn != -1)
    %%%%%: 1381-block 37
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1382:            max_pos_x = ImMax(max_pos_x, table->Columns[table->RightMostEnabledColumn].WorkMaxX + table->CellPaddingX + table->OuterPaddingX - outer_padding_for_border);
    %%%%%: 1382-block 38
call    0 never executed
call    1 never executed
    #####: 1383:        if (table->ResizedColumn != -1)
    %%%%%: 1383-block 40
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1384:            max_pos_x = ImMax(max_pos_x, table->ResizeLockMinContentsX2);
    %%%%%: 1384-block 41
call    0 never executed
    #####: 1385:        table->InnerWindow->DC.CursorMaxPos.x = max_pos_x + table->TempData->AngledHeadersExtraWidth;
    %%%%%: 1385-block 42
        -: 1386:    }
        -: 1387:
        -: 1388:    // Pop clipping rect
     1077: 1389:    if (!(flags & ImGuiTableFlags_NoClip))
     1077: 1389-block 43
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 1390:        inner_window->DrawList->PopClipRect();
     1077: 1390-block 44
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077: 1391:    inner_window->ClipRect = inner_window->DrawList->_ClipRectStack.back();
     1077: 1391-block 45
call    0 returned 1077
call    1 returned 1077
        -: 1392:
        -: 1393:    // Draw borders
     1077: 1394:    if ((flags & ImGuiTableFlags_Borders) != 0)
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 1395:        TableDrawBorders(table);
     1077: 1395-block 48
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -: 1396:
        -: 1397:#if 0
        -: 1398:    // Strip out dummy channel draw calls
        -: 1399:    // We have no way to prevent user submitting direct ImDrawList calls into a hidden column (but ImGui:: calls will be clipped out)
        -: 1400:    // Pros: remove draw calls which will have no effect. since they'll have zero-size cliprect they may be early out anyway.
        -: 1401:    // Cons: making it harder for users watching metrics/debugger to spot the wasted vertices.
        -: 1402:    if (table->DummyDrawChannel != (ImGuiTableColumnIdx)-1)
        -: 1403:    {
        -: 1404:        ImDrawChannel* dummy_channel = &table->DrawSplitter._Channels[table->DummyDrawChannel];
        -: 1405:        dummy_channel->_CmdBuffer.resize(0);
        -: 1406:        dummy_channel->_IdxBuffer.resize(0);
        -: 1407:    }
        -: 1408:#endif
        -: 1409:
        -: 1410:    // Flatten channels and merge draw calls
     1077: 1411:    ImDrawListSplitter* splitter = table->DrawSplitter;
     1077: 1412:    splitter->SetCurrentChannel(inner_window->DrawList, 0);
     1077: 1412-block 49
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077: 1413:    if ((table->Flags & ImGuiTableFlags_NoClip) == 0)
     1077: 1413-block 50
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 1414:        TableMergeDrawChannels(table);
     1077: 1414-block 51
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077: 1415:    splitter->Merge(inner_window->DrawList);
     1077: 1415-block 52
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -: 1416:
        -: 1417:    // Update ColumnsAutoFitWidth to get us ahead for host using our size to auto-resize without waiting for next BeginTable()
     1077: 1418:    float auto_fit_width_for_fixed = 0.0f;
     1077: 1419:    float auto_fit_width_for_stretched = 0.0f;
     1077: 1420:    float auto_fit_width_for_stretched_min = 0.0f;
     5385: 1421:    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
     1077: 1421-block 53
     4308: 1421-block 67
     5385: 1421-block 68
branch  0 taken 4308
branch  1 taken 1077 (fallthrough)
     4308: 1422:        if (IM_BITARRAY_TESTBIT(table->EnabledMaskByIndex, column_n))
     4308: 1422-block 54
branch  0 taken 4308 (fallthrough)
branch  1 taken 0
        -: 1423:        {
     4308: 1424:            ImGuiTableColumn* column = &table->Columns[column_n];
     4308: 1424-block 55
call    0 returned 4308
    4308*: 1425:            float column_width_request = ((column->Flags & ImGuiTableColumnFlags_WidthFixed) && !(column->Flags & ImGuiTableColumnFlags_NoResize)) ? column->WidthRequest : TableGetColumnWidthAuto(table, column);
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
    %%%%%: 1425-block 57
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1425-block 58
     4308: 1425-block 59
call    4 returned 4308
branch  5 taken 4308 (fallthrough)
branch  6 taken 0 (throw)
     4308: 1425-block 60
     4308: 1426:            if (column->Flags & ImGuiTableColumnFlags_WidthFixed)
     4308: 1426-block 61
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
    #####: 1427:                auto_fit_width_for_fixed += column_width_request;
    %%%%%: 1427-block 62
        -: 1428:            else
     4308: 1429:                auto_fit_width_for_stretched += column_width_request;
     4308: 1429-block 63
     4308: 1430:            if ((column->Flags & ImGuiTableColumnFlags_WidthStretch) && (column->Flags & ImGuiTableColumnFlags_NoResize) != 0)
     4308: 1430-block 64
branch  0 taken 4308 (fallthrough)
branch  1 taken 0
     4308: 1430-block 65
branch  2 taken 0 (fallthrough)
branch  3 taken 4308
    #####: 1431:                auto_fit_width_for_stretched_min = ImMax(auto_fit_width_for_stretched_min, column_width_request / (column->StretchWeight / table->ColumnsStretchSumWeights));
    %%%%%: 1431-block 66
call    0 never executed
        -: 1432:        }
     1077: 1433:    const float width_spacings = (table->OuterPaddingX * 2.0f) + (table->CellSpacingX1 + table->CellSpacingX2) * (table->ColumnsEnabledCount - 1);
     1077: 1434:    table->ColumnsAutoFitWidth = width_spacings + (table->CellPaddingX * 2.0f) * table->ColumnsEnabledCount + auto_fit_width_for_fixed + ImMax(auto_fit_width_for_stretched, auto_fit_width_for_stretched_min);
     1077: 1434-block 69
call    0 returned 1077
        -: 1435:
        -: 1436:    // Update scroll
     1077: 1437:    if ((table->Flags & ImGuiTableFlags_ScrollX) == 0 && inner_window != outer_window)
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 1437-block 71
branch  2 taken 0 (fallthrough)
branch  3 taken 1077
        -: 1438:    {
    #####: 1439:        inner_window->Scroll.x = 0.0f;
    %%%%%: 1439-block 72
        -: 1440:    }
    1077*: 1441:    else if (table->LastResizedColumn != -1 && table->ResizedColumn == -1 && inner_window->ScrollbarX && table->InstanceInteracted == table->InstanceCurrent)
     1077: 1441-block 73
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 1441-block 74
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1441-block 75
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 1441-block 76
branch  6 never executed (fallthrough)
branch  7 never executed
        -: 1442:    {
        -: 1443:        // When releasing a column being resized, scroll to keep the resulting column in sight
    #####: 1444:        const float neighbor_width_to_keep_visible = table->MinColumnWidth + table->CellPaddingX * 2.0f;
    #####: 1445:        ImGuiTableColumn* column = &table->Columns[table->LastResizedColumn];
    %%%%%: 1445-block 77
call    0 never executed
    #####: 1446:        if (column->MaxX < table->InnerClipRect.Min.x)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1447:            SetScrollFromPosX(inner_window, column->MaxX - inner_window->Pos.x - neighbor_width_to_keep_visible, 1.0f);
    %%%%%: 1447-block 79
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1448:        else if (column->MaxX > table->InnerClipRect.Max.x)
    %%%%%: 1448-block 80
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1449:            SetScrollFromPosX(inner_window, column->MaxX - inner_window->Pos.x + neighbor_width_to_keep_visible, 1.0f);
    %%%%%: 1449-block 81
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 1450:    }
        -: 1451:
        -: 1452:    // Apply resizing/dragging at the end of the frame
    1077*: 1453:    if (table->ResizedColumn != -1 && table->InstanceCurrent == table->InstanceInteracted)
     1077: 1453-block 82
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 1453-block 83
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 1454:    {
    #####: 1455:        ImGuiTableColumn* column = &table->Columns[table->ResizedColumn];
    %%%%%: 1455-block 84
call    0 never executed
    #####: 1456:        const float new_x2 = (g.IO.MousePos.x - g.ActiveIdClickOffset.x + ImTrunc(TABLE_RESIZE_SEPARATOR_HALF_THICKNESS * g.CurrentDpiScale));
call    0 never executed
    #####: 1457:        const float new_width = ImTrunc(new_x2 - column->MinX - table->CellSpacingX1 - table->CellPaddingX * 2.0f);
call    0 never executed
    #####: 1458:        table->ResizedColumnNextWidth = new_width;
        -: 1459:    }
        -: 1460:
    1077*: 1461:    table->IsActiveIdInTable = (g.ActiveIdIsAlive != 0 && table->IsActiveIdAliveBeforeTable == false);
     1077: 1461-block 88
branch  0 taken 157 (fallthrough)
branch  1 taken 920
      157: 1461-block 89
branch  2 taken 0 (fallthrough)
branch  3 taken 157
    %%%%%: 1461-block 90
     1077: 1461-block 91
        -: 1462:
        -: 1463:    // Pop from id stack
    1077*: 1464:    IM_ASSERT_USER_ERROR(inner_window->IDStack.back() == table_instance->TableInstanceID, "Mismatching PushID/PopID!");
     1077: 1464-block 92
call    0 returned 1077
branch  1 taken 0 (fallthrough)
branch  2 taken 1077
    %%%%%: 1464-block 94
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    %%%%%: 1464-block 95
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 1464-block 96
     1077: 1464-block 97
     1077: 1464-block 98
branch  8 taken 0 (fallthrough)
branch  9 taken 1077
    %%%%%: 1464-block 99
call   10 never executed
branch 11 never executed (fallthrough)
branch 12 never executed
    %%%%%: 1464-block 101
    %%%%%: 1464-block 102
call   13 never executed
    1077*: 1465:    IM_ASSERT_USER_ERROR(outer_window->DC.ItemWidthStack.Size >= temp_data->HostBackupItemWidthStackSize, "Too many PopItemWidth!");
     1077: 1465-block 104
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 1465-block 105
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 1465-block 106
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 1465-block 107
     1077: 1465-block 108
     1077: 1465-block 109
branch  7 taken 0 (fallthrough)
branch  8 taken 1077
    %%%%%: 1465-block 110
branch  9 never executed (fallthrough)
branch 10 never executed
    %%%%%: 1465-block 111
call   11 never executed
     1077: 1466:    if (table->InstanceCurrent > 0)
     1077: 1466-block 112
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####: 1467:        PopID();
    %%%%%: 1467-block 113
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
     1077: 1468:    PopID();
     1077: 1468-block 114
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -: 1469:
        -: 1470:    // Restore window data that we modified
     1077: 1471:    const ImVec2 backup_outer_max_pos = outer_window->DC.CursorMaxPos;
     1077: 1472:    inner_window->WorkRect = temp_data->HostBackupWorkRect;
     1077: 1473:    inner_window->ParentWorkRect = temp_data->HostBackupParentWorkRect;
     1077: 1474:    inner_window->SkipItems = table->HostSkipItems;
     1077: 1475:    outer_window->DC.CursorPos = table->OuterRect.Min;
     1077: 1476:    outer_window->DC.ItemWidth = temp_data->HostBackupItemWidth;
     1077: 1477:    outer_window->DC.ItemWidthStack.Size = temp_data->HostBackupItemWidthStackSize;
     1077: 1478:    outer_window->DC.ColumnsOffset = temp_data->HostBackupColumnsOffset;
        -: 1479:
        -: 1480:    // Layout in outer window
        -: 1481:    // (FIXME: To allow auto-fit and allow desirable effect of SameLine() we dissociate 'used' vs 'ideal' size by overriding
        -: 1482:    // CursorPosPrevLine and CursorMaxPos manually. That should be a more general layout feature, see same problem e.g. #3414)
     1077: 1483:    if (inner_window != outer_window)
     1077: 1483-block 115
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
        -: 1484:    {
    #####: 1485:        short backup_nav_layers_active_mask = inner_window->DC.NavLayersActiveMask;
    #####: 1486:        inner_window->DC.NavLayersActiveMask |= 1 << ImGuiNavLayer_Main; // So empty table don't appear to navigate differently.
    #####: 1487:        g.CurrentTable = NULL; // To avoid error recovery recursing
    #####: 1488:        EndChild();
    %%%%%: 1488-block 116
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1489:        g.CurrentTable = table;
    #####: 1490:        inner_window->DC.NavLayersActiveMask = backup_nav_layers_active_mask;
    %%%%%: 1490-block 117
        -: 1491:    }
        -: 1492:    else
        -: 1493:    {
     1077: 1494:        ItemSize(table->OuterRect.GetSize());
     1077: 1494-block 118
call    0 returned 1077
call    1 returned 1077
branch  2 taken 1077 (fallthrough)
branch  3 taken 0 (throw)
    $$$$$: 1494-block 168
     1077: 1495:        ItemAdd(table->OuterRect, 0);
     1077: 1495-block 120
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -: 1496:    }
        -: 1497:
        -: 1498:    // Override declared contents width/height to enable auto-resize while not needlessly adding a scrollbar
     1077: 1499:    if (table->Flags & ImGuiTableFlags_NoHostExtendX)
     1077: 1499-block 121
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
        -: 1500:    {
        -: 1501:        // FIXME-TABLE: Could we remove this section?
        -: 1502:        // ColumnsAutoFitWidth may be one frame ahead here since for Fixed+NoResize is calculated from latest contents
    #####: 1503:        IM_ASSERT((table->Flags & ImGuiTableFlags_ScrollX) == 0);
    %%%%%: 1503-block 122
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1503-block 123
call    2 never executed
    #####: 1504:        outer_window->DC.CursorMaxPos.x = ImMax(backup_outer_max_pos.x, table->OuterRect.Min.x + table->ColumnsAutoFitWidth);
    %%%%%: 1504-block 124
call    0 never executed
        -: 1505:    }
     1077: 1506:    else if (temp_data->UserOuterSize.x <= 0.0f)
     1077: 1506-block 126
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
        -: 1507:    {
        -: 1508:        // Some references for this: #7651 + tests "table_reported_size", "table_reported_size_outer" equivalent Y block
        -: 1509:        // - Checking for ImGuiTableFlags_ScrollX/ScrollY flag makes us a frame ahead when disabling those flags.
        -: 1510:        // - FIXME-TABLE: Would make sense to pre-compute expected scrollbar visibility/sizes to generally save a frame of feedback.
     1077: 1511:        const float inner_content_max_x = table->OuterRect.Min.x + table->ColumnsAutoFitWidth; // Slightly misleading name but used for code symmetry with inner_content_max_y
    1077*: 1512:        const float decoration_size = table->TempData->AngledHeadersExtraWidth + ((table->Flags & ImGuiTableFlags_ScrollY) ? inner_window->ScrollbarSizes.x : 0.0f);
     1077: 1512-block 127
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 1512-block 128
     1077: 1512-block 129
     1077: 1513:        outer_window->DC.IdealMaxPos.x = ImMax(outer_window->DC.IdealMaxPos.x, inner_content_max_x + decoration_size - temp_data->UserOuterSize.x);
     1077: 1513-block 130
call    0 returned 1077
     1077: 1514:        outer_window->DC.CursorMaxPos.x = ImMax(backup_outer_max_pos.x, ImMin(table->OuterRect.Max.x, inner_content_max_x + decoration_size));
call    0 returned 1077
call    1 returned 1077
        -: 1515:    }
        -: 1516:    else
        -: 1517:    {
    #####: 1518:        outer_window->DC.CursorMaxPos.x = ImMax(backup_outer_max_pos.x, table->OuterRect.Max.x);
    %%%%%: 1518-block 134
call    0 never executed
        -: 1519:    }
     1077: 1520:    if (temp_data->UserOuterSize.y <= 0.0f)
     1077: 1520-block 136
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
        -: 1521:    {
    1077*: 1522:        const float decoration_size = (table->Flags & ImGuiTableFlags_ScrollX) ? inner_window->ScrollbarSizes.y : 0.0f;
     1077: 1522-block 137
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 1522-block 138
     1077: 1522-block 139
     1077: 1523:        outer_window->DC.IdealMaxPos.y = ImMax(outer_window->DC.IdealMaxPos.y, inner_content_max_y + decoration_size - temp_data->UserOuterSize.y);
     1077: 1523-block 140
call    0 returned 1077
     1077: 1524:        outer_window->DC.CursorMaxPos.y = ImMax(backup_outer_max_pos.y, ImMin(table->OuterRect.Max.y, inner_content_max_y + decoration_size));
call    0 returned 1077
call    1 returned 1077
        -: 1525:    }
        -: 1526:    else
        -: 1527:    {
        -: 1528:        // OuterRect.Max.y may already have been pushed downward from the initial value (unless ImGuiTableFlags_NoHostExtendY is set)
    #####: 1529:        outer_window->DC.CursorMaxPos.y = ImMax(backup_outer_max_pos.y, table->OuterRect.Max.y);
    %%%%%: 1529-block 144
call    0 never executed
        -: 1530:    }
        -: 1531:
        -: 1532:    // Save settings
     1077: 1533:    if (table->IsSettingsDirty)
     1077: 1533-block 146
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####: 1534:        TableSaveSettings(table);
    %%%%%: 1534-block 147
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
     1077: 1535:    table->IsInitializing = false;
        -: 1536:
        -: 1537:    // Clear or restore current table, if any
    1077*: 1538:    IM_ASSERT(g.CurrentWindow == outer_window && g.CurrentTable == table);
     1077: 1538-block 148
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 1538-block 149
branch  2 taken 1077 (fallthrough)
branch  3 taken 0
     1077: 1538-block 150
    %%%%%: 1538-block 151
call    4 never executed
    1077*: 1539:    IM_ASSERT(g.TablesTempDataStacked > 0);
     1077: 1539-block 152
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 1539-block 153
call    2 never executed
    1077*: 1540:    temp_data = (--g.TablesTempDataStacked > 0) ? &g.TablesTempData[g.TablesTempDataStacked - 1] : NULL;
     1077: 1540-block 154
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 1540-block 155
call    2 never executed
     1077: 1540-block 156
    1077*: 1541:    g.CurrentTable = temp_data ? g.Tables.GetByIndex(temp_data->TableIndex) : NULL;
     1077: 1541-block 157
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 1541-block 158
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 1541-block 159
     1077: 1541-block 160
     1077: 1542:    if (g.CurrentTable)
     1077: 1542-block 161
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
        -: 1543:    {
    #####: 1544:        g.CurrentTable->TempData = temp_data;
    #####: 1545:        g.CurrentTable->DrawSplitter = &temp_data->DrawSplitter;
    %%%%%: 1545-block 162
        -: 1546:    }
    1077*: 1547:    outer_window->DC.CurrentTableIdx = g.CurrentTable ? g.Tables.GetIndex(g.CurrentTable) : -1;
     1077: 1547-block 163
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 1547-block 164
call    2 never executed
     1077: 1547-block 165
     1077: 1548:    NavUpdateCurrentWindowIsScrollPushableX();
     1077: 1548-block 166
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077: 1549:}
     1077: 1549-block 167
        -: 1550:
        -: 1551:// See "COLUMNS SIZING POLICIES" comments at the top of this file
        -: 1552:// If (init_width_or_weight <= 0.0f) it is ignored
function _ZN5ImGui16TableSetupColumnEPKcifj called 4308 returned 100% blocks executed 35%
     4308: 1553:void ImGui::TableSetupColumn(const char* label, ImGuiTableColumnFlags flags, float init_width_or_weight, ImGuiID user_id)
        -: 1554:{
     4308: 1555:    ImGuiContext& g = *GImGui;
     4308: 1556:    ImGuiTable* table = g.CurrentTable;
    4308*: 1557:    IM_ASSERT(table != NULL && "Need to call TableSetupColumn() after BeginTable()!");
     4308: 1557-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
    %%%%%: 1557-block 3
call    2 never executed
    4308*: 1558:    IM_ASSERT(table->IsLayoutLocked == false && "Need to call call TableSetupColumn() before first row!");
     4308: 1558-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
    %%%%%: 1558-block 5
call    2 never executed
    4308*: 1559:    IM_ASSERT((flags & ImGuiTableColumnFlags_StatusMask_) == 0 && "Illegal to pass StatusMask values to TableSetupColumn()");
     4308: 1559-block 6
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
    %%%%%: 1559-block 7
call    2 never executed
     4308: 1560:    if (table->DeclColumnsCount >= table->ColumnsCount)
     4308: 1560-block 8
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
        -: 1561:    {
    #####: 1562:        IM_ASSERT_USER_ERROR(table->DeclColumnsCount < table->ColumnsCount, "Called TableSetupColumn() too many times!");
    %%%%%: 1562-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1562-block 10
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 1562-block 12
    %%%%%: 1562-block 13
    %%%%%: 1562-block 14
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 1562-block 15
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 1562-block 16
call    9 never executed
    #####: 1563:        return;
    %%%%%: 1563-block 17
        -: 1564:    }
        -: 1565:
     4308: 1566:    ImGuiTableColumn* column = &table->Columns[table->DeclColumnsCount];
     4308: 1566-block 18
call    0 returned 4308
     4308: 1567:    table->DeclColumnsCount++;
        -: 1568:
        -: 1569:    // Assert when passing a width or weight if policy is entirely left to default, to avoid storing width into weight and vice-versa.
        -: 1570:    // Give a grace to users of ImGuiTableFlags_ScrollX.
    4308*: 1571:    if (table->IsDefaultSizingPolicy && (flags & ImGuiTableColumnFlags_WidthMask_) == 0 && (flags & ImGuiTableFlags_ScrollX) == 0)
branch  0 taken 4308 (fallthrough)
branch  1 taken 0
     4308: 1571-block 20
branch  2 taken 0 (fallthrough)
branch  3 taken 4308
    %%%%%: 1571-block 21
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 1572:        IM_ASSERT(init_width_or_weight <= 0.0f && "Can only specify width/weight if sizing policy is set explicitly in either Table or Column.");
    %%%%%: 1572-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1572-block 23
call    2 never executed
        -: 1573:
        -: 1574:    // When passing a width automatically enforce WidthFixed policy
        -: 1575:    // (whereas TableSetupColumnFlags would default to WidthAuto if table is not Resizable)
    4308*: 1576:    if ((flags & ImGuiTableColumnFlags_WidthMask_) == 0 && init_width_or_weight > 0.0f)
     4308: 1576-block 24
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
    %%%%%: 1576-block 25
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 1577:        if ((table->Flags & ImGuiTableFlags_SizingMask_) == ImGuiTableFlags_SizingFixedFit || (table->Flags & ImGuiTableFlags_SizingMask_) == ImGuiTableFlags_SizingFixedSame)
    %%%%%: 1577-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1577-block 27
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 1578:            flags |= ImGuiTableColumnFlags_WidthFixed;
    %%%%%: 1578-block 28
     4308: 1579:    if (flags & ImGuiTableColumnFlags_AngledHeader)
     4308: 1579-block 29
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
        -: 1580:    {
    #####: 1581:        flags |= ImGuiTableColumnFlags_NoHeaderLabel;
    #####: 1582:        table->AngledHeadersCount++;
    %%%%%: 1582-block 30
        -: 1583:    }
        -: 1584:
     4308: 1585:    TableSetupColumnFlags(table, column, flags);
     4308: 1585-block 31
call    0 returned 4308
     4308: 1586:    column->UserID = user_id;
     4308: 1587:    flags = column->Flags;
        -: 1588:
        -: 1589:    // Initialize defaults
     4308: 1590:    column->InitStretchWeightOrWidth = init_width_or_weight;
     4308: 1591:    if (table->IsInitializing)
branch  0 taken 4 (fallthrough)
branch  1 taken 4304
        -: 1592:    {
        -: 1593:        // Init width or weight
        4: 1594:        if (column->WidthRequest < 0.0f && column->StretchWeight < 0.0f)
        4: 1594-block 33
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4: 1594-block 34
branch  2 taken 0 (fallthrough)
branch  3 taken 4
        -: 1595:        {
    #####: 1596:            if ((flags & ImGuiTableColumnFlags_WidthFixed) && init_width_or_weight > 0.0f)
    %%%%%: 1596-block 35
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1596-block 36
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 1597:                column->WidthRequest = init_width_or_weight;
    %%%%%: 1597-block 37
    #####: 1598:            if (flags & ImGuiTableColumnFlags_WidthStretch)
    %%%%%: 1598-block 38
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1599:                column->StretchWeight = (init_width_or_weight > 0.0f) ? init_width_or_weight : -1.0f;
    %%%%%: 1599-block 39
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1599-block 40
    %%%%%: 1599-block 41
    %%%%%: 1599-block 42
        -: 1600:
        -: 1601:            // Disable auto-fit if an explicit width/weight has been specified
    #####: 1602:            if (init_width_or_weight > 0.0f)
    %%%%%: 1602-block 43
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1603:                column->AutoFitQueue = 0x00;
    %%%%%: 1603-block 44
        -: 1604:        }
        -: 1605:
        -: 1606:        // Init default visibility/sort state
       4*: 1607:        if ((flags & ImGuiTableColumnFlags_DefaultHide) && (table->SettingsLoadedFlags & ImGuiTableFlags_Hideable) == 0)
        4: 1607-block 45
branch  0 taken 0 (fallthrough)
branch  1 taken 4
    %%%%%: 1607-block 46
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 1608:            column->IsUserEnabled = column->IsUserEnabledNextFrame = false;
    %%%%%: 1608-block 47
       4*: 1609:        if (flags & ImGuiTableColumnFlags_DefaultSort && (table->SettingsLoadedFlags & ImGuiTableFlags_Sortable) == 0)
        4: 1609-block 48
branch  0 taken 0 (fallthrough)
branch  1 taken 4
    %%%%%: 1609-block 49
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 1610:        {
    #####: 1611:            column->SortOrder = 0; // Multiple columns using _DefaultSort will be reassigned unique SortOrder values when building the sort specs.
    #####: 1612:            column->SortDirection = (column->Flags & ImGuiTableColumnFlags_PreferSortDescending) ? (ImS8)ImGuiSortDirection_Descending : (ImU8)(ImGuiSortDirection_Ascending);
    %%%%%: 1612-block 50
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1612-block 51
    %%%%%: 1612-block 52
    %%%%%: 1612-block 53
        -: 1613:        }
        -: 1614:    }
        -: 1615:
        -: 1616:    // Store name (append with zero-terminator in contiguous buffer)
        -: 1617:    // FIXME: If we recorded the number of \n in names we could compute header row height
     4308: 1618:    column->NameOffset = -1;
     4308: 1619:    if (label != NULL && label[0] != 0)
     4308: 1619-block 54
branch  0 taken 4308 (fallthrough)
branch  1 taken 0
     4308: 1619-block 55
branch  2 taken 4308 (fallthrough)
branch  3 taken 0
        -: 1620:    {
     4308: 1621:        column->NameOffset = (ImS16)table->ColumnsNames.size();
     4308: 1621-block 56
call    0 returned 4308
     4308: 1622:        table->ColumnsNames.append(label, label + strlen(label) + 1);
call    0 returned 4308
        -: 1623:    }
        -: 1624:}
        -: 1625:
        -: 1626:// [Public]
function _ZN5ImGui22TableSetupScrollFreezeEii called 0 returned 0% blocks executed 0%
    #####: 1627:void ImGui::TableSetupScrollFreeze(int columns, int rows)
        -: 1628:{
    #####: 1629:    ImGuiContext& g = *GImGui;
    #####: 1630:    ImGuiTable* table = g.CurrentTable;
    #####: 1631:    IM_ASSERT(table != NULL && "Need to call TableSetupColumn() after BeginTable()!");
    %%%%%: 1631-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1631-block 3
call    2 never executed
    #####: 1632:    IM_ASSERT(table->IsLayoutLocked == false && "Need to call TableSetupColumn() before first row!");
    %%%%%: 1632-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1632-block 5
call    2 never executed
    #####: 1633:    IM_ASSERT(columns >= 0 && columns < IMGUI_TABLE_MAX_COLUMNS);
    %%%%%: 1633-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1633-block 7
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1633-block 8
    %%%%%: 1633-block 9
call    4 never executed
    #####: 1634:    IM_ASSERT(rows >= 0 && rows < 128); // Arbitrary limit
    %%%%%: 1634-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1634-block 11
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1634-block 12
    %%%%%: 1634-block 13
call    4 never executed
        -: 1635:
    #####: 1636:    table->FreezeColumnsRequest = (table->Flags & ImGuiTableFlags_ScrollX) ? (ImGuiTableColumnIdx)ImMin(columns, table->ColumnsCount) : 0;
    %%%%%: 1636-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1636-block 15
call    2 never executed
    %%%%%: 1636-block 17
    #####: 1637:    table->FreezeColumnsCount = (table->InnerWindow->Scroll.x != 0.0f) ? table->FreezeColumnsRequest : 0;
    %%%%%: 1637-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1637-block 19
    %%%%%: 1637-block 20
    #####: 1638:    table->FreezeRowsRequest = (table->Flags & ImGuiTableFlags_ScrollY) ? (ImGuiTableColumnIdx)rows : 0;
    %%%%%: 1638-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1638-block 22
    %%%%%: 1638-block 23
    #####: 1639:    table->FreezeRowsCount = (table->InnerWindow->Scroll.y != 0.0f) ? table->FreezeRowsRequest : 0;
    %%%%%: 1639-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1639-block 25
    %%%%%: 1639-block 26
    #####: 1640:    table->IsUnfrozenRows = (table->FreezeRowsCount == 0); // Make sure this is set before TableUpdateLayout() so ImGuiListClipper can benefit from it.b
        -: 1641:
        -: 1642:    // Ensure frozen columns are ordered in their section. We still allow multiple frozen columns to be reordered.
        -: 1643:    // FIXME-TABLE: This work for preserving 2143 into 21|43. How about 4321 turning into 21|43? (preserve relative order in each section)
    #####: 1644:    for (int column_n = 0; column_n < table->FreezeColumnsRequest; column_n++)
    %%%%%: 1644-block 27
    %%%%%: 1644-block 39
    %%%%%: 1644-block 40
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 1645:    {
    #####: 1646:        int order_n = table->DisplayOrderToIndex[column_n];
    %%%%%: 1646-block 28
call    0 never executed
    #####: 1647:        if (order_n != column_n && order_n >= table->FreezeColumnsRequest)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1647-block 30
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 1648:        {
    #####: 1649:            ImSwap(table->Columns[table->DisplayOrderToIndex[order_n]].DisplayOrder, table->Columns[table->DisplayOrderToIndex[column_n]].DisplayOrder);
    %%%%%: 1649-block 31
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 1650:            ImSwap(table->DisplayOrderToIndex[order_n], table->DisplayOrderToIndex[column_n]);
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1651:        }
        -: 1652:    }
    #####: 1653:}
        -: 1654:
        -: 1655://-----------------------------------------------------------------------------
        -: 1656:// [SECTION] Tables: Simple accessors
        -: 1657://-----------------------------------------------------------------------------
        -: 1658:// - TableGetColumnCount()
        -: 1659:// - TableGetColumnName()
        -: 1660:// - TableGetColumnName() [Internal]
        -: 1661:// - TableSetColumnEnabled()
        -: 1662:// - TableGetColumnFlags()
        -: 1663:// - TableGetCellBgRect() [Internal]
        -: 1664:// - TableGetColumnResizeID() [Internal]
        -: 1665:// - TableGetHoveredColumn() [Internal]
        -: 1666:// - TableGetHoveredRow() [Internal]
        -: 1667:// - TableSetBgColor()
        -: 1668://-----------------------------------------------------------------------------
        -: 1669:
function _ZN5ImGui19TableGetColumnCountEv called 1077 returned 100% blocks executed 80%
     1077: 1670:int ImGui::TableGetColumnCount()
        -: 1671:{
     1077: 1672:    ImGuiContext& g = *GImGui;
     1077: 1673:    ImGuiTable* table = g.CurrentTable;
    1077*: 1674:    return table ? table->ColumnsCount : 0;
     1077: 1674-block 2
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 1674-block 3
    %%%%%: 1674-block 4
     1077: 1674-block 5
        -: 1675:}
        -: 1676:
function _ZN5ImGui18TableGetColumnNameEi called 4305 returned 100% blocks executed 71%
     4305: 1677:const char* ImGui::TableGetColumnName(int column_n)
        -: 1678:{
     4305: 1679:    ImGuiContext& g = *GImGui;
     4305: 1680:    ImGuiTable* table = g.CurrentTable;
     4305: 1681:    if (!table)
     4305: 1681-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 4305
    #####: 1682:        return NULL;
    %%%%%: 1682-block 3
     4305: 1683:    if (column_n < 0)
     4305: 1683-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 4305
    #####: 1684:        column_n = table->CurrentColumn;
    %%%%%: 1684-block 5
     4305: 1685:    return TableGetColumnName(table, column_n);
     4305: 1685-block 6
call    0 returned 4305
        -: 1686:}
        -: 1687:
function _ZN5ImGui18TableGetColumnNameEPK10ImGuiTablei called 8613 returned 100% blocks executed 62%
     8613: 1688:const char* ImGui::TableGetColumnName(const ImGuiTable* table, int column_n)
        -: 1689:{
    8613*: 1690:    if (table->IsLayoutLocked == false && column_n >= table->DeclColumnsCount)
     8613: 1690-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 8613
    %%%%%: 1690-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 1691:        return ""; // NameOffset is invalid at this point
    %%%%%: 1691-block 4
     8613: 1692:    const ImGuiTableColumn* column = &table->Columns[column_n];
     8613: 1692-block 5
call    0 returned 8613
     8613: 1693:    if (column->NameOffset == -1)
branch  0 taken 0 (fallthrough)
branch  1 taken 8613
    #####: 1694:        return "";
    %%%%%: 1694-block 7
     8613: 1695:    return &table->ColumnsNames.Buf[column->NameOffset];
     8613: 1695-block 8
call    0 returned 8613
        -: 1696:}
        -: 1697:
        -: 1698:// Change user accessible enabled/disabled state of a column (often perceived as "showing/hiding" from users point of view)
        -: 1699:// Note that end-user can use the context menu to change this themselves (right-click in headers, or right-click in columns body with ImGuiTableFlags_ContextMenuInBody)
        -: 1700:// - Require table to have the ImGuiTableFlags_Hideable flag because we are manipulating user accessible state.
        -: 1701:// - Request will be applied during next layout, which happens on the first call to TableNextRow() after BeginTable().
        -: 1702:// - For the getter you can test (TableGetColumnFlags() & ImGuiTableColumnFlags_IsEnabled) != 0.
        -: 1703:// - Alternative: the ImGuiTableColumnFlags_Disabled is an overriding/master disable flag which will also hide the column from context menu.
function _ZN5ImGui21TableSetColumnEnabledEib called 0 returned 0% blocks executed 0%
    #####: 1704:void ImGui::TableSetColumnEnabled(int column_n, bool enabled)
        -: 1705:{
    #####: 1706:    ImGuiContext& g = *GImGui;
    #####: 1707:    ImGuiTable* table = g.CurrentTable;
    #####: 1708:    IM_ASSERT(table != NULL);
    %%%%%: 1708-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1708-block 3
call    2 never executed
    #####: 1709:    if (!table)
    %%%%%: 1709-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1710:        return;
    %%%%%: 1710-block 5
    #####: 1711:    IM_ASSERT(table->Flags & ImGuiTableFlags_Hideable); // See comments above
    %%%%%: 1711-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1711-block 7
call    2 never executed
    #####: 1712:    if (column_n < 0)
    %%%%%: 1712-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1713:        column_n = table->CurrentColumn;
    %%%%%: 1713-block 9
    #####: 1714:    IM_ASSERT(column_n >= 0 && column_n < table->ColumnsCount);
    %%%%%: 1714-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1714-block 11
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1714-block 12
    %%%%%: 1714-block 13
call    4 never executed
    #####: 1715:    ImGuiTableColumn* column = &table->Columns[column_n];
    %%%%%: 1715-block 14
call    0 never executed
    #####: 1716:    column->IsUserEnabledNextFrame = enabled;
        -: 1717:}
        -: 1718:
        -: 1719:// We allow querying for an extra column in order to poll the IsHovered state of the right-most section
function _ZN5ImGui19TableGetColumnFlagsEi called 4305 returned 100% blocks executed 50%
     4305: 1720:ImGuiTableColumnFlags ImGui::TableGetColumnFlags(int column_n)
        -: 1721:{
     4305: 1722:    ImGuiContext& g = *GImGui;
     4305: 1723:    ImGuiTable* table = g.CurrentTable;
     4305: 1724:    if (!table)
     4305: 1724-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 4305
    #####: 1725:        return ImGuiTableColumnFlags_None;
    %%%%%: 1725-block 3
     4305: 1726:    if (column_n < 0)
     4305: 1726-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 4305
    #####: 1727:        column_n = table->CurrentColumn;
    %%%%%: 1727-block 5
     4305: 1728:    if (column_n == table->ColumnsCount)
     4305: 1728-block 6
branch  0 taken 0 (fallthrough)
branch  1 taken 4305
    #####: 1729:        return (table->HoveredColumnBody == column_n) ? ImGuiTableColumnFlags_IsHovered : ImGuiTableColumnFlags_None;
    %%%%%: 1729-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1729-block 8
    %%%%%: 1729-block 9
    %%%%%: 1729-block 10
     4305: 1730:    return table->Columns[column_n].Flags;
     4305: 1730-block 11
call    0 returned 4305
        -: 1731:}
        -: 1732:
        -: 1733:// Return the cell rectangle based on currently known height.
        -: 1734:// - Important: we generally don't know our row height until the end of the row, so Max.y will be incorrect in many situations.
        -: 1735://   The only case where this is correct is if we provided a min_row_height to TableNextRow() and don't go below it, or in TableEndRow() when we locked that height.
        -: 1736:// - Important: if ImGuiTableFlags_PadOuterX is set but ImGuiTableFlags_PadInnerX is not set, the outer-most left and right
        -: 1737://   columns report a small offset so their CellBgRect can extend up to the outer border.
        -: 1738://   FIXME: But the rendering code in TableEndRow() nullifies that with clamping required for scrolling.
function _ZN5ImGui18TableGetCellBgRectEPK10ImGuiTablei called 4305 returned 100% blocks executed 100%
     4305: 1739:ImRect ImGui::TableGetCellBgRect(const ImGuiTable* table, int column_n)
        -: 1740:{
     4305: 1741:    const ImGuiTableColumn* column = &table->Columns[column_n];
     4305: 1741-block 2
call    0 returned 4305
     4305: 1742:    float x1 = column->MinX;
     4305: 1743:    float x2 = column->MaxX;
        -: 1744:    //if (column->PrevEnabledColumn == -1)
        -: 1745:    //    x1 -= table->OuterPaddingX;
        -: 1746:    //if (column->NextEnabledColumn == -1)
        -: 1747:    //    x2 += table->OuterPaddingX;
     4305: 1748:    x1 = ImMax(x1, table->WorkRect.Min.x);
call    0 returned 4305
     4305: 1749:    x2 = ImMin(x2, table->WorkRect.Max.x);
call    0 returned 4305
     4305: 1750:    return ImRect(x1, table->RowPosY1, x2, table->RowPosY2);
call    0 returned 4305
     4305: 1750-block 7
        -: 1751:}
        -: 1752:
        -: 1753:// Return the resizing ID for the right-side of the given column.
function _ZN5ImGui22TableGetColumnResizeIDEP10ImGuiTableii called 3229 returned 100% blocks executed 86%
     3229: 1754:ImGuiID ImGui::TableGetColumnResizeID(ImGuiTable* table, int column_n, int instance_no)
        -: 1755:{
    3229*: 1756:    IM_ASSERT(column_n >= 0 && column_n < table->ColumnsCount);
     3229: 1756-block 2
branch  0 taken 3229 (fallthrough)
branch  1 taken 0
     3229: 1756-block 3
branch  2 taken 3229 (fallthrough)
branch  3 taken 0
     3229: 1756-block 4
    %%%%%: 1756-block 5
call    4 never executed
     3229: 1757:    ImGuiID instance_id = TableGetInstanceID(table, instance_no);
     3229: 1757-block 6
call    0 returned 3229
     3229: 1758:    return instance_id + 1 + column_n; // FIXME: #6140: still not ideal
        -: 1759:}
        -: 1760:
        -: 1761:// Return -1 when table is not hovered. return columns_count if hovering the unused space at the right of the right-most visible column.
function _ZN5ImGui21TableGetHoveredColumnEv called 0 returned 0% blocks executed 0%
    #####: 1762:int ImGui::TableGetHoveredColumn()
        -: 1763:{
    #####: 1764:    ImGuiContext& g = *GImGui;
    #####: 1765:    ImGuiTable* table = g.CurrentTable;
    #####: 1766:    if (!table)
    %%%%%: 1766-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1767:        return -1;
    %%%%%: 1767-block 3
    #####: 1768:    return (int)table->HoveredColumnBody;
    %%%%%: 1768-block 4
        -: 1769:}
        -: 1770:
        -: 1771:// Return -1 when table is not hovered. Return maxrow+1 if in table but below last submitted row.
        -: 1772:// *IMPORTANT* Unlike TableGetHoveredColumn(), this has a one frame latency in updating the value.
        -: 1773:// This difference with is the reason why this is not public yet.
function _ZN5ImGui18TableGetHoveredRowEv called 0 returned 0% blocks executed 0%
    #####: 1774:int ImGui::TableGetHoveredRow()
        -: 1775:{
    #####: 1776:    ImGuiContext& g = *GImGui;
    #####: 1777:    ImGuiTable* table = g.CurrentTable;
    #####: 1778:    if (!table)
    %%%%%: 1778-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1779:        return -1;
    %%%%%: 1779-block 3
    #####: 1780:    ImGuiTableInstanceData* table_instance = TableGetInstanceData(table, table->InstanceCurrent);
    %%%%%: 1780-block 4
call    0 never executed
    #####: 1781:    return (int)table_instance->HoveredRowLast;
        -: 1782:}
        -: 1783:
function _ZN5ImGui15TableSetBgColorEiji called 1077 returned 100% blocks executed 30%
     1077: 1784:void ImGui::TableSetBgColor(ImGuiTableBgTarget target, ImU32 color, int column_n)
        -: 1785:{
     1077: 1786:    ImGuiContext& g = *GImGui;
     1077: 1787:    ImGuiTable* table = g.CurrentTable;
    1077*: 1788:    IM_ASSERT(target != ImGuiTableBgTarget_None);
     1077: 1788-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 1788-block 3
call    2 never executed
        -: 1789:
     1077: 1790:    if (color == IM_COL32_DISABLE)
     1077: 1790-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####: 1791:        color = 0;
    %%%%%: 1791-block 5
        -: 1792:
        -: 1793:    // We cannot draw neither the cell or row background immediately as we don't know the row height at this point in time.
     1077: 1794:    switch (target)
     1077: 1794-block 6
branch  0 taken 0
branch  1 taken 1077
branch  2 taken 0
        -: 1795:    {
    #####: 1796:    case ImGuiTableBgTarget_CellBg:
        -: 1797:    {
    #####: 1798:        if (table->RowPosY1 > table->InnerClipRect.Max.y) // Discard
    %%%%%: 1798-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1799:            return;
    %%%%%: 1799-block 8
    #####: 1800:        if (column_n == -1)
    %%%%%: 1800-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1801:            column_n = table->CurrentColumn;
    %%%%%: 1801-block 10
    #####: 1802:        if (!IM_BITARRAY_TESTBIT(table->VisibleMaskByIndex, column_n))
    %%%%%: 1802-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1803:            return;
    %%%%%: 1803-block 12
    #####: 1804:        if (table->RowCellDataCurrent < 0 || table->RowCellData[table->RowCellDataCurrent].Column != column_n)
    %%%%%: 1804-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1804-block 14
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 1804-block 16
    %%%%%: 1804-block 17
    %%%%%: 1804-block 18
branch  5 never executed (fallthrough)
branch  6 never executed
    #####: 1805:            table->RowCellDataCurrent++;
    %%%%%: 1805-block 19
    #####: 1806:        ImGuiTableCellData* cell_data = &table->RowCellData[table->RowCellDataCurrent];
    %%%%%: 1806-block 20
call    0 never executed
    #####: 1807:        cell_data->BgColor = color;
    #####: 1808:        cell_data->Column = (ImGuiTableColumnIdx)column_n;
    #####: 1809:        break;
        -: 1810:    }
     1077: 1811:    case ImGuiTableBgTarget_RowBg0:
        -: 1812:    case ImGuiTableBgTarget_RowBg1:
        -: 1813:    {
     1077: 1814:        if (table->RowPosY1 > table->InnerClipRect.Max.y) // Discard
     1077: 1814-block 22
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####: 1815:            return;
    %%%%%: 1815-block 23
    1077*: 1816:        IM_ASSERT(column_n == -1);
     1077: 1816-block 24
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 1816-block 25
call    2 never executed
    1077*: 1817:        int bg_idx = (target == ImGuiTableBgTarget_RowBg1) ? 1 : 0;
     1077: 1817-block 26
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 1817-block 27
     1077: 1817-block 28
     1077: 1818:        table->RowBgColor[bg_idx] = color;
     1077: 1819:        break;
     1077: 1819-block 29
        -: 1820:    }
    #####: 1821:    default:
    #####: 1822:        IM_ASSERT(0);
    %%%%%: 1822-block 30
call    0 never executed
        -: 1823:    }
        -: 1824:}
        -: 1825:
        -: 1826://-------------------------------------------------------------------------
        -: 1827:// [SECTION] Tables: Row changes
        -: 1828://-------------------------------------------------------------------------
        -: 1829:// - TableGetRowIndex()
        -: 1830:// - TableNextRow()
        -: 1831:// - TableBeginRow() [Internal]
        -: 1832:// - TableEndRow() [Internal]
        -: 1833://-------------------------------------------------------------------------
        -: 1834:
        -: 1835:// [Public] Note: for row coloring we use ->RowBgColorCounter which is the same value without counting header rows
function _ZN5ImGui16TableGetRowIndexEv called 0 returned 0% blocks executed 0%
    #####: 1836:int ImGui::TableGetRowIndex()
        -: 1837:{
    #####: 1838:    ImGuiContext& g = *GImGui;
    #####: 1839:    ImGuiTable* table = g.CurrentTable;
    #####: 1840:    if (!table)
    %%%%%: 1840-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1841:        return 0;
    %%%%%: 1841-block 3
    #####: 1842:    return table->CurrentRow;
    %%%%%: 1842-block 4
        -: 1843:}
        -: 1844:
        -: 1845:// [Public] Starts into the first cell of a new row
function _ZN5ImGui12TableNextRowEif called 14001 returned 100% blocks executed 86%
    14001: 1846:void ImGui::TableNextRow(ImGuiTableRowFlags row_flags, float row_min_height)
        -: 1847:{
    14001: 1848:    ImGuiContext& g = *GImGui;
    14001: 1849:    ImGuiTable* table = g.CurrentTable;
        -: 1850:
    14001: 1851:    if (!table->IsLayoutLocked)
    14001: 1851-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 14001
    #####: 1852:        TableUpdateLayout(table);
    %%%%%: 1852-block 3
call    0 never executed
    14001: 1853:    if (table->IsInsideRow)
    14001: 1853-block 4
branch  0 taken 12924 (fallthrough)
branch  1 taken 1077
    12924: 1854:        TableEndRow(table);
    12924: 1854-block 5
call    0 returned 12924
        -: 1855:
    14001: 1856:    table->LastRowFlags = table->RowFlags;
    14001: 1857:    table->RowFlags = row_flags;
    14001: 1858:    table->RowCellPaddingY = g.Style.CellPadding.y;
    14001: 1859:    table->RowMinHeight = row_min_height;
    14001: 1860:    TableBeginRow(table);
    14001: 1860-block 6
call    0 returned 14001
        -: 1861:
        -: 1862:    // We honor min_row_height requested by user, but cannot guarantee per-row maximum height,
        -: 1863:    // because that would essentially require a unique clipping rectangle per-cell.
    14001: 1864:    table->RowPosY2 += table->RowCellPaddingY * 2.0f;
    14001: 1865:    table->RowPosY2 = ImMax(table->RowPosY2, table->RowPosY1 + row_min_height);
call    0 returned 14001
        -: 1866:
        -: 1867:    // Disable output until user calls TableNextColumn()
    14001: 1868:    table->InnerWindow->SkipItems = true;
    14001: 1869:}
        -: 1870:
        -: 1871:// [Internal] Only called by TableNextRow()
function _ZN5ImGui13TableBeginRowEP10ImGuiTable called 14001 returned 100% blocks executed 85%
    14001: 1872:void ImGui::TableBeginRow(ImGuiTable* table)
        -: 1873:{
    14001: 1874:    ImGuiWindow* window = table->InnerWindow;
   14001*: 1875:    IM_ASSERT(!table->IsInsideRow);
    14001: 1875-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 14001
    %%%%%: 1875-block 3
call    2 never executed
        -: 1876:
        -: 1877:    // New row
    14001: 1878:    table->CurrentRow++;
    14001: 1879:    table->CurrentColumn = -1;
    14001: 1880:    table->RowBgColor[0] = table->RowBgColor[1] = IM_COL32_DISABLE;
    14001: 1881:    table->RowCellDataCurrent = -1;
    14001: 1882:    table->IsInsideRow = true;
        -: 1883:
        -: 1884:    // Begin frozen rows
    14001: 1885:    float next_y1 = table->RowPosY2;
    14001: 1886:    if (table->CurrentRow == 0 && table->FreezeRowsCount > 0)
    14001: 1886-block 4
branch  0 taken 1077 (fallthrough)
branch  1 taken 12924
     1077: 1886-block 5
branch  2 taken 0 (fallthrough)
branch  3 taken 1077
    #####: 1887:        next_y1 = window->DC.CursorPos.y = table->OuterRect.Min.y;
    %%%%%: 1887-block 6
        -: 1888:
    14001: 1889:    table->RowPosY1 = table->RowPosY2 = next_y1;
    14001: 1890:    table->RowTextBaseline = 0.0f;
    14001: 1891:    table->RowIndentOffsetX = window->DC.Indent.x - table->HostIndentX; // Lock indent
        -: 1892:
    14001: 1893:    window->DC.PrevLineTextBaseOffset = 0.0f;
    14001: 1894:    window->DC.CursorPosPrevLine = ImVec2(window->DC.CursorPos.x, window->DC.CursorPos.y + table->RowCellPaddingY); // This allows users to call SameLine() to share LineSize between columns.
    14001: 1894-block 7
call    0 returned 14001
    14001: 1895:    window->DC.PrevLineSize = window->DC.CurrLineSize = ImVec2(0.0f, 0.0f); // This allows users to call SameLine() to share LineSize between columns, and to call it from first column too.
call    0 returned 14001
    14001: 1896:    window->DC.IsSameLine = window->DC.IsSetPos = false;
    14001: 1897:    window->DC.CursorMaxPos.y = next_y1;
        -: 1898:
        -: 1899:    // Making the header BG color non-transparent will allow us to overlay it multiple times when handling smooth dragging.
    14001: 1900:    if (table->RowFlags & ImGuiTableRowFlags_Headers)
branch  0 taken 1077 (fallthrough)
branch  1 taken 12924
        -: 1901:    {
     1077: 1902:        TableSetBgColor(ImGuiTableBgTarget_RowBg0, GetColorU32(ImGuiCol_TableHeaderBg));
     1077: 1902-block 10
call    0 returned 1077
call    1 returned 1077
     1077: 1903:        if (table->CurrentRow == 0)
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 1904:            table->IsUsingHeaders = true;
     1077: 1904-block 13
        -: 1905:    }
    14001: 1906:}
        -: 1907:
        -: 1908:// [Internal] Called by TableNextRow()
function _ZN5ImGui11TableEndRowEP10ImGuiTable called 14001 returned 100% blocks executed 50%
    14001: 1909:void ImGui::TableEndRow(ImGuiTable* table)
        -: 1910:{
    14001: 1911:    ImGuiContext& g = *GImGui;
    14001: 1912:    ImGuiWindow* window = g.CurrentWindow;
   14001*: 1913:    IM_ASSERT(window == table->InnerWindow);
    14001: 1913-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 14001
    %%%%%: 1913-block 3
call    2 never executed
   14001*: 1914:    IM_ASSERT(table->IsInsideRow);
    14001: 1914-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 14001
    %%%%%: 1914-block 5
call    2 never executed
        -: 1915:
    14001: 1916:    if (table->CurrentColumn != -1)
    14001: 1916-block 6
branch  0 taken 14001 (fallthrough)
branch  1 taken 0
    14001: 1917:        TableEndCell(table);
    14001: 1917-block 7
call    0 returned 14001
        -: 1918:
        -: 1919:    // Logging
    14001: 1920:    if (g.LogEnabled)
    14001: 1920-block 8
branch  0 taken 0 (fallthrough)
branch  1 taken 14001
    #####: 1921:        LogRenderedText(NULL, "|");
    %%%%%: 1921-block 9
call    0 never executed
        -: 1922:
        -: 1923:    // Position cursor at the bottom of our row so it can be used for e.g. clipping calculation. However it is
        -: 1924:    // likely that the next call to TableBeginCell() will reposition the cursor to take account of vertical padding.
    14001: 1925:    window->DC.CursorPos.y = table->RowPosY2;
        -: 1926:
        -: 1927:    // Row background fill
    14001: 1928:    const float bg_y1 = table->RowPosY1;
    14001: 1929:    const float bg_y2 = table->RowPosY2;
    14001: 1930:    const bool unfreeze_rows_actual = (table->CurrentRow + 1 == table->FreezeRowsCount);
    14001: 1931:    const bool unfreeze_rows_request = (table->CurrentRow + 1 == table->FreezeRowsRequest);
    14001: 1932:    ImGuiTableInstanceData* table_instance = TableGetInstanceData(table, table->InstanceCurrent);
    14001: 1932-block 10
call    0 returned 14001
   14001*: 1933:    if ((table->RowFlags & ImGuiTableRowFlags_Headers) && (table->CurrentRow == 0 || (table->LastRowFlags & ImGuiTableRowFlags_Headers)))
branch  0 taken 1077 (fallthrough)
branch  1 taken 12924
     1077: 1933-block 12
branch  2 taken 0 (fallthrough)
branch  3 taken 1077
    %%%%%: 1933-block 13
branch  4 never executed (fallthrough)
branch  5 never executed
     1077: 1934:        table_instance->LastTopHeadersRowHeight += bg_y2 - bg_y1;
     1077: 1934-block 14
        -: 1935:
    14001: 1936:    const bool is_visible = (bg_y2 >= table->InnerClipRect.Min.y && bg_y1 <= table->InnerClipRect.Max.y);
    14001: 1936-block 15
branch  0 taken 14001 (fallthrough)
branch  1 taken 0
    14001: 1936-block 16
branch  2 taken 13989 (fallthrough)
branch  3 taken 12
    13989: 1936-block 17
       12: 1936-block 18
    14001: 1937:    if (is_visible)
    14001: 1937-block 19
branch  0 taken 13989 (fallthrough)
branch  1 taken 12
        -: 1938:    {
        -: 1939:        // Update data for TableGetHoveredRow()
   13989*: 1940:        if (table->HoveredColumnBody != -1 && g.IO.MousePos.y >= bg_y1 && g.IO.MousePos.y < bg_y2 && table_instance->HoveredRowNext < 0)
    13989: 1940-block 20
branch  0 taken 0 (fallthrough)
branch  1 taken 13989
    %%%%%: 1940-block 21
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1940-block 22
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 1940-block 23
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 1941:            table_instance->HoveredRowNext = table->CurrentRow;
    %%%%%: 1941-block 24
        -: 1942:
        -: 1943:        // Decide of background color for the row
    13989: 1944:        ImU32 bg_col0 = 0;
    13989: 1945:        ImU32 bg_col1 = 0;
    13989: 1946:        if (table->RowBgColor[0] != IM_COL32_DISABLE)
    13989: 1946-block 25
branch  0 taken 1077 (fallthrough)
branch  1 taken 12912
     1077: 1947:            bg_col0 = table->RowBgColor[0];
     1077: 1947-block 26
    12912: 1948:        else if (table->Flags & ImGuiTableFlags_RowBg)
    12912: 1948-block 27
branch  0 taken 12912 (fallthrough)
branch  1 taken 0
    12912: 1949:            bg_col0 = GetColorU32((table->RowBgColorCounter & 1) ? ImGuiCol_TableRowBgAlt : ImGuiCol_TableRowBg);
    12912: 1949-block 28
branch  0 taken 6456 (fallthrough)
branch  1 taken 6456
     6456: 1949-block 29
     6456: 1949-block 30
    12912: 1949-block 31
call    2 returned 12912
    13989: 1950:        if (table->RowBgColor[1] != IM_COL32_DISABLE)
    13989: 1950-block 33
branch  0 taken 0 (fallthrough)
branch  1 taken 13989
    #####: 1951:            bg_col1 = table->RowBgColor[1];
    %%%%%: 1951-block 34
        -: 1952:
        -: 1953:        // Decide of top border color
    13989: 1954:        ImU32 top_border_col = 0;
    13989: 1955:        const float border_size = TABLE_BORDER_SIZE;
    13989: 1956:        if (table->CurrentRow > 0 && (table->Flags & ImGuiTableFlags_BordersInnerH))
    13989: 1956-block 35
branch  0 taken 12912 (fallthrough)
branch  1 taken 1077
    12912: 1956-block 36
branch  2 taken 12912 (fallthrough)
branch  3 taken 0
    12912: 1957:            top_border_col = (table->LastRowFlags & ImGuiTableRowFlags_Headers) ? table->BorderColorStrong : table->BorderColorLight;
    12912: 1957-block 37
branch  0 taken 1076 (fallthrough)
branch  1 taken 11836
     1076: 1957-block 38
    11836: 1957-block 39
    12912: 1957-block 40
        -: 1958:
    13989: 1959:        const bool draw_cell_bg_color = table->RowCellDataCurrent >= 0;
    13989: 1960:        const bool draw_strong_bottom_border = unfreeze_rows_actual;
   13989*: 1961:        if ((bg_col0 | bg_col1 | top_border_col) != 0 || draw_strong_bottom_border || draw_cell_bg_color)
    13989: 1961-block 41
branch  0 taken 0 (fallthrough)
branch  1 taken 13989
    %%%%%: 1961-block 42
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1961-block 43
branch  4 never executed (fallthrough)
branch  5 never executed
        -: 1962:        {
        -: 1963:            // In theory we could call SetWindowClipRectBeforeSetChannel() but since we know TableEndRow() is
        -: 1964:            // always followed by a change of clipping rectangle we perform the smallest overwrite possible here.
    13989: 1965:            if ((table->Flags & ImGuiTableFlags_NoClip) == 0)
    13989: 1965-block 44
branch  0 taken 13989 (fallthrough)
branch  1 taken 0
    13989: 1966:                window->DrawList->_CmdHeader.ClipRect = table->Bg0ClipRectForDrawCmd.ToVec4();
    13989: 1966-block 45
call    0 returned 13989
    13989: 1967:            table->DrawSplitter->SetCurrentChannel(window->DrawList, TABLE_DRAW_CHANNEL_BG0);
    13989: 1967-block 46
call    0 returned 13989
        -: 1968:        }
        -: 1969:
        -: 1970:        // Draw row background
        -: 1971:        // We soft/cpu clip this so all backgrounds and borders can share the same clipping rectangle
   13989*: 1972:        if (bg_col0 || bg_col1)
    13989: 1972-block 47
branch  0 taken 0 (fallthrough)
branch  1 taken 13989
    %%%%%: 1972-block 48
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 1973:        {
    13989: 1974:            ImRect row_rect(table->WorkRect.Min.x, bg_y1, table->WorkRect.Max.x, bg_y2);
    13989: 1974-block 49
call    0 returned 13989
    13989: 1975:            row_rect.ClipWith(table->BgClipRect);
call    0 returned 13989
    13989: 1976:            if (bg_col0 != 0 && row_rect.Min.y < row_rect.Max.y)
branch  0 taken 13989 (fallthrough)
branch  1 taken 0
    13989: 1976-block 52
branch  2 taken 13989 (fallthrough)
branch  3 taken 0
    13989: 1977:                window->DrawList->AddRectFilled(row_rect.Min, row_rect.Max, bg_col0);
    13989: 1977-block 53
call    0 returned 13989
branch  1 taken 13989 (fallthrough)
branch  2 taken 0 (throw)
   13989*: 1978:            if (bg_col1 != 0 && row_rect.Min.y < row_rect.Max.y)
    13989: 1978-block 54
branch  0 taken 0 (fallthrough)
branch  1 taken 13989
    %%%%%: 1978-block 55
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 1979:                window->DrawList->AddRectFilled(row_rect.Min, row_rect.Max, bg_col1);
    %%%%%: 1979-block 56
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 1980:        }
        -: 1981:
        -: 1982:        // Draw cell background color
    13989: 1983:        if (draw_cell_bg_color)
    13989: 1983-block 58
branch  0 taken 0 (fallthrough)
branch  1 taken 13989
        -: 1984:        {
    #####: 1985:            ImGuiTableCellData* cell_data_end = &table->RowCellData[table->RowCellDataCurrent];
    %%%%%: 1985-block 59
call    0 never executed
    #####: 1986:            for (ImGuiTableCellData* cell_data = &table->RowCellData[0]; cell_data <= cell_data_end; cell_data++)
call    0 never executed
    %%%%%: 1986-block 68
    %%%%%: 1986-block 69
branch  1 never executed
branch  2 never executed (fallthrough)
        -: 1987:            {
        -: 1988:                // As we render the BG here we need to clip things (for layout we would not)
        -: 1989:                // FIXME: This cancels the OuterPadding addition done by TableGetCellBgRect(), need to keep it while rendering correctly while scrolling.
    #####: 1990:                const ImGuiTableColumn* column = &table->Columns[cell_data->Column];
    %%%%%: 1990-block 61
call    0 never executed
    #####: 1991:                ImRect cell_bg_rect = TableGetCellBgRect(table, cell_data->Column);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1992:                cell_bg_rect.ClipWith(table->BgClipRect);
    %%%%%: 1992-block 63
call    0 never executed
    #####: 1993:                cell_bg_rect.Min.x = ImMax(cell_bg_rect.Min.x, column->ClipRect.Min.x);     // So that first column after frozen one gets clipped when scrolling
call    0 never executed
    #####: 1994:                cell_bg_rect.Max.x = ImMin(cell_bg_rect.Max.x, column->MaxX);
call    0 never executed
    #####: 1995:                if (cell_bg_rect.Min.y < cell_bg_rect.Max.y)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1996:                    window->DrawList->AddRectFilled(cell_bg_rect.Min, cell_bg_rect.Max, cell_data->BgColor);
    %%%%%: 1996-block 67
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 1997:            }
        -: 1998:        }
        -: 1999:
        -: 2000:        // Draw top border
    13989: 2001:        if (top_border_col && bg_y1 >= table->BgClipRect.Min.y && bg_y1 < table->BgClipRect.Max.y)
    13989: 2001-block 70
branch  0 taken 12912 (fallthrough)
branch  1 taken 1077
    12912: 2001-block 71
branch  2 taken 12912 (fallthrough)
branch  3 taken 0
    12912: 2001-block 72
branch  4 taken 12912 (fallthrough)
branch  5 taken 0
    12912: 2002:            window->DrawList->AddLine(ImVec2(table->BorderX1, bg_y1), ImVec2(table->BorderX2, bg_y1), top_border_col, border_size);
    12912: 2002-block 73
call    0 returned 12912
call    1 returned 12912
call    2 returned 12912
branch  3 taken 12912 (fallthrough)
branch  4 taken 0 (throw)
    12912: 2002-block 76
    $$$$$: 2002-block 109
    $$$$$: 2002-block 110
call    5 never executed
        -: 2003:
        -: 2004:        // Draw bottom border at the row unfreezing mark (always strong)
   13989*: 2005:        if (draw_strong_bottom_border && bg_y2 >= table->BgClipRect.Min.y && bg_y2 < table->BgClipRect.Max.y)
    13989: 2005-block 77
branch  0 taken 0 (fallthrough)
branch  1 taken 13989
    %%%%%: 2005-block 78
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2005-block 79
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 2006:            window->DrawList->AddLine(ImVec2(table->BorderX1, bg_y2), ImVec2(table->BorderX2, bg_y2), table->BorderColorStrong, border_size);
    %%%%%: 2006-block 80
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 2006-block 83
    $$$$$: 2006-block 111
        -: 2007:    }
        -: 2008:
        -: 2009:    // End frozen rows (when we are past the last frozen row line, teleport cursor and alter clipping rectangle)
        -: 2010:    // We need to do that in TableEndRow() instead of TableBeginRow() so the list clipper can mark end of row and
        -: 2011:    // get the new cursor position.
    14001: 2012:    if (unfreeze_rows_request)
    14001: 2012-block 84
branch  0 taken 0 (fallthrough)
branch  1 taken 14001
        -: 2013:    {
    #####: 2014:        for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
    %%%%%: 2014-block 85
    %%%%%: 2014-block 88
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2015:            table->Columns[column_n].NavLayerCurrent = ImGuiNavLayer_Main;
    %%%%%: 2015-block 86
call    0 never executed
    #####: 2016:        const float y0 = ImMax(table->RowPosY2 + 1, table->InnerClipRect.Min.y);
    %%%%%: 2016-block 89
call    0 never executed
    #####: 2017:        table_instance->LastFrozenHeight = y0 - table->OuterRect.Min.y;
        -: 2018:
    #####: 2019:        if (unfreeze_rows_actual)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2020:        {
    #####: 2021:            IM_ASSERT(table->IsUnfrozenRows == false);
    %%%%%: 2021-block 91
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2021-block 92
call    2 never executed
    #####: 2022:            table->IsUnfrozenRows = true;
        -: 2023:
        -: 2024:            // BgClipRect starts as table->InnerClipRect, reduce it now and make BgClipRectForDrawCmd == BgClipRect
    #####: 2025:            table->BgClipRect.Min.y = table->Bg2ClipRectForDrawCmd.Min.y = ImMin(y0, table->InnerClipRect.Max.y);
    %%%%%: 2025-block 93
call    0 never executed
    #####: 2026:            table->BgClipRect.Max.y = table->Bg2ClipRectForDrawCmd.Max.y = table->InnerClipRect.Max.y;
    #####: 2027:            table->Bg2DrawChannelCurrent = table->Bg2DrawChannelUnfrozen;
    #####: 2028:            IM_ASSERT(table->Bg2ClipRectForDrawCmd.Min.y <= table->Bg2ClipRectForDrawCmd.Max.y);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2028-block 95
call    2 never executed
        -: 2029:
    #####: 2030:            float row_height = table->RowPosY2 - table->RowPosY1;
    #####: 2031:            table->RowPosY2 = window->DC.CursorPos.y = table->WorkRect.Min.y + table->RowPosY2 - table->OuterRect.Min.y;
    #####: 2032:            table->RowPosY1 = table->RowPosY2 - row_height;
    #####: 2033:            for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
    %%%%%: 2033-block 96
    %%%%%: 2033-block 99
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 2034:            {
    #####: 2035:                ImGuiTableColumn* column = &table->Columns[column_n];
    %%%%%: 2035-block 97
call    0 never executed
    #####: 2036:                column->DrawChannelCurrent = column->DrawChannelUnfrozen;
    #####: 2037:                column->ClipRect.Min.y = table->Bg2ClipRectForDrawCmd.Min.y;
        -: 2038:            }
        -: 2039:
        -: 2040:            // Update cliprect ahead of TableBeginCell() so clipper can access to new ClipRect->Min.y
    #####: 2041:            SetWindowClipRectBeforeSetChannel(window, table->Columns[0].ClipRect);
    %%%%%: 2041-block 100
call    0 never executed
call    1 never executed
    #####: 2042:            table->DrawSplitter->SetCurrentChannel(window->DrawList, table->Columns[0].DrawChannelCurrent);
call    0 never executed
call    1 never executed
        -: 2043:        }
        -: 2044:    }
        -: 2045:
    14001: 2046:    if (!(table->RowFlags & ImGuiTableRowFlags_Headers))
    14001: 2046-block 104
branch  0 taken 12924 (fallthrough)
branch  1 taken 1077
    12924: 2047:        table->RowBgColorCounter++;
    12924: 2047-block 105
    14001: 2048:    table->IsInsideRow = false;
    14001: 2049:}
    14001: 2049-block 106
        -: 2050:
        -: 2051://-------------------------------------------------------------------------
        -: 2052:// [SECTION] Tables: Columns changes
        -: 2053://-------------------------------------------------------------------------
        -: 2054:// - TableGetColumnIndex()
        -: 2055:// - TableSetColumnIndex()
        -: 2056:// - TableNextColumn()
        -: 2057:// - TableBeginCell() [Internal]
        -: 2058:// - TableEndCell() [Internal]
        -: 2059://-------------------------------------------------------------------------
        -: 2060:
function _ZN5ImGui19TableGetColumnIndexEv called 0 returned 0% blocks executed 0%
    #####: 2061:int ImGui::TableGetColumnIndex()
        -: 2062:{
    #####: 2063:    ImGuiContext& g = *GImGui;
    #####: 2064:    ImGuiTable* table = g.CurrentTable;
    #####: 2065:    if (!table)
    %%%%%: 2065-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2066:        return 0;
    %%%%%: 2066-block 3
    #####: 2067:    return table->CurrentColumn;
    %%%%%: 2067-block 4
        -: 2068:}
        -: 2069:
        -: 2070:// [Public] Append into a specific column
function _ZN5ImGui19TableSetColumnIndexEi called 53850 returned 100% blocks executed 85%
    53850: 2071:bool ImGui::TableSetColumnIndex(int column_n)
        -: 2072:{
    53850: 2073:    ImGuiContext& g = *GImGui;
    53850: 2074:    ImGuiTable* table = g.CurrentTable;
    53850: 2075:    if (!table)
    53850: 2075-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 53850
    #####: 2076:        return false;
    %%%%%: 2076-block 3
        -: 2077:
    53850: 2078:    if (table->CurrentColumn != column_n)
    53850: 2078-block 4
branch  0 taken 53850 (fallthrough)
branch  1 taken 0
        -: 2079:    {
    53850: 2080:        if (table->CurrentColumn != -1)
    53850: 2080-block 5
branch  0 taken 39849 (fallthrough)
branch  1 taken 14001
    39849: 2081:            TableEndCell(table);
    39849: 2081-block 6
call    0 returned 39849
   53850*: 2082:        IM_ASSERT(column_n >= 0 && table->ColumnsCount);
    53850: 2082-block 7
branch  0 taken 53850 (fallthrough)
branch  1 taken 0
    53850: 2082-block 8
branch  2 taken 53850 (fallthrough)
branch  3 taken 0
    53850: 2082-block 9
    %%%%%: 2082-block 10
call    4 never executed
    53850: 2083:        TableBeginCell(table, column_n);
    53850: 2083-block 11
call    0 returned 53850
        -: 2084:    }
        -: 2085:
        -: 2086:    // Return whether the column is visible. User may choose to skip submitting items based on this return value,
        -: 2087:    // however they shouldn't skip submitting for columns that may have the tallest contribution to row height.
    53850: 2088:    return table->Columns[column_n].IsRequestOutput;
    53850: 2088-block 12
call    0 returned 53850
        -: 2089:}
        -: 2090:
        -: 2091:// [Public] Append into the next column, wrap and create a new row when already on last column
function _ZN5ImGui15TableNextColumnEv called 0 returned 0% blocks executed 0%
    #####: 2092:bool ImGui::TableNextColumn()
        -: 2093:{
    #####: 2094:    ImGuiContext& g = *GImGui;
    #####: 2095:    ImGuiTable* table = g.CurrentTable;
    #####: 2096:    if (!table)
    %%%%%: 2096-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2097:        return false;
    %%%%%: 2097-block 3
        -: 2098:
    #####: 2099:    if (table->IsInsideRow && table->CurrentColumn + 1 < table->ColumnsCount)
    %%%%%: 2099-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2099-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 2100:    {
    #####: 2101:        if (table->CurrentColumn != -1)
    %%%%%: 2101-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2102:            TableEndCell(table);
    %%%%%: 2102-block 7
call    0 never executed
    #####: 2103:        TableBeginCell(table, table->CurrentColumn + 1);
    %%%%%: 2103-block 8
call    0 never executed
        -: 2104:    }
        -: 2105:    else
        -: 2106:    {
    #####: 2107:        TableNextRow();
    %%%%%: 2107-block 9
call    0 never executed
    #####: 2108:        TableBeginCell(table, 0);
call    0 never executed
        -: 2109:    }
        -: 2110:
        -: 2111:    // Return whether the column is visible. User may choose to skip submitting items based on this return value,
        -: 2112:    // however they shouldn't skip submitting for columns that may have the tallest contribution to row height.
    #####: 2113:    return table->Columns[table->CurrentColumn].IsRequestOutput;
    %%%%%: 2113-block 11
call    0 never executed
        -: 2114:}
        -: 2115:
        -: 2116:
        -: 2117:// [Internal] Called by TableSetColumnIndex()/TableNextColumn()
        -: 2118:// This is called very frequently, so we need to be mindful of unnecessary overhead.
        -: 2119:// FIXME-TABLE FIXME-OPT: Could probably shortcut some things for non-active or clipped columns.
function _ZN5ImGui14TableBeginCellEP10ImGuiTablei called 53850 returned 100% blocks executed 64%
    53850: 2120:void ImGui::TableBeginCell(ImGuiTable* table, int column_n)
        -: 2121:{
    53850: 2122:    ImGuiContext& g = *GImGui;
    53850: 2123:    ImGuiTableColumn* column = &table->Columns[column_n];
    53850: 2123-block 2
call    0 returned 53850
    53850: 2124:    ImGuiWindow* window = table->InnerWindow;
    53850: 2125:    table->CurrentColumn = column_n;
        -: 2126:
        -: 2127:    // Start position is roughly ~~ CellRect.Min + CellPadding + Indent
    53850: 2128:    float start_x = column->WorkMinX;
    53850: 2129:    if (column->Flags & ImGuiTableColumnFlags_IndentEnable)
branch  0 taken 14001 (fallthrough)
branch  1 taken 39849
    14001: 2130:        start_x += table->RowIndentOffsetX; // ~~ += window.DC.Indent.x - table->HostIndentX, except we locked it for the row.
    14001: 2130-block 4
        -: 2131:
    53850: 2132:    window->DC.CursorPos.x = start_x;
    53850: 2133:    window->DC.CursorPos.y = table->RowPosY1 + table->RowCellPaddingY;
    53850: 2134:    window->DC.CursorMaxPos.x = window->DC.CursorPos.x;
    53850: 2135:    window->DC.ColumnsOffset.x = start_x - window->Pos.x - window->DC.Indent.x; // FIXME-WORKRECT
    53850: 2136:    window->DC.CursorPosPrevLine.x = window->DC.CursorPos.x; // PrevLine.y is preserved. This allows users to call SameLine() to share LineSize between columns.
    53850: 2137:    window->DC.CurrLineTextBaseOffset = table->RowTextBaseline;
    53850: 2138:    window->DC.NavLayerCurrent = (ImGuiNavLayer)column->NavLayerCurrent;
        -: 2139:
        -: 2140:    // Note how WorkRect.Max.y is only set once during layout
    53850: 2141:    window->WorkRect.Min.y = window->DC.CursorPos.y;
    53850: 2142:    window->WorkRect.Min.x = column->WorkMinX;
    53850: 2143:    window->WorkRect.Max.x = column->WorkMaxX;
    53850: 2144:    window->DC.ItemWidth = column->ItemWidth;
        -: 2145:
    53850: 2146:    window->SkipItems = column->IsSkipItems;
    53850: 2147:    if (column->IsSkipItems)
    53850: 2147-block 5
branch  0 taken 0 (fallthrough)
branch  1 taken 53850
        -: 2148:    {
    #####: 2149:        g.LastItemData.ID = 0;
    #####: 2150:        g.LastItemData.StatusFlags = 0;
    %%%%%: 2150-block 6
        -: 2151:    }
        -: 2152:
    53850: 2153:    if (table->Flags & ImGuiTableFlags_NoClip)
    53850: 2153-block 7
branch  0 taken 0 (fallthrough)
branch  1 taken 53850
        -: 2154:    {
        -: 2155:        // FIXME: if we end up drawing all borders/bg in EndTable, could remove this and just assert that channel hasn't changed.
    #####: 2156:        table->DrawSplitter->SetCurrentChannel(window->DrawList, TABLE_DRAW_CHANNEL_NOCLIP);
    %%%%%: 2156-block 8
call    0 never executed
        -: 2157:        //IM_ASSERT(table->DrawSplitter._Current == TABLE_DRAW_CHANNEL_NOCLIP);
        -: 2158:    }
        -: 2159:    else
        -: 2160:    {
        -: 2161:        // FIXME-TABLE: Could avoid this if draw channel is dummy channel?
    53850: 2162:        SetWindowClipRectBeforeSetChannel(window, column->ClipRect);
    53850: 2162-block 9
call    0 returned 53850
    53850: 2163:        table->DrawSplitter->SetCurrentChannel(window->DrawList, column->DrawChannelCurrent);
call    0 returned 53850
        -: 2164:    }
        -: 2165:
        -: 2166:    // Logging
   53850*: 2167:    if (g.LogEnabled && !column->IsSkipItems)
    53850: 2167-block 11
branch  0 taken 0 (fallthrough)
branch  1 taken 53850
    %%%%%: 2167-block 12
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 2168:    {
    #####: 2169:        LogRenderedText(&window->DC.CursorPos, "|");
    %%%%%: 2169-block 13
call    0 never executed
    #####: 2170:        g.LogLinePosY = FLT_MAX;
        -: 2171:    }
    53850: 2172:}
        -: 2173:
        -: 2174:// [Internal] Called by TableNextRow()/TableSetColumnIndex()/TableNextColumn()
function _ZN5ImGui12TableEndCellEP10ImGuiTable called 53850 returned 100% blocks executed 87%
    53850: 2175:void ImGui::TableEndCell(ImGuiTable* table)
        -: 2176:{
    53850: 2177:    ImGuiTableColumn* column = &table->Columns[table->CurrentColumn];
    53850: 2177-block 2
call    0 returned 53850
    53850: 2178:    ImGuiWindow* window = table->InnerWindow;
        -: 2179:
    53850: 2180:    if (window->DC.IsSetPos)
branch  0 taken 0 (fallthrough)
branch  1 taken 53850
    #####: 2181:        ErrorCheckUsingSetCursorPosToExtendParentBoundaries();
    %%%%%: 2181-block 4
call    0 never executed
        -: 2182:
        -: 2183:    // Report maximum position so we can infer content size per column.
        -: 2184:    float* p_max_pos_x;
    53850: 2185:    if (table->RowFlags & ImGuiTableRowFlags_Headers)
    53850: 2185-block 5
branch  0 taken 4308 (fallthrough)
branch  1 taken 49542
     4308: 2186:        p_max_pos_x = &column->ContentMaxXHeadersUsed;  // Useful in case user submit contents in header row that is not a TableHeader() call
     4308: 2186-block 6
        -: 2187:    else
   49542*: 2188:        p_max_pos_x = table->IsUnfrozenRows ? &column->ContentMaxXUnfrozen : &column->ContentMaxXFrozen;
    49542: 2188-block 7
branch  0 taken 49542 (fallthrough)
branch  1 taken 0
    49542: 2188-block 8
    %%%%%: 2188-block 9
    49542: 2188-block 10
    53850: 2189:    *p_max_pos_x = ImMax(*p_max_pos_x, window->DC.CursorMaxPos.x);
    53850: 2189-block 11
call    0 returned 53850
    53850: 2190:    if (column->IsEnabled)
branch  0 taken 53850 (fallthrough)
branch  1 taken 0
    53850: 2191:        table->RowPosY2 = ImMax(table->RowPosY2, window->DC.CursorMaxPos.y + table->RowCellPaddingY);
    53850: 2191-block 13
call    0 returned 53850
    53850: 2192:    column->ItemWidth = window->DC.ItemWidth;
        -: 2193:
        -: 2194:    // Propagate text baseline for the entire row
        -: 2195:    // FIXME-TABLE: Here we propagate text baseline from the last line of the cell.. instead of the first one.
    53850: 2196:    table->RowTextBaseline = ImMax(table->RowTextBaseline, window->DC.PrevLineTextBaseOffset);
    53850: 2196-block 15
call    0 returned 53850
    53850: 2197:}
        -: 2198:
        -: 2199://-------------------------------------------------------------------------
        -: 2200:// [SECTION] Tables: Columns width management
        -: 2201://-------------------------------------------------------------------------
        -: 2202:// - TableGetMaxColumnWidth() [Internal]
        -: 2203:// - TableGetColumnWidthAuto() [Internal]
        -: 2204:// - TableSetColumnWidth()
        -: 2205:// - TableSetColumnWidthAutoSingle() [Internal]
        -: 2206:// - TableSetColumnWidthAutoAll() [Internal]
        -: 2207:// - TableUpdateColumnsWeightFromWidth() [Internal]
        -: 2208://-------------------------------------------------------------------------
        -: 2209:// Note that actual columns widths are computed in TableUpdateLayout().
        -: 2210://-------------------------------------------------------------------------
        -: 2211:
        -: 2212:// Maximum column content width given current layout. Use column->MinX so this value differs on a per-column basis.
function _ZN5ImGui23TableCalcMaxColumnWidthEPK10ImGuiTablei called 4308 returned 100% blocks executed 75%
     4308: 2213:float ImGui::TableCalcMaxColumnWidth(const ImGuiTable* table, int column_n)
        -: 2214:{
     4308: 2215:    const ImGuiTableColumn* column = &table->Columns[column_n];
     4308: 2215-block 2
call    0 returned 4308
     4308: 2216:    float max_width = FLT_MAX;
     4308: 2217:    const float min_column_distance = table->MinColumnWidth + table->CellPaddingX * 2.0f + table->CellSpacingX1 + table->CellSpacingX2;
     4308: 2218:    if (table->Flags & ImGuiTableFlags_ScrollX)
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
        -: 2219:    {
        -: 2220:        // Frozen columns can't reach beyond visible width else scrolling will naturally break.
        -: 2221:        // (we use DisplayOrder as within a set of multiple frozen column reordering is possible)
    #####: 2222:        if (column->DisplayOrder < table->FreezeColumnsRequest)
    %%%%%: 2222-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2223:        {
    #####: 2224:            max_width = (table->InnerClipRect.Max.x - (table->FreezeColumnsRequest - column->DisplayOrder) * min_column_distance) - column->MinX;
    #####: 2225:            max_width = max_width - table->OuterPaddingX - table->CellPaddingX - table->CellSpacingX2;
    %%%%%: 2225-block 5
        -: 2226:        }
        -: 2227:    }
     4308: 2228:    else if ((table->Flags & ImGuiTableFlags_NoKeepColumnsVisible) == 0)
     4308: 2228-block 6
branch  0 taken 4308 (fallthrough)
branch  1 taken 0
        -: 2229:    {
        -: 2230:        // If horizontal scrolling if disabled, we apply a final lossless shrinking of columns in order to make
        -: 2231:        // sure they are all visible. Because of this we also know that all of the columns will always fit in
        -: 2232:        // table->WorkRect and therefore in table->InnerRect (because ScrollX is off)
        -: 2233:        // FIXME-TABLE: This is solved incorrectly but also quite a difficult problem to fix as we also want ClipRect width to match.
        -: 2234:        // See "table_width_distrib" and "table_width_keep_visible" tests
     4308: 2235:        max_width = table->WorkRect.Max.x - (table->ColumnsEnabledCount - column->IndexWithinEnabledSet - 1) * min_column_distance - column->MinX;
        -: 2236:        //max_width -= table->CellSpacingX1;
     4308: 2237:        max_width -= table->CellSpacingX2;
     4308: 2238:        max_width -= table->CellPaddingX * 2.0f;
     4308: 2239:        max_width -= table->OuterPaddingX;
     4308: 2239-block 7
        -: 2240:    }
     4308: 2241:    return max_width;
     4308: 2241-block 8
        -: 2242:}
        -: 2243:
        -: 2244:// Note this is meant to be stored in column->WidthAuto, please generally use the WidthAuto field
function _ZN5ImGui23TableGetColumnWidthAutoEP10ImGuiTableP16ImGuiTableColumn called 8612 returned 100% blocks executed 60%
     8612: 2245:float ImGui::TableGetColumnWidthAuto(ImGuiTable* table, ImGuiTableColumn* column)
        -: 2246:{
     8612: 2247:    const float content_width_body = ImMax(column->ContentMaxXFrozen, column->ContentMaxXUnfrozen) - column->WorkMinX;
     8612: 2247-block 2
call    0 returned 8612
     8612: 2248:    const float content_width_headers = column->ContentMaxXHeadersIdeal - column->WorkMinX;
     8612: 2249:    float width_auto = content_width_body;
     8612: 2250:    if (!(column->Flags & ImGuiTableColumnFlags_NoHeaderWidth))
branch  0 taken 8612 (fallthrough)
branch  1 taken 0
     8612: 2251:        width_auto = ImMax(width_auto, content_width_headers);
     8612: 2251-block 4
call    0 returned 8612
        -: 2252:
        -: 2253:    // Non-resizable fixed columns preserve their requested width
    8612*: 2254:    if ((column->Flags & ImGuiTableColumnFlags_WidthFixed) && column->InitStretchWeightOrWidth > 0.0f)
     8612: 2254-block 5
branch  0 taken 0 (fallthrough)
branch  1 taken 8612
    %%%%%: 2254-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2255:        if (!(table->Flags & ImGuiTableFlags_Resizable) || (column->Flags & ImGuiTableColumnFlags_NoResize))
    %%%%%: 2255-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2255-block 8
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2256:            width_auto = column->InitStretchWeightOrWidth;
    %%%%%: 2256-block 9
        -: 2257:
     8612: 2258:    return ImMax(width_auto, table->MinColumnWidth);
     8612: 2258-block 10
call    0 returned 8612
        -: 2259:}
        -: 2260:
        -: 2261:// 'width' = inner column width, without padding
function _ZN5ImGui19TableSetColumnWidthEif called 0 returned 0% blocks executed 0%
    #####: 2262:void ImGui::TableSetColumnWidth(int column_n, float width)
        -: 2263:{
    #####: 2264:    ImGuiContext& g = *GImGui;
    #####: 2265:    ImGuiTable* table = g.CurrentTable;
    #####: 2266:    IM_ASSERT(table != NULL && table->IsLayoutLocked == false);
    %%%%%: 2266-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2266-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2266-block 4
    %%%%%: 2266-block 5
call    4 never executed
    #####: 2267:    IM_ASSERT(column_n >= 0 && column_n < table->ColumnsCount);
    %%%%%: 2267-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2267-block 7
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2267-block 8
    %%%%%: 2267-block 9
call    4 never executed
    #####: 2268:    ImGuiTableColumn* column_0 = &table->Columns[column_n];
    %%%%%: 2268-block 10
call    0 never executed
    #####: 2269:    float column_0_width = width;
        -: 2270:
        -: 2271:    // Apply constraints early
        -: 2272:    // Compare both requested and actual given width to avoid overwriting requested width when column is stuck (minimum size, bounded)
    #####: 2273:    IM_ASSERT(table->MinColumnWidth > 0.0f);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2273-block 12
call    2 never executed
    #####: 2274:    const float min_width = table->MinColumnWidth;
    #####: 2275:    const float max_width = ImMax(min_width, column_0->WidthMax); // Don't use TableCalcMaxColumnWidth() here as it would rely on MinX from last instance (#7933)
    %%%%%: 2275-block 13
call    0 never executed
    #####: 2276:    column_0_width = ImClamp(column_0_width, min_width, max_width);
call    0 never executed
    #####: 2277:    if (column_0->WidthGiven == column_0_width || column_0->WidthRequest == column_0_width)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2277-block 16
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2278:        return;
    %%%%%: 2278-block 17
        -: 2279:
        -: 2280:    //IMGUI_DEBUG_PRINT("TableSetColumnWidth(%d, %.1f->%.1f)\n", column_0_idx, column_0->WidthGiven, column_0_width);
    #####: 2281:    ImGuiTableColumn* column_1 = (column_0->NextEnabledColumn != -1) ? &table->Columns[column_0->NextEnabledColumn] : NULL;
    %%%%%: 2281-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2281-block 19
call    2 never executed
    %%%%%: 2281-block 20
        -: 2282:
        -: 2283:    // In this surprisingly not simple because of how we support mixing Fixed and multiple Stretch columns.
        -: 2284:    // - All fixed: easy.
        -: 2285:    // - All stretch: easy.
        -: 2286:    // - One or more fixed + one stretch: easy.
        -: 2287:    // - One or more fixed + more than one stretch: tricky.
        -: 2288:    // Qt when manual resize is enabled only supports a single _trailing_ stretch column, we support more cases here.
        -: 2289:
        -: 2290:    // When forwarding resize from Wn| to Fn+1| we need to be considerate of the _NoResize flag on Fn+1.
        -: 2291:    // FIXME-TABLE: Find a way to rewrite all of this so interactions feel more consistent for the user.
        -: 2292:    // Scenarios:
        -: 2293:    // - F1 F2 F3  resize from F1| or F2|   --> ok: alter ->WidthRequested of Fixed column. Subsequent columns will be offset.
        -: 2294:    // - F1 F2 F3  resize from F3|          --> ok: alter ->WidthRequested of Fixed column. If active, ScrollX extent can be altered.
        -: 2295:    // - F1 F2 W3  resize from F1| or F2|   --> ok: alter ->WidthRequested of Fixed column. If active, ScrollX extent can be altered, but it doesn't make much sense as the Stretch column will always be minimal size.
        -: 2296:    // - F1 F2 W3  resize from W3|          --> ok: no-op (disabled by Resize Rule 1)
        -: 2297:    // - W1 W2 W3  resize from W1| or W2|   --> ok
        -: 2298:    // - W1 W2 W3  resize from W3|          --> ok: no-op (disabled by Resize Rule 1)
        -: 2299:    // - W1 F2 F3  resize from F3|          --> ok: no-op (disabled by Resize Rule 1)
        -: 2300:    // - W1 F2     resize from F2|          --> ok: no-op (disabled by Resize Rule 1)
        -: 2301:    // - W1 W2 F3  resize from W1| or W2|   --> ok
        -: 2302:    // - W1 F2 W3  resize from W1| or F2|   --> ok
        -: 2303:    // - F1 W2 F3  resize from W2|          --> ok
        -: 2304:    // - F1 W3 F2  resize from W3|          --> ok
        -: 2305:    // - W1 F2 F3  resize from W1|          --> ok: equivalent to resizing |F2. F3 will not move.
        -: 2306:    // - W1 F2 F3  resize from F2|          --> ok
        -: 2307:    // All resizes from a Wx columns are locking other columns.
        -: 2308:
        -: 2309:    // Possible improvements:
        -: 2310:    // - W1 W2 W3  resize W1|               --> to not be stuck, both W2 and W3 would stretch down. Seems possible to fix. Would be most beneficial to simplify resize of all-weighted columns.
        -: 2311:    // - W3 F1 F2  resize W3|               --> to not be stuck past F1|, both F1 and F2 would need to stretch down, which would be lossy or ambiguous. Seems hard to fix.
        -: 2312:
        -: 2313:    // [Resize Rule 1] Can't resize from right of right-most visible column if there is any Stretch column. Implemented in TableUpdateLayout().
        -: 2314:
        -: 2315:    // If we have all Fixed columns OR resizing a Fixed column that doesn't come after a Stretch one, we can do an offsetting resize.
        -: 2316:    // This is the preferred resize path
    #####: 2317:    if (column_0->Flags & ImGuiTableColumnFlags_WidthFixed)
    %%%%%: 2317-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2318:        if (!column_1 || table->LeftMostStretchedColumn == -1 || table->Columns[table->LeftMostStretchedColumn].DisplayOrder >= column_0->DisplayOrder)
    %%%%%: 2318-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2318-block 23
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2318-block 24
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 2318-block 26
    %%%%%: 2318-block 27
    %%%%%: 2318-block 28
branch  7 never executed (fallthrough)
branch  8 never executed
        -: 2319:        {
    #####: 2320:            column_0->WidthRequest = column_0_width;
    #####: 2321:            table->IsSettingsDirty = true;
    #####: 2322:            return;
    %%%%%: 2322-block 29
        -: 2323:        }
        -: 2324:
        -: 2325:    // We can also use previous column if there's no next one (this is used when doing an auto-fit on the right-most stretch column)
    #####: 2326:    if (column_1 == NULL)
    %%%%%: 2326-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2327:        column_1 = (column_0->PrevEnabledColumn != -1) ? &table->Columns[column_0->PrevEnabledColumn] : NULL;
    %%%%%: 2327-block 31
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2327-block 32
call    2 never executed
    %%%%%: 2327-block 33
    %%%%%: 2327-block 34
    #####: 2328:    if (column_1 == NULL)
    %%%%%: 2328-block 35
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2329:        return;
    %%%%%: 2329-block 36
        -: 2330:
        -: 2331:    // Resizing from right-side of a Stretch column before a Fixed column forward sizing to left-side of fixed column.
        -: 2332:    // (old_a + old_b == new_a + new_b) --> (new_a == old_a + old_b - new_b)
    #####: 2333:    float column_1_width = ImMax(column_1->WidthRequest - (column_0_width - column_0->WidthRequest), min_width);
    %%%%%: 2333-block 37
call    0 never executed
    #####: 2334:    column_0_width = column_0->WidthRequest + column_1->WidthRequest - column_1_width;
    #####: 2335:    IM_ASSERT(column_0_width > 0.0f && column_1_width > 0.0f);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2335-block 39
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2335-block 40
    %%%%%: 2335-block 41
call    4 never executed
    #####: 2336:    column_0->WidthRequest = column_0_width;
    #####: 2337:    column_1->WidthRequest = column_1_width;
    #####: 2338:    if ((column_0->Flags | column_1->Flags) & ImGuiTableColumnFlags_WidthStretch)
    %%%%%: 2338-block 42
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2339:        TableUpdateColumnsWeightFromWidth(table);
    %%%%%: 2339-block 43
call    0 never executed
    #####: 2340:    table->IsSettingsDirty = true;
    %%%%%: 2340-block 44
        -: 2341:}
        -: 2342:
        -: 2343:// Disable clipping then auto-fit, will take 2 frames
        -: 2344:// (we don't take a shortcut for unclipped columns to reduce inconsistencies when e.g. resizing multiple columns)
function _ZN5ImGui29TableSetColumnWidthAutoSingleEP10ImGuiTablei called 0 returned 0% blocks executed 0%
    #####: 2345:void ImGui::TableSetColumnWidthAutoSingle(ImGuiTable* table, int column_n)
        -: 2346:{
        -: 2347:    // Single auto width uses auto-fit
    #####: 2348:    ImGuiTableColumn* column = &table->Columns[column_n];
    %%%%%: 2348-block 2
call    0 never executed
    #####: 2349:    if (!column->IsEnabled)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2350:        return;
    %%%%%: 2350-block 4
    #####: 2351:    column->CannotSkipItemsQueue = (1 << 0);
    #####: 2352:    table->AutoFitSingleColumn = (ImGuiTableColumnIdx)column_n;
    %%%%%: 2352-block 5
        -: 2353:}
        -: 2354:
function _ZN5ImGui26TableSetColumnWidthAutoAllEP10ImGuiTable called 0 returned 0% blocks executed 0%
    #####: 2355:void ImGui::TableSetColumnWidthAutoAll(ImGuiTable* table)
        -: 2356:{
    #####: 2357:    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
    %%%%%: 2357-block 2
    %%%%%: 2357-block 8
    %%%%%: 2357-block 9
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 2358:    {
    #####: 2359:        ImGuiTableColumn* column = &table->Columns[column_n];
    %%%%%: 2359-block 3
call    0 never executed
    #####: 2360:        if (!column->IsEnabled && !(column->Flags & ImGuiTableColumnFlags_WidthStretch)) // Cannot reset weight of hidden stretch column
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2360-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2361:            continue;
    %%%%%: 2361-block 6
    #####: 2362:        column->CannotSkipItemsQueue = (1 << 0);
    #####: 2363:        column->AutoFitQueue = (1 << 1);
    %%%%%: 2363-block 7
        -: 2364:    }
    #####: 2365:}
        -: 2366:
function _ZN5ImGui33TableUpdateColumnsWeightFromWidthEP10ImGuiTable called 0 returned 0% blocks executed 0%
    #####: 2367:void ImGui::TableUpdateColumnsWeightFromWidth(ImGuiTable* table)
        -: 2368:{
    #####: 2369:    IM_ASSERT(table->LeftMostStretchedColumn != -1 && table->RightMostStretchedColumn != -1);
    %%%%%: 2369-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2369-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2369-block 4
    %%%%%: 2369-block 5
call    4 never executed
        -: 2370:
        -: 2371:    // Measure existing quantities
    #####: 2372:    float visible_weight = 0.0f;
    #####: 2373:    float visible_width = 0.0f;
    #####: 2374:    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
    %%%%%: 2374-block 6
    %%%%%: 2374-block 14
    %%%%%: 2374-block 15
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 2375:    {
    #####: 2376:        ImGuiTableColumn* column = &table->Columns[column_n];
    %%%%%: 2376-block 7
call    0 never executed
    #####: 2377:        if (!column->IsEnabled || !(column->Flags & ImGuiTableColumnFlags_WidthStretch))
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2377-block 9
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2378:            continue;
    %%%%%: 2378-block 10
    #####: 2379:        IM_ASSERT(column->StretchWeight > 0.0f);
    %%%%%: 2379-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2379-block 12
call    2 never executed
    #####: 2380:        visible_weight += column->StretchWeight;
    #####: 2381:        visible_width += column->WidthRequest;
    %%%%%: 2381-block 13
        -: 2382:    }
    #####: 2383:    IM_ASSERT(visible_weight > 0.0f && visible_width > 0.0f);
    %%%%%: 2383-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2383-block 17
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2383-block 18
    %%%%%: 2383-block 19
call    4 never executed
        -: 2384:
        -: 2385:    // Apply new weights
    #####: 2386:    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
    %%%%%: 2386-block 20
    %%%%%: 2386-block 27
    %%%%%: 2386-block 28
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 2387:    {
    #####: 2388:        ImGuiTableColumn* column = &table->Columns[column_n];
    %%%%%: 2388-block 21
call    0 never executed
    #####: 2389:        if (!column->IsEnabled || !(column->Flags & ImGuiTableColumnFlags_WidthStretch))
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2389-block 23
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2390:            continue;
    %%%%%: 2390-block 24
    #####: 2391:        column->StretchWeight = (column->WidthRequest / visible_width) * visible_weight;
    #####: 2392:        IM_ASSERT(column->StretchWeight > 0.0f);
    %%%%%: 2392-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2392-block 26
call    2 never executed
        -: 2393:    }
    #####: 2394:}
        -: 2395:
        -: 2396://-------------------------------------------------------------------------
        -: 2397:// [SECTION] Tables: Drawing
        -: 2398://-------------------------------------------------------------------------
        -: 2399:// - TablePushBackgroundChannel() [Internal]
        -: 2400:// - TablePopBackgroundChannel() [Internal]
        -: 2401:// - TableSetupDrawChannels() [Internal]
        -: 2402:// - TableMergeDrawChannels() [Internal]
        -: 2403:// - TableGetColumnBorderCol() [Internal]
        -: 2404:// - TableDrawBorders() [Internal]
        -: 2405://-------------------------------------------------------------------------
        -: 2406:
        -: 2407:// Bg2 is used by Selectable (and possibly other widgets) to render to the background.
        -: 2408:// Unlike our Bg0/1 channel which we uses for RowBg/CellBg/Borders and where we guarantee all shapes to be CPU-clipped, the Bg2 channel being widgets-facing will rely on regular ClipRect.
function _ZN5ImGui26TablePushBackgroundChannelEv called 0 returned 0% blocks executed 0%
    #####: 2409:void ImGui::TablePushBackgroundChannel()
        -: 2410:{
    #####: 2411:    ImGuiContext& g = *GImGui;
    #####: 2412:    ImGuiWindow* window = g.CurrentWindow;
    #####: 2413:    ImGuiTable* table = g.CurrentTable;
        -: 2414:
        -: 2415:    // Optimization: avoid SetCurrentChannel() + PushClipRect()
    #####: 2416:    table->HostBackupInnerClipRect = window->ClipRect;
    #####: 2417:    SetWindowClipRectBeforeSetChannel(window, table->Bg2ClipRectForDrawCmd);
    %%%%%: 2417-block 2
call    0 never executed
    #####: 2418:    table->DrawSplitter->SetCurrentChannel(window->DrawList, table->Bg2DrawChannelCurrent);
call    0 never executed
    #####: 2419:}
        -: 2420:
function _ZN5ImGui25TablePopBackgroundChannelEv called 0 returned 0% blocks executed 0%
    #####: 2421:void ImGui::TablePopBackgroundChannel()
        -: 2422:{
    #####: 2423:    ImGuiContext& g = *GImGui;
    #####: 2424:    ImGuiWindow* window = g.CurrentWindow;
    #####: 2425:    ImGuiTable* table = g.CurrentTable;
    #####: 2426:    ImGuiTableColumn* column = &table->Columns[table->CurrentColumn];
    %%%%%: 2426-block 2
call    0 never executed
        -: 2427:
        -: 2428:    // Optimization: avoid PopClipRect() + SetCurrentChannel()
    #####: 2429:    SetWindowClipRectBeforeSetChannel(window, table->HostBackupInnerClipRect);
call    0 never executed
    #####: 2430:    table->DrawSplitter->SetCurrentChannel(window->DrawList, column->DrawChannelCurrent);
call    0 never executed
    #####: 2431:}
        -: 2432:
        -: 2433:// Allocate draw channels. Called by TableUpdateLayout()
        -: 2434:// - We allocate them following storage order instead of display order so reordering columns won't needlessly
        -: 2435://   increase overall dormant memory cost.
        -: 2436:// - We isolate headers draw commands in their own channels instead of just altering clip rects.
        -: 2437://   This is in order to facilitate merging of draw commands.
        -: 2438:// - After crossing FreezeRowsCount, all columns see their current draw channel changed to a second set of channels.
        -: 2439:// - We only use the dummy draw channel so we can push a null clipping rectangle into it without affecting other
        -: 2440://   channels, while simplifying per-row/per-cell overhead. It will be empty and discarded when merged.
        -: 2441:// - We allocate 1 or 2 background draw channels. This is because we know TablePushBackgroundChannel() is only used for
        -: 2442://   horizontal spanning. If we allowed vertical spanning we'd need one background draw channel per merge group (1-4).
        -: 2443:// Draw channel allocation (before merging):
        -: 2444:// - NoClip                       --> 2+D+1 channels: bg0/1 + bg2 + foreground (same clip rect == always 1 draw call)
        -: 2445:// - Clip                         --> 2+D+N channels
        -: 2446:// - FreezeRows                   --> 2+D+N*2 (unless scrolling value is zero)
        -: 2447:// - FreezeRows || FreezeColunns  --> 3+D+N*2 (unless scrolling value is zero)
        -: 2448:// Where D is 1 if any column is clipped or hidden (dummy channel) otherwise 0.
function _ZN5ImGui22TableSetupDrawChannelsEP10ImGuiTable called 1077 returned 100% blocks executed 85%
     1077: 2449:void ImGui::TableSetupDrawChannels(ImGuiTable* table)
        -: 2450:{
    1077*: 2451:    const int freeze_row_multiplier = (table->FreezeRowsCount > 0) ? 2 : 1;
     1077: 2451-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 2451-block 3
     1077: 2451-block 4
    1077*: 2452:    const int channels_for_row = (table->Flags & ImGuiTableFlags_NoClip) ? 1 : table->ColumnsEnabledCount;
     1077: 2452-block 5
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 2452-block 6
    %%%%%: 2452-block 7
     1077: 2453:    const int channels_for_bg = 1 + 1 * freeze_row_multiplier;
     1077: 2454:    const int channels_for_dummy = (table->ColumnsEnabledCount < table->ColumnsCount || (memcmp(table->VisibleMaskByIndex, table->EnabledMaskByIndex, ImBitArrayGetStorageSizeInBytes(table->ColumnsCount)) != 0)) ? +1 : 0;
     1077: 2454-block 8
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 2454-block 9
call    2 returned 1077
branch  3 taken 1 (fallthrough)
branch  4 taken 1076
        1: 2454-block 11
     1076: 2454-block 12
     1077: 2455:    const int channels_total = channels_for_bg + (channels_for_row * freeze_row_multiplier) + channels_for_dummy;
     1077: 2456:    table->DrawSplitter->Split(table->InnerWindow->DrawList, channels_total);
     1077: 2456-block 13
call    0 returned 1077
     1077: 2457:    table->DummyDrawChannel = (ImGuiTableDrawChannelIdx)((channels_for_dummy > 0) ? channels_total - 1 : -1);
branch  0 taken 1 (fallthrough)
branch  1 taken 1076
        1: 2457-block 15
     1076: 2457-block 16
     1077: 2458:    table->Bg2DrawChannelCurrent = TABLE_DRAW_CHANNEL_BG2_FROZEN;
    1077*: 2459:    table->Bg2DrawChannelUnfrozen = (ImGuiTableDrawChannelIdx)((table->FreezeRowsCount > 0) ? 2 + channels_for_row : TABLE_DRAW_CHANNEL_BG2_FROZEN);
     1077: 2459-block 17
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 2459-block 18
     1077: 2459-block 19
        -: 2460:
     1077: 2461:    int draw_channel_current = 2;
     5385: 2462:    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
     1077: 2462-block 20
     5385: 2462-block 32
branch  0 taken 4308
branch  1 taken 1077 (fallthrough)
        -: 2463:    {
     4308: 2464:        ImGuiTableColumn* column = &table->Columns[column_n];
     4308: 2464-block 21
call    0 returned 4308
     4308: 2465:        if (column->IsVisibleX && column->IsVisibleY)
branch  0 taken 4305 (fallthrough)
branch  1 taken 3
     4305: 2465-block 23
branch  2 taken 4305 (fallthrough)
branch  3 taken 0
        -: 2466:        {
     4305: 2467:            column->DrawChannelFrozen = (ImGuiTableDrawChannelIdx)(draw_channel_current);
    4305*: 2468:            column->DrawChannelUnfrozen = (ImGuiTableDrawChannelIdx)(draw_channel_current + (table->FreezeRowsCount > 0 ? channels_for_row + 1 : 0));
     4305: 2468-block 24
branch  0 taken 0 (fallthrough)
branch  1 taken 4305
    %%%%%: 2468-block 25
     4305: 2468-block 26
     4305: 2469:            if (!(table->Flags & ImGuiTableFlags_NoClip))
     4305: 2469-block 27
branch  0 taken 4305 (fallthrough)
branch  1 taken 0
     4305: 2470:                draw_channel_current++;
     4305: 2470-block 28
        -: 2471:        }
        -: 2472:        else
        -: 2473:        {
        3: 2474:            column->DrawChannelFrozen = column->DrawChannelUnfrozen = table->DummyDrawChannel;
        3: 2474-block 30
        -: 2475:        }
     4308: 2476:        column->DrawChannelCurrent = column->DrawChannelFrozen;
     4308: 2476-block 31
        -: 2477:    }
        -: 2478:
        -: 2479:    // Initial draw cmd starts with a BgClipRect that matches the one of its host, to facilitate merge draw commands by default.
        -: 2480:    // All our cell highlight are manually clipped with BgClipRect. When unfreezing it will be made smaller to fit scrolling rect.
        -: 2481:    // (This technically isn't part of setting up draw channels, but is reasonably related to be done here)
     1077: 2482:    table->BgClipRect = table->InnerClipRect;
     1077: 2483:    table->Bg0ClipRectForDrawCmd = table->OuterWindow->ClipRect;
     1077: 2484:    table->Bg2ClipRectForDrawCmd = table->HostClipRect;
    1077*: 2485:    IM_ASSERT(table->BgClipRect.Min.y <= table->BgClipRect.Max.y);
     1077: 2485-block 33
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 2485-block 34
call    2 never executed
     1077: 2486:}
        -: 2487:
        -: 2488:// This function reorder draw channels based on matching clip rectangle, to facilitate merging them. Called by EndTable().
        -: 2489:// For simplicity we call it TableMergeDrawChannels() but in fact it only reorder channels + overwrite ClipRect,
        -: 2490:// actual merging is done by table->DrawSplitter.Merge() which is called right after TableMergeDrawChannels().
        -: 2491://
        -: 2492:// Columns where the contents didn't stray off their local clip rectangle can be merged. To achieve
        -: 2493:// this we merge their clip rect and make them contiguous in the channel list, so they can be merged
        -: 2494:// by the call to DrawSplitter.Merge() following to the call to this function.
        -: 2495:// We reorder draw commands by arranging them into a maximum of 4 distinct groups:
        -: 2496://
        -: 2497://   1 group:               2 groups:              2 groups:              4 groups:
        -: 2498://   [ 0. ] no freeze       [ 0. ] row freeze      [ 01 ] col freeze      [ 01 ] row+col freeze
        -: 2499://   [ .. ]  or no scroll   [ 2. ]  and v-scroll   [ .. ]  and h-scroll   [ 23 ]  and v+h-scroll
        -: 2500://
        -: 2501:// Each column itself can use 1 channel (row freeze disabled) or 2 channels (row freeze enabled).
        -: 2502:// When the contents of a column didn't stray off its limit, we move its channels into the corresponding group
        -: 2503:// based on its position (within frozen rows/columns groups or not).
        -: 2504:// At the end of the operation our 1-4 groups will each have a ImDrawCmd using the same ClipRect.
        -: 2505:// This function assume that each column are pointing to a distinct draw channel,
        -: 2506:// otherwise merge_group->ChannelsCount will not match set bit count of merge_group->ChannelsMask.
        -: 2507://
        -: 2508:// Column channels will not be merged into one of the 1-4 groups in the following cases:
        -: 2509:// - The contents stray off its clipping rectangle (we only compare the MaxX value, not the MinX value).
        -: 2510://   Direct ImDrawList calls won't be taken into account by default, if you use them make sure the ImGui:: bounds
        -: 2511://   matches, by e.g. calling SetCursorScreenPos().
        -: 2512:// - The channel uses more than one draw command itself. We drop all our attempt at merging stuff here..
        -: 2513://   we could do better but it's going to be rare and probably not worth the hassle.
        -: 2514:// Columns for which the draw channel(s) haven't been merged with other will use their own ImDrawCmd.
        -: 2515://
        -: 2516:// This function is particularly tricky to understand.. take a breath.
function _ZN5ImGui22TableMergeDrawChannelsEP10ImGuiTable called 1077 returned 100% blocks executed 85%
     1077: 2517:void ImGui::TableMergeDrawChannels(ImGuiTable* table)
        -: 2518:{
     1077: 2519:    ImGuiContext& g = *GImGui;
     1077: 2520:    ImDrawListSplitter* splitter = table->DrawSplitter;
     1077: 2521:    const bool has_freeze_v = (table->FreezeRowsCount > 0);
     1077: 2522:    const bool has_freeze_h = (table->FreezeColumnsCount > 0);
    1077*: 2523:    IM_ASSERT(splitter->_Current == 0);
     1077: 2523-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 2523-block 3
call    2 never executed
        -: 2524:
        -: 2525:    // Track which groups we are going to attempt to merge, and which channels goes into each group.
        -: 2526:    struct MergeGroup
        -: 2527:    {
        -: 2528:        ImRect          ClipRect;
        -: 2529:        int             ChannelsCount = 0;
        -: 2530:        ImBitArrayPtr   ChannelsMask = NULL;
        -: 2531:    };
     1077: 2532:    int merge_group_mask = 0x00;
     1077: 2533:    MergeGroup merge_groups[4];
        -: 2534:
        -: 2535:    // Use a reusable temp buffer for the merge masks as they are dynamically sized.
     1077: 2536:    const int max_draw_channels = (4 + table->ColumnsCount * 2);
     1077: 2537:    const int size_for_masks_bitarrays_one = (int)ImBitArrayGetStorageSizeInBytes(max_draw_channels);
     1077: 2537-block 4
call    0 returned 1077
     1077: 2538:    g.TempBuffer.reserve(size_for_masks_bitarrays_one * 5);
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077: 2539:    memset(g.TempBuffer.Data, 0, size_for_masks_bitarrays_one * 5);
     5385: 2540:    for (int n = 0; n < IM_ARRAYSIZE(merge_groups); n++)
     1077: 2540-block 6
     5385: 2540-block 8
branch  0 taken 4308
branch  1 taken 1077 (fallthrough)
     4308: 2541:        merge_groups[n].ChannelsMask = (ImBitArrayPtr)(void*)(g.TempBuffer.Data + (size_for_masks_bitarrays_one * n));
     4308: 2541-block 7
     1077: 2542:    ImBitArrayPtr remaining_mask = (ImBitArrayPtr)(void*)(g.TempBuffer.Data + (size_for_masks_bitarrays_one * 4));
        -: 2543:
        -: 2544:    // 1. Scan channels and take note of those which can be merged
     5385: 2545:    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
     1077: 2545-block 9
     4308: 2545-block 61
     5385: 2545-block 62
branch  0 taken 4308
branch  1 taken 1077 (fallthrough)
        -: 2546:    {
     4308: 2547:        if (!IM_BITARRAY_TESTBIT(table->VisibleMaskByIndex, column_n))
     4308: 2547-block 10
branch  0 taken 3 (fallthrough)
branch  1 taken 4305
        3: 2548:            continue;
        3: 2548-block 11
     4305: 2549:        ImGuiTableColumn* column = &table->Columns[column_n];
     4305: 2549-block 12
call    0 returned 4305
        -: 2550:
    4305*: 2551:        const int merge_group_sub_count = has_freeze_v ? 2 : 1;
branch  0 taken 0 (fallthrough)
branch  1 taken 4305
    %%%%%: 2551-block 14
     4305: 2551-block 15
     8610: 2552:        for (int merge_group_sub_n = 0; merge_group_sub_n < merge_group_sub_count; merge_group_sub_n++)
     4305: 2552-block 16
     4305: 2552-block 58
     8610: 2552-block 59
branch  0 taken 4305
branch  1 taken 4305 (fallthrough)
        -: 2553:        {
    4305*: 2554:            const int channel_no = (merge_group_sub_n == 0) ? column->DrawChannelFrozen : column->DrawChannelUnfrozen;
     4305: 2554-block 17
branch  0 taken 4305 (fallthrough)
branch  1 taken 0
     4305: 2554-block 18
    %%%%%: 2554-block 19
        -: 2555:
        -: 2556:            // Don't attempt to merge if there are multiple draw calls within the column
     4305: 2557:            ImDrawChannel* src_channel = &splitter->_Channels[channel_no];
     4305: 2557-block 20
call    0 returned 4305
     4305: 2558:            if (src_channel->_CmdBuffer.Size > 0 && src_channel->_CmdBuffer.back().ElemCount == 0 && src_channel->_CmdBuffer.back().UserCallback == NULL) // Equivalent of PopUnusedDrawCmd()
branch  0 taken 4305 (fallthrough)
branch  1 taken 0
     4305: 2558-block 22
call    2 returned 4305
branch  3 taken 1 (fallthrough)
branch  4 taken 4304
        1: 2558-block 24
call    5 returned 1
branch  6 taken 1 (fallthrough)
branch  7 taken 0
        1: 2558-block 26
     4304: 2558-block 27
     4305: 2558-block 28
branch  8 taken 1 (fallthrough)
branch  9 taken 4304
        1: 2559:                src_channel->_CmdBuffer.pop_back();
        1: 2559-block 29
call    0 returned 1
     4305: 2560:            if (src_channel->_CmdBuffer.Size != 1)
     4305: 2560-block 30
branch  0 taken 1 (fallthrough)
branch  1 taken 4304
        1: 2561:                continue;
        1: 2561-block 31
        -: 2562:
        -: 2563:            // Find out the width of this merge group and check if it will fit in our column
        -: 2564:            // (note that we assume that rendering didn't stray on the left direction. we should need a CursorMinPos to detect it)
     4304: 2565:            if (!(column->Flags & ImGuiTableColumnFlags_NoClip))
     4304: 2565-block 32
branch  0 taken 4304 (fallthrough)
branch  1 taken 0
        -: 2566:            {
        -: 2567:                float content_max_x;
     4304: 2568:                if (!has_freeze_v)
     4304: 2568-block 33
branch  0 taken 4304 (fallthrough)
branch  1 taken 0
     4304: 2569:                    content_max_x = ImMax(column->ContentMaxXUnfrozen, column->ContentMaxXHeadersUsed); // No row freeze
     4304: 2569-block 34
call    0 returned 4304
    #####: 2570:                else if (merge_group_sub_n == 0)
    %%%%%: 2570-block 35
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2571:                    content_max_x = ImMax(column->ContentMaxXFrozen, column->ContentMaxXHeadersUsed);   // Row freeze: use width before freeze
    %%%%%: 2571-block 36
call    0 never executed
        -: 2572:                else
    #####: 2573:                    content_max_x = column->ContentMaxXUnfrozen;                                        // Row freeze: use width after freeze
    %%%%%: 2573-block 37
     4304: 2574:                if (content_max_x > column->ClipRect.Max.x)
     4304: 2574-block 38
branch  0 taken 2152 (fallthrough)
branch  1 taken 2152
     2152: 2575:                    continue;
     2152: 2575-block 39
        -: 2576:            }
        -: 2577:
    2152*: 2578:            const int merge_group_n = (has_freeze_h && column_n < table->FreezeColumnsCount ? 0 : 1) + (has_freeze_v && merge_group_sub_n == 0 ? 0 : 2);
     2152: 2578-block 40
branch  0 taken 0 (fallthrough)
branch  1 taken 2152
    %%%%%: 2578-block 41
branch  2 never executed (fallthrough)
branch  3 never executed
     2152: 2578-block 42
    %%%%%: 2578-block 43
     2152: 2578-block 44
branch  4 taken 0 (fallthrough)
branch  5 taken 2152
    %%%%%: 2578-block 45
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 2578-block 46
     2152: 2578-block 47
    2152*: 2579:            IM_ASSERT(channel_no < max_draw_channels);
     2152: 2579-block 48
branch  0 taken 0 (fallthrough)
branch  1 taken 2152
    %%%%%: 2579-block 49
call    2 never executed
     2152: 2580:            MergeGroup* merge_group = &merge_groups[merge_group_n];
     2152: 2581:            if (merge_group->ChannelsCount == 0)
     2152: 2581-block 50
branch  0 taken 1076 (fallthrough)
branch  1 taken 1076
     1076: 2582:                merge_group->ClipRect = ImRect(+FLT_MAX, +FLT_MAX, -FLT_MAX, -FLT_MAX);
     1076: 2582-block 51
call    0 returned 1076
     2152: 2583:            ImBitArraySetBit(merge_group->ChannelsMask, channel_no);
     2152: 2583-block 53
call    0 returned 2152
     2152: 2584:            merge_group->ChannelsCount++;
     2152: 2585:            merge_group->ClipRect.Add(src_channel->_CmdBuffer[0].ClipRect);
call    0 returned 2152
call    1 returned 2152
call    2 returned 2152
     2152: 2586:            merge_group_mask |= (1 << merge_group_n);
        -: 2587:        }
        -: 2588:
        -: 2589:        // Invalidate current draw channel
        -: 2590:        // (we don't clear DrawChannelFrozen/DrawChannelUnfrozen solely to facilitate debugging/later inspection of data)
     4305: 2591:        column->DrawChannelCurrent = (ImGuiTableDrawChannelIdx)-1;
     4305: 2591-block 60
        -: 2592:    }
        -: 2593:
        -: 2594:    // [DEBUG] Display merge groups
        -: 2595:#if 0
        -: 2596:    if (g.IO.KeyShift)
        -: 2597:        for (int merge_group_n = 0; merge_group_n < IM_ARRAYSIZE(merge_groups); merge_group_n++)
        -: 2598:        {
        -: 2599:            MergeGroup* merge_group = &merge_groups[merge_group_n];
        -: 2600:            if (merge_group->ChannelsCount == 0)
        -: 2601:                continue;
        -: 2602:            char buf[32];
        -: 2603:            ImFormatString(buf, 32, "MG%d:%d", merge_group_n, merge_group->ChannelsCount);
        -: 2604:            ImVec2 text_pos = merge_group->ClipRect.Min + ImVec2(4, 4);
        -: 2605:            ImVec2 text_size = CalcTextSize(buf, NULL);
        -: 2606:            GetForegroundDrawList()->AddRectFilled(text_pos, text_pos + text_size, IM_COL32(0, 0, 0, 255));
        -: 2607:            GetForegroundDrawList()->AddText(text_pos, IM_COL32(255, 255, 0, 255), buf, NULL);
        -: 2608:            GetForegroundDrawList()->AddRect(merge_group->ClipRect.Min, merge_group->ClipRect.Max, IM_COL32(255, 255, 0, 255));
        -: 2609:        }
        -: 2610:#endif
        -: 2611:
        -: 2612:    // 2. Rewrite channel list in our preferred order
     1077: 2613:    if (merge_group_mask != 0)
     1077: 2613-block 63
branch  0 taken 1076 (fallthrough)
branch  1 taken 1
        -: 2614:    {
        -: 2615:        // We skip channel 0 (Bg0/Bg1) and 1 (Bg2 frozen) from the shuffling since they won't move - see channels allocation in TableSetupDrawChannels().
     1076: 2616:        const int LEADING_DRAW_CHANNELS = 2;
     1076: 2617:        g.DrawChannelsTempMergeBuffer.resize(splitter->_Count - LEADING_DRAW_CHANNELS); // Use shared temporary storage so the allocation gets amortized
     1076: 2617-block 64
call    0 returned 1076
branch  1 taken 1076 (fallthrough)
branch  2 taken 0 (throw)
     1076: 2618:        ImDrawChannel* dst_tmp = g.DrawChannelsTempMergeBuffer.Data;
     1076: 2619:        ImBitArraySetBitRange(remaining_mask, LEADING_DRAW_CHANNELS, splitter->_Count);
     1076: 2619-block 65
call    0 returned 1076
     1076: 2620:        ImBitArrayClearBit(remaining_mask, table->Bg2DrawChannelUnfrozen);
call    0 returned 1076
    1076*: 2621:        IM_ASSERT(has_freeze_v == false || table->Bg2DrawChannelUnfrozen != TABLE_DRAW_CHANNEL_BG2_FROZEN);
branch  0 taken 0 (fallthrough)
branch  1 taken 1076
    %%%%%: 2621-block 68
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2621-block 69
call    4 never executed
    1076*: 2622:        int remaining_count = splitter->_Count - (has_freeze_v ? LEADING_DRAW_CHANNELS + 1 : LEADING_DRAW_CHANNELS);
     1076: 2622-block 70
branch  0 taken 0 (fallthrough)
branch  1 taken 1076
    %%%%%: 2622-block 71
     1076: 2622-block 72
        -: 2623:        //ImRect host_rect = (table->InnerWindow == table->OuterWindow) ? table->InnerClipRect : table->HostClipRect;
     1076: 2624:        ImRect host_rect = table->HostClipRect;
     5380: 2625:        for (int merge_group_n = 0; merge_group_n < IM_ARRAYSIZE(merge_groups); merge_group_n++)
     1076: 2625-block 73
     4304: 2625-block 115
     5380: 2625-block 116
branch  0 taken 4304
branch  1 taken 1076 (fallthrough)
        -: 2626:        {
     4304: 2627:            if (int merge_channels_count = merge_groups[merge_group_n].ChannelsCount)
     4304: 2627-block 74
branch  0 taken 1076 (fallthrough)
branch  1 taken 3228
        -: 2628:            {
     1076: 2629:                MergeGroup* merge_group = &merge_groups[merge_group_n];
     1076: 2630:                ImRect merge_clip_rect = merge_group->ClipRect;
        -: 2631:
        -: 2632:                // Extend outer-most clip limits to match those of host, so draw calls can be merged even if
        -: 2633:                // outer-most columns have some outer padding offsetting them from their parent ClipRect.
        -: 2634:                // The principal cases this is dealing with are:
        -: 2635:                // - On a same-window table (not scrolling = single group), all fitting columns ClipRect -> will extend and match host ClipRect -> will merge
        -: 2636:                // - Columns can use padding and have left-most ClipRect.Min.x and right-most ClipRect.Max.x != from host ClipRect -> will extend and match host ClipRect -> will merge
        -: 2637:                // FIXME-TABLE FIXME-WORKRECT: We are wasting a merge opportunity on tables without scrolling if column doesn't fit
        -: 2638:                // within host clip rect, solely because of the half-padding difference between window->WorkRect and window->InnerClipRect.
     1076: 2639:                if ((merge_group_n & 1) == 0 || !has_freeze_h)
     1076: 2639-block 75
branch  0 taken 1076 (fallthrough)
branch  1 taken 0
     1076: 2639-block 76
branch  2 taken 1076 (fallthrough)
branch  3 taken 0
     1076: 2640:                    merge_clip_rect.Min.x = ImMin(merge_clip_rect.Min.x, host_rect.Min.x);
     1076: 2640-block 77
call    0 returned 1076
     1076: 2641:                if ((merge_group_n & 2) == 0 || !has_freeze_v)
     1076: 2641-block 79
branch  0 taken 1076 (fallthrough)
branch  1 taken 0
     1076: 2641-block 80
branch  2 taken 1076 (fallthrough)
branch  3 taken 0
     1076: 2642:                    merge_clip_rect.Min.y = ImMin(merge_clip_rect.Min.y, host_rect.Min.y);
     1076: 2642-block 81
call    0 returned 1076
     1076: 2643:                if ((merge_group_n & 1) != 0)
     1076: 2643-block 83
branch  0 taken 1076 (fallthrough)
branch  1 taken 0
     1076: 2644:                    merge_clip_rect.Max.x = ImMax(merge_clip_rect.Max.x, host_rect.Max.x);
     1076: 2644-block 84
call    0 returned 1076
     1076: 2645:                if ((merge_group_n & 2) != 0 && (table->Flags & ImGuiTableFlags_NoHostExtendY) == 0)
     1076: 2645-block 86
branch  0 taken 1076 (fallthrough)
branch  1 taken 0
     1076: 2645-block 87
branch  2 taken 1076 (fallthrough)
branch  3 taken 0
     1076: 2646:                    merge_clip_rect.Max.y = ImMax(merge_clip_rect.Max.y, host_rect.Max.y);
     1076: 2646-block 88
call    0 returned 1076
        -: 2647:                //GetForegroundDrawList()->AddRect(merge_group->ClipRect.Min, merge_group->ClipRect.Max, IM_COL32(255, 0, 0, 200), 0.0f, 0, 1.0f); // [DEBUG]
        -: 2648:                //GetForegroundDrawList()->AddLine(merge_group->ClipRect.Min, merge_clip_rect.Min, IM_COL32(255, 100, 0, 200));
        -: 2649:                //GetForegroundDrawList()->AddLine(merge_group->ClipRect.Max, merge_clip_rect.Max, IM_COL32(255, 100, 0, 200));
     1076: 2650:                remaining_count -= merge_group->ChannelsCount;
     2152: 2651:                for (int n = 0; n < (size_for_masks_bitarrays_one >> 2); n++)
     1076: 2651-block 90
     2152: 2651-block 92
branch  0 taken 1076
branch  1 taken 1076 (fallthrough)
     1076: 2652:                    remaining_mask[n] &= ~merge_group->ChannelsMask[n];
     1076: 2652-block 91
     7532: 2653:                for (int n = 0; n < splitter->_Count && merge_channels_count != 0; n++)
     1076: 2653-block 93
     6456: 2653-block 107
     7532: 2653-block 108
branch  0 taken 6456 (fallthrough)
branch  1 taken 1076
     6456: 2653-block 109
branch  2 taken 6456
branch  3 taken 0 (fallthrough)
        -: 2654:                {
        -: 2655:                    // Copy + overwrite new clip rect
     6456: 2656:                    if (!IM_BITARRAY_TESTBIT(merge_group->ChannelsMask, n))
     6456: 2656-block 94
branch  0 taken 4304 (fallthrough)
branch  1 taken 2152
     4304: 2657:                        continue;
     4304: 2657-block 95
     2152: 2658:                    IM_BITARRAY_CLEARBIT(merge_group->ChannelsMask, n);
     2152: 2659:                    merge_channels_count--;
        -: 2660:
     2152: 2661:                    ImDrawChannel* channel = &splitter->_Channels[n];
     2152: 2661-block 96
call    0 returned 2152
    2152*: 2662:                    IM_ASSERT(channel->_CmdBuffer.Size == 1 && merge_clip_rect.Contains(ImRect(channel->_CmdBuffer[0].ClipRect)));
branch  0 taken 2152 (fallthrough)
branch  1 taken 0
     2152: 2662-block 98
call    2 returned 2152
call    3 returned 2152
call    4 returned 2152
branch  5 taken 2152 (fallthrough)
branch  6 taken 0
     2152: 2662-block 102
    %%%%%: 2662-block 103
call    7 never executed
     2152: 2663:                    channel->_CmdBuffer[0].ClipRect = merge_clip_rect.ToVec4();
     2152: 2663-block 104
call    0 returned 2152
call    1 returned 2152
     2152: 2664:                    memcpy(dst_tmp++, channel, sizeof(ImDrawChannel));
        -: 2665:                }
        -: 2666:            }
        -: 2667:
        -: 2668:            // Make sure Bg2DrawChannelUnfrozen appears in the middle of our groups (whereas Bg0/Bg1 and Bg2 frozen are fixed to 0 and 1)
     4304: 2669:            if (merge_group_n == 1 && has_freeze_v)
     4304: 2669-block 111
branch  0 taken 1076 (fallthrough)
branch  1 taken 3228
     1076: 2669-block 112
branch  2 taken 0 (fallthrough)
branch  3 taken 1076
    #####: 2670:                memcpy(dst_tmp++, &splitter->_Channels[table->Bg2DrawChannelUnfrozen], sizeof(ImDrawChannel));
    %%%%%: 2670-block 113
call    0 never executed
        -: 2671:        }
        -: 2672:
        -: 2673:        // Append unmergeable channels that we didn't reorder at the end of the list
     6456: 2674:        for (int n = 0; n < splitter->_Count && remaining_count != 0; n++)
     1076: 2674-block 117
     5380: 2674-block 122
     6456: 2674-block 123
branch  0 taken 6456 (fallthrough)
branch  1 taken 0
     6456: 2674-block 124
branch  2 taken 5380
branch  3 taken 1076 (fallthrough)
        -: 2675:        {
     5380: 2676:            if (!IM_BITARRAY_TESTBIT(remaining_mask, n))
     5380: 2676-block 118
branch  0 taken 3228 (fallthrough)
branch  1 taken 2152
     3228: 2677:                continue;
     3228: 2677-block 119
     2152: 2678:            ImDrawChannel* channel = &splitter->_Channels[n];
     2152: 2678-block 120
call    0 returned 2152
     2152: 2679:            memcpy(dst_tmp++, channel, sizeof(ImDrawChannel));
     2152: 2680:            remaining_count--;
        -: 2681:        }
    1076*: 2682:        IM_ASSERT(dst_tmp == g.DrawChannelsTempMergeBuffer.Data + g.DrawChannelsTempMergeBuffer.Size);
     1076: 2682-block 125
branch  0 taken 0 (fallthrough)
branch  1 taken 1076
    %%%%%: 2682-block 126
call    2 never executed
     1076: 2683:        memcpy(splitter->_Channels.Data + LEADING_DRAW_CHANNELS, g.DrawChannelsTempMergeBuffer.Data, (splitter->_Count - LEADING_DRAW_CHANNELS) * sizeof(ImDrawChannel));
     1076: 2683-block 127
        -: 2684:    }
     1077: 2685:}
     1077: 2685-block 128
        -: 2686:
function _ZL23TableGetColumnBorderColP10ImGuiTableii called 3228 returned 100% blocks executed 50%
     3228: 2687:static ImU32 TableGetColumnBorderCol(ImGuiTable* table, int order_n, int column_n)
        -: 2688:{
     3228: 2689:    const bool is_hovered = (table->HoveredColumnBorder == column_n);
    3228*: 2690:    const bool is_resized = (table->ResizedColumn == column_n) && (table->InstanceInteracted == table->InstanceCurrent);
     3228: 2690-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 3228
    %%%%%: 2690-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2690-block 4
     3228: 2690-block 5
     3228: 2691:    const bool is_frozen_separator = (table->FreezeColumnsCount == order_n + 1);
     3228: 2692:    if (is_resized || is_hovered)
     3228: 2692-block 6
branch  0 taken 3228 (fallthrough)
branch  1 taken 0
     3228: 2692-block 7
branch  2 taken 0 (fallthrough)
branch  3 taken 3228
    #####: 2693:        return ImGui::GetColorU32(is_resized ? ImGuiCol_SeparatorActive : ImGuiCol_SeparatorHovered);
    %%%%%: 2693-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2693-block 9
    %%%%%: 2693-block 10
    %%%%%: 2693-block 11
call    2 never executed
     3228: 2694:    if (is_frozen_separator || (table->Flags & (ImGuiTableFlags_NoBordersInBody | ImGuiTableFlags_NoBordersInBodyUntilResize)))
     3228: 2694-block 13
branch  0 taken 3228 (fallthrough)
branch  1 taken 0
     3228: 2694-block 14
branch  2 taken 0 (fallthrough)
branch  3 taken 3228
    #####: 2695:        return table->BorderColorStrong;
    %%%%%: 2695-block 15
     3228: 2696:    return table->BorderColorLight;
     3228: 2696-block 16
        -: 2697:}
        -: 2698:
        -: 2699:// FIXME-TABLE: This is a mess, need to redesign how we render borders (as some are also done in TableEndRow)
function _ZN5ImGui16TableDrawBordersEP10ImGuiTable called 1077 returned 100% blocks executed 58%
     1077: 2700:void ImGui::TableDrawBorders(ImGuiTable* table)
        -: 2701:{
     1077: 2702:    ImGuiWindow* inner_window = table->InnerWindow;
     1077: 2703:    if (!table->OuterWindow->ClipRect.Overlaps(table->OuterRect))
     1077: 2703-block 2
call    0 returned 1077
branch  1 taken 0 (fallthrough)
branch  2 taken 1077
    #####: 2704:        return;
    %%%%%: 2704-block 4
        -: 2705:
     1077: 2706:    ImDrawList* inner_drawlist = inner_window->DrawList;
     1077: 2707:    table->DrawSplitter->SetCurrentChannel(inner_drawlist, TABLE_DRAW_CHANNEL_BG0);
     1077: 2707-block 5
call    0 returned 1077
     1077: 2708:    inner_drawlist->PushClipRect(table->Bg0ClipRectForDrawCmd.Min, table->Bg0ClipRectForDrawCmd.Max, false);
call    0 returned 1077
        -: 2709:
        -: 2710:    // Draw inner border and resizing feedback
     1077: 2711:    ImGuiTableInstanceData* table_instance = TableGetInstanceData(table, table->InstanceCurrent);
call    0 returned 1077
     1077: 2712:    const float border_size = TABLE_BORDER_SIZE;
    1077*: 2713:    const float draw_y1 = ImMax(table->InnerRect.Min.y, (table->FreezeRowsCount >= 1 ? table->InnerRect.Min.y : table->WorkRect.Min.y) + table->AngledHeadersHeight) + ((table->Flags & ImGuiTableFlags_BordersOuterH) ? 1.0f : 0.0f);
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 2713-block 9
     1077: 2713-block 10
     1077: 2713-block 11
call    2 returned 1077
branch  3 taken 1077 (fallthrough)
branch  4 taken 0
     1077: 2713-block 13
    %%%%%: 2713-block 14
     1077: 2714:    const float draw_y2_body = table->InnerRect.Max.y;
    1077*: 2715:    const float draw_y2_head = table->IsUsingHeaders ? ImMin(table->InnerRect.Max.y, (table->FreezeRowsCount >= 1 ? table->InnerRect.Min.y : table->WorkRect.Min.y) + table_instance->LastTopHeadersRowHeight) : draw_y1;
     1077: 2715-block 15
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 2715-block 16
branch  2 taken 0 (fallthrough)
branch  3 taken 1077
    %%%%%: 2715-block 17
     1077: 2715-block 18
     1077: 2715-block 19
call    4 returned 1077
    %%%%%: 2715-block 20
     1077: 2716:    if (table->Flags & ImGuiTableFlags_BordersInnerV)
     1077: 2716-block 21
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
        -: 2717:    {
     5385: 2718:        for (int order_n = 0; order_n < table->ColumnsCount; order_n++)
     1077: 2718-block 22
     4308: 2718-block 53
     5385: 2718-block 54
branch  0 taken 4308
branch  1 taken 1077 (fallthrough)
        -: 2719:        {
    4308*: 2720:            if (!IM_BITARRAY_TESTBIT(table->EnabledMaskByDisplayOrder, order_n))
     4308: 2720-block 23
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
    #####: 2721:                continue;
    %%%%%: 2721-block 24
        -: 2722:
     4308: 2723:            const int column_n = table->DisplayOrderToIndex[order_n];
     4308: 2723-block 25
call    0 returned 4308
     4308: 2724:            ImGuiTableColumn* column = &table->Columns[column_n];
call    0 returned 4308
     4308: 2725:            const bool is_hovered = (table->HoveredColumnBorder == column_n);
    4308*: 2726:            const bool is_resized = (table->ResizedColumn == column_n) && (table->InstanceInteracted == table->InstanceCurrent);
branch  0 taken 0 (fallthrough)
branch  1 taken 4308
    %%%%%: 2726-block 28
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2726-block 29
     4308: 2726-block 30
     4308: 2727:            const bool is_resizable = (column->Flags & (ImGuiTableColumnFlags_NoResize | ImGuiTableColumnFlags_NoDirectResize_)) == 0;
     4308: 2728:            const bool is_frozen_separator = (table->FreezeColumnsCount == order_n + 1);
     4308: 2729:            if (column->MaxX > table->InnerClipRect.Max.x && !is_resized)
     4308: 2729-block 31
branch  0 taken 4 (fallthrough)
branch  1 taken 4304
        4: 2729-block 32
branch  2 taken 4 (fallthrough)
branch  3 taken 0
        4: 2730:                continue;
        4: 2730-block 33
        -: 2731:
        -: 2732:            // Decide whether right-most column is visible
     4304: 2733:            if (column->NextEnabledColumn == -1 && !is_resizable)
     4304: 2733-block 34
branch  0 taken 1076 (fallthrough)
branch  1 taken 3228
     1076: 2733-block 35
branch  2 taken 1076 (fallthrough)
branch  3 taken 0
    1076*: 2734:                if ((table->Flags & ImGuiTableFlags_SizingMask_) != ImGuiTableFlags_SizingFixedSame || (table->Flags & ImGuiTableFlags_NoHostExtendX))
     1076: 2734-block 36
branch  0 taken 0 (fallthrough)
branch  1 taken 1076
    %%%%%: 2734-block 37
branch  2 never executed (fallthrough)
branch  3 never executed
     1076: 2735:                    continue;
     1076: 2735-block 38
    3228*: 2736:            if (column->MaxX <= column->ClipRect.Min.x) // FIXME-TABLE FIXME-STYLE: Assume BorderSize==1, this is problematic if we want to increase the border size..
     3228: 2736-block 39
branch  0 taken 0 (fallthrough)
branch  1 taken 3228
    #####: 2737:                continue;
    %%%%%: 2737-block 40
        -: 2738:
        -: 2739:            // Draw in outer window so right-most column won't be clipped
        -: 2740:            // Always draw full height border when being resized/hovered, or on the delimitation of frozen column scrolling.
    3228*: 2741:            float draw_y2 = (is_hovered || is_resized || is_frozen_separator || (table->Flags & (ImGuiTableFlags_NoBordersInBody | ImGuiTableFlags_NoBordersInBodyUntilResize)) == 0) ? draw_y2_body : draw_y2_head;
     3228: 2741-block 41
branch  0 taken 3228 (fallthrough)
branch  1 taken 0
     3228: 2741-block 42
branch  2 taken 3228 (fallthrough)
branch  3 taken 0
     3228: 2741-block 43
branch  4 taken 3228 (fallthrough)
branch  5 taken 0
     3228: 2741-block 44
branch  6 taken 3228 (fallthrough)
branch  7 taken 0
     3228: 2741-block 45
    %%%%%: 2741-block 46
     3228: 2742:            if (draw_y2 > draw_y1)
     3228: 2742-block 47
branch  0 taken 3228 (fallthrough)
branch  1 taken 0
     3228: 2743:                inner_drawlist->AddLine(ImVec2(column->MaxX, draw_y1), ImVec2(column->MaxX, draw_y2), TableGetColumnBorderCol(table, order_n, column_n), border_size);
     3228: 2743-block 48
call    0 returned 3228
call    1 returned 3228
call    2 returned 3228
call    3 returned 3228
branch  4 taken 3228 (fallthrough)
branch  5 taken 0 (throw)
     3228: 2743-block 52
    $$$$$: 2743-block 81
    $$$$$: 2743-block 82
call    6 never executed
        -: 2744:        }
        -: 2745:    }
        -: 2746:
        -: 2747:    // Draw outer border
        -: 2748:    // FIXME: could use AddRect or explicit VLine/HLine helper?
     1077: 2749:    if (table->Flags & ImGuiTableFlags_BordersOuter)
     1077: 2749-block 55
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
        -: 2750:    {
        -: 2751:        // Display outer border offset by 1 which is a simple way to display it without adding an extra draw call
        -: 2752:        // (Without the offset, in outer_window it would be rendered behind cells, because child windows are above their
        -: 2753:        // parent. In inner_window, it won't reach out over scrollbars. Another weird solution would be to display part
        -: 2754:        // of it in inner window, and the part that's over scrollbars in the outer window..)
        -: 2755:        // Either solution currently won't allow us to use a larger border size: the border would clipped.
     1077: 2756:        const ImRect outer_border = table->OuterRect;
     1077: 2757:        const ImU32 outer_col = table->BorderColorStrong;
     1077: 2758:        if ((table->Flags & ImGuiTableFlags_BordersOuter) == ImGuiTableFlags_BordersOuter)
     1077: 2758-block 56
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
        -: 2759:        {
     1077: 2760:            inner_drawlist->AddRect(outer_border.Min, outer_border.Max, outer_col, 0.0f, 0, border_size);
     1077: 2760-block 57
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -: 2761:        }
    #####: 2762:        else if (table->Flags & ImGuiTableFlags_BordersOuterV)
    %%%%%: 2762-block 58
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2763:        {
    #####: 2764:            inner_drawlist->AddLine(outer_border.Min, ImVec2(outer_border.Min.x, outer_border.Max.y), outer_col, border_size);
    %%%%%: 2764-block 59
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$: 2764-block 83
    #####: 2765:            inner_drawlist->AddLine(ImVec2(outer_border.Max.x, outer_border.Min.y), outer_border.Max, outer_col, border_size);
    %%%%%: 2765-block 61
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 2765-block 63
    $$$$$: 2765-block 84
        -: 2766:        }
    #####: 2767:        else if (table->Flags & ImGuiTableFlags_BordersOuterH)
    %%%%%: 2767-block 64
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2768:        {
    #####: 2769:            inner_drawlist->AddLine(outer_border.Min, ImVec2(outer_border.Max.x, outer_border.Min.y), outer_col, border_size);
    %%%%%: 2769-block 65
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$: 2769-block 85
    #####: 2770:            inner_drawlist->AddLine(ImVec2(outer_border.Min.x, outer_border.Max.y), outer_border.Max, outer_col, border_size);
    %%%%%: 2770-block 67
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 2770-block 69
    $$$$$: 2770-block 86
        -: 2771:        }
        -: 2772:    }
     1077: 2773:    if ((table->Flags & ImGuiTableFlags_BordersInnerH) && table->RowPosY2 < table->OuterRect.Max.y)
     1077: 2773-block 71
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 2773-block 72
branch  2 taken 0 (fallthrough)
branch  3 taken 1077
        -: 2774:    {
        -: 2775:        // Draw bottom-most row border between it is above outer border.
    #####: 2776:        const float border_y = table->RowPosY2;
    #####: 2777:        if (border_y >= table->BgClipRect.Min.y && border_y < table->BgClipRect.Max.y)
    %%%%%: 2777-block 73
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2777-block 74
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2778:            inner_drawlist->AddLine(ImVec2(table->BorderX1, border_y), ImVec2(table->BorderX2, border_y), table->BorderColorLight, border_size);
    %%%%%: 2778-block 75
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 2778-block 78
    $$$$$: 2778-block 88
        -: 2779:    }
        -: 2780:
     1077: 2781:    inner_drawlist->PopClipRect();
     1077: 2781-block 79
call    0 returned 1077
        -: 2782:}
        -: 2783:
        -: 2784://-------------------------------------------------------------------------
        -: 2785:// [SECTION] Tables: Sorting
        -: 2786://-------------------------------------------------------------------------
        -: 2787:// - TableGetSortSpecs()
        -: 2788:// - TableFixColumnSortDirection() [Internal]
        -: 2789:// - TableGetColumnNextSortDirection() [Internal]
        -: 2790:// - TableSetColumnSortDirection() [Internal]
        -: 2791:// - TableSortSpecsSanitize() [Internal]
        -: 2792:// - TableSortSpecsBuild() [Internal]
        -: 2793://-------------------------------------------------------------------------
        -: 2794:
        -: 2795:// Return NULL if no sort specs (most often when ImGuiTableFlags_Sortable is not set)
        -: 2796:// When 'sort_specs->SpecsDirty == true' you should sort your data. It will be true when sorting specs have
        -: 2797:// changed since last call, or the first time. Make sure to set 'SpecsDirty = false' after sorting,
        -: 2798:// else you may wastefully sort your data every frame!
        -: 2799:// Lifetime: don't hold on this pointer over multiple frames or past any subsequent call to BeginTable()!
function _ZN5ImGui17TableGetSortSpecsEv called 0 returned 0% blocks executed 0%
    #####: 2800:ImGuiTableSortSpecs* ImGui::TableGetSortSpecs()
        -: 2801:{
    #####: 2802:    ImGuiContext& g = *GImGui;
    #####: 2803:    ImGuiTable* table = g.CurrentTable;
    #####: 2804:    IM_ASSERT(table != NULL);
    %%%%%: 2804-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2804-block 3
call    2 never executed
        -: 2805:
    #####: 2806:    if (!(table->Flags & ImGuiTableFlags_Sortable))
    %%%%%: 2806-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2807:        return NULL;
    %%%%%: 2807-block 5
        -: 2808:
        -: 2809:    // Require layout (in case TableHeadersRow() hasn't been called) as it may alter IsSortSpecsDirty in some paths.
    #####: 2810:    if (!table->IsLayoutLocked)
    %%%%%: 2810-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2811:        TableUpdateLayout(table);
    %%%%%: 2811-block 7
call    0 never executed
        -: 2812:
    #####: 2813:    TableSortSpecsBuild(table);
    %%%%%: 2813-block 8
call    0 never executed
    #####: 2814:    return &table->SortSpecs;
        -: 2815:}
        -: 2816:
function _ZL32TableGetColumnAvailSortDirectionP16ImGuiTableColumni called 0 returned 0% blocks executed 0%
    #####: 2817:static inline ImGuiSortDirection TableGetColumnAvailSortDirection(ImGuiTableColumn* column, int n)
        -: 2818:{
    #####: 2819:    IM_ASSERT(n < column->SortDirectionsAvailCount);
    %%%%%: 2819-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2819-block 3
call    2 never executed
    #####: 2820:    return (ImGuiSortDirection)((column->SortDirectionsAvailList >> (n << 1)) & 0x03);
    %%%%%: 2820-block 4
        -: 2821:}
        -: 2822:
        -: 2823:// Fix sort direction if currently set on a value which is unavailable (e.g. activating NoSortAscending/NoSortDescending)
function _ZN5ImGui27TableFixColumnSortDirectionEP10ImGuiTableP16ImGuiTableColumn called 0 returned 0% blocks executed 0%
    #####: 2824:void ImGui::TableFixColumnSortDirection(ImGuiTable* table, ImGuiTableColumn* column)
        -: 2825:{
    #####: 2826:    if (column->SortOrder == -1 || (column->SortDirectionsAvailMask & (1 << column->SortDirection)) != 0)
    %%%%%: 2826-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2826-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2827:        return;
    %%%%%: 2827-block 4
    #####: 2828:    column->SortDirection = (ImU8)TableGetColumnAvailSortDirection(column, 0);
    %%%%%: 2828-block 5
call    0 never executed
    #####: 2829:    table->IsSortSpecsDirty = true;
        -: 2830:}
        -: 2831:
        -: 2832:// Calculate next sort direction that would be set after clicking the column
        -: 2833:// - If the PreferSortDescending flag is set, we will default to a Descending direction on the first click.
        -: 2834:// - Note that the PreferSortAscending flag is never checked, it is essentially the default and therefore a no-op.
        -: 2835:IM_STATIC_ASSERT(ImGuiSortDirection_None == 0 && ImGuiSortDirection_Ascending == 1 && ImGuiSortDirection_Descending == 2);
function _ZN5ImGui31TableGetColumnNextSortDirectionEP16ImGuiTableColumn called 0 returned 0% blocks executed 0%
    #####: 2836:ImGuiSortDirection ImGui::TableGetColumnNextSortDirection(ImGuiTableColumn* column)
        -: 2837:{
    #####: 2838:    IM_ASSERT(column->SortDirectionsAvailCount > 0);
    %%%%%: 2838-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2838-block 3
call    2 never executed
    #####: 2839:    if (column->SortOrder == -1)
    %%%%%: 2839-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2840:        return TableGetColumnAvailSortDirection(column, 0);
    %%%%%: 2840-block 5
call    0 never executed
    #####: 2841:    for (int n = 0; n < 3; n++)
    %%%%%: 2841-block 6
    %%%%%: 2841-block 10
    %%%%%: 2841-block 11
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2842:        if (column->SortDirection == TableGetColumnAvailSortDirection(column, n))
    %%%%%: 2842-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 2843:            return TableGetColumnAvailSortDirection(column, (n + 1) % column->SortDirectionsAvailCount);
    %%%%%: 2843-block 9
call    0 never executed
    #####: 2844:    IM_ASSERT(0);
    %%%%%: 2844-block 12
call    0 never executed
        -: 2845:    return ImGuiSortDirection_None;
        -: 2846:}
        -: 2847:
        -: 2848:// Note that the NoSortAscending/NoSortDescending flags are processed in TableSortSpecsSanitize(), and they may change/revert
        -: 2849:// the value of SortDirection. We could technically also do it here but it would be unnecessary and duplicate code.
function _ZN5ImGui27TableSetColumnSortDirectionEi18ImGuiSortDirectionb called 0 returned 0% blocks executed 0%
    #####: 2850:void ImGui::TableSetColumnSortDirection(int column_n, ImGuiSortDirection sort_direction, bool append_to_sort_specs)
        -: 2851:{
    #####: 2852:    ImGuiContext& g = *GImGui;
    #####: 2853:    ImGuiTable* table = g.CurrentTable;
        -: 2854:
    #####: 2855:    if (!(table->Flags & ImGuiTableFlags_SortMulti))
    %%%%%: 2855-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2856:        append_to_sort_specs = false;
    %%%%%: 2856-block 3
    #####: 2857:    if (!(table->Flags & ImGuiTableFlags_SortTristate))
    %%%%%: 2857-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2858:        IM_ASSERT(sort_direction != ImGuiSortDirection_None);
    %%%%%: 2858-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2858-block 6
call    2 never executed
        -: 2859:
    #####: 2860:    ImGuiTableColumnIdx sort_order_max = 0;
    #####: 2861:    if (append_to_sort_specs)
    %%%%%: 2861-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2862:        for (int other_column_n = 0; other_column_n < table->ColumnsCount; other_column_n++)
    %%%%%: 2862-block 8
    %%%%%: 2862-block 12
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2863:            sort_order_max = ImMax(sort_order_max, table->Columns[other_column_n].SortOrder);
    %%%%%: 2863-block 9
call    0 never executed
call    1 never executed
        -: 2864:
    #####: 2865:    ImGuiTableColumn* column = &table->Columns[column_n];
    %%%%%: 2865-block 13
call    0 never executed
    #####: 2866:    column->SortDirection = (ImU8)sort_direction;
    #####: 2867:    if (column->SortDirection == ImGuiSortDirection_None)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2868:        column->SortOrder = -1;
    %%%%%: 2868-block 15
    #####: 2869:    else if (column->SortOrder == -1 || !append_to_sort_specs)
    %%%%%: 2869-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2869-block 17
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2870:        column->SortOrder = append_to_sort_specs ? sort_order_max + 1 : 0;
    %%%%%: 2870-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2870-block 19
    %%%%%: 2870-block 20
    %%%%%: 2870-block 21
        -: 2871:
    #####: 2872:    for (int other_column_n = 0; other_column_n < table->ColumnsCount; other_column_n++)
    %%%%%: 2872-block 22
    %%%%%: 2872-block 29
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 2873:    {
    #####: 2874:        ImGuiTableColumn* other_column = &table->Columns[other_column_n];
    %%%%%: 2874-block 23
call    0 never executed
    #####: 2875:        if (other_column != column && !append_to_sort_specs)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2875-block 25
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2876:            other_column->SortOrder = -1;
    %%%%%: 2876-block 26
    #####: 2877:        TableFixColumnSortDirection(table, other_column);
    %%%%%: 2877-block 27
call    0 never executed
        -: 2878:    }
    #####: 2879:    table->IsSettingsDirty = true;
    #####: 2880:    table->IsSortSpecsDirty = true;
    #####: 2881:}
        -: 2882:
function _ZN5ImGui22TableSortSpecsSanitizeEP10ImGuiTable called 0 returned 0% blocks executed 0%
    #####: 2883:void ImGui::TableSortSpecsSanitize(ImGuiTable* table)
        -: 2884:{
    #####: 2885:    IM_ASSERT(table->Flags & ImGuiTableFlags_Sortable);
    %%%%%: 2885-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2885-block 3
call    2 never executed
        -: 2886:
        -: 2887:    // Clear SortOrder from hidden column and verify that there's no gap or duplicate.
    #####: 2888:    int sort_order_count = 0;
    #####: 2889:    ImU64 sort_order_mask = 0x00;
    #####: 2890:    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
    %%%%%: 2890-block 4
    %%%%%: 2890-block 13
    %%%%%: 2890-block 14
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 2891:    {
    #####: 2892:        ImGuiTableColumn* column = &table->Columns[column_n];
    %%%%%: 2892-block 5
call    0 never executed
    #####: 2893:        if (column->SortOrder != -1 && !column->IsEnabled)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2893-block 7
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2894:            column->SortOrder = -1;
    %%%%%: 2894-block 8
    #####: 2895:        if (column->SortOrder == -1)
    %%%%%: 2895-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2896:            continue;
    %%%%%: 2896-block 10
    #####: 2897:        sort_order_count++;
    #####: 2898:        sort_order_mask |= ((ImU64)1 << column->SortOrder);
    #####: 2899:        IM_ASSERT(sort_order_count < (int)sizeof(sort_order_mask) * 8);
    %%%%%: 2899-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2899-block 12
call    2 never executed
        -: 2900:    }
        -: 2901:
    #####: 2902:    const bool need_fix_linearize = ((ImU64)1 << sort_order_count) != (sort_order_mask + 1);
    #####: 2903:    const bool need_fix_single_sort_order = (sort_order_count > 1) && !(table->Flags & ImGuiTableFlags_SortMulti);
    %%%%%: 2903-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2903-block 16
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2903-block 17
    %%%%%: 2903-block 18
    #####: 2904:    if (need_fix_linearize || need_fix_single_sort_order)
    %%%%%: 2904-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2904-block 20
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 2905:    {
    #####: 2906:        ImU64 fixed_mask = 0x00;
    #####: 2907:        for (int sort_n = 0; sort_n < sort_order_count; sort_n++)
    %%%%%: 2907-block 21
    %%%%%: 2907-block 50
    %%%%%: 2907-block 51
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 2908:        {
        -: 2909:            // Fix: Rewrite sort order fields if needed so they have no gap or duplicate.
        -: 2910:            // (e.g. SortOrder 0 disappeared, SortOrder 1..2 exists --> rewrite then as SortOrder 0..1)
    #####: 2911:            int column_with_smallest_sort_order = -1;
    #####: 2912:            for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
    %%%%%: 2912-block 22
    %%%%%: 2912-block 37
    %%%%%: 2912-block 38
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2913:                if ((fixed_mask & ((ImU64)1 << (ImU64)column_n)) == 0 && table->Columns[column_n].SortOrder != -1)
    %%%%%: 2913-block 23
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2913-block 24
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 2913-block 26
    %%%%%: 2913-block 27
    %%%%%: 2913-block 28
branch  5 never executed (fallthrough)
branch  6 never executed
    #####: 2914:                    if (column_with_smallest_sort_order == -1 || table->Columns[column_n].SortOrder < table->Columns[column_with_smallest_sort_order].SortOrder)
    %%%%%: 2914-block 29
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2914-block 30
call    2 never executed
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 2914-block 33
    %%%%%: 2914-block 34
    %%%%%: 2914-block 35
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 2915:                        column_with_smallest_sort_order = column_n;
    %%%%%: 2915-block 36
    #####: 2916:            IM_ASSERT(column_with_smallest_sort_order != -1);
    %%%%%: 2916-block 39
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2916-block 40
call    2 never executed
    #####: 2917:            fixed_mask |= ((ImU64)1 << column_with_smallest_sort_order);
    #####: 2918:            table->Columns[column_with_smallest_sort_order].SortOrder = (ImGuiTableColumnIdx)sort_n;
    %%%%%: 2918-block 41
call    0 never executed
        -: 2919:
        -: 2920:            // Fix: Make sure only one column has a SortOrder if ImGuiTableFlags_MultiSortable is not set.
    #####: 2921:            if (need_fix_single_sort_order)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2922:            {
    #####: 2923:                sort_order_count = 1;
    #####: 2924:                for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
    %%%%%: 2924-block 43
    %%%%%: 2924-block 47
    %%%%%: 2924-block 48
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2925:                    if (column_n != column_with_smallest_sort_order)
    %%%%%: 2925-block 44
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2926:                        table->Columns[column_n].SortOrder = -1;
    %%%%%: 2926-block 45
call    0 never executed
    #####: 2927:                break;
    %%%%%: 2927-block 49
        -: 2928:            }
        -: 2929:        }
        -: 2930:    }
        -: 2931:
        -: 2932:    // Fallback default sort order (if no column with the ImGuiTableColumnFlags_DefaultSort flag)
    #####: 2933:    if (sort_order_count == 0 && !(table->Flags & ImGuiTableFlags_SortTristate))
    %%%%%: 2933-block 52
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2933-block 53
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2934:        for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
    %%%%%: 2934-block 54
    %%%%%: 2934-block 60
    %%%%%: 2934-block 61
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 2935:        {
    #####: 2936:            ImGuiTableColumn* column = &table->Columns[column_n];
    %%%%%: 2936-block 55
call    0 never executed
    #####: 2937:            if (column->IsEnabled && !(column->Flags & ImGuiTableColumnFlags_NoSort))
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2937-block 57
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 2938:            {
    #####: 2939:                sort_order_count = 1;
    #####: 2940:                column->SortOrder = 0;
    #####: 2941:                column->SortDirection = (ImU8)TableGetColumnAvailSortDirection(column, 0);
    %%%%%: 2941-block 58
call    0 never executed
    #####: 2942:                break;
        -: 2943:            }
        -: 2944:        }
        -: 2945:
    #####: 2946:    table->SortSpecsCount = (ImGuiTableColumnIdx)sort_order_count;
    #####: 2947:}
        -: 2948:
function _ZN5ImGui19TableSortSpecsBuildEP10ImGuiTable called 0 returned 0% blocks executed 0%
    #####: 2949:void ImGui::TableSortSpecsBuild(ImGuiTable* table)
        -: 2950:{
    #####: 2951:    bool dirty = table->IsSortSpecsDirty;
    #####: 2952:    if (dirty)
    %%%%%: 2952-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2953:    {
    #####: 2954:        TableSortSpecsSanitize(table);
    %%%%%: 2954-block 3
call    0 never executed
    #####: 2955:        table->SortSpecsMulti.resize(table->SortSpecsCount <= 1 ? 0 : table->SortSpecsCount);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2955-block 5
    %%%%%: 2955-block 6
    %%%%%: 2955-block 7
call    2 never executed
    #####: 2956:        table->SortSpecs.SpecsDirty = true; // Mark as dirty for user
    #####: 2957:        table->IsSortSpecsDirty = false; // Mark as not dirty for us
        -: 2958:    }
        -: 2959:
        -: 2960:    // Write output
        -: 2961:    // May be able to move all SortSpecs data from table (48 bytes) to ImGuiTableTempData if we decide to write it back on every BeginTable()
    #####: 2962:    ImGuiTableColumnSortSpecs* sort_specs = (table->SortSpecsCount == 0) ? NULL : (table->SortSpecsCount == 1) ? &table->SortSpecsSingle : table->SortSpecsMulti.Data;
    %%%%%: 2962-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2962-block 10
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2962-block 11
    %%%%%: 2962-block 12
    %%%%%: 2962-block 13
    %%%%%: 2962-block 14
    #####: 2963:    if (dirty && sort_specs != NULL)
    %%%%%: 2963-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2963-block 16
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2964:        for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
    %%%%%: 2964-block 17
    %%%%%: 2964-block 24
    %%%%%: 2964-block 25
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 2965:        {
    #####: 2966:            ImGuiTableColumn* column = &table->Columns[column_n];
    %%%%%: 2966-block 18
call    0 never executed
    #####: 2967:            if (column->SortOrder == -1)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2968:                continue;
    %%%%%: 2968-block 20
    #####: 2969:            IM_ASSERT(column->SortOrder < table->SortSpecsCount);
    %%%%%: 2969-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2969-block 22
call    2 never executed
    #####: 2970:            ImGuiTableColumnSortSpecs* sort_spec = &sort_specs[column->SortOrder];
    #####: 2971:            sort_spec->ColumnUserID = column->UserID;
    #####: 2972:            sort_spec->ColumnIndex = (ImGuiTableColumnIdx)column_n;
    #####: 2973:            sort_spec->SortOrder = (ImGuiTableColumnIdx)column->SortOrder;
    #####: 2974:            sort_spec->SortDirection = (ImGuiSortDirection)column->SortDirection;
    %%%%%: 2974-block 23
        -: 2975:        }
        -: 2976:
    #####: 2977:    table->SortSpecs.Specs = sort_specs;
    #####: 2978:    table->SortSpecs.SpecsCount = table->SortSpecsCount;
    #####: 2979:}
        -: 2980:
        -: 2981://-------------------------------------------------------------------------
        -: 2982:// [SECTION] Tables: Headers
        -: 2983://-------------------------------------------------------------------------
        -: 2984:// - TableGetHeaderRowHeight() [Internal]
        -: 2985:// - TableGetHeaderAngledMaxLabelWidth() [Internal]
        -: 2986:// - TableHeadersRow()
        -: 2987:// - TableHeader()
        -: 2988:// - TableAngledHeadersRow()
        -: 2989:// - TableAngledHeadersRowEx() [Internal]
        -: 2990://-------------------------------------------------------------------------
        -: 2991:
function _ZN5ImGui23TableGetHeaderRowHeightEv called 1077 returned 100% blocks executed 100%
     1077: 2992:float ImGui::TableGetHeaderRowHeight()
        -: 2993:{
        -: 2994:    // Caring for a minor edge case:
        -: 2995:    // Calculate row height, for the unlikely case that some labels may be taller than others.
        -: 2996:    // If we didn't do that, uneven header height would highlight but smaller one before the tallest wouldn't catch input for all height.
        -: 2997:    // In your custom header row you may omit this all together and just call TableNextRow() without a height...
     1077: 2998:    ImGuiContext& g = *GImGui;
     1077: 2999:    ImGuiTable* table = g.CurrentTable;
     1077: 3000:    float row_height = g.FontSize;
     5385: 3001:    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
     1077: 3001-block 2
     4308: 3001-block 9
     5385: 3001-block 10
branch  0 taken 4308
branch  1 taken 1077 (fallthrough)
     4308: 3002:        if (IM_BITARRAY_TESTBIT(table->EnabledMaskByIndex, column_n))
     4308: 3002-block 3
branch  0 taken 4308 (fallthrough)
branch  1 taken 0
     4308: 3003:            if ((table->Columns[column_n].Flags & ImGuiTableColumnFlags_NoHeaderLabel) == 0)
     4308: 3003-block 4
call    0 returned 4308
branch  1 taken 4308 (fallthrough)
branch  2 taken 0
     4308: 3004:                row_height = ImMax(row_height, CalcTextSize(TableGetColumnName(table, column_n)).y);
     4308: 3004-block 6
call    0 returned 4308
call    1 returned 4308
call    2 returned 4308
     1077: 3005:    return row_height + g.Style.CellPadding.y * 2.0f;
     1077: 3005-block 11
        -: 3006:}
        -: 3007:
function _ZN5ImGui33TableGetHeaderAngledMaxLabelWidthEv called 0 returned 0% blocks executed 0%
    #####: 3008:float ImGui::TableGetHeaderAngledMaxLabelWidth()
        -: 3009:{
    #####: 3010:    ImGuiContext& g = *GImGui;
    #####: 3011:    ImGuiTable* table = g.CurrentTable;
    #####: 3012:    float width = 0.0f;
    #####: 3013:    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
    %%%%%: 3013-block 2
    %%%%%: 3013-block 9
    %%%%%: 3013-block 10
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3014:        if (IM_BITARRAY_TESTBIT(table->EnabledMaskByIndex, column_n))
    %%%%%: 3014-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3015:            if (table->Columns[column_n].Flags & ImGuiTableColumnFlags_AngledHeader)
    %%%%%: 3015-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 3016:                width = ImMax(width, CalcTextSize(TableGetColumnName(table, column_n), NULL, true).x);
    %%%%%: 3016-block 6
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3017:    return width + g.Style.CellPadding.y * 2.0f; // Swap padding
    %%%%%: 3017-block 11
        -: 3018:}
        -: 3019:
        -: 3020:// [Public] This is a helper to output TableHeader() calls based on the column names declared in TableSetupColumn().
        -: 3021:// The intent is that advanced users willing to create customized headers would not need to use this helper
        -: 3022:// and can create their own! For example: TableHeader() may be preceded by Checkbox() or other custom widgets.
        -: 3023:// See 'Demo->Tables->Custom headers' for a demonstration of implementing a custom version of this.
        -: 3024:// This code is intentionally written to not make much use of internal functions, to give you better direction
        -: 3025:// if you need to write your own.
        -: 3026:// FIXME-TABLE: TableOpenContextMenu() and TableGetHeaderRowHeight() are not public.
function _ZN5ImGui15TableHeadersRowEv called 1077 returned 100% blocks executed 76%
     1077: 3027:void ImGui::TableHeadersRow()
        -: 3028:{
     1077: 3029:    ImGuiContext& g = *GImGui;
     1077: 3030:    ImGuiTable* table = g.CurrentTable;
    1077*: 3031:    IM_ASSERT(table != NULL && "Need to call TableHeadersRow() after BeginTable()!");
     1077: 3031-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 3031-block 3
call    2 never executed
        -: 3032:
        -: 3033:    // Call layout if not already done. This is automatically done by TableNextRow: we do it here _only_ to make
        -: 3034:    // it easier to debug-step in TableUpdateLayout(). Your own version of this function doesn't need this.
     1077: 3035:    if (!table->IsLayoutLocked)
     1077: 3035-block 4
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077: 3036:        TableUpdateLayout(table);
     1077: 3036-block 5
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -: 3037:
        -: 3038:    // Open row
     1077: 3039:    const float row_height = TableGetHeaderRowHeight();
     1077: 3039-block 6
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077: 3040:    TableNextRow(ImGuiTableRowFlags_Headers, row_height);
     1077: 3040-block 7
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077: 3041:    const float row_y1 = GetCursorScreenPos().y;
     1077: 3041-block 8
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077: 3042:    if (table->HostSkipItems) // Merely an optimization, you may skip in your own code.
     1077: 3042-block 9
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####: 3043:        return;
    %%%%%: 3043-block 10
        -: 3044:
     1077: 3045:    const int columns_count = TableGetColumnCount();
     1077: 3045-block 11
call    0 returned 1077
     5385: 3046:    for (int column_n = 0; column_n < columns_count; column_n++)
     4308: 3046-block 24
     5385: 3046-block 25
branch  0 taken 4308
branch  1 taken 1077 (fallthrough)
        -: 3047:    {
     4308: 3048:        if (!TableSetColumnIndex(column_n))
     4308: 3048-block 13
call    0 returned 4308
branch  1 taken 4308 (fallthrough)
branch  2 taken 0 (throw)
     4308: 3048-block 14
branch  3 taken 3 (fallthrough)
branch  4 taken 4305
        3: 3049:            continue;
        3: 3049-block 15
        -: 3050:
        -: 3051:        // Push an id to allow empty/unnamed headers. This is also idiomatic as it ensure there is a consistent ID path to access columns (for e.g. automation)
    4305*: 3052:        const char* name = (TableGetColumnFlags(column_n) & ImGuiTableColumnFlags_NoHeaderLabel) ? "" : TableGetColumnName(column_n);
     4305: 3052-block 16
call    0 returned 4305
branch  1 taken 4305 (fallthrough)
branch  2 taken 0 (throw)
     4305: 3052-block 17
branch  3 taken 4305 (fallthrough)
branch  4 taken 0
     4305: 3052-block 18
call    5 returned 4305
branch  6 taken 4305 (fallthrough)
branch  7 taken 0 (throw)
     4305: 3052-block 19
    %%%%%: 3052-block 20
     4305: 3053:        PushID(column_n);
     4305: 3053-block 21
call    0 returned 4305
branch  1 taken 4305 (fallthrough)
branch  2 taken 0 (throw)
     4305: 3054:        TableHeader(name);
     4305: 3054-block 22
call    0 returned 4305
branch  1 taken 4305 (fallthrough)
branch  2 taken 0 (throw)
     4305: 3055:        PopID();
     4305: 3055-block 23
call    0 returned 4305
branch  1 taken 4305 (fallthrough)
branch  2 taken 0 (throw)
        -: 3056:    }
        -: 3057:
        -: 3058:    // Allow opening popup from the right-most section after the last column.
     1077: 3059:    ImVec2 mouse_pos = ImGui::GetMousePos();
     1077: 3059-block 26
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
    1077*: 3060:    if (IsMouseReleased(1) && TableGetHoveredColumn() == columns_count)
     1077: 3060-block 27
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077: 3060-block 28
branch  3 taken 0 (fallthrough)
branch  4 taken 1077
    %%%%%: 3060-block 29
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 3060-block 31
     1077: 3060-block 32
     1077: 3060-block 33
branch  8 taken 0 (fallthrough)
branch  9 taken 1077
    #####: 3061:        if (mouse_pos.y >= row_y1 && mouse_pos.y < row_y1 + row_height)
    %%%%%: 3061-block 34
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3061-block 35
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3062:            TableOpenContextMenu(columns_count); // Will open a non-column-specific popup.
    %%%%%: 3062-block 36
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 3063:}
        -: 3064:
        -: 3065:// Emit a column header (text + optional sort order)
        -: 3066:// We cpu-clip text here so that all columns headers can be merged into a same draw call.
        -: 3067:// Note that because of how we cpu-clip and display sorting indicators, you _cannot_ use SameLine() after a TableHeader()
function _ZN5ImGui11TableHeaderEPKc called 4305 returned 100% blocks executed 35%
     4305: 3068:void ImGui::TableHeader(const char* label)
        -: 3069:{
     4305: 3070:    ImGuiContext& g = *GImGui;
     4305: 3071:    ImGuiWindow* window = g.CurrentWindow;
     4305: 3072:    if (window->SkipItems)
     4305: 3072-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 4305
    #####: 3073:        return;
    %%%%%: 3073-block 3
    %%%%%: 3073-block 120
        -: 3074:
     4305: 3075:    ImGuiTable* table = g.CurrentTable;
    4305*: 3076:    IM_ASSERT(table != NULL && "Need to call TableHeader() after BeginTable()!");
     4305: 3076-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 4305
    %%%%%: 3076-block 5
call    2 never executed
    4305*: 3077:    IM_ASSERT(table->CurrentColumn != -1);
     4305: 3077-block 6
branch  0 taken 0 (fallthrough)
branch  1 taken 4305
    %%%%%: 3077-block 7
call    2 never executed
     4305: 3078:    const int column_n = table->CurrentColumn;
     4305: 3079:    ImGuiTableColumn* column = &table->Columns[column_n];
     4305: 3079-block 8
call    0 returned 4305
        -: 3080:
        -: 3081:    // Label
     4305: 3082:    if (label == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 4305
    #####: 3083:        label = "";
    %%%%%: 3083-block 10
     4305: 3084:    const char* label_end = FindRenderedTextEnd(label);
     4305: 3084-block 11
call    0 returned 4305
branch  1 taken 4305 (fallthrough)
branch  2 taken 0 (throw)
     4305: 3085:    ImVec2 label_size = CalcTextSize(label, label_end, true);
     4305: 3085-block 12
call    0 returned 4305
branch  1 taken 4305 (fallthrough)
branch  2 taken 0 (throw)
     4305: 3086:    ImVec2 label_pos = window->DC.CursorPos;
        -: 3087:
        -: 3088:    // If we already got a row height, there's use that.
        -: 3089:    // FIXME-TABLE: Padding problem if the correct outer-padding CellBgRect strays off our ClipRect?
     4305: 3090:    ImRect cell_r = TableGetCellBgRect(table, column_n);
     4305: 3090-block 13
call    0 returned 4305
branch  1 taken 4305 (fallthrough)
branch  2 taken 0 (throw)
     4305: 3091:    float label_height = ImMax(label_size.y, table->RowMinHeight - table->RowCellPaddingY * 2.0f);
     4305: 3091-block 14
call    0 returned 4305
        -: 3092:
        -: 3093:    // Calculate ideal size for sort order arrow
     4305: 3094:    float w_arrow = 0.0f;
     4305: 3095:    float w_sort_text = 0.0f;
     4305: 3096:    bool sort_arrow = false;
     4305: 3097:    char sort_order_suf[4] = "";
     4305: 3098:    const float ARROW_SCALE = 0.65f;
    4305*: 3099:    if ((table->Flags & ImGuiTableFlags_Sortable) && !(column->Flags & ImGuiTableColumnFlags_NoSort))
branch  0 taken 0 (fallthrough)
branch  1 taken 4305
    %%%%%: 3099-block 16
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 3100:    {
    #####: 3101:        w_arrow = ImTrunc(g.FontSize * ARROW_SCALE + g.Style.FramePadding.x);
    %%%%%: 3101-block 17
call    0 never executed
    #####: 3102:        if (column->SortOrder != -1)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3103:            sort_arrow = true;
    %%%%%: 3103-block 19
    #####: 3104:        if (column->SortOrder > 0)
    %%%%%: 3104-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3105:        {
    #####: 3106:            ImFormatString(sort_order_suf, IM_ARRAYSIZE(sort_order_suf), "%d", column->SortOrder + 1);
    %%%%%: 3106-block 21
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3107:            w_sort_text = g.Style.ItemInnerSpacing.x + CalcTextSize(sort_order_suf).x;
    %%%%%: 3107-block 22
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 3107-block 23
        -: 3108:        }
        -: 3109:    }
        -: 3110:
        -: 3111:    // We feed our unclipped width to the column without writing on CursorMaxPos, so that column is still considered for merging.
     4305: 3112:    float max_pos_x = label_pos.x + label_size.x + w_sort_text + w_arrow;
    4305*: 3113:    column->ContentMaxXHeadersUsed = ImMax(column->ContentMaxXHeadersUsed, sort_arrow ? cell_r.Max.x : ImMin(max_pos_x, cell_r.Max.x));
     4305: 3113-block 24
branch  0 taken 0 (fallthrough)
branch  1 taken 4305
    %%%%%: 3113-block 25
     4305: 3113-block 26
call    2 returned 4305
     4305: 3113-block 27
call    3 returned 4305
     4305: 3114:    column->ContentMaxXHeadersIdeal = ImMax(column->ContentMaxXHeadersIdeal, max_pos_x);
call    0 returned 4305
        -: 3115:
        -: 3116:    // Keep header highlighted when context menu is open.
     4305: 3117:    ImGuiID id = window->GetID(label);
call    0 returned 4305
branch  1 taken 4305 (fallthrough)
branch  2 taken 0 (throw)
     4305: 3118:    ImRect bb(cell_r.Min.x, cell_r.Min.y, cell_r.Max.x, ImMax(cell_r.Max.y, cell_r.Min.y + label_height + g.Style.CellPadding.y * 2.0f));
     4305: 3118-block 30
call    0 returned 4305
call    1 returned 4305
     4305: 3119:    ItemSize(ImVec2(0.0f, label_height)); // Don't declare unclipped width, it'll be fed ContentMaxPosHeadersIdeal
call    0 returned 4305
call    1 returned 4305
branch  2 taken 4305 (fallthrough)
branch  3 taken 0 (throw)
    $$$$$: 3119-block 122
     4305: 3120:    if (!ItemAdd(bb, id))
     4305: 3120-block 34
call    0 returned 4305
branch  1 taken 4305 (fallthrough)
branch  2 taken 0 (throw)
     4305: 3120-block 35
branch  3 taken 0 (fallthrough)
branch  4 taken 4305
    #####: 3121:        return;
    %%%%%: 3121-block 36
        -: 3122:
        -: 3123:    //GetForegroundDrawList()->AddRect(cell_r.Min, cell_r.Max, IM_COL32(255, 0, 0, 255)); // [DEBUG]
        -: 3124:    //GetForegroundDrawList()->AddRect(bb.Min, bb.Max, IM_COL32(255, 0, 0, 255)); // [DEBUG]
        -: 3125:
        -: 3126:    // Using AllowOverlap mode because we cover the whole cell, and we want user to be able to submit subsequent items.
     4305: 3127:    const bool highlight = (table->HighlightColumnHeader == column_n);
        -: 3128:    bool hovered, held;
     4305: 3129:    bool pressed = ButtonBehavior(bb, id, &hovered, &held, ImGuiButtonFlags_AllowOverlap);
     4305: 3129-block 37
call    0 returned 4305
branch  1 taken 4305 (fallthrough)
branch  2 taken 0 (throw)
     4305: 3130:    if (held || hovered || highlight)
     4305: 3130-block 38
branch  0 taken 4305 (fallthrough)
branch  1 taken 0
     4305: 3130-block 39
branch  2 taken 4305 (fallthrough)
branch  3 taken 0
     4305: 3130-block 40
branch  4 taken 0 (fallthrough)
branch  5 taken 4305
        -: 3131:    {
    #####: 3132:        const ImU32 col = GetColorU32(held ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered : ImGuiCol_Header);
    %%%%%: 3132-block 41
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3132-block 42
    %%%%%: 3132-block 43
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3132-block 44
    %%%%%: 3132-block 45
    %%%%%: 3132-block 46
    %%%%%: 3132-block 47
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
        -: 3133:        //RenderFrame(bb.Min, bb.Max, col, false, 0.0f);
    #####: 3134:        TableSetBgColor(ImGuiTableBgTarget_CellBg, col, table->CurrentColumn);
    %%%%%: 3134-block 48
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3135:    }
    %%%%%: 3135-block 49
        -: 3136:    else
        -: 3137:    {
        -: 3138:        // Submit single cell bg color in the case we didn't submit a full header row
     4305: 3139:        if ((table->RowFlags & ImGuiTableRowFlags_Headers) == 0)
     4305: 3139-block 50
branch  0 taken 0 (fallthrough)
branch  1 taken 4305
    #####: 3140:            TableSetBgColor(ImGuiTableBgTarget_CellBg, GetColorU32(ImGuiCol_TableHeaderBg), table->CurrentColumn);
    %%%%%: 3140-block 51
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 3140-block 52
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
        -: 3141:    }
     4305: 3142:    RenderNavCursor(bb, id, ImGuiNavRenderCursorFlags_Compact | ImGuiNavRenderCursorFlags_NoRounding);
     4305: 3142-block 53
call    0 returned 4305
branch  1 taken 4305 (fallthrough)
branch  2 taken 0 (throw)
     4305: 3143:    if (held)
     4305: 3143-block 54
branch  0 taken 0 (fallthrough)
branch  1 taken 4305
    #####: 3144:        table->HeldHeaderColumn = (ImGuiTableColumnIdx)column_n;
    %%%%%: 3144-block 55
     4305: 3145:    window->DC.CursorPos.y -= g.Style.ItemSpacing.y * 0.5f;
        -: 3146:
        -: 3147:    // Drag and drop to re-order columns.
        -: 3148:    // FIXME-TABLE: Scroll request while reordering a column and it lands out of the scrolling zone.
    4305*: 3149:    if (held && (table->Flags & ImGuiTableFlags_Reorderable) && IsMouseDragging(0) && !g.DragDropActive)
     4305: 3149-block 56
branch  0 taken 0 (fallthrough)
branch  1 taken 4305
    %%%%%: 3149-block 57
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3149-block 58
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    %%%%%: 3149-block 59
branch  7 never executed (fallthrough)
branch  8 never executed
    %%%%%: 3149-block 60
branch  9 never executed (fallthrough)
branch 10 never executed
    %%%%%: 3149-block 61
     4305: 3149-block 62
     4305: 3149-block 63
branch 11 taken 0 (fallthrough)
branch 12 taken 4305
        -: 3150:    {
        -: 3151:        // While moving a column it will jump on the other side of the mouse, so we also test for MouseDelta.x
    #####: 3152:        table->ReorderColumn = (ImGuiTableColumnIdx)column_n;
    #####: 3153:        table->InstanceInteracted = table->InstanceCurrent;
        -: 3154:
        -: 3155:        // We don't reorder: through the frozen<>unfrozen line, or through a column that is marked with ImGuiTableColumnFlags_NoReorder.
    #####: 3156:        if (g.IO.MouseDelta.x < 0.0f && g.IO.MousePos.x < cell_r.Min.x)
    %%%%%: 3156-block 64
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3156-block 65
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3157:            if (ImGuiTableColumn* prev_column = (column->PrevEnabledColumn != -1) ? &table->Columns[column->PrevEnabledColumn] : NULL)
    %%%%%: 3157-block 66
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3157-block 67
call    2 never executed
    %%%%%: 3157-block 68
    %%%%%: 3157-block 69
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 3158:                if (!((column->Flags | prev_column->Flags) & ImGuiTableColumnFlags_NoReorder))
    %%%%%: 3158-block 70
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3159:                    if ((column->IndexWithinEnabledSet < table->FreezeColumnsRequest) == (prev_column->IndexWithinEnabledSet < table->FreezeColumnsRequest))
    %%%%%: 3159-block 71
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3160:                        table->ReorderColumnDir = -1;
    %%%%%: 3160-block 72
    #####: 3161:        if (g.IO.MouseDelta.x > 0.0f && g.IO.MousePos.x > cell_r.Max.x)
    %%%%%: 3161-block 73
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3161-block 74
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3162:            if (ImGuiTableColumn* next_column = (column->NextEnabledColumn != -1) ? &table->Columns[column->NextEnabledColumn] : NULL)
    %%%%%: 3162-block 75
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3162-block 76
call    2 never executed
    %%%%%: 3162-block 77
    %%%%%: 3162-block 78
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 3163:                if (!((column->Flags | next_column->Flags) & ImGuiTableColumnFlags_NoReorder))
    %%%%%: 3163-block 79
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3164:                    if ((column->IndexWithinEnabledSet < table->FreezeColumnsRequest) == (next_column->IndexWithinEnabledSet < table->FreezeColumnsRequest))
    %%%%%: 3164-block 80
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3165:                        table->ReorderColumnDir = +1;
    %%%%%: 3165-block 81
        -: 3166:    }
        -: 3167:
        -: 3168:    // Sort order arrow
     4305: 3169:    const float ellipsis_max = ImMax(cell_r.Max.x - w_arrow - w_sort_text, label_pos.x);
     4305: 3169-block 82
call    0 returned 4305
    4305*: 3170:    if ((table->Flags & ImGuiTableFlags_Sortable) && !(column->Flags & ImGuiTableColumnFlags_NoSort))
branch  0 taken 0 (fallthrough)
branch  1 taken 4305
    %%%%%: 3170-block 84
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 3171:    {
    #####: 3172:        if (column->SortOrder != -1)
    %%%%%: 3172-block 85
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3173:        {
    #####: 3174:            float x = ImMax(cell_r.Min.x, cell_r.Max.x - w_arrow - w_sort_text);
    %%%%%: 3174-block 86
call    0 never executed
    #####: 3175:            float y = label_pos.y;
    #####: 3176:            if (column->SortOrder > 0)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3177:            {
    #####: 3178:                PushStyleColor(ImGuiCol_Text, GetColorU32(ImGuiCol_Text, 0.70f));
    %%%%%: 3178-block 88
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 3178-block 89
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    #####: 3179:                RenderText(ImVec2(x + g.Style.ItemInnerSpacing.x, y), sort_order_suf);
    %%%%%: 3179-block 90
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$: 3179-block 123
    #####: 3180:                PopStyleColor();
    %%%%%: 3180-block 92
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3181:                x += w_sort_text;
    %%%%%: 3181-block 93
        -: 3182:            }
    #####: 3183:            RenderArrow(window->DrawList, ImVec2(x, y), GetColorU32(ImGuiCol_Text), column->SortDirection == ImGuiSortDirection_Ascending ? ImGuiDir_Up : ImGuiDir_Down, ARROW_SCALE);
    %%%%%: 3183-block 94
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3183-block 95
    %%%%%: 3183-block 96
    %%%%%: 3183-block 97
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 3183-block 98
call    5 never executed
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed (throw)
    %%%%%: 3183-block 100
    $$$$$: 3183-block 124
        -: 3184:        }
        -: 3185:
        -: 3186:        // Handle clicking on column header to adjust Sort Order
    #####: 3187:        if (pressed && table->ReorderColumn != column_n)
    %%%%%: 3187-block 101
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3187-block 102
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 3188:        {
    #####: 3189:            ImGuiSortDirection sort_direction = TableGetColumnNextSortDirection(column);
    %%%%%: 3189-block 103
call    0 never executed
    #####: 3190:            TableSetColumnSortDirection(column_n, sort_direction, g.IO.KeyShift);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 3191:        }
        -: 3192:    }
        -: 3193:
        -: 3194:    // Render clipped label. Clipping here ensure that in the majority of situations, all our header cells will
        -: 3195:    // be merged into a single draw call.
        -: 3196:    //window->DrawList->AddCircleFilled(ImVec2(ellipsis_max, label_pos.y), 40, IM_COL32_WHITE);
     4305: 3197:    RenderTextEllipsis(window->DrawList, label_pos, ImVec2(ellipsis_max, label_pos.y + label_height + g.Style.FramePadding.y), ellipsis_max, ellipsis_max, label, label_end, &label_size);
     4305: 3197-block 105
call    0 returned 4305
call    1 returned 4305
branch  2 taken 4305 (fallthrough)
branch  3 taken 0 (throw)
    $$$$$: 3197-block 125
        -: 3198:
     4305: 3199:    const bool text_clipped = label_size.x > (ellipsis_max - label_pos.x);
    4305*: 3200:    if (text_clipped && hovered && g.ActiveId == 0)
     4305: 3200-block 107
branch  0 taken 4305 (fallthrough)
branch  1 taken 0
     4305: 3200-block 108
branch  2 taken 0 (fallthrough)
branch  3 taken 4305
    %%%%%: 3200-block 109
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 3201:        SetItemTooltip("%.*s", (int)(label_end - label), label);
    %%%%%: 3201-block 110
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 3202:
        -: 3203:    // We don't use BeginPopupContextItem() because we want the popup to stay up even after the column is hidden
    4305*: 3204:    if (IsMouseReleased(1) && IsItemHovered())
     4305: 3204-block 111
call    0 returned 4305
branch  1 taken 4305 (fallthrough)
branch  2 taken 0 (throw)
     4305: 3204-block 112
branch  3 taken 0 (fallthrough)
branch  4 taken 4305
    %%%%%: 3204-block 113
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
    %%%%%: 3204-block 114
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%: 3204-block 115
     4305: 3204-block 116
     4305: 3204-block 117
branch 10 taken 0 (fallthrough)
branch 11 taken 4305
    #####: 3205:        TableOpenContextMenu(column_n);
    %%%%%: 3205-block 118
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 3206:}
        -: 3207:
        -: 3208:// Unlike TableHeadersRow() it is not expected that you can reimplement or customize this with custom widgets.
        -: 3209:// FIXME: No hit-testing/button on the angled header.
function _ZN5ImGui21TableAngledHeadersRowEv called 0 returned 0% blocks executed 0%
    #####: 3210:void ImGui::TableAngledHeadersRow()
        -: 3211:{
    #####: 3212:    ImGuiContext& g = *GImGui;
    #####: 3213:    ImGuiTable* table = g.CurrentTable;
    #####: 3214:    ImGuiTableTempData* temp_data = table->TempData;
    #####: 3215:    temp_data->AngledHeadersRequests.resize(0);
    %%%%%: 3215-block 2
call    0 never executed
    #####: 3216:    temp_data->AngledHeadersRequests.reserve(table->ColumnsEnabledCount);
call    0 never executed
        -: 3217:
        -: 3218:    // Which column needs highlight?
    #####: 3219:    const ImGuiID row_id = GetID("##AngledHeaders");
call    0 never executed
    #####: 3220:    ImGuiTableInstanceData* table_instance = TableGetInstanceData(table, table->InstanceCurrent);
call    0 never executed
    #####: 3221:    int highlight_column_n = table->HighlightColumnHeader;
    #####: 3222:    if (highlight_column_n == -1 && table->HoveredColumnBody != -1)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3222-block 7
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3223:        if (table_instance->HoveredRowLast == 0 && table->HoveredColumnBorder == -1 && (g.ActiveId == 0 || g.ActiveId == row_id || (table->IsActiveIdInTable || g.DragDropActive)))
    %%%%%: 3223-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3223-block 9
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3223-block 10
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 3223-block 11
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 3223-block 12
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%: 3223-block 13
branch 10 never executed (fallthrough)
branch 11 never executed
    #####: 3224:            highlight_column_n = table->HoveredColumnBody;
    %%%%%: 3224-block 14
        -: 3225:
        -: 3226:    // Build up request
    #####: 3227:    ImU32 col_header_bg = GetColorU32(ImGuiCol_TableHeaderBg);
    %%%%%: 3227-block 15
call    0 never executed
    #####: 3228:    ImU32 col_text = GetColorU32(ImGuiCol_Text);
call    0 never executed
    #####: 3229:    for (int order_n = 0; order_n < table->ColumnsCount; order_n++)
    %%%%%: 3229-block 29
    %%%%%: 3229-block 30
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3230:        if (IM_BITARRAY_TESTBIT(table->EnabledMaskByDisplayOrder, order_n))
    %%%%%: 3230-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3231:        {
    #####: 3232:            const int column_n = table->DisplayOrderToIndex[order_n];
    %%%%%: 3232-block 19
call    0 never executed
    #####: 3233:            ImGuiTableColumn* column = &table->Columns[column_n];
call    0 never executed
    #####: 3234:            if ((column->Flags & ImGuiTableColumnFlags_AngledHeader) == 0) // Note: can't rely on ImGuiTableColumnFlags_IsVisible test here.
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3235:                continue;
    %%%%%: 3235-block 22
    #####: 3236:            ImGuiTableHeaderData request = { (ImGuiTableColumnIdx)column_n, col_text, col_header_bg, (column_n == highlight_column_n) ? GetColorU32(ImGuiCol_Header) : 0 };
    %%%%%: 3236-block 23
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3236-block 24
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 3236-block 25
    %%%%%: 3236-block 26
    #####: 3237:            temp_data->AngledHeadersRequests.push_back(request);
    %%%%%: 3237-block 27
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 3238:        }
        -: 3239:
        -: 3240:    // Render row
    #####: 3241:    TableAngledHeadersRowEx(row_id, g.Style.TableAngledHeadersAngle, 0.0f, temp_data->AngledHeadersRequests.Data, temp_data->AngledHeadersRequests.Size);
    %%%%%: 3241-block 31
call    0 never executed
    #####: 3242:}
        -: 3243:
        -: 3244:// Important: data must be fed left to right
function _ZN5ImGui23TableAngledHeadersRowExEjffPK20ImGuiTableHeaderDatai called 0 returned 0% blocks executed 0%
    #####: 3245:void ImGui::TableAngledHeadersRowEx(ImGuiID row_id, float angle, float max_label_width, const ImGuiTableHeaderData* data, int data_count)
        -: 3246:{
    #####: 3247:    ImGuiContext& g = *GImGui;
    #####: 3248:    ImGuiTable* table = g.CurrentTable;
    #####: 3249:    ImGuiWindow* window = g.CurrentWindow;
    #####: 3250:    ImDrawList* draw_list = window->DrawList;
    #####: 3251:    IM_ASSERT(table != NULL && "Need to call TableHeadersRow() after BeginTable()!");
    %%%%%: 3251-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3251-block 3
call    2 never executed
    #####: 3252:    IM_ASSERT(table->CurrentRow == -1 && "Must be first row");
    %%%%%: 3252-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3252-block 5
call    2 never executed
        -: 3253:
    #####: 3254:    if (max_label_width == 0.0f)
    %%%%%: 3254-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3255:        max_label_width = TableGetHeaderAngledMaxLabelWidth();
    %%%%%: 3255-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 3255-block 8
        -: 3256:
        -: 3257:    // Angle argument expressed in (-IM_PI/2 .. +IM_PI/2) as it is easier to think about for user.
    #####: 3258:    const bool flip_label = (angle < 0.0f);
    #####: 3259:    angle -= IM_PI * 0.5f;
    #####: 3260:    const float cos_a = ImCos(angle);
    #####: 3261:    const float sin_a = ImSin(angle);
    #####: 3262:    const float label_cos_a = flip_label ? ImCos(angle + IM_PI) : cos_a;
    %%%%%: 3262-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3262-block 10
    %%%%%: 3262-block 11
    #####: 3263:    const float label_sin_a = flip_label ? ImSin(angle + IM_PI) : sin_a;
    %%%%%: 3263-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3263-block 13
    %%%%%: 3263-block 14
    #####: 3264:    const ImVec2 unit_right = ImVec2(cos_a, sin_a);
    %%%%%: 3264-block 15
call    0 never executed
        -: 3265:
        -: 3266:    // Calculate our base metrics and set angled headers data _before_ the first call to TableNextRow()
        -: 3267:    // FIXME-STYLE: Would it be better for user to submit 'max_label_width' or 'row_height' ? One can be derived from the other.
    #####: 3268:    const float header_height = g.FontSize + g.Style.CellPadding.x * 2.0f;
    #####: 3269:    const float row_height = ImTrunc(ImFabs(ImRotate(ImVec2(max_label_width, flip_label ? +header_height : -header_height), cos_a, sin_a).y));
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3269-block 17
    %%%%%: 3269-block 18
    %%%%%: 3269-block 19
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 3270:    table->AngledHeadersHeight = row_height;
    #####: 3271:    table->AngledHeadersSlope = (sin_a != 0.0f) ? (cos_a / sin_a) : 0.0f;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3271-block 23
    %%%%%: 3271-block 24
    #####: 3272:    const ImVec2 header_angled_vector = unit_right * (row_height / -sin_a); // vector from bottom-left to top-left, and from bottom-right to top-right
    %%%%%: 3272-block 25
call    0 never executed
        -: 3273:
        -: 3274:    // Declare row, override and draw our own background
    #####: 3275:    TableNextRow(ImGuiTableRowFlags_Headers, row_height);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3276:    TableNextColumn();
    %%%%%: 3276-block 27
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3277:    const ImRect row_r(table->WorkRect.Min.x, table->BgClipRect.Min.y, table->WorkRect.Max.x, table->RowPosY2);
    %%%%%: 3277-block 28
call    0 never executed
    #####: 3278:    table->DrawSplitter->SetCurrentChannel(draw_list, TABLE_DRAW_CHANNEL_BG0);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3279:    float clip_rect_min_x = table->BgClipRect.Min.x;
    #####: 3280:    if (table->FreezeColumnsCount > 0)
    %%%%%: 3280-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3281:        clip_rect_min_x = ImMax(clip_rect_min_x, table->Columns[table->FreezeColumnsCount - 1].MaxX);
    %%%%%: 3281-block 31
call    0 never executed
call    1 never executed
    #####: 3282:    TableSetBgColor(ImGuiTableBgTarget_RowBg0, 0); // Cancel
    %%%%%: 3282-block 33
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3283:    PushClipRect(table->BgClipRect.Min, table->BgClipRect.Max, false); // Span all columns
    %%%%%: 3283-block 34
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3284:    draw_list->AddRectFilled(ImVec2(table->BgClipRect.Min.x, row_r.Min.y), ImVec2(table->BgClipRect.Max.x, row_r.Max.y), GetColorU32(ImGuiCol_TableHeaderBg, 0.25f)); // FIXME-STYLE: Change row background with an arbitrary color.
    %%%%%: 3284-block 35
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 3284-block 36
call    3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
    $$$$$: 3284-block 112
    $$$$$: 3284-block 113
    #####: 3285:    PushClipRect(ImVec2(clip_rect_min_x, table->BgClipRect.Min.y), table->BgClipRect.Max, true); // Span all columns
    %%%%%: 3285-block 39
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$: 3285-block 114
        -: 3286:
    #####: 3287:    ButtonBehavior(row_r, row_id, NULL, NULL);
    %%%%%: 3287-block 41
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3288:    KeepAliveID(row_id);
    %%%%%: 3288-block 42
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 3289:
    #####: 3290:    const float ascent_scaled = g.Font->Ascent * g.FontScale; // FIXME: Standardize those scaling factors better
    #####: 3291:    const float line_off_for_ascent_x = (ImMax((g.FontSize - ascent_scaled) * 0.5f, 0.0f) / -sin_a) * (flip_label ? -1.0f : 1.0f);
    %%%%%: 3291-block 43
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3291-block 45
    %%%%%: 3291-block 46
    #####: 3292:    const ImVec2 padding = g.Style.CellPadding; // We will always use swapped component
    #####: 3293:    const ImVec2 align = g.Style.TableAngledHeadersTextAlign;
        -: 3294:
        -: 3295:    // Draw background and labels in first pass, then all borders.
    #####: 3296:    float max_x = 0.0f;
    #####: 3297:    for (int pass = 0; pass < 2; pass++)
    %%%%%: 3297-block 47
    %%%%%: 3297-block 105
    %%%%%: 3297-block 106
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3298:        for (int order_n = 0; order_n < data_count; order_n++)
    %%%%%: 3298-block 48
    %%%%%: 3298-block 103
    %%%%%: 3298-block 104
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 3299:        {
    #####: 3300:            const ImGuiTableHeaderData* request = &data[order_n];
    #####: 3301:            const int column_n = request->Index;
    #####: 3302:            ImGuiTableColumn* column = &table->Columns[column_n];
    %%%%%: 3302-block 49
call    0 never executed
        -: 3303:
    #####: 3304:            ImVec2 bg_shape[4];
    #####: 3305:            bg_shape[0] = ImVec2(column->MaxX, row_r.Max.y);
call    0 never executed
    #####: 3306:            bg_shape[1] = ImVec2(column->MinX, row_r.Max.y);
call    0 never executed
    #####: 3307:            bg_shape[2] = bg_shape[1] + header_angled_vector;
call    0 never executed
    #####: 3308:            bg_shape[3] = bg_shape[0] + header_angled_vector;
call    0 never executed
    #####: 3309:            if (pass == 0)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3310:            {
        -: 3311:                // Draw shape
    #####: 3312:                draw_list->AddQuadFilled(bg_shape[0], bg_shape[1], bg_shape[2], bg_shape[3], request->BgColor0);
    %%%%%: 3312-block 55
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3313:                draw_list->AddQuadFilled(bg_shape[0], bg_shape[1], bg_shape[2], bg_shape[3], request->BgColor1); // Optional highlight
    %%%%%: 3313-block 56
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3314:                max_x = ImMax(max_x, bg_shape[3].x);
    %%%%%: 3314-block 57
call    0 never executed
        -: 3315:
        -: 3316:                // Draw label
        -: 3317:                // - First draw at an offset where RenderTextXXX() function won't meddle with applying current ClipRect, then transform to final offset.
        -: 3318:                // - Handle multiple lines manually, as we want each lines to follow on the horizontal border, rather than see a whole block rotated.
    #####: 3319:                const char* label_name = TableGetColumnName(table, column_n);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3320:                const char* label_name_end = FindRenderedTextEnd(label_name);
    %%%%%: 3320-block 59
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3321:                const float line_off_step_x = (g.FontSize / -sin_a);
    #####: 3322:                const int label_lines = ImTextCountLines(label_name, label_name_end);
    %%%%%: 3322-block 60
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 3323:
        -: 3324:                // Left<>Right alignment
    #####: 3325:                float line_off_curr_x = flip_label ? (label_lines - 1) * line_off_step_x : 0.0f;
    %%%%%: 3325-block 61
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3325-block 62
    %%%%%: 3325-block 63
    #####: 3326:                float line_off_for_align_x = ImMax((((column->MaxX - column->MinX) - padding.x * 2.0f) - (label_lines * line_off_step_x)), 0.0f) * align.x;
    %%%%%: 3326-block 64
call    0 never executed
    #####: 3327:                line_off_curr_x += line_off_for_align_x - line_off_for_ascent_x;
        -: 3328:
        -: 3329:                // Register header width
    #####: 3330:                column->ContentMaxXHeadersUsed = column->ContentMaxXHeadersIdeal = column->WorkMinX + ImCeil(label_lines * line_off_step_x - line_off_for_align_x);
        -: 3331:
    #####: 3332:                while (label_name < label_name_end)
    %%%%%: 3332-block 99
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 3333:                {
    #####: 3334:                    const char* label_name_eol = strchr(label_name, '\n');
    #####: 3335:                    if (label_name_eol == NULL)
    %%%%%: 3335-block 66
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3336:                        label_name_eol = label_name_end;
    %%%%%: 3336-block 67
        -: 3337:
        -: 3338:                    // FIXME: Individual line clipping for right-most column is broken for negative angles.
    #####: 3339:                    ImVec2 label_size = CalcTextSize(label_name, label_name_eol);
    %%%%%: 3339-block 68
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3340:                    float clip_width = max_label_width - padding.y; // Using padding.y*2.0f would be symmetrical but hide more text.
    #####: 3341:                    float clip_height = ImMin(label_size.y, column->ClipRect.Max.x - column->WorkMinX - line_off_curr_x);
    %%%%%: 3341-block 69
call    0 never executed
    #####: 3342:                    ImRect clip_r(window->ClipRect.Min, window->ClipRect.Min + ImVec2(clip_width, clip_height));
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3343:                    int vtx_idx_begin = draw_list->_VtxCurrentIdx;
    #####: 3344:                    PushStyleColor(ImGuiCol_Text, request->TextColor);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3345:                    RenderTextEllipsis(draw_list, clip_r.Min, clip_r.Max, clip_r.Max.x, clip_r.Max.x, label_name, label_name_eol, &label_size);
    %%%%%: 3345-block 74
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3346:                    PopStyleColor();
    %%%%%: 3346-block 75
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3347:                    int vtx_idx_end = draw_list->_VtxCurrentIdx;
        -: 3348:
        -: 3349:                    // Up<>Down alignment
    #####: 3350:                    const float available_space = ImMax(clip_width - label_size.x + ImAbs(padding.x * cos_a) * 2.0f - ImAbs(padding.y * sin_a) * 2.0f, 0.0f);
    %%%%%: 3350-block 76
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3351:                    const float vertical_offset = available_space * align.y * (flip_label ? -1.0f : 1.0f);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3351-block 80
    %%%%%: 3351-block 81
        -: 3352:
        -: 3353:                    // Rotate and offset label
    #####: 3354:                    ImVec2 pivot_in = ImVec2(window->ClipRect.Min.x - vertical_offset, window->ClipRect.Min.y + label_size.y);
    %%%%%: 3354-block 82
call    0 never executed
    #####: 3355:                    ImVec2 pivot_out = ImVec2(column->WorkMinX, row_r.Max.y);
call    0 never executed
    #####: 3356:                    line_off_curr_x += flip_label ? -line_off_step_x : line_off_step_x;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3356-block 85
    %%%%%: 3356-block 86
    #####: 3357:                    pivot_out += unit_right * padding.y;
    %%%%%: 3357-block 87
call    0 never executed
call    1 never executed
    #####: 3358:                    if (flip_label)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3359:                        pivot_out += unit_right * (clip_width - ImMax(0.0f, clip_width - label_size.x));
    %%%%%: 3359-block 90
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3360:                    pivot_out.x += flip_label ? line_off_curr_x + line_off_step_x : line_off_curr_x;
    %%%%%: 3360-block 94
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3360-block 95
    %%%%%: 3360-block 96
    #####: 3361:                    ShadeVertsTransformPos(draw_list, vtx_idx_begin, vtx_idx_end, pivot_in, label_cos_a, label_sin_a, pivot_out); // Rotate and offset
    %%%%%: 3361-block 97
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 3362:                    //if (g.IO.KeyShift) { ImDrawList* fg_dl = GetForegroundDrawList(); vtx_idx_begin = fg_dl->_VtxCurrentIdx; fg_dl->AddRect(clip_r.Min, clip_r.Max, IM_COL32(0, 255, 0, 255), 0.0f, 0, 1.0f); ShadeVertsTransformPos(fg_dl, vtx_idx_begin, fg_dl->_VtxCurrentIdx, pivot_in, label_cos_a, label_sin_a, pivot_out); }
        -: 3363:
    #####: 3364:                    label_name = label_name_eol + 1;
    %%%%%: 3364-block 98
        -: 3365:                }
        -: 3366:            }
    #####: 3367:            if (pass == 1)
    %%%%%: 3367-block 100
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3368:            {
        -: 3369:                // Draw border
    #####: 3370:                draw_list->AddLine(bg_shape[0], bg_shape[3], TableGetColumnBorderCol(table, order_n, column_n));
    %%%%%: 3370-block 101
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 3370-block 102
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
        -: 3371:            }
        -: 3372:        }
    #####: 3373:    PopClipRect();
    %%%%%: 3373-block 107
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3374:    PopClipRect();
    %%%%%: 3374-block 108
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3375:    table->TempData->AngledHeadersExtraWidth = ImMax(0.0f, max_x - table->Columns[table->RightMostEnabledColumn].MaxX);
    %%%%%: 3375-block 109
call    0 never executed
call    1 never executed
    #####: 3376:}
        -: 3377:
        -: 3378://-------------------------------------------------------------------------
        -: 3379:// [SECTION] Tables: Context Menu
        -: 3380://-------------------------------------------------------------------------
        -: 3381:// - TableOpenContextMenu() [Internal]
        -: 3382:// - TableBeginContextMenuPopup() [Internal]
        -: 3383:// - TableDrawDefaultContextMenu() [Internal]
        -: 3384://-------------------------------------------------------------------------
        -: 3385:
        -: 3386:// Use -1 to open menu not specific to a given column.
function _ZN5ImGui20TableOpenContextMenuEi called 0 returned 0% blocks executed 0%
    #####: 3387:void ImGui::TableOpenContextMenu(int column_n)
        -: 3388:{
    #####: 3389:    ImGuiContext& g = *GImGui;
    #####: 3390:    ImGuiTable* table = g.CurrentTable;
    #####: 3391:    if (column_n == -1 && table->CurrentColumn != -1)   // When called within a column automatically use this one (for consistency)
    %%%%%: 3391-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3391-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3392:        column_n = table->CurrentColumn;
    %%%%%: 3392-block 4
    #####: 3393:    if (column_n == table->ColumnsCount)                // To facilitate using with TableGetHoveredColumn()
    %%%%%: 3393-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3394:        column_n = -1;
    %%%%%: 3394-block 6
    #####: 3395:    IM_ASSERT(column_n >= -1 && column_n < table->ColumnsCount);
    %%%%%: 3395-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3395-block 8
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3395-block 9
    %%%%%: 3395-block 10
call    4 never executed
    #####: 3396:    if (table->Flags & (ImGuiTableFlags_Resizable | ImGuiTableFlags_Reorderable | ImGuiTableFlags_Hideable))
    %%%%%: 3396-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3397:    {
    #####: 3398:        table->IsContextPopupOpen = true;
    #####: 3399:        table->ContextPopupColumn = (ImGuiTableColumnIdx)column_n;
    #####: 3400:        table->InstanceInteracted = table->InstanceCurrent;
    #####: 3401:        const ImGuiID context_menu_id = ImHashStr("##ContextMenu", 0, table->ID);
    %%%%%: 3401-block 12
call    0 never executed
    #####: 3402:        OpenPopupEx(context_menu_id, ImGuiPopupFlags_None);
call    0 never executed
        -: 3403:    }
    #####: 3404:}
        -: 3405:
function _ZN5ImGui26TableBeginContextMenuPopupEP10ImGuiTable called 1077 returned 100% blocks executed 33%
     1077: 3406:bool ImGui::TableBeginContextMenuPopup(ImGuiTable* table)
        -: 3407:{
    1077*: 3408:    if (!table->IsContextPopupOpen || table->InstanceCurrent != table->InstanceInteracted)
     1077: 3408-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 3408-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
     1077: 3409:        return false;
     1077: 3409-block 4
    #####: 3410:    const ImGuiID context_menu_id = ImHashStr("##ContextMenu", 0, table->ID);
    %%%%%: 3410-block 5
call    0 never executed
    #####: 3411:    if (BeginPopupEx(context_menu_id, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings))
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 3412:        return true;
    %%%%%: 3412-block 8
    #####: 3413:    table->IsContextPopupOpen = false;
    #####: 3414:    return false;
    %%%%%: 3414-block 9
        -: 3415:}
        -: 3416:
        -: 3417:// Output context menu into current window (generally a popup)
        -: 3418:// FIXME-TABLE: Ideally this should be writable by the user. Full programmatic access to that data?
        -: 3419:// Sections to display are pulled from 'flags_for_section_to_display', which is typically == table->Flags.
        -: 3420:// - ImGuiTableFlags_Resizable   -> display Sizing menu items
        -: 3421:// - ImGuiTableFlags_Reorderable -> display "Reset Order"
        -: 3422:////- ImGuiTableFlags_Sortable   -> display sorting options (disabled)
        -: 3423:// - ImGuiTableFlags_Hideable    -> display columns visibility menu items
        -: 3424:// It means if you have a custom context menus you can call this section and omit some sections, and add your own.
function _ZN5ImGui27TableDrawDefaultContextMenuEP10ImGuiTablei called 0 returned 0% blocks executed 0%
    #####: 3425:void ImGui::TableDrawDefaultContextMenu(ImGuiTable* table, ImGuiTableFlags flags_for_section_to_display)
        -: 3426:{
    #####: 3427:    ImGuiContext& g = *GImGui;
    #####: 3428:    ImGuiWindow* window = g.CurrentWindow;
    #####: 3429:    if (window->SkipItems)
    %%%%%: 3429-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3430:        return;
    %%%%%: 3430-block 3
        -: 3431:
    #####: 3432:    bool want_separator = false;
    #####: 3433:    const int column_n = (table->ContextPopupColumn >= 0 && table->ContextPopupColumn < table->ColumnsCount) ? table->ContextPopupColumn : -1;
    %%%%%: 3433-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3433-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3433-block 6
    %%%%%: 3433-block 7
    #####: 3434:    ImGuiTableColumn* column = (column_n != -1) ? &table->Columns[column_n] : NULL;
    %%%%%: 3434-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3434-block 9
call    2 never executed
    %%%%%: 3434-block 10
        -: 3435:
        -: 3436:    // Sizing
    #####: 3437:    if (flags_for_section_to_display & ImGuiTableFlags_Resizable)
    %%%%%: 3437-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3438:    {
    #####: 3439:        if (column != NULL)
    %%%%%: 3439-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3440:        {
    #####: 3441:            const bool can_resize = !(column->Flags & ImGuiTableColumnFlags_NoResize) && column->IsEnabled;
    %%%%%: 3441-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3441-block 14
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3441-block 15
    %%%%%: 3441-block 16
    #####: 3442:            if (MenuItem(LocalizeGetMsg(ImGuiLocKey_TableSizeOne), NULL, false, can_resize)) // "###SizeOne"
    %%%%%: 3442-block 17
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3443:                TableSetColumnWidthAutoSingle(table, column_n);
    %%%%%: 3443-block 20
call    0 never executed
        -: 3444:        }
        -: 3445:
        -: 3446:        const char* size_all_desc;
    #####: 3447:        if (table->ColumnsEnabledFixedCount == table->ColumnsEnabledCount && (table->Flags & ImGuiTableFlags_SizingMask_) != ImGuiTableFlags_SizingFixedSame)
    %%%%%: 3447-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3447-block 22
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3448:            size_all_desc = LocalizeGetMsg(ImGuiLocKey_TableSizeAllFit);        // "###SizeAll" All fixed
    %%%%%: 3448-block 23
call    0 never executed
        -: 3449:        else
    #####: 3450:            size_all_desc = LocalizeGetMsg(ImGuiLocKey_TableSizeAllDefault);    // "###SizeAll" All stretch or mixed
    %%%%%: 3450-block 24
call    0 never executed
    #####: 3451:        if (MenuItem(size_all_desc, NULL))
    %%%%%: 3451-block 25
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 3452:            TableSetColumnWidthAutoAll(table);
    %%%%%: 3452-block 27
call    0 never executed
    #####: 3453:        want_separator = true;
    %%%%%: 3453-block 28
        -: 3454:    }
        -: 3455:
        -: 3456:    // Ordering
    #####: 3457:    if (flags_for_section_to_display & ImGuiTableFlags_Reorderable)
    %%%%%: 3457-block 29
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3458:    {
    #####: 3459:        if (MenuItem(LocalizeGetMsg(ImGuiLocKey_TableResetOrder), NULL, false, !table->IsDefaultDisplayOrder))
    %%%%%: 3459-block 30
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3460:            table->IsResetDisplayOrderRequest = true;
    %%%%%: 3460-block 33
    #####: 3461:        want_separator = true;
    %%%%%: 3461-block 34
        -: 3462:    }
        -: 3463:
        -: 3464:    // Reset all (should work but seems unnecessary/noisy to expose?)
        -: 3465:    //if (MenuItem("Reset all"))
        -: 3466:    //    table->IsResetAllRequest = true;
        -: 3467:
        -: 3468:    // Sorting
        -: 3469:    // (modify TableOpenContextMenu() to add _Sortable flag if enabling this)
        -: 3470:#if 0
        -: 3471:    if ((flags_for_section_to_display & ImGuiTableFlags_Sortable) && column != NULL && (column->Flags & ImGuiTableColumnFlags_NoSort) == 0)
        -: 3472:    {
        -: 3473:        if (want_separator)
        -: 3474:            Separator();
        -: 3475:        want_separator = true;
        -: 3476:
        -: 3477:        bool append_to_sort_specs = g.IO.KeyShift;
        -: 3478:        if (MenuItem("Sort in Ascending Order", NULL, column->SortOrder != -1 && column->SortDirection == ImGuiSortDirection_Ascending, (column->Flags & ImGuiTableColumnFlags_NoSortAscending) == 0))
        -: 3479:            TableSetColumnSortDirection(table, column_n, ImGuiSortDirection_Ascending, append_to_sort_specs);
        -: 3480:        if (MenuItem("Sort in Descending Order", NULL, column->SortOrder != -1 && column->SortDirection == ImGuiSortDirection_Descending, (column->Flags & ImGuiTableColumnFlags_NoSortDescending) == 0))
        -: 3481:            TableSetColumnSortDirection(table, column_n, ImGuiSortDirection_Descending, append_to_sort_specs);
        -: 3482:    }
        -: 3483:#endif
        -: 3484:
        -: 3485:    // Hiding / Visibility
    #####: 3486:    if (flags_for_section_to_display & ImGuiTableFlags_Hideable)
    %%%%%: 3486-block 35
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3487:    {
    #####: 3488:        if (want_separator)
    %%%%%: 3488-block 36
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3489:            Separator();
    %%%%%: 3489-block 37
call    0 never executed
    #####: 3490:        want_separator = true;
        -: 3491:
    #####: 3492:        PushItemFlag(ImGuiItemFlags_AutoClosePopups, false);
    %%%%%: 3492-block 38
call    0 never executed
    #####: 3493:        for (int other_column_n = 0; other_column_n < table->ColumnsCount; other_column_n++)
    %%%%%: 3493-block 53
    %%%%%: 3493-block 54
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 3494:        {
    #####: 3495:            ImGuiTableColumn* other_column = &table->Columns[other_column_n];
    %%%%%: 3495-block 40
call    0 never executed
    #####: 3496:            if (other_column->Flags & ImGuiTableColumnFlags_Disabled)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3497:                continue;
    %%%%%: 3497-block 42
        -: 3498:
    #####: 3499:            const char* name = TableGetColumnName(table, other_column_n);
    %%%%%: 3499-block 43
call    0 never executed
    #####: 3500:            if (name == NULL || name[0] == 0)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3500-block 45
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3501:                name = "<Unknown>";
    %%%%%: 3501-block 46
        -: 3502:
        -: 3503:            // Make sure we can't hide the last active column
    #####: 3504:            bool menu_item_active = (other_column->Flags & ImGuiTableColumnFlags_NoHide) ? false : true;
    #####: 3505:            if (other_column->IsUserEnabled && table->ColumnsEnabledCount <= 1)
    %%%%%: 3505-block 47
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3505-block 48
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3506:                menu_item_active = false;
    %%%%%: 3506-block 49
    #####: 3507:            if (MenuItem(name, NULL, other_column->IsUserEnabled, menu_item_active))
    %%%%%: 3507-block 50
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 3508:                other_column->IsUserEnabledNextFrame = !other_column->IsUserEnabled;
    %%%%%: 3508-block 52
        -: 3509:        }
    #####: 3510:        PopItemFlag();
    %%%%%: 3510-block 55
call    0 never executed
        -: 3511:    }
        -: 3512:}
        -: 3513:
        -: 3514://-------------------------------------------------------------------------
        -: 3515:// [SECTION] Tables: Settings (.ini data)
        -: 3516://-------------------------------------------------------------------------
        -: 3517:// FIXME: The binding/finding/creating flow are too confusing.
        -: 3518://-------------------------------------------------------------------------
        -: 3519:// - TableSettingsInit() [Internal]
        -: 3520:// - TableSettingsCalcChunkSize() [Internal]
        -: 3521:// - TableSettingsCreate() [Internal]
        -: 3522:// - TableSettingsFindByID() [Internal]
        -: 3523:// - TableGetBoundSettings() [Internal]
        -: 3524:// - TableResetSettings()
        -: 3525:// - TableSaveSettings() [Internal]
        -: 3526:// - TableLoadSettings() [Internal]
        -: 3527:// - TableSettingsHandler_ClearAll() [Internal]
        -: 3528:// - TableSettingsHandler_ApplyAll() [Internal]
        -: 3529:// - TableSettingsHandler_ReadOpen() [Internal]
        -: 3530:// - TableSettingsHandler_ReadLine() [Internal]
        -: 3531:// - TableSettingsHandler_WriteAll() [Internal]
        -: 3532:// - TableSettingsInstallHandler() [Internal]
        -: 3533://-------------------------------------------------------------------------
        -: 3534:// [Init] 1: TableSettingsHandler_ReadXXXX()   Load and parse .ini file into TableSettings.
        -: 3535:// [Main] 2: TableLoadSettings()               When table is created, bind Table to TableSettings, serialize TableSettings data into Table.
        -: 3536:// [Main] 3: TableSaveSettings()               When table properties are modified, serialize Table data into bound or new TableSettings, mark .ini as dirty.
        -: 3537:// [Main] 4: TableSettingsHandler_WriteAll()   When .ini file is dirty (which can come from other source), save TableSettings into .ini file.
        -: 3538://-------------------------------------------------------------------------
        -: 3539:
        -: 3540:// Clear and initialize empty settings instance
function _ZL17TableSettingsInitP18ImGuiTableSettingsjii called 7 returned 100% blocks executed 100%
        7: 3541:static void TableSettingsInit(ImGuiTableSettings* settings, ImGuiID id, int columns_count, int columns_count_max)
        -: 3542:{
        7: 3543:    IM_PLACEMENT_NEW(settings) ImGuiTableSettings();
        7: 3543-block 2
call    0 returned 7
call    1 returned 7
        7: 3544:    ImGuiTableColumnSettings* settings_column = settings->GetColumnSettings();
call    0 returned 7
       33: 3545:    for (int n = 0; n < columns_count_max; n++, settings_column++)
       33: 3545-block 9
branch  0 taken 26
branch  1 taken 7 (fallthrough)
       26: 3546:        IM_PLACEMENT_NEW(settings_column) ImGuiTableColumnSettings();
       26: 3546-block 6
call    0 returned 26
call    1 returned 26
        7: 3547:    settings->ID = id;
        7: 3548:    settings->ColumnsCount = (ImGuiTableColumnIdx)columns_count;
        7: 3549:    settings->ColumnsCountMax = (ImGuiTableColumnIdx)columns_count_max;
        7: 3550:    settings->WantApply = true;
        7: 3551:}
        -: 3552:
function _ZL26TableSettingsCalcChunkSizei called 7 returned 100% blocks executed 100%
        7: 3553:static size_t TableSettingsCalcChunkSize(int columns_count)
        -: 3554:{
        7: 3555:    return sizeof(ImGuiTableSettings) + (size_t)columns_count * sizeof(ImGuiTableColumnSettings);
        7: 3555-block 2
        -: 3556:}
        -: 3557:
function _ZN5ImGui19TableSettingsCreateEji called 7 returned 100% blocks executed 100%
        7: 3558:ImGuiTableSettings* ImGui::TableSettingsCreate(ImGuiID id, int columns_count)
        -: 3559:{
        7: 3560:    ImGuiContext& g = *GImGui;
        7: 3561:    ImGuiTableSettings* settings = g.SettingsTables.alloc_chunk(TableSettingsCalcChunkSize(columns_count));
        7: 3561-block 2
call    0 returned 7
call    1 returned 7
        7: 3562:    TableSettingsInit(settings, id, columns_count, columns_count);
call    0 returned 7
        7: 3563:    return settings;
        -: 3564:}
        -: 3565:
        -: 3566:// Find existing settings
function _ZN5ImGui21TableSettingsFindByIDEj called 8 returned 100% blocks executed 100%
        8: 3567:ImGuiTableSettings* ImGui::TableSettingsFindByID(ImGuiID id)
        -: 3568:{
        -: 3569:    // FIXME-OPT: Might want to store a lookup map for this?
        8: 3570:    ImGuiContext& g = *GImGui;
       30: 3571:    for (ImGuiTableSettings* settings = g.SettingsTables.begin(); settings != NULL; settings = g.SettingsTables.next_chunk(settings))
        8: 3571-block 2
call    0 returned 8
       22: 3571-block 5
call    1 returned 22
       30: 3571-block 7
branch  2 taken 23
branch  3 taken 7 (fallthrough)
       23: 3572:        if (settings->ID == id)
       23: 3572-block 3
branch  0 taken 1 (fallthrough)
branch  1 taken 22
        1: 3573:            return settings;
        1: 3573-block 4
        7: 3574:    return NULL;
        7: 3574-block 8
        -: 3575:}
        -: 3576:
        -: 3577:// Get settings for a given table, NULL if none
function _ZN5ImGui21TableGetBoundSettingsEP10ImGuiTable called 0 returned 0% blocks executed 0%
    #####: 3578:ImGuiTableSettings* ImGui::TableGetBoundSettings(ImGuiTable* table)
        -: 3579:{
    #####: 3580:    if (table->SettingsOffset != -1)
    %%%%%: 3580-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3581:    {
    #####: 3582:        ImGuiContext& g = *GImGui;
    #####: 3583:        ImGuiTableSettings* settings = g.SettingsTables.ptr_from_offset(table->SettingsOffset);
    %%%%%: 3583-block 3
call    0 never executed
    #####: 3584:        IM_ASSERT(settings->ID == table->ID);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3584-block 5
call    2 never executed
    #####: 3585:        if (settings->ColumnsCountMax >= table->ColumnsCount)
    %%%%%: 3585-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3586:            return settings; // OK
    %%%%%: 3586-block 7
    #####: 3587:        settings->ID = 0; // Invalidate storage, we won't fit because of a count change
    %%%%%: 3587-block 8
        -: 3588:    }
    #####: 3589:    return NULL;
    %%%%%: 3589-block 9
        -: 3590:}
        -: 3591:
        -: 3592:// Restore initial state of table (with or without saved settings)
function _ZN5ImGui18TableResetSettingsEP10ImGuiTable called 0 returned 0% blocks executed 0%
    #####: 3593:void ImGui::TableResetSettings(ImGuiTable* table)
        -: 3594:{
    #####: 3595:    table->IsInitializing = table->IsSettingsDirty = true;
    #####: 3596:    table->IsResetAllRequest = false;
    #####: 3597:    table->IsSettingsRequestLoad = false;                   // Don't reload from ini
    #####: 3598:    table->SettingsLoadedFlags = ImGuiTableFlags_None;      // Mark as nothing loaded so our initialized data becomes authoritative
    #####: 3599:}
        -: 3600:
function _ZN5ImGui17TableSaveSettingsEP10ImGuiTable called 0 returned 0% blocks executed 0%
    #####: 3601:void ImGui::TableSaveSettings(ImGuiTable* table)
        -: 3602:{
    #####: 3603:    table->IsSettingsDirty = false;
    #####: 3604:    if (table->Flags & ImGuiTableFlags_NoSavedSettings)
    %%%%%: 3604-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3605:        return;
    %%%%%: 3605-block 3
        -: 3606:
        -: 3607:    // Bind or create settings data
    #####: 3608:    ImGuiContext& g = *GImGui;
    #####: 3609:    ImGuiTableSettings* settings = TableGetBoundSettings(table);
    %%%%%: 3609-block 4
call    0 never executed
    #####: 3610:    if (settings == NULL)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3611:    {
    #####: 3612:        settings = TableSettingsCreate(table->ID, table->ColumnsCount);
    %%%%%: 3612-block 6
call    0 never executed
    #####: 3613:        table->SettingsOffset = g.SettingsTables.offset_from_ptr(settings);
call    0 never executed
        -: 3614:    }
    #####: 3615:    settings->ColumnsCount = (ImGuiTableColumnIdx)table->ColumnsCount;
        -: 3616:
        -: 3617:    // Serialize ImGuiTable/ImGuiTableColumn into ImGuiTableSettings/ImGuiTableColumnSettings
    #####: 3618:    IM_ASSERT(settings->ID == table->ID);
    %%%%%: 3618-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3618-block 10
call    2 never executed
    #####: 3619:    IM_ASSERT(settings->ColumnsCount == table->ColumnsCount && settings->ColumnsCountMax >= settings->ColumnsCount);
    %%%%%: 3619-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3619-block 12
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3619-block 13
    %%%%%: 3619-block 14
call    4 never executed
    #####: 3620:    ImGuiTableColumn* column = table->Columns.Data;
    #####: 3621:    ImGuiTableColumnSettings* column_settings = settings->GetColumnSettings();
    %%%%%: 3621-block 15
call    0 never executed
        -: 3622:
    #####: 3623:    bool save_ref_scale = false;
    #####: 3624:    settings->SaveFlags = ImGuiTableFlags_None;
    #####: 3625:    for (int n = 0; n < table->ColumnsCount; n++, column++, column_settings++)
    %%%%%: 3625-block 30
    %%%%%: 3625-block 31
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 3626:    {
    #####: 3627:        const float width_or_weight = (column->Flags & ImGuiTableColumnFlags_WidthStretch) ? column->StretchWeight : column->WidthRequest;
    %%%%%: 3627-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3627-block 18
    %%%%%: 3627-block 19
    #####: 3628:        column_settings->WidthOrWeight = width_or_weight;
    #####: 3629:        column_settings->Index = (ImGuiTableColumnIdx)n;
    #####: 3630:        column_settings->DisplayOrder = column->DisplayOrder;
    #####: 3631:        column_settings->SortOrder = column->SortOrder;
    #####: 3632:        column_settings->SortDirection = column->SortDirection;
    #####: 3633:        column_settings->IsEnabled = column->IsUserEnabled;
    #####: 3634:        column_settings->IsStretch = (column->Flags & ImGuiTableColumnFlags_WidthStretch) ? 1 : 0;
    #####: 3635:        if ((column->Flags & ImGuiTableColumnFlags_WidthStretch) == 0)
    %%%%%: 3635-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3636:            save_ref_scale = true;
    %%%%%: 3636-block 21
        -: 3637:
        -: 3638:        // We skip saving some data in the .ini file when they are unnecessary to restore our state.
        -: 3639:        // Note that fixed width where initial width was derived from auto-fit will always be saved as InitStretchWeightOrWidth will be 0.0f.
        -: 3640:        // FIXME-TABLE: We don't have logic to easily compare SortOrder to DefaultSortOrder yet so it's always saved when present.
    #####: 3641:        if (width_or_weight != column->InitStretchWeightOrWidth)
    %%%%%: 3641-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3642:            settings->SaveFlags |= ImGuiTableFlags_Resizable;
    %%%%%: 3642-block 23
    #####: 3643:        if (column->DisplayOrder != n)
    %%%%%: 3643-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3644:            settings->SaveFlags |= ImGuiTableFlags_Reorderable;
    %%%%%: 3644-block 25
    #####: 3645:        if (column->SortOrder != -1)
    %%%%%: 3645-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3646:            settings->SaveFlags |= ImGuiTableFlags_Sortable;
    %%%%%: 3646-block 27
    #####: 3647:        if (column->IsUserEnabled != ((column->Flags & ImGuiTableColumnFlags_DefaultHide) == 0))
    %%%%%: 3647-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3648:            settings->SaveFlags |= ImGuiTableFlags_Hideable;
    %%%%%: 3648-block 29
        -: 3649:    }
    #####: 3650:    settings->SaveFlags &= table->Flags;
    #####: 3651:    settings->RefScale = save_ref_scale ? table->RefScale : 0.0f;
    %%%%%: 3651-block 32
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3651-block 33
    %%%%%: 3651-block 34
        -: 3652:
    #####: 3653:    MarkIniSettingsDirty();
    %%%%%: 3653-block 35
call    0 never executed
        -: 3654:}
        -: 3655:
function _ZN5ImGui17TableLoadSettingsEP10ImGuiTable called 1 returned 100% blocks executed 70%
        1: 3656:void ImGui::TableLoadSettings(ImGuiTable* table)
        -: 3657:{
        1: 3658:    ImGuiContext& g = *GImGui;
        1: 3659:    table->IsSettingsRequestLoad = false;
        1: 3660:    if (table->Flags & ImGuiTableFlags_NoSavedSettings)
        1: 3660-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 3661:        return;
    %%%%%: 3661-block 3
        -: 3662:
        -: 3663:    // Bind settings
        -: 3664:    ImGuiTableSettings* settings;
        1: 3665:    if (table->SettingsOffset == -1)
        1: 3665-block 4
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 3666:    {
        1: 3667:        settings = TableSettingsFindByID(table->ID);
        1: 3667-block 5
call    0 returned 1
        1: 3668:        if (settings == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 3669:            return;
    %%%%%: 3669-block 7
        1: 3670:        if (settings->ColumnsCount != table->ColumnsCount) // Allow settings if columns count changed. We could otherwise decide to return...
        1: 3670-block 8
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 3671:            table->IsSettingsDirty = true;
    %%%%%: 3671-block 9
        1: 3672:        table->SettingsOffset = g.SettingsTables.offset_from_ptr(settings);
        1: 3672-block 10
call    0 returned 1
        -: 3673:    }
        -: 3674:    else
        -: 3675:    {
    #####: 3676:        settings = TableGetBoundSettings(table);
    %%%%%: 3676-block 12
call    0 never executed
        -: 3677:    }
        -: 3678:
        1: 3679:    table->SettingsLoadedFlags = settings->SaveFlags;
        1: 3680:    table->RefScale = settings->RefScale;
        -: 3681:
        -: 3682:    // Serialize ImGuiTableSettings/ImGuiTableColumnSettings into ImGuiTable/ImGuiTableColumn
        1: 3683:    ImGuiTableColumnSettings* column_settings = settings->GetColumnSettings();
        1: 3683-block 14
call    0 returned 1
        1: 3684:    ImU64 display_order_mask = 0;
        5: 3685:    for (int data_n = 0; data_n < settings->ColumnsCount; data_n++, column_settings++)
        4: 3685-block 29
        5: 3685-block 30
branch  0 taken 4
branch  1 taken 1 (fallthrough)
        -: 3686:    {
        4: 3687:        int column_n = column_settings->Index;
       4*: 3688:        if (column_n < 0 || column_n >= table->ColumnsCount)
        4: 3688-block 16
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4: 3688-block 17
branch  2 taken 0 (fallthrough)
branch  3 taken 4
    #####: 3689:            continue;
    %%%%%: 3689-block 18
        -: 3690:
        4: 3691:        ImGuiTableColumn* column = &table->Columns[column_n];
        4: 3691-block 19
call    0 returned 4
        4: 3692:        if (settings->SaveFlags & ImGuiTableFlags_Resizable)
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        -: 3693:        {
        4: 3694:            if (column_settings->IsStretch)
        4: 3694-block 21
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4: 3695:                column->StretchWeight = column_settings->WidthOrWeight;
        4: 3695-block 22
        -: 3696:            else
    #####: 3697:                column->WidthRequest = column_settings->WidthOrWeight;
    %%%%%: 3697-block 23
        4: 3698:            column->AutoFitQueue = 0x00;
        4: 3698-block 24
        -: 3699:        }
        4: 3700:        if (settings->SaveFlags & ImGuiTableFlags_Reorderable)
        4: 3700-block 25
branch  0 taken 0 (fallthrough)
branch  1 taken 4
    #####: 3701:            column->DisplayOrder = column_settings->DisplayOrder;
    %%%%%: 3701-block 26
        -: 3702:        else
        4: 3703:            column->DisplayOrder = (ImGuiTableColumnIdx)column_n;
        4: 3703-block 27
        4: 3704:        display_order_mask |= (ImU64)1 << column->DisplayOrder;
        4: 3705:        column->IsUserEnabled = column->IsUserEnabledNextFrame = column_settings->IsEnabled;
        4: 3706:        column->SortOrder = column_settings->SortOrder;
        4: 3707:        column->SortDirection = column_settings->SortDirection;
        4: 3707-block 28
        -: 3708:    }
        -: 3709:
        -: 3710:    // Validate and fix invalid display order data
       1*: 3711:    const ImU64 expected_display_order_mask = (settings->ColumnsCount == 64) ? ~0 : ((ImU64)1 << settings->ColumnsCount) - 1;
        1: 3711-block 31
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 3711-block 32
    %%%%%: 3711-block 33
        1: 3712:    if (display_order_mask != expected_display_order_mask)
        1: 3712-block 34
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 3713:        for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
    %%%%%: 3713-block 35
    %%%%%: 3713-block 38
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3714:            table->Columns[column_n].DisplayOrder = (ImGuiTableColumnIdx)column_n;
    %%%%%: 3714-block 36
call    0 never executed
        -: 3715:
        -: 3716:    // Rebuild index
        5: 3717:    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
        1: 3717-block 39
        5: 3717-block 43
branch  0 taken 4
branch  1 taken 1 (fallthrough)
        4: 3718:        table->DisplayOrderToIndex[table->Columns[column_n].DisplayOrder] = (ImGuiTableColumnIdx)column_n;
        4: 3718-block 40
call    0 returned 4
call    1 returned 4
        -: 3719:}
        -: 3720:
function _ZL29TableSettingsHandler_ClearAllP12ImGuiContextP20ImGuiSettingsHandler called 0 returned 0% blocks executed 0%
    #####: 3721:static void TableSettingsHandler_ClearAll(ImGuiContext* ctx, ImGuiSettingsHandler*)
        -: 3722:{
    #####: 3723:    ImGuiContext& g = *ctx;
    #####: 3724:    for (int i = 0; i != g.Tables.GetMapSize(); i++)
    %%%%%: 3724-block 2
    %%%%%: 3724-block 6
    %%%%%: 3724-block 7
call    0 never executed
branch  1 never executed
branch  2 never executed (fallthrough)
    #####: 3725:        if (ImGuiTable* table = g.Tables.TryGetMapData(i))
    %%%%%: 3725-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 3726:            table->SettingsOffset = -1;
    %%%%%: 3726-block 5
    #####: 3727:    g.SettingsTables.clear();
    %%%%%: 3727-block 9
call    0 never executed
    #####: 3728:}
        -: 3729:
        -: 3730:// Apply to existing windows (if any)
function _ZL29TableSettingsHandler_ApplyAllP12ImGuiContextP20ImGuiSettingsHandler called 1 returned 100% blocks executed 50%
        1: 3731:static void TableSettingsHandler_ApplyAll(ImGuiContext* ctx, ImGuiSettingsHandler*)
        -: 3732:{
        1: 3733:    ImGuiContext& g = *ctx;
       1*: 3734:    for (int i = 0; i != g.Tables.GetMapSize(); i++)
        1: 3734-block 2
    %%%%%: 3734-block 6
        1: 3734-block 7
call    0 returned 1
branch  1 taken 0
branch  2 taken 1 (fallthrough)
    #####: 3735:        if (ImGuiTable* table = g.Tables.TryGetMapData(i))
    %%%%%: 3735-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -: 3736:        {
    #####: 3737:            table->IsSettingsRequestLoad = true;
    #####: 3738:            table->SettingsOffset = -1;
    %%%%%: 3738-block 5
        -: 3739:        }
        1: 3740:}
        -: 3741:
function _ZL29TableSettingsHandler_ReadOpenP12ImGuiContextP20ImGuiSettingsHandlerPKc called 7 returned 100% blocks executed 62%
        7: 3742:static void* TableSettingsHandler_ReadOpen(ImGuiContext*, ImGuiSettingsHandler*, const char* name)
        -: 3743:{
        7: 3744:    ImGuiID id = 0;
        7: 3745:    int columns_count = 0;
        7: 3746:    if (sscanf(name, "0x%08X,%d", &id, &columns_count) < 2)
        7: 3746-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 7
    #####: 3747:        return NULL;
    %%%%%: 3747-block 3
        -: 3748:
        7: 3749:    if (ImGuiTableSettings* settings = ImGui::TableSettingsFindByID(id))
        7: 3749-block 4
call    0 returned 7
branch  1 taken 7 (fallthrough)
branch  2 taken 0 (throw)
        7: 3749-block 5
branch  3 taken 0 (fallthrough)
branch  4 taken 7
        -: 3750:    {
    #####: 3751:        if (settings->ColumnsCountMax >= columns_count)
    %%%%%: 3751-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3752:        {
    #####: 3753:            TableSettingsInit(settings, id, columns_count, settings->ColumnsCountMax); // Recycle
    %%%%%: 3753-block 7
call    0 never executed
    #####: 3754:            return settings;
        -: 3755:        }
    #####: 3756:        settings->ID = 0; // Invalidate storage, we won't fit because of a count change
    %%%%%: 3756-block 9
        -: 3757:    }
        7: 3758:    return ImGui::TableSettingsCreate(id, columns_count);
        7: 3758-block 10
call    0 returned 7
branch  1 taken 7 (fallthrough)
branch  2 taken 0 (throw)
        7: 3758-block 11
        -: 3759:}
        -: 3760:
function _ZL29TableSettingsHandler_ReadLineP12ImGuiContextP20ImGuiSettingsHandlerPvPKc called 26 returned 100% blocks executed 51%
       26: 3761:static void TableSettingsHandler_ReadLine(ImGuiContext*, ImGuiSettingsHandler*, void* entry, const char* line)
        -: 3762:{
        -: 3763:    // "Column 0  UserID=0x42AD2D21 Width=100 Visible=1 Order=0 Sort=0v"
       26: 3764:    ImGuiTableSettings* settings = (ImGuiTableSettings*)entry;
       26: 3765:    float f = 0.0f;
       26: 3766:    int column_n = 0, r = 0, n = 0;
        -: 3767:
      26*: 3768:    if (sscanf(line, "RefScale=%f", &f) == 1) { settings->RefScale = f; return; }
       26: 3768-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 26
    %%%%%: 3768-block 3
    %%%%%: 3768-block 33
        -: 3769:
       26: 3770:    if (sscanf(line, "Column %d%n", &column_n, &r) == 1)
       26: 3770-block 4
branch  0 taken 26 (fallthrough)
branch  1 taken 0
        -: 3771:    {
       26: 3772:        if (column_n < 0 || column_n >= settings->ColumnsCount)
       26: 3772-block 5
branch  0 taken 26 (fallthrough)
branch  1 taken 0
       26: 3772-block 6
branch  2 taken 0 (fallthrough)
branch  3 taken 26
    #####: 3773:            return;
    %%%%%: 3773-block 7
       26: 3774:        line = ImStrSkipBlank(line + r);
       26: 3774-block 8
call    0 returned 26
branch  1 taken 26 (fallthrough)
branch  2 taken 0 (throw)
       26: 3775:        char c = 0;
       26: 3776:        ImGuiTableColumnSettings* column = settings->GetColumnSettings() + column_n;
       26: 3776-block 9
call    0 returned 26
       26: 3777:        column->Index = (ImGuiTableColumnIdx)column_n;
      26*: 3778:        if (sscanf(line, "UserID=0x%08X%n", (ImU32*)&n, &r)==1) { line = ImStrSkipBlank(line + r); column->UserID = (ImGuiID)n; }
branch  0 taken 0 (fallthrough)
branch  1 taken 26
    %%%%%: 3778-block 11
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 3778-block 12
      26*: 3779:        if (sscanf(line, "Width=%d%n", &n, &r) == 1)            { line = ImStrSkipBlank(line + r); column->WidthOrWeight = (float)n; column->IsStretch = 0; settings->SaveFlags |= ImGuiTableFlags_Resizable; }
       26: 3779-block 13
branch  0 taken 0 (fallthrough)
branch  1 taken 26
    %%%%%: 3779-block 14
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 3779-block 15
       26: 3780:        if (sscanf(line, "Weight=%f%n", &f, &r) == 1)           { line = ImStrSkipBlank(line + r); column->WidthOrWeight = f; column->IsStretch = 1; settings->SaveFlags |= ImGuiTableFlags_Resizable; }
       26: 3780-block 16
branch  0 taken 26 (fallthrough)
branch  1 taken 0
       26: 3780-block 17
call    2 returned 26
branch  3 taken 26 (fallthrough)
branch  4 taken 0 (throw)
       26: 3780-block 18
      26*: 3781:        if (sscanf(line, "Visible=%d%n", &n, &r) == 1)          { line = ImStrSkipBlank(line + r); column->IsEnabled = (ImU8)n; settings->SaveFlags |= ImGuiTableFlags_Hideable; }
       26: 3781-block 19
branch  0 taken 0 (fallthrough)
branch  1 taken 26
    %%%%%: 3781-block 20
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 3781-block 21
      26*: 3782:        if (sscanf(line, "Order=%d%n", &n, &r) == 1)            { line = ImStrSkipBlank(line + r); column->DisplayOrder = (ImGuiTableColumnIdx)n; settings->SaveFlags |= ImGuiTableFlags_Reorderable; }
       26: 3782-block 22
branch  0 taken 0 (fallthrough)
branch  1 taken 26
    %%%%%: 3782-block 23
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 3782-block 24
      26*: 3783:        if (sscanf(line, "Sort=%d%c%n", &n, &c, &r) == 2)       { line = ImStrSkipBlank(line + r); column->SortOrder = (ImGuiTableColumnIdx)n; column->SortDirection = (c == '^') ? ImGuiSortDirection_Descending : ImGuiSortDirection_Ascending; settings->SaveFlags |= ImGuiTableFlags_Sortable; }
       26: 3783-block 25
branch  0 taken 0 (fallthrough)
branch  1 taken 26
    %%%%%: 3783-block 26
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 3783-block 27
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 3783-block 28
    %%%%%: 3783-block 29
    %%%%%: 3783-block 30
        -: 3784:    }
        -: 3785:}
        -: 3786:
function _ZL29TableSettingsHandler_WriteAllP12ImGuiContextP20ImGuiSettingsHandlerP15ImGuiTextBuffer called 2 returned 100% blocks executed 60%
        2: 3787:static void TableSettingsHandler_WriteAll(ImGuiContext* ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* buf)
        -: 3788:{
        2: 3789:    ImGuiContext& g = *ctx;
       16: 3790:    for (ImGuiTableSettings* settings = g.SettingsTables.begin(); settings != NULL; settings = g.SettingsTables.next_chunk(settings))
        2: 3790-block 2
call    0 returned 2
       14: 3790-block 50
call    1 returned 14
       16: 3790-block 52
branch  2 taken 14
branch  3 taken 2 (fallthrough)
        -: 3791:    {
      14*: 3792:        if (settings->ID == 0) // Skip ditched settings
       14: 3792-block 3
branch  0 taken 0 (fallthrough)
branch  1 taken 14
    #####: 3793:            continue;
    %%%%%: 3793-block 4
        -: 3794:
        -: 3795:        // TableSaveSettings() may clear some of those flags when we establish that the data can be stripped
        -: 3796:        // (e.g. Order was unchanged)
       14: 3797:        const bool save_size    = (settings->SaveFlags & ImGuiTableFlags_Resizable) != 0;
       14: 3798:        const bool save_visible = (settings->SaveFlags & ImGuiTableFlags_Hideable) != 0;
       14: 3799:        const bool save_order   = (settings->SaveFlags & ImGuiTableFlags_Reorderable) != 0;
       14: 3800:        const bool save_sort    = (settings->SaveFlags & ImGuiTableFlags_Sortable) != 0;
      14*: 3801:        if (!save_size && !save_visible && !save_order && !save_sort)
       14: 3801-block 5
branch  0 taken 0 (fallthrough)
branch  1 taken 14
    %%%%%: 3801-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3801-block 7
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 3801-block 8
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 3802:            continue;
    %%%%%: 3802-block 9
        -: 3803:
       14: 3804:        buf->reserve(buf->size() + 30 + settings->ColumnsCount * 50); // ballpark reserve
       14: 3804-block 10
call    0 returned 14
call    1 returned 14
       14: 3805:        buf->appendf("[%s][0x%08X,%d]\n", handler->TypeName, settings->ID, settings->ColumnsCount);
call    0 returned 14
       14: 3806:        if (settings->RefScale != 0.0f)
branch  0 taken 0 (fallthrough)
branch  1 taken 14
    #####: 3807:            buf->appendf("RefScale=%g\n", settings->RefScale);
    %%%%%: 3807-block 14
call    0 never executed
       14: 3808:        ImGuiTableColumnSettings* column = settings->GetColumnSettings();
       14: 3808-block 15
call    0 returned 14
       66: 3809:        for (int column_n = 0; column_n < settings->ColumnsCount; column_n++, column++)
       52: 3809-block 47
       66: 3809-block 48
branch  0 taken 52
branch  1 taken 14 (fallthrough)
        -: 3810:        {
        -: 3811:            // "Column 0  UserID=0x42AD2D21 Width=100 Visible=1 Order=0 Sort=0v"
      52*: 3812:            bool save_column = column->UserID != 0 || save_size || save_visible || save_order || (save_sort && column->SortOrder != -1);
       52: 3812-block 17
branch  0 taken 52 (fallthrough)
branch  1 taken 0
       52: 3812-block 18
branch  2 taken 0 (fallthrough)
branch  3 taken 52
    %%%%%: 3812-block 19
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 3812-block 20
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 3812-block 21
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%: 3812-block 22
branch 10 never executed (fallthrough)
branch 11 never executed
       52: 3812-block 23
    %%%%%: 3812-block 24
      52*: 3813:            if (!save_column)
       52: 3813-block 25
branch  0 taken 0 (fallthrough)
branch  1 taken 52
    #####: 3814:                continue;
    %%%%%: 3814-block 26
       52: 3815:            buf->appendf("Column %-2d", column_n);
       52: 3815-block 27
call    0 returned 52
      52*: 3816:            if (column->UserID != 0)                    { buf->appendf(" UserID=%08X", column->UserID); }
branch  0 taken 0 (fallthrough)
branch  1 taken 52
    %%%%%: 3816-block 29
call    2 never executed
       52: 3817:            if (save_size && column->IsStretch)         { buf->appendf(" Weight=%.4f", column->WidthOrWeight); }
       52: 3817-block 30
branch  0 taken 52 (fallthrough)
branch  1 taken 0
       52: 3817-block 31
branch  2 taken 52 (fallthrough)
branch  3 taken 0
       52: 3817-block 32
call    4 returned 52
      52*: 3818:            if (save_size && !column->IsStretch)        { buf->appendf(" Width=%d", (int)column->WidthOrWeight); }
       52: 3818-block 33
branch  0 taken 52 (fallthrough)
branch  1 taken 0
       52: 3818-block 34
branch  2 taken 0 (fallthrough)
branch  3 taken 52
    %%%%%: 3818-block 35
call    4 never executed
      52*: 3819:            if (save_visible)                           { buf->appendf(" Visible=%d", column->IsEnabled); }
       52: 3819-block 36
branch  0 taken 0 (fallthrough)
branch  1 taken 52
    %%%%%: 3819-block 37
call    2 never executed
      52*: 3820:            if (save_order)                             { buf->appendf(" Order=%d", column->DisplayOrder); }
       52: 3820-block 38
branch  0 taken 0 (fallthrough)
branch  1 taken 52
    %%%%%: 3820-block 39
call    2 never executed
      52*: 3821:            if (save_sort && column->SortOrder != -1)   { buf->appendf(" Sort=%d%c", column->SortOrder, (column->SortDirection == ImGuiSortDirection_Ascending) ? 'v' : '^'); }
       52: 3821-block 40
branch  0 taken 0 (fallthrough)
branch  1 taken 52
    %%%%%: 3821-block 41
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3821-block 42
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 3821-block 43
    %%%%%: 3821-block 44
    %%%%%: 3821-block 45
call    6 never executed
       52: 3822:            buf->append("\n");
       52: 3822-block 46
call    0 returned 52
        -: 3823:        }
       14: 3824:        buf->append("\n");
       14: 3824-block 49
call    0 returned 14
        -: 3825:    }
        2: 3826:}
        -: 3827:
function _ZN5ImGui31TableSettingsAddSettingsHandlerEv called 1 returned 100% blocks executed 100%
        1: 3828:void ImGui::TableSettingsAddSettingsHandler()
        -: 3829:{
        1: 3830:    ImGuiSettingsHandler ini_handler;
        1: 3830-block 2
call    0 returned 1
        1: 3831:    ini_handler.TypeName = "Table";
        1: 3832:    ini_handler.TypeHash = ImHashStr("Table");
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 3833:    ini_handler.ClearAllFn = TableSettingsHandler_ClearAll;
        1: 3834:    ini_handler.ReadOpenFn = TableSettingsHandler_ReadOpen;
        1: 3835:    ini_handler.ReadLineFn = TableSettingsHandler_ReadLine;
        1: 3836:    ini_handler.ApplyAllFn = TableSettingsHandler_ApplyAll;
        1: 3837:    ini_handler.WriteAllFn = TableSettingsHandler_WriteAll;
        1: 3838:    AddSettingsHandler(&ini_handler);
        1: 3838-block 4
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 3839:}
        1: 3839-block 5
        -: 3840:
        -: 3841://-------------------------------------------------------------------------
        -: 3842:// [SECTION] Tables: Garbage Collection
        -: 3843://-------------------------------------------------------------------------
        -: 3844:// - TableRemove() [Internal]
        -: 3845:// - TableGcCompactTransientBuffers() [Internal]
        -: 3846:// - TableGcCompactSettings() [Internal]
        -: 3847://-------------------------------------------------------------------------
        -: 3848:
        -: 3849:// Remove Table (currently only used by TestEngine)
function _ZN5ImGui11TableRemoveEP10ImGuiTable called 0 returned 0% blocks executed 0%
    #####: 3850:void ImGui::TableRemove(ImGuiTable* table)
        -: 3851:{
        -: 3852:    //IMGUI_DEBUG_PRINT("TableRemove() id=0x%08X\n", table->ID);
    #####: 3853:    ImGuiContext& g = *GImGui;
    #####: 3854:    int table_idx = g.Tables.GetIndex(table);
    %%%%%: 3854-block 2
call    0 never executed
        -: 3855:    //memset(table->RawData.Data, 0, table->RawData.size_in_bytes());
        -: 3856:    //memset(table, 0, sizeof(ImGuiTable));
    #####: 3857:    g.Tables.Remove(table->ID, table);
call    0 never executed
    #####: 3858:    g.TablesLastTimeActive[table_idx] = -1.0f;
call    0 never executed
    #####: 3859:}
        -: 3860:
        -: 3861:// Free up/compact internal Table buffers for when it gets unused
function _ZN5ImGui30TableGcCompactTransientBuffersEP10ImGuiTable called 0 returned 0% blocks executed 0%
    #####: 3862:void ImGui::TableGcCompactTransientBuffers(ImGuiTable* table)
        -: 3863:{
        -: 3864:    //IMGUI_DEBUG_PRINT("TableGcCompactTransientBuffers() id=0x%08X\n", table->ID);
    #####: 3865:    ImGuiContext& g = *GImGui;
    #####: 3866:    IM_ASSERT(table->MemoryCompacted == false);
    %%%%%: 3866-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3866-block 3
call    2 never executed
    #####: 3867:    table->SortSpecs.Specs = NULL;
    #####: 3868:    table->SortSpecsMulti.clear();
    %%%%%: 3868-block 4
call    0 never executed
    #####: 3869:    table->IsSortSpecsDirty = true; // FIXME: In theory shouldn't have to leak into user performing a sort on resume.
    #####: 3870:    table->ColumnsNames.clear();
call    0 never executed
    #####: 3871:    table->MemoryCompacted = true;
    #####: 3872:    for (int n = 0; n < table->ColumnsCount; n++)
    %%%%%: 3872-block 9
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3873:        table->Columns[n].NameOffset = -1;
    %%%%%: 3873-block 7
call    0 never executed
    #####: 3874:    g.TablesLastTimeActive[g.Tables.GetIndex(table)] = -1.0f;
    %%%%%: 3874-block 10
call    0 never executed
call    1 never executed
    #####: 3875:}
        -: 3876:
function _ZN5ImGui30TableGcCompactTransientBuffersEP18ImGuiTableTempData called 0 returned 0% blocks executed 0%
    #####: 3877:void ImGui::TableGcCompactTransientBuffers(ImGuiTableTempData* temp_data)
        -: 3878:{
    #####: 3879:    temp_data->DrawSplitter.ClearFreeMemory();
    %%%%%: 3879-block 2
call    0 never executed
    #####: 3880:    temp_data->LastTimeActive = -1.0f;
    #####: 3881:}
        -: 3882:
        -: 3883:// Compact and remove unused settings data (currently only used by TestEngine)
function _ZN5ImGui22TableGcCompactSettingsEv called 0 returned 0% blocks executed 0%
    #####: 3884:void ImGui::TableGcCompactSettings()
        -: 3885:{
    #####: 3886:    ImGuiContext& g = *GImGui;
    #####: 3887:    int required_memory = 0;
    #####: 3888:    for (ImGuiTableSettings* settings = g.SettingsTables.begin(); settings != NULL; settings = g.SettingsTables.next_chunk(settings))
    %%%%%: 3888-block 2
call    0 never executed
    %%%%%: 3888-block 6
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 3888-block 7
    %%%%%: 3888-block 8
branch  4 never executed
branch  5 never executed (fallthrough)
    #####: 3889:        if (settings->ID != 0)
    %%%%%: 3889-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3890:            required_memory += (int)TableSettingsCalcChunkSize(settings->ColumnsCount);
    %%%%%: 3890-block 4
call    0 never executed
    #####: 3891:    if (required_memory == g.SettingsTables.Buf.Size)
    %%%%%: 3891-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3892:        return;
    %%%%%: 3892-block 10
    #####: 3893:    ImChunkStream<ImGuiTableSettings> new_chunk_stream;
    %%%%%: 3893-block 11
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3894:    new_chunk_stream.Buf.reserve(required_memory);
    %%%%%: 3894-block 12
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3895:    for (ImGuiTableSettings* settings = g.SettingsTables.begin(); settings != NULL; settings = g.SettingsTables.next_chunk(settings))
    %%%%%: 3895-block 13
call    0 never executed
    %%%%%: 3895-block 19
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 3895-block 20
    %%%%%: 3895-block 21
branch  4 never executed
branch  5 never executed (fallthrough)
    #####: 3896:        if (settings->ID != 0)
    %%%%%: 3896-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3897:            memcpy(new_chunk_stream.alloc_chunk(TableSettingsCalcChunkSize(settings->ColumnsCount)), settings, TableSettingsCalcChunkSize(settings->ColumnsCount));
    %%%%%: 3897-block 15
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 3897-block 18
    #####: 3898:    g.SettingsTables.swap(new_chunk_stream);
    %%%%%: 3898-block 22
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3899:}
    %%%%%: 3899-block 23
call    0 never executed
    $$$$$: 3899-block 26
call    1 never executed
        -: 3900:
        -: 3901:
        -: 3902://-------------------------------------------------------------------------
        -: 3903:// [SECTION] Tables: Debugging
        -: 3904://-------------------------------------------------------------------------
        -: 3905:// - DebugNodeTable() [Internal]
        -: 3906://-------------------------------------------------------------------------
        -: 3907:
        -: 3908:#ifndef IMGUI_DISABLE_DEBUG_TOOLS
        -: 3909:
function _ZL33DebugNodeTableGetSizingPolicyDesci called 0 returned 0% blocks executed 0%
    #####: 3910:static const char* DebugNodeTableGetSizingPolicyDesc(ImGuiTableFlags sizing_policy)
        -: 3911:{
    #####: 3912:    sizing_policy &= ImGuiTableFlags_SizingMask_;
    #####: 3913:    if (sizing_policy == ImGuiTableFlags_SizingFixedFit)    { return "FixedFit"; }
    %%%%%: 3913-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3913-block 3
    #####: 3914:    if (sizing_policy == ImGuiTableFlags_SizingFixedSame)   { return "FixedSame"; }
    %%%%%: 3914-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3914-block 5
    #####: 3915:    if (sizing_policy == ImGuiTableFlags_SizingStretchProp) { return "StretchProp"; }
    %%%%%: 3915-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3915-block 7
    #####: 3916:    if (sizing_policy == ImGuiTableFlags_SizingStretchSame) { return "StretchSame"; }
    %%%%%: 3916-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3916-block 9
    #####: 3917:    return "N/A";
    %%%%%: 3917-block 10
        -: 3918:}
        -: 3919:
function _ZN5ImGui14DebugNodeTableEP10ImGuiTable called 0 returned 0% blocks executed 0%
    #####: 3920:void ImGui::DebugNodeTable(ImGuiTable* table)
        -: 3921:{
    #####: 3922:    ImGuiContext& g = *GImGui;
    #####: 3923:    const bool is_active = (table->LastFrameActive >= g.FrameCount - 2); // Note that fully clipped early out scrolling tables will appear as inactive here.
    #####: 3924:    if (!is_active) { PushStyleColor(ImGuiCol_Text, GetStyleColorVec4(ImGuiCol_TextDisabled)); }
    %%%%%: 3924-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3924-block 3
call    2 never executed
call    3 never executed
    #####: 3925:    bool open = TreeNode(table, "Table 0x%08X (%d columns, in '%s')%s", table->ID, table->ColumnsCount, table->OuterWindow->Name, is_active ? "" : " *Inactive*");
    %%%%%: 3925-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3925-block 6
    %%%%%: 3925-block 7
    %%%%%: 3925-block 8
call    2 never executed
    #####: 3926:    if (!is_active) { PopStyleColor(); }
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3926-block 10
call    2 never executed
    #####: 3927:    if (IsItemHovered())
    %%%%%: 3927-block 11
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 3928:        GetForegroundDrawList()->AddRect(table->OuterRect.Min, table->OuterRect.Max, IM_COL32(255, 255, 0, 255));
    %%%%%: 3928-block 13
call    0 never executed
call    1 never executed
    #####: 3929:    if (IsItemVisible() && table->HoveredColumnBody != -1)
    %%%%%: 3929-block 15
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 3929-block 17
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 3929-block 18
    %%%%%: 3929-block 19
    %%%%%: 3929-block 20
branch  5 never executed (fallthrough)
branch  6 never executed
    #####: 3930:        GetForegroundDrawList()->AddRect(GetItemRectMin(), GetItemRectMax(), IM_COL32(255, 255, 0, 255));
    %%%%%: 3930-block 21
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 3930-block 23
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    %%%%%: 3930-block 24
call    7 never executed
branch  8 never executed (fallthrough)
branch  9 never executed (throw)
    %%%%%: 3930-block 25
    $$$$$: 3930-block 102
    $$$$$: 3930-block 103
call   10 never executed
    #####: 3931:    if (!open)
    %%%%%: 3931-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3932:        return;
    %%%%%: 3932-block 27
    #####: 3933:    if (table->InstanceCurrent > 0)
    %%%%%: 3933-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3934:        Text("** %d instances of same table! Some data below will refer to last instance.", table->InstanceCurrent + 1);
    %%%%%: 3934-block 29
call    0 never executed
    #####: 3935:    if (g.IO.ConfigDebugIsDebuggerPresent)
    %%%%%: 3935-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3936:    {
    #####: 3937:        if (DebugBreakButton("**DebugBreak**", "in BeginTable()"))
    %%%%%: 3937-block 31
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 3938:            g.DebugBreakInTable = table->ID;
    %%%%%: 3938-block 33
    #####: 3939:        SameLine();
    %%%%%: 3939-block 34
call    0 never executed
        -: 3940:    }
        -: 3941:
    #####: 3942:    bool clear_settings = SmallButton("Clear settings");
    %%%%%: 3942-block 35
call    0 never executed
    #####: 3943:    BulletText("OuterRect: Pos: (%.1f,%.1f) Size: (%.1f,%.1f) Sizing: '%s'", table->OuterRect.Min.x, table->OuterRect.Min.y, table->OuterRect.GetWidth(), table->OuterRect.GetHeight(), DebugNodeTableGetSizingPolicyDesc(table->Flags));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 3944:    BulletText("ColumnsGivenWidth: %.1f, ColumnsAutoFitWidth: %.1f, InnerWidth: %.1f%s", table->ColumnsGivenWidth, table->ColumnsAutoFitWidth, table->InnerWidth, table->InnerWidth == 0.0f ? " (auto)" : "");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3944-block 41
    %%%%%: 3944-block 42
    %%%%%: 3944-block 43
call    2 never executed
    #####: 3945:    BulletText("CellPaddingX: %.1f, CellSpacingX: %.1f/%.1f, OuterPaddingX: %.1f", table->CellPaddingX, table->CellSpacingX1, table->CellSpacingX2, table->OuterPaddingX);
call    0 never executed
    #####: 3946:    BulletText("HoveredColumnBody: %d, HoveredColumnBorder: %d", table->HoveredColumnBody, table->HoveredColumnBorder);
call    0 never executed
    #####: 3947:    BulletText("ResizedColumn: %d, ReorderColumn: %d, HeldHeaderColumn: %d", table->ResizedColumn, table->ReorderColumn, table->HeldHeaderColumn);
call    0 never executed
    #####: 3948:    for (int n = 0; n < table->InstanceCurrent + 1; n++)
    %%%%%: 3948-block 51
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 3949:    {
    #####: 3950:        ImGuiTableInstanceData* table_instance = TableGetInstanceData(table, n);
    %%%%%: 3950-block 48
call    0 never executed
    #####: 3951:        BulletText("Instance %d: HoveredRow: %d, LastOuterHeight: %.2f", n, table_instance->HoveredRowLast, table_instance->LastOuterHeight);
call    0 never executed
        -: 3952:    }
        -: 3953:    //BulletText("BgDrawChannels: %d/%d", 0, table->BgDrawChannelUnfrozen);
    #####: 3954:    float sum_weights = 0.0f;
    #####: 3955:    for (int n = 0; n < table->ColumnsCount; n++)
    %%%%%: 3955-block 52
    %%%%%: 3955-block 57
    %%%%%: 3955-block 58
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3956:        if (table->Columns[n].Flags & ImGuiTableColumnFlags_WidthStretch)
    %%%%%: 3956-block 53
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 3957:            sum_weights += table->Columns[n].StretchWeight;
    %%%%%: 3957-block 55
call    0 never executed
    #####: 3958:    for (int n = 0; n < table->ColumnsCount; n++)
    %%%%%: 3958-block 59
    %%%%%: 3958-block 93
    %%%%%: 3958-block 94
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 3959:    {
    #####: 3960:        ImGuiTableColumn* column = &table->Columns[n];
    %%%%%: 3960-block 60
call    0 never executed
    #####: 3961:        const char* name = TableGetColumnName(table, n);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 3962:        char buf[512];
    #####: 3963:        ImFormatString(buf, IM_ARRAYSIZE(buf),
    %%%%%: 3963-block 63
    %%%%%: 3963-block 64
    %%%%%: 3963-block 66
    %%%%%: 3963-block 67
    %%%%%: 3963-block 69
    %%%%%: 3963-block 70
    %%%%%: 3963-block 75
    %%%%%: 3963-block 76
    %%%%%: 3963-block 79
    %%%%%: 3963-block 81
    %%%%%: 3963-block 82
        -: 3964:            "Column %d order %d '%s': offset %+.2f to %+.2f%s\n"
        -: 3965:            "Enabled: %d, VisibleX/Y: %d/%d, RequestOutput: %d, SkipItems: %d, DrawChannels: %d,%d\n"
        -: 3966:            "WidthGiven: %.1f, Request/Auto: %.1f/%.1f, StretchWeight: %.3f (%.1f%%)\n"
        -: 3967:            "MinX: %.1f, MaxX: %.1f (%+.1f), ClipRect: %.1f to %.1f (+%.1f)\n"
        -: 3968:            "ContentWidth: %.1f,%.1f, HeadersUsed/Ideal %.1f/%.1f\n"
        -: 3969:            "Sort: %d%s, UserID: 0x%08X, Flags: 0x%04X: %s%s%s..",
    #####: 3970:            n, column->DisplayOrder, name, column->MinX - table->WorkRect.Min.x, column->MaxX - table->WorkRect.Min.x, (n < table->FreezeColumnsRequest) ? " (Frozen)" : "",
    %%%%%: 3970-block 83
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3971:            column->IsEnabled, column->IsVisibleX, column->IsVisibleY, column->IsRequestOutput, column->IsSkipItems, column->DrawChannelFrozen, column->DrawChannelUnfrozen,
    #####: 3972:            column->WidthGiven, column->WidthRequest, column->WidthAuto, column->StretchWeight, column->StretchWeight > 0.0f ? (column->StretchWeight / sum_weights) * 100.0f : 0.0f,
    %%%%%: 3972-block 78
    %%%%%: 3972-block 80
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3973:            column->MinX, column->MaxX, column->MaxX - column->MinX, column->ClipRect.Min.x, column->ClipRect.Max.x, column->ClipRect.Max.x - column->ClipRect.Min.x,
    #####: 3974:            column->ContentMaxXFrozen - column->WorkMinX, column->ContentMaxXUnfrozen - column->WorkMinX, column->ContentMaxXHeadersUsed - column->WorkMinX, column->ContentMaxXHeadersIdeal - column->WorkMinX,
    #####: 3975:            column->SortOrder, (column->SortDirection == ImGuiSortDirection_Ascending) ? " (Asc)" : (column->SortDirection == ImGuiSortDirection_Descending) ? " (Des)" : "", column->UserID, column->Flags,
    %%%%%: 3975-block 71
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3975-block 72
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3975-block 73
    %%%%%: 3975-block 74
    %%%%%: 3975-block 77
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 3976:            (column->Flags & ImGuiTableColumnFlags_WidthStretch) ? "WidthStretch " : "",
    %%%%%: 3976-block 68
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3977:            (column->Flags & ImGuiTableColumnFlags_WidthFixed) ? "WidthFixed " : "",
    %%%%%: 3977-block 65
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3978:            (column->Flags & ImGuiTableColumnFlags_NoResize) ? "NoResize " : "");
    %%%%%: 3978-block 62
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3979:        Bullet();
    %%%%%: 3979-block 84
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3980:        Selectable(buf);
    %%%%%: 3980-block 85
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$: 3980-block 104
    #####: 3981:        if (IsItemHovered())
    %%%%%: 3981-block 87
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 3981-block 88
branch  3 never executed (fallthrough)
branch  4 never executed
        -: 3982:        {
    #####: 3983:            ImRect r(column->MinX, table->OuterRect.Min.y, column->MaxX, table->OuterRect.Max.y);
    %%%%%: 3983-block 89
call    0 never executed
    #####: 3984:            GetForegroundDrawList()->AddRect(r.Min, r.Max, IM_COL32(255, 255, 0, 255));
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 3984-block 91
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
        -: 3985:        }
        -: 3986:    }
    #####: 3987:    if (ImGuiTableSettings* settings = TableGetBoundSettings(table))
    %%%%%: 3987-block 95
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 3988:        DebugNodeTableSettings(settings);
    %%%%%: 3988-block 97
call    0 never executed
    #####: 3989:    if (clear_settings)
    %%%%%: 3989-block 98
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3990:        table->IsResetAllRequest = true;
    %%%%%: 3990-block 99
    #####: 3991:    TreePop();
    %%%%%: 3991-block 100
call    0 never executed
        -: 3992:}
        -: 3993:
function _ZN5ImGui22DebugNodeTableSettingsEP18ImGuiTableSettings called 0 returned 0% blocks executed 0%
    #####: 3994:void ImGui::DebugNodeTableSettings(ImGuiTableSettings* settings)
        -: 3995:{
    #####: 3996:    if (!TreeNode((void*)(intptr_t)settings->ID, "Settings 0x%08X (%d columns)", settings->ID, settings->ColumnsCount))
    %%%%%: 3996-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 3997:        return;
    %%%%%: 3997-block 4
    #####: 3998:    BulletText("SaveFlags: 0x%08X", settings->SaveFlags);
    %%%%%: 3998-block 5
call    0 never executed
    #####: 3999:    BulletText("ColumnsCount: %d (max %d)", settings->ColumnsCount, settings->ColumnsCountMax);
call    0 never executed
    #####: 4000:    for (int n = 0; n < settings->ColumnsCount; n++)
    %%%%%: 4000-block 23
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 4001:    {
    #####: 4002:        ImGuiTableColumnSettings* column_settings = &settings->GetColumnSettings()[n];
    %%%%%: 4002-block 8
call    0 never executed
    #####: 4003:        ImGuiSortDirection sort_dir = (column_settings->SortOrder != -1) ? (ImGuiSortDirection)column_settings->SortDirection : ImGuiSortDirection_None;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4003-block 10
    %%%%%: 4003-block 11
    #####: 4004:        BulletText("Column %d Order %d SortOrder %d %s Vis %d %s %7.3f UserID 0x%08X",
    %%%%%: 4004-block 13
    %%%%%: 4004-block 14
    %%%%%: 4004-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4004-block 17
    %%%%%: 4004-block 18
    %%%%%: 4004-block 19
    %%%%%: 4004-block 20
    #####: 4005:            n, column_settings->DisplayOrder, column_settings->SortOrder,
    %%%%%: 4005-block 21
call    0 never executed
        -: 4006:            (sort_dir == ImGuiSortDirection_Ascending) ? "Asc" : (sort_dir == ImGuiSortDirection_Descending) ? "Des" : "---",
    #####: 4007:            column_settings->IsEnabled, column_settings->IsStretch ? "Weight" : "Width ", column_settings->WidthOrWeight, column_settings->UserID);
    %%%%%: 4007-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4007-block 15
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 4008:    }
    #####: 4009:    TreePop();
    %%%%%: 4009-block 24
call    0 never executed
        -: 4010:}
        -: 4011:
        -: 4012:#else // #ifndef IMGUI_DISABLE_DEBUG_TOOLS
        -: 4013:
        -: 4014:void ImGui::DebugNodeTable(ImGuiTable*) {}
        -: 4015:void ImGui::DebugNodeTableSettings(ImGuiTableSettings*) {}
        -: 4016:
        -: 4017:#endif
        -: 4018:
        -: 4019:
        -: 4020://-------------------------------------------------------------------------
        -: 4021:// [SECTION] Columns, BeginColumns, EndColumns, etc.
        -: 4022:// (This is a legacy API, prefer using BeginTable/EndTable!)
        -: 4023://-------------------------------------------------------------------------
        -: 4024:// FIXME: sizing is lossy when columns width is very small (default width may turn negative etc.)
        -: 4025://-------------------------------------------------------------------------
        -: 4026:// - SetWindowClipRectBeforeSetChannel() [Internal]
        -: 4027:// - GetColumnIndex()
        -: 4028:// - GetColumnsCount()
        -: 4029:// - GetColumnOffset()
        -: 4030:// - GetColumnWidth()
        -: 4031:// - SetColumnOffset()
        -: 4032:// - SetColumnWidth()
        -: 4033:// - PushColumnClipRect() [Internal]
        -: 4034:// - PushColumnsBackground() [Internal]
        -: 4035:// - PopColumnsBackground() [Internal]
        -: 4036:// - FindOrCreateColumns() [Internal]
        -: 4037:// - GetColumnsID() [Internal]
        -: 4038:// - BeginColumns()
        -: 4039:// - NextColumn()
        -: 4040:// - EndColumns()
        -: 4041:// - Columns()
        -: 4042://-------------------------------------------------------------------------
        -: 4043:
        -: 4044:// [Internal] Small optimization to avoid calls to PopClipRect/SetCurrentChannel/PushClipRect in sequences,
        -: 4045:// they would meddle many times with the underlying ImDrawCmd.
        -: 4046:// Instead, we do a preemptive overwrite of clipping rectangle _without_ altering the command-buffer and let
        -: 4047:// the subsequent single call to SetCurrentChannel() does it things once.
function _ZN5ImGui33SetWindowClipRectBeforeSetChannelEP11ImGuiWindowRK6ImRect called 53850 returned 100% blocks executed 100%
    53850: 4048:void ImGui::SetWindowClipRectBeforeSetChannel(ImGuiWindow* window, const ImRect& clip_rect)
        -: 4049:{
    53850: 4050:    ImVec4 clip_rect_vec4 = clip_rect.ToVec4();
    53850: 4050-block 2
call    0 returned 53850
    53850: 4051:    window->ClipRect = clip_rect;
    53850: 4052:    window->DrawList->_CmdHeader.ClipRect = clip_rect_vec4;
    53850: 4053:    window->DrawList->_ClipRectStack.Data[window->DrawList->_ClipRectStack.Size - 1] = clip_rect_vec4;
    53850: 4054:}
        -: 4055:
function _ZN5ImGui14GetColumnIndexEv called 0 returned 0% blocks executed 0%
    #####: 4056:int ImGui::GetColumnIndex()
        -: 4057:{
    #####: 4058:    ImGuiWindow* window = GetCurrentWindowRead();
    %%%%%: 4058-block 2
call    0 never executed
    #####: 4059:    return window->DC.CurrentColumns ? window->DC.CurrentColumns->Current : 0;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4059-block 4
    %%%%%: 4059-block 5
    %%%%%: 4059-block 6
        -: 4060:}
        -: 4061:
function _ZN5ImGui15GetColumnsCountEv called 0 returned 0% blocks executed 0%
    #####: 4062:int ImGui::GetColumnsCount()
        -: 4063:{
    #####: 4064:    ImGuiWindow* window = GetCurrentWindowRead();
    %%%%%: 4064-block 2
call    0 never executed
    #####: 4065:    return window->DC.CurrentColumns ? window->DC.CurrentColumns->Count : 1;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4065-block 4
    %%%%%: 4065-block 5
    %%%%%: 4065-block 6
        -: 4066:}
        -: 4067:
function _ZN5ImGui23GetColumnOffsetFromNormEPK15ImGuiOldColumnsf called 0 returned 0% blocks executed 0%
    #####: 4068:float ImGui::GetColumnOffsetFromNorm(const ImGuiOldColumns* columns, float offset_norm)
        -: 4069:{
    #####: 4070:    return offset_norm * (columns->OffMaxX - columns->OffMinX);
    %%%%%: 4070-block 2
        -: 4071:}
        -: 4072:
function _ZN5ImGui23GetColumnNormFromOffsetEPK15ImGuiOldColumnsf called 0 returned 0% blocks executed 0%
    #####: 4073:float ImGui::GetColumnNormFromOffset(const ImGuiOldColumns* columns, float offset)
        -: 4074:{
    #####: 4075:    return offset / (columns->OffMaxX - columns->OffMinX);
    %%%%%: 4075-block 2
        -: 4076:}
        -: 4077:
        -: 4078:static const float COLUMNS_HIT_RECT_HALF_THICKNESS = 4.0f;
        -: 4079:
function _ZL22GetDraggedColumnOffsetP15ImGuiOldColumnsi called 0 returned 0% blocks executed 0%
    #####: 4080:static float GetDraggedColumnOffset(ImGuiOldColumns* columns, int column_index)
        -: 4081:{
        -: 4082:    // Active (dragged) column always follow mouse. The reason we need this is that dragging a column to the right edge of an auto-resizing
        -: 4083:    // window creates a feedback loop because we store normalized positions. So while dragging we enforce absolute positioning.
    #####: 4084:    ImGuiContext& g = *GImGui;
    #####: 4085:    ImGuiWindow* window = g.CurrentWindow;
    #####: 4086:    IM_ASSERT(column_index > 0); // We are not supposed to drag column 0.
    %%%%%: 4086-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4086-block 3
call    2 never executed
    #####: 4087:    IM_ASSERT(g.ActiveId == columns->ID + ImGuiID(column_index));
    %%%%%: 4087-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4087-block 5
call    2 never executed
        -: 4088:
    #####: 4089:    float x = g.IO.MousePos.x - g.ActiveIdClickOffset.x + ImTrunc(COLUMNS_HIT_RECT_HALF_THICKNESS * g.CurrentDpiScale) - window->Pos.x;
    %%%%%: 4089-block 6
call    0 never executed
    #####: 4090:    x = ImMax(x, ImGui::GetColumnOffset(column_index - 1) + g.Style.ColumnsMinSpacing);
call    0 never executed
call    1 never executed
    #####: 4091:    if ((columns->Flags & ImGuiOldColumnFlags_NoPreserveWidths))
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4092:        x = ImMin(x, ImGui::GetColumnOffset(column_index + 1) - g.Style.ColumnsMinSpacing);
    %%%%%: 4092-block 10
call    0 never executed
call    1 never executed
        -: 4093:
    #####: 4094:    return x;
    %%%%%: 4094-block 12
        -: 4095:}
        -: 4096:
function _ZN5ImGui15GetColumnOffsetEi called 0 returned 0% blocks executed 0%
    #####: 4097:float ImGui::GetColumnOffset(int column_index)
        -: 4098:{
    #####: 4099:    ImGuiWindow* window = GetCurrentWindowRead();
    %%%%%: 4099-block 2
call    0 never executed
    #####: 4100:    ImGuiOldColumns* columns = window->DC.CurrentColumns;
    #####: 4101:    if (columns == NULL)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4102:        return 0.0f;
    %%%%%: 4102-block 4
        -: 4103:
    #####: 4104:    if (column_index < 0)
    %%%%%: 4104-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4105:        column_index = columns->Current;
    %%%%%: 4105-block 6
    #####: 4106:    IM_ASSERT(column_index < columns->Columns.Size);
    %%%%%: 4106-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4106-block 8
call    2 never executed
        -: 4107:
    #####: 4108:    const float t = columns->Columns[column_index].OffsetNorm;
    %%%%%: 4108-block 9
call    0 never executed
    #####: 4109:    const float x_offset = ImLerp(columns->OffMinX, columns->OffMaxX, t);
call    0 never executed
    #####: 4110:    return x_offset;
        -: 4111:}
        -: 4112:
function _ZL16GetColumnWidthExP15ImGuiOldColumnsib called 0 returned 0% blocks executed 0%
    #####: 4113:static float GetColumnWidthEx(ImGuiOldColumns* columns, int column_index, bool before_resize = false)
        -: 4114:{
    #####: 4115:    if (column_index < 0)
    %%%%%: 4115-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4116:        column_index = columns->Current;
    %%%%%: 4116-block 3
        -: 4117:
        -: 4118:    float offset_norm;
    #####: 4119:    if (before_resize)
    %%%%%: 4119-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4120:        offset_norm = columns->Columns[column_index + 1].OffsetNormBeforeResize - columns->Columns[column_index].OffsetNormBeforeResize;
    %%%%%: 4120-block 5
call    0 never executed
call    1 never executed
        -: 4121:    else
    #####: 4122:        offset_norm = columns->Columns[column_index + 1].OffsetNorm - columns->Columns[column_index].OffsetNorm;
    %%%%%: 4122-block 8
call    0 never executed
call    1 never executed
    #####: 4123:    return ImGui::GetColumnOffsetFromNorm(columns, offset_norm);
    %%%%%: 4123-block 11
call    0 never executed
        -: 4124:}
        -: 4125:
function _ZN5ImGui14GetColumnWidthEi called 0 returned 0% blocks executed 0%
    #####: 4126:float ImGui::GetColumnWidth(int column_index)
        -: 4127:{
    #####: 4128:    ImGuiContext& g = *GImGui;
    #####: 4129:    ImGuiWindow* window = g.CurrentWindow;
    #####: 4130:    ImGuiOldColumns* columns = window->DC.CurrentColumns;
    #####: 4131:    if (columns == NULL)
    %%%%%: 4131-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4132:        return GetContentRegionAvail().x;
    %%%%%: 4132-block 3
call    0 never executed
        -: 4133:
    #####: 4134:    if (column_index < 0)
    %%%%%: 4134-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4135:        column_index = columns->Current;
    %%%%%: 4135-block 6
    #####: 4136:    return GetColumnOffsetFromNorm(columns, columns->Columns[column_index + 1].OffsetNorm - columns->Columns[column_index].OffsetNorm);
    %%%%%: 4136-block 7
call    0 never executed
call    1 never executed
call    2 never executed
        -: 4137:}
        -: 4138:
function _ZN5ImGui15SetColumnOffsetEif called 0 returned 0% blocks executed 0%
    #####: 4139:void ImGui::SetColumnOffset(int column_index, float offset)
        -: 4140:{
    #####: 4141:    ImGuiContext& g = *GImGui;
    #####: 4142:    ImGuiWindow* window = g.CurrentWindow;
    #####: 4143:    ImGuiOldColumns* columns = window->DC.CurrentColumns;
    #####: 4144:    IM_ASSERT(columns != NULL);
    %%%%%: 4144-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4144-block 3
call    2 never executed
        -: 4145:
    #####: 4146:    if (column_index < 0)
    %%%%%: 4146-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4147:        column_index = columns->Current;
    %%%%%: 4147-block 5
    #####: 4148:    IM_ASSERT(column_index < columns->Columns.Size);
    %%%%%: 4148-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4148-block 7
call    2 never executed
        -: 4149:
    #####: 4150:    const bool preserve_width = !(columns->Flags & ImGuiOldColumnFlags_NoPreserveWidths) && (column_index < columns->Count - 1);
    %%%%%: 4150-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4150-block 9
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4150-block 10
    %%%%%: 4150-block 11
    #####: 4151:    const float width = preserve_width ? GetColumnWidthEx(columns, column_index, columns->IsBeingResized) : 0.0f;
    %%%%%: 4151-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4151-block 13
call    2 never executed
    %%%%%: 4151-block 15
        -: 4152:
    #####: 4153:    if (!(columns->Flags & ImGuiOldColumnFlags_NoForceWithinWindow))
    %%%%%: 4153-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4154:        offset = ImMin(offset, columns->OffMaxX - g.Style.ColumnsMinSpacing * (columns->Count - column_index));
    %%%%%: 4154-block 17
call    0 never executed
    #####: 4155:    columns->Columns[column_index].OffsetNorm = GetColumnNormFromOffset(columns, offset - columns->OffMinX);
    %%%%%: 4155-block 18
call    0 never executed
call    1 never executed
        -: 4156:
    #####: 4157:    if (preserve_width)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4158:        SetColumnOffset(column_index + 1, offset + ImMax(g.Style.ColumnsMinSpacing, width));
    %%%%%: 4158-block 21
call    0 never executed
call    1 never executed
    #####: 4159:}
        -: 4160:
function _ZN5ImGui14SetColumnWidthEif called 0 returned 0% blocks executed 0%
    #####: 4161:void ImGui::SetColumnWidth(int column_index, float width)
        -: 4162:{
    #####: 4163:    ImGuiWindow* window = GetCurrentWindowRead();
    %%%%%: 4163-block 2
call    0 never executed
    #####: 4164:    ImGuiOldColumns* columns = window->DC.CurrentColumns;
    #####: 4165:    IM_ASSERT(columns != NULL);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4165-block 4
call    2 never executed
        -: 4166:
    #####: 4167:    if (column_index < 0)
    %%%%%: 4167-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4168:        column_index = columns->Current;
    %%%%%: 4168-block 6
    #####: 4169:    SetColumnOffset(column_index + 1, GetColumnOffset(column_index) + width);
    %%%%%: 4169-block 7
call    0 never executed
call    1 never executed
    #####: 4170:}
        -: 4171:
function _ZN5ImGui18PushColumnClipRectEi called 0 returned 0% blocks executed 0%
    #####: 4172:void ImGui::PushColumnClipRect(int column_index)
        -: 4173:{
    #####: 4174:    ImGuiWindow* window = GetCurrentWindowRead();
    %%%%%: 4174-block 2
call    0 never executed
    #####: 4175:    ImGuiOldColumns* columns = window->DC.CurrentColumns;
    #####: 4176:    if (column_index < 0)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4177:        column_index = columns->Current;
    %%%%%: 4177-block 4
        -: 4178:
    #####: 4179:    ImGuiOldColumnData* column = &columns->Columns[column_index];
    %%%%%: 4179-block 5
call    0 never executed
    #####: 4180:    PushClipRect(column->ClipRect.Min, column->ClipRect.Max, false);
call    0 never executed
    #####: 4181:}
        -: 4182:
        -: 4183:// Get into the columns background draw command (which is generally the same draw command as before we called BeginColumns)
function _ZN5ImGui21PushColumnsBackgroundEv called 0 returned 0% blocks executed 0%
    #####: 4184:void ImGui::PushColumnsBackground()
        -: 4185:{
    #####: 4186:    ImGuiWindow* window = GetCurrentWindowRead();
    %%%%%: 4186-block 2
call    0 never executed
    #####: 4187:    ImGuiOldColumns* columns = window->DC.CurrentColumns;
    #####: 4188:    if (columns->Count == 1)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4189:        return;
    %%%%%: 4189-block 4
        -: 4190:
        -: 4191:    // Optimization: avoid SetCurrentChannel() + PushClipRect()
    #####: 4192:    columns->HostBackupClipRect = window->ClipRect;
    #####: 4193:    SetWindowClipRectBeforeSetChannel(window, columns->HostInitialClipRect);
    %%%%%: 4193-block 5
call    0 never executed
    #####: 4194:    columns->Splitter.SetCurrentChannel(window->DrawList, 0);
call    0 never executed
        -: 4195:}
        -: 4196:
function _ZN5ImGui20PopColumnsBackgroundEv called 0 returned 0% blocks executed 0%
    #####: 4197:void ImGui::PopColumnsBackground()
        -: 4198:{
    #####: 4199:    ImGuiWindow* window = GetCurrentWindowRead();
    %%%%%: 4199-block 2
call    0 never executed
    #####: 4200:    ImGuiOldColumns* columns = window->DC.CurrentColumns;
    #####: 4201:    if (columns->Count == 1)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4202:        return;
    %%%%%: 4202-block 4
        -: 4203:
        -: 4204:    // Optimization: avoid PopClipRect() + SetCurrentChannel()
    #####: 4205:    SetWindowClipRectBeforeSetChannel(window, columns->HostBackupClipRect);
    %%%%%: 4205-block 5
call    0 never executed
    #####: 4206:    columns->Splitter.SetCurrentChannel(window->DrawList, columns->Current + 1);
call    0 never executed
        -: 4207:}
        -: 4208:
function _ZN5ImGui19FindOrCreateColumnsEP11ImGuiWindowj called 0 returned 0% blocks executed 0%
    #####: 4209:ImGuiOldColumns* ImGui::FindOrCreateColumns(ImGuiWindow* window, ImGuiID id)
        -: 4210:{
        -: 4211:    // We have few columns per window so for now we don't need bother much with turning this into a faster lookup.
    #####: 4212:    for (int n = 0; n < window->ColumnsStorage.Size; n++)
    %%%%%: 4212-block 2
    %%%%%: 4212-block 6
    %%%%%: 4212-block 7
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4213:        if (window->ColumnsStorage[n].ID == id)
    %%%%%: 4213-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 4214:            return &window->ColumnsStorage[n];
    %%%%%: 4214-block 5
call    0 never executed
        -: 4215:
    #####: 4216:    window->ColumnsStorage.push_back(ImGuiOldColumns());
    %%%%%: 4216-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 4216-block 9
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    %%%%%: 4216-block 10
call    6 never executed
    $$$$$: 4216-block 14
call    7 never executed
    #####: 4217:    ImGuiOldColumns* columns = &window->ColumnsStorage.back();
call    0 never executed
    #####: 4218:    columns->ID = id;
    #####: 4219:    return columns;
        -: 4220:}
        -: 4221:
function _ZN5ImGui12GetColumnsIDEPKci called 0 returned 0% blocks executed 0%
    #####: 4222:ImGuiID ImGui::GetColumnsID(const char* str_id, int columns_count)
        -: 4223:{
    #####: 4224:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%: 4224-block 2
call    0 never executed
        -: 4225:
        -: 4226:    // Differentiate column ID with an arbitrary prefix for cases where users name their columns set the same as another widget.
        -: 4227:    // In addition, when an identifier isn't explicitly provided we include the number of columns in the hash to make it uniquer.
    #####: 4228:    PushID(0x11223347 + (str_id ? 0 : columns_count));
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4228-block 4
    %%%%%: 4228-block 5
    %%%%%: 4228-block 6
call    2 never executed
    #####: 4229:    ImGuiID id = window->GetID(str_id ? str_id : "columns");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4229-block 8
    %%%%%: 4229-block 9
    %%%%%: 4229-block 10
call    2 never executed
    #####: 4230:    PopID();
call    0 never executed
        -: 4231:
    #####: 4232:    return id;
        -: 4233:}
        -: 4234:
function _ZN5ImGui12BeginColumnsEPKcii called 0 returned 0% blocks executed 0%
    #####: 4235:void ImGui::BeginColumns(const char* str_id, int columns_count, ImGuiOldColumnFlags flags)
        -: 4236:{
    #####: 4237:    ImGuiContext& g = *GImGui;
    #####: 4238:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%: 4238-block 2
call    0 never executed
        -: 4239:
    #####: 4240:    IM_ASSERT(columns_count >= 1);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4240-block 4
call    2 never executed
    #####: 4241:    IM_ASSERT(window->DC.CurrentColumns == NULL);   // Nested columns are currently not supported
    %%%%%: 4241-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4241-block 6
call    2 never executed
        -: 4242:
        -: 4243:    // Acquire storage for the columns set
    #####: 4244:    ImGuiID id = GetColumnsID(str_id, columns_count);
    %%%%%: 4244-block 7
call    0 never executed
    #####: 4245:    ImGuiOldColumns* columns = FindOrCreateColumns(window, id);
call    0 never executed
    #####: 4246:    IM_ASSERT(columns->ID == id);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4246-block 10
call    2 never executed
    #####: 4247:    columns->Current = 0;
    #####: 4248:    columns->Count = columns_count;
    #####: 4249:    columns->Flags = flags;
    #####: 4250:    window->DC.CurrentColumns = columns;
    #####: 4251:    window->DC.NavIsScrollPushableX = false; // Shortcut for NavUpdateCurrentWindowIsScrollPushableX();
        -: 4252:
    #####: 4253:    columns->HostCursorPosY = window->DC.CursorPos.y;
    #####: 4254:    columns->HostCursorMaxPosX = window->DC.CursorMaxPos.x;
    #####: 4255:    columns->HostInitialClipRect = window->ClipRect;
    #####: 4256:    columns->HostBackupParentWorkRect = window->ParentWorkRect;
    #####: 4257:    window->ParentWorkRect = window->WorkRect;
        -: 4258:
        -: 4259:    // Set state for first column
        -: 4260:    // We aim so that the right-most column will have the same clipping width as other after being clipped by parent ClipRect
    #####: 4261:    const float column_padding = g.Style.ItemSpacing.x;
    #####: 4262:    const float half_clip_extend_x = ImTrunc(ImMax(window->WindowPadding.x * 0.5f, window->WindowBorderSize));
    %%%%%: 4262-block 11
call    0 never executed
call    1 never executed
    #####: 4263:    const float max_1 = window->WorkRect.Max.x + column_padding - ImMax(column_padding - window->WindowPadding.x, 0.0f);
call    0 never executed
    #####: 4264:    const float max_2 = window->WorkRect.Max.x + half_clip_extend_x;
    #####: 4265:    columns->OffMinX = window->DC.Indent.x - column_padding + ImMax(column_padding - window->WindowPadding.x, 0.0f);
call    0 never executed
    #####: 4266:    columns->OffMaxX = ImMax(ImMin(max_1, max_2) - window->Pos.x, columns->OffMinX + 1.0f);
call    0 never executed
call    1 never executed
    #####: 4267:    columns->LineMinY = columns->LineMaxY = window->DC.CursorPos.y;
        -: 4268:
        -: 4269:    // Clear data if columns count changed
    #####: 4270:    if (columns->Columns.Size != 0 && columns->Columns.Size != columns_count + 1)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4270-block 18
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4271:        columns->Columns.resize(0);
    %%%%%: 4271-block 19
call    0 never executed
        -: 4272:
        -: 4273:    // Initialize default widths
    #####: 4274:    columns->IsFirstFrame = (columns->Columns.Size == 0);
    #####: 4275:    if (columns->Columns.Size == 0)
    %%%%%: 4275-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4276:    {
    #####: 4277:        columns->Columns.reserve(columns_count + 1);
    %%%%%: 4277-block 21
call    0 never executed
    #####: 4278:        for (int n = 0; n < columns_count + 1; n++)
    %%%%%: 4278-block 25
    %%%%%: 4278-block 26
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 4279:        {
    #####: 4280:            ImGuiOldColumnData column;
    %%%%%: 4280-block 23
call    0 never executed
    #####: 4281:            column.OffsetNorm = n / (float)columns_count;
    #####: 4282:            columns->Columns.push_back(column);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 4283:        }
        -: 4284:    }
        -: 4285:
    #####: 4286:    for (int n = 0; n < columns_count; n++)
    %%%%%: 4286-block 27
    %%%%%: 4286-block 34
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 4287:    {
        -: 4288:        // Compute clipping rectangle
    #####: 4289:        ImGuiOldColumnData* column = &columns->Columns[n];
    %%%%%: 4289-block 28
call    0 never executed
    #####: 4290:        float clip_x1 = IM_ROUND(window->Pos.x + GetColumnOffset(n));
call    0 never executed
    #####: 4291:        float clip_x2 = IM_ROUND(window->Pos.x + GetColumnOffset(n + 1) - 1.0f);
call    0 never executed
    #####: 4292:        column->ClipRect = ImRect(clip_x1, -FLT_MAX, clip_x2, +FLT_MAX);
call    0 never executed
    #####: 4293:        column->ClipRect.ClipWithFull(window->ClipRect);
call    0 never executed
        -: 4294:    }
        -: 4295:
    #####: 4296:    if (columns->Count > 1)
    %%%%%: 4296-block 35
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4297:    {
    #####: 4298:        columns->Splitter.Split(window->DrawList, 1 + columns->Count);
    %%%%%: 4298-block 36
call    0 never executed
    #####: 4299:        columns->Splitter.SetCurrentChannel(window->DrawList, 1);
call    0 never executed
    #####: 4300:        PushColumnClipRect(0);
call    0 never executed
        -: 4301:    }
        -: 4302:
        -: 4303:    // We don't generally store Indent.x inside ColumnsOffset because it may be manipulated by the user.
    #####: 4304:    float offset_0 = GetColumnOffset(columns->Current);
    %%%%%: 4304-block 39
call    0 never executed
    #####: 4305:    float offset_1 = GetColumnOffset(columns->Current + 1);
call    0 never executed
    #####: 4306:    float width = offset_1 - offset_0;
    #####: 4307:    PushItemWidth(width * 0.65f);
call    0 never executed
    #####: 4308:    window->DC.ColumnsOffset.x = ImMax(column_padding - window->WindowPadding.x, 0.0f);
call    0 never executed
    #####: 4309:    window->DC.CursorPos.x = IM_TRUNC(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);
    #####: 4310:    window->WorkRect.Max.x = window->Pos.x + offset_1 - column_padding;
    #####: 4311:    window->WorkRect.Max.y = window->ContentRegionRect.Max.y;
    #####: 4312:}
        -: 4313:
function _ZN5ImGui10NextColumnEv called 0 returned 0% blocks executed 0%
    #####: 4314:void ImGui::NextColumn()
        -: 4315:{
    #####: 4316:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%: 4316-block 2
call    0 never executed
    #####: 4317:    if (window->SkipItems || window->DC.CurrentColumns == NULL)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4317-block 4
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4318:        return;
    %%%%%: 4318-block 5
        -: 4319:
    #####: 4320:    ImGuiContext& g = *GImGui;
    #####: 4321:    ImGuiOldColumns* columns = window->DC.CurrentColumns;
        -: 4322:
    #####: 4323:    if (columns->Count == 1)
    %%%%%: 4323-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4324:    {
    #####: 4325:        window->DC.CursorPos.x = IM_TRUNC(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);
    #####: 4326:        IM_ASSERT(columns->Current == 0);
    %%%%%: 4326-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4326-block 8
call    2 never executed
    #####: 4327:        return;
    %%%%%: 4327-block 9
        -: 4328:    }
        -: 4329:
        -: 4330:    // Next column
    #####: 4331:    if (++columns->Current == columns->Count)
    %%%%%: 4331-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4332:        columns->Current = 0;
    %%%%%: 4332-block 11
        -: 4333:
    #####: 4334:    PopItemWidth();
    %%%%%: 4334-block 12
call    0 never executed
        -: 4335:
        -: 4336:    // Optimization: avoid PopClipRect() + SetCurrentChannel() + PushClipRect()
        -: 4337:    // (which would needlessly attempt to update commands in the wrong channel, then pop or overwrite them),
    #####: 4338:    ImGuiOldColumnData* column = &columns->Columns[columns->Current];
call    0 never executed
    #####: 4339:    SetWindowClipRectBeforeSetChannel(window, column->ClipRect);
call    0 never executed
    #####: 4340:    columns->Splitter.SetCurrentChannel(window->DrawList, columns->Current + 1);
call    0 never executed
        -: 4341:
    #####: 4342:    const float column_padding = g.Style.ItemSpacing.x;
    #####: 4343:    columns->LineMaxY = ImMax(columns->LineMaxY, window->DC.CursorPos.y);
call    0 never executed
    #####: 4344:    if (columns->Current > 0)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4345:    {
        -: 4346:        // Columns 1+ ignore IndentX (by canceling it out)
        -: 4347:        // FIXME-COLUMNS: Unnecessary, could be locked?
    #####: 4348:        window->DC.ColumnsOffset.x = GetColumnOffset(columns->Current) - window->DC.Indent.x + column_padding;
    %%%%%: 4348-block 18
call    0 never executed
        -: 4349:    }
        -: 4350:    else
        -: 4351:    {
        -: 4352:        // New row/line: column 0 honor IndentX.
    #####: 4353:        window->DC.ColumnsOffset.x = ImMax(column_padding - window->WindowPadding.x, 0.0f);
    %%%%%: 4353-block 20
call    0 never executed
    #####: 4354:        window->DC.IsSameLine = false;
    #####: 4355:        columns->LineMinY = columns->LineMaxY;
        -: 4356:    }
    #####: 4357:    window->DC.CursorPos.x = IM_TRUNC(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);
    #####: 4358:    window->DC.CursorPos.y = columns->LineMinY;
    #####: 4359:    window->DC.CurrLineSize = ImVec2(0.0f, 0.0f);
    %%%%%: 4359-block 22
call    0 never executed
    #####: 4360:    window->DC.CurrLineTextBaseOffset = 0.0f;
        -: 4361:
        -: 4362:    // FIXME-COLUMNS: Share code with BeginColumns() - move code on columns setup.
    #####: 4363:    float offset_0 = GetColumnOffset(columns->Current);
call    0 never executed
    #####: 4364:    float offset_1 = GetColumnOffset(columns->Current + 1);
call    0 never executed
    #####: 4365:    float width = offset_1 - offset_0;
    #####: 4366:    PushItemWidth(width * 0.65f);
call    0 never executed
    #####: 4367:    window->WorkRect.Max.x = window->Pos.x + offset_1 - column_padding;
        -: 4368:}
        -: 4369:
function _ZN5ImGui10EndColumnsEv called 0 returned 0% blocks executed 0%
    #####: 4370:void ImGui::EndColumns()
        -: 4371:{
    #####: 4372:    ImGuiContext& g = *GImGui;
    #####: 4373:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%: 4373-block 2
call    0 never executed
    #####: 4374:    ImGuiOldColumns* columns = window->DC.CurrentColumns;
    #####: 4375:    IM_ASSERT(columns != NULL);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4375-block 4
call    2 never executed
        -: 4376:
    #####: 4377:    PopItemWidth();
    %%%%%: 4377-block 5
call    0 never executed
    #####: 4378:    if (columns->Count > 1)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4379:    {
    #####: 4380:        PopClipRect();
    %%%%%: 4380-block 7
call    0 never executed
    #####: 4381:        columns->Splitter.Merge(window->DrawList);
call    0 never executed
        -: 4382:    }
        -: 4383:
    #####: 4384:    const ImGuiOldColumnFlags flags = columns->Flags;
    #####: 4385:    columns->LineMaxY = ImMax(columns->LineMaxY, window->DC.CursorPos.y);
    %%%%%: 4385-block 9
call    0 never executed
    #####: 4386:    window->DC.CursorPos.y = columns->LineMaxY;
    #####: 4387:    if (!(flags & ImGuiOldColumnFlags_GrowParentContentsSize))
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4388:        window->DC.CursorMaxPos.x = columns->HostCursorMaxPosX;  // Restore cursor max pos, as columns don't grow parent
    %%%%%: 4388-block 11
        -: 4389:
        -: 4390:    // Draw columns borders and handle resize
        -: 4391:    // The IsBeingResized flag ensure we preserve pre-resize columns width so back-and-forth are not lossy
    #####: 4392:    bool is_being_resized = false;
    #####: 4393:    if (!(flags & ImGuiOldColumnFlags_NoBorder) && !window->SkipItems)
    %%%%%: 4393-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4393-block 13
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 4394:    {
        -: 4395:        // We clip Y boundaries CPU side because very long triangles are mishandled by some GPU drivers.
    #####: 4396:        const float y1 = ImMax(columns->HostCursorPosY, window->ClipRect.Min.y);
    %%%%%: 4396-block 14
call    0 never executed
    #####: 4397:        const float y2 = ImMin(window->DC.CursorPos.y, window->ClipRect.Max.y);
call    0 never executed
    #####: 4398:        int dragging_column = -1;
    #####: 4399:        for (int n = 1; n < columns->Count; n++)
    %%%%%: 4399-block 45
    %%%%%: 4399-block 46
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 4400:        {
    #####: 4401:            ImGuiOldColumnData* column = &columns->Columns[n];
    %%%%%: 4401-block 17
call    0 never executed
    #####: 4402:            float x = window->Pos.x + GetColumnOffset(n);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 4403:            const ImGuiID column_id = columns->ID + ImGuiID(n);
    #####: 4404:            const float column_hit_hw = ImTrunc(COLUMNS_HIT_RECT_HALF_THICKNESS * g.CurrentDpiScale);
    %%%%%: 4404-block 19
call    0 never executed
    #####: 4405:            const ImRect column_hit_rect(ImVec2(x - column_hit_hw, y1), ImVec2(x + column_hit_hw, y2));
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4406:            if (!ItemAdd(column_hit_rect, column_id, NULL, ImGuiItemFlags_NoNav))
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 4406-block 24
branch  3 never executed (fallthrough)
branch  4 never executed
    #####: 4407:                continue;
    %%%%%: 4407-block 25
        -: 4408:
    #####: 4409:            bool hovered = false, held = false;
    #####: 4410:            if (!(flags & ImGuiOldColumnFlags_NoResize))
    %%%%%: 4410-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4411:            {
    #####: 4412:                ButtonBehavior(column_hit_rect, column_id, &hovered, &held);
    %%%%%: 4412-block 27
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 4413:                if (hovered || held)
    %%%%%: 4413-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4413-block 29
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4414:                    SetMouseCursor(ImGuiMouseCursor_ResizeEW);
    %%%%%: 4414-block 30
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 4415:                if (held && !(column->Flags & ImGuiOldColumnFlags_NoResize))
    %%%%%: 4415-block 31
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4415-block 32
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4416:                    dragging_column = n;
    %%%%%: 4416-block 33
        -: 4417:            }
        -: 4418:
        -: 4419:            // Draw column
    #####: 4420:            const ImU32 col = GetColorU32(held ? ImGuiCol_SeparatorActive : hovered ? ImGuiCol_SeparatorHovered : ImGuiCol_Separator);
    %%%%%: 4420-block 34
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4420-block 35
    %%%%%: 4420-block 36
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4420-block 37
    %%%%%: 4420-block 38
    %%%%%: 4420-block 39
    %%%%%: 4420-block 40
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    #####: 4421:            const float xi = IM_TRUNC(x);
    #####: 4422:            window->DrawList->AddLine(ImVec2(xi, y1 + 1.0f), ImVec2(xi, y2), col);
    %%%%%: 4422-block 41
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 4422-block 44
    $$$$$: 4422-block 58
    $$$$$: 4422-block 59
        -: 4423:        }
        -: 4424:
        -: 4425:        // Apply dragging after drawing the column lines, so our rendered lines are in sync with how items were displayed during the frame.
    #####: 4426:        if (dragging_column != -1)
    %%%%%: 4426-block 47
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4427:        {
    #####: 4428:            if (!columns->IsBeingResized)
    %%%%%: 4428-block 48
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4429:                for (int n = 0; n < columns->Count + 1; n++)
    %%%%%: 4429-block 49
    %%%%%: 4429-block 53
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4430:                    columns->Columns[n].OffsetNormBeforeResize = columns->Columns[n].OffsetNorm;
    %%%%%: 4430-block 50
call    0 never executed
call    1 never executed
    #####: 4431:            columns->IsBeingResized = is_being_resized = true;
    #####: 4432:            float x = GetDraggedColumnOffset(columns, dragging_column);
    %%%%%: 4432-block 54
call    0 never executed
    #####: 4433:            SetColumnOffset(dragging_column, x);
call    0 never executed
        -: 4434:        }
        -: 4435:    }
    #####: 4436:    columns->IsBeingResized = is_being_resized;
        -: 4437:
    #####: 4438:    window->WorkRect = window->ParentWorkRect;
    #####: 4439:    window->ParentWorkRect = columns->HostBackupParentWorkRect;
    #####: 4440:    window->DC.CurrentColumns = NULL;
    #####: 4441:    window->DC.ColumnsOffset.x = 0.0f;
    #####: 4442:    window->DC.CursorPos.x = IM_TRUNC(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);
    #####: 4443:    NavUpdateCurrentWindowIsScrollPushableX();
    %%%%%: 4443-block 56
call    0 never executed
    #####: 4444:}
        -: 4445:
function _ZN5ImGui7ColumnsEiPKcb called 0 returned 0% blocks executed 0%
    #####: 4446:void ImGui::Columns(int columns_count, const char* id, bool borders)
        -: 4447:{
    #####: 4448:    ImGuiWindow* window = GetCurrentWindow();
    %%%%%: 4448-block 2
call    0 never executed
    #####: 4449:    IM_ASSERT(columns_count >= 1);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4449-block 4
call    2 never executed
        -: 4450:
    #####: 4451:    ImGuiOldColumnFlags flags = (borders ? 0 : ImGuiOldColumnFlags_NoBorder);
    %%%%%: 4451-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4451-block 6
    %%%%%: 4451-block 7
        -: 4452:    //flags |= ImGuiOldColumnFlags_NoPreserveWidths; // NB: Legacy behavior
    #####: 4453:    ImGuiOldColumns* columns = window->DC.CurrentColumns;
    #####: 4454:    if (columns != NULL && columns->Count == columns_count && columns->Flags == flags)
    %%%%%: 4454-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4454-block 9
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4454-block 10
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 4455:        return;
    %%%%%: 4455-block 11
        -: 4456:
    #####: 4457:    if (columns != NULL)
    %%%%%: 4457-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4458:        EndColumns();
    %%%%%: 4458-block 13
call    0 never executed
        -: 4459:
    #####: 4460:    if (columns_count != 1)
    %%%%%: 4460-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4461:        BeginColumns(id, columns_count, flags);
    %%%%%: 4461-block 15
call    0 never executed
        -: 4462:}
        -: 4463:
        -: 4464://-------------------------------------------------------------------------
        -: 4465:
        -: 4466:#endif // #ifndef IMGUI_DISABLE
