        -:    0:Source:/home/rc/ZathuraDbg/vendor/imgui/imstb_truetype.h
        -:    0:Graph:/home/rc/ZathuraDbg/src/cmake-build-debug-coverage/CMakeFiles/Zathura.dir/home/rc/ZathuraDbg/vendor/imgui/imgui_draw.cpp.gcno
        -:    0:Data:/home/rc/ZathuraDbg/src/cmake-build-debug-coverage/CMakeFiles/Zathura.dir/home/rc/ZathuraDbg/vendor/imgui/imgui_draw.cpp.gcda
        -:    0:Runs:1
        -:    1:// [DEAR IMGUI]
        -:    2:// This is a slightly modified version of stb_truetype.h 1.26.
        -:    3:// Mostly fixing for compiler and static analyzer warnings.
        -:    4:// Grep for [DEAR IMGUI] to find the changes.
        -:    5:
        -:    6:// stb_truetype.h - v1.26 - public domain
        -:    7:// authored from 2009-2021 by Sean Barrett / RAD Game Tools
        -:    8://
        -:    9:// =======================================================================
        -:   10://
        -:   11://    NO SECURITY GUARANTEE -- DO NOT USE THIS ON UNTRUSTED FONT FILES
        -:   12://
        -:   13:// This library does no range checking of the offsets found in the file,
        -:   14:// meaning an attacker can use it to read arbitrary memory.
        -:   15://
        -:   16:// =======================================================================
        -:   17://
        -:   18://   This library processes TrueType files:
        -:   19://        parse files
        -:   20://        extract glyph metrics
        -:   21://        extract glyph shapes
        -:   22://        render glyphs to one-channel bitmaps with antialiasing (box filter)
        -:   23://        render glyphs to one-channel SDF bitmaps (signed-distance field/function)
        -:   24://
        -:   25://   Todo:
        -:   26://        non-MS cmaps
        -:   27://        crashproof on bad data
        -:   28://        hinting? (no longer patented)
        -:   29://        cleartype-style AA?
        -:   30://        optimize: use simple memory allocator for intermediates
        -:   31://        optimize: build edge-list directly from curves
        -:   32://        optimize: rasterize directly from curves?
        -:   33://
        -:   34:// ADDITIONAL CONTRIBUTORS
        -:   35://
        -:   36://   Mikko Mononen: compound shape support, more cmap formats
        -:   37://   Tor Andersson: kerning, subpixel rendering
        -:   38://   Dougall Johnson: OpenType / Type 2 font handling
        -:   39://   Daniel Ribeiro Maciel: basic GPOS-based kerning
        -:   40://
        -:   41://   Misc other:
        -:   42://       Ryan Gordon
        -:   43://       Simon Glass
        -:   44://       github:IntellectualKitty
        -:   45://       Imanol Celaya
        -:   46://       Daniel Ribeiro Maciel
        -:   47://
        -:   48://   Bug/warning reports/fixes:
        -:   49://       "Zer" on mollyrocket       Fabian "ryg" Giesen   github:NiLuJe
        -:   50://       Cass Everitt               Martins Mozeiko       github:aloucks
        -:   51://       stoiko (Haemimont Games)   Cap Petschulat        github:oyvindjam
        -:   52://       Brian Hook                 Omar Cornut           github:vassvik
        -:   53://       Walter van Niftrik         Ryan Griege
        -:   54://       David Gow                  Peter LaValle
        -:   55://       David Given                Sergey Popov
        -:   56://       Ivan-Assen Ivanov          Giumo X. Clanjor
        -:   57://       Anthony Pesch              Higor Euripedes
        -:   58://       Johan Duparc               Thomas Fields
        -:   59://       Hou Qiming                 Derek Vinyard
        -:   60://       Rob Loach                  Cort Stratton
        -:   61://       Kenney Phillis Jr.         Brian Costabile
        -:   62://       Ken Voskuil (kaesve)
        -:   63://
        -:   64:// VERSION HISTORY
        -:   65://
        -:   66://   1.26 (2021-08-28) fix broken rasterizer
        -:   67://   1.25 (2021-07-11) many fixes
        -:   68://   1.24 (2020-02-05) fix warning
        -:   69://   1.23 (2020-02-02) query SVG data for glyphs; query whole kerning table (but only kern not GPOS)
        -:   70://   1.22 (2019-08-11) minimize missing-glyph duplication; fix kerning if both 'GPOS' and 'kern' are defined
        -:   71://   1.21 (2019-02-25) fix warning
        -:   72://   1.20 (2019-02-07) PackFontRange skips missing codepoints; GetScaleFontVMetrics()
        -:   73://   1.19 (2018-02-11) GPOS kerning, STBTT_fmod
        -:   74://   1.18 (2018-01-29) add missing function
        -:   75://   1.17 (2017-07-23) make more arguments const; doc fix
        -:   76://   1.16 (2017-07-12) SDF support
        -:   77://   1.15 (2017-03-03) make more arguments const
        -:   78://   1.14 (2017-01-16) num-fonts-in-TTC function
        -:   79://   1.13 (2017-01-02) support OpenType fonts, certain Apple fonts
        -:   80://   1.12 (2016-10-25) suppress warnings about casting away const with -Wcast-qual
        -:   81://   1.11 (2016-04-02) fix unused-variable warning
        -:   82://   1.10 (2016-04-02) user-defined fabs(); rare memory leak; remove duplicate typedef
        -:   83://   1.09 (2016-01-16) warning fix; avoid crash on outofmem; use allocation userdata properly
        -:   84://   1.08 (2015-09-13) document stbtt_Rasterize(); fixes for vertical & horizontal edges
        -:   85://   1.07 (2015-08-01) allow PackFontRanges to accept arrays of sparse codepoints;
        -:   86://                     variant PackFontRanges to pack and render in separate phases;
        -:   87://                     fix stbtt_GetFontOFfsetForIndex (never worked for non-0 input?);
        -:   88://                     fixed an assert() bug in the new rasterizer
        -:   89://                     replace assert() with STBTT_assert() in new rasterizer
        -:   90://
        -:   91://   Full history can be found at the end of this file.
        -:   92://
        -:   93:// LICENSE
        -:   94://
        -:   95://   See end of file for license information.
        -:   96://
        -:   97:// USAGE
        -:   98://
        -:   99://   Include this file in whatever places need to refer to it. In ONE C/C++
        -:  100://   file, write:
        -:  101://      #define STB_TRUETYPE_IMPLEMENTATION
        -:  102://   before the #include of this file. This expands out the actual
        -:  103://   implementation into that C/C++ file.
        -:  104://
        -:  105://   To make the implementation private to the file that generates the implementation,
        -:  106://      #define STBTT_STATIC
        -:  107://
        -:  108://   Simple 3D API (don't ship this, but it's fine for tools and quick start)
        -:  109://           stbtt_BakeFontBitmap()               -- bake a font to a bitmap for use as texture
        -:  110://           stbtt_GetBakedQuad()                 -- compute quad to draw for a given char
        -:  111://
        -:  112://   Improved 3D API (more shippable):
        -:  113://           #include "stb_rect_pack.h"           -- optional, but you really want it
        -:  114://           stbtt_PackBegin()
        -:  115://           stbtt_PackSetOversampling()          -- for improved quality on small fonts
        -:  116://           stbtt_PackFontRanges()               -- pack and renders
        -:  117://           stbtt_PackEnd()
        -:  118://           stbtt_GetPackedQuad()
        -:  119://
        -:  120://   "Load" a font file from a memory buffer (you have to keep the buffer loaded)
        -:  121://           stbtt_InitFont()
        -:  122://           stbtt_GetFontOffsetForIndex()        -- indexing for TTC font collections
        -:  123://           stbtt_GetNumberOfFonts()             -- number of fonts for TTC font collections
        -:  124://
        -:  125://   Render a unicode codepoint to a bitmap
        -:  126://           stbtt_GetCodepointBitmap()           -- allocates and returns a bitmap
        -:  127://           stbtt_MakeCodepointBitmap()          -- renders into bitmap you provide
        -:  128://           stbtt_GetCodepointBitmapBox()        -- how big the bitmap must be
        -:  129://
        -:  130://   Character advance/positioning
        -:  131://           stbtt_GetCodepointHMetrics()
        -:  132://           stbtt_GetFontVMetrics()
        -:  133://           stbtt_GetFontVMetricsOS2()
        -:  134://           stbtt_GetCodepointKernAdvance()
        -:  135://
        -:  136://   Starting with version 1.06, the rasterizer was replaced with a new,
        -:  137://   faster and generally-more-precise rasterizer. The new rasterizer more
        -:  138://   accurately measures pixel coverage for anti-aliasing, except in the case
        -:  139://   where multiple shapes overlap, in which case it overestimates the AA pixel
        -:  140://   coverage. Thus, anti-aliasing of intersecting shapes may look wrong. If
        -:  141://   this turns out to be a problem, you can re-enable the old rasterizer with
        -:  142://        #define STBTT_RASTERIZER_VERSION 1
        -:  143://   which will incur about a 15% speed hit.
        -:  144://
        -:  145:// ADDITIONAL DOCUMENTATION
        -:  146://
        -:  147://   Immediately after this block comment are a series of sample programs.
        -:  148://
        -:  149://   After the sample programs is the "header file" section. This section
        -:  150://   includes documentation for each API function.
        -:  151://
        -:  152://   Some important concepts to understand to use this library:
        -:  153://
        -:  154://      Codepoint
        -:  155://         Characters are defined by unicode codepoints, e.g. 65 is
        -:  156://         uppercase A, 231 is lowercase c with a cedilla, 0x7e30 is
        -:  157://         the hiragana for "ma".
        -:  158://
        -:  159://      Glyph
        -:  160://         A visual character shape (every codepoint is rendered as
        -:  161://         some glyph)
        -:  162://
        -:  163://      Glyph index
        -:  164://         A font-specific integer ID representing a glyph
        -:  165://
        -:  166://      Baseline
        -:  167://         Glyph shapes are defined relative to a baseline, which is the
        -:  168://         bottom of uppercase characters. Characters extend both above
        -:  169://         and below the baseline.
        -:  170://
        -:  171://      Current Point
        -:  172://         As you draw text to the screen, you keep track of a "current point"
        -:  173://         which is the origin of each character. The current point's vertical
        -:  174://         position is the baseline. Even "baked fonts" use this model.
        -:  175://
        -:  176://      Vertical Font Metrics
        -:  177://         The vertical qualities of the font, used to vertically position
        -:  178://         and space the characters. See docs for stbtt_GetFontVMetrics.
        -:  179://
        -:  180://      Font Size in Pixels or Points
        -:  181://         The preferred interface for specifying font sizes in stb_truetype
        -:  182://         is to specify how tall the font's vertical extent should be in pixels.
        -:  183://         If that sounds good enough, skip the next paragraph.
        -:  184://
        -:  185://         Most font APIs instead use "points", which are a common typographic
        -:  186://         measurement for describing font size, defined as 72 points per inch.
        -:  187://         stb_truetype provides a point API for compatibility. However, true
        -:  188://         "per inch" conventions don't make much sense on computer displays
        -:  189://         since different monitors have different number of pixels per
        -:  190://         inch. For example, Windows traditionally uses a convention that
        -:  191://         there are 96 pixels per inch, thus making 'inch' measurements have
        -:  192://         nothing to do with inches, and thus effectively defining a point to
        -:  193://         be 1.333 pixels. Additionally, the TrueType font data provides
        -:  194://         an explicit scale factor to scale a given font's glyphs to points,
        -:  195://         but the author has observed that this scale factor is often wrong
        -:  196://         for non-commercial fonts, thus making fonts scaled in points
        -:  197://         according to the TrueType spec incoherently sized in practice.
        -:  198://
        -:  199:// DETAILED USAGE:
        -:  200://
        -:  201://  Scale:
        -:  202://    Select how high you want the font to be, in points or pixels.
        -:  203://    Call ScaleForPixelHeight or ScaleForMappingEmToPixels to compute
        -:  204://    a scale factor SF that will be used by all other functions.
        -:  205://
        -:  206://  Baseline:
        -:  207://    You need to select a y-coordinate that is the baseline of where
        -:  208://    your text will appear. Call GetFontBoundingBox to get the baseline-relative
        -:  209://    bounding box for all characters. SF*-y0 will be the distance in pixels
        -:  210://    that the worst-case character could extend above the baseline, so if
        -:  211://    you want the top edge of characters to appear at the top of the
        -:  212://    screen where y=0, then you would set the baseline to SF*-y0.
        -:  213://
        -:  214://  Current point:
        -:  215://    Set the current point where the first character will appear. The
        -:  216://    first character could extend left of the current point; this is font
        -:  217://    dependent. You can either choose a current point that is the leftmost
        -:  218://    point and hope, or add some padding, or check the bounding box or
        -:  219://    left-side-bearing of the first character to be displayed and set
        -:  220://    the current point based on that.
        -:  221://
        -:  222://  Displaying a character:
        -:  223://    Compute the bounding box of the character. It will contain signed values
        -:  224://    relative to <current_point, baseline>. I.e. if it returns x0,y0,x1,y1,
        -:  225://    then the character should be displayed in the rectangle from
        -:  226://    <current_point+SF*x0, baseline+SF*y0> to <current_point+SF*x1,baseline+SF*y1).
        -:  227://
        -:  228://  Advancing for the next character:
        -:  229://    Call GlyphHMetrics, and compute 'current_point += SF * advance'.
        -:  230://
        -:  231://
        -:  232:// ADVANCED USAGE
        -:  233://
        -:  234://   Quality:
        -:  235://
        -:  236://    - Use the functions with Subpixel at the end to allow your characters
        -:  237://      to have subpixel positioning. Since the font is anti-aliased, not
        -:  238://      hinted, this is very import for quality. (This is not possible with
        -:  239://      baked fonts.)
        -:  240://
        -:  241://    - Kerning is now supported, and if you're supporting subpixel rendering
        -:  242://      then kerning is worth using to give your text a polished look.
        -:  243://
        -:  244://   Performance:
        -:  245://
        -:  246://    - Convert Unicode codepoints to glyph indexes and operate on the glyphs;
        -:  247://      if you don't do this, stb_truetype is forced to do the conversion on
        -:  248://      every call.
        -:  249://
        -:  250://    - There are a lot of memory allocations. We should modify it to take
        -:  251://      a temp buffer and allocate from the temp buffer (without freeing),
        -:  252://      should help performance a lot.
        -:  253://
        -:  254:// NOTES
        -:  255://
        -:  256://   The system uses the raw data found in the .ttf file without changing it
        -:  257://   and without building auxiliary data structures. This is a bit inefficient
        -:  258://   on little-endian systems (the data is big-endian), but assuming you're
        -:  259://   caching the bitmaps or glyph shapes this shouldn't be a big deal.
        -:  260://
        -:  261://   It appears to be very hard to programmatically determine what font a
        -:  262://   given file is in a general way. I provide an API for this, but I don't
        -:  263://   recommend it.
        -:  264://
        -:  265://
        -:  266:// PERFORMANCE MEASUREMENTS FOR 1.06:
        -:  267://
        -:  268://                      32-bit     64-bit
        -:  269://   Previous release:  8.83 s     7.68 s
        -:  270://   Pool allocations:  7.72 s     6.34 s
        -:  271://   Inline sort     :  6.54 s     5.65 s
        -:  272://   New rasterizer  :  5.63 s     5.00 s
        -:  273:
        -:  274://////////////////////////////////////////////////////////////////////////////
        -:  275://////////////////////////////////////////////////////////////////////////////
        -:  276:////
        -:  277:////  SAMPLE PROGRAMS
        -:  278:////
        -:  279://
        -:  280://  Incomplete text-in-3d-api example, which draws quads properly aligned to be lossless.
        -:  281://  See "tests/truetype_demo_win32.c" for a complete version.
        -:  282:#if 0
        -:  283:#define STB_TRUETYPE_IMPLEMENTATION  // force following include to generate implementation
        -:  284:#include "stb_truetype.h"
        -:  285:
        -:  286:unsigned char ttf_buffer[1<<20];
        -:  287:unsigned char temp_bitmap[512*512];
        -:  288:
        -:  289:stbtt_bakedchar cdata[96]; // ASCII 32..126 is 95 glyphs
        -:  290:GLuint ftex;
        -:  291:
        -:  292:void my_stbtt_initfont(void)
        -:  293:{
        -:  294:   fread(ttf_buffer, 1, 1<<20, fopen("c:/windows/fonts/times.ttf", "rb"));
        -:  295:   stbtt_BakeFontBitmap(ttf_buffer,0, 32.0, temp_bitmap,512,512, 32,96, cdata); // no guarantee this fits!
        -:  296:   // can free ttf_buffer at this point
        -:  297:   glGenTextures(1, &ftex);
        -:  298:   glBindTexture(GL_TEXTURE_2D, ftex);
        -:  299:   glTexImage2D(GL_TEXTURE_2D, 0, GL_ALPHA, 512,512, 0, GL_ALPHA, GL_UNSIGNED_BYTE, temp_bitmap);
        -:  300:   // can free temp_bitmap at this point
        -:  301:   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        -:  302:}
        -:  303:
        -:  304:void my_stbtt_print(float x, float y, char *text)
        -:  305:{
        -:  306:   // assume orthographic projection with units = screen pixels, origin at top left
        -:  307:   glEnable(GL_BLEND);
        -:  308:   glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
        -:  309:   glEnable(GL_TEXTURE_2D);
        -:  310:   glBindTexture(GL_TEXTURE_2D, ftex);
        -:  311:   glBegin(GL_QUADS);
        -:  312:   while (*text) {
        -:  313:      if (*text >= 32 && *text < 128) {
        -:  314:         stbtt_aligned_quad q;
        -:  315:         stbtt_GetBakedQuad(cdata, 512,512, *text-32, &x,&y,&q,1);//1=opengl & d3d10+,0=d3d9
        -:  316:         glTexCoord2f(q.s0,q.t0); glVertex2f(q.x0,q.y0);
        -:  317:         glTexCoord2f(q.s1,q.t0); glVertex2f(q.x1,q.y0);
        -:  318:         glTexCoord2f(q.s1,q.t1); glVertex2f(q.x1,q.y1);
        -:  319:         glTexCoord2f(q.s0,q.t1); glVertex2f(q.x0,q.y1);
        -:  320:      }
        -:  321:      ++text;
        -:  322:   }
        -:  323:   glEnd();
        -:  324:}
        -:  325:#endif
        -:  326://
        -:  327://
        -:  328://////////////////////////////////////////////////////////////////////////////
        -:  329://
        -:  330:// Complete program (this compiles): get a single bitmap, print as ASCII art
        -:  331://
        -:  332:#if 0
        -:  333:#include <stdio.h>
        -:  334:#define STB_TRUETYPE_IMPLEMENTATION  // force following include to generate implementation
        -:  335:#include "stb_truetype.h"
        -:  336:
        -:  337:char ttf_buffer[1<<25];
        -:  338:
        -:  339:int main(int argc, char **argv)
        -:  340:{
        -:  341:   stbtt_fontinfo font;
        -:  342:   unsigned char *bitmap;
        -:  343:   int w,h,i,j,c = (argc > 1 ? atoi(argv[1]) : 'a'), s = (argc > 2 ? atoi(argv[2]) : 20);
        -:  344:
        -:  345:   fread(ttf_buffer, 1, 1<<25, fopen(argc > 3 ? argv[3] : "c:/windows/fonts/arialbd.ttf", "rb"));
        -:  346:
        -:  347:   stbtt_InitFont(&font, ttf_buffer, stbtt_GetFontOffsetForIndex(ttf_buffer,0));
        -:  348:   bitmap = stbtt_GetCodepointBitmap(&font, 0,stbtt_ScaleForPixelHeight(&font, s), c, &w, &h, 0,0);
        -:  349:
        -:  350:   for (j=0; j < h; ++j) {
        -:  351:      for (i=0; i < w; ++i)
        -:  352:         putchar(" .:ioVM@"[bitmap[j*w+i]>>5]);
        -:  353:      putchar('\n');
        -:  354:   }
        -:  355:   return 0;
        -:  356:}
        -:  357:#endif
        -:  358://
        -:  359:// Output:
        -:  360://
        -:  361://     .ii.
        -:  362://    @@@@@@.
        -:  363://   V@Mio@@o
        -:  364://   :i.  V@V
        -:  365://     :oM@@M
        -:  366://   :@@@MM@M
        -:  367://   @@o  o@M
        -:  368://  :@@.  M@M
        -:  369://   @@@o@@@@
        -:  370://   :M@@V:@@.
        -:  371://
        -:  372://////////////////////////////////////////////////////////////////////////////
        -:  373://
        -:  374:// Complete program: print "Hello World!" banner, with bugs
        -:  375://
        -:  376:#if 0
        -:  377:char buffer[24<<20];
        -:  378:unsigned char screen[20][79];
        -:  379:
        -:  380:int main(int arg, char **argv)
        -:  381:{
        -:  382:   stbtt_fontinfo font;
        -:  383:   int i,j,ascent,baseline,ch=0;
        -:  384:   float scale, xpos=2; // leave a little padding in case the character extends left
        -:  385:   char *text = "Heljo World!"; // intentionally misspelled to show 'lj' brokenness
        -:  386:
        -:  387:   fread(buffer, 1, 1000000, fopen("c:/windows/fonts/arialbd.ttf", "rb"));
        -:  388:   stbtt_InitFont(&font, buffer, 0);
        -:  389:
        -:  390:   scale = stbtt_ScaleForPixelHeight(&font, 15);
        -:  391:   stbtt_GetFontVMetrics(&font, &ascent,0,0);
        -:  392:   baseline = (int) (ascent*scale);
        -:  393:
        -:  394:   while (text[ch]) {
        -:  395:      int advance,lsb,x0,y0,x1,y1;
        -:  396:      float x_shift = xpos - (float) floor(xpos);
        -:  397:      stbtt_GetCodepointHMetrics(&font, text[ch], &advance, &lsb);
        -:  398:      stbtt_GetCodepointBitmapBoxSubpixel(&font, text[ch], scale,scale,x_shift,0, &x0,&y0,&x1,&y1);
        -:  399:      stbtt_MakeCodepointBitmapSubpixel(&font, &screen[baseline + y0][(int) xpos + x0], x1-x0,y1-y0, 79, scale,scale,x_shift,0, text[ch]);
        -:  400:      // note that this stomps the old data, so where character boxes overlap (e.g. 'lj') it's wrong
        -:  401:      // because this API is really for baking character bitmaps into textures. if you want to render
        -:  402:      // a sequence of characters, you really need to render each bitmap to a temp buffer, then
        -:  403:      // "alpha blend" that into the working buffer
        -:  404:      xpos += (advance * scale);
        -:  405:      if (text[ch+1])
        -:  406:         xpos += scale*stbtt_GetCodepointKernAdvance(&font, text[ch],text[ch+1]);
        -:  407:      ++ch;
        -:  408:   }
        -:  409:
        -:  410:   for (j=0; j < 20; ++j) {
        -:  411:      for (i=0; i < 78; ++i)
        -:  412:         putchar(" .:ioVM@"[screen[j][i]>>5]);
        -:  413:      putchar('\n');
        -:  414:   }
        -:  415:
        -:  416:   return 0;
        -:  417:}
        -:  418:#endif
        -:  419:
        -:  420:
        -:  421://////////////////////////////////////////////////////////////////////////////
        -:  422://////////////////////////////////////////////////////////////////////////////
        -:  423:////
        -:  424:////   INTEGRATION WITH YOUR CODEBASE
        -:  425:////
        -:  426:////   The following sections allow you to supply alternate definitions
        -:  427:////   of C library functions used by stb_truetype, e.g. if you don't
        -:  428:////   link with the C runtime library.
        -:  429:
        -:  430:#ifdef STB_TRUETYPE_IMPLEMENTATION
        -:  431:   // #define your own (u)stbtt_int8/16/32 before including to override this
        -:  432:   #ifndef stbtt_uint8
        -:  433:   typedef unsigned char   stbtt_uint8;
        -:  434:   typedef signed   char   stbtt_int8;
        -:  435:   typedef unsigned short  stbtt_uint16;
        -:  436:   typedef signed   short  stbtt_int16;
        -:  437:   typedef unsigned int    stbtt_uint32;
        -:  438:   typedef signed   int    stbtt_int32;
        -:  439:   #endif
        -:  440:
        -:  441:   typedef char stbtt__check_size32[sizeof(stbtt_int32)==4 ? 1 : -1];
        -:  442:   typedef char stbtt__check_size16[sizeof(stbtt_int16)==2 ? 1 : -1];
        -:  443:
        -:  444:   // e.g. #define your own STBTT_ifloor/STBTT_iceil() to avoid math.h
        -:  445:   #ifndef STBTT_ifloor
        -:  446:   #include <math.h>
        -:  447:   #define STBTT_ifloor(x)   ((int) floor(x))
        -:  448:   #define STBTT_iceil(x)    ((int) ceil(x))
        -:  449:   #endif
        -:  450:
        -:  451:   #ifndef STBTT_sqrt
        -:  452:   #include <math.h>
        -:  453:   #define STBTT_sqrt(x)      sqrt(x)
        -:  454:   #define STBTT_pow(x,y)     pow(x,y)
        -:  455:   #endif
        -:  456:
        -:  457:   #ifndef STBTT_fmod
        -:  458:   #include <math.h>
        -:  459:   #define STBTT_fmod(x,y)    fmod(x,y)
        -:  460:   #endif
        -:  461:
        -:  462:   #ifndef STBTT_cos
        -:  463:   #include <math.h>
        -:  464:   #define STBTT_cos(x)       cos(x)
        -:  465:   #define STBTT_acos(x)      acos(x)
        -:  466:   #endif
        -:  467:
        -:  468:   #ifndef STBTT_fabs
        -:  469:   #include <math.h>
        -:  470:   #define STBTT_fabs(x)      fabs(x)
        -:  471:   #endif
        -:  472:
        -:  473:   // #define your own functions "STBTT_malloc" / "STBTT_free" to avoid malloc.h
        -:  474:   #ifndef STBTT_malloc
        -:  475:   #include <stdlib.h>
        -:  476:   #define STBTT_malloc(x,u)  ((void)(u),malloc(x))
        -:  477:   #define STBTT_free(x,u)    ((void)(u),free(x))
        -:  478:   #endif
        -:  479:
        -:  480:   #ifndef STBTT_assert
        -:  481:   #include <assert.h>
        -:  482:   #define STBTT_assert(x)    assert(x)
        -:  483:   #endif
        -:  484:
        -:  485:   #ifndef STBTT_strlen
        -:  486:   #include <string.h>
        -:  487:   #define STBTT_strlen(x)    strlen(x)
        -:  488:   #endif
        -:  489:
        -:  490:   #ifndef STBTT_memcpy
        -:  491:   #include <string.h>
        -:  492:   #define STBTT_memcpy       memcpy
        -:  493:   #define STBTT_memset       memset
        -:  494:   #endif
        -:  495:#endif
        -:  496:
        -:  497:///////////////////////////////////////////////////////////////////////////////
        -:  498:///////////////////////////////////////////////////////////////////////////////
        -:  499:////
        -:  500:////   INTERFACE
        -:  501:////
        -:  502:////
        -:  503:
        -:  504:#ifndef __STB_INCLUDE_STB_TRUETYPE_H__
        -:  505:#define __STB_INCLUDE_STB_TRUETYPE_H__
        -:  506:
        -:  507:#ifdef STBTT_STATIC
        -:  508:#define STBTT_DEF static
        -:  509:#else
        -:  510:#define STBTT_DEF extern
        -:  511:#endif
        -:  512:
        -:  513:#ifdef __cplusplus
        -:  514:extern "C" {
        -:  515:#endif
        -:  516:
        -:  517:// private structure
        -:  518:typedef struct
        -:  519:{
        -:  520:   unsigned char *data;
        -:  521:   int cursor;
        -:  522:   int size;
        -:  523:} stbtt__buf;
        -:  524:
        -:  525://////////////////////////////////////////////////////////////////////////////
        -:  526://
        -:  527:// TEXTURE BAKING API
        -:  528://
        -:  529:// If you use this API, you only have to call two functions ever.
        -:  530://
        -:  531:
        -:  532:typedef struct
        -:  533:{
        -:  534:   unsigned short x0,y0,x1,y1; // coordinates of bbox in bitmap
        -:  535:   float xoff,yoff,xadvance;
        -:  536:} stbtt_bakedchar;
        -:  537:
        -:  538:STBTT_DEF int stbtt_BakeFontBitmap(const unsigned char *data, int offset,  // font location (use offset=0 for plain .ttf)
        -:  539:                                float pixel_height,                     // height of font in pixels
        -:  540:                                unsigned char *pixels, int pw, int ph,  // bitmap to be filled in
        -:  541:                                int first_char, int num_chars,          // characters to bake
        -:  542:                                stbtt_bakedchar *chardata);             // you allocate this, it's num_chars long
        -:  543:// if return is positive, the first unused row of the bitmap
        -:  544:// if return is negative, returns the negative of the number of characters that fit
        -:  545:// if return is 0, no characters fit and no rows were used
        -:  546:// This uses a very crappy packing.
        -:  547:
        -:  548:typedef struct
        -:  549:{
        -:  550:   float x0,y0,s0,t0; // top-left
        -:  551:   float x1,y1,s1,t1; // bottom-right
        -:  552:} stbtt_aligned_quad;
        -:  553:
        -:  554:STBTT_DEF void stbtt_GetBakedQuad(const stbtt_bakedchar *chardata, int pw, int ph,  // same data as above
        -:  555:                               int char_index,             // character to display
        -:  556:                               float *xpos, float *ypos,   // pointers to current position in screen pixel space
        -:  557:                               stbtt_aligned_quad *q,      // output: quad to draw
        -:  558:                               int opengl_fillrule);       // true if opengl fill rule; false if DX9 or earlier
        -:  559:// Call GetBakedQuad with char_index = 'character - first_char', and it
        -:  560:// creates the quad you need to draw and advances the current position.
        -:  561://
        -:  562:// The coordinate system used assumes y increases downwards.
        -:  563://
        -:  564:// Characters will extend both above and below the current position;
        -:  565:// see discussion of "BASELINE" above.
        -:  566://
        -:  567:// It's inefficient; you might want to c&p it and optimize it.
        -:  568:
        -:  569:STBTT_DEF void stbtt_GetScaledFontVMetrics(const unsigned char *fontdata, int index, float size, float *ascent, float *descent, float *lineGap);
        -:  570:// Query the font vertical metrics without having to create a font first.
        -:  571:
        -:  572:
        -:  573://////////////////////////////////////////////////////////////////////////////
        -:  574://
        -:  575:// NEW TEXTURE BAKING API
        -:  576://
        -:  577:// This provides options for packing multiple fonts into one atlas, not
        -:  578:// perfectly but better than nothing.
        -:  579:
        -:  580:typedef struct
        -:  581:{
        -:  582:   unsigned short x0,y0,x1,y1; // coordinates of bbox in bitmap
        -:  583:   float xoff,yoff,xadvance;
        -:  584:   float xoff2,yoff2;
        -:  585:} stbtt_packedchar;
        -:  586:
        -:  587:typedef struct stbtt_pack_context stbtt_pack_context;
        -:  588:typedef struct stbtt_fontinfo stbtt_fontinfo;
        -:  589:#ifndef STB_RECT_PACK_VERSION
        -:  590:typedef struct stbrp_rect stbrp_rect;
        -:  591:#endif
        -:  592:
        -:  593:STBTT_DEF int  stbtt_PackBegin(stbtt_pack_context *spc, unsigned char *pixels, int width, int height, int stride_in_bytes, int padding, void *alloc_context);
        -:  594:// Initializes a packing context stored in the passed-in stbtt_pack_context.
        -:  595:// Future calls using this context will pack characters into the bitmap passed
        -:  596:// in here: a 1-channel bitmap that is width * height. stride_in_bytes is
        -:  597:// the distance from one row to the next (or 0 to mean they are packed tightly
        -:  598:// together). "padding" is the amount of padding to leave between each
        -:  599:// character (normally you want '1' for bitmaps you'll use as textures with
        -:  600:// bilinear filtering).
        -:  601://
        -:  602:// Returns 0 on failure, 1 on success.
        -:  603:
        -:  604:STBTT_DEF void stbtt_PackEnd  (stbtt_pack_context *spc);
        -:  605:// Cleans up the packing context and frees all memory.
        -:  606:
        -:  607:#define STBTT_POINT_SIZE(x)   (-(x))
        -:  608:
        -:  609:STBTT_DEF int  stbtt_PackFontRange(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, float font_size,
        -:  610:                                int first_unicode_char_in_range, int num_chars_in_range, stbtt_packedchar *chardata_for_range);
        -:  611:// Creates character bitmaps from the font_index'th font found in fontdata (use
        -:  612:// font_index=0 if you don't know what that is). It creates num_chars_in_range
        -:  613:// bitmaps for characters with unicode values starting at first_unicode_char_in_range
        -:  614:// and increasing. Data for how to render them is stored in chardata_for_range;
        -:  615:// pass these to stbtt_GetPackedQuad to get back renderable quads.
        -:  616://
        -:  617:// font_size is the full height of the character from ascender to descender,
        -:  618:// as computed by stbtt_ScaleForPixelHeight. To use a point size as computed
        -:  619:// by stbtt_ScaleForMappingEmToPixels, wrap the point size in STBTT_POINT_SIZE()
        -:  620:// and pass that result as 'font_size':
        -:  621://       ...,                  20 , ... // font max minus min y is 20 pixels tall
        -:  622://       ..., STBTT_POINT_SIZE(20), ... // 'M' is 20 pixels tall
        -:  623:
        -:  624:typedef struct
        -:  625:{
        -:  626:   float font_size;
        -:  627:   int first_unicode_codepoint_in_range;  // if non-zero, then the chars are continuous, and this is the first codepoint
        -:  628:   int *array_of_unicode_codepoints;       // if non-zero, then this is an array of unicode codepoints
        -:  629:   int num_chars;
        -:  630:   stbtt_packedchar *chardata_for_range; // output
        -:  631:   unsigned char h_oversample, v_oversample; // don't set these, they're used internally
        -:  632:} stbtt_pack_range;
        -:  633:
        -:  634:STBTT_DEF int  stbtt_PackFontRanges(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, stbtt_pack_range *ranges, int num_ranges);
        -:  635:// Creates character bitmaps from multiple ranges of characters stored in
        -:  636:// ranges. This will usually create a better-packed bitmap than multiple
        -:  637:// calls to stbtt_PackFontRange. Note that you can call this multiple
        -:  638:// times within a single PackBegin/PackEnd.
        -:  639:
        -:  640:STBTT_DEF void stbtt_PackSetOversampling(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample);
        -:  641:// Oversampling a font increases the quality by allowing higher-quality subpixel
        -:  642:// positioning, and is especially valuable at smaller text sizes.
        -:  643://
        -:  644:// This function sets the amount of oversampling for all following calls to
        -:  645:// stbtt_PackFontRange(s) or stbtt_PackFontRangesGatherRects for a given
        -:  646:// pack context. The default (no oversampling) is achieved by h_oversample=1
        -:  647:// and v_oversample=1. The total number of pixels required is
        -:  648:// h_oversample*v_oversample larger than the default; for example, 2x2
        -:  649:// oversampling requires 4x the storage of 1x1. For best results, render
        -:  650:// oversampled textures with bilinear filtering. Look at the readme in
        -:  651:// stb/tests/oversample for information about oversampled fonts
        -:  652://
        -:  653:// To use with PackFontRangesGather etc., you must set it before calls
        -:  654:// call to PackFontRangesGatherRects.
        -:  655:
        -:  656:STBTT_DEF void stbtt_PackSetSkipMissingCodepoints(stbtt_pack_context *spc, int skip);
        -:  657:// If skip != 0, this tells stb_truetype to skip any codepoints for which
        -:  658:// there is no corresponding glyph. If skip=0, which is the default, then
        -:  659:// codepoints without a glyph received the font's "missing character" glyph,
        -:  660:// typically an empty box by convention.
        -:  661:
        -:  662:STBTT_DEF void stbtt_GetPackedQuad(const stbtt_packedchar *chardata, int pw, int ph,  // same data as above
        -:  663:                               int char_index,             // character to display
        -:  664:                               float *xpos, float *ypos,   // pointers to current position in screen pixel space
        -:  665:                               stbtt_aligned_quad *q,      // output: quad to draw
        -:  666:                               int align_to_integer);
        -:  667:
        -:  668:STBTT_DEF int  stbtt_PackFontRangesGatherRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects);
        -:  669:STBTT_DEF void stbtt_PackFontRangesPackRects(stbtt_pack_context *spc, stbrp_rect *rects, int num_rects);
        -:  670:STBTT_DEF int  stbtt_PackFontRangesRenderIntoRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects);
        -:  671:// Calling these functions in sequence is roughly equivalent to calling
        -:  672:// stbtt_PackFontRanges(). If you more control over the packing of multiple
        -:  673:// fonts, or if you want to pack custom data into a font texture, take a look
        -:  674:// at the source to of stbtt_PackFontRanges() and create a custom version
        -:  675:// using these functions, e.g. call GatherRects multiple times,
        -:  676:// building up a single array of rects, then call PackRects once,
        -:  677:// then call RenderIntoRects repeatedly. This may result in a
        -:  678:// better packing than calling PackFontRanges multiple times
        -:  679:// (or it may not).
        -:  680:
        -:  681:// this is an opaque structure that you shouldn't mess with which holds
        -:  682:// all the context needed from PackBegin to PackEnd.
        -:  683:struct stbtt_pack_context {
        -:  684:   void *user_allocator_context;
        -:  685:   void *pack_info;
        -:  686:   int   width;
        -:  687:   int   height;
        -:  688:   int   stride_in_bytes;
        -:  689:   int   padding;
        -:  690:   int   skip_missing;
        -:  691:   unsigned int   h_oversample, v_oversample;
        -:  692:   unsigned char *pixels;
        -:  693:   void  *nodes;
        -:  694:};
        -:  695:
        -:  696://////////////////////////////////////////////////////////////////////////////
        -:  697://
        -:  698:// FONT LOADING
        -:  699://
        -:  700://
        -:  701:
        -:  702:STBTT_DEF int stbtt_GetNumberOfFonts(const unsigned char *data);
        -:  703:// This function will determine the number of fonts in a font file.  TrueType
        -:  704:// collection (.ttc) files may contain multiple fonts, while TrueType font
        -:  705:// (.ttf) files only contain one font. The number of fonts can be used for
        -:  706:// indexing with the previous function where the index is between zero and one
        -:  707:// less than the total fonts. If an error occurs, -1 is returned.
        -:  708:
        -:  709:STBTT_DEF int stbtt_GetFontOffsetForIndex(const unsigned char *data, int index);
        -:  710:// Each .ttf/.ttc file may have more than one font. Each font has a sequential
        -:  711:// index number starting from 0. Call this function to get the font offset for
        -:  712:// a given index; it returns -1 if the index is out of range. A regular .ttf
        -:  713:// file will only define one font and it always be at offset 0, so it will
        -:  714:// return '0' for index 0, and -1 for all other indices.
        -:  715:
        -:  716:// The following structure is defined publicly so you can declare one on
        -:  717:// the stack or as a global or etc, but you should treat it as opaque.
        -:  718:struct stbtt_fontinfo
        -:  719:{
        -:  720:   void           * userdata;
        -:  721:   unsigned char  * data;              // pointer to .ttf file
        -:  722:   int              fontstart;         // offset of start of font
        -:  723:
        -:  724:   int numGlyphs;                     // number of glyphs, needed for range checking
        -:  725:
        -:  726:   int loca,head,glyf,hhea,hmtx,kern,gpos,svg; // table locations as offset from start of .ttf
        -:  727:   int index_map;                     // a cmap mapping for our chosen character encoding
        -:  728:   int indexToLocFormat;              // format needed to map from glyph index to glyph
        -:  729:
        -:  730:   stbtt__buf cff;                    // cff font data
        -:  731:   stbtt__buf charstrings;            // the charstring index
        -:  732:   stbtt__buf gsubrs;                 // global charstring subroutines index
        -:  733:   stbtt__buf subrs;                  // private charstring subroutines index
        -:  734:   stbtt__buf fontdicts;              // array of font dicts
        -:  735:   stbtt__buf fdselect;               // map from glyph to fontdict
        -:  736:};
        -:  737:
        -:  738:STBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data, int offset);
        -:  739:// Given an offset into the file that defines a font, this function builds
        -:  740:// the necessary cached info for the rest of the system. You must allocate
        -:  741:// the stbtt_fontinfo yourself, and stbtt_InitFont will fill it out. You don't
        -:  742:// need to do anything special to free it, because the contents are pure
        -:  743:// value data with no additional data structures. Returns 0 on failure.
        -:  744:
        -:  745:
        -:  746://////////////////////////////////////////////////////////////////////////////
        -:  747://
        -:  748:// CHARACTER TO GLYPH-INDEX CONVERSIOn
        -:  749:
        -:  750:STBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint);
        -:  751:// If you're going to perform multiple operations on the same character
        -:  752:// and you want a speed-up, call this function with the character you're
        -:  753:// going to process, then use glyph-based functions instead of the
        -:  754:// codepoint-based functions.
        -:  755:// Returns 0 if the character codepoint is not defined in the font.
        -:  756:
        -:  757:
        -:  758://////////////////////////////////////////////////////////////////////////////
        -:  759://
        -:  760:// CHARACTER PROPERTIES
        -:  761://
        -:  762:
        -:  763:STBTT_DEF float stbtt_ScaleForPixelHeight(const stbtt_fontinfo *info, float pixels);
        -:  764:// computes a scale factor to produce a font whose "height" is 'pixels' tall.
        -:  765:// Height is measured as the distance from the highest ascender to the lowest
        -:  766:// descender; in other words, it's equivalent to calling stbtt_GetFontVMetrics
        -:  767:// and computing:
        -:  768://       scale = pixels / (ascent - descent)
        -:  769:// so if you prefer to measure height by the ascent only, use a similar calculation.
        -:  770:
        -:  771:STBTT_DEF float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo *info, float pixels);
        -:  772:// computes a scale factor to produce a font whose EM size is mapped to
        -:  773:// 'pixels' tall. This is probably what traditional APIs compute, but
        -:  774:// I'm not positive.
        -:  775:
        -:  776:STBTT_DEF void stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap);
        -:  777:// ascent is the coordinate above the baseline the font extends; descent
        -:  778:// is the coordinate below the baseline the font extends (i.e. it is typically negative)
        -:  779:// lineGap is the spacing between one row's descent and the next row's ascent...
        -:  780:// so you should advance the vertical position by "*ascent - *descent + *lineGap"
        -:  781://   these are expressed in unscaled coordinates, so you must multiply by
        -:  782://   the scale factor for a given size
        -:  783:
        -:  784:STBTT_DEF int  stbtt_GetFontVMetricsOS2(const stbtt_fontinfo *info, int *typoAscent, int *typoDescent, int *typoLineGap);
        -:  785:// analogous to GetFontVMetrics, but returns the "typographic" values from the OS/2
        -:  786:// table (specific to MS/Windows TTF files).
        -:  787://
        -:  788:// Returns 1 on success (table present), 0 on failure.
        -:  789:
        -:  790:STBTT_DEF void stbtt_GetFontBoundingBox(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1);
        -:  791:// the bounding box around all possible characters
        -:  792:
        -:  793:STBTT_DEF void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing);
        -:  794:// leftSideBearing is the offset from the current horizontal position to the left edge of the character
        -:  795:// advanceWidth is the offset from the current horizontal position to the next horizontal position
        -:  796://   these are expressed in unscaled coordinates
        -:  797:
        -:  798:STBTT_DEF int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2);
        -:  799:// an additional amount to add to the 'advance' value between ch1 and ch2
        -:  800:
        -:  801:STBTT_DEF int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1);
        -:  802:// Gets the bounding box of the visible part of the glyph, in unscaled coordinates
        -:  803:
        -:  804:STBTT_DEF void stbtt_GetGlyphHMetrics(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing);
        -:  805:STBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2);
        -:  806:STBTT_DEF int  stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1);
        -:  807:// as above, but takes one or more glyph indices for greater efficiency
        -:  808:
        -:  809:typedef struct stbtt_kerningentry
        -:  810:{
        -:  811:   int glyph1; // use stbtt_FindGlyphIndex
        -:  812:   int glyph2;
        -:  813:   int advance;
        -:  814:} stbtt_kerningentry;
        -:  815:
        -:  816:STBTT_DEF int  stbtt_GetKerningTableLength(const stbtt_fontinfo *info);
        -:  817:STBTT_DEF int  stbtt_GetKerningTable(const stbtt_fontinfo *info, stbtt_kerningentry* table, int table_length);
        -:  818:// Retrieves a complete list of all of the kerning pairs provided by the font
        -:  819:// stbtt_GetKerningTable never writes more than table_length entries and returns how many entries it did write.
        -:  820:// The table will be sorted by (a.glyph1 == b.glyph1)?(a.glyph2 < b.glyph2):(a.glyph1 < b.glyph1)
        -:  821:
        -:  822://////////////////////////////////////////////////////////////////////////////
        -:  823://
        -:  824:// GLYPH SHAPES (you probably don't need these, but they have to go before
        -:  825:// the bitmaps for C declaration-order reasons)
        -:  826://
        -:  827:
        -:  828:#ifndef STBTT_vmove // you can predefine these to use different values (but why?)
        -:  829:   enum {
        -:  830:      STBTT_vmove=1,
        -:  831:      STBTT_vline,
        -:  832:      STBTT_vcurve,
        -:  833:      STBTT_vcubic
        -:  834:   };
        -:  835:#endif
        -:  836:
        -:  837:#ifndef stbtt_vertex // you can predefine this to use different values
        -:  838:                   // (we share this with other code at RAD)
        -:  839:   #define stbtt_vertex_type short // can't use stbtt_int16 because that's not visible in the header file
        -:  840:   typedef struct
        -:  841:   {
        -:  842:      stbtt_vertex_type x,y,cx,cy,cx1,cy1;
        -:  843:      unsigned char type,padding;
        -:  844:   } stbtt_vertex;
        -:  845:#endif
        -:  846:
        -:  847:STBTT_DEF int stbtt_IsGlyphEmpty(const stbtt_fontinfo *info, int glyph_index);
        -:  848:// returns non-zero if nothing is drawn for this glyph
        -:  849:
        -:  850:STBTT_DEF int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices);
        -:  851:STBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **vertices);
        -:  852:// returns # of vertices and fills *vertices with the pointer to them
        -:  853://   these are expressed in "unscaled" coordinates
        -:  854://
        -:  855:// The shape is a series of contours. Each one starts with
        -:  856:// a STBTT_moveto, then consists of a series of mixed
        -:  857:// STBTT_lineto and STBTT_curveto segments. A lineto
        -:  858:// draws a line from previous endpoint to its x,y; a curveto
        -:  859:// draws a quadratic bezier from previous endpoint to
        -:  860:// its x,y, using cx,cy as the bezier control point.
        -:  861:
        -:  862:STBTT_DEF void stbtt_FreeShape(const stbtt_fontinfo *info, stbtt_vertex *vertices);
        -:  863:// frees the data allocated above
        -:  864:
        -:  865:STBTT_DEF unsigned char *stbtt_FindSVGDoc(const stbtt_fontinfo *info, int gl);
        -:  866:STBTT_DEF int stbtt_GetCodepointSVG(const stbtt_fontinfo *info, int unicode_codepoint, const char **svg);
        -:  867:STBTT_DEF int stbtt_GetGlyphSVG(const stbtt_fontinfo *info, int gl, const char **svg);
        -:  868:// fills svg with the character's SVG data.
        -:  869:// returns data size or 0 if SVG not found.
        -:  870:
        -:  871://////////////////////////////////////////////////////////////////////////////
        -:  872://
        -:  873:// BITMAP RENDERING
        -:  874://
        -:  875:
        -:  876:STBTT_DEF void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata);
        -:  877:// frees the bitmap allocated below
        -:  878:
        -:  879:STBTT_DEF unsigned char *stbtt_GetCodepointBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff);
        -:  880:// allocates a large-enough single-channel 8bpp bitmap and renders the
        -:  881:// specified character/glyph at the specified scale into it, with
        -:  882:// antialiasing. 0 is no coverage (transparent), 255 is fully covered (opaque).
        -:  883:// *width & *height are filled out with the width & height of the bitmap,
        -:  884:// which is stored left-to-right, top-to-bottom.
        -:  885://
        -:  886:// xoff/yoff are the offset it pixel space from the glyph origin to the top-left of the bitmap
        -:  887:
        -:  888:STBTT_DEF unsigned char *stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff);
        -:  889:// the same as stbtt_GetCodepoitnBitmap, but you can specify a subpixel
        -:  890:// shift for the character
        -:  891:
        -:  892:STBTT_DEF void stbtt_MakeCodepointBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint);
        -:  893:// the same as stbtt_GetCodepointBitmap, but you pass in storage for the bitmap
        -:  894:// in the form of 'output', with row spacing of 'out_stride' bytes. the bitmap
        -:  895:// is clipped to out_w/out_h bytes. Call stbtt_GetCodepointBitmapBox to get the
        -:  896:// width and height and positioning info for it first.
        -:  897:
        -:  898:STBTT_DEF void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint);
        -:  899:// same as stbtt_MakeCodepointBitmap, but you can specify a subpixel
        -:  900:// shift for the character
        -:  901:
        -:  902:STBTT_DEF void stbtt_MakeCodepointBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int codepoint);
        -:  903:// same as stbtt_MakeCodepointBitmapSubpixel, but prefiltering
        -:  904:// is performed (see stbtt_PackSetOversampling)
        -:  905:
        -:  906:STBTT_DEF void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1);
        -:  907:// get the bbox of the bitmap centered around the glyph origin; so the
        -:  908:// bitmap width is ix1-ix0, height is iy1-iy0, and location to place
        -:  909:// the bitmap top left is (leftSideBearing*scale,iy0).
        -:  910:// (Note that the bitmap uses y-increases-down, but the shape uses
        -:  911:// y-increases-up, so CodepointBitmapBox and CodepointBox are inverted.)
        -:  912:
        -:  913:STBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1);
        -:  914:// same as stbtt_GetCodepointBitmapBox, but you can specify a subpixel
        -:  915:// shift for the character
        -:  916:
        -:  917:// the following functions are equivalent to the above functions, but operate
        -:  918:// on glyph indices instead of Unicode codepoints (for efficiency)
        -:  919:STBTT_DEF unsigned char *stbtt_GetGlyphBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff);
        -:  920:STBTT_DEF unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff);
        -:  921:STBTT_DEF void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph);
        -:  922:STBTT_DEF void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph);
        -:  923:STBTT_DEF void stbtt_MakeGlyphBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int glyph);
        -:  924:STBTT_DEF void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1);
        -:  925:STBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1);
        -:  926:
        -:  927:
        -:  928:// @TODO: don't expose this structure
        -:  929:typedef struct
        -:  930:{
        -:  931:   int w,h,stride;
        -:  932:   unsigned char *pixels;
        -:  933:} stbtt__bitmap;
        -:  934:
        -:  935:// rasterize a shape with quadratic beziers into a bitmap
        -:  936:STBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result,        // 1-channel bitmap to draw into
        -:  937:                               float flatness_in_pixels,     // allowable error of curve in pixels
        -:  938:                               stbtt_vertex *vertices,       // array of vertices defining shape
        -:  939:                               int num_verts,                // number of vertices in above array
        -:  940:                               float scale_x, float scale_y, // scale applied to input vertices
        -:  941:                               float shift_x, float shift_y, // translation applied to input vertices
        -:  942:                               int x_off, int y_off,         // another translation applied to input
        -:  943:                               int invert,                   // if non-zero, vertically flip shape
        -:  944:                               void *userdata);              // context for to STBTT_MALLOC
        -:  945:
        -:  946://////////////////////////////////////////////////////////////////////////////
        -:  947://
        -:  948:// Signed Distance Function (or Field) rendering
        -:  949:
        -:  950:STBTT_DEF void stbtt_FreeSDF(unsigned char *bitmap, void *userdata);
        -:  951:// frees the SDF bitmap allocated below
        -:  952:
        -:  953:STBTT_DEF unsigned char * stbtt_GetGlyphSDF(const stbtt_fontinfo *info, float scale, int glyph, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff);
        -:  954:STBTT_DEF unsigned char * stbtt_GetCodepointSDF(const stbtt_fontinfo *info, float scale, int codepoint, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff);
        -:  955:// These functions compute a discretized SDF field for a single character, suitable for storing
        -:  956:// in a single-channel texture, sampling with bilinear filtering, and testing against
        -:  957:// larger than some threshold to produce scalable fonts.
        -:  958://        info              --  the font
        -:  959://        scale             --  controls the size of the resulting SDF bitmap, same as it would be creating a regular bitmap
        -:  960://        glyph/codepoint   --  the character to generate the SDF for
        -:  961://        padding           --  extra "pixels" around the character which are filled with the distance to the character (not 0),
        -:  962://                                 which allows effects like bit outlines
        -:  963://        onedge_value      --  value 0-255 to test the SDF against to reconstruct the character (i.e. the isocontour of the character)
        -:  964://        pixel_dist_scale  --  what value the SDF should increase by when moving one SDF "pixel" away from the edge (on the 0..255 scale)
        -:  965://                                 if positive, > onedge_value is inside; if negative, < onedge_value is inside
        -:  966://        width,height      --  output height & width of the SDF bitmap (including padding)
        -:  967://        xoff,yoff         --  output origin of the character
        -:  968://        return value      --  a 2D array of bytes 0..255, width*height in size
        -:  969://
        -:  970:// pixel_dist_scale & onedge_value are a scale & bias that allows you to make
        -:  971:// optimal use of the limited 0..255 for your application, trading off precision
        -:  972:// and special effects. SDF values outside the range 0..255 are clamped to 0..255.
        -:  973://
        -:  974:// Example:
        -:  975://      scale = stbtt_ScaleForPixelHeight(22)
        -:  976://      padding = 5
        -:  977://      onedge_value = 180
        -:  978://      pixel_dist_scale = 180/5.0 = 36.0
        -:  979://
        -:  980://      This will create an SDF bitmap in which the character is about 22 pixels
        -:  981://      high but the whole bitmap is about 22+5+5=32 pixels high. To produce a filled
        -:  982://      shape, sample the SDF at each pixel and fill the pixel if the SDF value
        -:  983://      is greater than or equal to 180/255. (You'll actually want to antialias,
        -:  984://      which is beyond the scope of this example.) Additionally, you can compute
        -:  985://      offset outlines (e.g. to stroke the character border inside & outside,
        -:  986://      or only outside). For example, to fill outside the character up to 3 SDF
        -:  987://      pixels, you would compare against (180-36.0*3)/255 = 72/255. The above
        -:  988://      choice of variables maps a range from 5 pixels outside the shape to
        -:  989://      2 pixels inside the shape to 0..255; this is intended primarily for apply
        -:  990://      outside effects only (the interior range is needed to allow proper
        -:  991://      antialiasing of the font at *smaller* sizes)
        -:  992://
        -:  993:// The function computes the SDF analytically at each SDF pixel, not by e.g.
        -:  994:// building a higher-res bitmap and approximating it. In theory the quality
        -:  995:// should be as high as possible for an SDF of this size & representation, but
        -:  996:// unclear if this is true in practice (perhaps building a higher-res bitmap
        -:  997:// and computing from that can allow drop-out prevention).
        -:  998://
        -:  999:// The algorithm has not been optimized at all, so expect it to be slow
        -: 1000:// if computing lots of characters or very large sizes.
        -: 1001:
        -: 1002:
        -: 1003:
        -: 1004://////////////////////////////////////////////////////////////////////////////
        -: 1005://
        -: 1006:// Finding the right font...
        -: 1007://
        -: 1008:// You should really just solve this offline, keep your own tables
        -: 1009:// of what font is what, and don't try to get it out of the .ttf file.
        -: 1010:// That's because getting it out of the .ttf file is really hard, because
        -: 1011:// the names in the file can appear in many possible encodings, in many
        -: 1012:// possible languages, and e.g. if you need a case-insensitive comparison,
        -: 1013:// the details of that depend on the encoding & language in a complex way
        -: 1014:// (actually underspecified in truetype, but also gigantic).
        -: 1015://
        -: 1016:// But you can use the provided functions in two possible ways:
        -: 1017://     stbtt_FindMatchingFont() will use *case-sensitive* comparisons on
        -: 1018://             unicode-encoded names to try to find the font you want;
        -: 1019://             you can run this before calling stbtt_InitFont()
        -: 1020://
        -: 1021://     stbtt_GetFontNameString() lets you get any of the various strings
        -: 1022://             from the file yourself and do your own comparisons on them.
        -: 1023://             You have to have called stbtt_InitFont() first.
        -: 1024:
        -: 1025:
        -: 1026:STBTT_DEF int stbtt_FindMatchingFont(const unsigned char *fontdata, const char *name, int flags);
        -: 1027:// returns the offset (not index) of the font that matches, or -1 if none
        -: 1028://   if you use STBTT_MACSTYLE_DONTCARE, use a font name like "Arial Bold".
        -: 1029://   if you use any other flag, use a font name like "Arial"; this checks
        -: 1030://     the 'macStyle' header field; i don't know if fonts set this consistently
        -: 1031:#define STBTT_MACSTYLE_DONTCARE     0
        -: 1032:#define STBTT_MACSTYLE_BOLD         1
        -: 1033:#define STBTT_MACSTYLE_ITALIC       2
        -: 1034:#define STBTT_MACSTYLE_UNDERSCORE   4
        -: 1035:#define STBTT_MACSTYLE_NONE         8   // <= not same as 0, this makes us check the bitfield is 0
        -: 1036:
        -: 1037:STBTT_DEF int stbtt_CompareUTF8toUTF16_bigendian(const char *s1, int len1, const char *s2, int len2);
        -: 1038:// returns 1/0 whether the first string interpreted as utf8 is identical to
        -: 1039:// the second string interpreted as big-endian utf16... useful for strings from next func
        -: 1040:
        -: 1041:STBTT_DEF const char *stbtt_GetFontNameString(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID);
        -: 1042:// returns the string (which may be big-endian double byte, e.g. for unicode)
        -: 1043:// and puts the length in bytes in *length.
        -: 1044://
        -: 1045:// some of the values for the IDs are below; for more see the truetype spec:
        -: 1046://     http://developer.apple.com/textfonts/TTRefMan/RM06/Chap6name.html
        -: 1047://     http://www.microsoft.com/typography/otspec/name.htm
        -: 1048:
        -: 1049:enum { // platformID
        -: 1050:   STBTT_PLATFORM_ID_UNICODE   =0,
        -: 1051:   STBTT_PLATFORM_ID_MAC       =1,
        -: 1052:   STBTT_PLATFORM_ID_ISO       =2,
        -: 1053:   STBTT_PLATFORM_ID_MICROSOFT =3
        -: 1054:};
        -: 1055:
        -: 1056:enum { // encodingID for STBTT_PLATFORM_ID_UNICODE
        -: 1057:   STBTT_UNICODE_EID_UNICODE_1_0    =0,
        -: 1058:   STBTT_UNICODE_EID_UNICODE_1_1    =1,
        -: 1059:   STBTT_UNICODE_EID_ISO_10646      =2,
        -: 1060:   STBTT_UNICODE_EID_UNICODE_2_0_BMP=3,
        -: 1061:   STBTT_UNICODE_EID_UNICODE_2_0_FULL=4
        -: 1062:};
        -: 1063:
        -: 1064:enum { // encodingID for STBTT_PLATFORM_ID_MICROSOFT
        -: 1065:   STBTT_MS_EID_SYMBOL        =0,
        -: 1066:   STBTT_MS_EID_UNICODE_BMP   =1,
        -: 1067:   STBTT_MS_EID_SHIFTJIS      =2,
        -: 1068:   STBTT_MS_EID_UNICODE_FULL  =10
        -: 1069:};
        -: 1070:
        -: 1071:enum { // encodingID for STBTT_PLATFORM_ID_MAC; same as Script Manager codes
        -: 1072:   STBTT_MAC_EID_ROMAN        =0,   STBTT_MAC_EID_ARABIC       =4,
        -: 1073:   STBTT_MAC_EID_JAPANESE     =1,   STBTT_MAC_EID_HEBREW       =5,
        -: 1074:   STBTT_MAC_EID_CHINESE_TRAD =2,   STBTT_MAC_EID_GREEK        =6,
        -: 1075:   STBTT_MAC_EID_KOREAN       =3,   STBTT_MAC_EID_RUSSIAN      =7
        -: 1076:};
        -: 1077:
        -: 1078:enum { // languageID for STBTT_PLATFORM_ID_MICROSOFT; same as LCID...
        -: 1079:       // problematic because there are e.g. 16 english LCIDs and 16 arabic LCIDs
        -: 1080:   STBTT_MS_LANG_ENGLISH     =0x0409,   STBTT_MS_LANG_ITALIAN     =0x0410,
        -: 1081:   STBTT_MS_LANG_CHINESE     =0x0804,   STBTT_MS_LANG_JAPANESE    =0x0411,
        -: 1082:   STBTT_MS_LANG_DUTCH       =0x0413,   STBTT_MS_LANG_KOREAN      =0x0412,
        -: 1083:   STBTT_MS_LANG_FRENCH      =0x040c,   STBTT_MS_LANG_RUSSIAN     =0x0419,
        -: 1084:   STBTT_MS_LANG_GERMAN      =0x0407,   STBTT_MS_LANG_SPANISH     =0x0409,
        -: 1085:   STBTT_MS_LANG_HEBREW      =0x040d,   STBTT_MS_LANG_SWEDISH     =0x041D
        -: 1086:};
        -: 1087:
        -: 1088:enum { // languageID for STBTT_PLATFORM_ID_MAC
        -: 1089:   STBTT_MAC_LANG_ENGLISH      =0 ,   STBTT_MAC_LANG_JAPANESE     =11,
        -: 1090:   STBTT_MAC_LANG_ARABIC       =12,   STBTT_MAC_LANG_KOREAN       =23,
        -: 1091:   STBTT_MAC_LANG_DUTCH        =4 ,   STBTT_MAC_LANG_RUSSIAN      =32,
        -: 1092:   STBTT_MAC_LANG_FRENCH       =1 ,   STBTT_MAC_LANG_SPANISH      =6 ,
        -: 1093:   STBTT_MAC_LANG_GERMAN       =2 ,   STBTT_MAC_LANG_SWEDISH      =5 ,
        -: 1094:   STBTT_MAC_LANG_HEBREW       =10,   STBTT_MAC_LANG_CHINESE_SIMPLIFIED =33,
        -: 1095:   STBTT_MAC_LANG_ITALIAN      =3 ,   STBTT_MAC_LANG_CHINESE_TRAD =19
        -: 1096:};
        -: 1097:
        -: 1098:#ifdef __cplusplus
        -: 1099:}
        -: 1100:#endif
        -: 1101:
        -: 1102:#endif // __STB_INCLUDE_STB_TRUETYPE_H__
        -: 1103:
        -: 1104:///////////////////////////////////////////////////////////////////////////////
        -: 1105:///////////////////////////////////////////////////////////////////////////////
        -: 1106:////
        -: 1107:////   IMPLEMENTATION
        -: 1108:////
        -: 1109:////
        -: 1110:
        -: 1111:#ifdef STB_TRUETYPE_IMPLEMENTATION
        -: 1112:
        -: 1113:#ifndef STBTT_MAX_OVERSAMPLE
        -: 1114:#define STBTT_MAX_OVERSAMPLE   8
        -: 1115:#endif
        -: 1116:
        -: 1117:#if STBTT_MAX_OVERSAMPLE > 255
        -: 1118:#error "STBTT_MAX_OVERSAMPLE cannot be > 255"
        -: 1119:#endif
        -: 1120:
        -: 1121:typedef int stbtt__test_oversample_pow2[(STBTT_MAX_OVERSAMPLE & (STBTT_MAX_OVERSAMPLE-1)) == 0 ? 1 : -1];
        -: 1122:
        -: 1123:#ifndef STBTT_RASTERIZER_VERSION
        -: 1124:#define STBTT_RASTERIZER_VERSION 2
        -: 1125:#endif
        -: 1126:
        -: 1127:#ifdef _MSC_VER
        -: 1128:#define STBTT__NOTUSED(v)  (void)(v)
        -: 1129:#else
        -: 1130:#define STBTT__NOTUSED(v)  (void)sizeof(v)
        -: 1131:#endif
        -: 1132:
        -: 1133://////////////////////////////////////////////////////////////////////////
        -: 1134://
        -: 1135:// stbtt__buf helpers to parse data from file
        -: 1136://
        -: 1137:
function _ZL15stbtt__buf_get8P10stbtt__buf called 0 returned 0% blocks executed 0%
    #####: 1138:static stbtt_uint8 stbtt__buf_get8(stbtt__buf *b)
        -: 1139:{
    #####: 1140:   if (b->cursor >= b->size)
    %%%%%: 1140-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1141:      return 0;
    %%%%%: 1141-block 3
    #####: 1142:   return b->data[b->cursor++];
    %%%%%: 1142-block 4
        -: 1143:}
        -: 1144:
function _ZL16stbtt__buf_peek8P10stbtt__buf called 0 returned 0% blocks executed 0%
    #####: 1145:static stbtt_uint8 stbtt__buf_peek8(stbtt__buf *b)
        -: 1146:{
    #####: 1147:   if (b->cursor >= b->size)
    %%%%%: 1147-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1148:      return 0;
    %%%%%: 1148-block 3
    #####: 1149:   return b->data[b->cursor];
    %%%%%: 1149-block 4
        -: 1150:}
        -: 1151:
function _ZL15stbtt__buf_seekP10stbtt__bufi called 0 returned 0% blocks executed 0%
    #####: 1152:static void stbtt__buf_seek(stbtt__buf *b, int o)
        -: 1153:{
    #####: 1154:   STBTT_assert(!(o > b->size || o < 0));
    %%%%%: 1154-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1154-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1154-block 4
    %%%%%: 1154-block 5
call    4 never executed
    #####: 1155:   b->cursor = (o > b->size || o < 0) ? b->size : o;
    %%%%%: 1155-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1155-block 7
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1155-block 8
    %%%%%: 1155-block 9
    #####: 1156:}
        -: 1157:
function _ZL15stbtt__buf_skipP10stbtt__bufi called 0 returned 0% blocks executed 0%
    #####: 1158:static void stbtt__buf_skip(stbtt__buf *b, int o)
        -: 1159:{
    #####: 1160:   stbtt__buf_seek(b, b->cursor + o);
    %%%%%: 1160-block 2
call    0 never executed
    #####: 1161:}
        -: 1162:
function _ZL14stbtt__buf_getP10stbtt__bufi called 0 returned 0% blocks executed 0%
    #####: 1163:static stbtt_uint32 stbtt__buf_get(stbtt__buf *b, int n)
        -: 1164:{
    #####: 1165:   stbtt_uint32 v = 0;
        -: 1166:   int i;
    #####: 1167:   STBTT_assert(n >= 1 && n <= 4);
    %%%%%: 1167-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1167-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1167-block 4
    %%%%%: 1167-block 5
call    4 never executed
    #####: 1168:   for (i = 0; i < n; i++)
    %%%%%: 1168-block 6
    %%%%%: 1168-block 9
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 1169:      v = (v << 8) | stbtt__buf_get8(b);
    %%%%%: 1169-block 7
call    0 never executed
    #####: 1170:   return v;
    %%%%%: 1170-block 10
        -: 1171:}
        -: 1172:
function _ZL14stbtt__new_bufPKvm called 11 returned 100% blocks executed 75%
       11: 1173:static stbtt__buf stbtt__new_buf(const void *p, size_t size)
        -: 1174:{
        -: 1175:   stbtt__buf r;
      11*: 1176:   STBTT_assert(size < 0x40000000);
       11: 1176-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 11
    %%%%%: 1176-block 3
call    2 never executed
       11: 1177:   r.data = (stbtt_uint8*) p;
       11: 1178:   r.size = (int) size;
       11: 1179:   r.cursor = 0;
       11: 1180:   return r;
       11: 1180-block 4
        -: 1181:}
        -: 1182:
        -: 1183:#define stbtt__buf_get16(b)  stbtt__buf_get((b), 2)
        -: 1184:#define stbtt__buf_get32(b)  stbtt__buf_get((b), 4)
        -: 1185:
function _ZL16stbtt__buf_rangePK10stbtt__bufii called 0 returned 0% blocks executed 0%
    #####: 1186:static stbtt__buf stbtt__buf_range(const stbtt__buf *b, int o, int s)
        -: 1187:{
    #####: 1188:   stbtt__buf r = stbtt__new_buf(NULL, 0);
    %%%%%: 1188-block 2
call    0 never executed
    #####: 1189:   if (o < 0 || s < 0 || o > b->size || s > b->size - o) return r;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1189-block 4
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1189-block 5
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 1189-block 6
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 1189-block 7
    #####: 1190:   r.data = b->data + o;
    #####: 1191:   r.size = s;
    #####: 1192:   return r;
    %%%%%: 1192-block 8
        -: 1193:}
        -: 1194:
function _ZL20stbtt__cff_get_indexP10stbtt__buf called 0 returned 0% blocks executed 0%
    #####: 1195:static stbtt__buf stbtt__cff_get_index(stbtt__buf *b)
        -: 1196:{
        -: 1197:   int count, start, offsize;
    #####: 1198:   start = b->cursor;
    #####: 1199:   count = stbtt__buf_get16(b);
    %%%%%: 1199-block 2
call    0 never executed
    #####: 1200:   if (count) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1201:      offsize = stbtt__buf_get8(b);
    %%%%%: 1201-block 4
call    0 never executed
    #####: 1202:      STBTT_assert(offsize >= 1 && offsize <= 4);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1202-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1202-block 7
    %%%%%: 1202-block 8
call    4 never executed
    #####: 1203:      stbtt__buf_skip(b, offsize * count);
    %%%%%: 1203-block 9
call    0 never executed
    #####: 1204:      stbtt__buf_skip(b, stbtt__buf_get(b, offsize) - 1);
call    0 never executed
call    1 never executed
        -: 1205:   }
    #####: 1206:   return stbtt__buf_range(b, start, b->cursor - start);
    %%%%%: 1206-block 12
call    0 never executed
        -: 1207:}
        -: 1208:
function _ZL14stbtt__cff_intP10stbtt__buf called 0 returned 0% blocks executed 0%
    #####: 1209:static stbtt_uint32 stbtt__cff_int(stbtt__buf *b)
        -: 1210:{
    #####: 1211:   int b0 = stbtt__buf_get8(b);
    %%%%%: 1211-block 2
call    0 never executed
    #####: 1212:   if (b0 >= 32 && b0 <= 246)       return b0 - 139;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1212-block 4
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1212-block 5
    #####: 1213:   else if (b0 >= 247 && b0 <= 250) return (b0 - 247)*256 + stbtt__buf_get8(b) + 108;
    %%%%%: 1213-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1213-block 7
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1213-block 8
call    4 never executed
    #####: 1214:   else if (b0 >= 251 && b0 <= 254) return -(b0 - 251)*256 - stbtt__buf_get8(b) - 108;
    %%%%%: 1214-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1214-block 11
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1214-block 12
call    4 never executed
    #####: 1215:   else if (b0 == 28)               return stbtt__buf_get16(b);
    %%%%%: 1215-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1215-block 15
call    2 never executed
    #####: 1216:   else if (b0 == 29)               return stbtt__buf_get32(b);
    %%%%%: 1216-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1216-block 17
call    2 never executed
    #####: 1217:   STBTT_assert(0);
    %%%%%: 1217-block 18
call    0 never executed
        -: 1218:   return 0;
        -: 1219:}
        -: 1220:
function _ZL23stbtt__cff_skip_operandP10stbtt__buf called 0 returned 0% blocks executed 0%
    #####: 1221:static void stbtt__cff_skip_operand(stbtt__buf *b) {
    #####: 1222:   int v, b0 = stbtt__buf_peek8(b);
    %%%%%: 1222-block 2
call    0 never executed
    #####: 1223:   STBTT_assert(b0 >= 28);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1223-block 4
call    2 never executed
    #####: 1224:   if (b0 == 30) {
    %%%%%: 1224-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1225:      stbtt__buf_skip(b, 1);
    %%%%%: 1225-block 6
call    0 never executed
    #####: 1226:      while (b->cursor < b->size) {
    %%%%%: 1226-block 11
branch  0 never executed
branch  1 never executed
    #####: 1227:         v = stbtt__buf_get8(b);
    %%%%%: 1227-block 8
call    0 never executed
    #####: 1228:         if ((v & 0xF) == 0xF || (v >> 4) == 0xF)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1228-block 10
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 1229:            break;
        -: 1230:      }
        -: 1231:   } else {
    #####: 1232:      stbtt__cff_int(b);
    %%%%%: 1232-block 12
call    0 never executed
        -: 1233:   }
    #####: 1234:}
        -: 1235:
function _ZL15stbtt__dict_getP10stbtt__bufi called 0 returned 0% blocks executed 0%
    #####: 1236:static stbtt__buf stbtt__dict_get(stbtt__buf *b, int key)
        -: 1237:{
    #####: 1238:   stbtt__buf_seek(b, 0);
    %%%%%: 1238-block 2
call    0 never executed
    #####: 1239:   while (b->cursor < b->size) {
    %%%%%: 1239-block 14
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 1240:      int start = b->cursor, end, op;
    #####: 1241:      while (stbtt__buf_peek8(b) >= 28)
    %%%%%: 1241-block 3
    %%%%%: 1241-block 5
call    0 never executed
branch  1 never executed
branch  2 never executed (fallthrough)
    #####: 1242:         stbtt__cff_skip_operand(b);
    %%%%%: 1242-block 4
call    0 never executed
    #####: 1243:      end = b->cursor;
    #####: 1244:      op = stbtt__buf_get8(b);
    %%%%%: 1244-block 7
call    0 never executed
    #####: 1245:      if (op == 12)  op = stbtt__buf_get8(b) | 0x100;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1245-block 9
call    2 never executed
    #####: 1246:      if (op == key) return stbtt__buf_range(b, start, end-start);
    %%%%%: 1246-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1246-block 12
call    2 never executed
        -: 1247:   }
    #####: 1248:   return stbtt__buf_range(b, 0, 0);
    %%%%%: 1248-block 15
call    0 never executed
        -: 1249:}
        -: 1250:
function _ZL20stbtt__dict_get_intsP10stbtt__bufiiPj called 0 returned 0% blocks executed 0%
    #####: 1251:static void stbtt__dict_get_ints(stbtt__buf *b, int key, int outcount, stbtt_uint32 *out)
        -: 1252:{
        -: 1253:   int i;
    #####: 1254:   stbtt__buf operands = stbtt__dict_get(b, key);
    %%%%%: 1254-block 2
call    0 never executed
    #####: 1255:   for (i = 0; i < outcount && operands.cursor < operands.size; i++)
    %%%%%: 1255-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1255-block 7
branch  2 never executed
branch  3 never executed (fallthrough)
    #####: 1256:      out[i] = stbtt__cff_int(&operands);
    %%%%%: 1256-block 4
call    0 never executed
    #####: 1257:}
        -: 1258:
function _ZL22stbtt__cff_index_countP10stbtt__buf called 0 returned 0% blocks executed 0%
    #####: 1259:static int stbtt__cff_index_count(stbtt__buf *b)
        -: 1260:{
    #####: 1261:   stbtt__buf_seek(b, 0);
    %%%%%: 1261-block 2
call    0 never executed
    #####: 1262:   return stbtt__buf_get16(b);
call    0 never executed
        -: 1263:}
        -: 1264:
function _ZL20stbtt__cff_index_get10stbtt__bufi called 0 returned 0% blocks executed 0%
    #####: 1265:static stbtt__buf stbtt__cff_index_get(stbtt__buf b, int i)
        -: 1266:{
        -: 1267:   int count, offsize, start, end;
    #####: 1268:   stbtt__buf_seek(&b, 0);
    %%%%%: 1268-block 2
call    0 never executed
    #####: 1269:   count = stbtt__buf_get16(&b);
call    0 never executed
    #####: 1270:   offsize = stbtt__buf_get8(&b);
call    0 never executed
    #####: 1271:   STBTT_assert(i >= 0 && i < count);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1271-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1271-block 7
    %%%%%: 1271-block 8
call    4 never executed
    #####: 1272:   STBTT_assert(offsize >= 1 && offsize <= 4);
    %%%%%: 1272-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1272-block 10
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1272-block 11
    %%%%%: 1272-block 12
call    4 never executed
    #####: 1273:   stbtt__buf_skip(&b, i*offsize);
    %%%%%: 1273-block 13
call    0 never executed
    #####: 1274:   start = stbtt__buf_get(&b, offsize);
call    0 never executed
    #####: 1275:   end = stbtt__buf_get(&b, offsize);
call    0 never executed
    #####: 1276:   return stbtt__buf_range(&b, 2+(count+1)*offsize+start, end - start);
call    0 never executed
        -: 1277:}
        -: 1278:
        -: 1279://////////////////////////////////////////////////////////////////////////
        -: 1280://
        -: 1281:// accessors to parse data from file
        -: 1282://
        -: 1283:
        -: 1284:// on platforms that don't allow misaligned reads, if we want to allow
        -: 1285:// truetype fonts that aren't padded to alignment, define ALLOW_UNALIGNED_TRUETYPE
        -: 1286:
        -: 1287:#define ttBYTE(p)     (* (stbtt_uint8 *) (p))
        -: 1288:#define ttCHAR(p)     (* (stbtt_int8 *) (p))
        -: 1289:#define ttFixed(p)    ttLONG(p)
        -: 1290:
function _ZL8ttUSHORTPh called 111578 returned 100% blocks executed 100%
   111578: 1291:static stbtt_uint16 ttUSHORT(stbtt_uint8 *p) { return p[0]*256 + p[1]; }
   111578: 1291-block 2
function _ZL7ttSHORTPh called 39863 returned 100% blocks executed 100%
    39863: 1292:static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }
    39863: 1292-block 2
function _ZL7ttULONGPh called 73138 returned 100% blocks executed 100%
    73138: 1293:static stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }
    73138: 1293-block 2
function _ZL6ttLONGPh called 0 returned 0% blocks executed 0%
    #####: 1294:static stbtt_int32 ttLONG(stbtt_uint8 *p)    { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }
    %%%%%: 1294-block 2
        -: 1295:
        -: 1296:#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
        -: 1297:#define stbtt_tag(p,str)           stbtt_tag4(p,str[0],str[1],str[2],str[3])
        -: 1298:
function _ZL13stbtt__isfontPh called 11 returned 100% blocks executed 33%
       11: 1299:static int stbtt__isfont(stbtt_uint8 *font)
        -: 1300:{
        -: 1301:   // check the version number
      11*: 1302:   if (stbtt_tag4(font, '1',0,0,0))  return 1; // TrueType 1
       11: 1302-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 11
    %%%%%: 1302-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1302-block 4
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 1302-block 5
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 1302-block 6
      11*: 1303:   if (stbtt_tag(font, "typ1"))   return 1; // TrueType with type 1 font -- we don't support this!
       11: 1303-block 7
branch  0 taken 0 (fallthrough)
branch  1 taken 11
    %%%%%: 1303-block 8
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1303-block 9
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 1303-block 10
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 1303-block 11
      11*: 1304:   if (stbtt_tag(font, "OTTO"))   return 1; // OpenType with CFF
       11: 1304-block 12
branch  0 taken 0 (fallthrough)
branch  1 taken 11
    %%%%%: 1304-block 13
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1304-block 14
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 1304-block 15
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 1304-block 16
       11: 1305:   if (stbtt_tag4(font, 0,1,0,0)) return 1; // OpenType 1.0
       11: 1305-block 17
branch  0 taken 11 (fallthrough)
branch  1 taken 0
       11: 1305-block 18
branch  2 taken 11 (fallthrough)
branch  3 taken 0
       11: 1305-block 19
branch  4 taken 11 (fallthrough)
branch  5 taken 0
       11: 1305-block 20
branch  6 taken 11 (fallthrough)
branch  7 taken 0
       11: 1305-block 21
    #####: 1306:   if (stbtt_tag(font, "true"))   return 1; // Apple specification for TrueType fonts
    %%%%%: 1306-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1306-block 23
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1306-block 24
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 1306-block 25
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 1306-block 26
    #####: 1307:   return 0;
    %%%%%: 1307-block 27
        -: 1308:}
        -: 1309:
        -: 1310:// @OPTIMIZE: binary search
function _ZL17stbtt__find_tablePhjPKc called 99 returned 100% blocks executed 100%
       99: 1311:static stbtt_uint32 stbtt__find_table(stbtt_uint8 *data, stbtt_uint32 fontstart, const char *tag)
        -: 1312:{
       99: 1313:   stbtt_int32 num_tables = ttUSHORT(data+fontstart+4);
       99: 1313-block 2
call    0 returned 99
       99: 1314:   stbtt_uint32 tabledir = fontstart + 12;
        -: 1315:   stbtt_int32 i;
     1055: 1316:   for (i=0; i < num_tables; ++i) {
      956: 1316-block 9
     1055: 1316-block 10
branch  0 taken 1042
branch  1 taken 13 (fallthrough)
     1042: 1317:      stbtt_uint32 loc = tabledir + 16*i;
     1042: 1318:      if (stbtt_tag(data+loc+0, tag))
     1042: 1318-block 4
branch  0 taken 138 (fallthrough)
branch  1 taken 904
      138: 1318-block 5
branch  2 taken 86 (fallthrough)
branch  3 taken 52
       86: 1318-block 6
branch  4 taken 86 (fallthrough)
branch  5 taken 0
       86: 1318-block 7
branch  6 taken 86 (fallthrough)
branch  7 taken 0
       86: 1319:         return ttULONG(data+loc+8);
       86: 1319-block 8
call    0 returned 86
        -: 1320:   }
       13: 1321:   return 0;
       13: 1321-block 11
        -: 1322:}
        -: 1323:
function _ZL36stbtt_GetFontOffsetForIndex_internalPhi called 11 returned 100% blocks executed 25%
       11: 1324:static int stbtt_GetFontOffsetForIndex_internal(unsigned char *font_collection, int index)
        -: 1325:{
        -: 1326:   // if it's just a font, there's only one valid index
       11: 1327:   if (stbtt__isfont(font_collection))
       11: 1327-block 2
call    0 returned 11
branch  1 taken 11 (fallthrough)
branch  2 taken 0
      11*: 1328:      return index == 0 ? 0 : -1;
       11: 1328-block 4
branch  0 taken 11 (fallthrough)
branch  1 taken 0
       11: 1328-block 5
    %%%%%: 1328-block 6
       11: 1328-block 7
        -: 1329:
        -: 1330:   // check if it's a TTC
    #####: 1331:   if (stbtt_tag(font_collection, "ttcf")) {
    %%%%%: 1331-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1331-block 9
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1331-block 10
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 1331-block 11
branch  6 never executed (fallthrough)
branch  7 never executed
        -: 1332:      // version 1?
    #####: 1333:      if (ttULONG(font_collection+4) == 0x00010000 || ttULONG(font_collection+4) == 0x00020000) {
    %%%%%: 1333-block 12
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 1333-block 14
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 1333-block 16
    %%%%%: 1333-block 17
    %%%%%: 1333-block 18
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 1334:         stbtt_int32 n = ttLONG(font_collection+8);
    %%%%%: 1334-block 19
call    0 never executed
    #####: 1335:         if (index >= n)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1336:            return -1;
    %%%%%: 1336-block 21
    #####: 1337:         return ttULONG(font_collection+12+index*4);
    %%%%%: 1337-block 22
call    0 never executed
        -: 1338:      }
        -: 1339:   }
    #####: 1340:   return -1;
    %%%%%: 1340-block 24
        -: 1341:}
        -: 1342:
function _ZL31stbtt_GetNumberOfFonts_internalPh called 0 returned 0% blocks executed 0%
    #####: 1343:static int stbtt_GetNumberOfFonts_internal(unsigned char *font_collection)
        -: 1344:{
        -: 1345:   // if it's just a font, there's only one valid font
    #####: 1346:   if (stbtt__isfont(font_collection))
    %%%%%: 1346-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 1347:      return 1;
    %%%%%: 1347-block 4
        -: 1348:
        -: 1349:   // check if it's a TTC
    #####: 1350:   if (stbtt_tag(font_collection, "ttcf")) {
    %%%%%: 1350-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1350-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1350-block 7
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 1350-block 8
branch  6 never executed (fallthrough)
branch  7 never executed
        -: 1351:      // version 1?
    #####: 1352:      if (ttULONG(font_collection+4) == 0x00010000 || ttULONG(font_collection+4) == 0x00020000) {
    %%%%%: 1352-block 9
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 1352-block 11
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 1352-block 13
    %%%%%: 1352-block 14
    %%%%%: 1352-block 15
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 1353:         return ttLONG(font_collection+8);
    %%%%%: 1353-block 16
call    0 never executed
        -: 1354:      }
        -: 1355:   }
    #####: 1356:   return 0;
    %%%%%: 1356-block 17
        -: 1357:}
        -: 1358:
function _ZL16stbtt__get_subrs10stbtt__bufS_ called 0 returned 0% blocks executed 0%
    #####: 1359:static stbtt__buf stbtt__get_subrs(stbtt__buf cff, stbtt__buf fontdict)
        -: 1360:{
    #####: 1361:   stbtt_uint32 subrsoff = 0, private_loc[2] = { 0, 0 };
        -: 1362:   stbtt__buf pdict;
    #####: 1363:   stbtt__dict_get_ints(&fontdict, 18, 2, private_loc);
    %%%%%: 1363-block 2
call    0 never executed
    #####: 1364:   if (!private_loc[1] || !private_loc[0]) return stbtt__new_buf(NULL, 0);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1364-block 4
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1364-block 5
call    4 never executed
    #####: 1365:   pdict = stbtt__buf_range(&cff, private_loc[1], private_loc[0]);
    %%%%%: 1365-block 6
call    0 never executed
    #####: 1366:   stbtt__dict_get_ints(&pdict, 19, 1, &subrsoff);
call    0 never executed
    #####: 1367:   if (!subrsoff) return stbtt__new_buf(NULL, 0);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1367-block 9
call    2 never executed
    #####: 1368:   stbtt__buf_seek(&cff, private_loc[1]+subrsoff);
    %%%%%: 1368-block 10
call    0 never executed
    #####: 1369:   return stbtt__cff_get_index(&cff);
call    0 never executed
        -: 1370:}
        -: 1371:
        -: 1372:// since most people won't use this, find this table the first time it's needed
function _ZL14stbtt__get_svgP14stbtt_fontinfo called 0 returned 0% blocks executed 0%
    #####: 1373:static int stbtt__get_svg(stbtt_fontinfo *info)
        -: 1374:{
        -: 1375:   stbtt_uint32 t;
    #####: 1376:   if (info->svg < 0) {
    %%%%%: 1376-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1377:      t = stbtt__find_table(info->data, info->fontstart, "SVG ");
    %%%%%: 1377-block 3
call    0 never executed
    #####: 1378:      if (t) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1379:         stbtt_uint32 offset = ttULONG(info->data + t + 2);
    %%%%%: 1379-block 5
call    0 never executed
    #####: 1380:         info->svg = t + offset;
        -: 1381:      } else {
    #####: 1382:         info->svg = 0;
    %%%%%: 1382-block 7
        -: 1383:      }
        -: 1384:   }
    #####: 1385:   return info->svg;
    %%%%%: 1385-block 8
        -: 1386:}
        -: 1387:
function _ZL23stbtt_InitFont_internalP14stbtt_fontinfoPhi called 11 returned 100% blocks executed 49%
       11: 1388:static int stbtt_InitFont_internal(stbtt_fontinfo *info, unsigned char *data, int fontstart)
        -: 1389:{
        -: 1390:   stbtt_uint32 cmap, t;
        -: 1391:   stbtt_int32 i,numTables;
        -: 1392:
       11: 1393:   info->data = data;
       11: 1394:   info->fontstart = fontstart;
       11: 1395:   info->cff = stbtt__new_buf(NULL, 0);
       11: 1395-block 2
call    0 returned 11
        -: 1396:
       11: 1397:   cmap = stbtt__find_table(data, fontstart, "cmap");       // required
call    0 returned 11
       11: 1398:   info->loca = stbtt__find_table(data, fontstart, "loca"); // required
call    0 returned 11
       11: 1399:   info->head = stbtt__find_table(data, fontstart, "head"); // required
call    0 returned 11
       11: 1400:   info->glyf = stbtt__find_table(data, fontstart, "glyf"); // required
call    0 returned 11
       11: 1401:   info->hhea = stbtt__find_table(data, fontstart, "hhea"); // required
call    0 returned 11
       11: 1402:   info->hmtx = stbtt__find_table(data, fontstart, "hmtx"); // required
call    0 returned 11
       11: 1403:   info->kern = stbtt__find_table(data, fontstart, "kern"); // not required
call    0 returned 11
       11: 1404:   info->gpos = stbtt__find_table(data, fontstart, "GPOS"); // not required
call    0 returned 11
        -: 1405:
       11: 1406:   if (!cmap || !info->head || !info->hhea || !info->hmtx)
branch  0 taken 11 (fallthrough)
branch  1 taken 0
       11: 1406-block 12
branch  2 taken 11 (fallthrough)
branch  3 taken 0
       11: 1406-block 13
branch  4 taken 11 (fallthrough)
branch  5 taken 0
       11: 1406-block 14
branch  6 taken 0 (fallthrough)
branch  7 taken 11
    #####: 1407:      return 0;
    %%%%%: 1407-block 15
       11: 1408:   if (info->glyf) {
       11: 1408-block 16
branch  0 taken 11 (fallthrough)
branch  1 taken 0
        -: 1409:      // required for truetype
      11*: 1410:      if (!info->loca) return 0;
       11: 1410-block 17
branch  0 taken 0 (fallthrough)
branch  1 taken 11
    %%%%%: 1410-block 18
        -: 1411:   } else {
        -: 1412:      // initialization for CFF / Type2 fonts (OTF)
        -: 1413:      stbtt__buf b, topdict, topdictidx;
    #####: 1414:      stbtt_uint32 cstype = 2, charstrings = 0, fdarrayoff = 0, fdselectoff = 0;
        -: 1415:      stbtt_uint32 cff;
        -: 1416:
    #####: 1417:      cff = stbtt__find_table(data, fontstart, "CFF ");
    %%%%%: 1417-block 19
call    0 never executed
    #####: 1418:      if (!cff) return 0;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1418-block 21
    %%%%%: 1418-block 51
        -: 1419:
    #####: 1420:      info->fontdicts = stbtt__new_buf(NULL, 0);
    %%%%%: 1420-block 22
call    0 never executed
    #####: 1421:      info->fdselect = stbtt__new_buf(NULL, 0);
call    0 never executed
        -: 1422:
        -: 1423:      // @TODO this should use size from table (not 512MB)
    #####: 1424:      info->cff = stbtt__new_buf(data+cff, 512*1024*1024);
call    0 never executed
    #####: 1425:      b = info->cff;
        -: 1426:
        -: 1427:      // read the header
    #####: 1428:      stbtt__buf_skip(&b, 2);
call    0 never executed
    #####: 1429:      stbtt__buf_seek(&b, stbtt__buf_get8(&b)); // hdrsize
call    0 never executed
call    1 never executed
        -: 1430:
        -: 1431:      // @TODO the name INDEX could list multiple fonts,
        -: 1432:      // but we just use the first one.
    #####: 1433:      stbtt__cff_get_index(&b);  // name INDEX
call    0 never executed
    #####: 1434:      topdictidx = stbtt__cff_get_index(&b);
call    0 never executed
    #####: 1435:      topdict = stbtt__cff_index_get(topdictidx, 0);
call    0 never executed
    #####: 1436:      stbtt__cff_get_index(&b);  // string INDEX
call    0 never executed
    #####: 1437:      info->gsubrs = stbtt__cff_get_index(&b);
call    0 never executed
        -: 1438:
    #####: 1439:      stbtt__dict_get_ints(&topdict, 17, 1, &charstrings);
call    0 never executed
    #####: 1440:      stbtt__dict_get_ints(&topdict, 0x100 | 6, 1, &cstype);
call    0 never executed
    #####: 1441:      stbtt__dict_get_ints(&topdict, 0x100 | 36, 1, &fdarrayoff);
call    0 never executed
    #####: 1442:      stbtt__dict_get_ints(&topdict, 0x100 | 37, 1, &fdselectoff);
call    0 never executed
    #####: 1443:      info->subrs = stbtt__get_subrs(b, topdict);
call    0 never executed
        -: 1444:
        -: 1445:      // we only support Type 2 charstrings
    #####: 1446:      if (cstype != 2) return 0;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1446-block 39
    #####: 1447:      if (charstrings == 0) return 0;
    %%%%%: 1447-block 40
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1447-block 41
        -: 1448:
    #####: 1449:      if (fdarrayoff) {
    %%%%%: 1449-block 42
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1450:         // looks like a CID font
    #####: 1451:         if (!fdselectoff) return 0;
    %%%%%: 1451-block 43
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1451-block 44
    #####: 1452:         stbtt__buf_seek(&b, fdarrayoff);
    %%%%%: 1452-block 45
call    0 never executed
    #####: 1453:         info->fontdicts = stbtt__cff_get_index(&b);
call    0 never executed
    #####: 1454:         info->fdselect = stbtt__buf_range(&b, fdselectoff, b.size-fdselectoff);
call    0 never executed
        -: 1455:      }
        -: 1456:
    #####: 1457:      stbtt__buf_seek(&b, charstrings);
    %%%%%: 1457-block 48
call    0 never executed
    #####: 1458:      info->charstrings = stbtt__cff_get_index(&b);
call    0 never executed
        -: 1459:   }
        -: 1460:
       11: 1461:   t = stbtt__find_table(data, fontstart, "maxp");
       11: 1461-block 52
call    0 returned 11
       11: 1462:   if (t)
branch  0 taken 11 (fallthrough)
branch  1 taken 0
       11: 1463:      info->numGlyphs = ttUSHORT(data+t+4);
       11: 1463-block 54
call    0 returned 11
        -: 1464:   else
    #####: 1465:      info->numGlyphs = 0xffff;
    %%%%%: 1465-block 56
        -: 1466:
       11: 1467:   info->svg = -1;
        -: 1468:
        -: 1469:   // find a cmap encoding table we understand *now* to avoid searching
        -: 1470:   // later. (todo: could make this installable)
        -: 1471:   // the same regardless of glyph.
       11: 1472:   numTables = ttUSHORT(data + cmap + 2);
       11: 1472-block 57
call    0 returned 11
       11: 1473:   info->index_map = 0;
       45: 1474:   for (i=0; i < numTables; ++i) {
       34: 1474-block 68
       45: 1474-block 69
branch  0 taken 34
branch  1 taken 11 (fallthrough)
       34: 1475:      stbtt_uint32 encoding_record = cmap + 4 + 8 * i;
        -: 1476:      // find an encoding we understand:
       34: 1477:      switch(ttUSHORT(data+encoding_record)) {
       34: 1477-block 59
call    0 returned 34
branch  1 taken 14
branch  2 taken 14
branch  3 taken 6
       14: 1478:         case STBTT_PLATFORM_ID_MICROSOFT:
       14: 1479:            switch (ttUSHORT(data+encoding_record+2)) {
       14: 1479-block 61
call    0 returned 14
branch  1 taken 14
branch  2 taken 0
       14: 1480:               case STBTT_MS_EID_UNICODE_BMP:
        -: 1481:               case STBTT_MS_EID_UNICODE_FULL:
        -: 1482:                  // MS/Unicode
       14: 1483:                  info->index_map = cmap + ttULONG(data+encoding_record+4);
       14: 1483-block 63
call    0 returned 14
       14: 1484:                  break;
        -: 1485:            }
       14: 1486:            break;
       14: 1486-block 65
       14: 1487:        case STBTT_PLATFORM_ID_UNICODE:
        -: 1488:            // Mac/iOS has these
        -: 1489:            // all the encodingIDs are unicode, so we don't bother to check it
       14: 1490:            info->index_map = cmap + ttULONG(data+encoding_record+4);
       14: 1490-block 66
call    0 returned 14
       14: 1491:            break;
        -: 1492:      }
        -: 1493:   }
       11: 1494:   if (info->index_map == 0)
       11: 1494-block 70
branch  0 taken 0 (fallthrough)
branch  1 taken 11
    #####: 1495:      return 0;
    %%%%%: 1495-block 71
        -: 1496:
       11: 1497:   info->indexToLocFormat = ttUSHORT(data+info->head + 50);
       11: 1497-block 72
call    0 returned 11
       11: 1498:   return 1;
        -: 1499:}
        -: 1500:
function stbtt_FindGlyphIndex called 8698 returned 100% blocks executed 74%
     8698: 1501:STBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint)
        -: 1502:{
     8698: 1503:   stbtt_uint8 *data = info->data;
     8698: 1504:   stbtt_uint32 index_map = info->index_map;
        -: 1505:
     8698: 1506:   stbtt_uint16 format = ttUSHORT(data + index_map + 0);
     8698: 1506-block 2
call    0 returned 8698
     8698: 1507:   if (format == 0) { // apple byte encoding
branch  0 taken 0 (fallthrough)
branch  1 taken 8698
    #####: 1508:      stbtt_int32 bytes = ttUSHORT(data + index_map + 2);
    %%%%%: 1508-block 4
call    0 never executed
    #####: 1509:      if (unicode_codepoint < bytes-6)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1510:         return ttBYTE(data + index_map + 6 + unicode_codepoint);
    %%%%%: 1510-block 6
    #####: 1511:      return 0;
    %%%%%: 1511-block 7
     8698: 1512:   } else if (format == 6) {
     8698: 1512-block 8
branch  0 taken 0 (fallthrough)
branch  1 taken 8698
    #####: 1513:      stbtt_uint32 first = ttUSHORT(data + index_map + 6);
    %%%%%: 1513-block 9
call    0 never executed
    #####: 1514:      stbtt_uint32 count = ttUSHORT(data + index_map + 8);
call    0 never executed
    #####: 1515:      if ((stbtt_uint32) unicode_codepoint >= first && (stbtt_uint32) unicode_codepoint < first+count)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1515-block 12
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 1516:         return ttUSHORT(data + index_map + 10 + (unicode_codepoint - first)*2);
    %%%%%: 1516-block 13
call    0 never executed
    #####: 1517:      return 0;
    %%%%%: 1517-block 15
     8698: 1518:   } else if (format == 2) {
     8698: 1518-block 16
branch  0 taken 0 (fallthrough)
branch  1 taken 8698
    #####: 1519:      STBTT_assert(0); // @TODO: high-byte mapping for japanese/chinese/korean
    %%%%%: 1519-block 17
call    0 never executed
        -: 1520:      return 0;
     8698: 1521:   } else if (format == 4) { // standard mapping for windows fonts: binary search collection of ranges
     8698: 1521-block 18
branch  0 taken 4864 (fallthrough)
branch  1 taken 3834
     4864: 1522:      stbtt_uint16 segcount = ttUSHORT(data+index_map+6) >> 1;
     4864: 1522-block 19
call    0 returned 4864
     4864: 1523:      stbtt_uint16 searchRange = ttUSHORT(data+index_map+8) >> 1;
call    0 returned 4864
     4864: 1524:      stbtt_uint16 entrySelector = ttUSHORT(data+index_map+10);
call    0 returned 4864
     4864: 1525:      stbtt_uint16 rangeShift = ttUSHORT(data+index_map+12) >> 1;
call    0 returned 4864
        -: 1526:
        -: 1527:      // do a binary search of the segments
     4864: 1528:      stbtt_uint32 endCount = index_map + 14;
     4864: 1529:      stbtt_uint32 search = endCount;
        -: 1530:
     4864: 1531:      if (unicode_codepoint > 0xffff)
branch  0 taken 0 (fallthrough)
branch  1 taken 4864
    #####: 1532:         return 0;
    %%%%%: 1532-block 24
        -: 1533:
        -: 1534:      // they lie from endCount .. endCount + segCount
        -: 1535:      // but searchRange is the nearest power of two, so...
     4864: 1536:      if (unicode_codepoint >= ttUSHORT(data + search + rangeShift*2))
     4864: 1536-block 25
call    0 returned 4864
branch  1 taken 1651 (fallthrough)
branch  2 taken 3213
     1651: 1537:         search += rangeShift*2;
     1651: 1537-block 27
        -: 1538:
        -: 1539:      // now decrement to bias correctly to find smallest
     4864: 1540:      search -= 2;
    31974: 1541:      while (entrySelector) {
     4864: 1541-block 28
    31974: 1541-block 33
branch  0 taken 27110
branch  1 taken 4864 (fallthrough)
        -: 1542:         stbtt_uint16 end;
    27110: 1543:         searchRange >>= 1;
    27110: 1544:         end = ttUSHORT(data + search + searchRange*2);
    27110: 1544-block 29
call    0 returned 27110
    27110: 1545:         if (unicode_codepoint > end)
branch  0 taken 3921 (fallthrough)
branch  1 taken 23189
     3921: 1546:            search += searchRange*2;
     3921: 1546-block 31
    27110: 1547:         --entrySelector;
    27110: 1547-block 32
        -: 1548:      }
     4864: 1549:      search += 2;
        -: 1550:
        -: 1551:      {
        -: 1552:         stbtt_uint16 offset, start, last;
     4864: 1553:         stbtt_uint16 item = (stbtt_uint16) ((search - endCount) >> 1);
        -: 1554:
     4864: 1555:         start = ttUSHORT(data + index_map + 14 + segcount*2 + 2 + 2*item);
     4864: 1555-block 34
call    0 returned 4864
     4864: 1556:         last = ttUSHORT(data + endCount + 2*item);
call    0 returned 4864
     4864: 1557:         if (unicode_codepoint < start || unicode_codepoint > last)
branch  0 taken 4608 (fallthrough)
branch  1 taken 256
     4608: 1557-block 37
branch  2 taken 0 (fallthrough)
branch  3 taken 4608
      256: 1558:            return 0;
      256: 1558-block 38
        -: 1559:
     4608: 1560:         offset = ttUSHORT(data + index_map + 14 + segcount*6 + 2 + 2*item);
     4608: 1560-block 39
call    0 returned 4608
     4608: 1561:         if (offset == 0)
branch  0 taken 3003 (fallthrough)
branch  1 taken 1605
     3003: 1562:            return (stbtt_uint16) (unicode_codepoint + ttSHORT(data + index_map + 14 + segcount*4 + 2 + 2*item));
     3003: 1562-block 41
call    0 returned 3003
        -: 1563:
     1605: 1564:         return ttUSHORT(data + offset + (unicode_codepoint-start)*2 + index_map + 14 + segcount*6 + 2 + 2*item);
     1605: 1564-block 43
call    0 returned 1605
        -: 1565:      }
    3834*: 1566:   } else if (format == 12 || format == 13) {
     3834: 1566-block 45
branch  0 taken 0 (fallthrough)
branch  1 taken 3834
    %%%%%: 1566-block 46
branch  2 never executed (fallthrough)
branch  3 never executed
     3834: 1567:      stbtt_uint32 ngroups = ttULONG(data+index_map+12);
     3834: 1567-block 47
call    0 returned 3834
        -: 1568:      stbtt_int32 low,high;
     3834: 1569:      low = 0; high = (stbtt_int32)ngroups;
        -: 1570:      // Binary search the right group.
    34631: 1571:      while (low < high) {
    34631: 1571-block 59
branch  0 taken 33329
branch  1 taken 1302 (fallthrough)
    33329: 1572:         stbtt_int32 mid = low + ((high-low) >> 1); // rounds down, so low <= mid < high
    33329: 1573:         stbtt_uint32 start_char = ttULONG(data+index_map+16+mid*12);
    33329: 1573-block 49
call    0 returned 33329
    33329: 1574:         stbtt_uint32 end_char = ttULONG(data+index_map+16+mid*12+4);
call    0 returned 33329
    33329: 1575:         if ((stbtt_uint32) unicode_codepoint < start_char)
branch  0 taken 13321 (fallthrough)
branch  1 taken 20008
    13321: 1576:            high = mid;
    13321: 1576-block 52
    20008: 1577:         else if ((stbtt_uint32) unicode_codepoint > end_char)
    20008: 1577-block 53
branch  0 taken 17476 (fallthrough)
branch  1 taken 2532
    17476: 1578:            low = mid+1;
    17476: 1578-block 54
        -: 1579:         else {
     2532: 1580:            stbtt_uint32 start_glyph = ttULONG(data+index_map+16+mid*12+8);
     2532: 1580-block 55
call    0 returned 2532
     2532: 1581:            if (format == 12)
branch  0 taken 2532 (fallthrough)
branch  1 taken 0
     2532: 1582:               return start_glyph + unicode_codepoint-start_char;
     2532: 1582-block 57
        -: 1583:            else // format == 13
    #####: 1584:               return start_glyph;
    %%%%%: 1584-block 58
        -: 1585:         }
        -: 1586:      }
     1302: 1587:      return 0; // not found
     1302: 1587-block 60
        -: 1588:   }
        -: 1589:   // @TODO
    #####: 1590:   STBTT_assert(0);
    %%%%%: 1590-block 61
call    0 never executed
        -: 1591:   return 0;
        -: 1592:}
        -: 1593:
function stbtt_GetCodepointShape called 0 returned 0% blocks executed 0%
    #####: 1594:STBTT_DEF int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices)
        -: 1595:{
    #####: 1596:   return stbtt_GetGlyphShape(info, stbtt_FindGlyphIndex(info, unicode_codepoint), vertices);
    %%%%%: 1596-block 2
call    0 never executed
call    1 never executed
        -: 1597:}
        -: 1598:
function _ZL15stbtt_setvertexP12stbtt_vertexhiiii called 76669 returned 100% blocks executed 100%
    76669: 1599:static void stbtt_setvertex(stbtt_vertex *v, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy)
        -: 1600:{
    76669: 1601:   v->type = type;
    76669: 1602:   v->x = (stbtt_int16) x;
    76669: 1603:   v->y = (stbtt_int16) y;
    76669: 1604:   v->cx = (stbtt_int16) cx;
    76669: 1605:   v->cy = (stbtt_int16) cy;
    76669: 1606:}
        -: 1607:
function _ZL20stbtt__GetGlyfOffsetPK14stbtt_fontinfoi called 9871 returned 100% blocks executed 67%
     9871: 1608:static int stbtt__GetGlyfOffset(const stbtt_fontinfo *info, int glyph_index)
        -: 1609:{
        -: 1610:   int g1,g2;
        -: 1611:
    9871*: 1612:   STBTT_assert(!info->cff.size);
     9871: 1612-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 9871
    %%%%%: 1612-block 3
call    2 never executed
        -: 1613:
    9871*: 1614:   if (glyph_index >= info->numGlyphs) return -1; // glyph index out of range
     9871: 1614-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 9871
    %%%%%: 1614-block 5
    9871*: 1615:   if (info->indexToLocFormat >= 2)    return -1; // unknown index->glyph map format
     9871: 1615-block 6
branch  0 taken 0 (fallthrough)
branch  1 taken 9871
    %%%%%: 1615-block 7
        -: 1616:
     9871: 1617:   if (info->indexToLocFormat == 0) {
     9871: 1617-block 8
branch  0 taken 9871 (fallthrough)
branch  1 taken 0
     9871: 1618:      g1 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2) * 2;
     9871: 1618-block 9
call    0 returned 9871
     9871: 1619:      g2 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2 + 2) * 2;
call    0 returned 9871
        -: 1620:   } else {
    #####: 1621:      g1 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4);
    %%%%%: 1621-block 12
call    0 never executed
    #####: 1622:      g2 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4 + 4);
call    0 never executed
        -: 1623:   }
        -: 1624:
     9871: 1625:   return g1==g2 ? -1 : g1; // if length is 0, return -1
     9871: 1625-block 15
branch  0 taken 9783 (fallthrough)
branch  1 taken 88
     9783: 1625-block 16
       88: 1625-block 17
     9871: 1625-block 18
        -: 1626:}
        -: 1627:
        -: 1628:static int stbtt__GetGlyphInfoT2(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1);
        -: 1629:
function stbtt_GetGlyphBox called 7140 returned 100% blocks executed 95%
     7140: 1630:STBTT_DEF int stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)
        -: 1631:{
     7140: 1632:   if (info->cff.size) {
     7140: 1632-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 7140
    #####: 1633:      stbtt__GetGlyphInfoT2(info, glyph_index, x0, y0, x1, y1);
    %%%%%: 1633-block 3
call    0 never executed
        -: 1634:   } else {
     7140: 1635:      int g = stbtt__GetGlyfOffset(info, glyph_index);
     7140: 1635-block 4
call    0 returned 7140
     7140: 1636:      if (g < 0) return 0;
branch  0 taken 66 (fallthrough)
branch  1 taken 7074
       66: 1636-block 6
        -: 1637:
     7074: 1638:      if (x0) *x0 = ttSHORT(info->data + g + 2);
     7074: 1638-block 7
branch  0 taken 7074 (fallthrough)
branch  1 taken 0
     7074: 1638-block 8
call    2 returned 7074
     7074: 1639:      if (y0) *y0 = ttSHORT(info->data + g + 4);
     7074: 1639-block 10
branch  0 taken 7074 (fallthrough)
branch  1 taken 0
     7074: 1639-block 11
call    2 returned 7074
     7074: 1640:      if (x1) *x1 = ttSHORT(info->data + g + 6);
     7074: 1640-block 13
branch  0 taken 7074 (fallthrough)
branch  1 taken 0
     7074: 1640-block 14
call    2 returned 7074
     7074: 1641:      if (y1) *y1 = ttSHORT(info->data + g + 8);
     7074: 1641-block 16
branch  0 taken 7074 (fallthrough)
branch  1 taken 0
     7074: 1641-block 17
call    2 returned 7074
        -: 1642:   }
     7074: 1643:   return 1;
     7074: 1643-block 19
        -: 1644:}
        -: 1645:
function stbtt_GetCodepointBox called 0 returned 0% blocks executed 0%
    #####: 1646:STBTT_DEF int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1)
        -: 1647:{
    #####: 1648:   return stbtt_GetGlyphBox(info, stbtt_FindGlyphIndex(info,codepoint), x0,y0,x1,y1);
    %%%%%: 1648-block 2
call    0 never executed
call    1 never executed
        -: 1649:}
        -: 1650:
function stbtt_IsGlyphEmpty called 0 returned 0% blocks executed 0%
    #####: 1651:STBTT_DEF int stbtt_IsGlyphEmpty(const stbtt_fontinfo *info, int glyph_index)
        -: 1652:{
        -: 1653:   stbtt_int16 numberOfContours;
        -: 1654:   int g;
    #####: 1655:   if (info->cff.size)
    %%%%%: 1655-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1656:      return stbtt__GetGlyphInfoT2(info, glyph_index, NULL, NULL, NULL, NULL) == 0;
    %%%%%: 1656-block 3
call    0 never executed
    #####: 1657:   g = stbtt__GetGlyfOffset(info, glyph_index);
    %%%%%: 1657-block 5
call    0 never executed
    #####: 1658:   if (g < 0) return 1;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1658-block 7
    #####: 1659:   numberOfContours = ttSHORT(info->data + g);
    %%%%%: 1659-block 8
call    0 never executed
    #####: 1660:   return numberOfContours == 0;
        -: 1661:}
        -: 1662:
function _ZL18stbtt__close_shapeP12stbtt_vertexiiiiiiiii called 8157 returned 100% blocks executed 100%
     8157: 1663:static int stbtt__close_shape(stbtt_vertex *vertices, int num_vertices, int was_off, int start_off,
        -: 1664:    stbtt_int32 sx, stbtt_int32 sy, stbtt_int32 scx, stbtt_int32 scy, stbtt_int32 cx, stbtt_int32 cy)
        -: 1665:{
     8157: 1666:   if (start_off) {
     8157: 1666-block 2
branch  0 taken 162 (fallthrough)
branch  1 taken 7995
      162: 1667:      if (was_off)
      162: 1667-block 3
branch  0 taken 161 (fallthrough)
branch  1 taken 1
      161: 1668:         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+scx)>>1, (cy+scy)>>1, cx,cy);
      161: 1668-block 4
call    0 returned 161
      162: 1669:      stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, sx,sy,scx,scy);
      162: 1669-block 5
call    0 returned 162
        -: 1670:   } else {
     7995: 1671:      if (was_off)
     7995: 1671-block 6
branch  0 taken 1917 (fallthrough)
branch  1 taken 6078
     1917: 1672:         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve,sx,sy,cx,cy);
     1917: 1672-block 7
call    0 returned 1917
        -: 1673:      else
     6078: 1674:         stbtt_setvertex(&vertices[num_vertices++], STBTT_vline,sx,sy,0,0);
     6078: 1674-block 8
call    0 returned 6078
        -: 1675:   }
     8157: 1676:   return num_vertices;
     8157: 1676-block 9
        -: 1677:}
        -: 1678:
function _ZL22stbtt__GetGlyphShapeTTPK14stbtt_fontinfoiPP12stbtt_vertex called 2731 returned 100% blocks executed 83%
     2731: 1679:static int stbtt__GetGlyphShapeTT(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)
        -: 1680:{
        -: 1681:   stbtt_int16 numberOfContours;
        -: 1682:   stbtt_uint8 *endPtsOfContours;
     2731: 1683:   stbtt_uint8 *data = info->data;
     2731: 1684:   stbtt_vertex *vertices=0;
     2731: 1685:   int num_vertices=0;
     2731: 1686:   int g = stbtt__GetGlyfOffset(info, glyph_index);
     2731: 1686-block 2
call    0 returned 2731
        -: 1687:
     2731: 1688:   *pvertices = NULL;
        -: 1689:
     2731: 1690:   if (g < 0) return 0;
branch  0 taken 22 (fallthrough)
branch  1 taken 2709
       22: 1690-block 4
        -: 1691:
     2709: 1692:   numberOfContours = ttSHORT(data + g);
     2709: 1692-block 5
call    0 returned 2709
        -: 1693:
     2709: 1694:   if (numberOfContours > 0) {
branch  0 taken 2525 (fallthrough)
branch  1 taken 184
     2525: 1695:      stbtt_uint8 flags=0,flagcount;
     2525: 1696:      stbtt_int32 ins, i,j=0,m,n, next_move, was_off=0, off, start_off=0;
        -: 1697:      stbtt_int32 x,y,cx,cy,sx,sy, scx,scy;
        -: 1698:      stbtt_uint8 *points;
     2525: 1699:      endPtsOfContours = (data + g + 10);
     2525: 1700:      ins = ttUSHORT(data + g + 10 + numberOfContours * 2);
     2525: 1700-block 7
call    0 returned 2525
     2525: 1701:      points = data + g + 10 + numberOfContours * 2 + 2 + ins;
        -: 1702:
     2525: 1703:      n = 1+ttUSHORT(endPtsOfContours + numberOfContours*2-2);
call    0 returned 2525
        -: 1704:
     2525: 1705:      m = n + 2*numberOfContours;  // a loose bound on how many vertices we might need
     2525: 1706:      vertices = (stbtt_vertex *) STBTT_malloc(m * sizeof(vertices[0]), info->userdata);
call    0 returned 2525
     2525: 1707:      if (vertices == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 2525
    #####: 1708:         return 0;
    %%%%%: 1708-block 11
        -: 1709:
     2525: 1710:      next_move = 0;
     2525: 1711:      flagcount=0;
        -: 1712:
        -: 1713:      // in first pass, we load uninterpreted data into the allocated array
        -: 1714:      // above, shifted to the end of the array so we won't overwrite it when
        -: 1715:      // we create our final data starting from the front
        -: 1716:
     2525: 1717:      off = m - n; // starting offset for uninterpreted data, regardless of how m ends up being calculated
        -: 1718:
        -: 1719:      // first load flags
        -: 1720:
    84151: 1721:      for (i=0; i < n; ++i) {
     2525: 1721-block 12
    84151: 1721-block 18
branch  0 taken 81626
branch  1 taken 2525 (fallthrough)
    81626: 1722:         if (flagcount == 0) {
    81626: 1722-block 13
branch  0 taken 76886 (fallthrough)
branch  1 taken 4740
    76886: 1723:            flags = *points++;
    76886: 1724:            if (flags & 8)
    76886: 1724-block 14
branch  0 taken 3613 (fallthrough)
branch  1 taken 73273
     3613: 1725:               flagcount = *points++;
     3613: 1725-block 15
        -: 1726:         } else
     4740: 1727:            --flagcount;
     4740: 1727-block 16
    81626: 1728:         vertices[off+i].type = flags;
    81626: 1728-block 17
        -: 1729:      }
        -: 1730:
        -: 1731:      // now load x coordinates
     2525: 1732:      x=0;
    84151: 1733:      for (i=0; i < n; ++i) {
     2525: 1733-block 19
    84151: 1733-block 28
branch  0 taken 81626
branch  1 taken 2525 (fallthrough)
    81626: 1734:         flags = vertices[off+i].type;
    81626: 1735:         if (flags & 2) {
    81626: 1735-block 20
branch  0 taken 54191 (fallthrough)
branch  1 taken 27435
    54191: 1736:            stbtt_int16 dx = *points++;
    54191: 1737:            x += (flags & 16) ? dx : -dx; // ???
    54191: 1737-block 21
branch  0 taken 29672 (fallthrough)
branch  1 taken 24519
    29672: 1737-block 22
    24519: 1737-block 23
    54191: 1737-block 24
        -: 1738:         } else {
    27435: 1739:            if (!(flags & 16)) {
    27435: 1739-block 25
branch  0 taken 4023 (fallthrough)
branch  1 taken 23412
     4023: 1740:               x = x + (stbtt_int16) (points[0]*256 + points[1]);
     4023: 1741:               points += 2;
     4023: 1741-block 26
        -: 1742:            }
        -: 1743:         }
    81626: 1744:         vertices[off+i].x = (stbtt_int16) x;
    81626: 1744-block 27
        -: 1745:      }
        -: 1746:
        -: 1747:      // now load y coordinates
     2525: 1748:      y=0;
    84151: 1749:      for (i=0; i < n; ++i) {
     2525: 1749-block 29
    84151: 1749-block 38
branch  0 taken 81626
branch  1 taken 2525 (fallthrough)
    81626: 1750:         flags = vertices[off+i].type;
    81626: 1751:         if (flags & 4) {
    81626: 1751-block 30
branch  0 taken 53966 (fallthrough)
branch  1 taken 27660
    53966: 1752:            stbtt_int16 dy = *points++;
    53966: 1753:            y += (flags & 32) ? dy : -dy; // ???
    53966: 1753-block 31
branch  0 taken 26461 (fallthrough)
branch  1 taken 27505
    26461: 1753-block 32
    27505: 1753-block 33
    53966: 1753-block 34
        -: 1754:         } else {
    27660: 1755:            if (!(flags & 32)) {
    27660: 1755-block 35
branch  0 taken 4777 (fallthrough)
branch  1 taken 22883
     4777: 1756:               y = y + (stbtt_int16) (points[0]*256 + points[1]);
     4777: 1757:               points += 2;
     4777: 1757-block 36
        -: 1758:            }
        -: 1759:         }
    81626: 1760:         vertices[off+i].y = (stbtt_int16) y;
    81626: 1760-block 37
        -: 1761:      }
        -: 1762:
        -: 1763:      // now convert them to our format
     2525: 1764:      num_vertices=0;
     2525: 1765:      sx = sy = cx = cy = scx = scy = 0;
    84151: 1766:      for (i=0; i < n; ++i) {
     2525: 1766-block 39
    81626: 1766-block 59
    84151: 1766-block 60
branch  0 taken 81626
branch  1 taken 2525 (fallthrough)
    81626: 1767:         flags = vertices[off+i].type;
    81626: 1768:         x     = (stbtt_int16) vertices[off+i].x;
    81626: 1769:         y     = (stbtt_int16) vertices[off+i].y;
        -: 1770:
    81626: 1771:         if (next_move == i) {
    81626: 1771-block 40
branch  0 taken 8157 (fallthrough)
branch  1 taken 73469
     8157: 1772:            if (i != 0)
     8157: 1772-block 41
branch  0 taken 5632 (fallthrough)
branch  1 taken 2525
     5632: 1773:               num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);
     5632: 1773-block 42
call    0 returned 5632
        -: 1774:
        -: 1775:            // now start the new one
     8157: 1776:            start_off = !(flags & 1);
     8157: 1777:            if (start_off) {
     8157: 1777-block 43
branch  0 taken 162 (fallthrough)
branch  1 taken 7995
        -: 1778:               // if we start off with an off-curve point, then when we need to find a point on the curve
        -: 1779:               // where we can start, and we need to save some state for when we wraparound.
      162: 1780:               scx = x;
      162: 1781:               scy = y;
      162: 1782:               if (!(vertices[off+i+1].type & 1)) {
      162: 1782-block 44
branch  0 taken 162 (fallthrough)
branch  1 taken 0
        -: 1783:                  // next point is also a curve point, so interpolate an on-point curve
      162: 1784:                  sx = (x + (stbtt_int32) vertices[off+i+1].x) >> 1;
      162: 1785:                  sy = (y + (stbtt_int32) vertices[off+i+1].y) >> 1;
      162: 1785-block 45
        -: 1786:               } else {
        -: 1787:                  // otherwise just use the next point as our start point
    #####: 1788:                  sx = (stbtt_int32) vertices[off+i+1].x;
    #####: 1789:                  sy = (stbtt_int32) vertices[off+i+1].y;
    #####: 1790:                  ++i; // we're using point i+1 as the starting point, so skip it
    %%%%%: 1790-block 46
        -: 1791:               }
        -: 1792:            } else {
     7995: 1793:               sx = x;
     7995: 1794:               sy = y;
     7995: 1794-block 47
        -: 1795:            }
     8157: 1796:            stbtt_setvertex(&vertices[num_vertices++], STBTT_vmove,sx,sy,0,0);
     8157: 1796-block 48
call    0 returned 8157
     8157: 1797:            was_off = 0;
     8157: 1798:            next_move = 1 + ttUSHORT(endPtsOfContours+j*2);
call    0 returned 8157
     8157: 1799:            ++j;
        -: 1800:         } else {
    73469: 1801:            if (!(flags & 1)) { // if it's a curve
    73469: 1801-block 51
branch  0 taken 30526 (fallthrough)
branch  1 taken 42943
    30526: 1802:               if (was_off) // two off-curve control points in a row means interpolate an on-curve midpoint
    30526: 1802-block 52
branch  0 taken 17251 (fallthrough)
branch  1 taken 13275
    17251: 1803:                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+x)>>1, (cy+y)>>1, cx, cy);
    17251: 1803-block 53
call    0 returned 17251
    30526: 1804:               cx = x;
    30526: 1805:               cy = y;
    30526: 1806:               was_off = 1;
    30526: 1806-block 54
        -: 1807:            } else {
    42943: 1808:               if (was_off)
    42943: 1808-block 55
branch  0 taken 11197 (fallthrough)
branch  1 taken 31746
    11197: 1809:                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, x,y, cx, cy);
    11197: 1809-block 56
call    0 returned 11197
        -: 1810:               else
    31746: 1811:                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vline, x,y,0,0);
    31746: 1811-block 57
call    0 returned 31746
    42943: 1812:               was_off = 0;
    42943: 1812-block 58
        -: 1813:            }
        -: 1814:         }
        -: 1815:      }
     2525: 1816:      num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);
     2525: 1816-block 61
call    0 returned 2525
      184: 1817:   } else if (numberOfContours < 0) {
      184: 1817-block 62
branch  0 taken 184 (fallthrough)
branch  1 taken 0
        -: 1818:      // Compound shapes.
      184: 1819:      int more = 1;
      184: 1820:      stbtt_uint8 *comp = data + g + 10;
      184: 1821:      num_vertices = 0;
      184: 1822:      vertices = 0;
      535: 1823:      while (more) {
      184: 1823-block 63
      535: 1823-block 106
branch  0 taken 351
branch  1 taken 184 (fallthrough)
        -: 1824:         stbtt_uint16 flags, gidx;
      351: 1825:         int comp_num_verts = 0, i;
      351: 1826:         stbtt_vertex *comp_verts = 0, *tmp = 0;
      351: 1827:         float mtx[6] = {1,0,0,1,0,0}, m, n;
        -: 1828:
      351: 1829:         flags = ttSHORT(comp); comp+=2;
      351: 1829-block 64
call    0 returned 351
      351: 1830:         gidx = ttSHORT(comp); comp+=2;
call    0 returned 351
        -: 1831:
      351: 1832:         if (flags & 2) { // XY values
branch  0 taken 351 (fallthrough)
branch  1 taken 0
      351: 1833:            if (flags & 1) { // shorts
      351: 1833-block 67
branch  0 taken 147 (fallthrough)
branch  1 taken 204
      147: 1834:               mtx[4] = ttSHORT(comp); comp+=2;
      147: 1834-block 68
call    0 returned 147
      147: 1835:               mtx[5] = ttSHORT(comp); comp+=2;
call    0 returned 147
        -: 1836:            } else {
      204: 1837:               mtx[4] = ttCHAR(comp); comp+=1;
      204: 1838:               mtx[5] = ttCHAR(comp); comp+=1;
      204: 1838-block 71
        -: 1839:            }
        -: 1840:         }
        -: 1841:         else {
        -: 1842:            // @TODO handle matching point
    #####: 1843:            STBTT_assert(0);
    %%%%%: 1843-block 72
call    0 never executed
        -: 1844:         }
      351: 1845:         if (flags & (1<<3)) { // WE_HAVE_A_SCALE
      351: 1845-block 73
branch  0 taken 0 (fallthrough)
branch  1 taken 351
    #####: 1846:            mtx[0] = mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
    %%%%%: 1846-block 74
call    0 never executed
    #####: 1847:            mtx[1] = mtx[2] = 0;
      351: 1848:         } else if (flags & (1<<6)) { // WE_HAVE_AN_X_AND_YSCALE
      351: 1848-block 76
branch  0 taken 0 (fallthrough)
branch  1 taken 351
    #####: 1849:            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;
    %%%%%: 1849-block 77
call    0 never executed
    #####: 1850:            mtx[1] = mtx[2] = 0;
    #####: 1851:            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
call    0 never executed
      351: 1852:         } else if (flags & (1<<7)) { // WE_HAVE_A_TWO_BY_TWO
      351: 1852-block 80
branch  0 taken 0 (fallthrough)
branch  1 taken 351
    #####: 1853:            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;
    %%%%%: 1853-block 81
call    0 never executed
    #####: 1854:            mtx[1] = ttSHORT(comp)/16384.0f; comp+=2;
call    0 never executed
    #####: 1855:            mtx[2] = ttSHORT(comp)/16384.0f; comp+=2;
call    0 never executed
    #####: 1856:            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
call    0 never executed
        -: 1857:         }
        -: 1858:
        -: 1859:         // Find transformation scales.
      351: 1860:         m = (float) STBTT_sqrt(mtx[0]*mtx[0] + mtx[1]*mtx[1]);
      351: 1861:         n = (float) STBTT_sqrt(mtx[2]*mtx[2] + mtx[3]*mtx[3]);
        -: 1862:
        -: 1863:         // Get indexed glyph.
      351: 1864:         comp_num_verts = stbtt_GetGlyphShape(info, gidx, &comp_verts);
      351: 1864-block 86
call    0 returned 351
branch  1 taken 351 (fallthrough)
branch  2 taken 0 (throw)
      351: 1865:         if (comp_num_verts > 0) {
      351: 1865-block 87
branch  0 taken 351 (fallthrough)
branch  1 taken 0
        -: 1866:            // Transform vertices.
     6600: 1867:            for (i = 0; i < comp_num_verts; ++i) {
      351: 1867-block 88
     6600: 1867-block 90
branch  0 taken 6249
branch  1 taken 351 (fallthrough)
     6249: 1868:               stbtt_vertex* v = &comp_verts[i];
        -: 1869:               stbtt_vertex_type x,y;
     6249: 1870:               x=v->x; y=v->y;
     6249: 1871:               v->x = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));
     6249: 1872:               v->y = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));
     6249: 1873:               x=v->cx; y=v->cy;
     6249: 1874:               v->cx = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));
     6249: 1875:               v->cy = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));
     6249: 1875-block 89
        -: 1876:            }
        -: 1877:            // Append vertices.
      351: 1878:            tmp = (stbtt_vertex*)STBTT_malloc((num_vertices+comp_num_verts)*sizeof(stbtt_vertex), info->userdata);
      351: 1878-block 91
call    0 returned 351
branch  1 taken 351 (fallthrough)
branch  2 taken 0 (throw)
      351: 1879:            if (!tmp) {
      351: 1879-block 92
branch  0 taken 0 (fallthrough)
branch  1 taken 351
    #####: 1880:               if (vertices) STBTT_free(vertices, info->userdata);
    %%%%%: 1880-block 93
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1880-block 94
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####: 1881:               if (comp_verts) STBTT_free(comp_verts, info->userdata);
    %%%%%: 1881-block 95
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1881-block 96
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####: 1882:               return 0;
    %%%%%: 1882-block 97
        -: 1883:            }
      351: 1884:            if (num_vertices > 0 && vertices) STBTT_memcpy(tmp, vertices, num_vertices*sizeof(stbtt_vertex));
      351: 1884-block 98
branch  0 taken 167 (fallthrough)
branch  1 taken 184
      167: 1884-block 99
branch  2 taken 167 (fallthrough)
branch  3 taken 0
      167: 1884-block 100
      351: 1885:            STBTT_memcpy(tmp+num_vertices, comp_verts, comp_num_verts*sizeof(stbtt_vertex));
      351: 1886:            if (vertices) STBTT_free(vertices, info->userdata);
      351: 1886-block 101
branch  0 taken 167 (fallthrough)
branch  1 taken 184
      167: 1886-block 102
call    2 returned 167
branch  3 taken 167 (fallthrough)
branch  4 taken 0 (throw)
      351: 1887:            vertices = tmp;
      351: 1888:            STBTT_free(comp_verts, info->userdata);
      351: 1888-block 103
call    0 returned 351
branch  1 taken 351 (fallthrough)
branch  2 taken 0 (throw)
      351: 1889:            num_vertices += comp_num_verts;
      351: 1889-block 104
        -: 1890:         }
        -: 1891:         // More components ?
      351: 1892:         more = flags & (1<<5);
      351: 1892-block 105
        -: 1893:      }
        -: 1894:   } else {
        -: 1895:      // numberOfCounters == 0, do nothing
        -: 1896:   }
        -: 1897:
     2709: 1898:   *pvertices = vertices;
     2709: 1899:   return num_vertices;
     2709: 1899-block 107
        -: 1900:}
        -: 1901:
        -: 1902:typedef struct
        -: 1903:{
        -: 1904:   int bounds;
        -: 1905:   int started;
        -: 1906:   float first_x, first_y;
        -: 1907:   float x, y;
        -: 1908:   stbtt_int32 min_x, max_x, min_y, max_y;
        -: 1909:
        -: 1910:   stbtt_vertex *pvertices;
        -: 1911:   int num_vertices;
        -: 1912:} stbtt__csctx;
        -: 1913:
        -: 1914:#define STBTT__CSCTX_INIT(bounds) {bounds,0, 0,0, 0,0, 0,0,0,0, NULL, 0}
        -: 1915:
function _ZL19stbtt__track_vertexP12stbtt__csctxii called 0 returned 0% blocks executed 0%
    #####: 1916:static void stbtt__track_vertex(stbtt__csctx *c, stbtt_int32 x, stbtt_int32 y)
        -: 1917:{
    #####: 1918:   if (x > c->max_x || !c->started) c->max_x = x;
    %%%%%: 1918-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1918-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1918-block 4
    #####: 1919:   if (y > c->max_y || !c->started) c->max_y = y;
    %%%%%: 1919-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1919-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1919-block 7
    #####: 1920:   if (x < c->min_x || !c->started) c->min_x = x;
    %%%%%: 1920-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1920-block 9
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1920-block 10
    #####: 1921:   if (y < c->min_y || !c->started) c->min_y = y;
    %%%%%: 1921-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1921-block 12
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1921-block 13
    #####: 1922:   c->started = 1;
    #####: 1923:}
        -: 1924:
function _ZL14stbtt__csctx_vP12stbtt__csctxhiiiiii called 0 returned 0% blocks executed 0%
    #####: 1925:static void stbtt__csctx_v(stbtt__csctx *c, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy, stbtt_int32 cx1, stbtt_int32 cy1)
        -: 1926:{
    #####: 1927:   if (c->bounds) {
    %%%%%: 1927-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1928:      stbtt__track_vertex(c, x, y);
    %%%%%: 1928-block 3
call    0 never executed
    #####: 1929:      if (type == STBTT_vcubic) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1930:         stbtt__track_vertex(c, cx, cy);
    %%%%%: 1930-block 5
call    0 never executed
    #####: 1931:         stbtt__track_vertex(c, cx1, cy1);
call    0 never executed
        -: 1932:      }
        -: 1933:   } else {
    #####: 1934:      stbtt_setvertex(&c->pvertices[c->num_vertices], type, x, y, cx, cy);
    %%%%%: 1934-block 7
call    0 never executed
    #####: 1935:      c->pvertices[c->num_vertices].cx1 = (stbtt_int16) cx1;
    #####: 1936:      c->pvertices[c->num_vertices].cy1 = (stbtt_int16) cy1;
        -: 1937:   }
    #####: 1938:   c->num_vertices++;
    #####: 1939:}
        -: 1940:
function _ZL24stbtt__csctx_close_shapeP12stbtt__csctx called 0 returned 0% blocks executed 0%
    #####: 1941:static void stbtt__csctx_close_shape(stbtt__csctx *ctx)
        -: 1942:{
    #####: 1943:   if (ctx->first_x != ctx->x || ctx->first_y != ctx->y)
    %%%%%: 1943-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1943-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 1944:      stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->first_x, (int)ctx->first_y, 0, 0, 0, 0);
    %%%%%: 1944-block 4
call    0 never executed
    #####: 1945:}
        -: 1946:
function _ZL21stbtt__csctx_rmove_toP12stbtt__csctxff called 0 returned 0% blocks executed 0%
    #####: 1947:static void stbtt__csctx_rmove_to(stbtt__csctx *ctx, float dx, float dy)
        -: 1948:{
    #####: 1949:   stbtt__csctx_close_shape(ctx);
    %%%%%: 1949-block 2
call    0 never executed
    #####: 1950:   ctx->first_x = ctx->x = ctx->x + dx;
    #####: 1951:   ctx->first_y = ctx->y = ctx->y + dy;
    #####: 1952:   stbtt__csctx_v(ctx, STBTT_vmove, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);
call    0 never executed
    #####: 1953:}
        -: 1954:
function _ZL21stbtt__csctx_rline_toP12stbtt__csctxff called 0 returned 0% blocks executed 0%
    #####: 1955:static void stbtt__csctx_rline_to(stbtt__csctx *ctx, float dx, float dy)
        -: 1956:{
    #####: 1957:   ctx->x += dx;
    #####: 1958:   ctx->y += dy;
    #####: 1959:   stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);
    %%%%%: 1959-block 2
call    0 never executed
    #####: 1960:}
        -: 1961:
function _ZL23stbtt__csctx_rccurve_toP12stbtt__csctxffffff called 0 returned 0% blocks executed 0%
    #####: 1962:static void stbtt__csctx_rccurve_to(stbtt__csctx *ctx, float dx1, float dy1, float dx2, float dy2, float dx3, float dy3)
        -: 1963:{
    #####: 1964:   float cx1 = ctx->x + dx1;
    #####: 1965:   float cy1 = ctx->y + dy1;
    #####: 1966:   float cx2 = cx1 + dx2;
    #####: 1967:   float cy2 = cy1 + dy2;
    #####: 1968:   ctx->x = cx2 + dx3;
    #####: 1969:   ctx->y = cy2 + dy3;
    #####: 1970:   stbtt__csctx_v(ctx, STBTT_vcubic, (int)ctx->x, (int)ctx->y, (int)cx1, (int)cy1, (int)cx2, (int)cy2);
    %%%%%: 1970-block 2
call    0 never executed
    #####: 1971:}
        -: 1972:
function _ZL15stbtt__get_subr10stbtt__bufi called 0 returned 0% blocks executed 0%
    #####: 1973:static stbtt__buf stbtt__get_subr(stbtt__buf idx, int n)
        -: 1974:{
    #####: 1975:   int count = stbtt__cff_index_count(&idx);
    %%%%%: 1975-block 2
call    0 never executed
    #####: 1976:   int bias = 107;
    #####: 1977:   if (count >= 33900)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1978:      bias = 32768;
    %%%%%: 1978-block 4
    #####: 1979:   else if (count >= 1240)
    %%%%%: 1979-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1980:      bias = 1131;
    %%%%%: 1980-block 6
    #####: 1981:   n += bias;
    #####: 1982:   if (n < 0 || n >= count)
    %%%%%: 1982-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1982-block 8
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 1983:      return stbtt__new_buf(NULL, 0);
    %%%%%: 1983-block 9
call    0 never executed
    #####: 1984:   return stbtt__cff_index_get(idx, n);
    %%%%%: 1984-block 10
call    0 never executed
        -: 1985:}
        -: 1986:
function _ZL26stbtt__cid_get_glyph_subrsPK14stbtt_fontinfoi called 0 returned 0% blocks executed 0%
    #####: 1987:static stbtt__buf stbtt__cid_get_glyph_subrs(const stbtt_fontinfo *info, int glyph_index)
        -: 1988:{
    #####: 1989:   stbtt__buf fdselect = info->fdselect;
    #####: 1990:   int nranges, start, end, v, fmt, fdselector = -1, i;
        -: 1991:
    #####: 1992:   stbtt__buf_seek(&fdselect, 0);
    %%%%%: 1992-block 2
call    0 never executed
    #####: 1993:   fmt = stbtt__buf_get8(&fdselect);
call    0 never executed
    #####: 1994:   if (fmt == 0) {
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1995:      // untested
    #####: 1996:      stbtt__buf_skip(&fdselect, glyph_index);
    %%%%%: 1996-block 5
call    0 never executed
    #####: 1997:      fdselector = stbtt__buf_get8(&fdselect);
call    0 never executed
    #####: 1998:   } else if (fmt == 3) {
    %%%%%: 1998-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1999:      nranges = stbtt__buf_get16(&fdselect);
    %%%%%: 1999-block 9
call    0 never executed
    #####: 2000:      start = stbtt__buf_get16(&fdselect);
call    0 never executed
    #####: 2001:      for (i = 0; i < nranges; i++) {
    %%%%%: 2001-block 18
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2002:         v = stbtt__buf_get8(&fdselect);
    %%%%%: 2002-block 12
call    0 never executed
    #####: 2003:         end = stbtt__buf_get16(&fdselect);
call    0 never executed
    #####: 2004:         if (glyph_index >= start && glyph_index < end) {
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2004-block 15
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2005:            fdselector = v;
    #####: 2006:            break;
    %%%%%: 2006-block 16
        -: 2007:         }
    #####: 2008:         start = end;
    %%%%%: 2008-block 17
        -: 2009:      }
        -: 2010:   }
    #####: 2011:   if (fdselector == -1) return stbtt__new_buf(NULL, 0); // [DEAR IMGUI] fixed, see #6007 and nothings/stb#1422
    %%%%%: 2011-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2011-block 21
call    2 never executed
    #####: 2012:   return stbtt__get_subrs(info->cff, stbtt__cff_index_get(info->fontdicts, fdselector));
    %%%%%: 2012-block 22
call    0 never executed
call    1 never executed
        -: 2013:}
        -: 2014:
function _ZL21stbtt__run_charstringPK14stbtt_fontinfoiP12stbtt__csctx called 0 returned 0% blocks executed 0%
    #####: 2015:static int stbtt__run_charstring(const stbtt_fontinfo *info, int glyph_index, stbtt__csctx *c)
        -: 2016:{
    #####: 2017:   int in_header = 1, maskbits = 0, subr_stack_height = 0, sp = 0, v, i, b0;
    #####: 2018:   int has_subrs = 0, clear_stack;
        -: 2019:   float s[48];
    #####: 2020:   stbtt__buf subr_stack[10], subrs = info->subrs, b;
        -: 2021:   float f;
        -: 2022:
        -: 2023:#define STBTT__CSERR(s) (0)
        -: 2024:
        -: 2025:   // this currently ignores the initial width value, which isn't needed if we have hmtx
    #####: 2026:   b = stbtt__cff_index_get(info->charstrings, glyph_index);
    %%%%%: 2026-block 2
call    0 never executed
    #####: 2027:   while (b.cursor < b.size) {
    %%%%%: 2027-block 164
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2028:      i = 0;
    #####: 2029:      clear_stack = 1;
    #####: 2030:      b0 = stbtt__buf_get8(&b);
    %%%%%: 2030-block 4
call    0 never executed
    #####: 2031:      switch (b0) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
        -: 2032:      // @TODO implement hinting
    #####: 2033:      case 0x13: // hintmask
        -: 2034:      case 0x14: // cntrmask
    #####: 2035:         if (in_header)
    %%%%%: 2035-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2036:            maskbits += (sp / 2); // implicit "vstem"
    %%%%%: 2036-block 7
    #####: 2037:         in_header = 0;
    #####: 2038:         stbtt__buf_skip(&b, (maskbits + 7) / 8);
    %%%%%: 2038-block 8
call    0 never executed
    #####: 2039:         break;
        -: 2040:
    #####: 2041:      case 0x01: // hstem
        -: 2042:      case 0x03: // vstem
        -: 2043:      case 0x12: // hstemhm
        -: 2044:      case 0x17: // vstemhm
    #####: 2045:         maskbits += (sp / 2);
    #####: 2046:         break;
    %%%%%: 2046-block 10
        -: 2047:
    #####: 2048:      case 0x15: // rmoveto
    #####: 2049:         in_header = 0;
    #####: 2050:         if (sp < 2) return STBTT__CSERR("rmoveto stack");
    %%%%%: 2050-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2050-block 12
    #####: 2051:         stbtt__csctx_rmove_to(c, s[sp-2], s[sp-1]);
    %%%%%: 2051-block 13
call    0 never executed
    #####: 2052:         break;
    #####: 2053:      case 0x04: // vmoveto
    #####: 2054:         in_header = 0;
    #####: 2055:         if (sp < 1) return STBTT__CSERR("vmoveto stack");
    %%%%%: 2055-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2055-block 16
    #####: 2056:         stbtt__csctx_rmove_to(c, 0, s[sp-1]);
    %%%%%: 2056-block 17
call    0 never executed
    #####: 2057:         break;
    #####: 2058:      case 0x16: // hmoveto
    #####: 2059:         in_header = 0;
    #####: 2060:         if (sp < 1) return STBTT__CSERR("hmoveto stack");
    %%%%%: 2060-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2060-block 20
    #####: 2061:         stbtt__csctx_rmove_to(c, s[sp-1], 0);
    %%%%%: 2061-block 21
call    0 never executed
    #####: 2062:         break;
        -: 2063:
    #####: 2064:      case 0x05: // rlineto
    #####: 2065:         if (sp < 2) return STBTT__CSERR("rlineto stack");
    %%%%%: 2065-block 23
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2065-block 24
    #####: 2066:         for (; i + 1 < sp; i += 2)
    %%%%%: 2066-block 25
    %%%%%: 2066-block 28
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2067:            stbtt__csctx_rline_to(c, s[i], s[i+1]);
    %%%%%: 2067-block 26
call    0 never executed
    #####: 2068:         break;
    %%%%%: 2068-block 29
        -: 2069:
        -: 2070:      // hlineto/vlineto and vhcurveto/hvcurveto alternate horizontal and vertical
        -: 2071:      // starting from a different place.
        -: 2072:
    #####: 2073:      case 0x07: // vlineto
    #####: 2074:         if (sp < 1) return STBTT__CSERR("vlineto stack");
    %%%%%: 2074-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2074-block 31
    #####: 2075:         goto vlineto;
    %%%%%: 2075-block 32
    #####: 2076:      case 0x06: // hlineto
    #####: 2077:         if (sp < 1) return STBTT__CSERR("hlineto stack");
    %%%%%: 2077-block 33
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2077-block 34
        -: 2078:         for (;;) {
    #####: 2079:            if (i >= sp) break;
    %%%%%: 2079-block 35
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2079-block 36
    #####: 2080:            stbtt__csctx_rline_to(c, s[i], 0);
    %%%%%: 2080-block 37
call    0 never executed
    #####: 2081:            i++;
    #####: 2082:      vlineto:
    #####: 2083:            if (i >= sp) break;
    %%%%%: 2083-block 39
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2083-block 40
    #####: 2084:            stbtt__csctx_rline_to(c, 0, s[i]);
    %%%%%: 2084-block 41
call    0 never executed
    #####: 2085:            i++;
        -: 2086:         }
    #####: 2087:         break;
    %%%%%: 2087-block 43
        -: 2088:
    #####: 2089:      case 0x1F: // hvcurveto
    #####: 2090:         if (sp < 4) return STBTT__CSERR("hvcurveto stack");
    %%%%%: 2090-block 44
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2090-block 45
    #####: 2091:         goto hvcurveto;
    %%%%%: 2091-block 46
    #####: 2092:      case 0x1E: // vhcurveto
    #####: 2093:         if (sp < 4) return STBTT__CSERR("vhcurveto stack");
    %%%%%: 2093-block 47
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2093-block 48
        -: 2094:         for (;;) {
    #####: 2095:            if (i + 3 >= sp) break;
    %%%%%: 2095-block 49
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2095-block 50
    #####: 2096:            stbtt__csctx_rccurve_to(c, 0, s[i], s[i+1], s[i+2], s[i+3], (sp - i == 5) ? s[i + 4] : 0.0f);
    %%%%%: 2096-block 51
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2096-block 52
    %%%%%: 2096-block 53
    %%%%%: 2096-block 54
call    2 never executed
    #####: 2097:            i += 4;
    #####: 2098:      hvcurveto:
    #####: 2099:            if (i + 3 >= sp) break;
    %%%%%: 2099-block 56
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2099-block 57
    #####: 2100:            stbtt__csctx_rccurve_to(c, s[i], 0, s[i+1], s[i+2], (sp - i == 5) ? s[i+4] : 0.0f, s[i+3]);
    %%%%%: 2100-block 58
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2100-block 59
    %%%%%: 2100-block 60
    %%%%%: 2100-block 61
call    2 never executed
    #####: 2101:            i += 4;
        -: 2102:         }
    #####: 2103:         break;
    %%%%%: 2103-block 63
        -: 2104:
    #####: 2105:      case 0x08: // rrcurveto
    #####: 2106:         if (sp < 6) return STBTT__CSERR("rcurveline stack");
    %%%%%: 2106-block 64
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2106-block 65
    #####: 2107:         for (; i + 5 < sp; i += 6)
    %%%%%: 2107-block 66
    %%%%%: 2107-block 69
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2108:            stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);
    %%%%%: 2108-block 67
call    0 never executed
    #####: 2109:         break;
    %%%%%: 2109-block 70
        -: 2110:
    #####: 2111:      case 0x18: // rcurveline
    #####: 2112:         if (sp < 8) return STBTT__CSERR("rcurveline stack");
    %%%%%: 2112-block 71
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2112-block 72
    #####: 2113:         for (; i + 5 < sp - 2; i += 6)
    %%%%%: 2113-block 73
    %%%%%: 2113-block 76
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2114:            stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);
    %%%%%: 2114-block 74
call    0 never executed
    #####: 2115:         if (i + 1 >= sp) return STBTT__CSERR("rcurveline stack");
    %%%%%: 2115-block 77
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2115-block 78
    #####: 2116:         stbtt__csctx_rline_to(c, s[i], s[i+1]);
    %%%%%: 2116-block 79
call    0 never executed
    #####: 2117:         break;
        -: 2118:
    #####: 2119:      case 0x19: // rlinecurve
    #####: 2120:         if (sp < 8) return STBTT__CSERR("rlinecurve stack");
    %%%%%: 2120-block 81
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2120-block 82
    #####: 2121:         for (; i + 1 < sp - 6; i += 2)
    %%%%%: 2121-block 83
    %%%%%: 2121-block 86
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2122:            stbtt__csctx_rline_to(c, s[i], s[i+1]);
    %%%%%: 2122-block 84
call    0 never executed
    #####: 2123:         if (i + 5 >= sp) return STBTT__CSERR("rlinecurve stack");
    %%%%%: 2123-block 87
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2123-block 88
    #####: 2124:         stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);
    %%%%%: 2124-block 89
call    0 never executed
    #####: 2125:         break;
        -: 2126:
    #####: 2127:      case 0x1A: // vvcurveto
        -: 2128:      case 0x1B: // hhcurveto
    #####: 2129:         if (sp < 4) return STBTT__CSERR("(vv|hh)curveto stack");
    %%%%%: 2129-block 91
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2129-block 92
    #####: 2130:         f = 0.0;
    #####: 2131:         if (sp & 1) { f = s[i]; i++; }
    %%%%%: 2131-block 93
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2131-block 94
    #####: 2132:         for (; i + 3 < sp; i += 4) {
    %%%%%: 2132-block 95
    %%%%%: 2132-block 100
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2133:            if (b0 == 0x1B)
    %%%%%: 2133-block 96
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2134:               stbtt__csctx_rccurve_to(c, s[i], f, s[i+1], s[i+2], s[i+3], 0.0);
    %%%%%: 2134-block 97
call    0 never executed
        -: 2135:            else
    #####: 2136:               stbtt__csctx_rccurve_to(c, f, s[i], s[i+1], s[i+2], 0.0, s[i+3]);
    %%%%%: 2136-block 98
call    0 never executed
    #####: 2137:            f = 0.0;
    %%%%%: 2137-block 99
        -: 2138:         }
    #####: 2139:         break;
    %%%%%: 2139-block 101
        -: 2140:
    #####: 2141:      case 0x0A: // callsubr
    #####: 2142:         if (!has_subrs) {
    %%%%%: 2142-block 102
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2143:            if (info->fdselect.size)
    %%%%%: 2143-block 103
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2144:               subrs = stbtt__cid_get_glyph_subrs(info, glyph_index);
    %%%%%: 2144-block 104
call    0 never executed
    #####: 2145:            has_subrs = 1;
    %%%%%: 2145-block 105
        -: 2146:         }
        -: 2147:         // FALLTHROUGH
        -: 2148:      case 0x1D: // callgsubr
    #####: 2149:         if (sp < 1) return STBTT__CSERR("call(g|)subr stack");
    %%%%%: 2149-block 106
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2149-block 107
    #####: 2150:         v = (int) s[--sp];
    #####: 2151:         if (subr_stack_height >= 10) return STBTT__CSERR("recursion limit");
    %%%%%: 2151-block 108
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2151-block 109
    #####: 2152:         subr_stack[subr_stack_height++] = b;
    #####: 2153:         b = stbtt__get_subr(b0 == 0x0A ? subrs : info->gsubrs, v);
    %%%%%: 2153-block 110
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2153-block 111
    %%%%%: 2153-block 112
    %%%%%: 2153-block 113
call    2 never executed
    #####: 2154:         if (b.size == 0) return STBTT__CSERR("subr not found");
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2154-block 115
    #####: 2155:         b.cursor = 0;
    #####: 2156:         clear_stack = 0;
    #####: 2157:         break;
    %%%%%: 2157-block 116
        -: 2158:
    #####: 2159:      case 0x0B: // return
    #####: 2160:         if (subr_stack_height <= 0) return STBTT__CSERR("return outside subr");
    %%%%%: 2160-block 117
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2160-block 118
    #####: 2161:         b = subr_stack[--subr_stack_height];
    #####: 2162:         clear_stack = 0;
    #####: 2163:         break;
    %%%%%: 2163-block 119
        -: 2164:
    #####: 2165:      case 0x0E: // endchar
    #####: 2166:         stbtt__csctx_close_shape(c);
    %%%%%: 2166-block 120
call    0 never executed
    #####: 2167:         return 1;
        -: 2168:
    #####: 2169:      case 0x0C: { // two-byte escape
        -: 2170:         float dx1, dx2, dx3, dx4, dx5, dx6, dy1, dy2, dy3, dy4, dy5, dy6;
        -: 2171:         float dx, dy;
    #####: 2172:         int b1 = stbtt__buf_get8(&b);
    %%%%%: 2172-block 122
call    0 never executed
    #####: 2173:         switch (b1) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -: 2174:         // @TODO These "flex" implementations ignore the flex-depth and resolution,
        -: 2175:         // and always draw beziers.
    #####: 2176:         case 0x22: // hflex
    #####: 2177:            if (sp < 7) return STBTT__CSERR("hflex stack");
    %%%%%: 2177-block 124
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2177-block 125
    #####: 2178:            dx1 = s[0];
    #####: 2179:            dx2 = s[1];
    #####: 2180:            dy2 = s[2];
    #####: 2181:            dx3 = s[3];
    #####: 2182:            dx4 = s[4];
    #####: 2183:            dx5 = s[5];
    #####: 2184:            dx6 = s[6];
    #####: 2185:            stbtt__csctx_rccurve_to(c, dx1, 0, dx2, dy2, dx3, 0);
    %%%%%: 2185-block 126
call    0 never executed
    #####: 2186:            stbtt__csctx_rccurve_to(c, dx4, 0, dx5, -dy2, dx6, 0);
call    0 never executed
    #####: 2187:            break;
        -: 2188:
    #####: 2189:         case 0x23: // flex
    #####: 2190:            if (sp < 13) return STBTT__CSERR("flex stack");
    %%%%%: 2190-block 128
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2190-block 129
    #####: 2191:            dx1 = s[0];
    #####: 2192:            dy1 = s[1];
    #####: 2193:            dx2 = s[2];
    #####: 2194:            dy2 = s[3];
    #####: 2195:            dx3 = s[4];
    #####: 2196:            dy3 = s[5];
    #####: 2197:            dx4 = s[6];
    #####: 2198:            dy4 = s[7];
    #####: 2199:            dx5 = s[8];
    #####: 2200:            dy5 = s[9];
    #####: 2201:            dx6 = s[10];
    #####: 2202:            dy6 = s[11];
        -: 2203:            //fd is s[12]
    #####: 2204:            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);
    %%%%%: 2204-block 130
call    0 never executed
    #####: 2205:            stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);
call    0 never executed
    #####: 2206:            break;
        -: 2207:
    #####: 2208:         case 0x24: // hflex1
    #####: 2209:            if (sp < 9) return STBTT__CSERR("hflex1 stack");
    %%%%%: 2209-block 133
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2209-block 134
    #####: 2210:            dx1 = s[0];
    #####: 2211:            dy1 = s[1];
    #####: 2212:            dx2 = s[2];
    #####: 2213:            dy2 = s[3];
    #####: 2214:            dx3 = s[4];
    #####: 2215:            dx4 = s[5];
    #####: 2216:            dx5 = s[6];
    #####: 2217:            dy5 = s[7];
    #####: 2218:            dx6 = s[8];
    #####: 2219:            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, 0);
    %%%%%: 2219-block 135
call    0 never executed
    #####: 2220:            stbtt__csctx_rccurve_to(c, dx4, 0, dx5, dy5, dx6, -(dy1+dy2+dy5));
call    0 never executed
    #####: 2221:            break;
        -: 2222:
    #####: 2223:         case 0x25: // flex1
    #####: 2224:            if (sp < 11) return STBTT__CSERR("flex1 stack");
    %%%%%: 2224-block 138
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2224-block 139
    #####: 2225:            dx1 = s[0];
    #####: 2226:            dy1 = s[1];
    #####: 2227:            dx2 = s[2];
    #####: 2228:            dy2 = s[3];
    #####: 2229:            dx3 = s[4];
    #####: 2230:            dy3 = s[5];
    #####: 2231:            dx4 = s[6];
    #####: 2232:            dy4 = s[7];
    #####: 2233:            dx5 = s[8];
    #####: 2234:            dy5 = s[9];
    #####: 2235:            dx6 = dy6 = s[10];
    #####: 2236:            dx = dx1+dx2+dx3+dx4+dx5;
    #####: 2237:            dy = dy1+dy2+dy3+dy4+dy5;
    #####: 2238:            if (STBTT_fabs(dx) > STBTT_fabs(dy))
    %%%%%: 2238-block 140
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2239:               dy6 = -dy;
    %%%%%: 2239-block 141
        -: 2240:            else
    #####: 2241:               dx6 = -dx;
    %%%%%: 2241-block 142
    #####: 2242:            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);
    %%%%%: 2242-block 143
call    0 never executed
    #####: 2243:            stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);
call    0 never executed
    #####: 2244:            break;
        -: 2245:
    #####: 2246:         default:
    #####: 2247:            return STBTT__CSERR("unimplemented");
    %%%%%: 2247-block 146
        -: 2248:         }
    #####: 2249:      } break;
    %%%%%: 2249-block 148
        -: 2250:
    #####: 2251:      default:
    #####: 2252:         if (b0 != 255 && b0 != 28 && b0 < 32)
    %%%%%: 2252-block 149
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2252-block 150
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2252-block 151
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 2253:            return STBTT__CSERR("reserved operator");
    %%%%%: 2253-block 152
        -: 2254:
        -: 2255:         // push immediate
    #####: 2256:         if (b0 == 255) {
    %%%%%: 2256-block 153
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2257:            f = (float)(stbtt_int32)stbtt__buf_get32(&b) / 0x10000;
    %%%%%: 2257-block 154
call    0 never executed
        -: 2258:         } else {
    #####: 2259:            stbtt__buf_skip(&b, -1);
    %%%%%: 2259-block 156
call    0 never executed
    #####: 2260:            f = (float)(stbtt_int16)stbtt__cff_int(&b);
call    0 never executed
        -: 2261:         }
    #####: 2262:         if (sp >= 48) return STBTT__CSERR("push stack overflow");
    %%%%%: 2262-block 159
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2262-block 160
    #####: 2263:         s[sp++] = f;
    #####: 2264:         clear_stack = 0;
    #####: 2265:         break;
    %%%%%: 2265-block 161
        -: 2266:      }
    #####: 2267:      if (clear_stack) sp = 0;
    %%%%%: 2267-block 162
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2267-block 163
        -: 2268:   }
    #####: 2269:   return STBTT__CSERR("no endchar");
    %%%%%: 2269-block 165
        -: 2270:
        -: 2271:#undef STBTT__CSERR
        -: 2272:}
        -: 2273:
function _ZL22stbtt__GetGlyphShapeT2PK14stbtt_fontinfoiPP12stbtt_vertex called 0 returned 0% blocks executed 0%
    #####: 2274:static int stbtt__GetGlyphShapeT2(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)
        -: 2275:{
        -: 2276:   // runs the charstring twice, once to count and once to output (to avoid realloc)
    #####: 2277:   stbtt__csctx count_ctx = STBTT__CSCTX_INIT(1);
    #####: 2278:   stbtt__csctx output_ctx = STBTT__CSCTX_INIT(0);
    #####: 2279:   if (stbtt__run_charstring(info, glyph_index, &count_ctx)) {
    %%%%%: 2279-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 2280:      *pvertices = (stbtt_vertex*)STBTT_malloc(count_ctx.num_vertices*sizeof(stbtt_vertex), info->userdata);
    %%%%%: 2280-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 2281:      output_ctx.pvertices = *pvertices;
    #####: 2282:      if (stbtt__run_charstring(info, glyph_index, &output_ctx)) {
    %%%%%: 2282-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 2283:         STBTT_assert(output_ctx.num_vertices == count_ctx.num_vertices);
    %%%%%: 2283-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2283-block 8
call    2 never executed
    #####: 2284:         return output_ctx.num_vertices;
    %%%%%: 2284-block 9
        -: 2285:      }
        -: 2286:   }
    #####: 2287:   *pvertices = NULL;
    #####: 2288:   return 0;
    %%%%%: 2288-block 10
        -: 2289:}
        -: 2290:
function _ZL21stbtt__GetGlyphInfoT2PK14stbtt_fontinfoiPiS2_S2_S2_ called 0 returned 0% blocks executed 0%
    #####: 2291:static int stbtt__GetGlyphInfoT2(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)
        -: 2292:{
    #####: 2293:   stbtt__csctx c = STBTT__CSCTX_INIT(1);
    #####: 2294:   int r = stbtt__run_charstring(info, glyph_index, &c);
    %%%%%: 2294-block 2
call    0 never executed
    #####: 2295:   if (x0)  *x0 = r ? c.min_x : 0;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2295-block 4
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2295-block 5
    %%%%%: 2295-block 6
    %%%%%: 2295-block 7
    #####: 2296:   if (y0)  *y0 = r ? c.min_y : 0;
    %%%%%: 2296-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2296-block 9
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2296-block 10
    %%%%%: 2296-block 11
    %%%%%: 2296-block 12
    #####: 2297:   if (x1)  *x1 = r ? c.max_x : 0;
    %%%%%: 2297-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2297-block 14
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2297-block 15
    %%%%%: 2297-block 16
    %%%%%: 2297-block 17
    #####: 2298:   if (y1)  *y1 = r ? c.max_y : 0;
    %%%%%: 2298-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2298-block 19
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2298-block 20
    %%%%%: 2298-block 21
    %%%%%: 2298-block 22
    #####: 2299:   return r ? c.num_vertices : 0;
    %%%%%: 2299-block 23
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2299-block 24
    %%%%%: 2299-block 25
    %%%%%: 2299-block 26
        -: 2300:}
        -: 2301:
function stbtt_GetGlyphShape called 2731 returned 100% blocks executed 67%
     2731: 2302:STBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)
        -: 2303:{
     2731: 2304:   if (!info->cff.size)
     2731: 2304-block 2
branch  0 taken 2731 (fallthrough)
branch  1 taken 0
     2731: 2305:      return stbtt__GetGlyphShapeTT(info, glyph_index, pvertices);
     2731: 2305-block 3
call    0 returned 2731
        -: 2306:   else
    #####: 2307:      return stbtt__GetGlyphShapeT2(info, glyph_index, pvertices);
    %%%%%: 2307-block 5
call    0 never executed
        -: 2308:}
        -: 2309:
function stbtt_GetGlyphHMetrics called 2380 returned 100% blocks executed 100%
     2380: 2310:STBTT_DEF void stbtt_GetGlyphHMetrics(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing)
        -: 2311:{
     2380: 2312:   stbtt_uint16 numOfLongHorMetrics = ttUSHORT(info->data+info->hhea + 34);
     2380: 2312-block 2
call    0 returned 2380
     2380: 2313:   if (glyph_index < numOfLongHorMetrics) {
branch  0 taken 2157 (fallthrough)
branch  1 taken 223
     2157: 2314:      if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*glyph_index);
     2157: 2314-block 4
branch  0 taken 2157 (fallthrough)
branch  1 taken 0
     2157: 2314-block 5
call    2 returned 2157
     2157: 2315:      if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*glyph_index + 2);
     2157: 2315-block 7
branch  0 taken 2157 (fallthrough)
branch  1 taken 0
     2157: 2315-block 8
call    2 returned 2157
        -: 2316:   } else {
      223: 2317:      if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*(numOfLongHorMetrics-1));
      223: 2317-block 10
branch  0 taken 223 (fallthrough)
branch  1 taken 0
      223: 2317-block 11
call    2 returned 223
      223: 2318:      if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*numOfLongHorMetrics + 2*(glyph_index - numOfLongHorMetrics));
      223: 2318-block 13
branch  0 taken 223 (fallthrough)
branch  1 taken 0
      223: 2318-block 14
call    2 returned 223
        -: 2319:   }
     2380: 2320:}
        -: 2321:
function stbtt_GetKerningTableLength called 0 returned 0% blocks executed 0%
    #####: 2322:STBTT_DEF int  stbtt_GetKerningTableLength(const stbtt_fontinfo *info)
        -: 2323:{
    #####: 2324:   stbtt_uint8 *data = info->data + info->kern;
        -: 2325:
        -: 2326:   // we only look at the first table. it must be 'horizontal' and format 0.
    #####: 2327:   if (!info->kern)
    %%%%%: 2327-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2328:      return 0;
    %%%%%: 2328-block 3
    #####: 2329:   if (ttUSHORT(data+2) < 1) // number of tables, need at least 1
    %%%%%: 2329-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 2330:      return 0;
    %%%%%: 2330-block 6
    #####: 2331:   if (ttUSHORT(data+8) != 1) // horizontal flag must be set in format
    %%%%%: 2331-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 2332:      return 0;
    %%%%%: 2332-block 9
        -: 2333:
    #####: 2334:   return ttUSHORT(data+10);
    %%%%%: 2334-block 10
call    0 never executed
        -: 2335:}
        -: 2336:
function stbtt_GetKerningTable called 0 returned 0% blocks executed 0%
    #####: 2337:STBTT_DEF int stbtt_GetKerningTable(const stbtt_fontinfo *info, stbtt_kerningentry* table, int table_length)
        -: 2338:{
    #####: 2339:   stbtt_uint8 *data = info->data + info->kern;
        -: 2340:   int k, length;
        -: 2341:
        -: 2342:   // we only look at the first table. it must be 'horizontal' and format 0.
    #####: 2343:   if (!info->kern)
    %%%%%: 2343-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2344:      return 0;
    %%%%%: 2344-block 3
    #####: 2345:   if (ttUSHORT(data+2) < 1) // number of tables, need at least 1
    %%%%%: 2345-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 2346:      return 0;
    %%%%%: 2346-block 6
    #####: 2347:   if (ttUSHORT(data+8) != 1) // horizontal flag must be set in format
    %%%%%: 2347-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 2348:      return 0;
    %%%%%: 2348-block 9
        -: 2349:
    #####: 2350:   length = ttUSHORT(data+10);
    %%%%%: 2350-block 10
call    0 never executed
    #####: 2351:   if (table_length < length)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2352:      length = table_length;
    %%%%%: 2352-block 12
        -: 2353:
    #####: 2354:   for (k = 0; k < length; k++)
    %%%%%: 2354-block 13
    %%%%%: 2354-block 18
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 2355:   {
    #####: 2356:      table[k].glyph1 = ttUSHORT(data+18+(k*6));
    %%%%%: 2356-block 14
call    0 never executed
    #####: 2357:      table[k].glyph2 = ttUSHORT(data+20+(k*6));
call    0 never executed
    #####: 2358:      table[k].advance = ttSHORT(data+22+(k*6));
call    0 never executed
        -: 2359:   }
        -: 2360:
    #####: 2361:   return length;
    %%%%%: 2361-block 19
        -: 2362:}
        -: 2363:
function _ZL30stbtt__GetGlyphKernInfoAdvancePK14stbtt_fontinfoii called 0 returned 0% blocks executed 0%
    #####: 2364:static int stbtt__GetGlyphKernInfoAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)
        -: 2365:{
    #####: 2366:   stbtt_uint8 *data = info->data + info->kern;
        -: 2367:   stbtt_uint32 needle, straw;
        -: 2368:   int l, r, m;
        -: 2369:
        -: 2370:   // we only look at the first table. it must be 'horizontal' and format 0.
    #####: 2371:   if (!info->kern)
    %%%%%: 2371-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2372:      return 0;
    %%%%%: 2372-block 3
    #####: 2373:   if (ttUSHORT(data+2) < 1) // number of tables, need at least 1
    %%%%%: 2373-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 2374:      return 0;
    %%%%%: 2374-block 6
    #####: 2375:   if (ttUSHORT(data+8) != 1) // horizontal flag must be set in format
    %%%%%: 2375-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 2376:      return 0;
    %%%%%: 2376-block 9
        -: 2377:
    #####: 2378:   l = 0;
    #####: 2379:   r = ttUSHORT(data+10) - 1;
    %%%%%: 2379-block 10
call    0 never executed
    #####: 2380:   needle = glyph1 << 16 | glyph2;
    #####: 2381:   while (l <= r) {
    %%%%%: 2381-block 19
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2382:      m = (l + r) >> 1;
    #####: 2383:      straw = ttULONG(data+18+(m*6)); // note: unaligned read
    %%%%%: 2383-block 12
call    0 never executed
    #####: 2384:      if (needle < straw)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2385:         r = m - 1;
    %%%%%: 2385-block 14
    #####: 2386:      else if (needle > straw)
    %%%%%: 2386-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2387:         l = m + 1;
    %%%%%: 2387-block 16
        -: 2388:      else
    #####: 2389:         return ttSHORT(data+22+(m*6));
    %%%%%: 2389-block 17
call    0 never executed
        -: 2390:   }
    #####: 2391:   return 0;
    %%%%%: 2391-block 20
        -: 2392:}
        -: 2393:
function _ZL23stbtt__GetCoverageIndexPhi called 0 returned 0% blocks executed 0%
    #####: 2394:static stbtt_int32 stbtt__GetCoverageIndex(stbtt_uint8 *coverageTable, int glyph)
        -: 2395:{
    #####: 2396:   stbtt_uint16 coverageFormat = ttUSHORT(coverageTable);
    %%%%%: 2396-block 2
call    0 never executed
    #####: 2397:   switch (coverageFormat) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2398:      case 1: {
    #####: 2399:         stbtt_uint16 glyphCount = ttUSHORT(coverageTable + 2);
    %%%%%: 2399-block 4
call    0 never executed
        -: 2400:
        -: 2401:         // Binary search.
    #####: 2402:         stbtt_int32 l=0, r=glyphCount-1, m;
    #####: 2403:         int straw, needle=glyph;
    #####: 2404:         while (l <= r) {
    %%%%%: 2404-block 12
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2405:            stbtt_uint8 *glyphArray = coverageTable + 4;
        -: 2406:            stbtt_uint16 glyphID;
    #####: 2407:            m = (l + r) >> 1;
    #####: 2408:            glyphID = ttUSHORT(glyphArray + 2 * m);
    %%%%%: 2408-block 6
call    0 never executed
    #####: 2409:            straw = glyphID;
    #####: 2410:            if (needle < straw)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2411:               r = m - 1;
    %%%%%: 2411-block 8
    #####: 2412:            else if (needle > straw)
    %%%%%: 2412-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2413:               l = m + 1;
    %%%%%: 2413-block 10
        -: 2414:            else {
    #####: 2415:               return m;
    %%%%%: 2415-block 11
        -: 2416:            }
        -: 2417:         }
    #####: 2418:         break;
    %%%%%: 2418-block 13
        -: 2419:      }
        -: 2420:
    #####: 2421:      case 2: {
    #####: 2422:         stbtt_uint16 rangeCount = ttUSHORT(coverageTable + 2);
    %%%%%: 2422-block 14
call    0 never executed
    #####: 2423:         stbtt_uint8 *rangeArray = coverageTable + 4;
        -: 2424:
        -: 2425:         // Binary search.
    #####: 2426:         stbtt_int32 l=0, r=rangeCount-1, m;
    #####: 2427:         int strawStart, strawEnd, needle=glyph;
    #####: 2428:         while (l <= r) {
    %%%%%: 2428-block 24
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 2429:            stbtt_uint8 *rangeRecord;
    #####: 2430:            m = (l + r) >> 1;
    #####: 2431:            rangeRecord = rangeArray + 6 * m;
    #####: 2432:            strawStart = ttUSHORT(rangeRecord);
    %%%%%: 2432-block 16
call    0 never executed
    #####: 2433:            strawEnd = ttUSHORT(rangeRecord + 2);
call    0 never executed
    #####: 2434:            if (needle < strawStart)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2435:               r = m - 1;
    %%%%%: 2435-block 19
    #####: 2436:            else if (needle > strawEnd)
    %%%%%: 2436-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2437:               l = m + 1;
    %%%%%: 2437-block 21
        -: 2438:            else {
    #####: 2439:               stbtt_uint16 startCoverageIndex = ttUSHORT(rangeRecord + 4);
    %%%%%: 2439-block 22
call    0 never executed
    #####: 2440:               return startCoverageIndex + glyph - strawStart;
        -: 2441:            }
        -: 2442:         }
    #####: 2443:         break;
    %%%%%: 2443-block 25
        -: 2444:      }
        -: 2445:
    #####: 2446:      default: return -1; // unsupported
    %%%%%: 2446-block 26
        -: 2447:   }
        -: 2448:
    #####: 2449:   return -1;
    %%%%%: 2449-block 27
        -: 2450:}
        -: 2451:
function _ZL20stbtt__GetGlyphClassPhi called 0 returned 0% blocks executed 0%
    #####: 2452:static stbtt_int32  stbtt__GetGlyphClass(stbtt_uint8 *classDefTable, int glyph)
        -: 2453:{
    #####: 2454:   stbtt_uint16 classDefFormat = ttUSHORT(classDefTable);
    %%%%%: 2454-block 2
call    0 never executed
    #####: 2455:   switch (classDefFormat)
branch  0 never executed
branch  1 never executed
branch  2 never executed
        -: 2456:   {
    #####: 2457:      case 1: {
    #####: 2458:         stbtt_uint16 startGlyphID = ttUSHORT(classDefTable + 2);
    %%%%%: 2458-block 4
call    0 never executed
    #####: 2459:         stbtt_uint16 glyphCount = ttUSHORT(classDefTable + 4);
call    0 never executed
    #####: 2460:         stbtt_uint8 *classDef1ValueArray = classDefTable + 6;
        -: 2461:
    #####: 2462:         if (glyph >= startGlyphID && glyph < startGlyphID + glyphCount)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2462-block 7
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2463:            return (stbtt_int32)ttUSHORT(classDef1ValueArray + 2 * (glyph - startGlyphID));
    %%%%%: 2463-block 8
call    0 never executed
    #####: 2464:         break;
    %%%%%: 2464-block 10
        -: 2465:      }
        -: 2466:
    #####: 2467:      case 2: {
    #####: 2468:         stbtt_uint16 classRangeCount = ttUSHORT(classDefTable + 2);
    %%%%%: 2468-block 11
call    0 never executed
    #####: 2469:         stbtt_uint8 *classRangeRecords = classDefTable + 4;
        -: 2470:
        -: 2471:         // Binary search.
    #####: 2472:         stbtt_int32 l=0, r=classRangeCount-1, m;
    #####: 2473:         int strawStart, strawEnd, needle=glyph;
    #####: 2474:         while (l <= r) {
    %%%%%: 2474-block 21
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 2475:            stbtt_uint8 *classRangeRecord;
    #####: 2476:            m = (l + r) >> 1;
    #####: 2477:            classRangeRecord = classRangeRecords + 6 * m;
    #####: 2478:            strawStart = ttUSHORT(classRangeRecord);
    %%%%%: 2478-block 13
call    0 never executed
    #####: 2479:            strawEnd = ttUSHORT(classRangeRecord + 2);
call    0 never executed
    #####: 2480:            if (needle < strawStart)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2481:               r = m - 1;
    %%%%%: 2481-block 16
    #####: 2482:            else if (needle > strawEnd)
    %%%%%: 2482-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2483:               l = m + 1;
    %%%%%: 2483-block 18
        -: 2484:            else
    #####: 2485:               return (stbtt_int32)ttUSHORT(classRangeRecord + 4);
    %%%%%: 2485-block 19
call    0 never executed
        -: 2486:         }
    #####: 2487:         break;
    %%%%%: 2487-block 22
        -: 2488:      }
        -: 2489:
    #####: 2490:      default:
    #####: 2491:         return -1; // Unsupported definition type, return an error.
    %%%%%: 2491-block 23
        -: 2492:   }
        -: 2493:
        -: 2494:   // "All glyphs not assigned to a class fall into class 0". (OpenType spec)
    #####: 2495:   return 0;
    %%%%%: 2495-block 24
        -: 2496:}
        -: 2497:
        -: 2498:// Define to STBTT_assert(x) if you want to break on unimplemented formats.
        -: 2499:#define STBTT_GPOS_TODO_assert(x)
        -: 2500:
function _ZL30stbtt__GetGlyphGPOSInfoAdvancePK14stbtt_fontinfoii called 0 returned 0% blocks executed 0%
    #####: 2501:static stbtt_int32 stbtt__GetGlyphGPOSInfoAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)
        -: 2502:{
        -: 2503:   stbtt_uint16 lookupListOffset;
        -: 2504:   stbtt_uint8 *lookupList;
        -: 2505:   stbtt_uint16 lookupCount;
        -: 2506:   stbtt_uint8 *data;
        -: 2507:   stbtt_int32 i, sti;
        -: 2508:
    #####: 2509:   if (!info->gpos) return 0;
    %%%%%: 2509-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2509-block 3
        -: 2510:
    #####: 2511:   data = info->data + info->gpos;
        -: 2512:
    #####: 2513:   if (ttUSHORT(data+0) != 1) return 0; // Major version 1
    %%%%%: 2513-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 2513-block 6
    #####: 2514:   if (ttUSHORT(data+2) != 0) return 0; // Minor version 0
    %%%%%: 2514-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 2514-block 9
        -: 2515:
    #####: 2516:   lookupListOffset = ttUSHORT(data+8);
    %%%%%: 2516-block 10
call    0 never executed
    #####: 2517:   lookupList = data + lookupListOffset;
    #####: 2518:   lookupCount = ttUSHORT(lookupList);
call    0 never executed
        -: 2519:
    #####: 2520:   for (i=0; i<lookupCount; ++i) {
    %%%%%: 2520-block 69
    %%%%%: 2520-block 70
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2521:      stbtt_uint16 lookupOffset = ttUSHORT(lookupList + 2 + 2 * i);
    %%%%%: 2521-block 13
call    0 never executed
    #####: 2522:      stbtt_uint8 *lookupTable = lookupList + lookupOffset;
        -: 2523:
    #####: 2524:      stbtt_uint16 lookupType = ttUSHORT(lookupTable);
call    0 never executed
    #####: 2525:      stbtt_uint16 subTableCount = ttUSHORT(lookupTable + 4);
call    0 never executed
    #####: 2526:      stbtt_uint8 *subTableOffsets = lookupTable + 6;
    #####: 2527:      if (lookupType != 2) // Pair Adjustment Positioning Subtable
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2528:         continue;
    %%%%%: 2528-block 17
        -: 2529:
    #####: 2530:      for (sti=0; sti<subTableCount; sti++) {
    %%%%%: 2530-block 18
    %%%%%: 2530-block 67
    %%%%%: 2530-block 68
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2531:         stbtt_uint16 subtableOffset = ttUSHORT(subTableOffsets + 2 * sti);
    %%%%%: 2531-block 19
call    0 never executed
    #####: 2532:         stbtt_uint8 *table = lookupTable + subtableOffset;
    #####: 2533:         stbtt_uint16 posFormat = ttUSHORT(table);
call    0 never executed
    #####: 2534:         stbtt_uint16 coverageOffset = ttUSHORT(table + 2);
call    0 never executed
    #####: 2535:         stbtt_int32 coverageIndex = stbtt__GetCoverageIndex(table + coverageOffset, glyph1);
call    0 never executed
    #####: 2536:         if (coverageIndex == -1) continue;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2536-block 24
        -: 2537:
    #####: 2538:         switch (posFormat) {
    %%%%%: 2538-block 25
branch  0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2539:            case 1: {
        -: 2540:               stbtt_int32 l, r, m;
        -: 2541:               int straw, needle;
    #####: 2542:               stbtt_uint16 valueFormat1 = ttUSHORT(table + 4);
    %%%%%: 2542-block 26
call    0 never executed
    #####: 2543:               stbtt_uint16 valueFormat2 = ttUSHORT(table + 6);
call    0 never executed
    #####: 2544:               if (valueFormat1 == 4 && valueFormat2 == 0) { // Support more formats?
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2544-block 29
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2545:                  stbtt_int32 valueRecordPairSizeInBytes = 2;
    #####: 2546:                  stbtt_uint16 pairSetCount = ttUSHORT(table + 8);
    %%%%%: 2546-block 30
call    0 never executed
    #####: 2547:                  stbtt_uint16 pairPosOffset = ttUSHORT(table + 10 + 2 * coverageIndex);
call    0 never executed
    #####: 2548:                  stbtt_uint8 *pairValueTable = table + pairPosOffset;
    #####: 2549:                  stbtt_uint16 pairValueCount = ttUSHORT(pairValueTable);
call    0 never executed
    #####: 2550:                  stbtt_uint8 *pairValueArray = pairValueTable + 2;
        -: 2551:
    #####: 2552:                  if (coverageIndex >= pairSetCount) return 0;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2552-block 34
        -: 2553:
    #####: 2554:                  needle=glyph2;
    #####: 2555:                  r=pairValueCount-1;
    #####: 2556:                  l=0;
        -: 2557:
        -: 2558:                  // Binary search.
    #####: 2559:                  while (l <= r) {
    %%%%%: 2559-block 35
    %%%%%: 2559-block 43
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 2560:                     stbtt_uint16 secondGlyph;
        -: 2561:                     stbtt_uint8 *pairValue;
    #####: 2562:                     m = (l + r) >> 1;
    #####: 2563:                     pairValue = pairValueArray + (2 + valueRecordPairSizeInBytes) * m;
    #####: 2564:                     secondGlyph = ttUSHORT(pairValue);
    %%%%%: 2564-block 36
call    0 never executed
    #####: 2565:                     straw = secondGlyph;
    #####: 2566:                     if (needle < straw)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2567:                        r = m - 1;
    %%%%%: 2567-block 38
    #####: 2568:                     else if (needle > straw)
    %%%%%: 2568-block 39
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2569:                        l = m + 1;
    %%%%%: 2569-block 40
        -: 2570:                     else {
    #####: 2571:                        stbtt_int16 xAdvance = ttSHORT(pairValue + 2);
    %%%%%: 2571-block 41
call    0 never executed
    #####: 2572:                        return xAdvance;
        -: 2573:                     }
        -: 2574:                  }
    #####: 2575:               } else
    %%%%%: 2575-block 44
    #####: 2576:                  return 0;
    %%%%%: 2576-block 45
    #####: 2577:               break;
    %%%%%: 2577-block 46
        -: 2578:            }
        -: 2579:
    #####: 2580:            case 2: {
    #####: 2581:               stbtt_uint16 valueFormat1 = ttUSHORT(table + 4);
    %%%%%: 2581-block 47
call    0 never executed
    #####: 2582:               stbtt_uint16 valueFormat2 = ttUSHORT(table + 6);
call    0 never executed
    #####: 2583:               if (valueFormat1 == 4 && valueFormat2 == 0) { // Support more formats?
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2583-block 50
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2584:                  stbtt_uint16 classDef1Offset = ttUSHORT(table + 8);
    %%%%%: 2584-block 51
call    0 never executed
    #####: 2585:                  stbtt_uint16 classDef2Offset = ttUSHORT(table + 10);
call    0 never executed
    #####: 2586:                  int glyph1class = stbtt__GetGlyphClass(table + classDef1Offset, glyph1);
call    0 never executed
    #####: 2587:                  int glyph2class = stbtt__GetGlyphClass(table + classDef2Offset, glyph2);
call    0 never executed
        -: 2588:
    #####: 2589:                  stbtt_uint16 class1Count = ttUSHORT(table + 12);
call    0 never executed
    #####: 2590:                  stbtt_uint16 class2Count = ttUSHORT(table + 14);
call    0 never executed
        -: 2591:                  stbtt_uint8 *class1Records, *class2Records;
        -: 2592:                  stbtt_int16 xAdvance;
        -: 2593:
    #####: 2594:                  if (glyph1class < 0 || glyph1class >= class1Count) return 0; // malformed
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2594-block 58
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2594-block 59
    #####: 2595:                  if (glyph2class < 0 || glyph2class >= class2Count) return 0; // malformed
    %%%%%: 2595-block 60
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2595-block 61
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2595-block 62
        -: 2596:
    #####: 2597:                  class1Records = table + 16;
    #####: 2598:                  class2Records = class1Records + 2 * (glyph1class * class2Count);
    #####: 2599:                  xAdvance = ttSHORT(class2Records + 2 * glyph2class);
    %%%%%: 2599-block 63
call    0 never executed
    #####: 2600:                  return xAdvance;
        -: 2601:               } else
    #####: 2602:                  return 0;
    %%%%%: 2602-block 65
        -: 2603:               break;
        -: 2604:            }
        -: 2605:
    #####: 2606:            default:
    #####: 2607:               return 0; // Unsupported position format
    %%%%%: 2607-block 66
        -: 2608:         }
        -: 2609:      }
        -: 2610:   }
        -: 2611:
    #####: 2612:   return 0;
    %%%%%: 2612-block 71
        -: 2613:}
        -: 2614:
function stbtt_GetGlyphKernAdvance called 0 returned 0% blocks executed 0%
    #####: 2615:STBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int g1, int g2)
        -: 2616:{
    #####: 2617:   int xAdvance = 0;
        -: 2618:
    #####: 2619:   if (info->gpos)
    %%%%%: 2619-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2620:      xAdvance += stbtt__GetGlyphGPOSInfoAdvance(info, g1, g2);
    %%%%%: 2620-block 3
call    0 never executed
    #####: 2621:   else if (info->kern)
    %%%%%: 2621-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2622:      xAdvance += stbtt__GetGlyphKernInfoAdvance(info, g1, g2);
    %%%%%: 2622-block 6
call    0 never executed
        -: 2623:
    #####: 2624:   return xAdvance;
    %%%%%: 2624-block 8
        -: 2625:}
        -: 2626:
function stbtt_GetCodepointKernAdvance called 0 returned 0% blocks executed 0%
    #####: 2627:STBTT_DEF int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2)
        -: 2628:{
    #####: 2629:   if (!info->kern && !info->gpos) // if no kerning table, don't waste time looking up both codepoint->glyphs
    %%%%%: 2629-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2629-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2630:      return 0;
    %%%%%: 2630-block 4
    #####: 2631:   return stbtt_GetGlyphKernAdvance(info, stbtt_FindGlyphIndex(info,ch1), stbtt_FindGlyphIndex(info,ch2));
    %%%%%: 2631-block 5
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2632:}
        -: 2633:
function stbtt_GetCodepointHMetrics called 0 returned 0% blocks executed 0%
    #####: 2634:STBTT_DEF void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing)
        -: 2635:{
    #####: 2636:   stbtt_GetGlyphHMetrics(info, stbtt_FindGlyphIndex(info,codepoint), advanceWidth, leftSideBearing);
    %%%%%: 2636-block 2
call    0 never executed
call    1 never executed
    #####: 2637:}
        -: 2638:
function stbtt_GetFontVMetrics called 11 returned 100% blocks executed 100%
       11: 2639:STBTT_DEF void stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap)
        -: 2640:{
       11: 2641:   if (ascent ) *ascent  = ttSHORT(info->data+info->hhea + 4);
       11: 2641-block 2
branch  0 taken 11 (fallthrough)
branch  1 taken 0
       11: 2641-block 3
call    2 returned 11
       11: 2642:   if (descent) *descent = ttSHORT(info->data+info->hhea + 6);
       11: 2642-block 5
branch  0 taken 11 (fallthrough)
branch  1 taken 0
       11: 2642-block 6
call    2 returned 11
       11: 2643:   if (lineGap) *lineGap = ttSHORT(info->data+info->hhea + 8);
       11: 2643-block 8
branch  0 taken 11 (fallthrough)
branch  1 taken 0
       11: 2643-block 9
call    2 returned 11
       11: 2644:}
        -: 2645:
function stbtt_GetFontVMetricsOS2 called 0 returned 0% blocks executed 0%
    #####: 2646:STBTT_DEF int  stbtt_GetFontVMetricsOS2(const stbtt_fontinfo *info, int *typoAscent, int *typoDescent, int *typoLineGap)
        -: 2647:{
    #####: 2648:   int tab = stbtt__find_table(info->data, info->fontstart, "OS/2");
    %%%%%: 2648-block 2
call    0 never executed
    #####: 2649:   if (!tab)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2650:      return 0;
    %%%%%: 2650-block 4
    #####: 2651:   if (typoAscent ) *typoAscent  = ttSHORT(info->data+tab + 68);
    %%%%%: 2651-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2651-block 6
call    2 never executed
    #####: 2652:   if (typoDescent) *typoDescent = ttSHORT(info->data+tab + 70);
    %%%%%: 2652-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2652-block 9
call    2 never executed
    #####: 2653:   if (typoLineGap) *typoLineGap = ttSHORT(info->data+tab + 72);
    %%%%%: 2653-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2653-block 12
call    2 never executed
    #####: 2654:   return 1;
    %%%%%: 2654-block 14
        -: 2655:}
        -: 2656:
function stbtt_GetFontBoundingBox called 0 returned 0% blocks executed 0%
    #####: 2657:STBTT_DEF void stbtt_GetFontBoundingBox(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1)
        -: 2658:{
    #####: 2659:   *x0 = ttSHORT(info->data + info->head + 36);
    %%%%%: 2659-block 2
call    0 never executed
    #####: 2660:   *y0 = ttSHORT(info->data + info->head + 38);
call    0 never executed
    #####: 2661:   *x1 = ttSHORT(info->data + info->head + 40);
call    0 never executed
    #####: 2662:   *y1 = ttSHORT(info->data + info->head + 42);
call    0 never executed
    #####: 2663:}
        -: 2664:
function stbtt_ScaleForPixelHeight called 33 returned 100% blocks executed 100%
       33: 2665:STBTT_DEF float stbtt_ScaleForPixelHeight(const stbtt_fontinfo *info, float height)
        -: 2666:{
       33: 2667:   int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);
       33: 2667-block 2
call    0 returned 33
call    1 returned 33
       33: 2668:   return (float) height / fheight;
        -: 2669:}
        -: 2670:
function stbtt_ScaleForMappingEmToPixels called 0 returned 0% blocks executed 0%
    #####: 2671:STBTT_DEF float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo *info, float pixels)
        -: 2672:{
    #####: 2673:   int unitsPerEm = ttUSHORT(info->data + info->head + 18);
    %%%%%: 2673-block 2
call    0 never executed
    #####: 2674:   return pixels / unitsPerEm;
        -: 2675:}
        -: 2676:
function stbtt_FreeShape called 0 returned 0% blocks executed 0%
    #####: 2677:STBTT_DEF void stbtt_FreeShape(const stbtt_fontinfo *info, stbtt_vertex *v)
        -: 2678:{
    #####: 2679:   STBTT_free(v, info->userdata);
    %%%%%: 2679-block 2
call    0 never executed
    #####: 2680:}
        -: 2681:
function stbtt_FindSVGDoc called 0 returned 0% blocks executed 0%
    #####: 2682:STBTT_DEF stbtt_uint8 *stbtt_FindSVGDoc(const stbtt_fontinfo *info, int gl)
        -: 2683:{
        -: 2684:   int i;
    #####: 2685:   stbtt_uint8 *data = info->data;
    #####: 2686:   stbtt_uint8 *svg_doc_list = data + stbtt__get_svg((stbtt_fontinfo *) info);
    %%%%%: 2686-block 2
call    0 never executed
        -: 2687:
    #####: 2688:   int numEntries = ttUSHORT(svg_doc_list);
call    0 never executed
    #####: 2689:   stbtt_uint8 *svg_docs = svg_doc_list + 2;
        -: 2690:
    #####: 2691:   for(i=0; i<numEntries; i++) {
    %%%%%: 2691-block 13
    %%%%%: 2691-block 14
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2692:      stbtt_uint8 *svg_doc = svg_docs + (12 * i);
    #####: 2693:      if ((gl >= ttUSHORT(svg_doc)) && (gl <= ttUSHORT(svg_doc + 2)))
    %%%%%: 2693-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 2693-block 7
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 2693-block 9
    %%%%%: 2693-block 10
    %%%%%: 2693-block 11
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 2694:         return svg_doc;
    %%%%%: 2694-block 12
        -: 2695:   }
    #####: 2696:   return 0;
    %%%%%: 2696-block 15
        -: 2697:}
        -: 2698:
function stbtt_GetGlyphSVG called 0 returned 0% blocks executed 0%
    #####: 2699:STBTT_DEF int stbtt_GetGlyphSVG(const stbtt_fontinfo *info, int gl, const char **svg)
        -: 2700:{
    #####: 2701:   stbtt_uint8 *data = info->data;
        -: 2702:   stbtt_uint8 *svg_doc;
        -: 2703:
    #####: 2704:   if (info->svg == 0)
    %%%%%: 2704-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2705:      return 0;
    %%%%%: 2705-block 3
        -: 2706:
    #####: 2707:   svg_doc = stbtt_FindSVGDoc(info, gl);
    %%%%%: 2707-block 4
call    0 never executed
    #####: 2708:   if (svg_doc != NULL) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2709:      *svg = (char *) data + info->svg + ttULONG(svg_doc + 4);
    %%%%%: 2709-block 6
call    0 never executed
    #####: 2710:      return ttULONG(svg_doc + 8);
call    0 never executed
        -: 2711:   } else {
    #####: 2712:      return 0;
    %%%%%: 2712-block 9
        -: 2713:   }
        -: 2714:}
        -: 2715:
function stbtt_GetCodepointSVG called 0 returned 0% blocks executed 0%
    #####: 2716:STBTT_DEF int stbtt_GetCodepointSVG(const stbtt_fontinfo *info, int unicode_codepoint, const char **svg)
        -: 2717:{
    #####: 2718:   return stbtt_GetGlyphSVG(info, stbtt_FindGlyphIndex(info, unicode_codepoint), svg);
    %%%%%: 2718-block 2
call    0 never executed
call    1 never executed
        -: 2719:}
        -: 2720:
        -: 2721://////////////////////////////////////////////////////////////////////////////
        -: 2722://
        -: 2723:// antialiasing software rasterizer
        -: 2724://
        -: 2725:
function stbtt_GetGlyphBitmapBoxSubpixel called 7140 returned 100% blocks executed 100%
     7140: 2726:STBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)
        -: 2727:{
     7140: 2728:   int x0=0,y0=0,x1,y1; // =0 suppresses compiler warning
     7140: 2729:   if (!stbtt_GetGlyphBox(font, glyph, &x0,&y0,&x1,&y1)) {
     7140: 2729-block 2
call    0 returned 7140
branch  1 taken 7140 (fallthrough)
branch  2 taken 0 (throw)
     7140: 2729-block 3
branch  3 taken 66 (fallthrough)
branch  4 taken 7074
        -: 2730:      // e.g. space character
       66: 2731:      if (ix0) *ix0 = 0;
       66: 2731-block 4
branch  0 taken 66 (fallthrough)
branch  1 taken 0
       66: 2731-block 5
       66: 2732:      if (iy0) *iy0 = 0;
       66: 2732-block 6
branch  0 taken 66 (fallthrough)
branch  1 taken 0
       66: 2732-block 7
       66: 2733:      if (ix1) *ix1 = 0;
       66: 2733-block 8
branch  0 taken 44 (fallthrough)
branch  1 taken 22
       44: 2733-block 9
       66: 2734:      if (iy1) *iy1 = 0;
       66: 2734-block 10
branch  0 taken 44 (fallthrough)
branch  1 taken 22
       44: 2734-block 11
        -: 2735:   } else {
        -: 2736:      // move to integral bboxes (treating pixels as little squares, what pixels get touched)?
     7074: 2737:      if (ix0) *ix0 = STBTT_ifloor( x0 * scale_x + shift_x);
     7074: 2737-block 12
branch  0 taken 7074 (fallthrough)
branch  1 taken 0
     7074: 2737-block 13
call    2 returned 7074
     7074: 2738:      if (iy0) *iy0 = STBTT_ifloor(-y1 * scale_y + shift_y);
     7074: 2738-block 15
branch  0 taken 7074 (fallthrough)
branch  1 taken 0
     7074: 2738-block 16
call    2 returned 7074
     7074: 2739:      if (ix1) *ix1 = STBTT_iceil ( x1 * scale_x + shift_x);
     7074: 2739-block 18
branch  0 taken 4716 (fallthrough)
branch  1 taken 2358
     4716: 2739-block 19
     7074: 2740:      if (iy1) *iy1 = STBTT_iceil (-y0 * scale_y + shift_y);
     7074: 2740-block 20
branch  0 taken 4716 (fallthrough)
branch  1 taken 2358
     4716: 2740-block 21
        -: 2741:   }
     7140: 2742:}
     7140: 2742-block 22
        -: 2743:
function stbtt_GetGlyphBitmapBox called 2380 returned 100% blocks executed 100%
     2380: 2744:STBTT_DEF void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)
        -: 2745:{
     2380: 2746:   stbtt_GetGlyphBitmapBoxSubpixel(font, glyph, scale_x, scale_y,0.0f,0.0f, ix0, iy0, ix1, iy1);
     2380: 2746-block 2
call    0 returned 2380
     2380: 2747:}
        -: 2748:
function stbtt_GetCodepointBitmapBoxSubpixel called 0 returned 0% blocks executed 0%
    #####: 2749:STBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)
        -: 2750:{
    #####: 2751:   stbtt_GetGlyphBitmapBoxSubpixel(font, stbtt_FindGlyphIndex(font,codepoint), scale_x, scale_y,shift_x,shift_y, ix0,iy0,ix1,iy1);
    %%%%%: 2751-block 2
call    0 never executed
call    1 never executed
    #####: 2752:}
        -: 2753:
function stbtt_GetCodepointBitmapBox called 0 returned 0% blocks executed 0%
    #####: 2754:STBTT_DEF void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)
        -: 2755:{
    #####: 2756:   stbtt_GetCodepointBitmapBoxSubpixel(font, codepoint, scale_x, scale_y,0.0f,0.0f, ix0,iy0,ix1,iy1);
    %%%%%: 2756-block 2
call    0 never executed
    #####: 2757:}
        -: 2758:
        -: 2759://////////////////////////////////////////////////////////////////////////////
        -: 2760://
        -: 2761://  Rasterizer
        -: 2762:
        -: 2763:typedef struct stbtt__hheap_chunk
        -: 2764:{
        -: 2765:   struct stbtt__hheap_chunk *next;
        -: 2766:} stbtt__hheap_chunk;
        -: 2767:
        -: 2768:typedef struct stbtt__hheap
        -: 2769:{
        -: 2770:   struct stbtt__hheap_chunk *head;
        -: 2771:   void   *first_free;
        -: 2772:   int    num_remaining_in_head_chunk;
        -: 2773:} stbtt__hheap;
        -: 2774:
function _ZL18stbtt__hheap_allocP12stbtt__hheapmPv called 53634 returned 100% blocks executed 80%
    53634: 2775:static void *stbtt__hheap_alloc(stbtt__hheap *hh, size_t size, void *userdata)
        -: 2776:{
    53634: 2777:   if (hh->first_free) {
    53634: 2777-block 2
branch  0 taken 33556 (fallthrough)
branch  1 taken 20078
    33556: 2778:      void *p = hh->first_free;
    33556: 2779:      hh->first_free = * (void **) p;
    33556: 2780:      return p;
    33556: 2780-block 3
        -: 2781:   } else {
    20078: 2782:      if (hh->num_remaining_in_head_chunk == 0) {
    20078: 2782-block 4
branch  0 taken 2358 (fallthrough)
branch  1 taken 17720
    2358*: 2783:         int count = (size < 32 ? 2000 : size < 128 ? 800 : 100);
     2358: 2783-block 5
branch  0 taken 2358 (fallthrough)
branch  1 taken 0
     2358: 2783-block 6
branch  2 taken 2358 (fallthrough)
branch  3 taken 0
     2358: 2783-block 7
    %%%%%: 2783-block 8
     2358: 2783-block 9
    %%%%%: 2783-block 10
     2358: 2784:         stbtt__hheap_chunk *c = (stbtt__hheap_chunk *) STBTT_malloc(sizeof(stbtt__hheap_chunk) + size * count, userdata);
     2358: 2784-block 11
call    0 returned 2358
     2358: 2785:         if (c == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 2358
    #####: 2786:            return NULL;
    %%%%%: 2786-block 13
     2358: 2787:         c->next = hh->head;
     2358: 2788:         hh->head = c;
     2358: 2789:         hh->num_remaining_in_head_chunk = count;
     2358: 2789-block 14
        -: 2790:      }
    20078: 2791:      --hh->num_remaining_in_head_chunk;
    20078: 2792:      return (char *) (hh->head) + sizeof(stbtt__hheap_chunk) + size * hh->num_remaining_in_head_chunk;
    20078: 2792-block 15
        -: 2793:   }
        -: 2794:}
        -: 2795:
function _ZL17stbtt__hheap_freeP12stbtt__hheapPv called 47026 returned 100% blocks executed 100%
    47026: 2796:static void stbtt__hheap_free(stbtt__hheap *hh, void *p)
        -: 2797:{
    47026: 2798:   *(void **) p = hh->first_free;
    47026: 2799:   hh->first_free = p;
    47026: 2800:}
        -: 2801:
function _ZL20stbtt__hheap_cleanupP12stbtt__hheapPv called 2358 returned 100% blocks executed 100%
     2358: 2802:static void stbtt__hheap_cleanup(stbtt__hheap *hh, void *userdata)
        -: 2803:{
     2358: 2804:   stbtt__hheap_chunk *c = hh->head;
     4716: 2805:   while (c) {
     2358: 2805-block 2
     4716: 2805-block 5
branch  0 taken 2358
branch  1 taken 2358 (fallthrough)
     2358: 2806:      stbtt__hheap_chunk *n = c->next;
     2358: 2807:      STBTT_free(c, userdata);
     2358: 2807-block 3
call    0 returned 2358
     2358: 2808:      c = n;
        -: 2809:   }
     2358: 2810:}
        -: 2811:
        -: 2812:typedef struct stbtt__edge {
        -: 2813:   float x0,y0, x1,y1;
        -: 2814:   int invert;
        -: 2815:} stbtt__edge;
        -: 2816:
        -: 2817:
        -: 2818:typedef struct stbtt__active_edge
        -: 2819:{
        -: 2820:   struct stbtt__active_edge *next;
        -: 2821:   #if STBTT_RASTERIZER_VERSION==1
        -: 2822:   int x,dx;
        -: 2823:   float ey;
        -: 2824:   int direction;
        -: 2825:   #elif STBTT_RASTERIZER_VERSION==2
        -: 2826:   float fx,fdx,fdy;
        -: 2827:   float direction;
        -: 2828:   float sy;
        -: 2829:   float ey;
        -: 2830:   #else
        -: 2831:   #error "Unrecognized value of STBTT_RASTERIZER_VERSION"
        -: 2832:   #endif
        -: 2833:} stbtt__active_edge;
        -: 2834:
        -: 2835:#if STBTT_RASTERIZER_VERSION == 1
        -: 2836:#define STBTT_FIXSHIFT   10
        -: 2837:#define STBTT_FIX        (1 << STBTT_FIXSHIFT)
        -: 2838:#define STBTT_FIXMASK    (STBTT_FIX-1)
        -: 2839:
        -: 2840:static stbtt__active_edge *stbtt__new_active(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)
        -: 2841:{
        -: 2842:   stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);
        -: 2843:   float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);
        -: 2844:   STBTT_assert(z != NULL);
        -: 2845:   if (!z) return z;
        -: 2846:
        -: 2847:   // round dx down to avoid overshooting
        -: 2848:   if (dxdy < 0)
        -: 2849:      z->dx = -STBTT_ifloor(STBTT_FIX * -dxdy);
        -: 2850:   else
        -: 2851:      z->dx = STBTT_ifloor(STBTT_FIX * dxdy);
        -: 2852:
        -: 2853:   z->x = STBTT_ifloor(STBTT_FIX * e->x0 + z->dx * (start_point - e->y0)); // use z->dx so when we offset later it's by the same amount
        -: 2854:   z->x -= off_x * STBTT_FIX;
        -: 2855:
        -: 2856:   z->ey = e->y1;
        -: 2857:   z->next = 0;
        -: 2858:   z->direction = e->invert ? 1 : -1;
        -: 2859:   return z;
        -: 2860:}
        -: 2861:#elif STBTT_RASTERIZER_VERSION == 2
function _ZL17stbtt__new_activeP12stbtt__hheapP11stbtt__edgeifPv called 53634 returned 100% blocks executed 85%
    53634: 2862:static stbtt__active_edge *stbtt__new_active(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)
        -: 2863:{
    53634: 2864:   stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);
    53634: 2864-block 2
call    0 returned 53634
    53634: 2865:   float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);
   53634*: 2866:   STBTT_assert(z != NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 53634
    %%%%%: 2866-block 4
call    2 never executed
        -: 2867:   //STBTT_assert(e->y0 <= start_point);
   53634*: 2868:   if (!z) return z;
    53634: 2868-block 5
branch  0 taken 0 (fallthrough)
branch  1 taken 53634
    %%%%%: 2868-block 6
    53634: 2869:   z->fdx = dxdy;
    53634: 2870:   z->fdy = dxdy != 0.0f ? (1.0f/dxdy) : 0.0f;
    53634: 2870-block 7
branch  0 taken 39621 (fallthrough)
branch  1 taken 14013
    39621: 2870-block 8
    14013: 2870-block 9
    53634: 2871:   z->fx = e->x0 + dxdy * (start_point - e->y0);
    53634: 2872:   z->fx -= off_x;
    53634: 2873:   z->direction = e->invert ? 1.0f : -1.0f;
    53634: 2873-block 10
branch  0 taken 26777 (fallthrough)
branch  1 taken 26857
    26777: 2873-block 11
    26857: 2873-block 12
    53634: 2874:   z->sy = e->y0;
    53634: 2875:   z->ey = e->y1;
    53634: 2876:   z->next = 0;
    53634: 2877:   return z;
    53634: 2877-block 13
        -: 2878:}
        -: 2879:#else
        -: 2880:#error "Unrecognized value of STBTT_RASTERIZER_VERSION"
        -: 2881:#endif
        -: 2882:
        -: 2883:#if STBTT_RASTERIZER_VERSION == 1
        -: 2884:// note: this routine clips fills that extend off the edges... ideally this
        -: 2885:// wouldn't happen, but it could happen if the truetype glyph bounding boxes
        -: 2886:// are wrong, or if the user supplies a too-small bitmap
        -: 2887:static void stbtt__fill_active_edges(unsigned char *scanline, int len, stbtt__active_edge *e, int max_weight)
        -: 2888:{
        -: 2889:   // non-zero winding fill
        -: 2890:   int x0=0, w=0;
        -: 2891:
        -: 2892:   while (e) {
        -: 2893:      if (w == 0) {
        -: 2894:         // if we're currently at zero, we need to record the edge start point
        -: 2895:         x0 = e->x; w += e->direction;
        -: 2896:      } else {
        -: 2897:         int x1 = e->x; w += e->direction;
        -: 2898:         // if we went to zero, we need to draw
        -: 2899:         if (w == 0) {
        -: 2900:            int i = x0 >> STBTT_FIXSHIFT;
        -: 2901:            int j = x1 >> STBTT_FIXSHIFT;
        -: 2902:
        -: 2903:            if (i < len && j >= 0) {
        -: 2904:               if (i == j) {
        -: 2905:                  // x0,x1 are the same pixel, so compute combined coverage
        -: 2906:                  scanline[i] = scanline[i] + (stbtt_uint8) ((x1 - x0) * max_weight >> STBTT_FIXSHIFT);
        -: 2907:               } else {
        -: 2908:                  if (i >= 0) // add antialiasing for x0
        -: 2909:                     scanline[i] = scanline[i] + (stbtt_uint8) (((STBTT_FIX - (x0 & STBTT_FIXMASK)) * max_weight) >> STBTT_FIXSHIFT);
        -: 2910:                  else
        -: 2911:                     i = -1; // clip
        -: 2912:
        -: 2913:                  if (j < len) // add antialiasing for x1
        -: 2914:                     scanline[j] = scanline[j] + (stbtt_uint8) (((x1 & STBTT_FIXMASK) * max_weight) >> STBTT_FIXSHIFT);
        -: 2915:                  else
        -: 2916:                     j = len; // clip
        -: 2917:
        -: 2918:                  for (++i; i < j; ++i) // fill pixels between x0 and x1
        -: 2919:                     scanline[i] = scanline[i] + (stbtt_uint8) max_weight;
        -: 2920:               }
        -: 2921:            }
        -: 2922:         }
        -: 2923:      }
        -: 2924:
        -: 2925:      e = e->next;
        -: 2926:   }
        -: 2927:}
        -: 2928:
        -: 2929:static void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)
        -: 2930:{
        -: 2931:   stbtt__hheap hh = { 0, 0, 0 };
        -: 2932:   stbtt__active_edge *active = NULL;
        -: 2933:   int y,j=0;
        -: 2934:   int max_weight = (255 / vsubsample);  // weight per vertical scanline
        -: 2935:   int s; // vertical subsample index
        -: 2936:   unsigned char scanline_data[512], *scanline;
        -: 2937:
        -: 2938:   if (result->w > 512)
        -: 2939:      scanline = (unsigned char *) STBTT_malloc(result->w, userdata);
        -: 2940:   else
        -: 2941:      scanline = scanline_data;
        -: 2942:
        -: 2943:   y = off_y * vsubsample;
        -: 2944:   e[n].y0 = (off_y + result->h) * (float) vsubsample + 1;
        -: 2945:
        -: 2946:   while (j < result->h) {
        -: 2947:      STBTT_memset(scanline, 0, result->w);
        -: 2948:      for (s=0; s < vsubsample; ++s) {
        -: 2949:         // find center of pixel for this scanline
        -: 2950:         float scan_y = y + 0.5f;
        -: 2951:         stbtt__active_edge **step = &active;
        -: 2952:
        -: 2953:         // update all active edges;
        -: 2954:         // remove all active edges that terminate before the center of this scanline
        -: 2955:         while (*step) {
        -: 2956:            stbtt__active_edge * z = *step;
        -: 2957:            if (z->ey <= scan_y) {
        -: 2958:               *step = z->next; // delete from list
        -: 2959:               STBTT_assert(z->direction);
        -: 2960:               z->direction = 0;
        -: 2961:               stbtt__hheap_free(&hh, z);
        -: 2962:            } else {
        -: 2963:               z->x += z->dx; // advance to position for current scanline
        -: 2964:               step = &((*step)->next); // advance through list
        -: 2965:            }
        -: 2966:         }
        -: 2967:
        -: 2968:         // resort the list if needed
        -: 2969:         for(;;) {
        -: 2970:            int changed=0;
        -: 2971:            step = &active;
        -: 2972:            while (*step && (*step)->next) {
        -: 2973:               if ((*step)->x > (*step)->next->x) {
        -: 2974:                  stbtt__active_edge *t = *step;
        -: 2975:                  stbtt__active_edge *q = t->next;
        -: 2976:
        -: 2977:                  t->next = q->next;
        -: 2978:                  q->next = t;
        -: 2979:                  *step = q;
        -: 2980:                  changed = 1;
        -: 2981:               }
        -: 2982:               step = &(*step)->next;
        -: 2983:            }
        -: 2984:            if (!changed) break;
        -: 2985:         }
        -: 2986:
        -: 2987:         // insert all edges that start before the center of this scanline -- omit ones that also end on this scanline
        -: 2988:         while (e->y0 <= scan_y) {
        -: 2989:            if (e->y1 > scan_y) {
        -: 2990:               stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y, userdata);
        -: 2991:               if (z != NULL) {
        -: 2992:                  // find insertion point
        -: 2993:                  if (active == NULL)
        -: 2994:                     active = z;
        -: 2995:                  else if (z->x < active->x) {
        -: 2996:                     // insert at front
        -: 2997:                     z->next = active;
        -: 2998:                     active = z;
        -: 2999:                  } else {
        -: 3000:                     // find thing to insert AFTER
        -: 3001:                     stbtt__active_edge *p = active;
        -: 3002:                     while (p->next && p->next->x < z->x)
        -: 3003:                        p = p->next;
        -: 3004:                     // at this point, p->next->x is NOT < z->x
        -: 3005:                     z->next = p->next;
        -: 3006:                     p->next = z;
        -: 3007:                  }
        -: 3008:               }
        -: 3009:            }
        -: 3010:            ++e;
        -: 3011:         }
        -: 3012:
        -: 3013:         // now process all active edges in XOR fashion
        -: 3014:         if (active)
        -: 3015:            stbtt__fill_active_edges(scanline, result->w, active, max_weight);
        -: 3016:
        -: 3017:         ++y;
        -: 3018:      }
        -: 3019:      STBTT_memcpy(result->pixels + j * result->stride, scanline, result->w);
        -: 3020:      ++j;
        -: 3021:   }
        -: 3022:
        -: 3023:   stbtt__hheap_cleanup(&hh, userdata);
        -: 3024:
        -: 3025:   if (scanline != scanline_data)
        -: 3026:      STBTT_free(scanline, userdata);
        -: 3027:}
        -: 3028:
        -: 3029:#elif STBTT_RASTERIZER_VERSION == 2
        -: 3030:
        -: 3031:// the edge passed in here does not cross the vertical line at x or the vertical line at x+1
        -: 3032:// (i.e. it has already been clipped to those)
function _ZL26stbtt__handle_clipped_edgePfiP18stbtt__active_edgeffff called 92991 returned 100% blocks executed 80%
    92991: 3033:static void stbtt__handle_clipped_edge(float *scanline, int x, stbtt__active_edge *e, float x0, float y0, float x1, float y1)
        -: 3034:{
   92991*: 3035:   if (y0 == y1) return;
    92991: 3035-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 92991
    %%%%%: 3035-block 3
   92991*: 3036:   STBTT_assert(y0 < y1);
    92991: 3036-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 92991
    %%%%%: 3036-block 5
call    2 never executed
   92991*: 3037:   STBTT_assert(e->sy <= e->ey);
    92991: 3037-block 6
branch  0 taken 0 (fallthrough)
branch  1 taken 92991
    %%%%%: 3037-block 7
call    2 never executed
    92991: 3038:   if (y0 > e->ey) return;
    92991: 3038-block 8
branch  0 taken 6 (fallthrough)
branch  1 taken 92985
        6: 3038-block 9
    92985: 3039:   if (y1 < e->sy) return;
    92985: 3039-block 10
branch  0 taken 3 (fallthrough)
branch  1 taken 92982
        3: 3039-block 11
    92982: 3040:   if (y0 < e->sy) {
    92982: 3040-block 12
branch  0 taken 25289 (fallthrough)
branch  1 taken 67693
    25289: 3041:      x0 += (x1-x0) * (e->sy - y0) / (y1-y0);
    25289: 3042:      y0 = e->sy;
    25289: 3042-block 13
        -: 3043:   }
    92982: 3044:   if (y1 > e->ey) {
    92982: 3044-block 14
branch  0 taken 13159 (fallthrough)
branch  1 taken 79823
    13159: 3045:      x1 += (x1-x0) * (e->ey - y1) / (y1-y0);
    13159: 3046:      y1 = e->ey;
    13159: 3046-block 15
        -: 3047:   }
        -: 3048:
    92982: 3049:   if (x0 == x)
    92982: 3049-block 16
branch  0 taken 12205 (fallthrough)
branch  1 taken 80777
   12205*: 3050:      STBTT_assert(x1 <= x+1);
    12205: 3050-block 17
branch  0 taken 0 (fallthrough)
branch  1 taken 12205
    %%%%%: 3050-block 18
call    2 never executed
    80777: 3051:   else if (x0 == x+1)
    80777: 3051-block 19
branch  0 taken 78 (fallthrough)
branch  1 taken 80699
      78*: 3052:      STBTT_assert(x1 >= x);
       78: 3052-block 20
branch  0 taken 0 (fallthrough)
branch  1 taken 78
    %%%%%: 3052-block 21
call    2 never executed
    80699: 3053:   else if (x0 <= x)
    80699: 3053-block 22
branch  0 taken 45812 (fallthrough)
branch  1 taken 34887
   45812*: 3054:      STBTT_assert(x1 <= x);
    45812: 3054-block 23
branch  0 taken 0 (fallthrough)
branch  1 taken 45812
    %%%%%: 3054-block 24
call    2 never executed
    34887: 3055:   else if (x0 >= x+1)
    34887: 3055-block 25
branch  0 taken 1457 (fallthrough)
branch  1 taken 33430
    1457*: 3056:      STBTT_assert(x1 >= x+1);
     1457: 3056-block 26
branch  0 taken 0 (fallthrough)
branch  1 taken 1457
    %%%%%: 3056-block 27
call    2 never executed
        -: 3057:   else
   33430*: 3058:      STBTT_assert(x1 >= x && x1 <= x+1);
    33430: 3058-block 28
branch  0 taken 33430 (fallthrough)
branch  1 taken 0
    33430: 3058-block 29
branch  2 taken 33430 (fallthrough)
branch  3 taken 0
    33430: 3058-block 30
    %%%%%: 3058-block 31
call    4 never executed
        -: 3059:
    92982: 3060:   if (x0 <= x && x1 <= x)
    92982: 3060-block 32
branch  0 taken 58017 (fallthrough)
branch  1 taken 34965
    58017: 3060-block 33
branch  2 taken 58012 (fallthrough)
branch  3 taken 5
    58012: 3061:      scanline[x] += e->direction * (y1-y0);
    58012: 3061-block 34
    34970: 3062:   else if (x0 >= x+1 && x1 >= x+1)
    34970: 3062-block 35
branch  0 taken 1535 (fallthrough)
branch  1 taken 33435
     1535: 3062-block 36
branch  2 taken 1504 (fallthrough)
branch  3 taken 31
     1504: 3062-block 37
        -: 3063:      ;
        -: 3064:   else {
   33466*: 3065:      STBTT_assert(x0 >= x && x0 <= x+1 && x1 >= x && x1 <= x+1);
    33466: 3065-block 38
branch  0 taken 33466 (fallthrough)
branch  1 taken 0
    33466: 3065-block 39
branch  2 taken 33466 (fallthrough)
branch  3 taken 0
    33466: 3065-block 40
branch  4 taken 33466 (fallthrough)
branch  5 taken 0
    33466: 3065-block 41
branch  6 taken 33466 (fallthrough)
branch  7 taken 0
    33466: 3065-block 42
    %%%%%: 3065-block 43
call    8 never executed
    33466: 3066:      scanline[x] += e->direction * (y1-y0) * (1-((x0-x)+(x1-x))/2); // coverage = 1 - average x position
    33466: 3066-block 44
        -: 3067:   }
        -: 3068:}
        -: 3069:
function _ZL27stbtt__sized_trapezoid_areafff called 86815 returned 100% blocks executed 67%
    86815: 3070:static float stbtt__sized_trapezoid_area(float height, float top_width, float bottom_width)
        -: 3071:{
   86815*: 3072:   STBTT_assert(top_width >= 0);
    86815: 3072-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 86815
    %%%%%: 3072-block 3
call    2 never executed
   86815*: 3073:   STBTT_assert(bottom_width >= 0);
    86815: 3073-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 86815
    %%%%%: 3073-block 5
call    2 never executed
    86815: 3074:   return (top_width + bottom_width) / 2.0f * height;
    86815: 3074-block 6
        -: 3075:}
        -: 3076:
function _ZL30stbtt__position_trapezoid_areafffff called 86815 returned 100% blocks executed 100%
    86815: 3077:static float stbtt__position_trapezoid_area(float height, float tx0, float tx1, float bx0, float bx1)
        -: 3078:{
    86815: 3079:   return stbtt__sized_trapezoid_area(height, tx1 - tx0, bx1 - bx0);
    86815: 3079-block 2
call    0 returned 86815
        -: 3080:}
        -: 3081:
function _ZL26stbtt__sized_triangle_areaff called 53409 returned 100% blocks executed 100%
    53409: 3082:static float stbtt__sized_triangle_area(float height, float width)
        -: 3083:{
    53409: 3084:   return height * width / 2;
    53409: 3084-block 2
        -: 3085:}
        -: 3086:
function _ZL28stbtt__fill_active_edges_newPfS_iP18stbtt__active_edgef called 26077 returned 100% blocks executed 91%
    26077: 3087:static void stbtt__fill_active_edges_new(float *scanline, float *scanline_fill, int len, stbtt__active_edge *e, float y_top)
        -: 3088:{
    26077: 3089:   float y_bottom = y_top+1;
        -: 3090:
   160105: 3091:   while (e) {
    26077: 3091-block 2
   160105: 3091-block 85
branch  0 taken 134028
branch  1 taken 26077 (fallthrough)
        -: 3092:      // brute force every pixel
        -: 3093:
        -: 3094:      // compute intersection points with top & bottom
  134028*: 3095:      STBTT_assert(e->ey >= y_top);
   134028: 3095-block 3
branch  0 taken 0 (fallthrough)
branch  1 taken 134028
    %%%%%: 3095-block 4
call    2 never executed
        -: 3096:
   134028: 3097:      if (e->fdx == 0) {
   134028: 3097-block 5
branch  0 taken 47139 (fallthrough)
branch  1 taken 86889
    47139: 3098:         float x0 = e->fx;
    47139: 3099:         if (x0 < len) {
    47139: 3099-block 6
branch  0 taken 45561 (fallthrough)
branch  1 taken 1578
    45561: 3100:            if (x0 >= 0) {
    45561: 3100-block 7
branch  0 taken 45561 (fallthrough)
branch  1 taken 0
    45561: 3101:               stbtt__handle_clipped_edge(scanline,(int) x0,e, x0,y_top, x0,y_bottom);
    45561: 3101-block 8
call    0 returned 45561
    45561: 3102:               stbtt__handle_clipped_edge(scanline_fill-1,(int) x0+1,e, x0,y_top, x0,y_bottom);
call    0 returned 45561
        -: 3103:            } else {
    #####: 3104:               stbtt__handle_clipped_edge(scanline_fill-1,0,e, x0,y_top, x0,y_bottom);
    %%%%%: 3104-block 10
call    0 never executed
        -: 3105:            }
        -: 3106:         }
        -: 3107:      } else {
    86889: 3108:         float x0 = e->fx;
    86889: 3109:         float dx = e->fdx;
    86889: 3110:         float xb = x0 + dx;
        -: 3111:         float x_top, x_bottom;
        -: 3112:         float sy0,sy1;
    86889: 3113:         float dy = e->fdy;
   86889*: 3114:         STBTT_assert(e->sy <= y_bottom && e->ey >= y_top);
    86889: 3114-block 11
branch  0 taken 86889 (fallthrough)
branch  1 taken 0
    86889: 3114-block 12
branch  2 taken 86889 (fallthrough)
branch  3 taken 0
    86889: 3114-block 13
    %%%%%: 3114-block 14
call    4 never executed
        -: 3115:
        -: 3116:         // compute endpoints of line segment clipped to this scanline (if the
        -: 3117:         // line segment starts on this scanline. x0 is the intersection of the
        -: 3118:         // line with y_top, but that may be off the line segment.
    86889: 3119:         if (e->sy > y_top) {
    86889: 3119-block 15
branch  0 taken 39556 (fallthrough)
branch  1 taken 47333
    39556: 3120:            x_top = x0 + dx * (e->sy - y_top);
    39556: 3121:            sy0 = e->sy;
    39556: 3121-block 16
        -: 3122:         } else {
    47333: 3123:            x_top = x0;
    47333: 3124:            sy0 = y_top;
    47333: 3124-block 17
        -: 3125:         }
    86889: 3126:         if (e->ey < y_bottom) {
    86889: 3126-block 18
branch  0 taken 37734 (fallthrough)
branch  1 taken 49155
    37734: 3127:            x_bottom = x0 + dx * (e->ey - y_top);
    37734: 3128:            sy1 = e->ey;
    37734: 3128-block 19
        -: 3129:         } else {
    49155: 3130:            x_bottom = xb;
    49155: 3131:            sy1 = y_bottom;
    49155: 3131-block 20
        -: 3132:         }
        -: 3133:
    86889: 3134:         if (x_top >= 0 && x_bottom >= 0 && x_top < len && x_bottom < len) {
    86889: 3134-block 21
branch  0 taken 86889 (fallthrough)
branch  1 taken 0
    86889: 3134-block 22
branch  2 taken 86875 (fallthrough)
branch  3 taken 14
    86875: 3134-block 23
branch  4 taken 86848 (fallthrough)
branch  5 taken 27
    86848: 3134-block 24
branch  6 taken 86815 (fallthrough)
branch  7 taken 33
        -: 3135:            // from here on, we don't have to range check x values
        -: 3136:
    86815: 3137:            if ((int) x_top == (int) x_bottom) {
    86815: 3137-block 25
branch  0 taken 33406 (fallthrough)
branch  1 taken 53409
        -: 3138:               float height;
        -: 3139:               // simple case, only spans one pixel
    33406: 3140:               int x = (int) x_top;
    33406: 3141:               height = (sy1 - sy0) * e->direction;
   33406*: 3142:               STBTT_assert(x >= 0 && x < len);
    33406: 3142-block 26
branch  0 taken 33406 (fallthrough)
branch  1 taken 0
    33406: 3142-block 27
branch  2 taken 33406 (fallthrough)
branch  3 taken 0
    33406: 3142-block 28
    %%%%%: 3142-block 29
call    4 never executed
    33406: 3143:               scanline[x]      += stbtt__position_trapezoid_area(height, x_top, x+1.0f, x_bottom, x+1.0f);
    33406: 3143-block 30
call    0 returned 33406
    33406: 3144:               scanline_fill[x] += height; // everything right of this pixel is filled
        -: 3145:            } else {
        -: 3146:               int x,x1,x2;
        -: 3147:               float y_crossing, y_final, step, sign, area;
        -: 3148:               // covers 2+ pixels
    53409: 3149:               if (x_top > x_bottom) {
    53409: 3149-block 32
branch  0 taken 28220 (fallthrough)
branch  1 taken 25189
        -: 3150:                  // flip scanline vertically; signed area is the same
        -: 3151:                  float t;
    28220: 3152:                  sy0 = y_bottom - (sy0 - y_top);
    28220: 3153:                  sy1 = y_bottom - (sy1 - y_top);
    28220: 3154:                  t = sy0, sy0 = sy1, sy1 = t;
    28220: 3155:                  t = x_bottom, x_bottom = x_top, x_top = t;
    28220: 3156:                  dx = -dx;
    28220: 3157:                  dy = -dy;
    28220: 3158:                  t = x0, x0 = xb, xb = t;
    28220: 3158-block 33
        -: 3159:               }
   53409*: 3160:               STBTT_assert(dy >= 0);
    53409: 3160-block 34
branch  0 taken 0 (fallthrough)
branch  1 taken 53409
    %%%%%: 3160-block 35
call    2 never executed
   53409*: 3161:               STBTT_assert(dx >= 0);
    53409: 3161-block 36
branch  0 taken 0 (fallthrough)
branch  1 taken 53409
    %%%%%: 3161-block 37
call    2 never executed
        -: 3162:
    53409: 3163:               x1 = (int) x_top;
    53409: 3164:               x2 = (int) x_bottom;
        -: 3165:               // compute intersection with y axis at x1+1
    53409: 3166:               y_crossing = y_top + dy * (x1+1 - x0);
        -: 3167:
        -: 3168:               // compute intersection with y axis at x2
    53409: 3169:               y_final = y_top + dy * (x2 - x0);
        -: 3170:
        -: 3171:               //           x1    x_top                            x2    x_bottom
        -: 3172:               //     y_top  +------|-----+------------+------------+--------|---+------------+
        -: 3173:               //            |            |            |            |            |            |
        -: 3174:               //            |            |            |            |            |            |
        -: 3175:               //       sy0  |      Txxxxx|............|............|............|............|
        -: 3176:               // y_crossing |            *xxxxx.......|............|............|............|
        -: 3177:               //            |            |     xxxxx..|............|............|............|
        -: 3178:               //            |            |     /-   xx*xxxx........|............|............|
        -: 3179:               //            |            | dy <       |    xxxxxx..|............|............|
        -: 3180:               //   y_final  |            |     \-     |          xx*xxx.........|............|
        -: 3181:               //       sy1  |            |            |            |   xxxxxB...|............|
        -: 3182:               //            |            |            |            |            |            |
        -: 3183:               //            |            |            |            |            |            |
        -: 3184:               //  y_bottom  +------------+------------+------------+------------+------------+
        -: 3185:               //
        -: 3186:               // goal is to measure the area covered by '.' in each pixel
        -: 3187:
        -: 3188:               // if x2 is right at the right edge of x1, y_crossing can blow up, github #1057
        -: 3189:               // @TODO: maybe test against sy1 rather than y_bottom?
    53409: 3190:               if (y_crossing > y_bottom)
    53409: 3190-block 38
branch  0 taken 9 (fallthrough)
branch  1 taken 53400
        9: 3191:                  y_crossing = y_bottom;
        9: 3191-block 39
        -: 3192:
    53409: 3193:               sign = e->direction;
        -: 3194:
        -: 3195:               // area of the rectangle covered from sy0..y_crossing
    53409: 3196:               area = sign * (y_crossing-sy0);
        -: 3197:
        -: 3198:               // area of the triangle (x_top,sy0), (x1+1,sy0), (x1+1,y_crossing)
    53409: 3199:               scanline[x1] += stbtt__sized_triangle_area(area, x1+1 - x_top);
    53409: 3199-block 40
call    0 returned 53409
        -: 3200:
        -: 3201:               // check if final y_crossing is blown up; no test case for this
    53409: 3202:               if (y_final > y_bottom) {
branch  0 taken 16 (fallthrough)
branch  1 taken 53393
       16: 3203:                  int denom = (x2 - (x1+1));
       16: 3204:                  y_final = y_bottom;
       16: 3205:                  if (denom != 0) { // [DEAR IMGUI] Avoid div by zero (https://github.com/nothings/stb/issues/1316)
       16: 3205-block 42
branch  0 taken 7 (fallthrough)
branch  1 taken 9
        7: 3206:                     dy = (y_final - y_crossing ) / denom; // if denom=0, y_final = y_crossing, so y_final <= y_bottom
        7: 3206-block 43
        -: 3207:                  }
        -: 3208:               }
        -: 3209:
        -: 3210:               // in second pixel, area covered by line segment found in first pixel
        -: 3211:               // is always a rectangle 1 wide * the height of that line segment; this
        -: 3212:               // is exactly what the variable 'area' stores. it also gets a contribution
        -: 3213:               // from the line segment within it. the THIRD pixel will get the first
        -: 3214:               // pixel's rectangle contribution, the second pixel's rectangle contribution,
        -: 3215:               // and its own contribution. the 'own contribution' is the same in every pixel except
        -: 3216:               // the leftmost and rightmost, a trapezoid that slides down in each pixel.
        -: 3217:               // the second pixel's contribution to the third pixel will be the
        -: 3218:               // rectangle 1 wide times the height change in the second pixel, which is dy.
        -: 3219:
    53409: 3220:               step = sign * dy * 1; // dy is dy/dx, change in y for every 1 change in x,
        -: 3221:               // which multiplied by 1-pixel-width is how much pixel area changes for each step in x
        -: 3222:               // so the area advances by 'step' every time
        -: 3223:
    82614: 3224:               for (x = x1+1; x < x2; ++x) {
    53409: 3224-block 44
    82614: 3224-block 46
branch  0 taken 29205
branch  1 taken 53409 (fallthrough)
    29205: 3225:                  scanline[x] += area + step/2; // area of trapezoid is 1*step/2
    29205: 3226:                  area += step;
    29205: 3226-block 45
        -: 3227:               }
   53409*: 3228:               STBTT_assert(STBTT_fabs(area) <= 1.01f); // accumulated error from area += step unless we round step down
    53409: 3228-block 47
branch  0 taken 0 (fallthrough)
branch  1 taken 53409
    %%%%%: 3228-block 48
call    2 never executed
   53409*: 3229:               STBTT_assert(sy1 > y_final-0.01f);
    53409: 3229-block 49
branch  0 taken 0 (fallthrough)
branch  1 taken 53409
    %%%%%: 3229-block 50
call    2 never executed
        -: 3230:
        -: 3231:               // area covered in the last pixel is the rectangle from all the pixels to the left,
        -: 3232:               // plus the trapezoid filled by the line segment in this pixel all the way to the right edge
    53409: 3233:               scanline[x2] += area + sign * stbtt__position_trapezoid_area(sy1-y_final, (float) x2, x2+1.0f, x_bottom, x2+1.0f);
    53409: 3233-block 51
call    0 returned 53409
        -: 3234:
        -: 3235:               // the rest of the line is filled based on the total height of the line segment in this pixel
    53409: 3236:               scanline_fill[x2] += sign * (sy1-sy0);
        -: 3237:            }
    86815: 3238:         } else {
    86815: 3238-block 53
        -: 3239:            // if edge goes outside of box we're drawing, we require
        -: 3240:            // clipping logic. since this does not match the intended use
        -: 3241:            // of this library, we use a different, very slow brute
        -: 3242:            // force implementation
        -: 3243:            // note though that this does happen some of the time because
        -: 3244:            // x_top and x_bottom can be extrapolated at the top & bottom of
        -: 3245:            // the shape and actually lie outside the bounding box
        -: 3246:            int x;
     1854: 3247:            for (x=0; x < len; ++x) {
       74: 3247-block 54
     1780: 3247-block 82
     1854: 3247-block 83
branch  0 taken 1780
branch  1 taken 74 (fallthrough)
        -: 3248:               // cases:
        -: 3249:               //
        -: 3250:               // there can be up to two intersections with the pixel. any intersection
        -: 3251:               // with left or right edges can be handled by splitting into two (or three)
        -: 3252:               // regions. intersections with top & bottom do not necessitate case-wise logic.
        -: 3253:               //
        -: 3254:               // the old way of doing this found the intersections with the left & right edges,
        -: 3255:               // then used some simple logic to produce up to three segments in sorted order
        -: 3256:               // from top-to-bottom. however, this had a problem: if an x edge was epsilon
        -: 3257:               // across the x border, then the corresponding y position might not be distinct
        -: 3258:               // from the other y segment, and it might ignored as an empty segment. to avoid
        -: 3259:               // that, we need to explicitly produce segments based on x positions.
        -: 3260:
        -: 3261:               // rename variables to clearly-defined pairs
     1780: 3262:               float y0 = y_top;
     1780: 3263:               float x1 = (float) (x);
     1780: 3264:               float x2 = (float) (x+1);
     1780: 3265:               float x3 = xb;
     1780: 3266:               float y3 = y_bottom;
        -: 3267:
        -: 3268:               // x = e->x + e->dx * (y-y_top)
        -: 3269:               // (y-y_top) = (x - e->x) / e->dx
        -: 3270:               // y = (x - e->x) / e->dx + y_top
     1780: 3271:               float y1 = (x - x0) / dx + y_top;
     1780: 3272:               float y2 = (x+1 - x0) / dx + y_top;
        -: 3273:
     1780: 3274:               if (x0 < x1 && x3 > x2) {         // three segments descending down-right
     1780: 3274-block 55
branch  0 taken 251 (fallthrough)
branch  1 taken 1529
      251: 3274-block 56
branch  2 taken 4 (fallthrough)
branch  3 taken 247
        4: 3275:                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
        4: 3275-block 57
call    0 returned 4
        4: 3276:                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x2,y2);
call    0 returned 4
        4: 3277:                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
call    0 returned 4
     1776: 3278:               } else if (x3 < x1 && x0 > x2) {  // three segments descending down-left
     1776: 3278-block 60
branch  0 taken 268 (fallthrough)
branch  1 taken 1508
      268: 3278-block 61
branch  2 taken 8 (fallthrough)
branch  3 taken 260
        8: 3279:                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
        8: 3279-block 62
call    0 returned 8
        8: 3280:                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x1,y1);
call    0 returned 8
        8: 3281:                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
call    0 returned 8
     1768: 3282:               } else if (x0 < x1 && x3 > x1) {  // two segments across x, down-right
     1768: 3282-block 65
branch  0 taken 247 (fallthrough)
branch  1 taken 1521
      247: 3282-block 66
branch  2 taken 1 (fallthrough)
branch  3 taken 246
        1: 3283:                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
        1: 3283-block 67
call    0 returned 1
        1: 3284:                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
call    0 returned 1
     1767: 3285:               } else if (x3 < x1 && x0 > x1) {  // two segments across x, down-left
     1767: 3285-block 69
branch  0 taken 260 (fallthrough)
branch  1 taken 1507
      260: 3285-block 70
branch  2 taken 14 (fallthrough)
branch  3 taken 246
       14: 3286:                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
       14: 3286-block 71
call    0 returned 14
       14: 3287:                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
call    0 returned 14
     1753: 3288:               } else if (x0 < x2 && x3 > x2) {  // two segments across x+1, down-right
     1753: 3288-block 73
branch  0 taken 279 (fallthrough)
branch  1 taken 1474
      279: 3288-block 74
branch  2 taken 31 (fallthrough)
branch  3 taken 248
       31: 3289:                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
       31: 3289-block 75
call    0 returned 31
       31: 3290:                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
call    0 returned 31
     1722: 3291:               } else if (x3 < x2 && x0 > x2) {  // two segments across x+1, down-left
     1722: 3291-block 77
branch  0 taken 269 (fallthrough)
branch  1 taken 1453
      269: 3291-block 78
branch  2 taken 19 (fallthrough)
branch  3 taken 250
       19: 3292:                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
       19: 3292-block 79
call    0 returned 19
       19: 3293:                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
call    0 returned 19
        -: 3294:               } else {  // one segment
     1703: 3295:                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x3,y3);
     1703: 3295-block 81
call    0 returned 1703
        -: 3296:               }
        -: 3297:            }
        -: 3298:         }
        -: 3299:      }
   134028: 3300:      e = e->next;
   134028: 3300-block 84
        -: 3301:   }
    26077: 3302:}
        -: 3303:
        -: 3304:// directly AA rasterize edges w/o supersampling
function _ZL29stbtt__rasterize_sorted_edgesP13stbtt__bitmapP11stbtt__edgeiiiiPv called 2358 returned 100% blocks executed 86%
     2358: 3305:static void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)
        -: 3306:{
     2358: 3307:   stbtt__hheap hh = { 0, 0, 0 };
     2358: 3308:   stbtt__active_edge *active = NULL;
     2358: 3309:   int y,j=0, i;
        -: 3310:   float scanline_data[129], *scanline, *scanline2;
        -: 3311:
        -: 3312:   STBTT__NOTUSED(vsubsample);
        -: 3313:
     2358: 3314:   if (result->w > 64)
     2358: 3314-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 2358
    #####: 3315:      scanline = (float *) STBTT_malloc((result->w*2+1) * sizeof(float), userdata);
    %%%%%: 3315-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 3315-block 4
        -: 3316:   else
     2358: 3317:      scanline = scanline_data;
     2358: 3317-block 5
        -: 3318:
     2358: 3319:   scanline2 = scanline + result->w;
        -: 3320:
     2358: 3321:   y = off_y;
     2358: 3322:   e[n].y0 = (float) (off_y + result->h) + 1;
        -: 3323:
    29503: 3324:   while (j < result->h) {
     2358: 3324-block 6
    29503: 3324-block 38
branch  0 taken 27145
branch  1 taken 2358 (fallthrough)
        -: 3325:      // find center of pixel for this scanline
    27145: 3326:      float scan_y_top    = y + 0.0f;
    27145: 3327:      float scan_y_bottom = y + 1.0f;
    27145: 3328:      stbtt__active_edge **step = &active;
        -: 3329:
    27145: 3330:      STBTT_memset(scanline , 0, result->w*sizeof(scanline[0]));
    27145: 3331:      STBTT_memset(scanline2, 0, (result->w+1)*sizeof(scanline[0]));
        -: 3332:
        -: 3333:      // update all active edges;
        -: 3334:      // remove all active edges that terminate before the top of this scanline
   154565: 3335:      while (*step) {
    27145: 3335-block 7
   154565: 3335-block 13
branch  0 taken 127420
branch  1 taken 27145 (fallthrough)
   127420: 3336:         stbtt__active_edge * z = *step;
   127420: 3337:         if (z->ey <= scan_y_top) {
   127420: 3337-block 8
branch  0 taken 47026 (fallthrough)
branch  1 taken 80394
    47026: 3338:            *step = z->next; // delete from list
   47026*: 3339:            STBTT_assert(z->direction);
    47026: 3339-block 9
branch  0 taken 0 (fallthrough)
branch  1 taken 47026
    %%%%%: 3339-block 10
call    2 never executed
    47026: 3340:            z->direction = 0;
    47026: 3341:            stbtt__hheap_free(&hh, z);
    47026: 3341-block 11
call    0 returned 47026
        -: 3342:         } else {
    80394: 3343:            step = &((*step)->next); // advance through list
    80394: 3343-block 12
        -: 3344:         }
        -: 3345:      }
        -: 3346:
        -: 3347:      // insert all edges that start before the bottom of this scanline
    80779: 3348:      while (e->y0 <= scan_y_bottom) {
    27145: 3348-block 14
    80779: 3348-block 26
branch  0 taken 53634
branch  1 taken 27145 (fallthrough)
    53634: 3349:         if (e->y0 != e->y1) {
    53634: 3349-block 15
branch  0 taken 53634 (fallthrough)
branch  1 taken 0
    53634: 3350:            stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y_top, userdata);
    53634: 3350-block 16
call    0 returned 53634
branch  1 taken 53634 (fallthrough)
branch  2 taken 0 (throw)
    53634: 3351:            if (z != NULL) {
    53634: 3351-block 17
branch  0 taken 53634 (fallthrough)
branch  1 taken 0
    53634: 3352:               if (j == 0 && off_y != 0) {
    53634: 3352-block 18
branch  0 taken 8248 (fallthrough)
branch  1 taken 45386
     8248: 3352-block 19
branch  2 taken 8212 (fallthrough)
branch  3 taken 36
     8212: 3353:                  if (z->ey < scan_y_top) {
     8212: 3353-block 20
branch  0 taken 0 (fallthrough)
branch  1 taken 8212
        -: 3354:                     // this can happen due to subpixel positioning and some kind of fp rounding error i think
    #####: 3355:                     z->ey = scan_y_top;
    %%%%%: 3355-block 21
        -: 3356:                  }
        -: 3357:               }
   53634*: 3358:               STBTT_assert(z->ey >= scan_y_top); // if we get really unlucky a tiny bit of an edge can be out of bounds
    53634: 3358-block 22
branch  0 taken 0 (fallthrough)
branch  1 taken 53634
    %%%%%: 3358-block 23
call    2 never executed
        -: 3359:               // insert at front
    53634: 3360:               z->next = active;
    53634: 3361:               active = z;
    53634: 3361-block 24
        -: 3362:            }
        -: 3363:         }
    53634: 3364:         ++e;
    53634: 3364-block 25
        -: 3365:      }
        -: 3366:
        -: 3367:      // now process all active edges
    27145: 3368:      if (active)
    27145: 3368-block 27
branch  0 taken 26077 (fallthrough)
branch  1 taken 1068
    26077: 3369:         stbtt__fill_active_edges_new(scanline, scanline2+1, result->w, active, scan_y_top);
    26077: 3369-block 28
call    0 returned 26077
        -: 3370:
        -: 3371:      {
    27145: 3372:         float sum = 0;
   518082: 3373:         for (i=0; i < result->w; ++i) {
    27145: 3373-block 29
   518082: 3373-block 33
branch  0 taken 490937
branch  1 taken 27145 (fallthrough)
        -: 3374:            float k;
        -: 3375:            int m;
   490937: 3376:            sum += scanline2[i];
   490937: 3377:            k = scanline[i] + sum;
   490937: 3378:            k = (float) STBTT_fabs(k)*255 + 0.5f;
   490937: 3379:            m = (int) k;
   490937: 3380:            if (m > 255) m = 255;
   490937: 3380-block 30
branch  0 taken 1730 (fallthrough)
branch  1 taken 489207
     1730: 3380-block 31
   490937: 3381:            result->pixels[j*result->stride + i] = (unsigned char) m;
   490937: 3381-block 32
        -: 3382:         }
        -: 3383:      }
        -: 3384:      // advance all the edges
    27145: 3385:      step = &active;
   161173: 3386:      while (*step) {
    27145: 3386-block 34
   161173: 3386-block 36
branch  0 taken 134028
branch  1 taken 27145 (fallthrough)
   134028: 3387:         stbtt__active_edge *z = *step;
   134028: 3388:         z->fx += z->fdx; // advance to position for current scanline
   134028: 3389:         step = &((*step)->next); // advance through list
   134028: 3389-block 35
        -: 3390:      }
        -: 3391:
    27145: 3392:      ++y;
    27145: 3393:      ++j;
    27145: 3393-block 37
        -: 3394:   }
        -: 3395:
     2358: 3396:   stbtt__hheap_cleanup(&hh, userdata);
     2358: 3396-block 39
call    0 returned 2358
branch  1 taken 2358 (fallthrough)
branch  2 taken 0 (throw)
        -: 3397:
     2358: 3398:   if (scanline != scanline_data)
     2358: 3398-block 40
branch  0 taken 0 (fallthrough)
branch  1 taken 2358
    #####: 3399:      STBTT_free(scanline, userdata);
    %%%%%: 3399-block 41
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
     2358: 3400:}
     2358: 3400-block 42
        -: 3401:#else
        -: 3402:#error "Unrecognized value of STBTT_RASTERIZER_VERSION"
        -: 3403:#endif
        -: 3404:
        -: 3405:#define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)
        -: 3406:
function _ZL26stbtt__sort_edges_ins_sortP11stbtt__edgei called 2358 returned 100% blocks executed 100%
     2358: 3407:static void stbtt__sort_edges_ins_sort(stbtt__edge *p, int n)
        -: 3408:{
        -: 3409:   int i,j;
    53634: 3410:   for (i=1; i < n; ++i) {
     2358: 3410-block 2
    51276: 3410-block 10
    53634: 3410-block 11
branch  0 taken 51276
branch  1 taken 2358 (fallthrough)
    51276: 3411:      stbtt__edge t = p[i], *a = &t;
    51276: 3412:      j = i;
   156672: 3413:      while (j > 0) {
    51276: 3413-block 3
   156672: 3413-block 7
branch  0 taken 152964
branch  1 taken 3708 (fallthrough)
   152964: 3414:         stbtt__edge *b = &p[j-1];
   152964: 3415:         int c = STBTT__COMPARE(a,b);
   152964: 3416:         if (!c) break;
   152964: 3416-block 4
branch  0 taken 47568 (fallthrough)
branch  1 taken 105396
    47568: 3416-block 5
   105396: 3417:         p[j] = p[j-1];
   105396: 3418:         --j;
   105396: 3418-block 6
        -: 3419:      }
    51276: 3420:      if (i != j)
    51276: 3420-block 8
branch  0 taken 35547 (fallthrough)
branch  1 taken 15729
    35547: 3421:         p[j] = t;
    35547: 3421-block 9
        -: 3422:   }
     2358: 3423:}
        -: 3424:
function _ZL27stbtt__sort_edges_quicksortP11stbtt__edgei called 7276 returned 100% blocks executed 100%
     7276: 3425:static void stbtt__sort_edges_quicksort(stbtt__edge *p, int n)
        -: 3426:{
        -: 3427:   /* threshold for transitioning to insertion sort */
    12194: 3428:   while (n > 12) {
     7276: 3428-block 2
    12194: 3428-block 24
branch  0 taken 4918
branch  1 taken 7276 (fallthrough)
        -: 3429:      stbtt__edge t;
        -: 3430:      int c01,c12,c,m,i,j;
        -: 3431:
        -: 3432:      /* compute median of three */
     4918: 3433:      m = n >> 1;
     4918: 3434:      c01 = STBTT__COMPARE(&p[0],&p[m]);
     4918: 3435:      c12 = STBTT__COMPARE(&p[m],&p[n-1]);
        -: 3436:      /* if 0 >= mid >= end, or 0 < mid < end, then use mid */
     4918: 3437:      if (c01 != c12) {
     4918: 3437-block 3
branch  0 taken 2785 (fallthrough)
branch  1 taken 2133
        -: 3438:         /* otherwise, we'll need to swap something else to middle */
        -: 3439:         int z;
     2785: 3440:         c = STBTT__COMPARE(&p[0],&p[n-1]);
        -: 3441:         /* 0>mid && mid<n:  0>n => n; 0<n => 0 */
        -: 3442:         /* 0<mid && mid>n:  0>n => 0; 0<n => n */
     2785: 3443:         z = (c == c12) ? 0 : n-1;
     2785: 3443-block 4
branch  0 taken 2195 (fallthrough)
branch  1 taken 590
     2195: 3443-block 5
      590: 3443-block 6
     2785: 3444:         t = p[z];
     2785: 3445:         p[z] = p[m];
     2785: 3446:         p[m] = t;
     2785: 3446-block 7
        -: 3447:      }
        -: 3448:      /* now p[m] is the median-of-three */
        -: 3449:      /* swap it to the beginning so it won't move around */
     4918: 3450:      t = p[0];
     4918: 3451:      p[0] = p[m];
     4918: 3452:      p[m] = t;
        -: 3453:
        -: 3454:      /* partition loop */
     4918: 3455:      i=1;
     4918: 3456:      j=n-1;
     4918: 3456-block 8
    20279: 3457:      for(;;) {
        -: 3458:         /* handling of equality is crucial here */
        -: 3459:         /* for sentinels & efficiency with duplicates */
    46453: 3460:         for (;;++i) {
    46453: 3460-block 11
    71650: 3461:            if (!STBTT__COMPARE(&p[i], &p[0])) break;
    71650: 3461-block 9
branch  0 taken 25197 (fallthrough)
branch  1 taken 46453
    25197: 3461-block 10
        -: 3462:         }
    23085: 3463:         for (;;--j) {
    23085: 3463-block 14
    48282: 3464:            if (!STBTT__COMPARE(&p[0], &p[j])) break;
    48282: 3464-block 12
branch  0 taken 25197 (fallthrough)
branch  1 taken 23085
    25197: 3464-block 13
        -: 3465:         }
        -: 3466:         /* make sure we haven't crossed */
    25197: 3467:         if (i >= j) break;
    25197: 3467-block 15
branch  0 taken 4918 (fallthrough)
branch  1 taken 20279
     4918: 3467-block 16
    20279: 3468:         t = p[i];
    20279: 3469:         p[i] = p[j];
    20279: 3470:         p[j] = t;
        -: 3471:
    20279: 3472:         ++i;
    20279: 3473:         --j;
    20279: 3473-block 17
        -: 3474:      }
        -: 3475:      /* recurse on smaller side, iterate on larger */
     4918: 3476:      if (j < (n-i)) {
     4918: 3476-block 18
branch  0 taken 1523 (fallthrough)
branch  1 taken 3395
     1523: 3477:         stbtt__sort_edges_quicksort(p,j);
     1523: 3477-block 19
call    0 returned 1523
branch  1 taken 1523 (fallthrough)
branch  2 taken 0 (throw)
     1523: 3478:         p = p+i;
     1523: 3479:         n = n-i;
     1523: 3479-block 20
        -: 3480:      } else {
     3395: 3481:         stbtt__sort_edges_quicksort(p+i, n-i);
     3395: 3481-block 21
call    0 returned 3395
branch  1 taken 3395 (fallthrough)
branch  2 taken 0 (throw)
     3395: 3482:         n = j;
     3395: 3482-block 22
        -: 3483:      }
        -: 3484:   }
     7276: 3485:}
     7276: 3485-block 25
        -: 3486:
function _ZL17stbtt__sort_edgesP11stbtt__edgei called 2358 returned 100% blocks executed 100%
     2358: 3487:static void stbtt__sort_edges(stbtt__edge *p, int n)
        -: 3488:{
     2358: 3489:   stbtt__sort_edges_quicksort(p, n);
     2358: 3489-block 2
call    0 returned 2358
     2358: 3490:   stbtt__sort_edges_ins_sort(p, n);
call    0 returned 2358
     2358: 3491:}
        -: 3492:
        -: 3493:typedef struct
        -: 3494:{
        -: 3495:   float x,y;
        -: 3496:} stbtt__point;
        -: 3497:
function _ZL16stbtt__rasterizeP13stbtt__bitmapP12stbtt__pointPiiffffiiiPv called 2358 returned 100% blocks executed 89%
     2358: 3498:static void stbtt__rasterize(stbtt__bitmap *result, stbtt__point *pts, int *wcount, int windings, float scale_x, float scale_y, float shift_x, float shift_y, int off_x, int off_y, int invert, void *userdata)
        -: 3499:{
    2358*: 3500:   float y_scale_inv = invert ? -scale_y : scale_y;
     2358: 3500-block 2
branch  0 taken 2358 (fallthrough)
branch  1 taken 0
     2358: 3500-block 3
    %%%%%: 3500-block 4
        -: 3501:   stbtt__edge *e;
        -: 3502:   int n,i,j,k,m;
        -: 3503:#if STBTT_RASTERIZER_VERSION == 1
        -: 3504:   int vsubsample = result->h < 8 ? 15 : 5;
        -: 3505:#elif STBTT_RASTERIZER_VERSION == 2
     2358: 3506:   int vsubsample = 1;
        -: 3507:#else
        -: 3508:   #error "Unrecognized value of STBTT_RASTERIZER_VERSION"
        -: 3509:#endif
        -: 3510:   // vsubsample should divide 255 evenly; otherwise we won't reach full opacity
        -: 3511:
        -: 3512:   // now we have to blow out the windings into explicit edge lists
     2358: 3513:   n = 0;
    10515: 3514:   for (i=0; i < windings; ++i)
     2358: 3514-block 5
    10515: 3514-block 7
branch  0 taken 8157
branch  1 taken 2358 (fallthrough)
     8157: 3515:      n += wcount[i];
     8157: 3515-block 6
        -: 3516:
     2358: 3517:   e = (stbtt__edge *) STBTT_malloc(sizeof(*e) * (n+1), userdata); // add an extra one as a sentinel
     2358: 3517-block 8
call    0 returned 2358
    2358*: 3518:   if (e == 0) return;
branch  0 taken 0 (fallthrough)
branch  1 taken 2358
    %%%%%: 3518-block 10
     2358: 3519:   n = 0;
        -: 3520:
     2358: 3521:   m=0;
    10515: 3522:   for (i=0; i < windings; ++i) {
     2358: 3522-block 11
     8157: 3522-block 23
    10515: 3522-block 24
branch  0 taken 8157
branch  1 taken 2358 (fallthrough)
     8157: 3523:      stbtt__point *p = pts + m;
     8157: 3524:      m += wcount[i];
     8157: 3525:      j = wcount[i]-1;
    85742: 3526:      for (k=0; k < wcount[i]; j=k++) {
     8157: 3526-block 12
    77585: 3526-block 21
    85742: 3526-block 22
branch  0 taken 77585
branch  1 taken 8157 (fallthrough)
    77585: 3527:         int a=k,b=j;
        -: 3528:         // skip the edge if horizontal
    77585: 3529:         if (p[j].y == p[k].y)
    77585: 3529-block 13
branch  0 taken 23951 (fallthrough)
branch  1 taken 53634
    23951: 3530:            continue;
    23951: 3530-block 14
        -: 3531:         // add edge from j to k to the list
    53634: 3532:         e[n].invert = 0;
   53634*: 3533:         if (invert ? p[j].y > p[k].y : p[j].y < p[k].y) {
    53634: 3533-block 15
branch  0 taken 53634 (fallthrough)
branch  1 taken 0
    53634: 3533-block 16
    %%%%%: 3533-block 17
    53634: 3533-block 18
branch  2 taken 26777 (fallthrough)
branch  3 taken 26857
    26777: 3534:            e[n].invert = 1;
    26777: 3535:            a=j,b=k;
    26777: 3535-block 19
        -: 3536:         }
    53634: 3537:         e[n].x0 = p[a].x * scale_x + shift_x;
    53634: 3538:         e[n].y0 = (p[a].y * y_scale_inv + shift_y) * vsubsample;
    53634: 3539:         e[n].x1 = p[b].x * scale_x + shift_x;
    53634: 3540:         e[n].y1 = (p[b].y * y_scale_inv + shift_y) * vsubsample;
    53634: 3541:         ++n;
    53634: 3541-block 20
        -: 3542:      }
        -: 3543:   }
        -: 3544:
        -: 3545:   // now sort the edges by their highest point (should snap to integer, and then by x)
        -: 3546:   //STBTT_sort(e, n, sizeof(e[0]), stbtt__edge_compare);
     2358: 3547:   stbtt__sort_edges(e, n);
     2358: 3547-block 25
call    0 returned 2358
        -: 3548:
        -: 3549:   // now, traverse the scanlines and find the intersections on each scanline, use xor winding rule
     2358: 3550:   stbtt__rasterize_sorted_edges(result, e, n, vsubsample, off_x, off_y, userdata);
call    0 returned 2358
        -: 3551:
     2358: 3552:   STBTT_free(e, userdata);
call    0 returned 2358
        -: 3553:}
        -: 3554:
function _ZL16stbtt__add_pointP12stbtt__pointiff called 155170 returned 100% blocks executed 100%
   155170: 3555:static void stbtt__add_point(stbtt__point *points, int n, float x, float y)
        -: 3556:{
   155170: 3557:   if (!points) return; // during first pass, it's unallocated
   155170: 3557-block 2
branch  0 taken 77585 (fallthrough)
branch  1 taken 77585
    77585: 3557-block 3
    77585: 3558:   points[n].x = x;
    77585: 3559:   points[n].y = y;
    77585: 3559-block 4
        -: 3560:}
        -: 3561:
        -: 3562:// tessellate until threshold p is happy... @TODO warped to compensate for non-linear stretching
function _ZL22stbtt__tesselate_curveP12stbtt__pointPifffffffi called 65040 returned 100% blocks executed 89%
    65040: 3563:static int stbtt__tesselate_curve(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float objspace_flatness_squared, int n)
        -: 3564:{
        -: 3565:   // midpoint
    65040: 3566:   float mx = (x0 + 2*x1 + x2)/4;
    65040: 3567:   float my = (y0 + 2*y1 + y2)/4;
        -: 3568:   // versus directly drawn line
    65040: 3569:   float dx = (x0+x2)/2 - mx;
    65040: 3570:   float dy = (y0+y2)/2 - my;
    65040: 3571:   if (n > 16) // 65536 segments on one curve better be enough!
    65040: 3571-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 65040
    #####: 3572:      return 1;
    %%%%%: 3572-block 3
    65040: 3573:   if (dx*dx+dy*dy > objspace_flatness_squared) { // half-pixel error allowed... need to be smaller if AA
    65040: 3573-block 4
branch  0 taken 1832 (fallthrough)
branch  1 taken 63208
     1832: 3574:      stbtt__tesselate_curve(points, num_points, x0,y0, (x0+x1)/2.0f,(y0+y1)/2.0f, mx,my, objspace_flatness_squared,n+1);
     1832: 3574-block 5
call    0 returned 1832
     1832: 3575:      stbtt__tesselate_curve(points, num_points, mx,my, (x1+x2)/2.0f,(y1+y2)/2.0f, x2,y2, objspace_flatness_squared,n+1);
call    0 returned 1832
        -: 3576:   } else {
    63208: 3577:      stbtt__add_point(points, *num_points,x2,y2);
    63208: 3577-block 7
call    0 returned 63208
    63208: 3578:      *num_points = *num_points+1;
        -: 3579:   }
    65040: 3580:   return 1;
    65040: 3580-block 9
        -: 3581:}
        -: 3582:
function _ZL22stbtt__tesselate_cubicP12stbtt__pointPifffffffffi called 0 returned 0% blocks executed 0%
    #####: 3583:static void stbtt__tesselate_cubic(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float x3, float y3, float objspace_flatness_squared, int n)
        -: 3584:{
        -: 3585:   // @TODO this "flatness" calculation is just made-up nonsense that seems to work well enough
    #####: 3586:   float dx0 = x1-x0;
    #####: 3587:   float dy0 = y1-y0;
    #####: 3588:   float dx1 = x2-x1;
    #####: 3589:   float dy1 = y2-y1;
    #####: 3590:   float dx2 = x3-x2;
    #####: 3591:   float dy2 = y3-y2;
    #####: 3592:   float dx = x3-x0;
    #####: 3593:   float dy = y3-y0;
    #####: 3594:   float longlen = (float) (STBTT_sqrt(dx0*dx0+dy0*dy0)+STBTT_sqrt(dx1*dx1+dy1*dy1)+STBTT_sqrt(dx2*dx2+dy2*dy2));
    #####: 3595:   float shortlen = (float) STBTT_sqrt(dx*dx+dy*dy);
    #####: 3596:   float flatness_squared = longlen*longlen-shortlen*shortlen;
        -: 3597:
    #####: 3598:   if (n > 16) // 65536 segments on one curve better be enough!
    %%%%%: 3598-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3599:      return;
    %%%%%: 3599-block 3
        -: 3600:
    #####: 3601:   if (flatness_squared > objspace_flatness_squared) {
    %%%%%: 3601-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3602:      float x01 = (x0+x1)/2;
    #####: 3603:      float y01 = (y0+y1)/2;
    #####: 3604:      float x12 = (x1+x2)/2;
    #####: 3605:      float y12 = (y1+y2)/2;
    #####: 3606:      float x23 = (x2+x3)/2;
    #####: 3607:      float y23 = (y2+y3)/2;
        -: 3608:
    #####: 3609:      float xa = (x01+x12)/2;
    #####: 3610:      float ya = (y01+y12)/2;
    #####: 3611:      float xb = (x12+x23)/2;
    #####: 3612:      float yb = (y12+y23)/2;
        -: 3613:
    #####: 3614:      float mx = (xa+xb)/2;
    #####: 3615:      float my = (ya+yb)/2;
        -: 3616:
    #####: 3617:      stbtt__tesselate_cubic(points, num_points, x0,y0, x01,y01, xa,ya, mx,my, objspace_flatness_squared,n+1);
    %%%%%: 3617-block 5
call    0 never executed
    #####: 3618:      stbtt__tesselate_cubic(points, num_points, mx,my, xb,yb, x23,y23, x3,y3, objspace_flatness_squared,n+1);
call    0 never executed
        -: 3619:   } else {
    #####: 3620:      stbtt__add_point(points, *num_points,x3,y3);
    %%%%%: 3620-block 7
call    0 never executed
    #####: 3621:      *num_points = *num_points+1;
        -: 3622:   }
        -: 3623:}
        -: 3624:
        -: 3625:// returns number of contours
function _ZL19stbtt_FlattenCurvesP12stbtt_vertexifPPiS1_Pv called 2358 returned 100% blocks executed 79%
     2358: 3626:static stbtt__point *stbtt_FlattenCurves(stbtt_vertex *vertices, int num_verts, float objspace_flatness, int **contour_lengths, int *num_contours, void *userdata)
        -: 3627:{
     2358: 3628:   stbtt__point *points=0;
     2358: 3629:   int num_points=0;
        -: 3630:
     2358: 3631:   float objspace_flatness_squared = objspace_flatness * objspace_flatness;
     2358: 3632:   int i,n=0,start=0, pass;
        -: 3633:
        -: 3634:   // count how many "moves" there are to get the contour count
    79027: 3635:   for (i=0; i < num_verts; ++i)
     2358: 3635-block 2
    76669: 3635-block 5
    79027: 3635-block 6
branch  0 taken 76669
branch  1 taken 2358 (fallthrough)
    76669: 3636:      if (vertices[i].type == STBTT_vmove)
    76669: 3636-block 3
branch  0 taken 8157 (fallthrough)
branch  1 taken 68512
     8157: 3637:         ++n;
     8157: 3637-block 4
        -: 3638:
     2358: 3639:   *num_contours = n;
    2358*: 3640:   if (n == 0) return 0;
     2358: 3640-block 7
branch  0 taken 0 (fallthrough)
branch  1 taken 2358
    %%%%%: 3640-block 8
        -: 3641:
     2358: 3642:   *contour_lengths = (int *) STBTT_malloc(sizeof(**contour_lengths) * n, userdata);
     2358: 3642-block 9
call    0 returned 2358
branch  1 taken 2358 (fallthrough)
branch  2 taken 0 (throw)
        -: 3643:
     2358: 3644:   if (*contour_lengths == 0) {
     2358: 3644-block 10
branch  0 taken 0 (fallthrough)
branch  1 taken 2358
    #####: 3645:      *num_contours = 0;
    #####: 3646:      return 0;
    %%%%%: 3646-block 11
        -: 3647:   }
        -: 3648:
        -: 3649:   // make two passes through the points so we don't need to realloc
     7074: 3650:   for (pass=0; pass < 2; ++pass) {
     2358: 3650-block 12
     7074: 3650-block 32
branch  0 taken 4716
branch  1 taken 2358 (fallthrough)
     4716: 3651:      float x=0,y=0;
     4716: 3652:      if (pass == 1) {
     4716: 3652-block 13
branch  0 taken 2358 (fallthrough)
branch  1 taken 2358
     2358: 3653:         points = (stbtt__point *) STBTT_malloc(num_points * sizeof(points[0]), userdata);
     2358: 3653-block 14
call    0 returned 2358
branch  1 taken 2358 (fallthrough)
branch  2 taken 0 (throw)
    2358*: 3654:         if (points == NULL) goto error;
     2358: 3654-block 15
branch  0 taken 0 (fallthrough)
branch  1 taken 2358
    %%%%%: 3654-block 16
        -: 3655:      }
     4716: 3656:      num_points = 0;
     4716: 3657:      n= -1;
   158054: 3658:      for (i=0; i < num_verts; ++i) {
     4716: 3658-block 17
   153338: 3658-block 29
   158054: 3658-block 30
branch  0 taken 153338
branch  1 taken 4716 (fallthrough)
   153338: 3659:         switch (vertices[i].type) {
   153338: 3659-block 18
branch  0 taken 16314
branch  1 taken 75648
branch  2 taken 61376
branch  3 taken 0
branch  4 taken 0
    16314: 3660:            case STBTT_vmove:
        -: 3661:               // start the next contour
    16314: 3662:               if (n >= 0)
    16314: 3662-block 19
branch  0 taken 11598 (fallthrough)
branch  1 taken 4716
    11598: 3663:                  (*contour_lengths)[n] = num_points - start;
    11598: 3663-block 20
    16314: 3664:               ++n;
    16314: 3665:               start = num_points;
        -: 3666:
    16314: 3667:               x = vertices[i].x, y = vertices[i].y;
    16314: 3668:               stbtt__add_point(points, num_points++, x,y);
    16314: 3668-block 21
call    0 returned 16314
    16314: 3669:               break;
    75648: 3670:            case STBTT_vline:
    75648: 3671:               x = vertices[i].x, y = vertices[i].y;
    75648: 3672:               stbtt__add_point(points, num_points++, x, y);
    75648: 3672-block 23
call    0 returned 75648
    75648: 3673:               break;
    61376: 3674:            case STBTT_vcurve:
    61376: 3675:               stbtt__tesselate_curve(points, &num_points, x,y,
    61376: 3676:                                        vertices[i].cx, vertices[i].cy,
    61376: 3677:                                        vertices[i].x,  vertices[i].y,
    61376: 3677-block 25
call    0 returned 61376
branch  1 taken 61376 (fallthrough)
branch  2 taken 0 (throw)
        -: 3678:                                        objspace_flatness_squared, 0);
    61376: 3679:               x = vertices[i].x, y = vertices[i].y;
    61376: 3680:               break;
    61376: 3680-block 26
    #####: 3681:            case STBTT_vcubic:
    #####: 3682:               stbtt__tesselate_cubic(points, &num_points, x,y,
    #####: 3683:                                        vertices[i].cx, vertices[i].cy,
    #####: 3684:                                        vertices[i].cx1, vertices[i].cy1,
    #####: 3685:                                        vertices[i].x,  vertices[i].y,
    %%%%%: 3685-block 27
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 3686:                                        objspace_flatness_squared, 0);
    #####: 3687:               x = vertices[i].x, y = vertices[i].y;
    #####: 3688:               break;
    %%%%%: 3688-block 28
        -: 3689:         }
        -: 3690:      }
     4716: 3691:      (*contour_lengths)[n] = num_points - start;
     4716: 3691-block 31
        -: 3692:   }
        -: 3693:
     2358: 3694:   return points;
     2358: 3694-block 33
    #####: 3695:error:
    #####: 3696:   STBTT_free(points, userdata);
    %%%%%: 3696-block 34
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3697:   STBTT_free(*contour_lengths, userdata);
    %%%%%: 3697-block 35
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3698:   *contour_lengths = 0;
    #####: 3699:   *num_contours = 0;
    #####: 3700:   return NULL;
    %%%%%: 3700-block 36
        -: 3701:}
        -: 3702:
function stbtt_Rasterize called 2358 returned 100% blocks executed 100%
     2358: 3703:STBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result, float flatness_in_pixels, stbtt_vertex *vertices, int num_verts, float scale_x, float scale_y, float shift_x, float shift_y, int x_off, int y_off, int invert, void *userdata)
        -: 3704:{
     2358: 3705:   float scale            = scale_x > scale_y ? scale_y : scale_x;
     2358: 3705-block 2
branch  0 taken 2144 (fallthrough)
branch  1 taken 214
     2144: 3705-block 3
      214: 3705-block 4
     2358: 3706:   int winding_count      = 0;
     2358: 3707:   int *winding_lengths   = NULL;
     2358: 3708:   stbtt__point *windings = stbtt_FlattenCurves(vertices, num_verts, flatness_in_pixels / scale, &winding_lengths, &winding_count, userdata);
     2358: 3708-block 5
call    0 returned 2358
branch  1 taken 2358 (fallthrough)
branch  2 taken 0 (throw)
     2358: 3709:   if (windings) {
     2358: 3709-block 6
branch  0 taken 2358 (fallthrough)
branch  1 taken 0
     2358: 3710:      stbtt__rasterize(result, windings, winding_lengths, winding_count, scale_x, scale_y, shift_x, shift_y, x_off, y_off, invert, userdata);
     2358: 3710-block 7
call    0 returned 2358
branch  1 taken 2358 (fallthrough)
branch  2 taken 0 (throw)
     2358: 3711:      STBTT_free(winding_lengths, userdata);
     2358: 3711-block 8
call    0 returned 2358
branch  1 taken 2358 (fallthrough)
branch  2 taken 0 (throw)
     2358: 3712:      STBTT_free(windings, userdata);
     2358: 3712-block 9
call    0 returned 2358
branch  1 taken 2358 (fallthrough)
branch  2 taken 0 (throw)
        -: 3713:   }
     2358: 3714:}
     2358: 3714-block 10
        -: 3715:
function stbtt_FreeBitmap called 0 returned 0% blocks executed 0%
    #####: 3716:STBTT_DEF void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata)
        -: 3717:{
    #####: 3718:   STBTT_free(bitmap, userdata);
    %%%%%: 3718-block 2
call    0 never executed
    #####: 3719:}
        -: 3720:
function stbtt_GetGlyphBitmapSubpixel called 0 returned 0% blocks executed 0%
    #####: 3721:STBTT_DEF unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff)
        -: 3722:{
        -: 3723:   int ix0,iy0,ix1,iy1;
        -: 3724:   stbtt__bitmap gbm;
        -: 3725:   stbtt_vertex *vertices;
    #####: 3726:   int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);
    %%%%%: 3726-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 3727:
    #####: 3728:   if (scale_x == 0) scale_x = scale_y;
    %%%%%: 3728-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3728-block 4
    #####: 3729:   if (scale_y == 0) {
    %%%%%: 3729-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3730:      if (scale_x == 0) {
    %%%%%: 3730-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3731:         STBTT_free(vertices, info->userdata);
    %%%%%: 3731-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3732:         return NULL;
    %%%%%: 3732-block 8
        -: 3733:      }
    #####: 3734:      scale_y = scale_x;
    %%%%%: 3734-block 9
        -: 3735:   }
        -: 3736:
    #####: 3737:   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,&ix1,&iy1);
    %%%%%: 3737-block 10
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 3738:
        -: 3739:   // now we get the size
    #####: 3740:   gbm.w = (ix1 - ix0);
    #####: 3741:   gbm.h = (iy1 - iy0);
    #####: 3742:   gbm.pixels = NULL; // in case we error
        -: 3743:
    #####: 3744:   if (width ) *width  = gbm.w;
    %%%%%: 3744-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3744-block 12
    #####: 3745:   if (height) *height = gbm.h;
    %%%%%: 3745-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3745-block 14
    #####: 3746:   if (xoff  ) *xoff   = ix0;
    %%%%%: 3746-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3746-block 16
    #####: 3747:   if (yoff  ) *yoff   = iy0;
    %%%%%: 3747-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3747-block 18
        -: 3748:
    #####: 3749:   if (gbm.w && gbm.h) {
    %%%%%: 3749-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3749-block 20
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3750:      gbm.pixels = (unsigned char *) STBTT_malloc(gbm.w * gbm.h, info->userdata);
    %%%%%: 3750-block 21
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3751:      if (gbm.pixels) {
    %%%%%: 3751-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3752:         gbm.stride = gbm.w;
        -: 3753:
    #####: 3754:         stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0, iy0, 1, info->userdata);
    %%%%%: 3754-block 23
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 3755:      }
        -: 3756:   }
    #####: 3757:   STBTT_free(vertices, info->userdata);
    %%%%%: 3757-block 24
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3758:   return gbm.pixels;
    %%%%%: 3758-block 25
        -: 3759:}
        -: 3760:
function stbtt_GetGlyphBitmap called 0 returned 0% blocks executed 0%
    #####: 3761:STBTT_DEF unsigned char *stbtt_GetGlyphBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff)
        -: 3762:{
    #####: 3763:   return stbtt_GetGlyphBitmapSubpixel(info, scale_x, scale_y, 0.0f, 0.0f, glyph, width, height, xoff, yoff);
    %%%%%: 3763-block 2
call    0 never executed
        -: 3764:}
        -: 3765:
function stbtt_MakeGlyphBitmapSubpixel called 2380 returned 100% blocks executed 100%
     2380: 3766:STBTT_DEF void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph)
        -: 3767:{
        -: 3768:   int ix0,iy0;
        -: 3769:   stbtt_vertex *vertices;
     2380: 3770:   int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);
     2380: 3770-block 2
call    0 returned 2380
branch  1 taken 2380 (fallthrough)
branch  2 taken 0 (throw)
        -: 3771:   stbtt__bitmap gbm;
        -: 3772:
     2380: 3773:   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,0,0);
     2380: 3773-block 3
call    0 returned 2380
branch  1 taken 2380 (fallthrough)
branch  2 taken 0 (throw)
     2380: 3774:   gbm.pixels = output;
     2380: 3775:   gbm.w = out_w;
     2380: 3776:   gbm.h = out_h;
     2380: 3777:   gbm.stride = out_stride;
        -: 3778:
     2380: 3779:   if (gbm.w && gbm.h)
     2380: 3779-block 4
branch  0 taken 2358 (fallthrough)
branch  1 taken 22
     2358: 3779-block 5
branch  2 taken 2358 (fallthrough)
branch  3 taken 0
     2358: 3780:      stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0,iy0, 1, info->userdata);
     2358: 3780-block 6
call    0 returned 2358
branch  1 taken 2358 (fallthrough)
branch  2 taken 0 (throw)
        -: 3781:
     2380: 3782:   STBTT_free(vertices, info->userdata);
     2380: 3782-block 7
call    0 returned 2380
branch  1 taken 2380 (fallthrough)
branch  2 taken 0 (throw)
     2380: 3783:}
     2380: 3783-block 8
        -: 3784:
function stbtt_MakeGlyphBitmap called 0 returned 0% blocks executed 0%
    #####: 3785:STBTT_DEF void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph)
        -: 3786:{
    #####: 3787:   stbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0f,0.0f, glyph);
    %%%%%: 3787-block 2
call    0 never executed
    #####: 3788:}
        -: 3789:
function stbtt_GetCodepointBitmapSubpixel called 0 returned 0% blocks executed 0%
    #####: 3790:STBTT_DEF unsigned char *stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff)
        -: 3791:{
    #####: 3792:   return stbtt_GetGlyphBitmapSubpixel(info, scale_x, scale_y,shift_x,shift_y, stbtt_FindGlyphIndex(info,codepoint), width,height,xoff,yoff);
    %%%%%: 3792-block 2
call    0 never executed
call    1 never executed
        -: 3793:}
        -: 3794:
function stbtt_MakeCodepointBitmapSubpixelPrefilter called 0 returned 0% blocks executed 0%
    #####: 3795:STBTT_DEF void stbtt_MakeCodepointBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int codepoint)
        -: 3796:{
    #####: 3797:   stbtt_MakeGlyphBitmapSubpixelPrefilter(info, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, oversample_x, oversample_y, sub_x, sub_y, stbtt_FindGlyphIndex(info,codepoint));
    %%%%%: 3797-block 2
call    0 never executed
call    1 never executed
    #####: 3798:}
        -: 3799:
function stbtt_MakeCodepointBitmapSubpixel called 0 returned 0% blocks executed 0%
    #####: 3800:STBTT_DEF void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint)
        -: 3801:{
    #####: 3802:   stbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, stbtt_FindGlyphIndex(info,codepoint));
    %%%%%: 3802-block 2
call    0 never executed
call    1 never executed
    #####: 3803:}
        -: 3804:
function stbtt_GetCodepointBitmap called 0 returned 0% blocks executed 0%
    #####: 3805:STBTT_DEF unsigned char *stbtt_GetCodepointBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff)
        -: 3806:{
    #####: 3807:   return stbtt_GetCodepointBitmapSubpixel(info, scale_x, scale_y, 0.0f,0.0f, codepoint, width,height,xoff,yoff);
    %%%%%: 3807-block 2
call    0 never executed
        -: 3808:}
        -: 3809:
function stbtt_MakeCodepointBitmap called 0 returned 0% blocks executed 0%
    #####: 3810:STBTT_DEF void stbtt_MakeCodepointBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint)
        -: 3811:{
    #####: 3812:   stbtt_MakeCodepointBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0f,0.0f, codepoint);
    %%%%%: 3812-block 2
call    0 never executed
    #####: 3813:}
        -: 3814:
        -: 3815://////////////////////////////////////////////////////////////////////////////
        -: 3816://
        -: 3817:// bitmap baking
        -: 3818://
        -: 3819:// This is SUPER-CRAPPY packing to keep source code small
        -: 3820:
function _ZL29stbtt_BakeFontBitmap_internalPhifS_iiiiP15stbtt_bakedchar called 0 returned 0% blocks executed 0%
    #####: 3821:static int stbtt_BakeFontBitmap_internal(unsigned char *data, int offset,  // font location (use offset=0 for plain .ttf)
        -: 3822:                                float pixel_height,                     // height of font in pixels
        -: 3823:                                unsigned char *pixels, int pw, int ph,  // bitmap to be filled in
        -: 3824:                                int first_char, int num_chars,          // characters to bake
        -: 3825:                                stbtt_bakedchar *chardata)
        -: 3826:{
        -: 3827:   float scale;
        -: 3828:   int x,y,bottom_y, i;
        -: 3829:   stbtt_fontinfo f;
    #####: 3830:   f.userdata = NULL;
    #####: 3831:   if (!stbtt_InitFont(&f, data, offset))
    %%%%%: 3831-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 3832:      return -1;
    %%%%%: 3832-block 4
    #####: 3833:   STBTT_memset(pixels, 0, pw*ph); // background of 0 around pixels
    #####: 3834:   x=y=1;
    #####: 3835:   bottom_y = 1;
        -: 3836:
    #####: 3837:   scale = stbtt_ScaleForPixelHeight(&f, pixel_height);
    %%%%%: 3837-block 5
call    0 never executed
        -: 3838:
    #####: 3839:   for (i=0; i < num_chars; ++i) {
    %%%%%: 3839-block 21
    %%%%%: 3839-block 22
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 3840:      int advance, lsb, x0,y0,x1,y1,gw,gh;
    #####: 3841:      int g = stbtt_FindGlyphIndex(&f, first_char + i);
    %%%%%: 3841-block 7
call    0 never executed
    #####: 3842:      stbtt_GetGlyphHMetrics(&f, g, &advance, &lsb);
call    0 never executed
    #####: 3843:      stbtt_GetGlyphBitmapBox(&f, g, scale,scale, &x0,&y0,&x1,&y1);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3844:      gw = x1-x0;
    #####: 3845:      gh = y1-y0;
    #####: 3846:      if (x + gw + 1 >= pw)
    %%%%%: 3846-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3847:         y = bottom_y, x = 1; // advance to next row
    %%%%%: 3847-block 11
    #####: 3848:      if (y + gh + 1 >= ph) // check if it fits vertically AFTER potentially moving to next row
    %%%%%: 3848-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3849:         return -i;
    %%%%%: 3849-block 13
    #####: 3850:      STBTT_assert(x+gw < pw);
    %%%%%: 3850-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3850-block 15
call    2 never executed
    #####: 3851:      STBTT_assert(y+gh < ph);
    %%%%%: 3851-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3851-block 17
call    2 never executed
    #####: 3852:      stbtt_MakeGlyphBitmap(&f, pixels+x+y*pw, gw,gh,pw, scale,scale, g);
    %%%%%: 3852-block 18
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3853:      chardata[i].x0 = (stbtt_int16) x;
    #####: 3854:      chardata[i].y0 = (stbtt_int16) y;
    #####: 3855:      chardata[i].x1 = (stbtt_int16) (x + gw);
    #####: 3856:      chardata[i].y1 = (stbtt_int16) (y + gh);
    #####: 3857:      chardata[i].xadvance = scale * advance;
    #####: 3858:      chardata[i].xoff     = (float) x0;
    #####: 3859:      chardata[i].yoff     = (float) y0;
    #####: 3860:      x = x + gw + 1;
    #####: 3861:      if (y+gh+1 > bottom_y)
    %%%%%: 3861-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3862:         bottom_y = y+gh+1;
    %%%%%: 3862-block 20
        -: 3863:   }
    #####: 3864:   return bottom_y;
    %%%%%: 3864-block 23
        -: 3865:}
        -: 3866:
function stbtt_GetBakedQuad called 0 returned 0% blocks executed 0%
    #####: 3867:STBTT_DEF void stbtt_GetBakedQuad(const stbtt_bakedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int opengl_fillrule)
        -: 3868:{
    #####: 3869:   float d3d_bias = opengl_fillrule ? 0 : -0.5f;
    %%%%%: 3869-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3869-block 3
    %%%%%: 3869-block 4
    #####: 3870:   float ipw = 1.0f / pw, iph = 1.0f / ph;
    #####: 3871:   const stbtt_bakedchar *b = chardata + char_index;
    #####: 3872:   int round_x = STBTT_ifloor((*xpos + b->xoff) + 0.5f);
    %%%%%: 3872-block 5
call    0 never executed
    #####: 3873:   int round_y = STBTT_ifloor((*ypos + b->yoff) + 0.5f);
call    0 never executed
        -: 3874:
    #####: 3875:   q->x0 = round_x + d3d_bias;
    #####: 3876:   q->y0 = round_y + d3d_bias;
    #####: 3877:   q->x1 = round_x + b->x1 - b->x0 + d3d_bias;
    #####: 3878:   q->y1 = round_y + b->y1 - b->y0 + d3d_bias;
        -: 3879:
    #####: 3880:   q->s0 = b->x0 * ipw;
    #####: 3881:   q->t0 = b->y0 * iph;
    #####: 3882:   q->s1 = b->x1 * ipw;
    #####: 3883:   q->t1 = b->y1 * iph;
        -: 3884:
    #####: 3885:   *xpos += b->xadvance;
    #####: 3886:}
        -: 3887:
        -: 3888://////////////////////////////////////////////////////////////////////////////
        -: 3889://
        -: 3890:// rectangle packing replacement routines if you don't have stb_rect_pack.h
        -: 3891://
        -: 3892:
        -: 3893:#ifndef STB_RECT_PACK_VERSION
        -: 3894:
        -: 3895:typedef int stbrp_coord;
        -: 3896:
        -: 3897:////////////////////////////////////////////////////////////////////////////////////
        -: 3898://                                                                                //
        -: 3899://                                                                                //
        -: 3900:// COMPILER WARNING ?!?!?                                                         //
        -: 3901://                                                                                //
        -: 3902://                                                                                //
        -: 3903:// if you get a compile warning due to these symbols being defined more than      //
        -: 3904:// once, move #include "stb_rect_pack.h" before #include "stb_truetype.h"         //
        -: 3905://                                                                                //
        -: 3906:////////////////////////////////////////////////////////////////////////////////////
        -: 3907:
        -: 3908:typedef struct
        -: 3909:{
        -: 3910:   int width,height;
        -: 3911:   int x,y,bottom_y;
        -: 3912:} stbrp_context;
        -: 3913:
        -: 3914:typedef struct
        -: 3915:{
        -: 3916:   unsigned char x;
        -: 3917:} stbrp_node;
        -: 3918:
        -: 3919:struct stbrp_rect
        -: 3920:{
        -: 3921:   stbrp_coord x,y;
        -: 3922:   int id,w,h,was_packed;
        -: 3923:};
        -: 3924:
        -: 3925:static void stbrp_init_target(stbrp_context *con, int pw, int ph, stbrp_node *nodes, int num_nodes)
        -: 3926:{
        -: 3927:   con->width  = pw;
        -: 3928:   con->height = ph;
        -: 3929:   con->x = 0;
        -: 3930:   con->y = 0;
        -: 3931:   con->bottom_y = 0;
        -: 3932:   STBTT__NOTUSED(nodes);
        -: 3933:   STBTT__NOTUSED(num_nodes);
        -: 3934:}
        -: 3935:
        -: 3936:static void stbrp_pack_rects(stbrp_context *con, stbrp_rect *rects, int num_rects)
        -: 3937:{
        -: 3938:   int i;
        -: 3939:   for (i=0; i < num_rects; ++i) {
        -: 3940:      if (con->x + rects[i].w > con->width) {
        -: 3941:         con->x = 0;
        -: 3942:         con->y = con->bottom_y;
        -: 3943:      }
        -: 3944:      if (con->y + rects[i].h > con->height)
        -: 3945:         break;
        -: 3946:      rects[i].x = con->x;
        -: 3947:      rects[i].y = con->y;
        -: 3948:      rects[i].was_packed = 1;
        -: 3949:      con->x += rects[i].w;
        -: 3950:      if (con->y + rects[i].h > con->bottom_y)
        -: 3951:         con->bottom_y = con->y + rects[i].h;
        -: 3952:   }
        -: 3953:   for (   ; i < num_rects; ++i)
        -: 3954:      rects[i].was_packed = 0;
        -: 3955:}
        -: 3956:#endif
        -: 3957:
        -: 3958://////////////////////////////////////////////////////////////////////////////
        -: 3959://
        -: 3960:// bitmap baking
        -: 3961://
        -: 3962:// This is SUPER-AWESOME (tm Ryan Gordon) packing using stb_rect_pack.h. If
        -: 3963:// stb_rect_pack.h isn't available, it uses the BakeFontBitmap strategy.
        -: 3964:
function stbtt_PackBegin called 1 returned 100% blocks executed 59%
        1: 3965:STBTT_DEF int stbtt_PackBegin(stbtt_pack_context *spc, unsigned char *pixels, int pw, int ph, int stride_in_bytes, int padding, void *alloc_context)
        -: 3966:{
        1: 3967:   stbrp_context *context = (stbrp_context *) STBTT_malloc(sizeof(*context)            ,alloc_context);
        1: 3967-block 2
call    0 returned 1
        1: 3968:   int            num_nodes = pw - padding;
        1: 3969:   stbrp_node    *nodes   = (stbrp_node    *) STBTT_malloc(sizeof(*nodes  ) * num_nodes,alloc_context);
call    0 returned 1
        -: 3970:
        1: 3971:   if (context == NULL || nodes == NULL) {
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 3971-block 5
branch  2 taken 0 (fallthrough)
branch  3 taken 1
    #####: 3972:      if (context != NULL) STBTT_free(context, alloc_context);
    %%%%%: 3972-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3972-block 7
call    2 never executed
    #####: 3973:      if (nodes   != NULL) STBTT_free(nodes  , alloc_context);
    %%%%%: 3973-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3973-block 9
call    2 never executed
    #####: 3974:      return 0;
    %%%%%: 3974-block 10
        -: 3975:   }
        -: 3976:
        1: 3977:   spc->user_allocator_context = alloc_context;
        1: 3978:   spc->width = pw;
        1: 3979:   spc->height = ph;
        1: 3980:   spc->pixels = pixels;
        1: 3981:   spc->pack_info = context;
        1: 3982:   spc->nodes = nodes;
        1: 3983:   spc->padding = padding;
       1*: 3984:   spc->stride_in_bytes = stride_in_bytes != 0 ? stride_in_bytes : pw;
        1: 3984-block 11
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 3984-block 12
        1: 3984-block 13
        1: 3985:   spc->h_oversample = 1;
        1: 3986:   spc->v_oversample = 1;
        1: 3987:   spc->skip_missing = 0;
        -: 3988:
        1: 3989:   stbrp_init_target(context, pw-padding, ph-padding, nodes, num_nodes);
        1: 3989-block 14
call    0 returned 1
        -: 3990:
        1: 3991:   if (pixels)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 3992:      STBTT_memset(pixels, 0, pw*ph); // background of 0 around pixels
    %%%%%: 3992-block 16
        -: 3993:
        1: 3994:   return 1;
        1: 3994-block 17
        -: 3995:}
        -: 3996:
function stbtt_PackEnd called 1 returned 100% blocks executed 100%
        1: 3997:STBTT_DEF void stbtt_PackEnd  (stbtt_pack_context *spc)
        -: 3998:{
        1: 3999:   STBTT_free(spc->nodes    , spc->user_allocator_context);
        1: 3999-block 2
call    0 returned 1
        1: 4000:   STBTT_free(spc->pack_info, spc->user_allocator_context);
call    0 returned 1
        1: 4001:}
        -: 4002:
function stbtt_PackSetOversampling called 0 returned 0% blocks executed 0%
    #####: 4003:STBTT_DEF void stbtt_PackSetOversampling(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample)
        -: 4004:{
    #####: 4005:   STBTT_assert(h_oversample <= STBTT_MAX_OVERSAMPLE);
    %%%%%: 4005-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4005-block 3
call    2 never executed
    #####: 4006:   STBTT_assert(v_oversample <= STBTT_MAX_OVERSAMPLE);
    %%%%%: 4006-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4006-block 5
call    2 never executed
    #####: 4007:   if (h_oversample <= STBTT_MAX_OVERSAMPLE)
    %%%%%: 4007-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4008:      spc->h_oversample = h_oversample;
    %%%%%: 4008-block 7
    #####: 4009:   if (v_oversample <= STBTT_MAX_OVERSAMPLE)
    %%%%%: 4009-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4010:      spc->v_oversample = v_oversample;
    %%%%%: 4010-block 9
    #####: 4011:}
        -: 4012:
function stbtt_PackSetSkipMissingCodepoints called 0 returned 0% blocks executed 0%
    #####: 4013:STBTT_DEF void stbtt_PackSetSkipMissingCodepoints(stbtt_pack_context *spc, int skip)
        -: 4014:{
    #####: 4015:   spc->skip_missing = skip;
    #####: 4016:}
        -: 4017:
        -: 4018:#define STBTT__OVER_MASK  (STBTT_MAX_OVERSAMPLE-1)
        -: 4019:
function _ZL18stbtt__h_prefilterPhiiij called 2157 returned 100% blocks executed 43%
     2157: 4020:static void stbtt__h_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)
        -: 4021:{
        -: 4022:   unsigned char buffer[STBTT_MAX_OVERSAMPLE];
     2157: 4023:   int safe_w = w - kernel_width;
        -: 4024:   int j;
     2157: 4025:   STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze
    27683: 4026:   for (j=0; j < h; ++j) {
     2157: 4026-block 2
    27683: 4026-block 30
branch  0 taken 25526
branch  1 taken 2157 (fallthrough)
        -: 4027:      int i;
        -: 4028:      unsigned int total;
    25526: 4029:      STBTT_memset(buffer, 0, kernel_width);
        -: 4030:
    25526: 4031:      total = 0;
        -: 4032:
        -: 4033:      // make kernel_width a constant in common cases so compiler can optimize out the divide
    25526: 4034:      switch (kernel_width) {
    25526: 4034-block 3
branch  0 taken 25526
branch  1 taken 0
branch  2 taken 0
branch  3 taken 0
branch  4 taken 0
    25526: 4035:         case 2:
   508311: 4036:            for (i=0; i <= safe_w; ++i) {
    25526: 4036-block 4
   508311: 4036-block 6
branch  0 taken 482785
branch  1 taken 25526 (fallthrough)
   482785: 4037:               total += pixels[i] - buffer[i & STBTT__OVER_MASK];
   482785: 4038:               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
   482785: 4039:               pixels[i] = (unsigned char) (total / 2);
   482785: 4039-block 5
        -: 4040:            }
    25526: 4041:            break;
    25526: 4041-block 7
    #####: 4042:         case 3:
    #####: 4043:            for (i=0; i <= safe_w; ++i) {
    %%%%%: 4043-block 8
    %%%%%: 4043-block 10
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4044:               total += pixels[i] - buffer[i & STBTT__OVER_MASK];
    #####: 4045:               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
    #####: 4046:               pixels[i] = (unsigned char) (total / 3);
    %%%%%: 4046-block 9
        -: 4047:            }
    #####: 4048:            break;
    %%%%%: 4048-block 11
    #####: 4049:         case 4:
    #####: 4050:            for (i=0; i <= safe_w; ++i) {
    %%%%%: 4050-block 12
    %%%%%: 4050-block 14
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4051:               total += pixels[i] - buffer[i & STBTT__OVER_MASK];
    #####: 4052:               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
    #####: 4053:               pixels[i] = (unsigned char) (total / 4);
    %%%%%: 4053-block 13
        -: 4054:            }
    #####: 4055:            break;
    %%%%%: 4055-block 15
    #####: 4056:         case 5:
    #####: 4057:            for (i=0; i <= safe_w; ++i) {
    %%%%%: 4057-block 16
    %%%%%: 4057-block 18
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4058:               total += pixels[i] - buffer[i & STBTT__OVER_MASK];
    #####: 4059:               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
    #####: 4060:               pixels[i] = (unsigned char) (total / 5);
    %%%%%: 4060-block 17
        -: 4061:            }
    #####: 4062:            break;
    %%%%%: 4062-block 19
    #####: 4063:         default:
    #####: 4064:            for (i=0; i <= safe_w; ++i) {
    %%%%%: 4064-block 20
    %%%%%: 4064-block 22
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4065:               total += pixels[i] - buffer[i & STBTT__OVER_MASK];
    #####: 4066:               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
    #####: 4067:               pixels[i] = (unsigned char) (total / kernel_width);
    %%%%%: 4067-block 21
        -: 4068:            }
    #####: 4069:            break;
    %%%%%: 4069-block 23
        -: 4070:      }
        -: 4071:
    51052: 4072:      for (; i < w; ++i) {
    25526: 4072-block 24
    51052: 4072-block 28
branch  0 taken 25526
branch  1 taken 25526 (fallthrough)
   25526*: 4073:         STBTT_assert(pixels[i] == 0);
    25526: 4073-block 25
branch  0 taken 0 (fallthrough)
branch  1 taken 25526
    %%%%%: 4073-block 26
call    2 never executed
    25526: 4074:         total -= buffer[i & STBTT__OVER_MASK];
    25526: 4075:         pixels[i] = (unsigned char) (total / kernel_width);
    25526: 4075-block 27
        -: 4076:      }
        -: 4077:
    25526: 4078:      pixels += stride_in_bytes;
    25526: 4078-block 29
        -: 4079:   }
     2157: 4080:}
        -: 4081:
function _ZL18stbtt__v_prefilterPhiiij called 0 returned 0% blocks executed 0%
    #####: 4082:static void stbtt__v_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)
        -: 4083:{
        -: 4084:   unsigned char buffer[STBTT_MAX_OVERSAMPLE];
    #####: 4085:   int safe_h = h - kernel_width;
        -: 4086:   int j;
    #####: 4087:   STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze
    #####: 4088:   for (j=0; j < w; ++j) {
    %%%%%: 4088-block 2
    %%%%%: 4088-block 30
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 4089:      int i;
        -: 4090:      unsigned int total;
    #####: 4091:      STBTT_memset(buffer, 0, kernel_width);
        -: 4092:
    #####: 4093:      total = 0;
        -: 4094:
        -: 4095:      // make kernel_width a constant in common cases so compiler can optimize out the divide
    #####: 4096:      switch (kernel_width) {
    %%%%%: 4096-block 3
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 4097:         case 2:
    #####: 4098:            for (i=0; i <= safe_h; ++i) {
    %%%%%: 4098-block 4
    %%%%%: 4098-block 6
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4099:               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
    #####: 4100:               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
    #####: 4101:               pixels[i*stride_in_bytes] = (unsigned char) (total / 2);
    %%%%%: 4101-block 5
        -: 4102:            }
    #####: 4103:            break;
    %%%%%: 4103-block 7
    #####: 4104:         case 3:
    #####: 4105:            for (i=0; i <= safe_h; ++i) {
    %%%%%: 4105-block 8
    %%%%%: 4105-block 10
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4106:               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
    #####: 4107:               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
    #####: 4108:               pixels[i*stride_in_bytes] = (unsigned char) (total / 3);
    %%%%%: 4108-block 9
        -: 4109:            }
    #####: 4110:            break;
    %%%%%: 4110-block 11
    #####: 4111:         case 4:
    #####: 4112:            for (i=0; i <= safe_h; ++i) {
    %%%%%: 4112-block 12
    %%%%%: 4112-block 14
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4113:               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
    #####: 4114:               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
    #####: 4115:               pixels[i*stride_in_bytes] = (unsigned char) (total / 4);
    %%%%%: 4115-block 13
        -: 4116:            }
    #####: 4117:            break;
    %%%%%: 4117-block 15
    #####: 4118:         case 5:
    #####: 4119:            for (i=0; i <= safe_h; ++i) {
    %%%%%: 4119-block 16
    %%%%%: 4119-block 18
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4120:               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
    #####: 4121:               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
    #####: 4122:               pixels[i*stride_in_bytes] = (unsigned char) (total / 5);
    %%%%%: 4122-block 17
        -: 4123:            }
    #####: 4124:            break;
    %%%%%: 4124-block 19
    #####: 4125:         default:
    #####: 4126:            for (i=0; i <= safe_h; ++i) {
    %%%%%: 4126-block 20
    %%%%%: 4126-block 22
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4127:               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
    #####: 4128:               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
    #####: 4129:               pixels[i*stride_in_bytes] = (unsigned char) (total / kernel_width);
    %%%%%: 4129-block 21
        -: 4130:            }
    #####: 4131:            break;
    %%%%%: 4131-block 23
        -: 4132:      }
        -: 4133:
    #####: 4134:      for (; i < h; ++i) {
    %%%%%: 4134-block 24
    %%%%%: 4134-block 28
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4135:         STBTT_assert(pixels[i*stride_in_bytes] == 0);
    %%%%%: 4135-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4135-block 26
call    2 never executed
    #####: 4136:         total -= buffer[i & STBTT__OVER_MASK];
    #####: 4137:         pixels[i*stride_in_bytes] = (unsigned char) (total / kernel_width);
    %%%%%: 4137-block 27
        -: 4138:      }
        -: 4139:
    #####: 4140:      pixels += 1;
    %%%%%: 4140-block 29
        -: 4141:   }
    #####: 4142:}
        -: 4143:
function _ZL23stbtt__oversample_shifti called 22 returned 100% blocks executed 75%
       22: 4144:static float stbtt__oversample_shift(int oversample)
        -: 4145:{
       22: 4146:   if (!oversample)
       22: 4146-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 22
    #####: 4147:      return 0.0f;
    %%%%%: 4147-block 3
        -: 4148:
        -: 4149:   // The prefilter is a box filter of width "oversample",
        -: 4150:   // which shifts phase by (oversample - 1)/2 pixels in
        -: 4151:   // oversampled space. We want to shift in the opposite
        -: 4152:   // direction to counter this.
       22: 4153:   return (float)-(oversample - 1) / (2.0f * (float)oversample);
       22: 4153-block 4
        -: 4154:}
        -: 4155:
        -: 4156:// rects array must be big enough to accommodate all characters in the given ranges
function stbtt_PackFontRangesGatherRects called 0 returned 0% blocks executed 0%
    #####: 4157:STBTT_DEF int stbtt_PackFontRangesGatherRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)
        -: 4158:{
        -: 4159:   int i,j,k;
    #####: 4160:   int missing_glyph_added = 0;
        -: 4161:
    #####: 4162:   k=0;
    #####: 4163:   for (i=0; i < num_ranges; ++i) {
    %%%%%: 4163-block 2
    %%%%%: 4163-block 20
    %%%%%: 4163-block 21
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4164:      float fh = ranges[i].font_size;
    #####: 4165:      float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);
    %%%%%: 4165-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4165-block 4
call    2 never executed
    %%%%%: 4165-block 5
call    3 never executed
    #####: 4166:      ranges[i].h_oversample = (unsigned char) spc->h_oversample;
    #####: 4167:      ranges[i].v_oversample = (unsigned char) spc->v_oversample;
    #####: 4168:      for (j=0; j < ranges[i].num_chars; ++j) {
    %%%%%: 4168-block 6
    %%%%%: 4168-block 19
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 4169:         int x0,y0,x1,y1;
    #####: 4170:         int codepoint = ranges[i].array_of_unicode_codepoints == NULL ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];
    %%%%%: 4170-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4170-block 8
    %%%%%: 4170-block 9
    #####: 4171:         int glyph = stbtt_FindGlyphIndex(info, codepoint);
    %%%%%: 4171-block 10
call    0 never executed
    #####: 4172:         if (glyph == 0 && (spc->skip_missing || missing_glyph_added)) {
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4172-block 12
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4172-block 13
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 4173:            rects[k].w = rects[k].h = 0;
    %%%%%: 4173-block 14
        -: 4174:         } else {
    #####: 4175:            stbtt_GetGlyphBitmapBoxSubpixel(info,glyph,
    #####: 4176:                                            scale * spc->h_oversample,
    #####: 4177:                                            scale * spc->v_oversample,
    %%%%%: 4177-block 15
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 4178:                                            0,0,
        -: 4179:                                            &x0,&y0,&x1,&y1);
    #####: 4180:            rects[k].w = (stbrp_coord) (x1-x0 + spc->padding + spc->h_oversample-1);
    #####: 4181:            rects[k].h = (stbrp_coord) (y1-y0 + spc->padding + spc->v_oversample-1);
    #####: 4182:            if (glyph == 0)
    %%%%%: 4182-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4183:               missing_glyph_added = 1;
    %%%%%: 4183-block 17
        -: 4184:         }
    #####: 4185:         ++k;
    %%%%%: 4185-block 18
        -: 4186:      }
        -: 4187:   }
        -: 4188:
    #####: 4189:   return k;
    %%%%%: 4189-block 22
    %%%%%: 4189-block 23
        -: 4190:}
        -: 4191:
function stbtt_MakeGlyphBitmapSubpixelPrefilter called 0 returned 0% blocks executed 0%
    #####: 4192:STBTT_DEF void stbtt_MakeGlyphBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int prefilter_x, int prefilter_y, float *sub_x, float *sub_y, int glyph)
        -: 4193:{
    #####: 4194:   stbtt_MakeGlyphBitmapSubpixel(info,
        -: 4195:                                 output,
    #####: 4196:                                 out_w - (prefilter_x - 1),
    #####: 4197:                                 out_h - (prefilter_y - 1),
    %%%%%: 4197-block 2
call    0 never executed
        -: 4198:                                 out_stride,
        -: 4199:                                 scale_x,
        -: 4200:                                 scale_y,
        -: 4201:                                 shift_x,
        -: 4202:                                 shift_y,
        -: 4203:                                 glyph);
        -: 4204:
    #####: 4205:   if (prefilter_x > 1)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4206:      stbtt__h_prefilter(output, out_w, out_h, out_stride, prefilter_x);
    %%%%%: 4206-block 4
call    0 never executed
        -: 4207:
    #####: 4208:   if (prefilter_y > 1)
    %%%%%: 4208-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4209:      stbtt__v_prefilter(output, out_w, out_h, out_stride, prefilter_y);
    %%%%%: 4209-block 6
call    0 never executed
        -: 4210:
    #####: 4211:   *sub_x = stbtt__oversample_shift(prefilter_x);
    %%%%%: 4211-block 7
call    0 never executed
    #####: 4212:   *sub_y = stbtt__oversample_shift(prefilter_y);
call    0 never executed
    #####: 4213:}
        -: 4214:
        -: 4215:// rects array must be big enough to accommodate all characters in the given ranges
function stbtt_PackFontRangesRenderIntoRects called 11 returned 100% blocks executed 69%
       11: 4216:STBTT_DEF int stbtt_PackFontRangesRenderIntoRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)
        -: 4217:{
       11: 4218:   int i,j,k, missing_glyph = -1, return_value = 1;
        -: 4219:
        -: 4220:   // save current values
       11: 4221:   int old_h_over = spc->h_oversample;
       11: 4222:   int old_v_over = spc->v_oversample;
        -: 4223:
       11: 4224:   k = 0;
       22: 4225:   for (i=0; i < num_ranges; ++i) {
       11: 4225-block 2
       11: 4225-block 36
       22: 4225-block 37
branch  0 taken 11
branch  1 taken 11 (fallthrough)
       11: 4226:      float fh = ranges[i].font_size;
      11*: 4227:      float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);
       11: 4227-block 3
branch  0 taken 11 (fallthrough)
branch  1 taken 0
       11: 4227-block 4
call    2 returned 11
    %%%%%: 4227-block 5
call    3 never executed
        -: 4228:      float recip_h,recip_v,sub_x,sub_y;
       11: 4229:      spc->h_oversample = ranges[i].h_oversample;
       11: 4230:      spc->v_oversample = ranges[i].v_oversample;
       11: 4231:      recip_h = 1.0f / spc->h_oversample;
       11: 4232:      recip_v = 1.0f / spc->v_oversample;
       11: 4233:      sub_x = stbtt__oversample_shift(spc->h_oversample);
       11: 4233-block 6
call    0 returned 11
       11: 4234:      sub_y = stbtt__oversample_shift(spc->v_oversample);
call    0 returned 11
     2391: 4235:      for (j=0; j < ranges[i].num_chars; ++j) {
     2391: 4235-block 35
branch  0 taken 2380
branch  1 taken 11 (fallthrough)
     2380: 4236:         stbrp_rect *r = &rects[k];
     2380: 4237:         if (r->was_packed && r->w != 0 && r->h != 0) {
     2380: 4237-block 9
branch  0 taken 2380 (fallthrough)
branch  1 taken 0
     2380: 4237-block 10
branch  2 taken 2380 (fallthrough)
branch  3 taken 0
     2380: 4237-block 11
branch  4 taken 2380 (fallthrough)
branch  5 taken 0
     2380: 4238:            stbtt_packedchar *bc = &ranges[i].chardata_for_range[j];
        -: 4239:            int advance, lsb, x0,y0,x1,y1;
    2380*: 4240:            int codepoint = ranges[i].array_of_unicode_codepoints == NULL ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];
     2380: 4240-block 12
branch  0 taken 0 (fallthrough)
branch  1 taken 2380
    %%%%%: 4240-block 13
     2380: 4240-block 14
     2380: 4241:            int glyph = stbtt_FindGlyphIndex(info, codepoint);
     2380: 4241-block 15
call    0 returned 2380
     2380: 4242:            stbrp_coord pad = (stbrp_coord) spc->padding;
        -: 4243:
        -: 4244:            // pad on left and top
     2380: 4245:            r->x += pad;
     2380: 4246:            r->y += pad;
     2380: 4247:            r->w -= pad;
     2380: 4248:            r->h -= pad;
     2380: 4249:            stbtt_GetGlyphHMetrics(info, glyph, &advance, &lsb);
call    0 returned 2380
     2380: 4250:            stbtt_GetGlyphBitmapBox(info, glyph,
     2380: 4251:                                    scale * spc->h_oversample,
     2380: 4252:                                    scale * spc->v_oversample,
call    0 returned 2380
branch  1 taken 2380 (fallthrough)
branch  2 taken 0 (throw)
        -: 4253:                                    &x0,&y0,&x1,&y1);
     2380: 4254:            stbtt_MakeGlyphBitmapSubpixel(info,
     2380: 4255:                                          spc->pixels + r->x + r->y*spc->stride_in_bytes,
     2380: 4256:                                          r->w - spc->h_oversample+1,
     2380: 4257:                                          r->h - spc->v_oversample+1,
        -: 4258:                                          spc->stride_in_bytes,
     2380: 4259:                                          scale * spc->h_oversample,
     2380: 4260:                                          scale * spc->v_oversample,
     2380: 4260-block 18
call    0 returned 2380
branch  1 taken 2380 (fallthrough)
branch  2 taken 0 (throw)
        -: 4261:                                          0,0,
        -: 4262:                                          glyph);
        -: 4263:
     2380: 4264:            if (spc->h_oversample > 1)
     2380: 4264-block 19
branch  0 taken 2157 (fallthrough)
branch  1 taken 223
     2157: 4265:               stbtt__h_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,
     2157: 4265-block 20
call    0 returned 2157
        -: 4266:                                  r->w, r->h, spc->stride_in_bytes,
        -: 4267:                                  spc->h_oversample);
        -: 4268:
     2380: 4269:            if (spc->v_oversample > 1)
     2380: 4269-block 21
branch  0 taken 0 (fallthrough)
branch  1 taken 2380
    #####: 4270:               stbtt__v_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,
    %%%%%: 4270-block 22
call    0 never executed
        -: 4271:                                  r->w, r->h, spc->stride_in_bytes,
        -: 4272:                                  spc->v_oversample);
        -: 4273:
     2380: 4274:            bc->x0       = (stbtt_int16)  r->x;
     2380: 4275:            bc->y0       = (stbtt_int16)  r->y;
     2380: 4276:            bc->x1       = (stbtt_int16) (r->x + r->w);
     2380: 4277:            bc->y1       = (stbtt_int16) (r->y + r->h);
     2380: 4278:            bc->xadvance =                scale * advance;
     2380: 4279:            bc->xoff     =       (float)  x0 * recip_h + sub_x;
     2380: 4280:            bc->yoff     =       (float)  y0 * recip_v + sub_y;
     2380: 4281:            bc->xoff2    =                (x0 + r->w) * recip_h + sub_x;
     2380: 4282:            bc->yoff2    =                (y0 + r->h) * recip_v + sub_y;
        -: 4283:
     2380: 4284:            if (glyph == 0)
     2380: 4284-block 23
branch  0 taken 0 (fallthrough)
branch  1 taken 2380
    #####: 4285:               missing_glyph = j;
    %%%%%: 4285-block 24
    2380*: 4286:         } else if (spc->skip_missing) {
     2380: 4286-block 25
    %%%%%: 4286-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4287:            return_value = 0;
    %%%%%: 4287-block 27
    #####: 4288:         } else if (r->was_packed && r->w == 0 && r->h == 0 && missing_glyph >= 0) {
    %%%%%: 4288-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4288-block 29
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4288-block 30
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 4288-block 31
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 4289:            ranges[i].chardata_for_range[j] = ranges[i].chardata_for_range[missing_glyph];
    %%%%%: 4289-block 32
        -: 4290:         } else {
    #####: 4291:            return_value = 0; // if any fail, report failure
    %%%%%: 4291-block 33
        -: 4292:         }
        -: 4293:
     2380: 4294:         ++k;
     2380: 4294-block 34
        -: 4295:      }
        -: 4296:   }
        -: 4297:
        -: 4298:   // restore original values
       11: 4299:   spc->h_oversample = old_h_over;
       11: 4300:   spc->v_oversample = old_v_over;
        -: 4301:
       11: 4302:   return return_value;
       11: 4302-block 38
       11: 4302-block 39
        -: 4303:}
        -: 4304:
function stbtt_PackFontRangesPackRects called 0 returned 0% blocks executed 0%
    #####: 4305:STBTT_DEF void stbtt_PackFontRangesPackRects(stbtt_pack_context *spc, stbrp_rect *rects, int num_rects)
        -: 4306:{
    #####: 4307:   stbrp_pack_rects((stbrp_context *) spc->pack_info, rects, num_rects);
    %%%%%: 4307-block 2
call    0 never executed
    #####: 4308:}
        -: 4309:
function stbtt_PackFontRanges called 0 returned 0% blocks executed 0%
    #####: 4310:STBTT_DEF int stbtt_PackFontRanges(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, stbtt_pack_range *ranges, int num_ranges)
        -: 4311:{
        -: 4312:   stbtt_fontinfo info;
        -: 4313:   int i, j, n, return_value; // [DEAR IMGUI] removed = 1;
        -: 4314:   //stbrp_context *context = (stbrp_context *) spc->pack_info;
        -: 4315:   stbrp_rect    *rects;
        -: 4316:
        -: 4317:   // flag all characters as NOT packed
    #####: 4318:   for (i=0; i < num_ranges; ++i)
    %%%%%: 4318-block 2
    %%%%%: 4318-block 6
    %%%%%: 4318-block 7
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4319:      for (j=0; j < ranges[i].num_chars; ++j)
    %%%%%: 4319-block 3
    %%%%%: 4319-block 5
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4320:         ranges[i].chardata_for_range[j].x0 =
    #####: 4321:         ranges[i].chardata_for_range[j].y0 =
    #####: 4322:         ranges[i].chardata_for_range[j].x1 =
    #####: 4323:         ranges[i].chardata_for_range[j].y1 = 0;
    %%%%%: 4323-block 4
        -: 4324:
    #####: 4325:   n = 0;
    #####: 4326:   for (i=0; i < num_ranges; ++i)
    %%%%%: 4326-block 8
    %%%%%: 4326-block 10
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4327:      n += ranges[i].num_chars;
    %%%%%: 4327-block 9
        -: 4328:
    #####: 4329:   rects = (stbrp_rect *) STBTT_malloc(sizeof(*rects) * n, spc->user_allocator_context);
    %%%%%: 4329-block 11
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 4330:   if (rects == NULL)
    %%%%%: 4330-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4331:      return 0;
    %%%%%: 4331-block 13
        -: 4332:
    #####: 4333:   info.userdata = spc->user_allocator_context;
    #####: 4334:   stbtt_InitFont(&info, fontdata, stbtt_GetFontOffsetForIndex(fontdata,font_index));
    %%%%%: 4334-block 14
call    0 never executed
call    1 never executed
        -: 4335:
    #####: 4336:   n = stbtt_PackFontRangesGatherRects(spc, &info, ranges, num_ranges, rects);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 4337:
    #####: 4338:   stbtt_PackFontRangesPackRects(spc, rects, n);
    %%%%%: 4338-block 17
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 4339:
    #####: 4340:   return_value = stbtt_PackFontRangesRenderIntoRects(spc, &info, ranges, num_ranges, rects);
    %%%%%: 4340-block 18
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 4341:
    #####: 4342:   STBTT_free(rects, spc->user_allocator_context);
    %%%%%: 4342-block 19
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 4343:   return return_value;
    %%%%%: 4343-block 20
        -: 4344:}
        -: 4345:
function stbtt_PackFontRange called 0 returned 0% blocks executed 0%
    #####: 4346:STBTT_DEF int stbtt_PackFontRange(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, float font_size,
        -: 4347:            int first_unicode_codepoint_in_range, int num_chars_in_range, stbtt_packedchar *chardata_for_range)
        -: 4348:{
        -: 4349:   stbtt_pack_range range;
    #####: 4350:   range.first_unicode_codepoint_in_range = first_unicode_codepoint_in_range;
    #####: 4351:   range.array_of_unicode_codepoints = NULL;
    #####: 4352:   range.num_chars                   = num_chars_in_range;
    #####: 4353:   range.chardata_for_range          = chardata_for_range;
    #####: 4354:   range.font_size                   = font_size;
    #####: 4355:   return stbtt_PackFontRanges(spc, fontdata, font_index, &range, 1);
    %%%%%: 4355-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 4355-block 3
    %%%%%: 4355-block 5
        -: 4356:}
        -: 4357:
function stbtt_GetScaledFontVMetrics called 0 returned 0% blocks executed 0%
    #####: 4358:STBTT_DEF void stbtt_GetScaledFontVMetrics(const unsigned char *fontdata, int index, float size, float *ascent, float *descent, float *lineGap)
        -: 4359:{
        -: 4360:   int i_ascent, i_descent, i_lineGap;
        -: 4361:   float scale;
        -: 4362:   stbtt_fontinfo info;
    #####: 4363:   stbtt_InitFont(&info, fontdata, stbtt_GetFontOffsetForIndex(fontdata, index));
    %%%%%: 4363-block 2
call    0 never executed
call    1 never executed
    #####: 4364:   scale = size > 0 ? stbtt_ScaleForPixelHeight(&info, size) : stbtt_ScaleForMappingEmToPixels(&info, -size);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4364-block 5
call    2 never executed
    %%%%%: 4364-block 6
call    3 never executed
    #####: 4365:   stbtt_GetFontVMetrics(&info, &i_ascent, &i_descent, &i_lineGap);
    %%%%%: 4365-block 7
call    0 never executed
    #####: 4366:   *ascent  = (float) i_ascent  * scale;
    #####: 4367:   *descent = (float) i_descent * scale;
    #####: 4368:   *lineGap = (float) i_lineGap * scale;
    #####: 4369:}
        -: 4370:
function stbtt_GetPackedQuad called 2380 returned 100% blocks executed 50%
     2380: 4371:STBTT_DEF void stbtt_GetPackedQuad(const stbtt_packedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int align_to_integer)
        -: 4372:{
     2380: 4373:   float ipw = 1.0f / pw, iph = 1.0f / ph;
     2380: 4374:   const stbtt_packedchar *b = chardata + char_index;
        -: 4375:
     2380: 4376:   if (align_to_integer) {
     2380: 4376-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 2380
    #####: 4377:      float x = (float) STBTT_ifloor((*xpos + b->xoff) + 0.5f);
    %%%%%: 4377-block 3
call    0 never executed
    #####: 4378:      float y = (float) STBTT_ifloor((*ypos + b->yoff) + 0.5f);
call    0 never executed
    #####: 4379:      q->x0 = x;
    #####: 4380:      q->y0 = y;
    #####: 4381:      q->x1 = x + b->xoff2 - b->xoff;
    #####: 4382:      q->y1 = y + b->yoff2 - b->yoff;
        -: 4383:   } else {
     2380: 4384:      q->x0 = *xpos + b->xoff;
     2380: 4385:      q->y0 = *ypos + b->yoff;
     2380: 4386:      q->x1 = *xpos + b->xoff2;
     2380: 4387:      q->y1 = *ypos + b->yoff2;
     2380: 4387-block 6
        -: 4388:   }
        -: 4389:
     2380: 4390:   q->s0 = b->x0 * ipw;
     2380: 4391:   q->t0 = b->y0 * iph;
     2380: 4392:   q->s1 = b->x1 * ipw;
     2380: 4393:   q->t1 = b->y1 * iph;
        -: 4394:
     2380: 4395:   *xpos += b->xadvance;
     2380: 4396:}
        -: 4397:
        -: 4398://////////////////////////////////////////////////////////////////////////////
        -: 4399://
        -: 4400:// sdf computation
        -: 4401://
        -: 4402:
        -: 4403:#define STBTT_min(a,b)  ((a) < (b) ? (a) : (b))
        -: 4404:#define STBTT_max(a,b)  ((a) < (b) ? (b) : (a))
        -: 4405:
function _ZL27stbtt__ray_intersect_bezierPfS_S_S_S_PA2_f called 0 returned 0% blocks executed 0%
    #####: 4406:static int stbtt__ray_intersect_bezier(float orig[2], float ray[2], float q0[2], float q1[2], float q2[2], float hits[2][2])
        -: 4407:{
    #####: 4408:   float q0perp = q0[1]*ray[0] - q0[0]*ray[1];
    #####: 4409:   float q1perp = q1[1]*ray[0] - q1[0]*ray[1];
    #####: 4410:   float q2perp = q2[1]*ray[0] - q2[0]*ray[1];
    #####: 4411:   float roperp = orig[1]*ray[0] - orig[0]*ray[1];
        -: 4412:
    #####: 4413:   float a = q0perp - 2*q1perp + q2perp;
    #####: 4414:   float b = q1perp - q0perp;
    #####: 4415:   float c = q0perp - roperp;
        -: 4416:
    #####: 4417:   float s0 = 0., s1 = 0.;
    #####: 4418:   int num_s = 0;
        -: 4419:
    #####: 4420:   if (a != 0.0) {
    %%%%%: 4420-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4421:      float discr = b*b - a*c;
    #####: 4422:      if (discr > 0.0) {
    %%%%%: 4422-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4423:         float rcpna = -1 / a;
    #####: 4424:         float d = (float) STBTT_sqrt(discr);
    #####: 4425:         s0 = (b+d) * rcpna;
    #####: 4426:         s1 = (b-d) * rcpna;
    #####: 4427:         if (s0 >= 0.0 && s0 <= 1.0)
    %%%%%: 4427-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4427-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4428:            num_s = 1;
    %%%%%: 4428-block 6
    #####: 4429:         if (d > 0.0 && s1 >= 0.0 && s1 <= 1.0) {
    %%%%%: 4429-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4429-block 8
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4429-block 9
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 4430:            if (num_s == 0) s0 = s1;
    %%%%%: 4430-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4430-block 11
    #####: 4431:            ++num_s;
    %%%%%: 4431-block 12
        -: 4432:         }
        -: 4433:      }
        -: 4434:   } else {
        -: 4435:      // 2*b*s + c = 0
        -: 4436:      // s = -c / (2*b)
    #####: 4437:      s0 = c / (-2 * b);
    #####: 4438:      if (s0 >= 0.0 && s0 <= 1.0)
    %%%%%: 4438-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4438-block 14
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4439:         num_s = 1;
    %%%%%: 4439-block 15
        -: 4440:   }
        -: 4441:
    #####: 4442:   if (num_s == 0)
    %%%%%: 4442-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4443:      return 0;
    %%%%%: 4443-block 17
        -: 4444:   else {
    #####: 4445:      float rcp_len2 = 1 / (ray[0]*ray[0] + ray[1]*ray[1]);
    #####: 4446:      float rayn_x = ray[0] * rcp_len2, rayn_y = ray[1] * rcp_len2;
        -: 4447:
    #####: 4448:      float q0d =   q0[0]*rayn_x +   q0[1]*rayn_y;
    #####: 4449:      float q1d =   q1[0]*rayn_x +   q1[1]*rayn_y;
    #####: 4450:      float q2d =   q2[0]*rayn_x +   q2[1]*rayn_y;
    #####: 4451:      float rod = orig[0]*rayn_x + orig[1]*rayn_y;
        -: 4452:
    #####: 4453:      float q10d = q1d - q0d;
    #####: 4454:      float q20d = q2d - q0d;
    #####: 4455:      float q0rd = q0d - rod;
        -: 4456:
    #####: 4457:      hits[0][0] = q0rd + s0*(2.0f - 2.0f*s0)*q10d + s0*s0*q20d;
    #####: 4458:      hits[0][1] = a*s0+b;
        -: 4459:
    #####: 4460:      if (num_s > 1) {
    %%%%%: 4460-block 18
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4461:         hits[1][0] = q0rd + s1*(2.0f - 2.0f*s1)*q10d + s1*s1*q20d;
    #####: 4462:         hits[1][1] = a*s1+b;
    #####: 4463:         return 2;
    %%%%%: 4463-block 19
        -: 4464:      } else {
    #####: 4465:         return 1;
    %%%%%: 4465-block 20
        -: 4466:      }
        -: 4467:   }
        -: 4468:}
        -: 4469:
function _ZL5equalPfS_ called 0 returned 0% blocks executed 0%
    #####: 4470:static int equal(float *a, float *b)
        -: 4471:{
    #####: 4472:   return (a[0] == b[0] && a[1] == b[1]);
    %%%%%: 4472-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4472-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4472-block 4
    %%%%%: 4472-block 5
    %%%%%: 4472-block 6
        -: 4473:}
        -: 4474:
function _ZL26stbtt__compute_crossings_xffiP12stbtt_vertex called 0 returned 0% blocks executed 0%
    #####: 4475:static int stbtt__compute_crossings_x(float x, float y, int nverts, stbtt_vertex *verts)
        -: 4476:{
        -: 4477:   int i;
    #####: 4478:   float orig[2], ray[2] = { 1, 0 };
        -: 4479:   float y_frac;
    #####: 4480:   int winding = 0;
        -: 4481:
        -: 4482:   // make sure y never passes through a vertex of the shape
    #####: 4483:   y_frac = (float) STBTT_fmod(y, 1.0f);
    #####: 4484:   if (y_frac < 0.01f)
    %%%%%: 4484-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4485:      y += 0.01f;
    %%%%%: 4485-block 3
    #####: 4486:   else if (y_frac > 0.99f)
    %%%%%: 4486-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4487:      y -= 0.01f;
    %%%%%: 4487-block 5
        -: 4488:
    #####: 4489:   orig[0] = x;
    #####: 4490:   orig[1] = y;
        -: 4491:
        -: 4492:   // test a ray from (-infinity,y) to (x,y)
    #####: 4493:   for (i=0; i < nverts; ++i) {
    %%%%%: 4493-block 6
    %%%%%: 4493-block 94
    %%%%%: 4493-block 95
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4494:      if (verts[i].type == STBTT_vline) {
    %%%%%: 4494-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4495:         int x0 = (int) verts[i-1].x, y0 = (int) verts[i-1].y;
    #####: 4496:         int x1 = (int) verts[i  ].x, y1 = (int) verts[i  ].y;
    #####: 4497:         if (y > STBTT_min(y0,y1) && y < STBTT_max(y0,y1) && x > STBTT_min(x0,x1)) {
    %%%%%: 4497-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4497-block 9
    %%%%%: 4497-block 10
    %%%%%: 4497-block 11
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4497-block 12
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 4497-block 13
    %%%%%: 4497-block 14
    %%%%%: 4497-block 15
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 4497-block 16
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%: 4497-block 17
    %%%%%: 4497-block 18
    %%%%%: 4497-block 19
branch 10 never executed (fallthrough)
branch 11 never executed
    #####: 4498:            float x_inter = (y - y0) / (y1 - y0) * (x1-x0) + x0;
    #####: 4499:            if (x_inter < x)
    %%%%%: 4499-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4500:               winding += (y0 < y1) ? 1 : -1;
    %%%%%: 4500-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4500-block 22
    %%%%%: 4500-block 23
    %%%%%: 4500-block 24
        -: 4501:         }
        -: 4502:      }
    #####: 4503:      if (verts[i].type == STBTT_vcurve) {
    %%%%%: 4503-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4504:         int x0 = (int) verts[i-1].x , y0 = (int) verts[i-1].y ;
    #####: 4505:         int x1 = (int) verts[i  ].cx, y1 = (int) verts[i  ].cy;
    #####: 4506:         int x2 = (int) verts[i  ].x , y2 = (int) verts[i  ].y ;
    #####: 4507:         int ax = STBTT_min(x0,STBTT_min(x1,x2)), ay = STBTT_min(y0,STBTT_min(y1,y2));
    %%%%%: 4507-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4507-block 27
    %%%%%: 4507-block 28
    %%%%%: 4507-block 29
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4507-block 30
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 4507-block 31
    %%%%%: 4507-block 32
    %%%%%: 4507-block 33
    %%%%%: 4507-block 34
    %%%%%: 4507-block 35
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 4507-block 36
    %%%%%: 4507-block 37
    %%%%%: 4507-block 38
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%: 4507-block 39
branch 10 never executed (fallthrough)
branch 11 never executed
    %%%%%: 4507-block 40
    %%%%%: 4507-block 41
    %%%%%: 4507-block 42
    %%%%%: 4507-block 43
    #####: 4508:         int by = STBTT_max(y0,STBTT_max(y1,y2));
    %%%%%: 4508-block 44
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4508-block 45
    %%%%%: 4508-block 46
    %%%%%: 4508-block 47
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4508-block 48
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 4508-block 49
    %%%%%: 4508-block 50
    %%%%%: 4508-block 51
    %%%%%: 4508-block 52
    #####: 4509:         if (y > ay && y < by && x > ax) {
    %%%%%: 4509-block 53
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4509-block 54
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4509-block 55
branch  4 never executed (fallthrough)
branch  5 never executed
        -: 4510:            float q0[2],q1[2],q2[2];
        -: 4511:            float hits[2][2];
    #####: 4512:            q0[0] = (float)x0;
    #####: 4513:            q0[1] = (float)y0;
    #####: 4514:            q1[0] = (float)x1;
    #####: 4515:            q1[1] = (float)y1;
    #####: 4516:            q2[0] = (float)x2;
    #####: 4517:            q2[1] = (float)y2;
    #####: 4518:            if (equal(q0,q1) || equal(q1,q2)) {
    %%%%%: 4518-block 56
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 4518-block 58
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 4518-block 60
    %%%%%: 4518-block 61
    %%%%%: 4518-block 62
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 4519:               x0 = (int)verts[i-1].x;
    #####: 4520:               y0 = (int)verts[i-1].y;
    #####: 4521:               x1 = (int)verts[i  ].x;
    #####: 4522:               y1 = (int)verts[i  ].y;
    #####: 4523:               if (y > STBTT_min(y0,y1) && y < STBTT_max(y0,y1) && x > STBTT_min(x0,x1)) {
    %%%%%: 4523-block 63
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4523-block 64
    %%%%%: 4523-block 65
    %%%%%: 4523-block 66
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4523-block 67
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 4523-block 68
    %%%%%: 4523-block 69
    %%%%%: 4523-block 70
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 4523-block 71
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%: 4523-block 72
    %%%%%: 4523-block 73
    %%%%%: 4523-block 74
branch 10 never executed (fallthrough)
branch 11 never executed
    #####: 4524:                  float x_inter = (y - y0) / (y1 - y0) * (x1-x0) + x0;
    #####: 4525:                  if (x_inter < x)
    %%%%%: 4525-block 75
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4526:                     winding += (y0 < y1) ? 1 : -1;
    %%%%%: 4526-block 76
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4526-block 77
    %%%%%: 4526-block 78
    %%%%%: 4526-block 79
        -: 4527:               }
        -: 4528:            } else {
    #####: 4529:               int num_hits = stbtt__ray_intersect_bezier(orig, ray, q0, q1, q2, hits);
    %%%%%: 4529-block 80
call    0 never executed
    #####: 4530:               if (num_hits >= 1)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4531:                  if (hits[0][0] < 0)
    %%%%%: 4531-block 82
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4532:                     winding += (hits[0][1] < 0 ? -1 : 1);
    %%%%%: 4532-block 83
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4532-block 84
    %%%%%: 4532-block 85
    %%%%%: 4532-block 86
    #####: 4533:               if (num_hits >= 2)
    %%%%%: 4533-block 87
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4534:                  if (hits[1][0] < 0)
    %%%%%: 4534-block 88
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4535:                     winding += (hits[1][1] < 0 ? -1 : 1);
    %%%%%: 4535-block 89
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4535-block 90
    %%%%%: 4535-block 91
    %%%%%: 4535-block 92
        -: 4536:            }
        -: 4537:         }
        -: 4538:      }
        -: 4539:   }
    #####: 4540:   return winding;
    %%%%%: 4540-block 96
        -: 4541:}
        -: 4542:
function _ZL15stbtt__cuberootf called 0 returned 0% blocks executed 0%
    #####: 4543:static float stbtt__cuberoot( float x )
        -: 4544:{
    #####: 4545:   if (x<0)
    %%%%%: 4545-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4546:      return -(float) STBTT_pow(-x,1.0f/3.0f);
    %%%%%: 4546-block 3
call    0 never executed
        -: 4547:   else
    #####: 4548:      return  (float) STBTT_pow( x,1.0f/3.0f);
    %%%%%: 4548-block 5
call    0 never executed
        -: 4549:}
        -: 4550:
        -: 4551:// x^3 + a*x^2 + b*x + c = 0
function _ZL18stbtt__solve_cubicfffPf called 0 returned 0% blocks executed 0%
    #####: 4552:static int stbtt__solve_cubic(float a, float b, float c, float* r)
        -: 4553:{
    #####: 4554:   float s = -a / 3;
    #####: 4555:   float p = b - a*a / 3;
    #####: 4556:   float q = a * (2*a*a - 9*b) / 27 + c;
    #####: 4557:   float p3 = p*p*p;
    #####: 4558:   float d = q*q + 4*p3 / 27;
    #####: 4559:   if (d >= 0) {
    %%%%%: 4559-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4560:      float z = (float) STBTT_sqrt(d);
    #####: 4561:      float u = (-q + z) / 2;
    #####: 4562:      float v = (-q - z) / 2;
    #####: 4563:      u = stbtt__cuberoot(u);
    %%%%%: 4563-block 3
call    0 never executed
    #####: 4564:      v = stbtt__cuberoot(v);
call    0 never executed
    #####: 4565:      r[0] = s + u + v;
    #####: 4566:      return 1;
        -: 4567:   } else {
    #####: 4568:      float u = (float) STBTT_sqrt(-p/3);
    #####: 4569:      float v = (float) STBTT_acos(-STBTT_sqrt(-27/p3) * q / 2) / 3; // p3 must be negative, since d is negative
    %%%%%: 4569-block 6
call    0 never executed
    #####: 4570:      float m = (float) STBTT_cos(v);
call    0 never executed
    #####: 4571:      float n = (float) STBTT_cos(v-3.141592/2)*1.732050808f;
    #####: 4572:      r[0] = s + u * 2 * m;
    #####: 4573:      r[1] = s - u * (m + n);
    #####: 4574:      r[2] = s - u * (m - n);
        -: 4575:
        -: 4576:      //STBTT_assert( STBTT_fabs(((r[0]+a)*r[0]+b)*r[0]+c) < 0.05f);  // these asserts may not be safe at all scales, though they're in bezier t parameter units so maybe?
        -: 4577:      //STBTT_assert( STBTT_fabs(((r[1]+a)*r[1]+b)*r[1]+c) < 0.05f);
        -: 4578:      //STBTT_assert( STBTT_fabs(((r[2]+a)*r[2]+b)*r[2]+c) < 0.05f);
    #####: 4579:      return 3;
        -: 4580:   }
        -: 4581:}
        -: 4582:
function stbtt_GetGlyphSDF called 0 returned 0% blocks executed 0%
    #####: 4583:STBTT_DEF unsigned char * stbtt_GetGlyphSDF(const stbtt_fontinfo *info, float scale, int glyph, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff)
        -: 4584:{
    #####: 4585:   float scale_x = scale, scale_y = scale;
        -: 4586:   int ix0,iy0,ix1,iy1;
        -: 4587:   int w,h;
        -: 4588:   unsigned char *data;
        -: 4589:
    #####: 4590:   if (scale == 0) return NULL;
    %%%%%: 4590-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4590-block 3
        -: 4591:
    #####: 4592:   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale, scale, 0.0f,0.0f, &ix0,&iy0,&ix1,&iy1);
    %%%%%: 4592-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 4593:
        -: 4594:   // if empty, return NULL
    #####: 4595:   if (ix0 == ix1 || iy0 == iy1)
    %%%%%: 4595-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4595-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4596:      return NULL;
    %%%%%: 4596-block 7
        -: 4597:
    #####: 4598:   ix0 -= padding;
    #####: 4599:   iy0 -= padding;
    #####: 4600:   ix1 += padding;
    #####: 4601:   iy1 += padding;
        -: 4602:
    #####: 4603:   w = (ix1 - ix0);
    #####: 4604:   h = (iy1 - iy0);
        -: 4605:
    #####: 4606:   if (width ) *width  = w;
    %%%%%: 4606-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4606-block 9
    #####: 4607:   if (height) *height = h;
    %%%%%: 4607-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4607-block 11
    #####: 4608:   if (xoff  ) *xoff   = ix0;
    %%%%%: 4608-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4608-block 13
    #####: 4609:   if (yoff  ) *yoff   = iy0;
    %%%%%: 4609-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4609-block 15
        -: 4610:
        -: 4611:   // invert for y-downwards bitmaps
    #####: 4612:   scale_y = -scale_y;
        -: 4613:
        -: 4614:   {
        -: 4615:      int x,y,i,j;
        -: 4616:      float *precompute;
        -: 4617:      stbtt_vertex *verts;
    #####: 4618:      int num_verts = stbtt_GetGlyphShape(info, glyph, &verts);
    %%%%%: 4618-block 16
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 4619:      data = (unsigned char *) STBTT_malloc(w * h, info->userdata);
    %%%%%: 4619-block 17
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 4620:      precompute = (float *) STBTT_malloc(num_verts * sizeof(float), info->userdata);
    %%%%%: 4620-block 18
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 4621:
    #####: 4622:      for (i=0,j=num_verts-1; i < num_verts; j=i++) {
    %%%%%: 4622-block 19
    %%%%%: 4622-block 30
    %%%%%: 4622-block 31
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4623:         if (verts[i].type == STBTT_vline) {
    %%%%%: 4623-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4624:            float x0 = verts[i].x*scale_x, y0 = verts[i].y*scale_y;
    #####: 4625:            float x1 = verts[j].x*scale_x, y1 = verts[j].y*scale_y;
    #####: 4626:            float dist = (float) STBTT_sqrt((x1-x0)*(x1-x0) + (y1-y0)*(y1-y0));
    #####: 4627:            precompute[i] = (dist == 0) ? 0.0f : 1.0f / dist;
    %%%%%: 4627-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4627-block 22
    %%%%%: 4627-block 23
    %%%%%: 4627-block 24
    #####: 4628:         } else if (verts[i].type == STBTT_vcurve) {
    %%%%%: 4628-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4629:            float x2 = verts[j].x *scale_x, y2 = verts[j].y *scale_y;
    #####: 4630:            float x1 = verts[i].cx*scale_x, y1 = verts[i].cy*scale_y;
    #####: 4631:            float x0 = verts[i].x *scale_x, y0 = verts[i].y *scale_y;
    #####: 4632:            float bx = x0 - 2*x1 + x2, by = y0 - 2*y1 + y2;
    #####: 4633:            float len2 = bx*bx + by*by;
    #####: 4634:            if (len2 != 0.0f)
    %%%%%: 4634-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4635:               precompute[i] = 1.0f / (bx*bx + by*by);
    %%%%%: 4635-block 27
        -: 4636:            else
    #####: 4637:               precompute[i] = 0.0f;
    %%%%%: 4637-block 28
        -: 4638:         } else
    #####: 4639:            precompute[i] = 0.0f;
    %%%%%: 4639-block 29
        -: 4640:      }
        -: 4641:
    #####: 4642:      for (y=iy0; y < iy1; ++y) {
    %%%%%: 4642-block 32
    %%%%%: 4642-block 124
    %%%%%: 4642-block 125
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4643:         for (x=ix0; x < ix1; ++x) {
    %%%%%: 4643-block 33
    %%%%%: 4643-block 123
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 4644:            float val;
    #####: 4645:            float min_dist = 999999.0f;
    #####: 4646:            float sx = (float) x + 0.5f;
    #####: 4647:            float sy = (float) y + 0.5f;
    #####: 4648:            float x_gspace = (sx / scale_x);
    #####: 4649:            float y_gspace = (sy / scale_y);
        -: 4650:
    #####: 4651:            int winding = stbtt__compute_crossings_x(x_gspace, y_gspace, num_verts, verts); // @OPTIMIZE: this could just be a rasterization, but needs to be line vs. non-tesselated curves so a new path
    %%%%%: 4651-block 34
call    0 never executed
        -: 4652:
    #####: 4653:            for (i=0; i < num_verts; ++i) {
    %%%%%: 4653-block 114
    %%%%%: 4653-block 115
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4654:               float x0 = verts[i].x*scale_x, y0 = verts[i].y*scale_y;
        -: 4655:
    #####: 4656:               if (verts[i].type == STBTT_vline && precompute[i] != 0.0f) {
    %%%%%: 4656-block 36
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4656-block 37
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4657:                  float x1 = verts[i-1].x*scale_x, y1 = verts[i-1].y*scale_y;
        -: 4658:
    #####: 4659:                  float dist,dist2 = (x0-sx)*(x0-sx) + (y0-sy)*(y0-sy);
    #####: 4660:                  if (dist2 < min_dist*min_dist)
    %%%%%: 4660-block 38
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4661:                     min_dist = (float) STBTT_sqrt(dist2);
    %%%%%: 4661-block 39
        -: 4662:
        -: 4663:                  // coarse culling against bbox
        -: 4664:                  //if (sx > STBTT_min(x0,x1)-min_dist && sx < STBTT_max(x0,x1)+min_dist &&
        -: 4665:                  //    sy > STBTT_min(y0,y1)-min_dist && sy < STBTT_max(y0,y1)+min_dist)
    #####: 4666:                  dist = (float) STBTT_fabs((x1-x0)*(y0-sy) - (y1-y0)*(x0-sx)) * precompute[i];
    #####: 4667:                  STBTT_assert(i != 0);
    %%%%%: 4667-block 40
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4667-block 41
call    2 never executed
    #####: 4668:                  if (dist < min_dist) {
    %%%%%: 4668-block 42
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4669:                     // check position along line
        -: 4670:                     // x' = x0 + t*(x1-x0), y' = y0 + t*(y1-y0)
        -: 4671:                     // minimize (x'-sx)*(x'-sx)+(y'-sy)*(y'-sy)
    #####: 4672:                     float dx = x1-x0, dy = y1-y0;
    #####: 4673:                     float px = x0-sx, py = y0-sy;
        -: 4674:                     // minimize (px+t*dx)^2 + (py+t*dy)^2 = px*px + 2*px*dx*t + t^2*dx*dx + py*py + 2*py*dy*t + t^2*dy*dy
        -: 4675:                     // derivative: 2*px*dx + 2*py*dy + (2*dx*dx+2*dy*dy)*t, set to 0 and solve
    #####: 4676:                     float t = -(px*dx + py*dy) / (dx*dx + dy*dy);
    #####: 4677:                     if (t >= 0.0f && t <= 1.0f)
    %%%%%: 4677-block 43
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4677-block 44
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4678:                        min_dist = dist;
    %%%%%: 4678-block 45
        -: 4679:                  }
    #####: 4680:               } else if (verts[i].type == STBTT_vcurve) {
    %%%%%: 4680-block 46
    %%%%%: 4680-block 47
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4681:                  float x2 = verts[i-1].x *scale_x, y2 = verts[i-1].y *scale_y;
    #####: 4682:                  float x1 = verts[i  ].cx*scale_x, y1 = verts[i  ].cy*scale_y;
    #####: 4683:                  float box_x0 = STBTT_min(STBTT_min(x0,x1),x2);
    %%%%%: 4683-block 48
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4683-block 49
    %%%%%: 4683-block 50
    %%%%%: 4683-block 51
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4683-block 52
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 4683-block 53
    %%%%%: 4683-block 54
    %%%%%: 4683-block 55
    %%%%%: 4683-block 56
    #####: 4684:                  float box_y0 = STBTT_min(STBTT_min(y0,y1),y2);
    %%%%%: 4684-block 57
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4684-block 58
    %%%%%: 4684-block 59
    %%%%%: 4684-block 60
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4684-block 61
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 4684-block 62
    %%%%%: 4684-block 63
    %%%%%: 4684-block 64
    %%%%%: 4684-block 65
    #####: 4685:                  float box_x1 = STBTT_max(STBTT_max(x0,x1),x2);
    %%%%%: 4685-block 66
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4685-block 67
    %%%%%: 4685-block 68
    %%%%%: 4685-block 69
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4685-block 70
    %%%%%: 4685-block 71
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 4685-block 72
    %%%%%: 4685-block 73
    %%%%%: 4685-block 74
    #####: 4686:                  float box_y1 = STBTT_max(STBTT_max(y0,y1),y2);
    %%%%%: 4686-block 75
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4686-block 76
    %%%%%: 4686-block 77
    %%%%%: 4686-block 78
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4686-block 79
    %%%%%: 4686-block 80
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 4686-block 81
    %%%%%: 4686-block 82
    %%%%%: 4686-block 83
        -: 4687:                  // coarse culling against bbox to avoid computing cubic unnecessarily
    #####: 4688:                  if (sx > box_x0-min_dist && sx < box_x1+min_dist && sy > box_y0-min_dist && sy < box_y1+min_dist) {
    %%%%%: 4688-block 84
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4688-block 85
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4688-block 86
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 4688-block 87
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 4689:                     int num=0;
    #####: 4690:                     float ax = x1-x0, ay = y1-y0;
    #####: 4691:                     float bx = x0 - 2*x1 + x2, by = y0 - 2*y1 + y2;
    #####: 4692:                     float mx = x0 - sx, my = y0 - sy;
    #####: 4693:                     float res[3] = {0.f,0.f,0.f};
        -: 4694:                     float px,py,t,it,dist2;
    #####: 4695:                     float a_inv = precompute[i];
    #####: 4696:                     if (a_inv == 0.0) { // if a_inv is 0, it's 2nd degree so use quadratic formula
    %%%%%: 4696-block 88
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4697:                        float a = 3*(ax*bx + ay*by);
    #####: 4698:                        float b = 2*(ax*ax + ay*ay) + (mx*bx+my*by);
    #####: 4699:                        float c = mx*ax+my*ay;
    #####: 4700:                        if (a == 0.0) { // if a is 0, it's linear
    %%%%%: 4700-block 89
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4701:                           if (b != 0.0) {
    %%%%%: 4701-block 90
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4702:                              res[num++] = -c/b;
    %%%%%: 4702-block 91
        -: 4703:                           }
        -: 4704:                        } else {
    #####: 4705:                           float discriminant = b*b - 4*a*c;
    #####: 4706:                           if (discriminant < 0)
    %%%%%: 4706-block 92
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4707:                              num = 0;
    %%%%%: 4707-block 93
        -: 4708:                           else {
    #####: 4709:                              float root = (float) STBTT_sqrt(discriminant);
    #####: 4710:                              res[0] = (-b - root)/(2*a);
    #####: 4711:                              res[1] = (-b + root)/(2*a);
    #####: 4712:                              num = 2; // don't bother distinguishing 1-solution case, as code below will still work
    %%%%%: 4712-block 94
        -: 4713:                           }
        -: 4714:                        }
        -: 4715:                     } else {
    #####: 4716:                        float b = 3*(ax*bx + ay*by) * a_inv; // could precompute this as it doesn't depend on sample point
    #####: 4717:                        float c = (2*(ax*ax + ay*ay) + (mx*bx+my*by)) * a_inv;
    #####: 4718:                        float d = (mx*ax+my*ay) * a_inv;
    #####: 4719:                        num = stbtt__solve_cubic(b, c, d, res);
    %%%%%: 4719-block 95
call    0 never executed
        -: 4720:                     }
    #####: 4721:                     dist2 = (x0-sx)*(x0-sx) + (y0-sy)*(y0-sy);
    #####: 4722:                     if (dist2 < min_dist*min_dist)
    %%%%%: 4722-block 96
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4723:                        min_dist = (float) STBTT_sqrt(dist2);
    %%%%%: 4723-block 97
        -: 4724:
    #####: 4725:                     if (num >= 1 && res[0] >= 0.0f && res[0] <= 1.0f) {
    %%%%%: 4725-block 98
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4725-block 99
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4725-block 100
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 4726:                        t = res[0], it = 1.0f - t;
    #####: 4727:                        px = it*it*x0 + 2*t*it*x1 + t*t*x2;
    #####: 4728:                        py = it*it*y0 + 2*t*it*y1 + t*t*y2;
    #####: 4729:                        dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);
    #####: 4730:                        if (dist2 < min_dist * min_dist)
    %%%%%: 4730-block 101
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4731:                           min_dist = (float) STBTT_sqrt(dist2);
    %%%%%: 4731-block 102
        -: 4732:                     }
    #####: 4733:                     if (num >= 2 && res[1] >= 0.0f && res[1] <= 1.0f) {
    %%%%%: 4733-block 103
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4733-block 104
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4733-block 105
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 4734:                        t = res[1], it = 1.0f - t;
    #####: 4735:                        px = it*it*x0 + 2*t*it*x1 + t*t*x2;
    #####: 4736:                        py = it*it*y0 + 2*t*it*y1 + t*t*y2;
    #####: 4737:                        dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);
    #####: 4738:                        if (dist2 < min_dist * min_dist)
    %%%%%: 4738-block 106
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4739:                           min_dist = (float) STBTT_sqrt(dist2);
    %%%%%: 4739-block 107
        -: 4740:                     }
    #####: 4741:                     if (num >= 3 && res[2] >= 0.0f && res[2] <= 1.0f) {
    %%%%%: 4741-block 108
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4741-block 109
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4741-block 110
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 4742:                        t = res[2], it = 1.0f - t;
    #####: 4743:                        px = it*it*x0 + 2*t*it*x1 + t*t*x2;
    #####: 4744:                        py = it*it*y0 + 2*t*it*y1 + t*t*y2;
    #####: 4745:                        dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);
    #####: 4746:                        if (dist2 < min_dist * min_dist)
    %%%%%: 4746-block 111
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4747:                           min_dist = (float) STBTT_sqrt(dist2);
    %%%%%: 4747-block 112
        -: 4748:                     }
        -: 4749:                  }
        -: 4750:               }
        -: 4751:            }
    #####: 4752:            if (winding == 0)
    %%%%%: 4752-block 116
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4753:               min_dist = -min_dist;  // if outside the shape, value is negative
    %%%%%: 4753-block 117
    #####: 4754:            val = onedge_value + pixel_dist_scale * min_dist;
    #####: 4755:            if (val < 0)
    %%%%%: 4755-block 118
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4756:               val = 0;
    %%%%%: 4756-block 119
    #####: 4757:            else if (val > 255)
    %%%%%: 4757-block 120
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4758:               val = 255;
    %%%%%: 4758-block 121
    #####: 4759:            data[(y-iy0)*w+(x-ix0)] = (unsigned char) val;
    %%%%%: 4759-block 122
        -: 4760:         }
        -: 4761:      }
    #####: 4762:      STBTT_free(precompute, info->userdata);
    %%%%%: 4762-block 126
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 4763:      STBTT_free(verts, info->userdata);
    %%%%%: 4763-block 127
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 4764:   }
    #####: 4765:   return data;
    %%%%%: 4765-block 128
        -: 4766:}
        -: 4767:
function stbtt_GetCodepointSDF called 0 returned 0% blocks executed 0%
    #####: 4768:STBTT_DEF unsigned char * stbtt_GetCodepointSDF(const stbtt_fontinfo *info, float scale, int codepoint, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff)
        -: 4769:{
    #####: 4770:   return stbtt_GetGlyphSDF(info, scale, stbtt_FindGlyphIndex(info, codepoint), padding, onedge_value, pixel_dist_scale, width, height, xoff, yoff);
    %%%%%: 4770-block 2
call    0 never executed
call    1 never executed
        -: 4771:}
        -: 4772:
function stbtt_FreeSDF called 0 returned 0% blocks executed 0%
    #####: 4773:STBTT_DEF void stbtt_FreeSDF(unsigned char *bitmap, void *userdata)
        -: 4774:{
    #####: 4775:   STBTT_free(bitmap, userdata);
    %%%%%: 4775-block 2
call    0 never executed
    #####: 4776:}
        -: 4777:
        -: 4778://////////////////////////////////////////////////////////////////////////////
        -: 4779://
        -: 4780:// font name matching -- recommended not to use this
        -: 4781://
        -: 4782:
        -: 4783:// check if a utf8 string contains a prefix which is the utf16 string; if so return length of matching utf8 string
function _ZL42stbtt__CompareUTF8toUTF16_bigendian_prefixPhiS_i called 0 returned 0% blocks executed 0%
    #####: 4784:static stbtt_int32 stbtt__CompareUTF8toUTF16_bigendian_prefix(stbtt_uint8 *s1, stbtt_int32 len1, stbtt_uint8 *s2, stbtt_int32 len2)
        -: 4785:{
    #####: 4786:   stbtt_int32 i=0;
        -: 4787:
        -: 4788:   // convert utf16 to utf8 and compare the results while converting
    #####: 4789:   while (len2) {
    %%%%%: 4789-block 2
    %%%%%: 4789-block 40
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4790:      stbtt_uint16 ch = s2[0]*256 + s2[1];
    #####: 4791:      if (ch < 0x80) {
    %%%%%: 4791-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4792:         if (i >= len1) return -1;
    %%%%%: 4792-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4792-block 5
    #####: 4793:         if (s1[i++] != ch) return -1;
    %%%%%: 4793-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4793-block 7
    #####: 4794:      } else if (ch < 0x800) {
    %%%%%: 4794-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4795:         if (i+1 >= len1) return -1;
    %%%%%: 4795-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4795-block 10
    #####: 4796:         if (s1[i++] != 0xc0 + (ch >> 6)) return -1;
    %%%%%: 4796-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4796-block 12
    #####: 4797:         if (s1[i++] != 0x80 + (ch & 0x3f)) return -1;
    %%%%%: 4797-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4797-block 14
    #####: 4798:      } else if (ch >= 0xd800 && ch < 0xdc00) {
    %%%%%: 4798-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4798-block 16
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 4799:         stbtt_uint32 c;
    #####: 4800:         stbtt_uint16 ch2 = s2[2]*256 + s2[3];
    #####: 4801:         if (i+3 >= len1) return -1;
    %%%%%: 4801-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4801-block 18
    #####: 4802:         c = ((ch - 0xd800) << 10) + (ch2 - 0xdc00) + 0x10000;
    #####: 4803:         if (s1[i++] != 0xf0 + (c >> 18)) return -1;
    %%%%%: 4803-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4803-block 20
    #####: 4804:         if (s1[i++] != 0x80 + ((c >> 12) & 0x3f)) return -1;
    %%%%%: 4804-block 21
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4804-block 22
    #####: 4805:         if (s1[i++] != 0x80 + ((c >>  6) & 0x3f)) return -1;
    %%%%%: 4805-block 23
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4805-block 24
    #####: 4806:         if (s1[i++] != 0x80 + ((c      ) & 0x3f)) return -1;
    %%%%%: 4806-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4806-block 26
    #####: 4807:         s2 += 2; // plus another 2 below
    #####: 4808:         len2 -= 2;
    #####: 4809:      } else if (ch >= 0xdc00 && ch < 0xe000) {
    %%%%%: 4809-block 27
    %%%%%: 4809-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4809-block 29
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4810:         return -1;
    %%%%%: 4810-block 30
        -: 4811:      } else {
    #####: 4812:         if (i+2 >= len1) return -1;
    %%%%%: 4812-block 31
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4812-block 32
    #####: 4813:         if (s1[i++] != 0xe0 + (ch >> 12)) return -1;
    %%%%%: 4813-block 33
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4813-block 34
    #####: 4814:         if (s1[i++] != 0x80 + ((ch >> 6) & 0x3f)) return -1;
    %%%%%: 4814-block 35
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4814-block 36
    #####: 4815:         if (s1[i++] != 0x80 + ((ch     ) & 0x3f)) return -1;
    %%%%%: 4815-block 37
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4815-block 38
        -: 4816:      }
    #####: 4817:      s2 += 2;
    #####: 4818:      len2 -= 2;
    %%%%%: 4818-block 39
        -: 4819:   }
    #####: 4820:   return i;
    %%%%%: 4820-block 41
        -: 4821:}
        -: 4822:
function _ZL43stbtt_CompareUTF8toUTF16_bigendian_internalPciS_i called 0 returned 0% blocks executed 0%
    #####: 4823:static int stbtt_CompareUTF8toUTF16_bigendian_internal(char *s1, int len1, char *s2, int len2)
        -: 4824:{
    #####: 4825:   return len1 == stbtt__CompareUTF8toUTF16_bigendian_prefix((stbtt_uint8*) s1, len1, (stbtt_uint8*) s2, len2);
    %%%%%: 4825-block 2
call    0 never executed
        -: 4826:}
        -: 4827:
        -: 4828:// returns results in whatever encoding you request... but note that 2-byte encodings
        -: 4829:// will be BIG-ENDIAN... use stbtt_CompareUTF8toUTF16_bigendian() to compare
function stbtt_GetFontNameString called 0 returned 0% blocks executed 0%
    #####: 4830:STBTT_DEF const char *stbtt_GetFontNameString(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID)
        -: 4831:{
        -: 4832:   stbtt_int32 i,count,stringOffset;
    #####: 4833:   stbtt_uint8 *fc = font->data;
    #####: 4834:   stbtt_uint32 offset = font->fontstart;
    #####: 4835:   stbtt_uint32 nm = stbtt__find_table(fc, offset, "name");
    %%%%%: 4835-block 2
call    0 never executed
    #####: 4836:   if (!nm) return NULL;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4836-block 4
        -: 4837:
    #####: 4838:   count = ttUSHORT(fc+nm+2);
    %%%%%: 4838-block 5
call    0 never executed
    #####: 4839:   stringOffset = nm + ttUSHORT(fc+nm+4);
call    0 never executed
    #####: 4840:   for (i=0; i < count; ++i) {
    %%%%%: 4840-block 22
    %%%%%: 4840-block 23
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4841:      stbtt_uint32 loc = nm + 6 + 12 * i;
    #####: 4842:      if (platformID == ttUSHORT(fc+loc+0) && encodingID == ttUSHORT(fc+loc+2)
    %%%%%: 4842-block 8
call    0 never executed
    %%%%%: 4842-block 10
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4843:          && languageID == ttUSHORT(fc+loc+4) && nameID == ttUSHORT(fc+loc+6)) {
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4843-block 12
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 4843-block 14
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 4843-block 16
    %%%%%: 4843-block 17
    %%%%%: 4843-block 18
branch  8 never executed (fallthrough)
branch  9 never executed
    #####: 4844:         *length = ttUSHORT(fc+loc+8);
    %%%%%: 4844-block 19
call    0 never executed
    #####: 4845:         return (const char *) (fc+stringOffset+ttUSHORT(fc+loc+10));
call    0 never executed
        -: 4846:      }
        -: 4847:   }
    #####: 4848:   return NULL;
    %%%%%: 4848-block 24
        -: 4849:}
        -: 4850:
function _ZL16stbtt__matchpairPhjS_iii called 0 returned 0% blocks executed 0%
    #####: 4851:static int stbtt__matchpair(stbtt_uint8 *fc, stbtt_uint32 nm, stbtt_uint8 *name, stbtt_int32 nlen, stbtt_int32 target_id, stbtt_int32 next_id)
        -: 4852:{
        -: 4853:   stbtt_int32 i;
    #####: 4854:   stbtt_int32 count = ttUSHORT(fc+nm+2);
    %%%%%: 4854-block 2
call    0 never executed
    #####: 4855:   stbtt_int32 stringOffset = nm + ttUSHORT(fc+nm+4);
call    0 never executed
        -: 4856:
    #####: 4857:   for (i=0; i < count; ++i) {
    %%%%%: 4857-block 43
    %%%%%: 4857-block 44
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 4858:      stbtt_uint32 loc = nm + 6 + 12 * i;
    #####: 4859:      stbtt_int32 id = ttUSHORT(fc+loc+6);
    %%%%%: 4859-block 5
call    0 never executed
    #####: 4860:      if (id == target_id) {
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4861:         // find the encoding
    #####: 4862:         stbtt_int32 platform = ttUSHORT(fc+loc+0), encoding = ttUSHORT(fc+loc+2), language = ttUSHORT(fc+loc+4);
    %%%%%: 4862-block 7
call    0 never executed
call    1 never executed
call    2 never executed
        -: 4863:
        -: 4864:         // is this a Unicode encoding?
    #####: 4865:         if (platform == 0 || (platform == 3 && encoding == 1) || (platform == 3 && encoding == 10)) {
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4865-block 11
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4865-block 12
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 4865-block 13
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 4865-block 14
branch  8 never executed (fallthrough)
branch  9 never executed
    #####: 4866:            stbtt_int32 slen = ttUSHORT(fc+loc+8);
    %%%%%: 4866-block 15
call    0 never executed
    #####: 4867:            stbtt_int32 off = ttUSHORT(fc+loc+10);
call    0 never executed
        -: 4868:
        -: 4869:            // check if there's a prefix match
    #####: 4870:            stbtt_int32 matchlen = stbtt__CompareUTF8toUTF16_bigendian_prefix(name, nlen, fc+stringOffset+off,slen);
call    0 never executed
    #####: 4871:            if (matchlen >= 0) {
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4872:               // check for target_id+1 immediately following, with same encoding & language
    #####: 4873:               if (i+1 < count && ttUSHORT(fc+loc+12+6) == next_id && ttUSHORT(fc+loc+12) == platform && ttUSHORT(fc+loc+12+2) == encoding && ttUSHORT(fc+loc+12+4) == language) {
    %%%%%: 4873-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4873-block 20
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 4873-block 22
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 4873-block 24
call    8 never executed
branch  9 never executed (fallthrough)
branch 10 never executed
    %%%%%: 4873-block 26
call   11 never executed
branch 12 never executed (fallthrough)
branch 13 never executed
    %%%%%: 4873-block 28
    %%%%%: 4873-block 29
    %%%%%: 4873-block 30
branch 14 never executed (fallthrough)
branch 15 never executed
    #####: 4874:                  slen = ttUSHORT(fc+loc+12+8);
    %%%%%: 4874-block 31
call    0 never executed
    #####: 4875:                  off = ttUSHORT(fc+loc+12+10);
call    0 never executed
    #####: 4876:                  if (slen == 0) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4877:                     if (matchlen == nlen)
    %%%%%: 4877-block 34
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4878:                        return 1;
    %%%%%: 4878-block 35
    #####: 4879:                  } else if (matchlen < nlen && name[matchlen] == ' ') {
    %%%%%: 4879-block 36
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4879-block 37
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 4880:                     ++matchlen;
    #####: 4881:                     if (stbtt_CompareUTF8toUTF16_bigendian_internal((char*) (name+matchlen), nlen-matchlen, (char*)(fc+stringOffset+off),slen))
    %%%%%: 4881-block 38
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 4882:                        return 1;
    %%%%%: 4882-block 40
        -: 4883:                  }
        -: 4884:               } else {
        -: 4885:                  // if nothing immediately following
    #####: 4886:                  if (matchlen == nlen)
    %%%%%: 4886-block 41
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4887:                     return 1;
    %%%%%: 4887-block 42
        -: 4888:               }
        -: 4889:            }
        -: 4890:         }
        -: 4891:
        -: 4892:         // @TODO handle other encodings
        -: 4893:      }
        -: 4894:   }
    #####: 4895:   return 0;
    %%%%%: 4895-block 45
        -: 4896:}
        -: 4897:
function _ZL14stbtt__matchesPhjS_i called 0 returned 0% blocks executed 0%
    #####: 4898:static int stbtt__matches(stbtt_uint8 *fc, stbtt_uint32 offset, stbtt_uint8 *name, stbtt_int32 flags)
        -: 4899:{
    #####: 4900:   stbtt_int32 nlen = (stbtt_int32) STBTT_strlen((char *) name);
        -: 4901:   stbtt_uint32 nm,hd;
    #####: 4902:   if (!stbtt__isfont(fc+offset)) return 0;
    %%%%%: 4902-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 4902-block 4
        -: 4903:
        -: 4904:   // check italics/bold/underline flags in macStyle...
    #####: 4905:   if (flags) {
    %%%%%: 4905-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4906:      hd = stbtt__find_table(fc, offset, "head");
    %%%%%: 4906-block 6
call    0 never executed
    #####: 4907:      if ((ttUSHORT(fc+hd+44) & 7) != (flags & 7)) return 0;
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 4907-block 9
        -: 4908:   }
        -: 4909:
    #####: 4910:   nm = stbtt__find_table(fc, offset, "name");
    %%%%%: 4910-block 10
call    0 never executed
    #####: 4911:   if (!nm) return 0;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4911-block 12
        -: 4912:
    #####: 4913:   if (flags) {
    %%%%%: 4913-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4914:      // if we checked the macStyle flags, then just check the family and ignore the subfamily
    #####: 4915:      if (stbtt__matchpair(fc, nm, name, nlen, 16, -1))  return 1;
    %%%%%: 4915-block 14
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 4915-block 16
    #####: 4916:      if (stbtt__matchpair(fc, nm, name, nlen,  1, -1))  return 1;
    %%%%%: 4916-block 17
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 4916-block 19
    #####: 4917:      if (stbtt__matchpair(fc, nm, name, nlen,  3, -1))  return 1;
    %%%%%: 4917-block 20
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 4917-block 22
        -: 4918:   } else {
    #####: 4919:      if (stbtt__matchpair(fc, nm, name, nlen, 16, 17))  return 1;
    %%%%%: 4919-block 23
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 4919-block 25
    #####: 4920:      if (stbtt__matchpair(fc, nm, name, nlen,  1,  2))  return 1;
    %%%%%: 4920-block 26
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 4920-block 28
    #####: 4921:      if (stbtt__matchpair(fc, nm, name, nlen,  3, -1))  return 1;
    %%%%%: 4921-block 29
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 4921-block 31
        -: 4922:   }
        -: 4923:
    #####: 4924:   return 0;
    %%%%%: 4924-block 32
        -: 4925:}
        -: 4926:
function _ZL31stbtt_FindMatchingFont_internalPhPci called 0 returned 0% blocks executed 0%
    #####: 4927:static int stbtt_FindMatchingFont_internal(unsigned char *font_collection, char *name_utf8, stbtt_int32 flags)
        -: 4928:{
        -: 4929:   stbtt_int32 i;
    #####: 4930:   for (i=0;;++i) {
    %%%%%: 4930-block 2
    #####: 4931:      stbtt_int32 off = stbtt_GetFontOffsetForIndex(font_collection, i);
    %%%%%: 4931-block 3
call    0 never executed
    #####: 4932:      if (off < 0) return off;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4932-block 5
    #####: 4933:      if (stbtt__matches((stbtt_uint8 *) font_collection, off, (stbtt_uint8*) name_utf8, flags))
    %%%%%: 4933-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 4934:         return off;
    %%%%%: 4934-block 8
    #####: 4935:   }
    %%%%%: 4935-block 9
        -: 4936:}
        -: 4937:
        -: 4938:#if defined(__GNUC__) || defined(__clang__)
        -: 4939:#pragma GCC diagnostic push
        -: 4940:#pragma GCC diagnostic ignored "-Wcast-qual"
        -: 4941:#endif
        -: 4942:
function stbtt_BakeFontBitmap called 0 returned 0% blocks executed 0%
    #####: 4943:STBTT_DEF int stbtt_BakeFontBitmap(const unsigned char *data, int offset,
        -: 4944:                                float pixel_height, unsigned char *pixels, int pw, int ph,
        -: 4945:                                int first_char, int num_chars, stbtt_bakedchar *chardata)
        -: 4946:{
    #####: 4947:   return stbtt_BakeFontBitmap_internal((unsigned char *) data, offset, pixel_height, pixels, pw, ph, first_char, num_chars, chardata);
    %%%%%: 4947-block 2
call    0 never executed
        -: 4948:}
        -: 4949:
function stbtt_GetFontOffsetForIndex called 11 returned 100% blocks executed 100%
       11: 4950:STBTT_DEF int stbtt_GetFontOffsetForIndex(const unsigned char *data, int index)
        -: 4951:{
       11: 4952:   return stbtt_GetFontOffsetForIndex_internal((unsigned char *) data, index);
       11: 4952-block 2
call    0 returned 11
        -: 4953:}
        -: 4954:
function stbtt_GetNumberOfFonts called 0 returned 0% blocks executed 0%
    #####: 4955:STBTT_DEF int stbtt_GetNumberOfFonts(const unsigned char *data)
        -: 4956:{
    #####: 4957:   return stbtt_GetNumberOfFonts_internal((unsigned char *) data);
    %%%%%: 4957-block 2
call    0 never executed
        -: 4958:}
        -: 4959:
function stbtt_InitFont called 11 returned 100% blocks executed 100%
       11: 4960:STBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data, int offset)
        -: 4961:{
       11: 4962:   return stbtt_InitFont_internal(info, (unsigned char *) data, offset);
       11: 4962-block 2
call    0 returned 11
        -: 4963:}
        -: 4964:
function stbtt_FindMatchingFont called 0 returned 0% blocks executed 0%
    #####: 4965:STBTT_DEF int stbtt_FindMatchingFont(const unsigned char *fontdata, const char *name, int flags)
        -: 4966:{
    #####: 4967:   return stbtt_FindMatchingFont_internal((unsigned char *) fontdata, (char *) name, flags);
    %%%%%: 4967-block 2
call    0 never executed
        -: 4968:}
        -: 4969:
function stbtt_CompareUTF8toUTF16_bigendian called 0 returned 0% blocks executed 0%
    #####: 4970:STBTT_DEF int stbtt_CompareUTF8toUTF16_bigendian(const char *s1, int len1, const char *s2, int len2)
        -: 4971:{
    #####: 4972:   return stbtt_CompareUTF8toUTF16_bigendian_internal((char *) s1, len1, (char *) s2, len2);
    %%%%%: 4972-block 2
call    0 never executed
        -: 4973:}
        -: 4974:
        -: 4975:#if defined(__GNUC__) || defined(__clang__)
        -: 4976:#pragma GCC diagnostic pop
        -: 4977:#endif
        -: 4978:
        -: 4979:#endif // STB_TRUETYPE_IMPLEMENTATION
        -: 4980:
        -: 4981:
        -: 4982:// FULL VERSION HISTORY
        -: 4983://
        -: 4984://   1.25 (2021-07-11) many fixes
        -: 4985://   1.24 (2020-02-05) fix warning
        -: 4986://   1.23 (2020-02-02) query SVG data for glyphs; query whole kerning table (but only kern not GPOS)
        -: 4987://   1.22 (2019-08-11) minimize missing-glyph duplication; fix kerning if both 'GPOS' and 'kern' are defined
        -: 4988://   1.21 (2019-02-25) fix warning
        -: 4989://   1.20 (2019-02-07) PackFontRange skips missing codepoints; GetScaleFontVMetrics()
        -: 4990://   1.19 (2018-02-11) OpenType GPOS kerning (horizontal only), STBTT_fmod
        -: 4991://   1.18 (2018-01-29) add missing function
        -: 4992://   1.17 (2017-07-23) make more arguments const; doc fix
        -: 4993://   1.16 (2017-07-12) SDF support
        -: 4994://   1.15 (2017-03-03) make more arguments const
        -: 4995://   1.14 (2017-01-16) num-fonts-in-TTC function
        -: 4996://   1.13 (2017-01-02) support OpenType fonts, certain Apple fonts
        -: 4997://   1.12 (2016-10-25) suppress warnings about casting away const with -Wcast-qual
        -: 4998://   1.11 (2016-04-02) fix unused-variable warning
        -: 4999://   1.10 (2016-04-02) allow user-defined fabs() replacement
        -: 5000://                     fix memory leak if fontsize=0.0
        -: 5001://                     fix warning from duplicate typedef
        -: 5002://   1.09 (2016-01-16) warning fix; avoid crash on outofmem; use alloc userdata for PackFontRanges
        -: 5003://   1.08 (2015-09-13) document stbtt_Rasterize(); fixes for vertical & horizontal edges
        -: 5004://   1.07 (2015-08-01) allow PackFontRanges to accept arrays of sparse codepoints;
        -: 5005://                     allow PackFontRanges to pack and render in separate phases;
        -: 5006://                     fix stbtt_GetFontOFfsetForIndex (never worked for non-0 input?);
        -: 5007://                     fixed an assert() bug in the new rasterizer
        -: 5008://                     replace assert() with STBTT_assert() in new rasterizer
        -: 5009://   1.06 (2015-07-14) performance improvements (~35% faster on x86 and x64 on test machine)
        -: 5010://                     also more precise AA rasterizer, except if shapes overlap
        -: 5011://                     remove need for STBTT_sort
        -: 5012://   1.05 (2015-04-15) fix misplaced definitions for STBTT_STATIC
        -: 5013://   1.04 (2015-04-15) typo in example
        -: 5014://   1.03 (2015-04-12) STBTT_STATIC, fix memory leak in new packing, various fixes
        -: 5015://   1.02 (2014-12-10) fix various warnings & compile issues w/ stb_rect_pack, C++
        -: 5016://   1.01 (2014-12-08) fix subpixel position when oversampling to exactly match
        -: 5017://                        non-oversampled; STBTT_POINT_SIZE for packed case only
        -: 5018://   1.00 (2014-12-06) add new PackBegin etc. API, w/ support for oversampling
        -: 5019://   0.99 (2014-09-18) fix multiple bugs with subpixel rendering (ryg)
        -: 5020://   0.9  (2014-08-07) support certain mac/iOS fonts without an MS platformID
        -: 5021://   0.8b (2014-07-07) fix a warning
        -: 5022://   0.8  (2014-05-25) fix a few more warnings
        -: 5023://   0.7  (2013-09-25) bugfix: subpixel glyph bug fixed in 0.5 had come back
        -: 5024://   0.6c (2012-07-24) improve documentation
        -: 5025://   0.6b (2012-07-20) fix a few more warnings
        -: 5026://   0.6  (2012-07-17) fix warnings; added stbtt_ScaleForMappingEmToPixels,
        -: 5027://                        stbtt_GetFontBoundingBox, stbtt_IsGlyphEmpty
        -: 5028://   0.5  (2011-12-09) bugfixes:
        -: 5029://                        subpixel glyph renderer computed wrong bounding box
        -: 5030://                        first vertex of shape can be off-curve (FreeSans)
        -: 5031://   0.4b (2011-12-03) fixed an error in the font baking example
        -: 5032://   0.4  (2011-12-01) kerning, subpixel rendering (tor)
        -: 5033://                    bugfixes for:
        -: 5034://                        codepoint-to-glyph conversion using table fmt=12
        -: 5035://                        codepoint-to-glyph conversion using table fmt=4
        -: 5036://                        stbtt_GetBakedQuad with non-square texture (Zer)
        -: 5037://                    updated Hello World! sample to use kerning and subpixel
        -: 5038://                    fixed some warnings
        -: 5039://   0.3  (2009-06-24) cmap fmt=12, compound shapes (MM)
        -: 5040://                    userdata, malloc-from-userdata, non-zero fill (stb)
        -: 5041://   0.2  (2009-03-11) Fix unsigned/signed char warnings
        -: 5042://   0.1  (2009-03-09) First public release
        -: 5043://
        -: 5044:
        -: 5045:/*
        -: 5046:------------------------------------------------------------------------------
        -: 5047:This software is available under 2 licenses -- choose whichever you prefer.
        -: 5048:------------------------------------------------------------------------------
        -: 5049:ALTERNATIVE A - MIT License
        -: 5050:Copyright (c) 2017 Sean Barrett
        -: 5051:Permission is hereby granted, free of charge, to any person obtaining a copy of
        -: 5052:this software and associated documentation files (the "Software"), to deal in
        -: 5053:the Software without restriction, including without limitation the rights to
        -: 5054:use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
        -: 5055:of the Software, and to permit persons to whom the Software is furnished to do
        -: 5056:so, subject to the following conditions:
        -: 5057:The above copyright notice and this permission notice shall be included in all
        -: 5058:copies or substantial portions of the Software.
        -: 5059:THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        -: 5060:IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        -: 5061:FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        -: 5062:AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        -: 5063:LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        -: 5064:OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
        -: 5065:SOFTWARE.
        -: 5066:------------------------------------------------------------------------------
        -: 5067:ALTERNATIVE B - Public Domain (www.unlicense.org)
        -: 5068:This is free and unencumbered software released into the public domain.
        -: 5069:Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
        -: 5070:software, either in source code form or as a compiled binary, for any purpose,
        -: 5071:commercial or non-commercial, and by any means.
        -: 5072:In jurisdictions that recognize copyright laws, the author or authors of this
        -: 5073:software dedicate any and all copyright interest in the software to the public
        -: 5074:domain. We make this dedication for the benefit of the public at large and to
        -: 5075:the detriment of our heirs and successors. We intend this dedication to be an
        -: 5076:overt act of relinquishment in perpetuity of all present and future rights to
        -: 5077:this software under copyright law.
        -: 5078:THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        -: 5079:IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        -: 5080:FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        -: 5081:AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
        -: 5082:ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
        -: 5083:WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
        -: 5084:------------------------------------------------------------------------------
        -: 5085:*/
