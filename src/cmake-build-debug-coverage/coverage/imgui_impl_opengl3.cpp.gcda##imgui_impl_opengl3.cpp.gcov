        -:    0:Source:/home/rc/ZathuraDbg/vendor/imgui/backends/imgui_impl_opengl3.cpp
        -:    0:Graph:/home/rc/ZathuraDbg/src/cmake-build-debug-coverage/CMakeFiles/Zathura.dir/home/rc/ZathuraDbg/vendor/imgui/backends/imgui_impl_opengl3.cpp.gcno
        -:    0:Data:/home/rc/ZathuraDbg/src/cmake-build-debug-coverage/CMakeFiles/Zathura.dir/home/rc/ZathuraDbg/vendor/imgui/backends/imgui_impl_opengl3.cpp.gcda
        -:    0:Runs:1
        -:    1:// dear imgui: Renderer Backend for modern OpenGL with shaders / programmatic pipeline
        -:    2:// - Desktop GL: 2.x 3.x 4.x
        -:    3:// - Embedded GL: ES 2.0 (WebGL 1.0), ES 3.0 (WebGL 2.0)
        -:    4:// This needs to be used along with a Platform Backend (e.g. GLFW, SDL, Win32, custom..)
        -:    5:
        -:    6:// Implemented features:
        -:    7://  [X] Renderer: User texture binding. Use 'GLuint' OpenGL texture identifier as void*/ImTextureID. Read the FAQ about ImTextureID!
        -:    8://  [X] Renderer: Large meshes support (64k+ vertices) with 16-bit indices (Desktop OpenGL only).
        -:    9://  [X] Renderer: Multi-viewport support (multiple windows). Enable with 'io.ConfigFlags |= ImGuiConfigFlags_ViewportsEnable'.
        -:   10:
        -:   11:// About WebGL/ES:
        -:   12:// - You need to '#define IMGUI_IMPL_OPENGL_ES2' or '#define IMGUI_IMPL_OPENGL_ES3' to use WebGL or OpenGL ES.
        -:   13:// - This is done automatically on iOS, Android and Emscripten targets.
        -:   14:// - For other targets, the define needs to be visible from the imgui_impl_opengl3.cpp compilation unit. If unsure, define globally or in imconfig.h.
        -:   15:
        -:   16:// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.
        -:   17:// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.
        -:   18:// Learn about Dear ImGui:
        -:   19:// - FAQ                  https://dearimgui.com/faq
        -:   20:// - Getting Started      https://dearimgui.com/getting-started
        -:   21:// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).
        -:   22:// - Introduction, links and more at the top of imgui.cpp
        -:   23:
        -:   24:// CHANGELOG
        -:   25:// (minor and older changes stripped away, please see git history for details)
        -:   26://  2024-XX-XX: Platform: Added support for multiple windows via the ImGuiPlatformIO interface.
        -:   27://  2024-10-07: OpenGL: Changed default texture sampler to Clamp instead of Repeat/Wrap.
        -:   28://  2024-06-28: OpenGL: ImGui_ImplOpenGL3_NewFrame() recreates font texture if it has been destroyed by ImGui_ImplOpenGL3_DestroyFontsTexture(). (#7748)
        -:   29://  2024-05-07: OpenGL: Update loader for Linux to support EGL/GLVND. (#7562)
        -:   30://  2024-04-16: OpenGL: Detect ES3 contexts on desktop based on version string, to e.g. avoid calling glPolygonMode() on them. (#7447)
        -:   31://  2024-01-09: OpenGL: Update GL3W based imgui_impl_opengl3_loader.h to load "libGL.so" and variants, fixing regression on distros missing a symlink.
        -:   32://  2023-11-08: OpenGL: Update GL3W based imgui_impl_opengl3_loader.h to load "libGL.so" instead of "libGL.so.1", accommodating for NetBSD systems having only "libGL.so.3" available. (#6983)
        -:   33://  2023-10-05: OpenGL: Rename symbols in our internal loader so that LTO compilation with another copy of gl3w is possible. (#6875, #6668, #4445)
        -:   34://  2023-06-20: OpenGL: Fixed erroneous use glGetIntegerv(GL_CONTEXT_PROFILE_MASK) on contexts lower than 3.2. (#6539, #6333)
        -:   35://  2023-05-09: OpenGL: Support for glBindSampler() backup/restore on ES3. (#6375)
        -:   36://  2023-04-18: OpenGL: Restore front and back polygon mode separately when supported by context. (#6333)
        -:   37://  2023-03-23: OpenGL: Properly restoring "no shader program bound" if it was the case prior to running the rendering function. (#6267, #6220, #6224)
        -:   38://  2023-03-15: OpenGL: Fixed GL loader crash when GL_VERSION returns NULL. (#6154, #4445, #3530)
        -:   39://  2023-03-06: OpenGL: Fixed restoration of a potentially deleted OpenGL program, by calling glIsProgram(). (#6220, #6224)
        -:   40://  2022-11-09: OpenGL: Reverted use of glBufferSubData(), too many corruptions issues + old issues seemingly can't be reproed with Intel drivers nowadays (revert 2021-12-15 and 2022-05-23 changes).
        -:   41://  2022-10-11: Using 'nullptr' instead of 'NULL' as per our switch to C++11.
        -:   42://  2022-09-27: OpenGL: Added ability to '#define IMGUI_IMPL_OPENGL_DEBUG'.
        -:   43://  2022-05-23: OpenGL: Reworking 2021-12-15 "Using buffer orphaning" so it only happens on Intel GPU, seems to cause problems otherwise. (#4468, #4825, #4832, #5127).
        -:   44://  2022-05-13: OpenGL: Fixed state corruption on OpenGL ES 2.0 due to not preserving GL_ELEMENT_ARRAY_BUFFER_BINDING and vertex attribute states.
        -:   45://  2021-12-15: OpenGL: Using buffer orphaning + glBufferSubData(), seems to fix leaks with multi-viewports with some Intel HD drivers.
        -:   46://  2021-08-23: OpenGL: Fixed ES 3.0 shader ("#version 300 es") use normal precision floats to avoid wobbly rendering at HD resolutions.
        -:   47://  2021-08-19: OpenGL: Embed and use our own minimal GL loader (imgui_impl_opengl3_loader.h), removing requirement and support for third-party loader.
        -:   48://  2021-06-29: Reorganized backend to pull data from a single structure to facilitate usage with multiple-contexts (all g_XXXX access changed to bd->XXXX).
        -:   49://  2021-06-25: OpenGL: Use OES_vertex_array extension on Emscripten + backup/restore current state.
        -:   50://  2021-06-21: OpenGL: Destroy individual vertex/fragment shader objects right after they are linked into the main shader.
        -:   51://  2021-05-24: OpenGL: Access GL_CLIP_ORIGIN when "GL_ARB_clip_control" extension is detected, inside of just OpenGL 4.5 version.
        -:   52://  2021-05-19: OpenGL: Replaced direct access to ImDrawCmd::TextureId with a call to ImDrawCmd::GetTexID(). (will become a requirement)
        -:   53://  2021-04-06: OpenGL: Don't try to read GL_CLIP_ORIGIN unless we're OpenGL 4.5 or greater.
        -:   54://  2021-02-18: OpenGL: Change blending equation to preserve alpha in output buffer.
        -:   55://  2021-01-03: OpenGL: Backup, setup and restore GL_STENCIL_TEST state.
        -:   56://  2020-10-23: OpenGL: Backup, setup and restore GL_PRIMITIVE_RESTART state.
        -:   57://  2020-10-15: OpenGL: Use glGetString(GL_VERSION) instead of glGetIntegerv(GL_MAJOR_VERSION, ...) when the later returns zero (e.g. Desktop GL 2.x)
        -:   58://  2020-09-17: OpenGL: Fix to avoid compiling/calling glBindSampler() on ES or pre 3.3 context which have the defines set by a loader.
        -:   59://  2020-07-10: OpenGL: Added support for glad2 OpenGL loader.
        -:   60://  2020-05-08: OpenGL: Made default GLSL version 150 (instead of 130) on OSX.
        -:   61://  2020-04-21: OpenGL: Fixed handling of glClipControl(GL_UPPER_LEFT) by inverting projection matrix.
        -:   62://  2020-04-12: OpenGL: Fixed context version check mistakenly testing for 4.0+ instead of 3.2+ to enable ImGuiBackendFlags_RendererHasVtxOffset.
        -:   63://  2020-03-24: OpenGL: Added support for glbinding 2.x OpenGL loader.
        -:   64://  2020-01-07: OpenGL: Added support for glbinding 3.x OpenGL loader.
        -:   65://  2019-10-25: OpenGL: Using a combination of GL define and runtime GL version to decide whether to use glDrawElementsBaseVertex(). Fix building with pre-3.2 GL loaders.
        -:   66://  2019-09-22: OpenGL: Detect default GL loader using __has_include compiler facility.
        -:   67://  2019-09-16: OpenGL: Tweak initialization code to allow application calling ImGui_ImplOpenGL3_CreateFontsTexture() before the first NewFrame() call.
        -:   68://  2019-05-29: OpenGL: Desktop GL only: Added support for large mesh (64K+ vertices), enable ImGuiBackendFlags_RendererHasVtxOffset flag.
        -:   69://  2019-04-30: OpenGL: Added support for special ImDrawCallback_ResetRenderState callback to reset render state.
        -:   70://  2019-03-29: OpenGL: Not calling glBindBuffer more than necessary in the render loop.
        -:   71://  2019-03-15: OpenGL: Added a GL call + comments in ImGui_ImplOpenGL3_Init() to detect uninitialized GL function loaders early.
        -:   72://  2019-03-03: OpenGL: Fix support for ES 2.0 (WebGL 1.0).
        -:   73://  2019-02-20: OpenGL: Fix for OSX not supporting OpenGL 4.5, we don't try to read GL_CLIP_ORIGIN even if defined by the headers/loader.
        -:   74://  2019-02-11: OpenGL: Projecting clipping rectangles correctly using draw_data->FramebufferScale to allow multi-viewports for retina display.
        -:   75://  2019-02-01: OpenGL: Using GLSL 410 shaders for any version over 410 (e.g. 430, 450).
        -:   76://  2018-11-30: Misc: Setting up io.BackendRendererName so it can be displayed in the About Window.
        -:   77://  2018-11-13: OpenGL: Support for GL 4.5's glClipControl(GL_UPPER_LEFT) / GL_CLIP_ORIGIN.
        -:   78://  2018-08-29: OpenGL: Added support for more OpenGL loaders: glew and glad, with comments indicative that any loader can be used.
        -:   79://  2018-08-09: OpenGL: Default to OpenGL ES 3 on iOS and Android. GLSL version default to "#version 300 ES".
        -:   80://  2018-07-30: OpenGL: Support for GLSL 300 ES and 410 core. Fixes for Emscripten compilation.
        -:   81://  2018-07-10: OpenGL: Support for more GLSL versions (based on the GLSL version string). Added error output when shaders fail to compile/link.
        -:   82://  2018-06-08: Misc: Extracted imgui_impl_opengl3.cpp/.h away from the old combined GLFW/SDL+OpenGL3 examples.
        -:   83://  2018-06-08: OpenGL: Use draw_data->DisplayPos and draw_data->DisplaySize to setup projection matrix and clipping rectangle.
        -:   84://  2018-05-25: OpenGL: Removed unnecessary backup/restore of GL_ELEMENT_ARRAY_BUFFER_BINDING since this is part of the VAO state.
        -:   85://  2018-05-14: OpenGL: Making the call to glBindSampler() optional so 3.2 context won't fail if the function is a nullptr pointer.
        -:   86://  2018-03-06: OpenGL: Added const char* glsl_version parameter to ImGui_ImplOpenGL3_Init() so user can override the GLSL version e.g. "#version 150".
        -:   87://  2018-02-23: OpenGL: Create the VAO in the render function so the setup can more easily be used with multiple shared GL context.
        -:   88://  2018-02-16: Misc: Obsoleted the io.RenderDrawListsFn callback and exposed ImGui_ImplSdlGL3_RenderDrawData() in the .h file so you can call it yourself.
        -:   89://  2018-01-07: OpenGL: Changed GLSL shader version from 330 to 150.
        -:   90://  2017-09-01: OpenGL: Save and restore current bound sampler. Save and restore current polygon mode.
        -:   91://  2017-05-01: OpenGL: Fixed save and restore of current blend func state.
        -:   92://  2017-05-01: OpenGL: Fixed save and restore of current GL_ACTIVE_TEXTURE.
        -:   93://  2016-09-05: OpenGL: Fixed save and restore of current scissor rectangle.
        -:   94://  2016-07-29: OpenGL: Explicitly setting GL_UNPACK_ROW_LENGTH to reduce issues because SDL changes it. (#752)
        -:   95:
        -:   96://----------------------------------------
        -:   97:// OpenGL    GLSL      GLSL
        -:   98:// version   version   string
        -:   99://----------------------------------------
        -:  100://  2.0       110       "#version 110"
        -:  101://  2.1       120       "#version 120"
        -:  102://  3.0       130       "#version 130"
        -:  103://  3.1       140       "#version 140"
        -:  104://  3.2       150       "#version 150"
        -:  105://  3.3       330       "#version 330 core"
        -:  106://  4.0       400       "#version 400 core"
        -:  107://  4.1       410       "#version 410 core"
        -:  108://  4.2       420       "#version 410 core"
        -:  109://  4.3       430       "#version 430 core"
        -:  110://  ES 2.0    100       "#version 100"      = WebGL 1.0
        -:  111://  ES 3.0    300       "#version 300 es"   = WebGL 2.0
        -:  112://----------------------------------------
        -:  113:
        -:  114:#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
        -:  115:#define _CRT_SECURE_NO_WARNINGS
        -:  116:#endif
        -:  117:
        -:  118:#include "imgui.h"
        -:  119:#ifndef IMGUI_DISABLE
        -:  120:#include "imgui_impl_opengl3.h"
        -:  121:#include <stdio.h>
        -:  122:#include <stdint.h>     // intptr_t
        -:  123:#if defined(__APPLE__)
        -:  124:#include <TargetConditionals.h>
        -:  125:#endif
        -:  126:
        -:  127:// Clang/GCC warnings with -Weverything
        -:  128:#if defined(__clang__)
        -:  129:#pragma clang diagnostic push
        -:  130:#pragma clang diagnostic ignored "-Wunknown-warning-option" // warning: ignore unknown flags
        -:  131:#pragma clang diagnostic ignored "-Wold-style-cast"         // warning: use of old-style cast
        -:  132:#pragma clang diagnostic ignored "-Wsign-conversion"        // warning: implicit conversion changes signedness
        -:  133:#pragma clang diagnostic ignored "-Wunused-macros"          // warning: macro is not used
        -:  134:#pragma clang diagnostic ignored "-Wnonportable-system-include-path"
        -:  135:#pragma clang diagnostic ignored "-Wcast-function-type"     // warning: cast between incompatible function types (for loader)
        -:  136:#endif
        -:  137:#if defined(__GNUC__)
        -:  138:#pragma GCC diagnostic push
        -:  139:#pragma GCC diagnostic ignored "-Wpragmas"                  // warning: unknown option after '#pragma GCC diagnostic' kind
        -:  140:#pragma GCC diagnostic ignored "-Wunknown-warning-option"   // warning: unknown warning group 'xxx'
        -:  141:#pragma GCC diagnostic ignored "-Wcast-function-type"       // warning: cast between incompatible function types (for loader)
        -:  142:#endif
        -:  143:
        -:  144:// GL includes
        -:  145:#if defined(IMGUI_IMPL_OPENGL_ES2)
        -:  146:#if (defined(__APPLE__) && (TARGET_OS_IOS || TARGET_OS_TV))
        -:  147:#include <OpenGLES/ES2/gl.h>    // Use GL ES 2
        -:  148:#else
        -:  149:#include <GLES2/gl2.h>          // Use GL ES 2
        -:  150:#endif
        -:  151:#if defined(__EMSCRIPTEN__)
        -:  152:#ifndef GL_GLEXT_PROTOTYPES
        -:  153:#define GL_GLEXT_PROTOTYPES
        -:  154:#endif
        -:  155:#include <GLES2/gl2ext.h>
        -:  156:#endif
        -:  157:#elif defined(IMGUI_IMPL_OPENGL_ES3)
        -:  158:#if (defined(__APPLE__) && (TARGET_OS_IOS || TARGET_OS_TV))
        -:  159:#include <OpenGLES/ES3/gl.h>    // Use GL ES 3
        -:  160:#else
        -:  161:#include <GLES3/gl3.h>          // Use GL ES 3
        -:  162:#endif
        -:  163:#elif !defined(IMGUI_IMPL_OPENGL_LOADER_CUSTOM)
        -:  164:// Modern desktop OpenGL doesn't have a standard portable header file to load OpenGL function pointers.
        -:  165:// Helper libraries are often used for this purpose! Here we are using our own minimal custom loader based on gl3w.
        -:  166:// In the rest of your app/engine, you can use another loader of your choice (gl3w, glew, glad, glbinding, glext, glLoadGen, etc.).
        -:  167:// If you happen to be developing a new feature for this backend (imgui_impl_opengl3.cpp):
        -:  168:// - You may need to regenerate imgui_impl_opengl3_loader.h to add new symbols. See https://github.com/dearimgui/gl3w_stripped
        -:  169:// - You can temporarily use an unstripped version. See https://github.com/dearimgui/gl3w_stripped/releases
        -:  170:// Changes to this backend using new APIs should be accompanied by a regenerated stripped loader version.
        -:  171:#define IMGL3W_IMPL
        -:  172:#include "imgui_impl_opengl3_loader.h"
        -:  173:#endif
        -:  174:
        -:  175:// Vertex arrays are not supported on ES2/WebGL1 unless Emscripten which uses an extension
        -:  176:#ifndef IMGUI_IMPL_OPENGL_ES2
        -:  177:#define IMGUI_IMPL_OPENGL_USE_VERTEX_ARRAY
        -:  178:#elif defined(__EMSCRIPTEN__)
        -:  179:#define IMGUI_IMPL_OPENGL_USE_VERTEX_ARRAY
        -:  180:#define glBindVertexArray       glBindVertexArrayOES
        -:  181:#define glGenVertexArrays       glGenVertexArraysOES
        -:  182:#define glDeleteVertexArrays    glDeleteVertexArraysOES
        -:  183:#define GL_VERTEX_ARRAY_BINDING GL_VERTEX_ARRAY_BINDING_OES
        -:  184:#endif
        -:  185:
        -:  186:// Desktop GL 2.0+ has extension and glPolygonMode() which GL ES and WebGL don't have..
        -:  187:// A desktop ES context can technically compile fine with our loader, so we also perform a runtime checks
        -:  188:#if !defined(IMGUI_IMPL_OPENGL_ES2) && !defined(IMGUI_IMPL_OPENGL_ES3)
        -:  189:#define IMGUI_IMPL_OPENGL_HAS_EXTENSIONS        // has glGetIntegerv(GL_NUM_EXTENSIONS)
        -:  190:#define IMGUI_IMPL_OPENGL_MAY_HAVE_POLYGON_MODE // may have glPolygonMode()
        -:  191:#endif
        -:  192:
        -:  193:// Desktop GL 2.1+ and GL ES 3.0+ have glBindBuffer() with GL_PIXEL_UNPACK_BUFFER target.
        -:  194:#if !defined(IMGUI_IMPL_OPENGL_ES2)
        -:  195:#define IMGUI_IMPL_OPENGL_MAY_HAVE_BIND_BUFFER_PIXEL_UNPACK
        -:  196:#endif
        -:  197:
        -:  198:// Desktop GL 3.1+ has GL_PRIMITIVE_RESTART state
        -:  199:#if !defined(IMGUI_IMPL_OPENGL_ES2) && !defined(IMGUI_IMPL_OPENGL_ES3) && defined(GL_VERSION_3_1)
        -:  200:#define IMGUI_IMPL_OPENGL_MAY_HAVE_PRIMITIVE_RESTART
        -:  201:#endif
        -:  202:
        -:  203:// Desktop GL 3.2+ has glDrawElementsBaseVertex() which GL ES and WebGL don't have.
        -:  204:#if !defined(IMGUI_IMPL_OPENGL_ES2) && !defined(IMGUI_IMPL_OPENGL_ES3) && defined(GL_VERSION_3_2)
        -:  205:#define IMGUI_IMPL_OPENGL_MAY_HAVE_VTX_OFFSET
        -:  206:#endif
        -:  207:
        -:  208:// Desktop GL 3.3+ and GL ES 3.0+ have glBindSampler()
        -:  209:#if !defined(IMGUI_IMPL_OPENGL_ES2) && (defined(IMGUI_IMPL_OPENGL_ES3) || defined(GL_VERSION_3_3))
        -:  210:#define IMGUI_IMPL_OPENGL_MAY_HAVE_BIND_SAMPLER
        -:  211:#endif
        -:  212:
        -:  213:// [Debugging]
        -:  214://#define IMGUI_IMPL_OPENGL_DEBUG
        -:  215:#ifdef IMGUI_IMPL_OPENGL_DEBUG
        -:  216:#include <stdio.h>
        -:  217:#define GL_CALL(_CALL)      do { _CALL; GLenum gl_err = glGetError(); if (gl_err != 0) fprintf(stderr, "GL error 0x%x returned from '%s'.\n", gl_err, #_CALL); } while (0)  // Call with error check
        -:  218:#else
        -:  219:#define GL_CALL(_CALL)      _CALL   // Call without error check
        -:  220:#endif
        -:  221:
        -:  222:// OpenGL Data
        -:  223:struct ImGui_ImplOpenGL3_Data
        -:  224:{
        -:  225:    GLuint          GlVersion;               // Extracted at runtime using GL_MAJOR_VERSION, GL_MINOR_VERSION queries (e.g. 320 for GL 3.2)
        -:  226:    char            GlslVersionString[32];   // Specified by user or detected based on compile time GL settings.
        -:  227:    bool            GlProfileIsES2;
        -:  228:    bool            GlProfileIsES3;
        -:  229:    bool            GlProfileIsCompat;
        -:  230:    GLint           GlProfileMask;
        -:  231:    GLuint          FontTexture;
        -:  232:    GLuint          ShaderHandle;
        -:  233:    GLint           AttribLocationTex;       // Uniforms location
        -:  234:    GLint           AttribLocationProjMtx;
        -:  235:    GLuint          AttribLocationVtxPos;    // Vertex attributes location
        -:  236:    GLuint          AttribLocationVtxUV;
        -:  237:    GLuint          AttribLocationVtxColor;
        -:  238:    unsigned int    VboHandle, ElementsHandle;
        -:  239:    GLsizeiptr      VertexBufferSize;
        -:  240:    GLsizeiptr      IndexBufferSize;
        -:  241:    bool            HasPolygonMode;
        -:  242:    bool            HasClipOrigin;
        -:  243:    bool            UseBufferSubData;
        -:  244:
function _ZN22ImGui_ImplOpenGL3_DataC2Ev called 1 returned 100% blocks executed 100%
        1:  245:    ImGui_ImplOpenGL3_Data() { memset((void*)this, 0, sizeof(*this)); }
        -:  246:};
        -:  247:
        -:  248:// Backend data stored in io.BackendRendererUserData to allow support for multiple Dear ImGui contexts
        -:  249:// It is STRONGLY preferred that you use docking branch with multi-viewports (== single Dear ImGui context + multiple windows) instead of multiple Dear ImGui contexts.
function _ZL32ImGui_ImplOpenGL3_GetBackendDatav called 3239 returned 100% blocks executed 86%
     3239:  250:static ImGui_ImplOpenGL3_Data* ImGui_ImplOpenGL3_GetBackendData()
        -:  251:{
    3239*:  252:    return ImGui::GetCurrentContext() ? (ImGui_ImplOpenGL3_Data*)ImGui::GetIO().BackendRendererUserData : nullptr;
     3239:  252-block 2
call    0 returned 3239
branch  1 taken 3239 (fallthrough)
branch  2 taken 0
     3239:  252-block 4
call    3 returned 3239
    %%%%%:  252-block 6
     3239:  252-block 7
        -:  253:}
        -:  254:
        -:  255:// Forward Declarations
        -:  256:static void ImGui_ImplOpenGL3_InitMultiViewportSupport();
        -:  257:static void ImGui_ImplOpenGL3_ShutdownMultiViewportSupport();
        -:  258:
        -:  259:// OpenGL vertex attribute state (for ES 1.0 and ES 2.0 only)
        -:  260:#ifndef IMGUI_IMPL_OPENGL_USE_VERTEX_ARRAY
        -:  261:struct ImGui_ImplOpenGL3_VtxAttribState
        -:  262:{
        -:  263:    GLint   Enabled, Size, Type, Normalized, Stride;
        -:  264:    GLvoid* Ptr;
        -:  265:
        -:  266:    void GetState(GLint index)
        -:  267:    {
        -:  268:        glGetVertexAttribiv(index, GL_VERTEX_ATTRIB_ARRAY_ENABLED, &Enabled);
        -:  269:        glGetVertexAttribiv(index, GL_VERTEX_ATTRIB_ARRAY_SIZE, &Size);
        -:  270:        glGetVertexAttribiv(index, GL_VERTEX_ATTRIB_ARRAY_TYPE, &Type);
        -:  271:        glGetVertexAttribiv(index, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, &Normalized);
        -:  272:        glGetVertexAttribiv(index, GL_VERTEX_ATTRIB_ARRAY_STRIDE, &Stride);
        -:  273:        glGetVertexAttribPointerv(index, GL_VERTEX_ATTRIB_ARRAY_POINTER, &Ptr);
        -:  274:    }
        -:  275:    void SetState(GLint index)
        -:  276:    {
        -:  277:        glVertexAttribPointer(index, Size, Type, (GLboolean)Normalized, Stride, Ptr);
        -:  278:        if (Enabled) glEnableVertexAttribArray(index); else glDisableVertexAttribArray(index);
        -:  279:    }
        -:  280:};
        -:  281:#endif
        -:  282:
        -:  283:// Functions
function _Z22ImGui_ImplOpenGL3_InitPKc called 1 returned 100% blocks executed 80%
        1:  284:bool    ImGui_ImplOpenGL3_Init(const char* glsl_version)
        -:  285:{
        1:  286:    ImGuiIO& io = ImGui::GetIO();
        1:  286-block 2
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  287:    IMGUI_CHECKVERSION();
        1:  287-block 3
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
       1*:  288:    IM_ASSERT(io.BackendRendererUserData == nullptr && "Already initialized a renderer backend!");
        1:  288-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%:  288-block 5
call    2 never executed
        -:  289:
        -:  290:    // Initialize our loader
        -:  291:#if !defined(IMGUI_IMPL_OPENGL_ES2) && !defined(IMGUI_IMPL_OPENGL_ES3) && !defined(IMGUI_IMPL_OPENGL_LOADER_CUSTOM)
        1:  292:    if (imgl3wInit() != 0)
        1:  292-block 6
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  292-block 7
branch  3 taken 0 (fallthrough)
branch  4 taken 1
        -:  293:    {
    #####:  294:        fprintf(stderr, "Failed to initialize OpenGL loader!\n");
    %%%%%:  294-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  295:        return false;
    %%%%%:  295-block 9
        -:  296:    }
        -:  297:#endif
        -:  298:
        -:  299:    // Setup backend capabilities flags
        1:  300:    ImGui_ImplOpenGL3_Data* bd = IM_NEW(ImGui_ImplOpenGL3_Data)();
        1:  300-block 10
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  300-block 11
call    3 returned 1
call    4 returned 1
        1:  301:    io.BackendRendererUserData = (void*)bd;
        1:  302:    io.BackendRendererName = "imgui_impl_opengl3";
        -:  303:
        -:  304:    // Query for GL version (e.g. 320 for GL 3.2)
        -:  305:#if defined(IMGUI_IMPL_OPENGL_ES2)
        -:  306:    // GLES 2
        -:  307:    bd->GlVersion = 200;
        -:  308:    bd->GlProfileIsES2 = true;
        -:  309:#else
        -:  310:    // Desktop or GLES 3
        1:  311:    const char* gl_version_str = (const char*)glGetString(GL_VERSION);
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  312:    GLint major = 0;
        1:  313:    GLint minor = 0;
        1:  314:    glGetIntegerv(GL_MAJOR_VERSION, &major);
        1:  314-block 14
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  315:    glGetIntegerv(GL_MINOR_VERSION, &minor);
        1:  315-block 15
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
       1*:  316:    if (major == 0 && minor == 0)
        1:  316-block 16
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%:  316-block 17
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:  317:        sscanf(gl_version_str, "%d.%d", &major, &minor); // Query GL_VERSION in desktop GL 2.x, the string will start with "<major>.<minor>"
    %%%%%:  317-block 18
        1:  318:    bd->GlVersion = (GLuint)(major * 100 + minor * 10);
        -:  319:#if defined(GL_CONTEXT_PROFILE_MASK)
        1:  320:    if (bd->GlVersion >= 320)
        1:  320-block 19
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  321:        glGetIntegerv(GL_CONTEXT_PROFILE_MASK, &bd->GlProfileMask);
        1:  321-block 20
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  322:    bd->GlProfileIsCompat = (bd->GlProfileMask & GL_CONTEXT_COMPATIBILITY_PROFILE_BIT) != 0;
        -:  323:#endif
        -:  324:
        -:  325:#if defined(IMGUI_IMPL_OPENGL_ES3)
        -:  326:    bd->GlProfileIsES3 = true;
        -:  327:#else
        1:  328:    if (strncmp(gl_version_str, "OpenGL ES 3", 11) == 0)
        1:  328-block 21
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:  329:        bd->GlProfileIsES3 = true;
    %%%%%:  329-block 22
        -:  330:#endif
        -:  331:
        1:  332:    bd->UseBufferSubData = false;
        -:  333:    /*
        -:  334:    // Query vendor to enable glBufferSubData kludge
        -:  335:#ifdef _WIN32
        -:  336:    if (const char* vendor = (const char*)glGetString(GL_VENDOR))
        -:  337:        if (strncmp(vendor, "Intel", 5) == 0)
        -:  338:            bd->UseBufferSubData = true;
        -:  339:#endif
        -:  340:    */
        -:  341:#endif
        -:  342:
        -:  343:#ifdef IMGUI_IMPL_OPENGL_DEBUG
        -:  344:    printf("GlVersion = %d, \"%s\"\nGlProfileIsCompat = %d\nGlProfileMask = 0x%X\nGlProfileIsES2 = %d, GlProfileIsES3 = %d\nGL_VENDOR = '%s'\nGL_RENDERER = '%s'\n", bd->GlVersion, gl_version_str, bd->GlProfileIsCompat, bd->GlProfileMask, bd->GlProfileIsES2, bd->GlProfileIsES3, (const char*)glGetString(GL_VENDOR), (const char*)glGetString(GL_RENDERER)); // [DEBUG]
        -:  345:#endif
        -:  346:
        -:  347:#ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_VTX_OFFSET
        1:  348:    if (bd->GlVersion >= 320)
        1:  348-block 23
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  349:        io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset;  // We can honor the ImDrawCmd::VtxOffset field, allowing for large meshes.
        1:  349-block 24
        -:  350:#endif
        1:  351:    io.BackendFlags |= ImGuiBackendFlags_RendererHasViewports;  // We can create multi-viewports on the Renderer side (optional)
        -:  352:
        -:  353:    // Store GLSL version string so we can refer to it later in case we recreate shaders.
        -:  354:    // Note: GLSL version is NOT the same as GL version. Leave this to nullptr if unsure.
        1:  355:    if (glsl_version == nullptr)
        1:  355-block 25
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:  356:    {
        -:  357:#if defined(IMGUI_IMPL_OPENGL_ES2)
        -:  358:        glsl_version = "#version 100";
        -:  359:#elif defined(IMGUI_IMPL_OPENGL_ES3)
        -:  360:        glsl_version = "#version 300 es";
        -:  361:#elif defined(__APPLE__)
        -:  362:        glsl_version = "#version 150";
        -:  363:#else
    #####:  364:        glsl_version = "#version 130";
    %%%%%:  364-block 26
        -:  365:#endif
        -:  366:    }
       1*:  367:    IM_ASSERT((int)strlen(glsl_version) + 2 < IM_ARRAYSIZE(bd->GlslVersionString));
        1:  367-block 27
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%:  367-block 28
call    2 never executed
        1:  368:    strcpy(bd->GlslVersionString, glsl_version);
        1:  369:    strcat(bd->GlslVersionString, "\n");
        -:  370:
        -:  371:    // Make an arbitrary GL call (we don't actually need the result)
        -:  372:    // IF YOU GET A CRASH HERE: it probably means the OpenGL function loader didn't do its job. Let us know!
        -:  373:    GLint current_texture;
        1:  374:    glGetIntegerv(GL_TEXTURE_BINDING_2D, &current_texture);
        1:  374-block 29
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:  375:
        -:  376:    // Detect extensions we support
        -:  377:#ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_POLYGON_MODE
       1*:  378:    bd->HasPolygonMode = (!bd->GlProfileIsES2 && !bd->GlProfileIsES3);
        1:  378-block 30
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  378-block 31
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1:  378-block 32
    %%%%%:  378-block 33
        -:  379:#endif
        1:  380:    bd->HasClipOrigin = (bd->GlVersion >= 450);
        -:  381:#ifdef IMGUI_IMPL_OPENGL_HAS_EXTENSIONS
        1:  382:    GLint num_extensions = 0;
        1:  383:    glGetIntegerv(GL_NUM_EXTENSIONS, &num_extensions);
        1:  383-block 34
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
      399:  384:    for (GLint i = 0; i < num_extensions; i++)
        1:  384-block 35
      398:  384-block 40
      399:  384-block 41
branch  0 taken 398
branch  1 taken 1 (fallthrough)
        -:  385:    {
      398:  386:        const char* extension = (const char*)glGetStringi(GL_EXTENSIONS, i);
      398:  386-block 36
call    0 returned 398
branch  1 taken 398 (fallthrough)
branch  2 taken 0 (throw)
      398:  387:        if (extension != nullptr && strcmp(extension, "GL_ARB_clip_control") == 0)
      398:  387-block 37
branch  0 taken 398 (fallthrough)
branch  1 taken 0
      398:  387-block 38
branch  2 taken 1 (fallthrough)
branch  3 taken 397
        1:  388:            bd->HasClipOrigin = true;
        1:  388-block 39
        -:  389:    }
        -:  390:#endif
        -:  391:
        1:  392:    ImGui_ImplOpenGL3_InitMultiViewportSupport();
        1:  392-block 42
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:  393:
        1:  394:    return true;
        1:  394-block 43
        -:  395:}
        -:  396:
function _Z26ImGui_ImplOpenGL3_Shutdownv called 1 returned 100% blocks executed 88%
        1:  397:void    ImGui_ImplOpenGL3_Shutdown()
        -:  398:{
        1:  399:    ImGui_ImplOpenGL3_Data* bd = ImGui_ImplOpenGL3_GetBackendData();
        1:  399-block 2
call    0 returned 1
       1*:  400:    IM_ASSERT(bd != nullptr && "No renderer backend to shutdown, or already shutdown?");
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%:  400-block 4
call    2 never executed
        1:  401:    ImGuiIO& io = ImGui::GetIO();
        1:  401-block 5
call    0 returned 1
        -:  402:
        1:  403:    ImGui_ImplOpenGL3_ShutdownMultiViewportSupport();
call    0 returned 1
        1:  404:    ImGui_ImplOpenGL3_DestroyDeviceObjects();
call    0 returned 1
        1:  405:    io.BackendRendererName = nullptr;
        1:  406:    io.BackendRendererUserData = nullptr;
        1:  407:    io.BackendFlags &= ~(ImGuiBackendFlags_RendererHasVtxOffset | ImGuiBackendFlags_RendererHasViewports);
        1:  408:    IM_DELETE(bd);
call    0 returned 1
        1:  409:}
        -:  410:
function _Z26ImGui_ImplOpenGL3_NewFramev called 1077 returned 100% blocks executed 75%
     1077:  411:void    ImGui_ImplOpenGL3_NewFrame()
        -:  412:{
     1077:  413:    ImGui_ImplOpenGL3_Data* bd = ImGui_ImplOpenGL3_GetBackendData();
     1077:  413-block 2
call    0 returned 1077
    1077*:  414:    IM_ASSERT(bd != nullptr && "Context or backend not initialized! Did you call ImGui_ImplOpenGL3_Init()?");
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:  414-block 4
call    2 never executed
        -:  415:
     1077:  416:    if (!bd->ShaderHandle)
     1077:  416-block 5
branch  0 taken 1 (fallthrough)
branch  1 taken 1076
        1:  417:        ImGui_ImplOpenGL3_CreateDeviceObjects();
        1:  417-block 6
call    0 returned 1
     1077:  418:    if (!bd->FontTexture)
     1077:  418-block 7
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####:  419:        ImGui_ImplOpenGL3_CreateFontsTexture();
    %%%%%:  419-block 8
call    0 never executed
     1077:  420:}
        -:  421:
function _ZL34ImGui_ImplOpenGL3_SetupRenderStateP10ImDrawDataiij called 1077 returned 100% blocks executed 89%
     1077:  422:static void ImGui_ImplOpenGL3_SetupRenderState(ImDrawData* draw_data, int fb_width, int fb_height, GLuint vertex_array_object)
        -:  423:{
     1077:  424:    ImGui_ImplOpenGL3_Data* bd = ImGui_ImplOpenGL3_GetBackendData();
     1077:  424-block 2
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -:  425:
        -:  426:    // Setup render state: alpha-blending enabled, no face culling, no depth testing, scissor enabled, polygon fill
     1077:  427:    glEnable(GL_BLEND);
     1077:  427-block 3
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:  428:    glBlendEquation(GL_FUNC_ADD);
     1077:  428-block 4
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:  429:    glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
     1077:  429-block 5
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:  430:    glDisable(GL_CULL_FACE);
     1077:  430-block 6
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:  431:    glDisable(GL_DEPTH_TEST);
     1077:  431-block 7
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:  432:    glDisable(GL_STENCIL_TEST);
     1077:  432-block 8
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:  433:    glEnable(GL_SCISSOR_TEST);
     1077:  433-block 9
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -:  434:#ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_PRIMITIVE_RESTART
     1077:  435:    if (bd->GlVersion >= 310)
     1077:  435-block 10
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:  436:        glDisable(GL_PRIMITIVE_RESTART);
     1077:  436-block 11
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -:  437:#endif
        -:  438:#ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_POLYGON_MODE
     1077:  439:    if (bd->HasPolygonMode)
     1077:  439-block 12
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:  440:        glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
     1077:  440-block 13
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -:  441:#endif
        -:  442:
        -:  443:    // Support for GL 4.5 rarely used glClipControl(GL_UPPER_LEFT)
        -:  444:#if defined(GL_CLIP_ORIGIN)
     1077:  445:    bool clip_origin_lower_left = true;
     1077:  446:    if (bd->HasClipOrigin)
     1077:  446-block 14
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
        -:  447:    {
     1077:  448:        GLenum current_clip_origin = 0; glGetIntegerv(GL_CLIP_ORIGIN, (GLint*)&current_clip_origin);
     1077:  448-block 15
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:  449:        if (current_clip_origin == GL_UPPER_LEFT)
     1077:  449-block 16
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    #####:  450:            clip_origin_lower_left = false;
    %%%%%:  450-block 17
        -:  451:    }
        -:  452:#endif
        -:  453:
        -:  454:    // Setup viewport, orthographic projection matrix
        -:  455:    // Our visible imgui space lies from draw_data->DisplayPos (top left) to draw_data->DisplayPos+data_data->DisplaySize (bottom right). DisplayPos is (0,0) for single viewport apps.
     1077:  456:    GL_CALL(glViewport(0, 0, (GLsizei)fb_width, (GLsizei)fb_height));
     1077:  456-block 19
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:  457:    float L = draw_data->DisplayPos.x;
     1077:  458:    float R = draw_data->DisplayPos.x + draw_data->DisplaySize.x;
     1077:  459:    float T = draw_data->DisplayPos.y;
     1077:  460:    float B = draw_data->DisplayPos.y + draw_data->DisplaySize.y;
        -:  461:#if defined(GL_CLIP_ORIGIN)
    1077*:  462:    if (!clip_origin_lower_left) { float tmp = T; T = B; B = tmp; } // Swap top and bottom if origin is upper left
     1077:  462-block 20
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:  462-block 21
        -:  463:#endif
     1077:  464:    const float ortho_projection[4][4] =
        -:  465:    {
     1077:  466:        { 2.0f/(R-L),   0.0f,         0.0f,   0.0f },
     1077:  467:        { 0.0f,         2.0f/(T-B),   0.0f,   0.0f },
        -:  468:        { 0.0f,         0.0f,        -1.0f,   0.0f },
     1077:  469:        { (R+L)/(L-R),  (T+B)/(B-T),  0.0f,   1.0f },
     1077:  470:    };
     1077:  471:    glUseProgram(bd->ShaderHandle);
     1077:  471-block 22
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:  472:    glUniform1i(bd->AttribLocationTex, 0);
     1077:  472-block 23
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:  473:    glUniformMatrix4fv(bd->AttribLocationProjMtx, 1, GL_FALSE, &ortho_projection[0][0]);
     1077:  473-block 24
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -:  474:
        -:  475:#ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_BIND_SAMPLER
    1077*:  476:    if (bd->GlVersion >= 330 || bd->GlProfileIsES3)
     1077:  476-block 25
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:  476-block 26
branch  2 never executed (fallthrough)
branch  3 never executed
     1077:  477:        glBindSampler(0, 0); // We use combined texture/sampler state. Applications using GL 3.3 and GL ES 3.0 may set that otherwise.
     1077:  477-block 27
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -:  478:#endif
        -:  479:
        -:  480:    (void)vertex_array_object;
        -:  481:#ifdef IMGUI_IMPL_OPENGL_USE_VERTEX_ARRAY
     1077:  482:    glBindVertexArray(vertex_array_object);
     1077:  482-block 28
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -:  483:#endif
        -:  484:
        -:  485:    // Bind vertex/index buffers and setup attributes for ImDrawVert
     1077:  486:    GL_CALL(glBindBuffer(GL_ARRAY_BUFFER, bd->VboHandle));
     1077:  486-block 29
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:  487:    GL_CALL(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, bd->ElementsHandle));
     1077:  487-block 30
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:  488:    GL_CALL(glEnableVertexAttribArray(bd->AttribLocationVtxPos));
     1077:  488-block 31
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:  489:    GL_CALL(glEnableVertexAttribArray(bd->AttribLocationVtxUV));
     1077:  489-block 32
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:  490:    GL_CALL(glEnableVertexAttribArray(bd->AttribLocationVtxColor));
     1077:  490-block 33
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:  491:    GL_CALL(glVertexAttribPointer(bd->AttribLocationVtxPos,   2, GL_FLOAT,         GL_FALSE, sizeof(ImDrawVert), (GLvoid*)offsetof(ImDrawVert, pos)));
     1077:  491-block 34
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:  492:    GL_CALL(glVertexAttribPointer(bd->AttribLocationVtxUV,    2, GL_FLOAT,         GL_FALSE, sizeof(ImDrawVert), (GLvoid*)offsetof(ImDrawVert, uv)));
     1077:  492-block 35
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:  493:    GL_CALL(glVertexAttribPointer(bd->AttribLocationVtxColor, 4, GL_UNSIGNED_BYTE, GL_TRUE, sizeof(ImDrawVert), (GLvoid*)offsetof(ImDrawVert, col)));
     1077:  493-block 36
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:  494:}
     1077:  494-block 37
        -:  495:
        -:  496:// OpenGL3 Render function.
        -:  497:// Note that this implementation is little overcomplicated because we are saving/setting up/restoring every OpenGL state explicitly.
        -:  498:// This is in order to be able to run within an OpenGL engine that doesn't do so.
function _Z32ImGui_ImplOpenGL3_RenderDrawDataP10ImDrawData called 1077 returned 100% blocks executed 78%
     1077:  499:void    ImGui_ImplOpenGL3_RenderDrawData(ImDrawData* draw_data)
        -:  500:{
        -:  501:    // Avoid rendering when minimized, scale coordinates for retina displays (screen coordinates != framebuffer coordinates)
     1077:  502:    int fb_width = (int)(draw_data->DisplaySize.x * draw_data->FramebufferScale.x);
     1077:  503:    int fb_height = (int)(draw_data->DisplaySize.y * draw_data->FramebufferScale.y);
     1077:  504:    if (fb_width <= 0 || fb_height <= 0)
     1077:  504-block 2
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:  504-block 3
branch  2 taken 0 (fallthrough)
branch  3 taken 1077
    #####:  505:        return;
    %%%%%:  505-block 4
        -:  506:
     1077:  507:    ImGui_ImplOpenGL3_Data* bd = ImGui_ImplOpenGL3_GetBackendData();
     1077:  507-block 5
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -:  508:
        -:  509:    // Backup GL state
     1077:  510:    GLenum last_active_texture; glGetIntegerv(GL_ACTIVE_TEXTURE, (GLint*)&last_active_texture);
     1077:  510-block 6
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:  511:    glActiveTexture(GL_TEXTURE0);
     1077:  511-block 7
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:  512:    GLuint last_program; glGetIntegerv(GL_CURRENT_PROGRAM, (GLint*)&last_program);
     1077:  512-block 8
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:  513:    GLuint last_texture; glGetIntegerv(GL_TEXTURE_BINDING_2D, (GLint*)&last_texture);
     1077:  513-block 9
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -:  514:#ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_BIND_SAMPLER
    1077*:  515:    GLuint last_sampler; if (bd->GlVersion >= 330 || bd->GlProfileIsES3) { glGetIntegerv(GL_SAMPLER_BINDING, (GLint*)&last_sampler); } else { last_sampler = 0; }
     1077:  515-block 10
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:  515-block 11
branch  2 never executed (fallthrough)
branch  3 never executed
     1077:  515-block 12
call    4 returned 1077
branch  5 taken 1077 (fallthrough)
branch  6 taken 0 (throw)
     1077:  515-block 13
    %%%%%:  515-block 14
        -:  516:#endif
     1077:  517:    GLuint last_array_buffer; glGetIntegerv(GL_ARRAY_BUFFER_BINDING, (GLint*)&last_array_buffer);
     1077:  517-block 15
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -:  518:#ifndef IMGUI_IMPL_OPENGL_USE_VERTEX_ARRAY
        -:  519:    // This is part of VAO on OpenGL 3.0+ and OpenGL ES 3.0+.
        -:  520:    GLint last_element_array_buffer; glGetIntegerv(GL_ELEMENT_ARRAY_BUFFER_BINDING, &last_element_array_buffer);
        -:  521:    ImGui_ImplOpenGL3_VtxAttribState last_vtx_attrib_state_pos; last_vtx_attrib_state_pos.GetState(bd->AttribLocationVtxPos);
        -:  522:    ImGui_ImplOpenGL3_VtxAttribState last_vtx_attrib_state_uv; last_vtx_attrib_state_uv.GetState(bd->AttribLocationVtxUV);
        -:  523:    ImGui_ImplOpenGL3_VtxAttribState last_vtx_attrib_state_color; last_vtx_attrib_state_color.GetState(bd->AttribLocationVtxColor);
        -:  524:#endif
        -:  525:#ifdef IMGUI_IMPL_OPENGL_USE_VERTEX_ARRAY
     1077:  526:    GLuint last_vertex_array_object; glGetIntegerv(GL_VERTEX_ARRAY_BINDING, (GLint*)&last_vertex_array_object);
     1077:  526-block 16
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -:  527:#endif
        -:  528:#ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_POLYGON_MODE
     1077:  529:    GLint last_polygon_mode[2]; if (bd->HasPolygonMode) { glGetIntegerv(GL_POLYGON_MODE, last_polygon_mode); }
     1077:  529-block 17
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:  529-block 18
call    2 returned 1077
branch  3 taken 1077 (fallthrough)
branch  4 taken 0 (throw)
        -:  530:#endif
     1077:  531:    GLint last_viewport[4]; glGetIntegerv(GL_VIEWPORT, last_viewport);
     1077:  531-block 19
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:  532:    GLint last_scissor_box[4]; glGetIntegerv(GL_SCISSOR_BOX, last_scissor_box);
     1077:  532-block 20
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:  533:    GLenum last_blend_src_rgb; glGetIntegerv(GL_BLEND_SRC_RGB, (GLint*)&last_blend_src_rgb);
     1077:  533-block 21
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:  534:    GLenum last_blend_dst_rgb; glGetIntegerv(GL_BLEND_DST_RGB, (GLint*)&last_blend_dst_rgb);
     1077:  534-block 22
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:  535:    GLenum last_blend_src_alpha; glGetIntegerv(GL_BLEND_SRC_ALPHA, (GLint*)&last_blend_src_alpha);
     1077:  535-block 23
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:  536:    GLenum last_blend_dst_alpha; glGetIntegerv(GL_BLEND_DST_ALPHA, (GLint*)&last_blend_dst_alpha);
     1077:  536-block 24
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:  537:    GLenum last_blend_equation_rgb; glGetIntegerv(GL_BLEND_EQUATION_RGB, (GLint*)&last_blend_equation_rgb);
     1077:  537-block 25
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:  538:    GLenum last_blend_equation_alpha; glGetIntegerv(GL_BLEND_EQUATION_ALPHA, (GLint*)&last_blend_equation_alpha);
     1077:  538-block 26
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:  539:    GLboolean last_enable_blend = glIsEnabled(GL_BLEND);
     1077:  539-block 27
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:  540:    GLboolean last_enable_cull_face = glIsEnabled(GL_CULL_FACE);
     1077:  540-block 28
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:  541:    GLboolean last_enable_depth_test = glIsEnabled(GL_DEPTH_TEST);
     1077:  541-block 29
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:  542:    GLboolean last_enable_stencil_test = glIsEnabled(GL_STENCIL_TEST);
     1077:  542-block 30
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:  543:    GLboolean last_enable_scissor_test = glIsEnabled(GL_SCISSOR_TEST);
     1077:  543-block 31
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -:  544:#ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_PRIMITIVE_RESTART
    1077*:  545:    GLboolean last_enable_primitive_restart = (bd->GlVersion >= 310) ? glIsEnabled(GL_PRIMITIVE_RESTART) : GL_FALSE;
     1077:  545-block 32
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:  545-block 33
call    2 returned 1077
branch  3 taken 1077 (fallthrough)
branch  4 taken 0 (throw)
     1077:  545-block 34
    %%%%%:  545-block 35
        -:  546:#endif
        -:  547:
        -:  548:    // Setup desired GL state
        -:  549:    // Recreate the VAO every time (this is to easily allow multiple GL contexts to be rendered to. VAO are not shared among GL contexts)
        -:  550:    // The renderer would actually work without any VAO bound, but then our VertexAttrib calls would overwrite the default one currently bound.
     1077:  551:    GLuint vertex_array_object = 0;
        -:  552:#ifdef IMGUI_IMPL_OPENGL_USE_VERTEX_ARRAY
     1077:  553:    GL_CALL(glGenVertexArrays(1, &vertex_array_object));
     1077:  553-block 36
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -:  554:#endif
     1077:  555:    ImGui_ImplOpenGL3_SetupRenderState(draw_data, fb_width, fb_height, vertex_array_object);
     1077:  555-block 37
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -:  556:
        -:  557:    // Will project scissor/clipping rectangles into framebuffer space
     1077:  558:    ImVec2 clip_off = draw_data->DisplayPos;         // (0,0) unless using multi-viewports
     1077:  559:    ImVec2 clip_scale = draw_data->FramebufferScale; // (1,1) unless using retina display which are often (2,2)
        -:  560:
        -:  561:    // Render command lists
    15272:  562:    for (int n = 0; n < draw_data->CmdListsCount; n++)
     1077:  562-block 38
    14195:  562-block 69
    15272:  562-block 70
branch  0 taken 14195
branch  1 taken 1077 (fallthrough)
        -:  563:    {
    14195:  564:        const ImDrawList* draw_list = draw_data->CmdLists[n];
    14195:  564-block 39
call    0 returned 14195
        -:  565:
        -:  566:        // Upload vertex/index buffers
        -:  567:        // - OpenGL drivers are in a very sorry state nowadays....
        -:  568:        //   During 2021 we attempted to switch from glBufferData() to orphaning+glBufferSubData() following reports
        -:  569:        //   of leaks on Intel GPU when using multi-viewports on Windows.
        -:  570:        // - After this we kept hearing of various display corruptions issues. We started disabling on non-Intel GPU, but issues still got reported on Intel.
        -:  571:        // - We are now back to using exclusively glBufferData(). So bd->UseBufferSubData IS ALWAYS FALSE in this code.
        -:  572:        //   We are keeping the old code path for a while in case people finding new issues may want to test the bd->UseBufferSubData path.
        -:  573:        // - See https://github.com/ocornut/imgui/issues/4468 and please report any corruption issues.
    14195:  574:        const GLsizeiptr vtx_buffer_size = (GLsizeiptr)draw_list->VtxBuffer.Size * (int)sizeof(ImDrawVert);
    14195:  575:        const GLsizeiptr idx_buffer_size = (GLsizeiptr)draw_list->IdxBuffer.Size * (int)sizeof(ImDrawIdx);
    14195:  576:        if (bd->UseBufferSubData)
branch  0 taken 0 (fallthrough)
branch  1 taken 14195
        -:  577:        {
    #####:  578:            if (bd->VertexBufferSize < vtx_buffer_size)
    %%%%%:  578-block 41
branch  0 never executed (fallthrough)
branch  1 never executed
        -:  579:            {
    #####:  580:                bd->VertexBufferSize = vtx_buffer_size;
    #####:  581:                GL_CALL(glBufferData(GL_ARRAY_BUFFER, bd->VertexBufferSize, nullptr, GL_STREAM_DRAW));
    %%%%%:  581-block 42
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:  582:            }
    #####:  583:            if (bd->IndexBufferSize < idx_buffer_size)
    %%%%%:  583-block 43
branch  0 never executed (fallthrough)
branch  1 never executed
        -:  584:            {
    #####:  585:                bd->IndexBufferSize = idx_buffer_size;
    #####:  586:                GL_CALL(glBufferData(GL_ELEMENT_ARRAY_BUFFER, bd->IndexBufferSize, nullptr, GL_STREAM_DRAW));
    %%%%%:  586-block 44
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:  587:            }
    #####:  588:            GL_CALL(glBufferSubData(GL_ARRAY_BUFFER, 0, vtx_buffer_size, (const GLvoid*)draw_list->VtxBuffer.Data));
    %%%%%:  588-block 45
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  589:            GL_CALL(glBufferSubData(GL_ELEMENT_ARRAY_BUFFER, 0, idx_buffer_size, (const GLvoid*)draw_list->IdxBuffer.Data));
    %%%%%:  589-block 46
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:  590:        }
        -:  591:        else
        -:  592:        {
    14195:  593:            GL_CALL(glBufferData(GL_ARRAY_BUFFER, vtx_buffer_size, (const GLvoid*)draw_list->VtxBuffer.Data, GL_STREAM_DRAW));
    14195:  593-block 47
call    0 returned 14195
branch  1 taken 14195 (fallthrough)
branch  2 taken 0 (throw)
    14195:  594:            GL_CALL(glBufferData(GL_ELEMENT_ARRAY_BUFFER, idx_buffer_size, (const GLvoid*)draw_list->IdxBuffer.Data, GL_STREAM_DRAW));
    14195:  594-block 48
call    0 returned 14195
branch  1 taken 14195 (fallthrough)
branch  2 taken 0 (throw)
        -:  595:        }
        -:  596:
    36127:  597:        for (int cmd_i = 0; cmd_i < draw_list->CmdBuffer.Size; cmd_i++)
    14195:  597-block 49
    21932:  597-block 67
    36127:  597-block 68
branch  0 taken 21932
branch  1 taken 14195 (fallthrough)
        -:  598:        {
    21932:  599:            const ImDrawCmd* pcmd = &draw_list->CmdBuffer[cmd_i];
    21932:  599-block 50
call    0 returned 21932
    21932:  600:            if (pcmd->UserCallback != nullptr)
branch  0 taken 0 (fallthrough)
branch  1 taken 21932
        -:  601:            {
        -:  602:                // User callback, registered via ImDrawList::AddCallback()
        -:  603:                // (ImDrawCallback_ResetRenderState is a special callback value used by the user to request the renderer to reset render state.)
    #####:  604:                if (pcmd->UserCallback == ImDrawCallback_ResetRenderState)
    %%%%%:  604-block 52
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  605:                    ImGui_ImplOpenGL3_SetupRenderState(draw_data, fb_width, fb_height, vertex_array_object);
    %%%%%:  605-block 53
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:  606:                else
    #####:  607:                    pcmd->UserCallback(draw_list, pcmd);
    %%%%%:  607-block 54
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:  608:            }
        -:  609:            else
        -:  610:            {
        -:  611:                // Project scissor/clipping rectangles into framebuffer space
    21932:  612:                ImVec2 clip_min((pcmd->ClipRect.x - clip_off.x) * clip_scale.x, (pcmd->ClipRect.y - clip_off.y) * clip_scale.y);
    21932:  612-block 55
call    0 returned 21932
    21932:  613:                ImVec2 clip_max((pcmd->ClipRect.z - clip_off.x) * clip_scale.x, (pcmd->ClipRect.w - clip_off.y) * clip_scale.y);
call    0 returned 21932
    21932:  614:                if (clip_max.x <= clip_min.x || clip_max.y <= clip_min.y)
branch  0 taken 20856 (fallthrough)
branch  1 taken 1076
    20856:  614-block 58
branch  2 taken 0 (fallthrough)
branch  3 taken 20856
     1076:  615:                    continue;
     1076:  615-block 59
        -:  616:
        -:  617:                // Apply scissor/clipping rectangle (Y is inverted in OpenGL)
    20856:  618:                GL_CALL(glScissor((int)clip_min.x, (int)((float)fb_height - clip_max.y), (int)(clip_max.x - clip_min.x), (int)(clip_max.y - clip_min.y)));
    20856:  618-block 60
call    0 returned 20856
branch  1 taken 20856 (fallthrough)
branch  2 taken 0 (throw)
        -:  619:
        -:  620:                // Bind texture, Draw
    20856:  621:                GL_CALL(glBindTexture(GL_TEXTURE_2D, (GLuint)(intptr_t)pcmd->GetTexID()));
    20856:  621-block 61
call    0 returned 20856
call    1 returned 20856
branch  2 taken 20856 (fallthrough)
branch  3 taken 0 (throw)
        -:  622:#ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_VTX_OFFSET
    20856:  623:                if (bd->GlVersion >= 320)
    20856:  623-block 63
branch  0 taken 20856 (fallthrough)
branch  1 taken 0
    20856:  624:                    GL_CALL(glDrawElementsBaseVertex(GL_TRIANGLES, (GLsizei)pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, (void*)(intptr_t)(pcmd->IdxOffset * sizeof(ImDrawIdx)), (GLint)pcmd->VtxOffset));
    20856:  624-block 64
call    0 returned 20856
branch  1 taken 20856 (fallthrough)
branch  2 taken 0 (throw)
        -:  625:                else
        -:  626:#endif
    #####:  627:                GL_CALL(glDrawElements(GL_TRIANGLES, (GLsizei)pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, (void*)(intptr_t)(pcmd->IdxOffset * sizeof(ImDrawIdx))));
    %%%%%:  627-block 65
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:  628:            }
        -:  629:        }
        -:  630:    }
        -:  631:
        -:  632:    // Destroy the temporary VAO
        -:  633:#ifdef IMGUI_IMPL_OPENGL_USE_VERTEX_ARRAY
     1077:  634:    GL_CALL(glDeleteVertexArrays(1, &vertex_array_object));
     1077:  634-block 71
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -:  635:#endif
        -:  636:
        -:  637:    // Restore modified GL state
        -:  638:    // This "glIsProgram()" check is required because if the program is "pending deletion" at the time of binding backup, it will have been deleted by now and will cause an OpenGL error. See #6220.
    1077*:  639:    if (last_program == 0 || glIsProgram(last_program)) glUseProgram(last_program);
     1077:  639-block 72
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:  639-block 73
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%:  639-block 74
branch  5 never executed (fallthrough)
branch  6 never executed
     1077:  639-block 75
    %%%%%:  639-block 76
     1077:  639-block 77
branch  7 taken 1077 (fallthrough)
branch  8 taken 0
     1077:  639-block 78
call    9 returned 1077
branch 10 taken 1077 (fallthrough)
branch 11 taken 0 (throw)
     1077:  640:    glBindTexture(GL_TEXTURE_2D, last_texture);
     1077:  640-block 79
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -:  641:#ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_BIND_SAMPLER
    1077*:  642:    if (bd->GlVersion >= 330 || bd->GlProfileIsES3)
     1077:  642-block 80
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:  642-block 81
branch  2 never executed (fallthrough)
branch  3 never executed
     1077:  643:        glBindSampler(0, last_sampler);
     1077:  643-block 82
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -:  644:#endif
     1077:  645:    glActiveTexture(last_active_texture);
     1077:  645-block 83
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -:  646:#ifdef IMGUI_IMPL_OPENGL_USE_VERTEX_ARRAY
     1077:  647:    glBindVertexArray(last_vertex_array_object);
     1077:  647-block 84
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -:  648:#endif
     1077:  649:    glBindBuffer(GL_ARRAY_BUFFER, last_array_buffer);
     1077:  649-block 85
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -:  650:#ifndef IMGUI_IMPL_OPENGL_USE_VERTEX_ARRAY
        -:  651:    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, last_element_array_buffer);
        -:  652:    last_vtx_attrib_state_pos.SetState(bd->AttribLocationVtxPos);
        -:  653:    last_vtx_attrib_state_uv.SetState(bd->AttribLocationVtxUV);
        -:  654:    last_vtx_attrib_state_color.SetState(bd->AttribLocationVtxColor);
        -:  655:#endif
     1077:  656:    glBlendEquationSeparate(last_blend_equation_rgb, last_blend_equation_alpha);
     1077:  656-block 86
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:  657:    glBlendFuncSeparate(last_blend_src_rgb, last_blend_dst_rgb, last_blend_src_alpha, last_blend_dst_alpha);
     1077:  657-block 87
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
    1077*:  658:    if (last_enable_blend) glEnable(GL_BLEND); else glDisable(GL_BLEND);
     1077:  658-block 88
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:  658-block 89
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
     1077:  658-block 90
call    5 returned 1077
branch  6 taken 1077 (fallthrough)
branch  7 taken 0 (throw)
    1077*:  659:    if (last_enable_cull_face) glEnable(GL_CULL_FACE); else glDisable(GL_CULL_FACE);
     1077:  659-block 91
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:  659-block 92
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
     1077:  659-block 93
call    5 returned 1077
branch  6 taken 1077 (fallthrough)
branch  7 taken 0 (throw)
    1077*:  660:    if (last_enable_depth_test) glEnable(GL_DEPTH_TEST); else glDisable(GL_DEPTH_TEST);
     1077:  660-block 94
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:  660-block 95
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
     1077:  660-block 96
call    5 returned 1077
branch  6 taken 1077 (fallthrough)
branch  7 taken 0 (throw)
    1077*:  661:    if (last_enable_stencil_test) glEnable(GL_STENCIL_TEST); else glDisable(GL_STENCIL_TEST);
     1077:  661-block 97
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:  661-block 98
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
     1077:  661-block 99
call    5 returned 1077
branch  6 taken 1077 (fallthrough)
branch  7 taken 0 (throw)
    1077*:  662:    if (last_enable_scissor_test) glEnable(GL_SCISSOR_TEST); else glDisable(GL_SCISSOR_TEST);
     1077:  662-block 100
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%:  662-block 101
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
     1077:  662-block 102
call    5 returned 1077
branch  6 taken 1077 (fallthrough)
branch  7 taken 0 (throw)
        -:  663:#ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_PRIMITIVE_RESTART
    1077*:  664:    if (bd->GlVersion >= 310) { if (last_enable_primitive_restart) glEnable(GL_PRIMITIVE_RESTART); else glDisable(GL_PRIMITIVE_RESTART); }
     1077:  664-block 103
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:  664-block 104
branch  2 taken 0 (fallthrough)
branch  3 taken 1077
    %%%%%:  664-block 105
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
     1077:  664-block 106
call    7 returned 1077
branch  8 taken 1077 (fallthrough)
branch  9 taken 0 (throw)
        -:  665:#endif
        -:  666:
        -:  667:#ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_POLYGON_MODE
        -:  668:    // Desktop OpenGL 3.0 and OpenGL 3.1 had separate polygon draw modes for front-facing and back-facing faces of polygons
    1077*:  669:    if (bd->HasPolygonMode) { if (bd->GlVersion <= 310 || bd->GlProfileIsCompat) { glPolygonMode(GL_FRONT, (GLenum)last_polygon_mode[0]); glPolygonMode(GL_BACK, (GLenum)last_polygon_mode[1]); } else { glPolygonMode(GL_FRONT_AND_BACK, (GLenum)last_polygon_mode[0]); } }
     1077:  669-block 107
branch  0 taken 1077 (fallthrough)
branch  1 taken 0
     1077:  669-block 108
branch  2 taken 1077 (fallthrough)
branch  3 taken 0
     1077:  669-block 109
branch  4 taken 1077 (fallthrough)
branch  5 taken 0
     1077:  669-block 110
call    6 returned 1077
branch  7 taken 1077 (fallthrough)
branch  8 taken 0 (throw)
     1077:  669-block 111
call    9 returned 1077
branch 10 taken 1077 (fallthrough)
branch 11 taken 0 (throw)
     1077:  669-block 112
    %%%%%:  669-block 113
call   12 never executed
branch 13 never executed (fallthrough)
branch 14 never executed (throw)
        -:  670:#endif // IMGUI_IMPL_OPENGL_MAY_HAVE_POLYGON_MODE
        -:  671:
     1077:  672:    glViewport(last_viewport[0], last_viewport[1], (GLsizei)last_viewport[2], (GLsizei)last_viewport[3]);
     1077:  672-block 115
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
     1077:  673:    glScissor(last_scissor_box[0], last_scissor_box[1], (GLsizei)last_scissor_box[2], (GLsizei)last_scissor_box[3]);
     1077:  673-block 116
call    0 returned 1077
branch  1 taken 1077 (fallthrough)
branch  2 taken 0 (throw)
        -:  674:    (void)bd; // Not all compilation paths use this
        -:  675:}
        -:  676:
function _Z36ImGui_ImplOpenGL3_CreateFontsTexturev called 1 returned 100% blocks executed 100%
        1:  677:bool ImGui_ImplOpenGL3_CreateFontsTexture()
        -:  678:{
        1:  679:    ImGuiIO& io = ImGui::GetIO();
        1:  679-block 2
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  680:    ImGui_ImplOpenGL3_Data* bd = ImGui_ImplOpenGL3_GetBackendData();
        1:  680-block 3
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:  681:
        -:  682:    // Build texture atlas
        -:  683:    unsigned char* pixels;
        -:  684:    int width, height;
        1:  685:    io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);   // Load as RGBA 32-bit (75% of the memory is wasted, but default font is so small) because it is more likely to be compatible with user's existing shaders. If your ImTextureId represent a higher-level concept than just a GL texture id, consider calling GetTexDataAsAlpha8() instead to save on GPU memory.
        1:  685-block 4
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:  686:
        -:  687:    // Upload texture to graphics system
        -:  688:    // (Bilinear sampling is required by default. Set 'io.Fonts->Flags |= ImFontAtlasFlags_NoBakedLines' or 'style.AntiAliasedLinesUseTex = false' to allow point/nearest sampling)
        -:  689:    GLint last_texture;
        1:  690:    GL_CALL(glGetIntegerv(GL_TEXTURE_BINDING_2D, &last_texture));
        1:  690-block 5
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  691:    GL_CALL(glGenTextures(1, &bd->FontTexture));
        1:  691-block 6
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  692:    GL_CALL(glBindTexture(GL_TEXTURE_2D, bd->FontTexture));
        1:  692-block 7
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  693:    GL_CALL(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR));
        1:  693-block 8
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  694:    GL_CALL(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR));
        1:  694-block 9
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  695:    GL_CALL(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE));
        1:  695-block 10
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  696:    GL_CALL(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE));
        1:  696-block 11
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:  697:#ifdef GL_UNPACK_ROW_LENGTH // Not on WebGL/ES
        1:  698:    GL_CALL(glPixelStorei(GL_UNPACK_ROW_LENGTH, 0));
        1:  698-block 12
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:  699:#endif
        1:  700:    GL_CALL(glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, pixels));
        1:  700-block 13
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:  701:
        -:  702:    // Store our identifier
        1:  703:    io.Fonts->SetTexID((ImTextureID)(intptr_t)bd->FontTexture);
        1:  703-block 14
call    0 returned 1
        -:  704:
        -:  705:    // Restore state
        1:  706:    GL_CALL(glBindTexture(GL_TEXTURE_2D, last_texture));
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:  707:
        1:  708:    return true;
        1:  708-block 16
        1:  708-block 17
        -:  709:}
        -:  710:
function _Z37ImGui_ImplOpenGL3_DestroyFontsTexturev called 1 returned 100% blocks executed 100%
        1:  711:void ImGui_ImplOpenGL3_DestroyFontsTexture()
        -:  712:{
        1:  713:    ImGuiIO& io = ImGui::GetIO();
        1:  713-block 2
call    0 returned 1
        1:  714:    ImGui_ImplOpenGL3_Data* bd = ImGui_ImplOpenGL3_GetBackendData();
call    0 returned 1
        1:  715:    if (bd->FontTexture)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -:  716:    {
        1:  717:        glDeleteTextures(1, &bd->FontTexture);
        1:  717-block 5
call    0 returned 1
        1:  718:        io.Fonts->SetTexID(0);
call    0 returned 1
        1:  719:        bd->FontTexture = 0;
        -:  720:    }
        1:  721:}
        -:  722:
        -:  723:// If you get an error please report on github. You may try different GL context version or GLSL version. See GL<>GLSL version table at the top of this file.
function _ZL11CheckShaderjPKc called 2 returned 100% blocks executed 40%
        2:  724:static bool CheckShader(GLuint handle, const char* desc)
        -:  725:{
        2:  726:    ImGui_ImplOpenGL3_Data* bd = ImGui_ImplOpenGL3_GetBackendData();
        2:  726-block 2
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        2:  727:    GLint status = 0, log_length = 0;
        2:  728:    glGetShaderiv(handle, GL_COMPILE_STATUS, &status);
        2:  728-block 3
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        2:  729:    glGetShaderiv(handle, GL_INFO_LOG_LENGTH, &log_length);
        2:  729-block 4
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        2:  730:    if ((GLboolean)status == GL_FALSE)
        2:  730-block 5
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  731:        fprintf(stderr, "ERROR: ImGui_ImplOpenGL3_CreateDeviceObjects: failed to compile %s! With GLSL: %s\n", desc, bd->GlslVersionString);
    %%%%%:  731-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        2:  732:    if (log_length > 1)
        2:  732-block 7
branch  0 taken 0 (fallthrough)
branch  1 taken 2
        -:  733:    {
    #####:  734:        ImVector<char> buf;
    %%%%%:  734-block 8
call    0 never executed
    #####:  735:        buf.resize((int)(log_length + 1));
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  736:        glGetShaderInfoLog(handle, log_length, nullptr, (GLchar*)buf.begin());
    %%%%%:  736-block 10
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####:  737:        fprintf(stderr, "%s\n", buf.begin());
    %%%%%:  737-block 12
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####:  738:    }
    %%%%%:  738-block 14
call    0 never executed
    $$$$$:  738-block 18
call    1 never executed
        2:  739:    return (GLboolean)status == GL_TRUE;
        2:  739-block 16
        2:  739-block 17
        -:  740:}
        -:  741:
        -:  742:// If you get an error please report on GitHub. You may try different GL context version or GLSL version.
function _ZL12CheckProgramjPKc called 1 returned 100% blocks executed 40%
        1:  743:static bool CheckProgram(GLuint handle, const char* desc)
        -:  744:{
        1:  745:    ImGui_ImplOpenGL3_Data* bd = ImGui_ImplOpenGL3_GetBackendData();
        1:  745-block 2
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  746:    GLint status = 0, log_length = 0;
        1:  747:    glGetProgramiv(handle, GL_LINK_STATUS, &status);
        1:  747-block 3
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  748:    glGetProgramiv(handle, GL_INFO_LOG_LENGTH, &log_length);
        1:  748-block 4
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  749:    if ((GLboolean)status == GL_FALSE)
        1:  749-block 5
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:  750:        fprintf(stderr, "ERROR: ImGui_ImplOpenGL3_CreateDeviceObjects: failed to link %s! With GLSL %s\n", desc, bd->GlslVersionString);
    %%%%%:  750-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        1:  751:    if (log_length > 1)
        1:  751-block 7
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:  752:    {
    #####:  753:        ImVector<char> buf;
    %%%%%:  753-block 8
call    0 never executed
    #####:  754:        buf.resize((int)(log_length + 1));
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  755:        glGetProgramInfoLog(handle, log_length, nullptr, (GLchar*)buf.begin());
    %%%%%:  755-block 10
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####:  756:        fprintf(stderr, "%s\n", buf.begin());
    %%%%%:  756-block 12
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####:  757:    }
    %%%%%:  757-block 14
call    0 never executed
    $$$$$:  757-block 18
call    1 never executed
        1:  758:    return (GLboolean)status == GL_TRUE;
        1:  758-block 16
        1:  758-block 17
        -:  759:}
        -:  760:
function _Z37ImGui_ImplOpenGL3_CreateDeviceObjectsv called 1 returned 100% blocks executed 94%
        1:  761:bool    ImGui_ImplOpenGL3_CreateDeviceObjects()
        -:  762:{
        1:  763:    ImGui_ImplOpenGL3_Data* bd = ImGui_ImplOpenGL3_GetBackendData();
        1:  763-block 2
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:  764:
        -:  765:    // Backup GL state
        -:  766:    GLint last_texture, last_array_buffer;
        1:  767:    glGetIntegerv(GL_TEXTURE_BINDING_2D, &last_texture);
        1:  767-block 3
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  768:    glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &last_array_buffer);
        1:  768-block 4
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:  769:#ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_BIND_BUFFER_PIXEL_UNPACK
        1:  770:    GLint last_pixel_unpack_buffer = 0;
        1:  771:    if (bd->GlVersion >= 210) { glGetIntegerv(GL_PIXEL_UNPACK_BUFFER_BINDING, &last_pixel_unpack_buffer); glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0); }
        1:  771-block 5
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  771-block 6
call    2 returned 1
branch  3 taken 1 (fallthrough)
branch  4 taken 0 (throw)
        1:  771-block 7
call    5 returned 1
branch  6 taken 1 (fallthrough)
branch  7 taken 0 (throw)
        -:  772:#endif
        -:  773:#ifdef IMGUI_IMPL_OPENGL_USE_VERTEX_ARRAY
        -:  774:    GLint last_vertex_array;
        1:  775:    glGetIntegerv(GL_VERTEX_ARRAY_BINDING, &last_vertex_array);
        1:  775-block 8
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:  776:#endif
        -:  777:
        -:  778:    // Parse GLSL version string
        1:  779:    int glsl_version = 130;
        1:  780:    sscanf(bd->GlslVersionString, "#version %d", &glsl_version);
        -:  781:
        1:  782:    const GLchar* vertex_shader_glsl_120 =
        -:  783:        "uniform mat4 ProjMtx;\n"
        -:  784:        "attribute vec2 Position;\n"
        -:  785:        "attribute vec2 UV;\n"
        -:  786:        "attribute vec4 Color;\n"
        -:  787:        "varying vec2 Frag_UV;\n"
        -:  788:        "varying vec4 Frag_Color;\n"
        -:  789:        "void main()\n"
        -:  790:        "{\n"
        -:  791:        "    Frag_UV = UV;\n"
        -:  792:        "    Frag_Color = Color;\n"
        -:  793:        "    gl_Position = ProjMtx * vec4(Position.xy,0,1);\n"
        -:  794:        "}\n";
        -:  795:
        1:  796:    const GLchar* vertex_shader_glsl_130 =
        -:  797:        "uniform mat4 ProjMtx;\n"
        -:  798:        "in vec2 Position;\n"
        -:  799:        "in vec2 UV;\n"
        -:  800:        "in vec4 Color;\n"
        -:  801:        "out vec2 Frag_UV;\n"
        -:  802:        "out vec4 Frag_Color;\n"
        -:  803:        "void main()\n"
        -:  804:        "{\n"
        -:  805:        "    Frag_UV = UV;\n"
        -:  806:        "    Frag_Color = Color;\n"
        -:  807:        "    gl_Position = ProjMtx * vec4(Position.xy,0,1);\n"
        -:  808:        "}\n";
        -:  809:
        1:  810:    const GLchar* vertex_shader_glsl_300_es =
        -:  811:        "precision highp float;\n"
        -:  812:        "layout (location = 0) in vec2 Position;\n"
        -:  813:        "layout (location = 1) in vec2 UV;\n"
        -:  814:        "layout (location = 2) in vec4 Color;\n"
        -:  815:        "uniform mat4 ProjMtx;\n"
        -:  816:        "out vec2 Frag_UV;\n"
        -:  817:        "out vec4 Frag_Color;\n"
        -:  818:        "void main()\n"
        -:  819:        "{\n"
        -:  820:        "    Frag_UV = UV;\n"
        -:  821:        "    Frag_Color = Color;\n"
        -:  822:        "    gl_Position = ProjMtx * vec4(Position.xy,0,1);\n"
        -:  823:        "}\n";
        -:  824:
        1:  825:    const GLchar* vertex_shader_glsl_410_core =
        -:  826:        "layout (location = 0) in vec2 Position;\n"
        -:  827:        "layout (location = 1) in vec2 UV;\n"
        -:  828:        "layout (location = 2) in vec4 Color;\n"
        -:  829:        "uniform mat4 ProjMtx;\n"
        -:  830:        "out vec2 Frag_UV;\n"
        -:  831:        "out vec4 Frag_Color;\n"
        -:  832:        "void main()\n"
        -:  833:        "{\n"
        -:  834:        "    Frag_UV = UV;\n"
        -:  835:        "    Frag_Color = Color;\n"
        -:  836:        "    gl_Position = ProjMtx * vec4(Position.xy,0,1);\n"
        -:  837:        "}\n";
        -:  838:
        1:  839:    const GLchar* fragment_shader_glsl_120 =
        -:  840:        "#ifdef GL_ES\n"
        -:  841:        "    precision mediump float;\n"
        -:  842:        "#endif\n"
        -:  843:        "uniform sampler2D Texture;\n"
        -:  844:        "varying vec2 Frag_UV;\n"
        -:  845:        "varying vec4 Frag_Color;\n"
        -:  846:        "void main()\n"
        -:  847:        "{\n"
        -:  848:        "    gl_FragColor = Frag_Color * texture2D(Texture, Frag_UV.st);\n"
        -:  849:        "}\n";
        -:  850:
        1:  851:    const GLchar* fragment_shader_glsl_130 =
        -:  852:        "uniform sampler2D Texture;\n"
        -:  853:        "in vec2 Frag_UV;\n"
        -:  854:        "in vec4 Frag_Color;\n"
        -:  855:        "out vec4 Out_Color;\n"
        -:  856:        "void main()\n"
        -:  857:        "{\n"
        -:  858:        "    Out_Color = Frag_Color * texture(Texture, Frag_UV.st);\n"
        -:  859:        "}\n";
        -:  860:
        1:  861:    const GLchar* fragment_shader_glsl_300_es =
        -:  862:        "precision mediump float;\n"
        -:  863:        "uniform sampler2D Texture;\n"
        -:  864:        "in vec2 Frag_UV;\n"
        -:  865:        "in vec4 Frag_Color;\n"
        -:  866:        "layout (location = 0) out vec4 Out_Color;\n"
        -:  867:        "void main()\n"
        -:  868:        "{\n"
        -:  869:        "    Out_Color = Frag_Color * texture(Texture, Frag_UV.st);\n"
        -:  870:        "}\n";
        -:  871:
        1:  872:    const GLchar* fragment_shader_glsl_410_core =
        -:  873:        "in vec2 Frag_UV;\n"
        -:  874:        "in vec4 Frag_Color;\n"
        -:  875:        "uniform sampler2D Texture;\n"
        -:  876:        "layout (location = 0) out vec4 Out_Color;\n"
        -:  877:        "void main()\n"
        -:  878:        "{\n"
        -:  879:        "    Out_Color = Frag_Color * texture(Texture, Frag_UV.st);\n"
        -:  880:        "}\n";
        -:  881:
        -:  882:    // Select shaders matching our GLSL versions
        1:  883:    const GLchar* vertex_shader = nullptr;
        1:  884:    const GLchar* fragment_shader = nullptr;
        1:  885:    if (glsl_version < 130)
        1:  885-block 9
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:  886:    {
    #####:  887:        vertex_shader = vertex_shader_glsl_120;
    #####:  888:        fragment_shader = fragment_shader_glsl_120;
    %%%%%:  888-block 10
        -:  889:    }
        1:  890:    else if (glsl_version >= 410)
        1:  890-block 11
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:  891:    {
    #####:  892:        vertex_shader = vertex_shader_glsl_410_core;
    #####:  893:        fragment_shader = fragment_shader_glsl_410_core;
    %%%%%:  893-block 12
        -:  894:    }
        1:  895:    else if (glsl_version == 300)
        1:  895-block 13
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:  896:    {
    #####:  897:        vertex_shader = vertex_shader_glsl_300_es;
    #####:  898:        fragment_shader = fragment_shader_glsl_300_es;
    %%%%%:  898-block 14
        -:  899:    }
        -:  900:    else
        -:  901:    {
        1:  902:        vertex_shader = vertex_shader_glsl_130;
        1:  903:        fragment_shader = fragment_shader_glsl_130;
        1:  903-block 15
        -:  904:    }
        -:  905:
        -:  906:    // Create shaders
        1:  907:    const GLchar* vertex_shader_with_version[2] = { bd->GlslVersionString, vertex_shader };
        1:  908:    GLuint vert_handle = glCreateShader(GL_VERTEX_SHADER);
        1:  908-block 16
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  909:    glShaderSource(vert_handle, 2, vertex_shader_with_version, nullptr);
        1:  909-block 17
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  910:    glCompileShader(vert_handle);
        1:  910-block 18
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  911:    CheckShader(vert_handle, "vertex shader");
        1:  911-block 19
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:  912:
        1:  913:    const GLchar* fragment_shader_with_version[2] = { bd->GlslVersionString, fragment_shader };
        1:  914:    GLuint frag_handle = glCreateShader(GL_FRAGMENT_SHADER);
        1:  914-block 20
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  915:    glShaderSource(frag_handle, 2, fragment_shader_with_version, nullptr);
        1:  915-block 21
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  916:    glCompileShader(frag_handle);
        1:  916-block 22
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  917:    CheckShader(frag_handle, "fragment shader");
        1:  917-block 23
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:  918:
        -:  919:    // Link
        1:  920:    bd->ShaderHandle = glCreateProgram();
        1:  920-block 24
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  921:    glAttachShader(bd->ShaderHandle, vert_handle);
        1:  921-block 25
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  922:    glAttachShader(bd->ShaderHandle, frag_handle);
        1:  922-block 26
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  923:    glLinkProgram(bd->ShaderHandle);
        1:  923-block 27
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  924:    CheckProgram(bd->ShaderHandle, "shader program");
        1:  924-block 28
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:  925:
        1:  926:    glDetachShader(bd->ShaderHandle, vert_handle);
        1:  926-block 29
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  927:    glDetachShader(bd->ShaderHandle, frag_handle);
        1:  927-block 30
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  928:    glDeleteShader(vert_handle);
        1:  928-block 31
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  929:    glDeleteShader(frag_handle);
        1:  929-block 32
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:  930:
        1:  931:    bd->AttribLocationTex = glGetUniformLocation(bd->ShaderHandle, "Texture");
        1:  931-block 33
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  932:    bd->AttribLocationProjMtx = glGetUniformLocation(bd->ShaderHandle, "ProjMtx");
        1:  932-block 34
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  933:    bd->AttribLocationVtxPos = (GLuint)glGetAttribLocation(bd->ShaderHandle, "Position");
        1:  933-block 35
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  934:    bd->AttribLocationVtxUV = (GLuint)glGetAttribLocation(bd->ShaderHandle, "UV");
        1:  934-block 36
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  935:    bd->AttribLocationVtxColor = (GLuint)glGetAttribLocation(bd->ShaderHandle, "Color");
        1:  935-block 37
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:  936:
        -:  937:    // Create buffers
        1:  938:    glGenBuffers(1, &bd->VboHandle);
        1:  938-block 38
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  939:    glGenBuffers(1, &bd->ElementsHandle);
        1:  939-block 39
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:  940:
        1:  941:    ImGui_ImplOpenGL3_CreateFontsTexture();
        1:  941-block 40
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:  942:
        -:  943:    // Restore modified GL state
        1:  944:    glBindTexture(GL_TEXTURE_2D, last_texture);
        1:  944-block 41
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  945:    glBindBuffer(GL_ARRAY_BUFFER, last_array_buffer);
        1:  945-block 42
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:  946:#ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_BIND_BUFFER_PIXEL_UNPACK
        1:  947:    if (bd->GlVersion >= 210) { glBindBuffer(GL_PIXEL_UNPACK_BUFFER, last_pixel_unpack_buffer); }
        1:  947-block 43
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  947-block 44
call    2 returned 1
branch  3 taken 1 (fallthrough)
branch  4 taken 0 (throw)
        -:  948:#endif
        -:  949:#ifdef IMGUI_IMPL_OPENGL_USE_VERTEX_ARRAY
        1:  950:    glBindVertexArray(last_vertex_array);
        1:  950-block 45
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:  951:#endif
        -:  952:
        1:  953:    return true;
        1:  953-block 46
        1:  953-block 47
        -:  954:}
        -:  955:
function _Z38ImGui_ImplOpenGL3_DestroyDeviceObjectsv called 1 returned 100% blocks executed 100%
        1:  956:void    ImGui_ImplOpenGL3_DestroyDeviceObjects()
        -:  957:{
        1:  958:    ImGui_ImplOpenGL3_Data* bd = ImGui_ImplOpenGL3_GetBackendData();
        1:  958-block 2
call    0 returned 1
        1:  959:    if (bd->VboHandle)      { glDeleteBuffers(1, &bd->VboHandle); bd->VboHandle = 0; }
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  959-block 4
call    2 returned 1
        1:  960:    if (bd->ElementsHandle) { glDeleteBuffers(1, &bd->ElementsHandle); bd->ElementsHandle = 0; }
        1:  960-block 6
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  960-block 7
call    2 returned 1
        1:  961:    if (bd->ShaderHandle)   { glDeleteProgram(bd->ShaderHandle); bd->ShaderHandle = 0; }
        1:  961-block 9
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  961-block 10
call    2 returned 1
        1:  962:    ImGui_ImplOpenGL3_DestroyFontsTexture();
        1:  962-block 12
call    0 returned 1
        1:  963:}
        -:  964:
        -:  965://--------------------------------------------------------------------------------------------------------
        -:  966:// MULTI-VIEWPORT / PLATFORM INTERFACE SUPPORT
        -:  967:// This is an _advanced_ and _optional_ feature, allowing the backend to create and handle multiple viewports simultaneously.
        -:  968:// If you are new to dear imgui or creating a new binding for dear imgui, it is recommended that you completely ignore this section first..
        -:  969://--------------------------------------------------------------------------------------------------------
        -:  970:
function _ZL30ImGui_ImplOpenGL3_RenderWindowP13ImGuiViewportPv called 0 returned 0% blocks executed 0%
    #####:  971:static void ImGui_ImplOpenGL3_RenderWindow(ImGuiViewport* viewport, void*)
        -:  972:{
    #####:  973:    if (!(viewport->Flags & ImGuiViewportFlags_NoRendererClear))
    %%%%%:  973-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -:  974:    {
    #####:  975:        ImVec4 clear_color = ImVec4(0.0f, 0.0f, 0.0f, 1.0f);
    #####:  976:        glClearColor(clear_color.x, clear_color.y, clear_color.z, clear_color.w);
    %%%%%:  976-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  977:        glClear(GL_COLOR_BUFFER_BIT);
    %%%%%:  977-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:  978:    }
    #####:  979:    ImGui_ImplOpenGL3_RenderDrawData(viewport->DrawData);
    %%%%%:  979-block 6
call    0 never executed
    #####:  980:}
        -:  981:
function _ZL42ImGui_ImplOpenGL3_InitMultiViewportSupportv called 1 returned 100% blocks executed 100%
        1:  982:static void ImGui_ImplOpenGL3_InitMultiViewportSupport()
        -:  983:{
        1:  984:    ImGuiPlatformIO& platform_io = ImGui::GetPlatformIO();
        1:  984-block 2
call    0 returned 1
        1:  985:    platform_io.Renderer_RenderWindow = ImGui_ImplOpenGL3_RenderWindow;
        1:  986:}
        -:  987:
function _ZL46ImGui_ImplOpenGL3_ShutdownMultiViewportSupportv called 1 returned 100% blocks executed 100%
        1:  988:static void ImGui_ImplOpenGL3_ShutdownMultiViewportSupport()
        -:  989:{
        1:  990:    ImGui::DestroyPlatformWindows();
        1:  990-block 2
call    0 returned 1
        1:  991:}
        -:  992:
        -:  993://-----------------------------------------------------------------------------
        -:  994:
        -:  995:#if defined(__GNUC__)
        -:  996:#pragma GCC diagnostic pop
        -:  997:#endif
        -:  998:#if defined(__clang__)
        -:  999:#pragma clang diagnostic pop
        -: 1000:#endif
        -: 1001:
        -: 1002:#endif // #ifndef IMGUI_DISABLE
