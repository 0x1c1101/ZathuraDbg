        -:    0:Source:/home/rc/ZathuraDbg/vendor/imgui/imgui_draw.cpp
        -:    0:Graph:/home/rc/ZathuraDbg/src/cmake-build-debug-coverage/CMakeFiles/Zathura.dir/home/rc/ZathuraDbg/vendor/imgui/imgui_draw.cpp.gcno
        -:    0:Data:/home/rc/ZathuraDbg/src/cmake-build-debug-coverage/CMakeFiles/Zathura.dir/home/rc/ZathuraDbg/vendor/imgui/imgui_draw.cpp.gcda
        -:    0:Runs:1
        -:    1:// dear imgui, v1.91.4
        -:    2:// (drawing and font code)
        -:    3:
        -:    4:/*
        -:    5:
        -:    6:Index of this file:
        -:    7:
        -:    8:// [SECTION] STB libraries implementation
        -:    9:// [SECTION] Style functions
        -:   10:// [SECTION] ImDrawList
        -:   11:// [SECTION] ImTriangulator, ImDrawList concave polygon fill
        -:   12:// [SECTION] ImDrawListSplitter
        -:   13:// [SECTION] ImDrawData
        -:   14:// [SECTION] Helpers ShadeVertsXXX functions
        -:   15:// [SECTION] ImFontConfig
        -:   16:// [SECTION] ImFontAtlas
        -:   17:// [SECTION] ImFontAtlas glyph ranges helpers
        -:   18:// [SECTION] ImFontGlyphRangesBuilder
        -:   19:// [SECTION] ImFont
        -:   20:// [SECTION] ImGui Internal Render Helpers
        -:   21:// [SECTION] Decompression code
        -:   22:// [SECTION] Default font data (ProggyClean.ttf)
        -:   23:
        -:   24:*/
        -:   25:
        -:   26:#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
        -:   27:#define _CRT_SECURE_NO_WARNINGS
        -:   28:#endif
        -:   29:
        -:   30:#ifndef IMGUI_DEFINE_MATH_OPERATORS
        -:   31:#define IMGUI_DEFINE_MATH_OPERATORS
        -:   32:#endif
        -:   33:
        -:   34:#include "imgui.h"
        -:   35:#ifndef IMGUI_DISABLE
        -:   36:#include "imgui_internal.h"
        -:   37:#ifdef IMGUI_ENABLE_FREETYPE
        -:   38:#include "misc/freetype/imgui_freetype.h"
        -:   39:#endif
        -:   40:
        -:   41:#include <stdio.h>      // vsnprintf, sscanf, printf
        -:   42:
        -:   43:// Visual Studio warnings
        -:   44:#ifdef _MSC_VER
        -:   45:#pragma warning (disable: 4127)     // condition expression is constant
        -:   46:#pragma warning (disable: 4505)     // unreferenced local function has been removed (stb stuff)
        -:   47:#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen
        -:   48:#pragma warning (disable: 26451)    // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to a 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).
        -:   49:#pragma warning (disable: 26812)    // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3). [MSVC Static Analyzer)
        -:   50:#endif
        -:   51:
        -:   52:// Clang/GCC warnings with -Weverything
        -:   53:#if defined(__clang__)
        -:   54:#if __has_warning("-Wunknown-warning-option")
        -:   55:#pragma clang diagnostic ignored "-Wunknown-warning-option"         // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!
        -:   56:#endif
        -:   57:#pragma clang diagnostic ignored "-Wunknown-pragmas"                // warning: unknown warning group 'xxx'
        -:   58:#pragma clang diagnostic ignored "-Wold-style-cast"                 // warning: use of old-style cast                            // yes, they are more terse.
        -:   59:#pragma clang diagnostic ignored "-Wfloat-equal"                    // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants ok.
        -:   60:#pragma clang diagnostic ignored "-Wglobal-constructors"            // warning: declaration requires a global destructor         // similar to above, not sure what the exact difference is.
        -:   61:#pragma clang diagnostic ignored "-Wsign-conversion"                // warning: implicit conversion changes signedness
        -:   62:#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"  // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0
        -:   63:#pragma clang diagnostic ignored "-Wcomma"                          // warning: possible misuse of comma operator here
        -:   64:#pragma clang diagnostic ignored "-Wreserved-id-macro"              // warning: macro name is a reserved identifier
        -:   65:#pragma clang diagnostic ignored "-Wdouble-promotion"               // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.
        -:   66:#pragma clang diagnostic ignored "-Wimplicit-int-float-conversion"  // warning: implicit conversion from 'xxx' to 'float' may lose precision
        -:   67:#pragma clang diagnostic ignored "-Wreserved-identifier"            // warning: identifier '_Xxx' is reserved because it starts with '_' followed by a capital letter
        -:   68:#pragma clang diagnostic ignored "-Wunsafe-buffer-usage"            // warning: 'xxx' is an unsafe pointer used for buffer access
        -:   69:#elif defined(__GNUC__)
        -:   70:#pragma GCC diagnostic ignored "-Wpragmas"                  // warning: unknown option after '#pragma GCC diagnostic' kind
        -:   71:#pragma GCC diagnostic ignored "-Wunused-function"          // warning: 'xxxx' defined but not used
        -:   72:#pragma GCC diagnostic ignored "-Wdouble-promotion"         // warning: implicit conversion from 'float' to 'double' when passing argument to function
        -:   73:#pragma GCC diagnostic ignored "-Wconversion"               // warning: conversion to 'xxxx' from 'xxxx' may alter its value
        -:   74:#pragma GCC diagnostic ignored "-Wstack-protector"          // warning: stack protector not protecting local variables: variable length buffer
        -:   75:#pragma GCC diagnostic ignored "-Wclass-memaccess"          // [__GNUC__ >= 8] warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead
        -:   76:#endif
        -:   77:
        -:   78://-------------------------------------------------------------------------
        -:   79:// [SECTION] STB libraries implementation (for stb_truetype and stb_rect_pack)
        -:   80://-------------------------------------------------------------------------
        -:   81:
        -:   82:// Compile time options:
        -:   83://#define IMGUI_STB_NAMESPACE           ImStb
        -:   84://#define IMGUI_STB_TRUETYPE_FILENAME   "my_folder/stb_truetype.h"
        -:   85://#define IMGUI_STB_RECT_PACK_FILENAME  "my_folder/stb_rect_pack.h"
        -:   86://#define IMGUI_DISABLE_STB_TRUETYPE_IMPLEMENTATION
        -:   87://#define IMGUI_DISABLE_STB_RECT_PACK_IMPLEMENTATION
        -:   88:
        -:   89:#ifdef IMGUI_STB_NAMESPACE
        -:   90:namespace IMGUI_STB_NAMESPACE
        -:   91:{
        -:   92:#endif
        -:   93:
        -:   94:#ifdef _MSC_VER
        -:   95:#pragma warning (push)
        -:   96:#pragma warning (disable: 4456)                             // declaration of 'xx' hides previous local declaration
        -:   97:#pragma warning (disable: 6011)                             // (stb_rectpack) Dereferencing NULL pointer 'cur->next'.
        -:   98:#pragma warning (disable: 6385)                             // (stb_truetype) Reading invalid data from 'buffer':  the readable size is '_Old_3`kernel_width' bytes, but '3' bytes may be read.
        -:   99:#pragma warning (disable: 28182)                            // (stb_rectpack) Dereferencing NULL pointer. 'cur' contains the same NULL value as 'cur->next' did.
        -:  100:#endif
        -:  101:
        -:  102:#if defined(__clang__)
        -:  103:#pragma clang diagnostic push
        -:  104:#pragma clang diagnostic ignored "-Wunused-function"
        -:  105:#pragma clang diagnostic ignored "-Wmissing-prototypes"
        -:  106:#pragma clang diagnostic ignored "-Wimplicit-fallthrough"
        -:  107:#pragma clang diagnostic ignored "-Wcast-qual"              // warning: cast from 'const xxxx *' to 'xxx *' drops const qualifier
        -:  108:#endif
        -:  109:
        -:  110:#if defined(__GNUC__)
        -:  111:#pragma GCC diagnostic push
        -:  112:#pragma GCC diagnostic ignored "-Wtype-limits"              // warning: comparison is always true due to limited range of data type [-Wtype-limits]
        -:  113:#pragma GCC diagnostic ignored "-Wcast-qual"                // warning: cast from type 'const xxxx *' to type 'xxxx *' casts away qualifiers
        -:  114:#endif
        -:  115:
        -:  116:#ifndef STB_RECT_PACK_IMPLEMENTATION                        // in case the user already have an implementation in the _same_ compilation unit (e.g. unity builds)
        -:  117:#ifndef IMGUI_DISABLE_STB_RECT_PACK_IMPLEMENTATION          // in case the user already have an implementation in another compilation unit
        -:  118:#define STBRP_STATIC
        -:  119:#define STBRP_ASSERT(x)     do { IM_ASSERT(x); } while (0)
        -:  120:#define STBRP_SORT          ImQsort
        -:  121:#define STB_RECT_PACK_IMPLEMENTATION
        -:  122:#endif
        -:  123:#ifdef IMGUI_STB_RECT_PACK_FILENAME
        -:  124:#include IMGUI_STB_RECT_PACK_FILENAME
        -:  125:#else
        -:  126:#include "imstb_rectpack.h"
        -:  127:#endif
        -:  128:#endif
        -:  129:
        -:  130:#ifdef  IMGUI_ENABLE_STB_TRUETYPE
        -:  131:#ifndef STB_TRUETYPE_IMPLEMENTATION                         // in case the user already have an implementation in the _same_ compilation unit (e.g. unity builds)
        -:  132:#ifndef IMGUI_DISABLE_STB_TRUETYPE_IMPLEMENTATION           // in case the user already have an implementation in another compilation unit
        -:  133:#define STBTT_malloc(x,u)   ((void)(u), IM_ALLOC(x))
        -:  134:#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
        -:  135:#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
        -:  136:#define STBTT_fmod(x,y)     ImFmod(x,y)
        -:  137:#define STBTT_sqrt(x)       ImSqrt(x)
        -:  138:#define STBTT_pow(x,y)      ImPow(x,y)
        -:  139:#define STBTT_fabs(x)       ImFabs(x)
        -:  140:#define STBTT_ifloor(x)     ((int)ImFloor(x))
        -:  141:#define STBTT_iceil(x)      ((int)ImCeil(x))
        -:  142:#define STBTT_STATIC
        -:  143:#define STB_TRUETYPE_IMPLEMENTATION
        -:  144:#else
        -:  145:#define STBTT_DEF extern
        -:  146:#endif
        -:  147:#ifdef IMGUI_STB_TRUETYPE_FILENAME
        -:  148:#include IMGUI_STB_TRUETYPE_FILENAME
        -:  149:#else
        -:  150:#include "imstb_truetype.h"
        -:  151:#endif
        -:  152:#endif
        -:  153:#endif // IMGUI_ENABLE_STB_TRUETYPE
        -:  154:
        -:  155:#if defined(__GNUC__)
        -:  156:#pragma GCC diagnostic pop
        -:  157:#endif
        -:  158:
        -:  159:#if defined(__clang__)
        -:  160:#pragma clang diagnostic pop
        -:  161:#endif
        -:  162:
        -:  163:#if defined(_MSC_VER)
        -:  164:#pragma warning (pop)
        -:  165:#endif
        -:  166:
        -:  167:#ifdef IMGUI_STB_NAMESPACE
        -:  168:} // namespace ImStb
        -:  169:using namespace IMGUI_STB_NAMESPACE;
        -:  170:#endif
        -:  171:
        -:  172://-----------------------------------------------------------------------------
        -:  173:// [SECTION] Style functions
        -:  174://-----------------------------------------------------------------------------
        -:  175:
function _ZN5ImGui15StyleColorsDarkEP10ImGuiStyle called 1 returned 100% blocks executed 97%
        1:  176:void ImGui::StyleColorsDark(ImGuiStyle* dst)
        -:  177:{
       1*:  178:    ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();
        1:  178-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%:  178-block 3
call    2 never executed
        1:  178-block 5
        1:  179:    ImVec4* colors = style->Colors;
        -:  180:
        1:  181:    colors[ImGuiCol_Text]                   = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);
        1:  181-block 6
call    0 returned 1
        1:  182:    colors[ImGuiCol_TextDisabled]           = ImVec4(0.50f, 0.50f, 0.50f, 1.00f);
call    0 returned 1
        1:  183:    colors[ImGuiCol_WindowBg]               = ImVec4(0.06f, 0.06f, 0.06f, 0.94f);
call    0 returned 1
        1:  184:    colors[ImGuiCol_ChildBg]                = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
call    0 returned 1
        1:  185:    colors[ImGuiCol_PopupBg]                = ImVec4(0.08f, 0.08f, 0.08f, 0.94f);
call    0 returned 1
        1:  186:    colors[ImGuiCol_Border]                 = ImVec4(0.43f, 0.43f, 0.50f, 0.50f);
call    0 returned 1
        1:  187:    colors[ImGuiCol_BorderShadow]           = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
call    0 returned 1
        1:  188:    colors[ImGuiCol_FrameBg]                = ImVec4(0.16f, 0.29f, 0.48f, 0.54f);
call    0 returned 1
        1:  189:    colors[ImGuiCol_FrameBgHovered]         = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
call    0 returned 1
        1:  190:    colors[ImGuiCol_FrameBgActive]          = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
call    0 returned 1
        1:  191:    colors[ImGuiCol_TitleBg]                = ImVec4(0.04f, 0.04f, 0.04f, 1.00f);
call    0 returned 1
        1:  192:    colors[ImGuiCol_TitleBgActive]          = ImVec4(0.16f, 0.29f, 0.48f, 1.00f);
call    0 returned 1
        1:  193:    colors[ImGuiCol_TitleBgCollapsed]       = ImVec4(0.00f, 0.00f, 0.00f, 0.51f);
call    0 returned 1
        1:  194:    colors[ImGuiCol_MenuBarBg]              = ImVec4(0.14f, 0.14f, 0.14f, 1.00f);
call    0 returned 1
        1:  195:    colors[ImGuiCol_ScrollbarBg]            = ImVec4(0.02f, 0.02f, 0.02f, 0.53f);
call    0 returned 1
        1:  196:    colors[ImGuiCol_ScrollbarGrab]          = ImVec4(0.31f, 0.31f, 0.31f, 1.00f);
call    0 returned 1
        1:  197:    colors[ImGuiCol_ScrollbarGrabHovered]   = ImVec4(0.41f, 0.41f, 0.41f, 1.00f);
call    0 returned 1
        1:  198:    colors[ImGuiCol_ScrollbarGrabActive]    = ImVec4(0.51f, 0.51f, 0.51f, 1.00f);
call    0 returned 1
        1:  199:    colors[ImGuiCol_CheckMark]              = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
call    0 returned 1
        1:  200:    colors[ImGuiCol_SliderGrab]             = ImVec4(0.24f, 0.52f, 0.88f, 1.00f);
call    0 returned 1
        1:  201:    colors[ImGuiCol_SliderGrabActive]       = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
call    0 returned 1
        1:  202:    colors[ImGuiCol_Button]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
call    0 returned 1
        1:  203:    colors[ImGuiCol_ButtonHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
call    0 returned 1
        1:  204:    colors[ImGuiCol_ButtonActive]           = ImVec4(0.06f, 0.53f, 0.98f, 1.00f);
call    0 returned 1
        1:  205:    colors[ImGuiCol_Header]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.31f);
call    0 returned 1
        1:  206:    colors[ImGuiCol_HeaderHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 0.80f);
call    0 returned 1
        1:  207:    colors[ImGuiCol_HeaderActive]           = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
call    0 returned 1
        1:  208:    colors[ImGuiCol_Separator]              = colors[ImGuiCol_Border];
        1:  209:    colors[ImGuiCol_SeparatorHovered]       = ImVec4(0.10f, 0.40f, 0.75f, 0.78f);
call    0 returned 1
        1:  210:    colors[ImGuiCol_SeparatorActive]        = ImVec4(0.10f, 0.40f, 0.75f, 1.00f);
call    0 returned 1
        1:  211:    colors[ImGuiCol_ResizeGrip]             = ImVec4(0.26f, 0.59f, 0.98f, 0.20f);
call    0 returned 1
        1:  212:    colors[ImGuiCol_ResizeGripHovered]      = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
call    0 returned 1
        1:  213:    colors[ImGuiCol_ResizeGripActive]       = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);
call    0 returned 1
        1:  214:    colors[ImGuiCol_TabHovered]             = colors[ImGuiCol_HeaderHovered];
        1:  215:    colors[ImGuiCol_Tab]                    = ImLerp(colors[ImGuiCol_Header],       colors[ImGuiCol_TitleBgActive], 0.80f);
call    0 returned 1
        1:  216:    colors[ImGuiCol_TabSelected]            = ImLerp(colors[ImGuiCol_HeaderActive], colors[ImGuiCol_TitleBgActive], 0.60f);
call    0 returned 1
        1:  217:    colors[ImGuiCol_TabSelectedOverline]    = colors[ImGuiCol_HeaderActive];
        1:  218:    colors[ImGuiCol_TabDimmed]              = ImLerp(colors[ImGuiCol_Tab],          colors[ImGuiCol_TitleBg], 0.80f);
call    0 returned 1
        1:  219:    colors[ImGuiCol_TabDimmedSelected]      = ImLerp(colors[ImGuiCol_TabSelected],  colors[ImGuiCol_TitleBg], 0.40f);
call    0 returned 1
        1:  220:    colors[ImGuiCol_TabDimmedSelectedOverline] = ImVec4(0.50f, 0.50f, 0.50f, 1.00f);
call    0 returned 1
        1:  221:    colors[ImGuiCol_DockingPreview]         = colors[ImGuiCol_HeaderActive] * ImVec4(1.0f, 1.0f, 1.0f, 0.7f);
call    0 returned 1
call    1 returned 1
        1:  222:    colors[ImGuiCol_DockingEmptyBg]         = ImVec4(0.20f, 0.20f, 0.20f, 1.00f);
call    0 returned 1
        1:  223:    colors[ImGuiCol_PlotLines]              = ImVec4(0.61f, 0.61f, 0.61f, 1.00f);
call    0 returned 1
        1:  224:    colors[ImGuiCol_PlotLinesHovered]       = ImVec4(1.00f, 0.43f, 0.35f, 1.00f);
call    0 returned 1
        1:  225:    colors[ImGuiCol_PlotHistogram]          = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);
call    0 returned 1
        1:  226:    colors[ImGuiCol_PlotHistogramHovered]   = ImVec4(1.00f, 0.60f, 0.00f, 1.00f);
call    0 returned 1
        1:  227:    colors[ImGuiCol_TableHeaderBg]          = ImVec4(0.19f, 0.19f, 0.20f, 1.00f);
call    0 returned 1
        1:  228:    colors[ImGuiCol_TableBorderStrong]      = ImVec4(0.31f, 0.31f, 0.35f, 1.00f);   // Prefer using Alpha=1.0 here
call    0 returned 1
        1:  229:    colors[ImGuiCol_TableBorderLight]       = ImVec4(0.23f, 0.23f, 0.25f, 1.00f);   // Prefer using Alpha=1.0 here
call    0 returned 1
        1:  230:    colors[ImGuiCol_TableRowBg]             = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
call    0 returned 1
        1:  231:    colors[ImGuiCol_TableRowBgAlt]          = ImVec4(1.00f, 1.00f, 1.00f, 0.06f);
call    0 returned 1
        1:  232:    colors[ImGuiCol_TextLink]               = colors[ImGuiCol_HeaderActive];
        1:  233:    colors[ImGuiCol_TextSelectedBg]         = ImVec4(0.26f, 0.59f, 0.98f, 0.35f);
call    0 returned 1
        1:  234:    colors[ImGuiCol_DragDropTarget]         = ImVec4(1.00f, 1.00f, 0.00f, 0.90f);
call    0 returned 1
        1:  235:    colors[ImGuiCol_NavCursor]              = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
call    0 returned 1
        1:  236:    colors[ImGuiCol_NavWindowingHighlight]  = ImVec4(1.00f, 1.00f, 1.00f, 0.70f);
call    0 returned 1
        1:  237:    colors[ImGuiCol_NavWindowingDimBg]      = ImVec4(0.80f, 0.80f, 0.80f, 0.20f);
call    0 returned 1
        1:  238:    colors[ImGuiCol_ModalWindowDimBg]       = ImVec4(0.80f, 0.80f, 0.80f, 0.35f);
call    0 returned 1
        1:  239:}
        -:  240:
function _ZN5ImGui18StyleColorsClassicEP10ImGuiStyle called 0 returned 0% blocks executed 0%
    #####:  241:void ImGui::StyleColorsClassic(ImGuiStyle* dst)
        -:  242:{
    #####:  243:    ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();
    %%%%%:  243-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  243-block 3
call    2 never executed
    %%%%%:  243-block 5
    #####:  244:    ImVec4* colors = style->Colors;
        -:  245:
    #####:  246:    colors[ImGuiCol_Text]                   = ImVec4(0.90f, 0.90f, 0.90f, 1.00f);
    %%%%%:  246-block 6
call    0 never executed
    #####:  247:    colors[ImGuiCol_TextDisabled]           = ImVec4(0.60f, 0.60f, 0.60f, 1.00f);
call    0 never executed
    #####:  248:    colors[ImGuiCol_WindowBg]               = ImVec4(0.00f, 0.00f, 0.00f, 0.85f);
call    0 never executed
    #####:  249:    colors[ImGuiCol_ChildBg]                = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
call    0 never executed
    #####:  250:    colors[ImGuiCol_PopupBg]                = ImVec4(0.11f, 0.11f, 0.14f, 0.92f);
call    0 never executed
    #####:  251:    colors[ImGuiCol_Border]                 = ImVec4(0.50f, 0.50f, 0.50f, 0.50f);
call    0 never executed
    #####:  252:    colors[ImGuiCol_BorderShadow]           = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
call    0 never executed
    #####:  253:    colors[ImGuiCol_FrameBg]                = ImVec4(0.43f, 0.43f, 0.43f, 0.39f);
call    0 never executed
    #####:  254:    colors[ImGuiCol_FrameBgHovered]         = ImVec4(0.47f, 0.47f, 0.69f, 0.40f);
call    0 never executed
    #####:  255:    colors[ImGuiCol_FrameBgActive]          = ImVec4(0.42f, 0.41f, 0.64f, 0.69f);
call    0 never executed
    #####:  256:    colors[ImGuiCol_TitleBg]                = ImVec4(0.27f, 0.27f, 0.54f, 0.83f);
call    0 never executed
    #####:  257:    colors[ImGuiCol_TitleBgActive]          = ImVec4(0.32f, 0.32f, 0.63f, 0.87f);
call    0 never executed
    #####:  258:    colors[ImGuiCol_TitleBgCollapsed]       = ImVec4(0.40f, 0.40f, 0.80f, 0.20f);
call    0 never executed
    #####:  259:    colors[ImGuiCol_MenuBarBg]              = ImVec4(0.40f, 0.40f, 0.55f, 0.80f);
call    0 never executed
    #####:  260:    colors[ImGuiCol_ScrollbarBg]            = ImVec4(0.20f, 0.25f, 0.30f, 0.60f);
call    0 never executed
    #####:  261:    colors[ImGuiCol_ScrollbarGrab]          = ImVec4(0.40f, 0.40f, 0.80f, 0.30f);
call    0 never executed
    #####:  262:    colors[ImGuiCol_ScrollbarGrabHovered]   = ImVec4(0.40f, 0.40f, 0.80f, 0.40f);
call    0 never executed
    #####:  263:    colors[ImGuiCol_ScrollbarGrabActive]    = ImVec4(0.41f, 0.39f, 0.80f, 0.60f);
call    0 never executed
    #####:  264:    colors[ImGuiCol_CheckMark]              = ImVec4(0.90f, 0.90f, 0.90f, 0.50f);
call    0 never executed
    #####:  265:    colors[ImGuiCol_SliderGrab]             = ImVec4(1.00f, 1.00f, 1.00f, 0.30f);
call    0 never executed
    #####:  266:    colors[ImGuiCol_SliderGrabActive]       = ImVec4(0.41f, 0.39f, 0.80f, 0.60f);
call    0 never executed
    #####:  267:    colors[ImGuiCol_Button]                 = ImVec4(0.35f, 0.40f, 0.61f, 0.62f);
call    0 never executed
    #####:  268:    colors[ImGuiCol_ButtonHovered]          = ImVec4(0.40f, 0.48f, 0.71f, 0.79f);
call    0 never executed
    #####:  269:    colors[ImGuiCol_ButtonActive]           = ImVec4(0.46f, 0.54f, 0.80f, 1.00f);
call    0 never executed
    #####:  270:    colors[ImGuiCol_Header]                 = ImVec4(0.40f, 0.40f, 0.90f, 0.45f);
call    0 never executed
    #####:  271:    colors[ImGuiCol_HeaderHovered]          = ImVec4(0.45f, 0.45f, 0.90f, 0.80f);
call    0 never executed
    #####:  272:    colors[ImGuiCol_HeaderActive]           = ImVec4(0.53f, 0.53f, 0.87f, 0.80f);
call    0 never executed
    #####:  273:    colors[ImGuiCol_Separator]              = ImVec4(0.50f, 0.50f, 0.50f, 0.60f);
call    0 never executed
    #####:  274:    colors[ImGuiCol_SeparatorHovered]       = ImVec4(0.60f, 0.60f, 0.70f, 1.00f);
call    0 never executed
    #####:  275:    colors[ImGuiCol_SeparatorActive]        = ImVec4(0.70f, 0.70f, 0.90f, 1.00f);
call    0 never executed
    #####:  276:    colors[ImGuiCol_ResizeGrip]             = ImVec4(1.00f, 1.00f, 1.00f, 0.10f);
call    0 never executed
    #####:  277:    colors[ImGuiCol_ResizeGripHovered]      = ImVec4(0.78f, 0.82f, 1.00f, 0.60f);
call    0 never executed
    #####:  278:    colors[ImGuiCol_ResizeGripActive]       = ImVec4(0.78f, 0.82f, 1.00f, 0.90f);
call    0 never executed
    #####:  279:    colors[ImGuiCol_TabHovered]             = colors[ImGuiCol_HeaderHovered];
    #####:  280:    colors[ImGuiCol_Tab]                    = ImLerp(colors[ImGuiCol_Header],       colors[ImGuiCol_TitleBgActive], 0.80f);
call    0 never executed
    #####:  281:    colors[ImGuiCol_TabSelected]            = ImLerp(colors[ImGuiCol_HeaderActive], colors[ImGuiCol_TitleBgActive], 0.60f);
call    0 never executed
    #####:  282:    colors[ImGuiCol_TabSelectedOverline]    = colors[ImGuiCol_HeaderActive];
    #####:  283:    colors[ImGuiCol_TabDimmed]              = ImLerp(colors[ImGuiCol_Tab],          colors[ImGuiCol_TitleBg], 0.80f);
call    0 never executed
    #####:  284:    colors[ImGuiCol_TabDimmedSelected]      = ImLerp(colors[ImGuiCol_TabSelected],  colors[ImGuiCol_TitleBg], 0.40f);
call    0 never executed
    #####:  285:    colors[ImGuiCol_TabDimmedSelectedOverline] = colors[ImGuiCol_HeaderActive];
    #####:  286:    colors[ImGuiCol_DockingPreview]         = colors[ImGuiCol_Header] * ImVec4(1.0f, 1.0f, 1.0f, 0.7f);
call    0 never executed
call    1 never executed
    #####:  287:    colors[ImGuiCol_DockingEmptyBg]         = ImVec4(0.20f, 0.20f, 0.20f, 1.00f);
call    0 never executed
    #####:  288:    colors[ImGuiCol_PlotLines]              = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);
call    0 never executed
    #####:  289:    colors[ImGuiCol_PlotLinesHovered]       = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);
call    0 never executed
    #####:  290:    colors[ImGuiCol_PlotHistogram]          = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);
call    0 never executed
    #####:  291:    colors[ImGuiCol_PlotHistogramHovered]   = ImVec4(1.00f, 0.60f, 0.00f, 1.00f);
call    0 never executed
    #####:  292:    colors[ImGuiCol_TableHeaderBg]          = ImVec4(0.27f, 0.27f, 0.38f, 1.00f);
call    0 never executed
    #####:  293:    colors[ImGuiCol_TableBorderStrong]      = ImVec4(0.31f, 0.31f, 0.45f, 1.00f);   // Prefer using Alpha=1.0 here
call    0 never executed
    #####:  294:    colors[ImGuiCol_TableBorderLight]       = ImVec4(0.26f, 0.26f, 0.28f, 1.00f);   // Prefer using Alpha=1.0 here
call    0 never executed
    #####:  295:    colors[ImGuiCol_TableRowBg]             = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
call    0 never executed
    #####:  296:    colors[ImGuiCol_TableRowBgAlt]          = ImVec4(1.00f, 1.00f, 1.00f, 0.07f);
call    0 never executed
    #####:  297:    colors[ImGuiCol_TextLink]               = colors[ImGuiCol_HeaderActive];
    #####:  298:    colors[ImGuiCol_TextSelectedBg]         = ImVec4(0.00f, 0.00f, 1.00f, 0.35f);
call    0 never executed
    #####:  299:    colors[ImGuiCol_DragDropTarget]         = ImVec4(1.00f, 1.00f, 0.00f, 0.90f);
call    0 never executed
    #####:  300:    colors[ImGuiCol_NavCursor]              = colors[ImGuiCol_HeaderHovered];
    #####:  301:    colors[ImGuiCol_NavWindowingHighlight]  = ImVec4(1.00f, 1.00f, 1.00f, 0.70f);
call    0 never executed
    #####:  302:    colors[ImGuiCol_NavWindowingDimBg]      = ImVec4(0.80f, 0.80f, 0.80f, 0.20f);
call    0 never executed
    #####:  303:    colors[ImGuiCol_ModalWindowDimBg]       = ImVec4(0.20f, 0.20f, 0.20f, 0.35f);
call    0 never executed
    #####:  304:}
        -:  305:
        -:  306:// Those light colors are better suited with a thicker font than the default one + FrameBorder
function _ZN5ImGui16StyleColorsLightEP10ImGuiStyle called 0 returned 0% blocks executed 0%
    #####:  307:void ImGui::StyleColorsLight(ImGuiStyle* dst)
        -:  308:{
    #####:  309:    ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();
    %%%%%:  309-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  309-block 3
call    2 never executed
    %%%%%:  309-block 5
    #####:  310:    ImVec4* colors = style->Colors;
        -:  311:
    #####:  312:    colors[ImGuiCol_Text]                   = ImVec4(0.00f, 0.00f, 0.00f, 1.00f);
    %%%%%:  312-block 6
call    0 never executed
    #####:  313:    colors[ImGuiCol_TextDisabled]           = ImVec4(0.60f, 0.60f, 0.60f, 1.00f);
call    0 never executed
    #####:  314:    colors[ImGuiCol_WindowBg]               = ImVec4(0.94f, 0.94f, 0.94f, 1.00f);
call    0 never executed
    #####:  315:    colors[ImGuiCol_ChildBg]                = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
call    0 never executed
    #####:  316:    colors[ImGuiCol_PopupBg]                = ImVec4(1.00f, 1.00f, 1.00f, 0.98f);
call    0 never executed
    #####:  317:    colors[ImGuiCol_Border]                 = ImVec4(0.00f, 0.00f, 0.00f, 0.30f);
call    0 never executed
    #####:  318:    colors[ImGuiCol_BorderShadow]           = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
call    0 never executed
    #####:  319:    colors[ImGuiCol_FrameBg]                = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);
call    0 never executed
    #####:  320:    colors[ImGuiCol_FrameBgHovered]         = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
call    0 never executed
    #####:  321:    colors[ImGuiCol_FrameBgActive]          = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
call    0 never executed
    #####:  322:    colors[ImGuiCol_TitleBg]                = ImVec4(0.96f, 0.96f, 0.96f, 1.00f);
call    0 never executed
    #####:  323:    colors[ImGuiCol_TitleBgActive]          = ImVec4(0.82f, 0.82f, 0.82f, 1.00f);
call    0 never executed
    #####:  324:    colors[ImGuiCol_TitleBgCollapsed]       = ImVec4(1.00f, 1.00f, 1.00f, 0.51f);
call    0 never executed
    #####:  325:    colors[ImGuiCol_MenuBarBg]              = ImVec4(0.86f, 0.86f, 0.86f, 1.00f);
call    0 never executed
    #####:  326:    colors[ImGuiCol_ScrollbarBg]            = ImVec4(0.98f, 0.98f, 0.98f, 0.53f);
call    0 never executed
    #####:  327:    colors[ImGuiCol_ScrollbarGrab]          = ImVec4(0.69f, 0.69f, 0.69f, 0.80f);
call    0 never executed
    #####:  328:    colors[ImGuiCol_ScrollbarGrabHovered]   = ImVec4(0.49f, 0.49f, 0.49f, 0.80f);
call    0 never executed
    #####:  329:    colors[ImGuiCol_ScrollbarGrabActive]    = ImVec4(0.49f, 0.49f, 0.49f, 1.00f);
call    0 never executed
    #####:  330:    colors[ImGuiCol_CheckMark]              = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
call    0 never executed
    #####:  331:    colors[ImGuiCol_SliderGrab]             = ImVec4(0.26f, 0.59f, 0.98f, 0.78f);
call    0 never executed
    #####:  332:    colors[ImGuiCol_SliderGrabActive]       = ImVec4(0.46f, 0.54f, 0.80f, 0.60f);
call    0 never executed
    #####:  333:    colors[ImGuiCol_Button]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
call    0 never executed
    #####:  334:    colors[ImGuiCol_ButtonHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
call    0 never executed
    #####:  335:    colors[ImGuiCol_ButtonActive]           = ImVec4(0.06f, 0.53f, 0.98f, 1.00f);
call    0 never executed
    #####:  336:    colors[ImGuiCol_Header]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.31f);
call    0 never executed
    #####:  337:    colors[ImGuiCol_HeaderHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 0.80f);
call    0 never executed
    #####:  338:    colors[ImGuiCol_HeaderActive]           = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
call    0 never executed
    #####:  339:    colors[ImGuiCol_Separator]              = ImVec4(0.39f, 0.39f, 0.39f, 0.62f);
call    0 never executed
    #####:  340:    colors[ImGuiCol_SeparatorHovered]       = ImVec4(0.14f, 0.44f, 0.80f, 0.78f);
call    0 never executed
    #####:  341:    colors[ImGuiCol_SeparatorActive]        = ImVec4(0.14f, 0.44f, 0.80f, 1.00f);
call    0 never executed
    #####:  342:    colors[ImGuiCol_ResizeGrip]             = ImVec4(0.35f, 0.35f, 0.35f, 0.17f);
call    0 never executed
    #####:  343:    colors[ImGuiCol_ResizeGripHovered]      = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
call    0 never executed
    #####:  344:    colors[ImGuiCol_ResizeGripActive]       = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);
call    0 never executed
    #####:  345:    colors[ImGuiCol_TabHovered]             = colors[ImGuiCol_HeaderHovered];
    #####:  346:    colors[ImGuiCol_Tab]                    = ImLerp(colors[ImGuiCol_Header],       colors[ImGuiCol_TitleBgActive], 0.90f);
call    0 never executed
    #####:  347:    colors[ImGuiCol_TabSelected]            = ImLerp(colors[ImGuiCol_HeaderActive], colors[ImGuiCol_TitleBgActive], 0.60f);
call    0 never executed
    #####:  348:    colors[ImGuiCol_TabSelectedOverline]    = colors[ImGuiCol_HeaderActive];
    #####:  349:    colors[ImGuiCol_TabDimmed]              = ImLerp(colors[ImGuiCol_Tab],          colors[ImGuiCol_TitleBg], 0.80f);
call    0 never executed
    #####:  350:    colors[ImGuiCol_TabDimmedSelected]      = ImLerp(colors[ImGuiCol_TabSelected],  colors[ImGuiCol_TitleBg], 0.40f);
call    0 never executed
    #####:  351:    colors[ImGuiCol_TabDimmedSelectedOverline] = ImVec4(0.26f, 0.59f, 1.00f, 1.00f);
call    0 never executed
    #####:  352:    colors[ImGuiCol_DockingPreview]         = colors[ImGuiCol_Header] * ImVec4(1.0f, 1.0f, 1.0f, 0.7f);
call    0 never executed
call    1 never executed
    #####:  353:    colors[ImGuiCol_DockingEmptyBg]         = ImVec4(0.20f, 0.20f, 0.20f, 1.00f);
call    0 never executed
    #####:  354:    colors[ImGuiCol_PlotLines]              = ImVec4(0.39f, 0.39f, 0.39f, 1.00f);
call    0 never executed
    #####:  355:    colors[ImGuiCol_PlotLinesHovered]       = ImVec4(1.00f, 0.43f, 0.35f, 1.00f);
call    0 never executed
    #####:  356:    colors[ImGuiCol_PlotHistogram]          = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);
call    0 never executed
    #####:  357:    colors[ImGuiCol_PlotHistogramHovered]   = ImVec4(1.00f, 0.45f, 0.00f, 1.00f);
call    0 never executed
    #####:  358:    colors[ImGuiCol_TableHeaderBg]          = ImVec4(0.78f, 0.87f, 0.98f, 1.00f);
call    0 never executed
    #####:  359:    colors[ImGuiCol_TableBorderStrong]      = ImVec4(0.57f, 0.57f, 0.64f, 1.00f);   // Prefer using Alpha=1.0 here
call    0 never executed
    #####:  360:    colors[ImGuiCol_TableBorderLight]       = ImVec4(0.68f, 0.68f, 0.74f, 1.00f);   // Prefer using Alpha=1.0 here
call    0 never executed
    #####:  361:    colors[ImGuiCol_TableRowBg]             = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
call    0 never executed
    #####:  362:    colors[ImGuiCol_TableRowBgAlt]          = ImVec4(0.30f, 0.30f, 0.30f, 0.09f);
call    0 never executed
    #####:  363:    colors[ImGuiCol_TextLink]               = colors[ImGuiCol_HeaderActive];
    #####:  364:    colors[ImGuiCol_TextSelectedBg]         = ImVec4(0.26f, 0.59f, 0.98f, 0.35f);
call    0 never executed
    #####:  365:    colors[ImGuiCol_DragDropTarget]         = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);
call    0 never executed
    #####:  366:    colors[ImGuiCol_NavCursor]              = colors[ImGuiCol_HeaderHovered];
    #####:  367:    colors[ImGuiCol_NavWindowingHighlight]  = ImVec4(0.70f, 0.70f, 0.70f, 0.70f);
call    0 never executed
    #####:  368:    colors[ImGuiCol_NavWindowingDimBg]      = ImVec4(0.20f, 0.20f, 0.20f, 0.20f);
call    0 never executed
    #####:  369:    colors[ImGuiCol_ModalWindowDimBg]       = ImVec4(0.20f, 0.20f, 0.20f, 0.35f);
call    0 never executed
    #####:  370:}
        -:  371:
        -:  372://-----------------------------------------------------------------------------
        -:  373:// [SECTION] ImDrawList
        -:  374://-----------------------------------------------------------------------------
        -:  375:
function _ZN20ImDrawListSharedDataC2Ev called 1 returned 100% blocks executed 100%
        1:  376:ImDrawListSharedData::ImDrawListSharedData()
        1:  376-block 2
call    0 returned 1
call    1 returned 1
call    2 returned 1
        -:  377:{
        1:  378:    memset(this, 0, sizeof(*this));
       49:  379:    for (int i = 0; i < IM_ARRAYSIZE(ArcFastVtx); i++)
       49:  379-block 8
branch  0 taken 48
branch  1 taken 1 (fallthrough)
        -:  380:    {
       48:  381:        const float a = ((float)i * 2 * IM_PI) / (float)IM_ARRAYSIZE(ArcFastVtx);
       48:  382:        ArcFastVtx[i] = ImVec2(ImCos(a), ImSin(a));
       48:  382-block 6
call    0 returned 48
        -:  383:    }
        1:  384:    ArcFastRadiusCutoff = IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_R(IM_DRAWLIST_ARCFAST_SAMPLE_MAX, CircleSegmentMaxError);
        1:  384-block 9
call    0 returned 1
        1:  385:}
        -:  386:
function _ZN20ImDrawListSharedData29SetCircleTessellationMaxErrorEf called 1077 returned 100% blocks executed 93%
     1077:  387:void ImDrawListSharedData::SetCircleTessellationMaxError(float max_error)
        -:  388:{
     1077:  389:    if (CircleSegmentMaxError == max_error)
     1077:  389-block 2
branch  0 taken 1076 (fallthrough)
branch  1 taken 1
     1076:  390:        return;
     1076:  390-block 3
        -:  391:
       1*:  392:    IM_ASSERT(max_error > 0.0f);
        1:  392-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%:  392-block 5
call    2 never executed
        1:  393:    CircleSegmentMaxError = max_error;
       65:  394:    for (int i = 0; i < IM_ARRAYSIZE(CircleSegmentCounts); i++)
        1:  394-block 6
       65:  394-block 13
branch  0 taken 64
branch  1 taken 1 (fallthrough)
        -:  395:    {
       64:  396:        const float radius = (float)i;
       64:  397:        CircleSegmentCounts[i] = (ImU8)((i > 0) ? IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(radius, CircleSegmentMaxError) : IM_DRAWLIST_ARCFAST_SAMPLE_MAX);
       64:  397-block 7
branch  0 taken 63 (fallthrough)
branch  1 taken 1
       63:  397-block 8
call    2 returned 63
call    3 returned 63
        1:  397-block 11
       64:  397-block 12
        -:  398:    }
        1:  399:    ArcFastRadiusCutoff = IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_R(IM_DRAWLIST_ARCFAST_SAMPLE_MAX, CircleSegmentMaxError);
        1:  399-block 14
call    0 returned 1
        -:  400:}
        -:  401:
        -:  402:// Initialize before use in a new frame. We always have a command ready in the buffer.
        -:  403:// In the majority of cases, you would want to call PushClipRect() and PushTextureID() after this.
function _ZN10ImDrawList17_ResetForNewFrameEv called 16368 returned 100% blocks executed 93%
    16368:  404:void ImDrawList::_ResetForNewFrame()
        -:  405:{
        -:  406:    // Verify that the ImDrawCmd fields we want to memcmp() are contiguous in memory.
        -:  407:    IM_STATIC_ASSERT(offsetof(ImDrawCmd, ClipRect) == 0);
        -:  408:    IM_STATIC_ASSERT(offsetof(ImDrawCmd, TextureId) == sizeof(ImVec4));
        -:  409:    IM_STATIC_ASSERT(offsetof(ImDrawCmd, VtxOffset) == sizeof(ImVec4) + sizeof(ImTextureID));
    16368:  410:    if (_Splitter._Count > 1)
    16368:  410-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 16368
    #####:  411:        _Splitter.Merge(this);
    %%%%%:  411-block 3
call    0 never executed
        -:  412:
    16368:  413:    CmdBuffer.resize(0);
    16368:  413-block 4
call    0 returned 16368
    16368:  414:    IdxBuffer.resize(0);
call    0 returned 16368
    16368:  415:    VtxBuffer.resize(0);
call    0 returned 16368
    16368:  416:    Flags = _Data->InitialFlags;
    16368:  417:    memset(&_CmdHeader, 0, sizeof(_CmdHeader));
    16368:  418:    _VtxCurrentIdx = 0;
    16368:  419:    _VtxWritePtr = NULL;
    16368:  420:    _IdxWritePtr = NULL;
    16368:  421:    _ClipRectStack.resize(0);
call    0 returned 16368
    16368:  422:    _TextureIdStack.resize(0);
call    0 returned 16368
    16368:  423:    _CallbacksDataBuf.resize(0);
call    0 returned 16368
    16368:  424:    _Path.resize(0);
call    0 returned 16368
    16368:  425:    _Splitter.Clear();
call    0 returned 16368
    16368:  426:    CmdBuffer.push_back(ImDrawCmd());
call    0 returned 16368
call    1 returned 16368
branch  2 taken 16368 (fallthrough)
branch  3 taken 0 (throw)
    16368:  427:    _FringeScale = 1.0f;
    16368:  428:}
    16368:  428-block 14
        -:  429:
function _ZN10ImDrawList16_ClearFreeMemoryEv called 16 returned 100% blocks executed 100%
       16:  430:void ImDrawList::_ClearFreeMemory()
        -:  431:{
       16:  432:    CmdBuffer.clear();
       16:  432-block 2
call    0 returned 16
       16:  433:    IdxBuffer.clear();
call    0 returned 16
       16:  434:    VtxBuffer.clear();
call    0 returned 16
       16:  435:    Flags = ImDrawListFlags_None;
       16:  436:    _VtxCurrentIdx = 0;
       16:  437:    _VtxWritePtr = NULL;
       16:  438:    _IdxWritePtr = NULL;
       16:  439:    _ClipRectStack.clear();
call    0 returned 16
       16:  440:    _TextureIdStack.clear();
call    0 returned 16
       16:  441:    _CallbacksDataBuf.clear();
call    0 returned 16
       16:  442:    _Path.clear();
call    0 returned 16
       16:  443:    _Splitter.ClearFreeMemory();
call    0 returned 16
       16:  444:}
        -:  445:
function _ZNK10ImDrawList11CloneOutputEv called 0 returned 0% blocks executed 0%
    #####:  446:ImDrawList* ImDrawList::CloneOutput() const
        -:  447:{
    #####:  448:    ImDrawList* dst = IM_NEW(ImDrawList(_Data));
    %%%%%:  448-block 2
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    $$$$$:  448-block 10
branch  5 never executed (fallthrough)
branch  6 never executed
    $$$$$:  448-block 11
call    7 never executed
    #####:  449:    dst->CmdBuffer = CmdBuffer;
    %%%%%:  449-block 5
call    0 never executed
    #####:  450:    dst->IdxBuffer = IdxBuffer;
call    0 never executed
    #####:  451:    dst->VtxBuffer = VtxBuffer;
call    0 never executed
    #####:  452:    dst->Flags = Flags;
    #####:  453:    return dst;
    %%%%%:  453-block 9
        -:  454:}
        -:  455:
function _ZN10ImDrawList10AddDrawCmdEv called 26268 returned 100% blocks executed 88%
    26268:  456:void ImDrawList::AddDrawCmd()
        -:  457:{
    26268:  458:    ImDrawCmd draw_cmd;
    26268:  458-block 2
call    0 returned 26268
    26268:  459:    draw_cmd.ClipRect = _CmdHeader.ClipRect;    // Same as calling ImDrawCmd_HeaderCopy()
    26268:  460:    draw_cmd.TextureId = _CmdHeader.TextureId;
    26268:  461:    draw_cmd.VtxOffset = _CmdHeader.VtxOffset;
    26268:  462:    draw_cmd.IdxOffset = IdxBuffer.Size;
        -:  463:
   26268*:  464:    IM_ASSERT(draw_cmd.ClipRect.x <= draw_cmd.ClipRect.z && draw_cmd.ClipRect.y <= draw_cmd.ClipRect.w);
branch  0 taken 26268 (fallthrough)
branch  1 taken 0
    26268:  464-block 4
branch  2 taken 26268 (fallthrough)
branch  3 taken 0
    26268:  464-block 5
    %%%%%:  464-block 6
call    4 never executed
    26268:  465:    CmdBuffer.push_back(draw_cmd);
    26268:  465-block 7
call    0 returned 26268
branch  1 taken 26268 (fallthrough)
branch  2 taken 0 (throw)
    26268:  466:}
    26268:  466-block 8
        -:  467:
        -:  468:// Pop trailing draw command (used before merging or presenting to user)
        -:  469:// Note that this leaves the ImDrawList in a state unfit for further commands, as most code assume that CmdBuffer.Size > 0 && CmdBuffer.back().UserCallback == NULL
function _ZN10ImDrawList17_PopUnusedDrawCmdEv called 16349 returned 100% blocks executed 100%
    16349:  470:void ImDrawList::_PopUnusedDrawCmd()
        -:  471:{
    28390:  472:    while (CmdBuffer.Size > 0)
    16349:  472-block 2
    28390:  472-block 7
branch  0 taken 28390
branch  1 taken 0 (fallthrough)
        -:  473:    {
    28390:  474:        ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
    28390:  475:        if (curr_cmd->ElemCount != 0 || curr_cmd->UserCallback != NULL)
    28390:  475-block 3
branch  0 taken 12041 (fallthrough)
branch  1 taken 16349
    12041:  475-block 4
branch  2 taken 0 (fallthrough)
branch  3 taken 12041
    16349:  476:            return;// break;
    16349:  476-block 5
    12041:  477:        CmdBuffer.pop_back();
    12041:  477-block 6
call    0 returned 12041
        -:  478:    }
        -:  479:}
        -:  480:
function _ZN10ImDrawList11AddCallbackEPFvPKS_PK9ImDrawCmdEPvm called 0 returned 0% blocks executed 0%
    #####:  481:void ImDrawList::AddCallback(ImDrawCallback callback, void* userdata, size_t userdata_size)
        -:  482:{
        -:  483:    IM_ASSERT_PARANOID(CmdBuffer.Size > 0);
    #####:  484:    ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
    #####:  485:    IM_ASSERT(curr_cmd->UserCallback == NULL);
    %%%%%:  485-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  485-block 3
call    2 never executed
    #####:  486:    if (curr_cmd->ElemCount != 0)
    %%%%%:  486-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
        -:  487:    {
    #####:  488:        AddDrawCmd();
    %%%%%:  488-block 5
call    0 never executed
    #####:  489:        curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
        -:  490:    }
        -:  491:
    #####:  492:    curr_cmd->UserCallback = callback;
    #####:  493:    if (userdata_size == 0)
    %%%%%:  493-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
        -:  494:    {
        -:  495:        // Store user data directly in command (no indirection)
    #####:  496:        curr_cmd->UserCallbackData = userdata;
    #####:  497:        curr_cmd->UserCallbackDataSize = 0;
    #####:  498:        curr_cmd->UserCallbackDataOffset = -1;
    %%%%%:  498-block 8
        -:  499:    }
        -:  500:    else
        -:  501:    {
        -:  502:        // Copy and store user data in a buffer
    #####:  503:        IM_ASSERT(userdata != NULL);
    %%%%%:  503-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  503-block 10
call    2 never executed
    #####:  504:        IM_ASSERT(userdata_size < (1u << 31));
    %%%%%:  504-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  504-block 12
call    2 never executed
    #####:  505:        curr_cmd->UserCallbackData = NULL; // Will be resolved during Render()
    #####:  506:        curr_cmd->UserCallbackDataSize = (int)userdata_size;
    #####:  507:        curr_cmd->UserCallbackDataOffset = _CallbacksDataBuf.Size;
    #####:  508:        _CallbacksDataBuf.resize(_CallbacksDataBuf.Size + (int)userdata_size);
    %%%%%:  508-block 13
call    0 never executed
    #####:  509:        memcpy(_CallbacksDataBuf.Data + (size_t)curr_cmd->UserCallbackDataOffset, userdata, userdata_size);
        -:  510:    }
        -:  511:
    #####:  512:    AddDrawCmd(); // Force a new command after us (see comment below)
    %%%%%:  512-block 15
call    0 never executed
    #####:  513:}
        -:  514:
        -:  515:// Compare ClipRect, TextureId and VtxOffset with a single memcmp()
        -:  516:#define ImDrawCmd_HeaderSize                            (offsetof(ImDrawCmd, VtxOffset) + sizeof(unsigned int))
        -:  517:#define ImDrawCmd_HeaderCompare(CMD_LHS, CMD_RHS)       (memcmp(CMD_LHS, CMD_RHS, ImDrawCmd_HeaderSize))    // Compare ClipRect, TextureId, VtxOffset
        -:  518:#define ImDrawCmd_HeaderCopy(CMD_DST, CMD_SRC)          (memcpy(CMD_DST, CMD_SRC, ImDrawCmd_HeaderSize))    // Copy ClipRect, TextureId, VtxOffset
        -:  519:#define ImDrawCmd_AreSequentialIdxOffset(CMD_0, CMD_1)  (CMD_0->IdxOffset + CMD_0->ElemCount == CMD_1->IdxOffset)
        -:  520:
        -:  521:// Try to merge two last draw commands
function _ZN10ImDrawList17_TryMergeDrawCmdsEv called 0 returned 0% blocks executed 0%
    #####:  522:void ImDrawList::_TryMergeDrawCmds()
        -:  523:{
        -:  524:    IM_ASSERT_PARANOID(CmdBuffer.Size > 0);
    #####:  525:    ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
    #####:  526:    ImDrawCmd* prev_cmd = curr_cmd - 1;
    #####:  527:    if (ImDrawCmd_HeaderCompare(curr_cmd, prev_cmd) == 0 && ImDrawCmd_AreSequentialIdxOffset(prev_cmd, curr_cmd) && curr_cmd->UserCallback == NULL && prev_cmd->UserCallback == NULL)
    %%%%%:  527-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  527-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:  527-block 4
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:  527-block 5
branch  6 never executed (fallthrough)
branch  7 never executed
        -:  528:    {
    #####:  529:        prev_cmd->ElemCount += curr_cmd->ElemCount;
    #####:  530:        CmdBuffer.pop_back();
    %%%%%:  530-block 6
call    0 never executed
        -:  531:    }
    #####:  532:}
        -:  533:
        -:  534:// Our scheme may appears a bit unusual, basically we want the most-common calls AddLine AddRect etc. to not have to perform any check so we always have a command ready in the stack.
        -:  535:// The cost of figuring out if a new command has to be added or if we can merge is paid in those Update** functions only.
function _ZN10ImDrawList18_OnChangedClipRectEv called 57718 returned 100% blocks executed 93%
    57718:  536:void ImDrawList::_OnChangedClipRect()
        -:  537:{
        -:  538:    // If current command is used with different settings we need to add a new command
        -:  539:    IM_ASSERT_PARANOID(CmdBuffer.Size > 0);
    57718:  540:    ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
    57718:  541:    if (curr_cmd->ElemCount != 0 && memcmp(&curr_cmd->ClipRect, &_CmdHeader.ClipRect, sizeof(ImVec4)) != 0)
    57718:  541-block 2
branch  0 taken 24118 (fallthrough)
branch  1 taken 33600
    24118:  541-block 3
branch  2 taken 19809 (fallthrough)
branch  3 taken 4309
        -:  542:    {
    19809:  543:        AddDrawCmd();
    19809:  543-block 4
call    0 returned 19809
    19809:  544:        return;
        -:  545:    }
   37909*:  546:    IM_ASSERT(curr_cmd->UserCallback == NULL);
    37909:  546-block 6
branch  0 taken 0 (fallthrough)
branch  1 taken 37909
    %%%%%:  546-block 7
call    2 never executed
        -:  547:
        -:  548:    // Try to merge with previous command if it matches, else use current command
    37909:  549:    ImDrawCmd* prev_cmd = curr_cmd - 1;
    37909:  550:    if (curr_cmd->ElemCount == 0 && CmdBuffer.Size > 1 && ImDrawCmd_HeaderCompare(&_CmdHeader, prev_cmd) == 0 && ImDrawCmd_AreSequentialIdxOffset(prev_cmd, curr_cmd) && prev_cmd->UserCallback == NULL)
    37909:  550-block 8
branch  0 taken 33600 (fallthrough)
branch  1 taken 4309
    33600:  550-block 9
branch  2 taken 5384 (fallthrough)
branch  3 taken 28216
     5384:  550-block 10
branch  4 taken 3230 (fallthrough)
branch  5 taken 2154
     3230:  550-block 11
branch  6 taken 3230 (fallthrough)
branch  7 taken 0
     3230:  550-block 12
branch  8 taken 3230 (fallthrough)
branch  9 taken 0
        -:  551:    {
     3230:  552:        CmdBuffer.pop_back();
     3230:  552-block 13
call    0 returned 3230
     3230:  553:        return;
        -:  554:    }
    34679:  555:    curr_cmd->ClipRect = _CmdHeader.ClipRect;
    34679:  555-block 15
        -:  556:}
        -:  557:
function _ZN10ImDrawList19_OnChangedTextureIDEv called 16368 returned 100% blocks executed 40%
    16368:  558:void ImDrawList::_OnChangedTextureID()
        -:  559:{
        -:  560:    // If current command is used with different settings we need to add a new command
        -:  561:    IM_ASSERT_PARANOID(CmdBuffer.Size > 0);
    16368:  562:    ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
   16368*:  563:    if (curr_cmd->ElemCount != 0 && curr_cmd->TextureId != _CmdHeader.TextureId)
    16368:  563-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 16368
    %%%%%:  563-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
        -:  564:    {
    #####:  565:        AddDrawCmd();
    %%%%%:  565-block 4
call    0 never executed
    #####:  566:        return;
        -:  567:    }
   16368*:  568:    IM_ASSERT(curr_cmd->UserCallback == NULL);
    16368:  568-block 6
branch  0 taken 0 (fallthrough)
branch  1 taken 16368
    %%%%%:  568-block 7
call    2 never executed
        -:  569:
        -:  570:    // Try to merge with previous command if it matches, else use current command
    16368:  571:    ImDrawCmd* prev_cmd = curr_cmd - 1;
   16368*:  572:    if (curr_cmd->ElemCount == 0 && CmdBuffer.Size > 1 && ImDrawCmd_HeaderCompare(&_CmdHeader, prev_cmd) == 0 && ImDrawCmd_AreSequentialIdxOffset(prev_cmd, curr_cmd) && prev_cmd->UserCallback == NULL)
    16368:  572-block 8
branch  0 taken 16368 (fallthrough)
branch  1 taken 0
    16368:  572-block 9
branch  2 taken 0 (fallthrough)
branch  3 taken 16368
    %%%%%:  572-block 10
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%:  572-block 11
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%:  572-block 12
branch  8 never executed (fallthrough)
branch  9 never executed
        -:  573:    {
    #####:  574:        CmdBuffer.pop_back();
    %%%%%:  574-block 13
call    0 never executed
    #####:  575:        return;
        -:  576:    }
    16368:  577:    curr_cmd->TextureId = _CmdHeader.TextureId;
    16368:  577-block 15
        -:  578:}
        -:  579:
function _ZN10ImDrawList19_OnChangedVtxOffsetEv called 0 returned 0% blocks executed 0%
    #####:  580:void ImDrawList::_OnChangedVtxOffset()
        -:  581:{
        -:  582:    // We don't need to compare curr_cmd->VtxOffset != _CmdHeader.VtxOffset because we know it'll be different at the time we call this.
    #####:  583:    _VtxCurrentIdx = 0;
        -:  584:    IM_ASSERT_PARANOID(CmdBuffer.Size > 0);
    #####:  585:    ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
        -:  586:    //IM_ASSERT(curr_cmd->VtxOffset != _CmdHeader.VtxOffset); // See #3349
    #####:  587:    if (curr_cmd->ElemCount != 0)
    %%%%%:  587-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -:  588:    {
    #####:  589:        AddDrawCmd();
    %%%%%:  589-block 3
call    0 never executed
    #####:  590:        return;
        -:  591:    }
    #####:  592:    IM_ASSERT(curr_cmd->UserCallback == NULL);
    %%%%%:  592-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  592-block 6
call    2 never executed
    #####:  593:    curr_cmd->VtxOffset = _CmdHeader.VtxOffset;
    %%%%%:  593-block 7
        -:  594:}
        -:  595:
function _ZNK10ImDrawList27_CalcCircleAutoSegmentCountEf called 31844 returned 100% blocks executed 67%
    31844:  596:int ImDrawList::_CalcCircleAutoSegmentCount(float radius) const
        -:  597:{
        -:  598:    // Automatic segment count
    31844:  599:    const int radius_idx = (int)(radius + 0.999999f); // ceil to never reduce accuracy
    31844:  600:    if (radius_idx >= 0 && radius_idx < IM_ARRAYSIZE(_Data->CircleSegmentCounts))
    31844:  600-block 2
branch  0 taken 31844 (fallthrough)
branch  1 taken 0
    31844:  600-block 3
branch  2 taken 31844 (fallthrough)
branch  3 taken 0
    31844:  601:        return _Data->CircleSegmentCounts[radius_idx]; // Use cached value
    31844:  601-block 4
        -:  602:    else
    #####:  603:        return IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(radius, _Data->CircleSegmentMaxError);
    %%%%%:  603-block 5
call    0 never executed
call    1 never executed
        -:  604:}
        -:  605:
        -:  606:// Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)
function _ZN10ImDrawList12PushClipRectERK6ImVec2S2_b called 37043 returned 100% blocks executed 76%
    37043:  607:void ImDrawList::PushClipRect(const ImVec2& cr_min, const ImVec2& cr_max, bool intersect_with_current_clip_rect)
        -:  608:{
    37043:  609:    ImVec4 cr(cr_min.x, cr_min.y, cr_max.x, cr_max.y);
    37043:  609-block 2
call    0 returned 37043
    37043:  610:    if (intersect_with_current_clip_rect)
branch  0 taken 17444 (fallthrough)
branch  1 taken 19599
        -:  611:    {
    17444:  612:        ImVec4 current = _CmdHeader.ClipRect;
   17444*:  613:        if (cr.x < current.x) cr.x = current.x;
    17444:  613-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 17444
    %%%%%:  613-block 5
   17444*:  614:        if (cr.y < current.y) cr.y = current.y;
    17444:  614-block 6
branch  0 taken 0 (fallthrough)
branch  1 taken 17444
    %%%%%:  614-block 7
   17444*:  615:        if (cr.z > current.z) cr.z = current.z;
    17444:  615-block 8
branch  0 taken 0 (fallthrough)
branch  1 taken 17444
    %%%%%:  615-block 9
   17444*:  616:        if (cr.w > current.w) cr.w = current.w;
    17444:  616-block 10
branch  0 taken 0 (fallthrough)
branch  1 taken 17444
    %%%%%:  616-block 11
        -:  617:    }
    37043:  618:    cr.z = ImMax(cr.x, cr.z);
    37043:  618-block 13
call    0 returned 37043
    37043:  619:    cr.w = ImMax(cr.y, cr.w);
call    0 returned 37043
        -:  620:
    37043:  621:    _ClipRectStack.push_back(cr);
call    0 returned 37043
branch  1 taken 37043 (fallthrough)
branch  2 taken 0 (throw)
    37043:  622:    _CmdHeader.ClipRect = cr;
    37043:  623:    _OnChangedClipRect();
    37043:  623-block 16
call    0 returned 37043
branch  1 taken 37043 (fallthrough)
branch  2 taken 0 (throw)
    37043:  624:}
    37043:  624-block 17
        -:  625:
function _ZN10ImDrawList22PushClipRectFullScreenEv called 0 returned 0% blocks executed 0%
    #####:  626:void ImDrawList::PushClipRectFullScreen()
        -:  627:{
    #####:  628:    PushClipRect(ImVec2(_Data->ClipRectFullscreen.x, _Data->ClipRectFullscreen.y), ImVec2(_Data->ClipRectFullscreen.z, _Data->ClipRectFullscreen.w));
    %%%%%:  628-block 2
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    $$$$$:  628-block 6
    #####:  629:}
    %%%%%:  629-block 5
        -:  630:
function _ZN10ImDrawList11PopClipRectEv called 20675 returned 100% blocks executed 83%
    20675:  631:void ImDrawList::PopClipRect()
        -:  632:{
    20675:  633:    _ClipRectStack.pop_back();
    20675:  633-block 2
call    0 returned 20675
   20675*:  634:    _CmdHeader.ClipRect = (_ClipRectStack.Size == 0) ? _Data->ClipRectFullscreen : _ClipRectStack.Data[_ClipRectStack.Size - 1];
branch  0 taken 0 (fallthrough)
branch  1 taken 20675
    %%%%%:  634-block 4
    20675:  634-block 5
    20675:  635:    _OnChangedClipRect();
    20675:  635-block 6
call    0 returned 20675
    20675:  636:}
        -:  637:
function _ZN10ImDrawList13PushTextureIDEy called 16368 returned 100% blocks executed 100%
    16368:  638:void ImDrawList::PushTextureID(ImTextureID texture_id)
        -:  639:{
    16368:  640:    _TextureIdStack.push_back(texture_id);
    16368:  640-block 2
call    0 returned 16368
    16368:  641:    _CmdHeader.TextureId = texture_id;
    16368:  642:    _OnChangedTextureID();
call    0 returned 16368
    16368:  643:}
        -:  644:
function _ZN10ImDrawList12PopTextureIDEv called 0 returned 0% blocks executed 0%
    #####:  645:void ImDrawList::PopTextureID()
        -:  646:{
    #####:  647:    _TextureIdStack.pop_back();
    %%%%%:  647-block 2
call    0 never executed
    #####:  648:    _CmdHeader.TextureId = (_TextureIdStack.Size == 0) ? (ImTextureID)NULL : _TextureIdStack.Data[_TextureIdStack.Size - 1];
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  648-block 4
    %%%%%:  648-block 5
    #####:  649:    _OnChangedTextureID();
    %%%%%:  649-block 6
call    0 never executed
    #####:  650:}
        -:  651:
        -:  652:// This is used by ImGui::PushFont()/PopFont(). It works because we never use _TextureIdStack[] elsewhere than in PushTextureID()/PopTextureID().
function _ZN10ImDrawList13_SetTextureIDEy called 79698 returned 100% blocks executed 75%
    79698:  653:void ImDrawList::_SetTextureID(ImTextureID texture_id)
        -:  654:{
    79698:  655:    if (_CmdHeader.TextureId == texture_id)
    79698:  655-block 2
branch  0 taken 79698 (fallthrough)
branch  1 taken 0
    79698:  656:        return;
    79698:  656-block 3
    #####:  657:    _CmdHeader.TextureId = texture_id;
    #####:  658:    _OnChangedTextureID();
    %%%%%:  658-block 4
call    0 never executed
        -:  659:}
        -:  660:
        -:  661:// Reserve space for a number of vertices and indices.
        -:  662:// You must finish filling your reserved data before calling PrimReserve() again, as it may reallocate or
        -:  663:// submit the intermediate results. PrimUnreserve() can be used to release unused allocations.
function _ZN10ImDrawList11PrimReserveEii called 1073726 returned 100% blocks executed 67%
  1073726:  664:void ImDrawList::PrimReserve(int idx_count, int vtx_count)
        -:  665:{
        -:  666:    // Large mesh support (when enabled)
        -:  667:    IM_ASSERT_PARANOID(idx_count >= 0 && vtx_count >= 0);
 1073726*:  668:    if (sizeof(ImDrawIdx) == 2 && (_VtxCurrentIdx + vtx_count >= (1 << 16)) && (Flags & ImDrawListFlags_AllowVtxOffset))
  1073726:  668-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1073726
    %%%%%:  668-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
        -:  669:    {
        -:  670:        // FIXME: In theory we should be testing that vtx_count <64k here.
        -:  671:        // In practice, RenderText() relies on reserving ahead for a worst case scenario so it is currently useful for us
        -:  672:        // to not make that check until we rework the text functions to handle clipping and large horizontal lines better.
    #####:  673:        _CmdHeader.VtxOffset = VtxBuffer.Size;
    #####:  674:        _OnChangedVtxOffset();
    %%%%%:  674-block 4
call    0 never executed
        -:  675:    }
        -:  676:
  1073726:  677:    ImDrawCmd* draw_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
  1073726:  678:    draw_cmd->ElemCount += idx_count;
        -:  679:
  1073726:  680:    int vtx_buffer_old_size = VtxBuffer.Size;
  1073726:  681:    VtxBuffer.resize(vtx_buffer_old_size + vtx_count);
  1073726:  681-block 5
call    0 returned 1073726
  1073726:  682:    _VtxWritePtr = VtxBuffer.Data + vtx_buffer_old_size;
        -:  683:
  1073726:  684:    int idx_buffer_old_size = IdxBuffer.Size;
  1073726:  685:    IdxBuffer.resize(idx_buffer_old_size + idx_count);
call    0 returned 1073726
  1073726:  686:    _IdxWritePtr = IdxBuffer.Data + idx_buffer_old_size;
  1073726:  687:}
        -:  688:
        -:  689:// Release the number of reserved vertices/indices from the end of the last reservation made with PrimReserve().
function _ZN10ImDrawList13PrimUnreserveEii called 0 returned 0% blocks executed 0%
    #####:  690:void ImDrawList::PrimUnreserve(int idx_count, int vtx_count)
        -:  691:{
        -:  692:    IM_ASSERT_PARANOID(idx_count >= 0 && vtx_count >= 0);
        -:  693:
    #####:  694:    ImDrawCmd* draw_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
    #####:  695:    draw_cmd->ElemCount -= idx_count;
    #####:  696:    VtxBuffer.shrink(VtxBuffer.Size - vtx_count);
    %%%%%:  696-block 2
call    0 never executed
    #####:  697:    IdxBuffer.shrink(IdxBuffer.Size - idx_count);
call    0 never executed
    #####:  698:}
        -:  699:
        -:  700:// Fully unrolled with inline call to keep our debug builds decently fast.
function _ZN10ImDrawList8PrimRectERK6ImVec2S2_j called 112993 returned 100% blocks executed 100%
   112993:  701:void ImDrawList::PrimRect(const ImVec2& a, const ImVec2& c, ImU32 col)
        -:  702:{
   112993:  703:    ImVec2 b(c.x, a.y), d(a.x, c.y), uv(_Data->TexUvWhitePixel);
   112993:  703-block 2
call    0 returned 112993
call    1 returned 112993
   112993:  704:    ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;
   112993:  705:    _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);
   112993:  706:    _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx+2); _IdxWritePtr[5] = (ImDrawIdx)(idx+3);
   112993:  707:    _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;
   112993:  708:    _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col;
   112993:  709:    _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col;
   112993:  710:    _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv; _VtxWritePtr[3].col = col;
   112993:  711:    _VtxWritePtr += 4;
   112993:  712:    _VtxCurrentIdx += 4;
   112993:  713:    _IdxWritePtr += 6;
   112993:  714:}
        -:  715:
function _ZN10ImDrawList10PrimRectUVERK6ImVec2S2_S2_S2_j called 1076 returned 100% blocks executed 100%
     1076:  716:void ImDrawList::PrimRectUV(const ImVec2& a, const ImVec2& c, const ImVec2& uv_a, const ImVec2& uv_c, ImU32 col)
        -:  717:{
     1076:  718:    ImVec2 b(c.x, a.y), d(a.x, c.y), uv_b(uv_c.x, uv_a.y), uv_d(uv_a.x, uv_c.y);
     1076:  718-block 2
call    0 returned 1076
call    1 returned 1076
call    2 returned 1076
call    3 returned 1076
     1076:  719:    ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;
     1076:  720:    _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);
     1076:  721:    _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx+2); _IdxWritePtr[5] = (ImDrawIdx)(idx+3);
     1076:  722:    _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv_a; _VtxWritePtr[0].col = col;
     1076:  723:    _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv_b; _VtxWritePtr[1].col = col;
     1076:  724:    _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv_c; _VtxWritePtr[2].col = col;
     1076:  725:    _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv_d; _VtxWritePtr[3].col = col;
     1076:  726:    _VtxWritePtr += 4;
     1076:  727:    _VtxCurrentIdx += 4;
     1076:  728:    _IdxWritePtr += 6;
     1076:  729:}
        -:  730:
function _ZN10ImDrawList10PrimQuadUVERK6ImVec2S2_S2_S2_S2_S2_S2_S2_j called 0 returned 0% blocks executed 0%
    #####:  731:void ImDrawList::PrimQuadUV(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col)
        -:  732:{
    #####:  733:    ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;
    #####:  734:    _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);
    #####:  735:    _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx+2); _IdxWritePtr[5] = (ImDrawIdx)(idx+3);
    #####:  736:    _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv_a; _VtxWritePtr[0].col = col;
    #####:  737:    _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv_b; _VtxWritePtr[1].col = col;
    #####:  738:    _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv_c; _VtxWritePtr[2].col = col;
    #####:  739:    _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv_d; _VtxWritePtr[3].col = col;
    #####:  740:    _VtxWritePtr += 4;
    #####:  741:    _VtxCurrentIdx += 4;
    #####:  742:    _IdxWritePtr += 6;
    #####:  743:}
        -:  744:
        -:  745:// On AddPolyline() and AddConvexPolyFilled() we intentionally avoid using ImVec2 and superfluous function calls to optimize debug/non-inlined builds.
        -:  746:// - Those macros expects l-values and need to be used as their own statement.
        -:  747:// - Those macros are intentionally not surrounded by the 'do {} while (0)' idiom because even that translates to runtime with debug compilers.
        -:  748:#define IM_NORMALIZE2F_OVER_ZERO(VX,VY)     { float d2 = VX*VX + VY*VY; if (d2 > 0.0f) { float inv_len = ImRsqrt(d2); VX *= inv_len; VY *= inv_len; } } (void)0
        -:  749:#define IM_FIXNORMAL2F_MAX_INVLEN2          100.0f // 500.0f (see #4053, #3366)
        -:  750:#define IM_FIXNORMAL2F(VX,VY)               { float d2 = VX*VX + VY*VY; if (d2 > 0.000001f) { float inv_len2 = 1.0f / d2; if (inv_len2 > IM_FIXNORMAL2F_MAX_INVLEN2) inv_len2 = IM_FIXNORMAL2F_MAX_INVLEN2; VX *= inv_len2; VY *= inv_len2; } } (void)0
        -:  751:
        -:  752:// TODO: Thickness anti-aliased lines cap are missing their AA fringe.
        -:  753:// We avoid using the ImVec2 math operators here to reduce cost to a minimum for debug/non-inlined builds.
function _ZN10ImDrawList11AddPolylineEPK6ImVec2ijif called 33571 returned 100% blocks executed 53%
    33571:  754:void ImDrawList::AddPolyline(const ImVec2* points, const int points_count, ImU32 col, ImDrawFlags flags, float thickness)
        -:  755:{
    33571:  756:    if (points_count < 2 || (col & IM_COL32_A_MASK) == 0)
    33571:  756-block 2
branch  0 taken 33571 (fallthrough)
branch  1 taken 0
    33571:  756-block 3
branch  2 taken 0 (fallthrough)
branch  3 taken 33571
    #####:  757:        return;
    %%%%%:  757-block 4
        -:  758:
    33571:  759:    const bool closed = (flags & ImDrawFlags_Closed) != 0;
    33571:  760:    const ImVec2 opaque_uv = _Data->TexUvWhitePixel;
    33571:  761:    const int count = closed ? points_count : points_count - 1; // The number of line segments we need to draw
    33571:  761-block 5
branch  0 taken 1290 (fallthrough)
branch  1 taken 32281
     1290:  761-block 6
    32281:  761-block 7
    33571:  762:    const bool thick_line = (thickness > _FringeScale);
        -:  763:
    33571:  764:    if (Flags & ImDrawListFlags_AntiAliasedLines)
    33571:  764-block 8
branch  0 taken 33571 (fallthrough)
branch  1 taken 0
        -:  765:    {
        -:  766:        // Anti-aliased stroke
    33571:  767:        const float AA_SIZE = _FringeScale;
    33571:  768:        const ImU32 col_trans = col & ~IM_COL32_A_MASK;
        -:  769:
        -:  770:        // Thicknesses <1.0 should behave like thickness 1.0
    33571:  771:        thickness = ImMax(thickness, 1.0f);
    33571:  771-block 9
call    0 returned 33571
    33571:  772:        const int integer_thickness = (int)thickness;
    33571:  773:        const float fractional_thickness = thickness - integer_thickness;
        -:  774:
        -:  775:        // Do we want to draw this line using a texture?
        -:  776:        // - For now, only draw integer-width lines using textures to avoid issues with the way scaling occurs, could be improved.
        -:  777:        // - If AA_SIZE is not 1.0f we cannot use the texture path.
   33571*:  778:        const bool use_texture = (Flags & ImDrawListFlags_AntiAliasedLinesUseTex) && (integer_thickness < IM_DRAWLIST_TEX_LINES_WIDTH_MAX) && (fractional_thickness <= 0.00001f) && (AA_SIZE == 1.0f);
branch  0 taken 33571 (fallthrough)
branch  1 taken 0
    33571:  778-block 11
branch  2 taken 33571 (fallthrough)
branch  3 taken 0
    33571:  778-block 12
branch  4 taken 33571 (fallthrough)
branch  5 taken 0
    33571:  778-block 13
branch  6 taken 33571 (fallthrough)
branch  7 taken 0
    33571:  778-block 14
    %%%%%:  778-block 15
        -:  779:
        -:  780:        // We should never hit this, because NewFrame() doesn't set ImDrawListFlags_AntiAliasedLinesUseTex unless ImFontAtlasFlags_NoBakedLines is off
        -:  781:        IM_ASSERT_PARANOID(!use_texture || !(_Data->Font->ContainerAtlas->Flags & ImFontAtlasFlags_NoBakedLines));
        -:  782:
   33571*:  783:        const int idx_count = use_texture ? (count * 6) : (thick_line ? count * 18 : count * 12);
    33571:  783-block 16
branch  0 taken 33571 (fallthrough)
branch  1 taken 0
    33571:  783-block 17
    %%%%%:  783-block 18
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:  783-block 19
    %%%%%:  783-block 20
    %%%%%:  783-block 21
   33571*:  784:        const int vtx_count = use_texture ? (points_count * 2) : (thick_line ? points_count * 4 : points_count * 3);
    33571:  784-block 22
branch  0 taken 33571 (fallthrough)
branch  1 taken 0
    33571:  784-block 23
    %%%%%:  784-block 24
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:  784-block 25
    %%%%%:  784-block 26
    %%%%%:  784-block 27
    33571:  785:        PrimReserve(idx_count, vtx_count);
    33571:  785-block 28
call    0 returned 33571
branch  1 taken 33571 (fallthrough)
branch  2 taken 0 (throw)
        -:  786:
        -:  787:        // Temporary buffer
        -:  788:        // The first <points_count> items are normals at each line point, then after that there are either 2 or 4 temp points for each line point
   33571*:  789:        _Data->TempBuffer.reserve_discard(points_count * ((use_texture || !thick_line) ? 3 : 5));
    33571:  789-block 29
branch  0 taken 0 (fallthrough)
branch  1 taken 33571
    %%%%%:  789-block 30
branch  2 never executed (fallthrough)
branch  3 never executed
    33571:  789-block 31
    %%%%%:  789-block 32
    33571:  789-block 33
call    4 returned 33571
branch  5 taken 33571 (fallthrough)
branch  6 taken 0 (throw)
    33571:  790:        ImVec2* temp_normals = _Data->TempBuffer.Data;
    33571:  791:        ImVec2* temp_points = temp_normals + points_count;
        -:  792:
        -:  793:        // Calculate normals (tangents) for each line segment
    71864:  794:        for (int i1 = 0; i1 < count; i1++)
    33571:  794-block 34
    71864:  794-block 42
branch  0 taken 38293
branch  1 taken 33571 (fallthrough)
        -:  795:        {
    38293:  796:            const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1;
    38293:  796-block 35
branch  0 taken 37003 (fallthrough)
branch  1 taken 1290
    37003:  796-block 36
     1290:  796-block 37
    38293:  797:            float dx = points[i2].x - points[i1].x;
    38293:  798:            float dy = points[i2].y - points[i1].y;
    38293:  799:            IM_NORMALIZE2F_OVER_ZERO(dx, dy);
    38293:  799-block 38
branch  0 taken 38291 (fallthrough)
branch  1 taken 2
    38291:  799-block 39
call    2 returned 38291
    38293:  800:            temp_normals[i1].x = dy;
    38293:  801:            temp_normals[i1].y = -dx;
    38293:  801-block 41
        -:  802:        }
    33571:  803:        if (!closed)
    33571:  803-block 43
branch  0 taken 32281 (fallthrough)
branch  1 taken 1290
    32281:  804:            temp_normals[points_count - 1] = temp_normals[points_count - 2];
    32281:  804-block 44
        -:  805:
        -:  806:        // If we are drawing a one-pixel-wide line without a texture, or a textured line of any width, we only need 2 or 3 vertices per point
   33571*:  807:        if (use_texture || !thick_line)
    33571:  807-block 45
branch  0 taken 0 (fallthrough)
branch  1 taken 33571
    %%%%%:  807-block 46
branch  2 never executed (fallthrough)
branch  3 never executed
        -:  808:        {
        -:  809:            // [PATH 1] Texture-based lines (thick or non-thick)
        -:  810:            // [PATH 2] Non texture-based lines (non-thick)
        -:  811:
        -:  812:            // The width of the geometry we need to draw - this is essentially <thickness> pixels for the line itself, plus "one pixel" for AA.
        -:  813:            // - In the texture-based path, we don't use AA_SIZE here because the +1 is tied to the generated texture
        -:  814:            //   (see ImFontAtlasBuildRenderLinesTexData() function), and so alternate values won't work without changes to that code.
        -:  815:            // - In the non texture-based paths, we would allow AA_SIZE to potentially be != 1.0f with a patch (e.g. fringe_scale patch to
        -:  816:            //   allow scaling geometry while preserving one-screen-pixel AA fringe).
   33571*:  817:            const float half_draw_size = use_texture ? ((thickness * 0.5f) + 1) : AA_SIZE;
    33571:  817-block 47
branch  0 taken 33571 (fallthrough)
branch  1 taken 0
    33571:  817-block 48
    %%%%%:  817-block 49
        -:  818:
        -:  819:            // If line is not closed, the first and last points need to be generated differently as there are no normals to blend
    33571:  820:            if (!closed)
    33571:  820-block 50
branch  0 taken 32281 (fallthrough)
branch  1 taken 1290
        -:  821:            {
    32281:  822:                temp_points[0] = points[0] + temp_normals[0] * half_draw_size;
    32281:  822-block 51
call    0 returned 32281
call    1 returned 32281
    32281:  823:                temp_points[1] = points[0] - temp_normals[0] * half_draw_size;
call    0 returned 32281
call    1 returned 32281
    32281:  824:                temp_points[(points_count-1)*2+0] = points[points_count-1] + temp_normals[points_count-1] * half_draw_size;
call    0 returned 32281
call    1 returned 32281
    32281:  825:                temp_points[(points_count-1)*2+1] = points[points_count-1] - temp_normals[points_count-1] * half_draw_size;
call    0 returned 32281
call    1 returned 32281
        -:  826:            }
        -:  827:
        -:  828:            // Generate the indices to form a number of triangles for each line segment, and the vertices for the line edges
        -:  829:            // This takes points n and n+1 and writes into n+1, with the first point in a closed line being generated from the final one (as n+1 wraps)
        -:  830:            // FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.
    33571:  831:            unsigned int idx1 = _VtxCurrentIdx; // Vertex index for start of line segment
    71864:  832:            for (int i1 = 0; i1 < count; i1++) // i1 is the first point of the line segment
    33571:  832-block 60
    71864:  832-block 78
branch  0 taken 38293
branch  1 taken 33571 (fallthrough)
        -:  833:            {
    38293:  834:                const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1; // i2 is the second point of the line segment
    38293:  834-block 61
branch  0 taken 37003 (fallthrough)
branch  1 taken 1290
    37003:  834-block 62
     1290:  834-block 63
   38293*:  835:                const unsigned int idx2 = ((i1 + 1) == points_count) ? _VtxCurrentIdx : (idx1 + (use_texture ? 2 : 3)); // Vertex index for end of segment
    38293:  835-block 64
branch  0 taken 1290 (fallthrough)
branch  1 taken 37003
     1290:  835-block 65
    37003:  835-block 66
branch  2 taken 37003 (fallthrough)
branch  3 taken 0
    37003:  835-block 67
    %%%%%:  835-block 68
    37003:  835-block 69
        -:  836:
        -:  837:                // Average normals
    38293:  838:                float dm_x = (temp_normals[i1].x + temp_normals[i2].x) * 0.5f;
    38293:  839:                float dm_y = (temp_normals[i1].y + temp_normals[i2].y) * 0.5f;
   38293*:  840:                IM_FIXNORMAL2F(dm_x, dm_y);
    38293:  840-block 70
branch  0 taken 38293 (fallthrough)
branch  1 taken 0
    38293:  840-block 71
branch  2 taken 0 (fallthrough)
branch  3 taken 38293
    %%%%%:  840-block 72
    38293:  840-block 73
    38293:  841:                dm_x *= half_draw_size; // dm_x, dm_y are offset to the outer edge of the AA area
    38293:  842:                dm_y *= half_draw_size;
        -:  843:
        -:  844:                // Add temporary vertexes for the outer edges
    38293:  845:                ImVec2* out_vtx = &temp_points[i2 * 2];
    38293:  846:                out_vtx[0].x = points[i2].x + dm_x;
    38293:  847:                out_vtx[0].y = points[i2].y + dm_y;
    38293:  848:                out_vtx[1].x = points[i2].x - dm_x;
    38293:  849:                out_vtx[1].y = points[i2].y - dm_y;
        -:  850:
    38293:  851:                if (use_texture)
    38293:  851-block 74
branch  0 taken 38293 (fallthrough)
branch  1 taken 0
        -:  852:                {
        -:  853:                    // Add indices for two triangles
    38293:  854:                    _IdxWritePtr[0] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[1] = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[2] = (ImDrawIdx)(idx1 + 1); // Right tri
    38293:  855:                    _IdxWritePtr[3] = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[4] = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[5] = (ImDrawIdx)(idx2 + 0); // Left tri
    38293:  856:                    _IdxWritePtr += 6;
    38293:  856-block 75
        -:  857:                }
        -:  858:                else
        -:  859:                {
        -:  860:                    // Add indexes for four triangles
    #####:  861:                    _IdxWritePtr[0] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[1] = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[2] = (ImDrawIdx)(idx1 + 2); // Right tri 1
    #####:  862:                    _IdxWritePtr[3] = (ImDrawIdx)(idx1 + 2); _IdxWritePtr[4] = (ImDrawIdx)(idx2 + 2); _IdxWritePtr[5] = (ImDrawIdx)(idx2 + 0); // Right tri 2
    #####:  863:                    _IdxWritePtr[6] = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[7] = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[8] = (ImDrawIdx)(idx1 + 0); // Left tri 1
    #####:  864:                    _IdxWritePtr[9] = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[10] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[11] = (ImDrawIdx)(idx2 + 1); // Left tri 2
    #####:  865:                    _IdxWritePtr += 12;
    %%%%%:  865-block 76
        -:  866:                }
        -:  867:
    38293:  868:                idx1 = idx2;
    38293:  868-block 77
        -:  869:            }
        -:  870:
        -:  871:            // Add vertexes for each point on the line
    33571:  872:            if (use_texture)
    33571:  872-block 79
branch  0 taken 33571 (fallthrough)
branch  1 taken 0
        -:  873:            {
        -:  874:                // If we're using textures we only need to emit the left/right edge vertices
    33571:  875:                ImVec4 tex_uvs = _Data->TexUvLines[integer_thickness];
        -:  876:                /*if (fractional_thickness != 0.0f) // Currently always zero when use_texture==false!
        -:  877:                {
        -:  878:                    const ImVec4 tex_uvs_1 = _Data->TexUvLines[integer_thickness + 1];
        -:  879:                    tex_uvs.x = tex_uvs.x + (tex_uvs_1.x - tex_uvs.x) * fractional_thickness; // inlined ImLerp()
        -:  880:                    tex_uvs.y = tex_uvs.y + (tex_uvs_1.y - tex_uvs.y) * fractional_thickness;
        -:  881:                    tex_uvs.z = tex_uvs.z + (tex_uvs_1.z - tex_uvs.z) * fractional_thickness;
        -:  882:                    tex_uvs.w = tex_uvs.w + (tex_uvs_1.w - tex_uvs.w) * fractional_thickness;
        -:  883:                }*/
    33571:  884:                ImVec2 tex_uv0(tex_uvs.x, tex_uvs.y);
    33571:  884-block 80
call    0 returned 33571
    33571:  885:                ImVec2 tex_uv1(tex_uvs.z, tex_uvs.w);
call    0 returned 33571
   104145:  886:                for (int i = 0; i < points_count; i++)
   104145:  886-block 84
branch  0 taken 70574
branch  1 taken 33571 (fallthrough)
        -:  887:                {
    70574:  888:                    _VtxWritePtr[0].pos = temp_points[i * 2 + 0]; _VtxWritePtr[0].uv = tex_uv0; _VtxWritePtr[0].col = col; // Left-side outer edge
    70574:  889:                    _VtxWritePtr[1].pos = temp_points[i * 2 + 1]; _VtxWritePtr[1].uv = tex_uv1; _VtxWritePtr[1].col = col; // Right-side outer edge
    70574:  890:                    _VtxWritePtr += 2;
    70574:  890-block 83
        -:  891:                }
        -:  892:            }
        -:  893:            else
        -:  894:            {
        -:  895:                // If we're not using a texture, we need the center vertex as well
    #####:  896:                for (int i = 0; i < points_count; i++)
    %%%%%:  896-block 86
    %%%%%:  896-block 88
branch  0 never executed
branch  1 never executed (fallthrough)
        -:  897:                {
    #####:  898:                    _VtxWritePtr[0].pos = points[i];              _VtxWritePtr[0].uv = opaque_uv; _VtxWritePtr[0].col = col;       // Center of line
    #####:  899:                    _VtxWritePtr[1].pos = temp_points[i * 2 + 0]; _VtxWritePtr[1].uv = opaque_uv; _VtxWritePtr[1].col = col_trans; // Left-side outer edge
    #####:  900:                    _VtxWritePtr[2].pos = temp_points[i * 2 + 1]; _VtxWritePtr[2].uv = opaque_uv; _VtxWritePtr[2].col = col_trans; // Right-side outer edge
    #####:  901:                    _VtxWritePtr += 3;
    %%%%%:  901-block 87
        -:  902:                }
        -:  903:            }
    33571:  904:        }
    33571:  904-block 89
        -:  905:        else
        -:  906:        {
        -:  907:            // [PATH 2] Non texture-based lines (thick): we need to draw the solid line core and thus require four vertices per point
    #####:  908:            const float half_inner_thickness = (thickness - AA_SIZE) * 0.5f;
        -:  909:
        -:  910:            // If line is not closed, the first and last points need to be generated differently as there are no normals to blend
    #####:  911:            if (!closed)
    %%%%%:  911-block 90
branch  0 never executed (fallthrough)
branch  1 never executed
        -:  912:            {
    #####:  913:                const int points_last = points_count - 1;
    #####:  914:                temp_points[0] = points[0] + temp_normals[0] * (half_inner_thickness + AA_SIZE);
    %%%%%:  914-block 91
call    0 never executed
call    1 never executed
    #####:  915:                temp_points[1] = points[0] + temp_normals[0] * (half_inner_thickness);
call    0 never executed
call    1 never executed
    #####:  916:                temp_points[2] = points[0] - temp_normals[0] * (half_inner_thickness);
call    0 never executed
call    1 never executed
    #####:  917:                temp_points[3] = points[0] - temp_normals[0] * (half_inner_thickness + AA_SIZE);
call    0 never executed
call    1 never executed
    #####:  918:                temp_points[points_last * 4 + 0] = points[points_last] + temp_normals[points_last] * (half_inner_thickness + AA_SIZE);
call    0 never executed
call    1 never executed
    #####:  919:                temp_points[points_last * 4 + 1] = points[points_last] + temp_normals[points_last] * (half_inner_thickness);
call    0 never executed
call    1 never executed
    #####:  920:                temp_points[points_last * 4 + 2] = points[points_last] - temp_normals[points_last] * (half_inner_thickness);
call    0 never executed
call    1 never executed
    #####:  921:                temp_points[points_last * 4 + 3] = points[points_last] - temp_normals[points_last] * (half_inner_thickness + AA_SIZE);
call    0 never executed
call    1 never executed
        -:  922:            }
        -:  923:
        -:  924:            // Generate the indices to form a number of triangles for each line segment, and the vertices for the line edges
        -:  925:            // This takes points n and n+1 and writes into n+1, with the first point in a closed line being generated from the final one (as n+1 wraps)
        -:  926:            // FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.
    #####:  927:            unsigned int idx1 = _VtxCurrentIdx; // Vertex index for start of line segment
    #####:  928:            for (int i1 = 0; i1 < count; i1++) // i1 is the first point of the line segment
    %%%%%:  928-block 108
    %%%%%:  928-block 120
branch  0 never executed
branch  1 never executed (fallthrough)
        -:  929:            {
    #####:  930:                const int i2 = (i1 + 1) == points_count ? 0 : (i1 + 1); // i2 is the second point of the line segment
    %%%%%:  930-block 109
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  930-block 110
    %%%%%:  930-block 111
    #####:  931:                const unsigned int idx2 = (i1 + 1) == points_count ? _VtxCurrentIdx : (idx1 + 4); // Vertex index for end of segment
    %%%%%:  931-block 112
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  931-block 113
    %%%%%:  931-block 114
        -:  932:
        -:  933:                // Average normals
    #####:  934:                float dm_x = (temp_normals[i1].x + temp_normals[i2].x) * 0.5f;
    #####:  935:                float dm_y = (temp_normals[i1].y + temp_normals[i2].y) * 0.5f;
    #####:  936:                IM_FIXNORMAL2F(dm_x, dm_y);
    %%%%%:  936-block 115
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  936-block 116
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%:  936-block 117
    %%%%%:  936-block 118
    #####:  937:                float dm_out_x = dm_x * (half_inner_thickness + AA_SIZE);
    #####:  938:                float dm_out_y = dm_y * (half_inner_thickness + AA_SIZE);
    #####:  939:                float dm_in_x = dm_x * half_inner_thickness;
    #####:  940:                float dm_in_y = dm_y * half_inner_thickness;
        -:  941:
        -:  942:                // Add temporary vertices
    #####:  943:                ImVec2* out_vtx = &temp_points[i2 * 4];
    #####:  944:                out_vtx[0].x = points[i2].x + dm_out_x;
    #####:  945:                out_vtx[0].y = points[i2].y + dm_out_y;
    #####:  946:                out_vtx[1].x = points[i2].x + dm_in_x;
    #####:  947:                out_vtx[1].y = points[i2].y + dm_in_y;
    #####:  948:                out_vtx[2].x = points[i2].x - dm_in_x;
    #####:  949:                out_vtx[2].y = points[i2].y - dm_in_y;
    #####:  950:                out_vtx[3].x = points[i2].x - dm_out_x;
    #####:  951:                out_vtx[3].y = points[i2].y - dm_out_y;
        -:  952:
        -:  953:                // Add indexes
    #####:  954:                _IdxWritePtr[0]  = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[1]  = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[2]  = (ImDrawIdx)(idx1 + 2);
    #####:  955:                _IdxWritePtr[3]  = (ImDrawIdx)(idx1 + 2); _IdxWritePtr[4]  = (ImDrawIdx)(idx2 + 2); _IdxWritePtr[5]  = (ImDrawIdx)(idx2 + 1);
    #####:  956:                _IdxWritePtr[6]  = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[7]  = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[8]  = (ImDrawIdx)(idx1 + 0);
    #####:  957:                _IdxWritePtr[9]  = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[10] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[11] = (ImDrawIdx)(idx2 + 1);
    #####:  958:                _IdxWritePtr[12] = (ImDrawIdx)(idx2 + 2); _IdxWritePtr[13] = (ImDrawIdx)(idx1 + 2); _IdxWritePtr[14] = (ImDrawIdx)(idx1 + 3);
    #####:  959:                _IdxWritePtr[15] = (ImDrawIdx)(idx1 + 3); _IdxWritePtr[16] = (ImDrawIdx)(idx2 + 3); _IdxWritePtr[17] = (ImDrawIdx)(idx2 + 2);
    #####:  960:                _IdxWritePtr += 18;
        -:  961:
    #####:  962:                idx1 = idx2;
    %%%%%:  962-block 119
        -:  963:            }
        -:  964:
        -:  965:            // Add vertices
    #####:  966:            for (int i = 0; i < points_count; i++)
    %%%%%:  966-block 121
    %%%%%:  966-block 123
branch  0 never executed
branch  1 never executed (fallthrough)
        -:  967:            {
    #####:  968:                _VtxWritePtr[0].pos = temp_points[i * 4 + 0]; _VtxWritePtr[0].uv = opaque_uv; _VtxWritePtr[0].col = col_trans;
    #####:  969:                _VtxWritePtr[1].pos = temp_points[i * 4 + 1]; _VtxWritePtr[1].uv = opaque_uv; _VtxWritePtr[1].col = col;
    #####:  970:                _VtxWritePtr[2].pos = temp_points[i * 4 + 2]; _VtxWritePtr[2].uv = opaque_uv; _VtxWritePtr[2].col = col;
    #####:  971:                _VtxWritePtr[3].pos = temp_points[i * 4 + 3]; _VtxWritePtr[3].uv = opaque_uv; _VtxWritePtr[3].col = col_trans;
    #####:  972:                _VtxWritePtr += 4;
    %%%%%:  972-block 122
        -:  973:            }
        -:  974:        }
    33571:  975:        _VtxCurrentIdx += (ImDrawIdx)vtx_count;
    33571:  975-block 124
        -:  976:    }
        -:  977:    else
        -:  978:    {
        -:  979:        // [PATH 4] Non texture-based, Non anti-aliased lines
    #####:  980:        const int idx_count = count * 6;
    #####:  981:        const int vtx_count = count * 4;    // FIXME-OPT: Not sharing edges
    #####:  982:        PrimReserve(idx_count, vtx_count);
    %%%%%:  982-block 125
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:  983:
    #####:  984:        for (int i1 = 0; i1 < count; i1++)
    %%%%%:  984-block 126
    %%%%%:  984-block 134
branch  0 never executed
branch  1 never executed (fallthrough)
        -:  985:        {
    #####:  986:            const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1;
    %%%%%:  986-block 127
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  986-block 128
    %%%%%:  986-block 129
    #####:  987:            const ImVec2& p1 = points[i1];
    #####:  988:            const ImVec2& p2 = points[i2];
        -:  989:
    #####:  990:            float dx = p2.x - p1.x;
    #####:  991:            float dy = p2.y - p1.y;
    #####:  992:            IM_NORMALIZE2F_OVER_ZERO(dx, dy);
    %%%%%:  992-block 130
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  992-block 131
call    2 never executed
    #####:  993:            dx *= (thickness * 0.5f);
    #####:  994:            dy *= (thickness * 0.5f);
        -:  995:
    #####:  996:            _VtxWritePtr[0].pos.x = p1.x + dy; _VtxWritePtr[0].pos.y = p1.y - dx; _VtxWritePtr[0].uv = opaque_uv; _VtxWritePtr[0].col = col;
    #####:  997:            _VtxWritePtr[1].pos.x = p2.x + dy; _VtxWritePtr[1].pos.y = p2.y - dx; _VtxWritePtr[1].uv = opaque_uv; _VtxWritePtr[1].col = col;
    #####:  998:            _VtxWritePtr[2].pos.x = p2.x - dy; _VtxWritePtr[2].pos.y = p2.y + dx; _VtxWritePtr[2].uv = opaque_uv; _VtxWritePtr[2].col = col;
    #####:  999:            _VtxWritePtr[3].pos.x = p1.x - dy; _VtxWritePtr[3].pos.y = p1.y + dx; _VtxWritePtr[3].uv = opaque_uv; _VtxWritePtr[3].col = col;
    #####: 1000:            _VtxWritePtr += 4;
        -: 1001:
    #####: 1002:            _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx + 1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx + 2);
    #####: 1003:            _IdxWritePtr[3] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[4] = (ImDrawIdx)(_VtxCurrentIdx + 2); _IdxWritePtr[5] = (ImDrawIdx)(_VtxCurrentIdx + 3);
    #####: 1004:            _IdxWritePtr += 6;
    #####: 1005:            _VtxCurrentIdx += 4;
    %%%%%: 1005-block 133
        -: 1006:        }
        -: 1007:    }
        -: 1008:}
        -: 1009:
        -: 1010:// - We intentionally avoid using ImVec2 and its math operators here to reduce cost to a minimum for debug/non-inlined builds.
        -: 1011:// - Filled shapes must always use clockwise winding order. The anti-aliasing fringe depends on it. Counter-clockwise shapes will have "inward" anti-aliasing.
function _ZN10ImDrawList19AddConvexPolyFilledEPK6ImVec2ij called 20662 returned 100% blocks executed 71%
    20662: 1012:void ImDrawList::AddConvexPolyFilled(const ImVec2* points, const int points_count, ImU32 col)
        -: 1013:{
    20662: 1014:    if (points_count < 3 || (col & IM_COL32_A_MASK) == 0)
    20662: 1014-block 2
branch  0 taken 20662 (fallthrough)
branch  1 taken 0
    20662: 1014-block 3
branch  2 taken 0 (fallthrough)
branch  3 taken 20662
    #####: 1015:        return;
    %%%%%: 1015-block 4
        -: 1016:
    20662: 1017:    const ImVec2 uv = _Data->TexUvWhitePixel;
        -: 1018:
    20662: 1019:    if (Flags & ImDrawListFlags_AntiAliasedFill)
    20662: 1019-block 5
branch  0 taken 20662 (fallthrough)
branch  1 taken 0
        -: 1020:    {
        -: 1021:        // Anti-aliased Fill
    20662: 1022:        const float AA_SIZE = _FringeScale;
    20662: 1023:        const ImU32 col_trans = col & ~IM_COL32_A_MASK;
    20662: 1024:        const int idx_count = (points_count - 2)*3 + points_count * 6;
    20662: 1025:        const int vtx_count = (points_count * 2);
    20662: 1026:        PrimReserve(idx_count, vtx_count);
    20662: 1026-block 6
call    0 returned 20662
branch  1 taken 20662 (fallthrough)
branch  2 taken 0 (throw)
        -: 1027:
        -: 1028:        // Add indexes for fill
    20662: 1029:        unsigned int vtx_inner_idx = _VtxCurrentIdx;
    20662: 1030:        unsigned int vtx_outer_idx = _VtxCurrentIdx + 1;
   108049: 1031:        for (int i = 2; i < points_count; i++)
    20662: 1031-block 7
   108049: 1031-block 9
branch  0 taken 87387
branch  1 taken 20662 (fallthrough)
        -: 1032:        {
    87387: 1033:            _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + ((i - 1) << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_inner_idx + (i << 1));
    87387: 1034:            _IdxWritePtr += 3;
    87387: 1034-block 8
        -: 1035:        }
        -: 1036:
        -: 1037:        // Compute normals
    20662: 1038:        _Data->TempBuffer.reserve_discard(points_count);
    20662: 1038-block 10
call    0 returned 20662
branch  1 taken 20662 (fallthrough)
branch  2 taken 0 (throw)
    20662: 1039:        ImVec2* temp_normals = _Data->TempBuffer.Data;
   149373: 1040:        for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)
    20662: 1040-block 11
   149373: 1040-block 16
branch  0 taken 128711
branch  1 taken 20662 (fallthrough)
        -: 1041:        {
   128711: 1042:            const ImVec2& p0 = points[i0];
   128711: 1043:            const ImVec2& p1 = points[i1];
   128711: 1044:            float dx = p1.x - p0.x;
   128711: 1045:            float dy = p1.y - p0.y;
   128711: 1046:            IM_NORMALIZE2F_OVER_ZERO(dx, dy);
   128711: 1046-block 12
branch  0 taken 128711 (fallthrough)
branch  1 taken 0
   128711: 1046-block 13
call    2 returned 128711
   128711: 1047:            temp_normals[i0].x = dy;
   128711: 1048:            temp_normals[i0].y = -dx;
   128711: 1048-block 15
        -: 1049:        }
        -: 1050:
   149373: 1051:        for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)
    20662: 1051-block 17
   149373: 1051-block 23
branch  0 taken 128711
branch  1 taken 20662 (fallthrough)
        -: 1052:        {
        -: 1053:            // Average normals
   128711: 1054:            const ImVec2& n0 = temp_normals[i0];
   128711: 1055:            const ImVec2& n1 = temp_normals[i1];
   128711: 1056:            float dm_x = (n0.x + n1.x) * 0.5f;
   128711: 1057:            float dm_y = (n0.y + n1.y) * 0.5f;
  128711*: 1058:            IM_FIXNORMAL2F(dm_x, dm_y);
   128711: 1058-block 18
branch  0 taken 128711 (fallthrough)
branch  1 taken 0
   128711: 1058-block 19
branch  2 taken 0 (fallthrough)
branch  3 taken 128711
    %%%%%: 1058-block 20
   128711: 1058-block 21
   128711: 1059:            dm_x *= AA_SIZE * 0.5f;
   128711: 1060:            dm_y *= AA_SIZE * 0.5f;
        -: 1061:
        -: 1062:            // Add vertices
   128711: 1063:            _VtxWritePtr[0].pos.x = (points[i1].x - dm_x); _VtxWritePtr[0].pos.y = (points[i1].y - dm_y); _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;        // Inner
   128711: 1064:            _VtxWritePtr[1].pos.x = (points[i1].x + dm_x); _VtxWritePtr[1].pos.y = (points[i1].y + dm_y); _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col_trans;  // Outer
   128711: 1065:            _VtxWritePtr += 2;
        -: 1066:
        -: 1067:            // Add indexes for fringes
   128711: 1068:            _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1)); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + (i0 << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1));
   128711: 1069:            _IdxWritePtr[3] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1)); _IdxWritePtr[4] = (ImDrawIdx)(vtx_outer_idx + (i1 << 1)); _IdxWritePtr[5] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1));
   128711: 1070:            _IdxWritePtr += 6;
   128711: 1070-block 22
        -: 1071:        }
    20662: 1072:        _VtxCurrentIdx += (ImDrawIdx)vtx_count;
    20662: 1072-block 24
        -: 1073:    }
        -: 1074:    else
        -: 1075:    {
        -: 1076:        // Non Anti-aliased Fill
    #####: 1077:        const int idx_count = (points_count - 2)*3;
    #####: 1078:        const int vtx_count = points_count;
    #####: 1079:        PrimReserve(idx_count, vtx_count);
    %%%%%: 1079-block 25
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1080:        for (int i = 0; i < vtx_count; i++)
    %%%%%: 1080-block 26
    %%%%%: 1080-block 28
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 1081:        {
    #####: 1082:            _VtxWritePtr[0].pos = points[i]; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;
    #####: 1083:            _VtxWritePtr++;
    %%%%%: 1083-block 27
        -: 1084:        }
    #####: 1085:        for (int i = 2; i < points_count; i++)
    %%%%%: 1085-block 29
    %%%%%: 1085-block 31
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 1086:        {
    #####: 1087:            _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx + i - 1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx + i);
    #####: 1088:            _IdxWritePtr += 3;
    %%%%%: 1088-block 30
        -: 1089:        }
    #####: 1090:        _VtxCurrentIdx += (ImDrawIdx)vtx_count;
    %%%%%: 1090-block 32
        -: 1091:    }
        -: 1092:}
        -: 1093:
function _ZN10ImDrawList16_PathArcToFastExERK6ImVec2fiii called 31844 returned 100% blocks executed 70%
    31844: 1094:void ImDrawList::_PathArcToFastEx(const ImVec2& center, float radius, int a_min_sample, int a_max_sample, int a_step)
        -: 1095:{
    31844: 1096:    if (radius < 0.5f)
    31844: 1096-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 31844
        -: 1097:    {
    #####: 1098:        _Path.push_back(center);
    %%%%%: 1098-block 3
call    0 never executed
    #####: 1099:        return;
        -: 1100:    }
        -: 1101:
        -: 1102:    // Calculate arc auto segment step size
    31844: 1103:    if (a_step <= 0)
    31844: 1103-block 5
branch  0 taken 31844 (fallthrough)
branch  1 taken 0
    31844: 1104:        a_step = IM_DRAWLIST_ARCFAST_SAMPLE_MAX / _CalcCircleAutoSegmentCount(radius);
    31844: 1104-block 6
call    0 returned 31844
        -: 1105:
        -: 1106:    // Make sure we never do steps larger than one quarter of the circle
    31844: 1107:    a_step = ImClamp(a_step, 1, IM_DRAWLIST_ARCFAST_TABLE_SIZE / 4);
    31844: 1107-block 8
call    0 returned 31844
        -: 1108:
    31844: 1109:    const int sample_range = ImAbs(a_max_sample - a_min_sample);
call    0 returned 31844
    31844: 1110:    const int a_next_step = a_step;
        -: 1111:
    31844: 1112:    int samples = sample_range + 1;
    31844: 1113:    bool extra_max_sample = false;
    31844: 1114:    if (a_step > 1)
branch  0 taken 31844 (fallthrough)
branch  1 taken 0
        -: 1115:    {
    31844: 1116:        samples            = sample_range / a_step + 1;
    31844: 1117:        const int overstep = sample_range % a_step;
        -: 1118:
    31844: 1119:        if (overstep > 0)
    31844: 1119-block 11
branch  0 taken 21528 (fallthrough)
branch  1 taken 10316
        -: 1120:        {
    21528: 1121:            extra_max_sample = true;
    21528: 1122:            samples++;
        -: 1123:
        -: 1124:            // When we have overstep to avoid awkwardly looking one long line and one tiny one at the end,
        -: 1125:            // distribute first step range evenly between them by reducing first step size.
    21528: 1126:            if (sample_range > 0)
    21528: 1126-block 12
branch  0 taken 21528 (fallthrough)
branch  1 taken 0
    21528: 1127:                a_step -= (a_step - overstep) / 2;
    21528: 1127-block 13
        -: 1128:        }
        -: 1129:    }
        -: 1130:
    31844: 1131:    _Path.resize(_Path.Size + samples);
    31844: 1131-block 14
call    0 returned 31844
    31844: 1132:    ImVec2* out_ptr = _Path.Data + (_Path.Size - samples);
        -: 1133:
    31844: 1134:    int sample_index = a_min_sample;
    31844: 1135:    if (sample_index < 0 || sample_index >= IM_DRAWLIST_ARCFAST_SAMPLE_MAX)
branch  0 taken 31844 (fallthrough)
branch  1 taken 0
    31844: 1135-block 16
branch  2 taken 0 (fallthrough)
branch  3 taken 31844
        -: 1136:    {
    #####: 1137:        sample_index = sample_index % IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
    #####: 1138:        if (sample_index < 0)
    %%%%%: 1138-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1139:            sample_index += IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
    %%%%%: 1139-block 18
        -: 1140:    }
        -: 1141:
    31844: 1142:    if (a_max_sample >= a_min_sample)
    31844: 1142-block 19
branch  0 taken 31844 (fallthrough)
branch  1 taken 0
        -: 1143:    {
    95532: 1144:        for (int a = a_min_sample; a <= a_max_sample; a += a_step, sample_index += a_step, a_step = a_next_step)
    31844: 1144-block 20
    95532: 1144-block 24
branch  0 taken 63688
branch  1 taken 31844
        -: 1145:        {
        -: 1146:            // a_step is clamped to IM_DRAWLIST_ARCFAST_SAMPLE_MAX, so we have guaranteed that it will not wrap over range twice or more
    63688: 1147:            if (sample_index >= IM_DRAWLIST_ARCFAST_SAMPLE_MAX)
    63688: 1147-block 21
branch  0 taken 2579 (fallthrough)
branch  1 taken 61109
     2579: 1148:                sample_index -= IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
     2579: 1148-block 22
        -: 1149:
    63688: 1150:            const ImVec2 s = _Data->ArcFastVtx[sample_index];
    63688: 1151:            out_ptr->x = center.x + s.x * radius;
    63688: 1152:            out_ptr->y = center.y + s.y * radius;
    63688: 1153:            out_ptr++;
    63688: 1153-block 23
        -: 1154:        }
        -: 1155:    }
        -: 1156:    else
        -: 1157:    {
    #####: 1158:        for (int a = a_min_sample; a >= a_max_sample; a -= a_step, sample_index -= a_step, a_step = a_next_step)
    %%%%%: 1158-block 25
    %%%%%: 1158-block 29
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 1159:        {
        -: 1160:            // a_step is clamped to IM_DRAWLIST_ARCFAST_SAMPLE_MAX, so we have guaranteed that it will not wrap over range twice or more
    #####: 1161:            if (sample_index < 0)
    %%%%%: 1161-block 26
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1162:                sample_index += IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
    %%%%%: 1162-block 27
        -: 1163:
    #####: 1164:            const ImVec2 s = _Data->ArcFastVtx[sample_index];
    #####: 1165:            out_ptr->x = center.x + s.x * radius;
    #####: 1166:            out_ptr->y = center.y + s.y * radius;
    #####: 1167:            out_ptr++;
    %%%%%: 1167-block 28
        -: 1168:        }
        -: 1169:    }
        -: 1170:
    31844: 1171:    if (extra_max_sample)
    31844: 1171-block 30
branch  0 taken 21528 (fallthrough)
branch  1 taken 10316
        -: 1172:    {
    21528: 1173:        int normalized_max_sample = a_max_sample % IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
    21528: 1174:        if (normalized_max_sample < 0)
    21528: 1174-block 31
branch  0 taken 0 (fallthrough)
branch  1 taken 21528
    #####: 1175:            normalized_max_sample += IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
    %%%%%: 1175-block 32
        -: 1176:
    21528: 1177:        const ImVec2 s = _Data->ArcFastVtx[normalized_max_sample];
    21528: 1178:        out_ptr->x = center.x + s.x * radius;
    21528: 1179:        out_ptr->y = center.y + s.y * radius;
    21528: 1180:        out_ptr++;
    21528: 1180-block 33
        -: 1181:    }
        -: 1182:
        -: 1183:    IM_ASSERT_PARANOID(_Path.Data + _Path.Size == out_ptr);
        -: 1184:}
        -: 1185:
function _ZN10ImDrawList11_PathArcToNERK6ImVec2fffi called 0 returned 0% blocks executed 0%
    #####: 1186:void ImDrawList::_PathArcToN(const ImVec2& center, float radius, float a_min, float a_max, int num_segments)
        -: 1187:{
    #####: 1188:    if (radius < 0.5f)
    %%%%%: 1188-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1189:    {
    #####: 1190:        _Path.push_back(center);
    %%%%%: 1190-block 3
call    0 never executed
    #####: 1191:        return;
        -: 1192:    }
        -: 1193:
        -: 1194:    // Note that we are adding a point at both a_min and a_max.
        -: 1195:    // If you are trying to draw a full closed circle you don't want the overlapping points!
    #####: 1196:    _Path.reserve(_Path.Size + (num_segments + 1));
    %%%%%: 1196-block 5
call    0 never executed
    #####: 1197:    for (int i = 0; i <= num_segments; i++)
    %%%%%: 1197-block 10
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 1198:    {
    #####: 1199:        const float a = a_min + ((float)i / (float)num_segments) * (a_max - a_min);
    #####: 1200:        _Path.push_back(ImVec2(center.x + ImCos(a) * radius, center.y + ImSin(a) * radius));
    %%%%%: 1200-block 7
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 1200-block 9
        -: 1201:    }
        -: 1202:}
        -: 1203:
        -: 1204:// 0: East, 3: South, 6: West, 9: North, 12: East
function _ZN10ImDrawList13PathArcToFastERK6ImVec2fii called 44760 returned 100% blocks executed 100%
    44760: 1205:void ImDrawList::PathArcToFast(const ImVec2& center, float radius, int a_min_of_12, int a_max_of_12)
        -: 1206:{
    44760: 1207:    if (radius < 0.5f)
    44760: 1207-block 2
branch  0 taken 12916 (fallthrough)
branch  1 taken 31844
        -: 1208:    {
    12916: 1209:        _Path.push_back(center);
    12916: 1209-block 3
call    0 returned 12916
    12916: 1210:        return;
        -: 1211:    }
    31844: 1212:    _PathArcToFastEx(center, radius, a_min_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, a_max_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, 0);
    31844: 1212-block 5
call    0 returned 31844
        -: 1213:}
        -: 1214:
function _ZN10ImDrawList9PathArcToERK6ImVec2fffi called 0 returned 0% blocks executed 0%
    #####: 1215:void ImDrawList::PathArcTo(const ImVec2& center, float radius, float a_min, float a_max, int num_segments)
        -: 1216:{
    #####: 1217:    if (radius < 0.5f)
    %%%%%: 1217-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1218:    {
    #####: 1219:        _Path.push_back(center);
    %%%%%: 1219-block 3
call    0 never executed
    #####: 1220:        return;
        -: 1221:    }
        -: 1222:
    #####: 1223:    if (num_segments > 0)
    %%%%%: 1223-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1224:    {
    #####: 1225:        _PathArcToN(center, radius, a_min, a_max, num_segments);
    %%%%%: 1225-block 6
call    0 never executed
    #####: 1226:        return;
        -: 1227:    }
        -: 1228:
        -: 1229:    // Automatic segment count
    #####: 1230:    if (radius <= _Data->ArcFastRadiusCutoff)
    %%%%%: 1230-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1231:    {
    #####: 1232:        const bool a_is_reverse = a_max < a_min;
        -: 1233:
        -: 1234:        // We are going to use precomputed values for mid samples.
        -: 1235:        // Determine first and last sample in lookup table that belong to the arc.
    #####: 1236:        const float a_min_sample_f = IM_DRAWLIST_ARCFAST_SAMPLE_MAX * a_min / (IM_PI * 2.0f);
    #####: 1237:        const float a_max_sample_f = IM_DRAWLIST_ARCFAST_SAMPLE_MAX * a_max / (IM_PI * 2.0f);
        -: 1238:
    #####: 1239:        const int a_min_sample = a_is_reverse ? (int)ImFloor(a_min_sample_f) : (int)ImCeil(a_min_sample_f);
    %%%%%: 1239-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1239-block 10
call    2 never executed
    %%%%%: 1239-block 12
    #####: 1240:        const int a_max_sample = a_is_reverse ? (int)ImCeil(a_max_sample_f) : (int)ImFloor(a_max_sample_f);
    %%%%%: 1240-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1240-block 14
    %%%%%: 1240-block 15
call    2 never executed
    #####: 1241:        const int a_mid_samples = a_is_reverse ? ImMax(a_min_sample - a_max_sample, 0) : ImMax(a_max_sample - a_min_sample, 0);
    %%%%%: 1241-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1241-block 18
call    2 never executed
    %%%%%: 1241-block 19
call    3 never executed
        -: 1242:
    #####: 1243:        const float a_min_segment_angle = a_min_sample * IM_PI * 2.0f / IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
    #####: 1244:        const float a_max_segment_angle = a_max_sample * IM_PI * 2.0f / IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
    #####: 1245:        const bool a_emit_start = ImAbs(a_min_segment_angle - a_min) >= 1e-5f;
    %%%%%: 1245-block 20
call    0 never executed
    #####: 1246:        const bool a_emit_end = ImAbs(a_max - a_max_segment_angle) >= 1e-5f;
call    0 never executed
        -: 1247:
    #####: 1248:        _Path.reserve(_Path.Size + (a_mid_samples + 1 + (a_emit_start ? 1 : 0) + (a_emit_end ? 1 : 0)));
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1248-block 23
    %%%%%: 1248-block 24
    %%%%%: 1248-block 25
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1248-block 26
    %%%%%: 1248-block 27
    %%%%%: 1248-block 28
call    4 never executed
    #####: 1249:        if (a_emit_start)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1250:            _Path.push_back(ImVec2(center.x + ImCos(a_min) * radius, center.y + ImSin(a_min) * radius));
    %%%%%: 1250-block 30
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 1250-block 32
    $$$$$: 1250-block 44
call    4 never executed
    #####: 1251:        if (a_mid_samples > 0)
    %%%%%: 1251-block 33
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1252:            _PathArcToFastEx(center, radius, a_min_sample, a_max_sample, 0);
    %%%%%: 1252-block 34
call    0 never executed
    #####: 1253:        if (a_emit_end)
    %%%%%: 1253-block 35
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1254:            _Path.push_back(ImVec2(center.x + ImCos(a_max) * radius, center.y + ImSin(a_max) * radius));
    %%%%%: 1254-block 36
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 1254-block 38
        -: 1255:    }
        -: 1256:    else
        -: 1257:    {
    #####: 1258:        const float arc_length = ImAbs(a_max - a_min);
    %%%%%: 1258-block 39
call    0 never executed
    #####: 1259:        const int circle_segment_count = _CalcCircleAutoSegmentCount(radius);
call    0 never executed
    #####: 1260:        const int arc_segment_count = ImMax((int)ImCeil(circle_segment_count * arc_length / (IM_PI * 2.0f)), (int)(2.0f * IM_PI / arc_length));
call    0 never executed
    #####: 1261:        _PathArcToN(center, radius, a_min, a_max, arc_segment_count);
call    0 never executed
        -: 1262:    }
        -: 1263:}
        -: 1264:
function _ZN10ImDrawList19PathEllipticalArcToERK6ImVec2S2_fffi called 0 returned 0% blocks executed 0%
    #####: 1265:void ImDrawList::PathEllipticalArcTo(const ImVec2& center, const ImVec2& radius, float rot, float a_min, float a_max, int num_segments)
        -: 1266:{
    #####: 1267:    if (num_segments <= 0)
    %%%%%: 1267-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1268:        num_segments = _CalcCircleAutoSegmentCount(ImMax(radius.x, radius.y)); // A bit pessimistic, maybe there's a better computation to do here.
    %%%%%: 1268-block 3
call    0 never executed
call    1 never executed
        -: 1269:
    #####: 1270:    _Path.reserve(_Path.Size + (num_segments + 1));
    %%%%%: 1270-block 6
call    0 never executed
        -: 1271:
    #####: 1272:    const float cos_rot = ImCos(rot);
    #####: 1273:    const float sin_rot = ImSin(rot);
    #####: 1274:    for (int i = 0; i <= num_segments; i++)
    %%%%%: 1274-block 11
    %%%%%: 1274-block 12
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 1275:    {
    #####: 1276:        const float a = a_min + ((float)i / (float)num_segments) * (a_max - a_min);
    #####: 1277:        ImVec2 point(ImCos(a) * radius.x, ImSin(a) * radius.y);
    %%%%%: 1277-block 8
call    0 never executed
    #####: 1278:        const ImVec2 rel((point.x * cos_rot) - (point.y * sin_rot), (point.x * sin_rot) + (point.y * cos_rot));
call    0 never executed
    #####: 1279:        point.x = rel.x + center.x;
    #####: 1280:        point.y = rel.y + center.y;
    #####: 1281:        _Path.push_back(point);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 1282:    }
    #####: 1283:}
    %%%%%: 1283-block 13
        -: 1284:
function _Z17ImBezierCubicCalcRK6ImVec2S1_S1_S1_f called 0 returned 0% blocks executed 0%
    #####: 1285:ImVec2 ImBezierCubicCalc(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, float t)
        -: 1286:{
    #####: 1287:    float u = 1.0f - t;
    #####: 1288:    float w1 = u * u * u;
    #####: 1289:    float w2 = 3 * u * u * t;
    #####: 1290:    float w3 = 3 * u * t * t;
    #####: 1291:    float w4 = t * t * t;
    #####: 1292:    return ImVec2(w1 * p1.x + w2 * p2.x + w3 * p3.x + w4 * p4.x, w1 * p1.y + w2 * p2.y + w3 * p3.y + w4 * p4.y);
    %%%%%: 1292-block 2
call    0 never executed
    %%%%%: 1292-block 4
        -: 1293:}
        -: 1294:
function _Z21ImBezierQuadraticCalcRK6ImVec2S1_S1_f called 0 returned 0% blocks executed 0%
    #####: 1295:ImVec2 ImBezierQuadraticCalc(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, float t)
        -: 1296:{
    #####: 1297:    float u = 1.0f - t;
    #####: 1298:    float w1 = u * u;
    #####: 1299:    float w2 = 2 * u * t;
    #####: 1300:    float w3 = t * t;
    #####: 1301:    return ImVec2(w1 * p1.x + w2 * p2.x + w3 * p3.x, w1 * p1.y + w2 * p2.y + w3 * p3.y);
    %%%%%: 1301-block 2
call    0 never executed
    %%%%%: 1301-block 4
        -: 1302:}
        -: 1303:
        -: 1304:// Closely mimics ImBezierCubicClosestPointCasteljau() in imgui.cpp
function _ZL31PathBezierCubicCurveToCasteljauP8ImVectorI6ImVec2Efffffffffi called 0 returned 0% blocks executed 0%
    #####: 1305:static void PathBezierCubicCurveToCasteljau(ImVector<ImVec2>* path, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4, float tess_tol, int level)
        -: 1306:{
    #####: 1307:    float dx = x4 - x1;
    #####: 1308:    float dy = y4 - y1;
    #####: 1309:    float d2 = (x2 - x4) * dy - (y2 - y4) * dx;
    #####: 1310:    float d3 = (x3 - x4) * dy - (y3 - y4) * dx;
    #####: 1311:    d2 = (d2 >= 0) ? d2 : -d2;
    %%%%%: 1311-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1311-block 3
    %%%%%: 1311-block 4
    #####: 1312:    d3 = (d3 >= 0) ? d3 : -d3;
    %%%%%: 1312-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1312-block 6
    %%%%%: 1312-block 7
    #####: 1313:    if ((d2 + d3) * (d2 + d3) < tess_tol * (dx * dx + dy * dy))
    %%%%%: 1313-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1314:    {
    #####: 1315:        path->push_back(ImVec2(x4, y4));
    %%%%%: 1315-block 9
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 1315-block 11
        -: 1316:    }
    #####: 1317:    else if (level < 10)
    %%%%%: 1317-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1318:    {
    #####: 1319:        float x12 = (x1 + x2) * 0.5f, y12 = (y1 + y2) * 0.5f;
    #####: 1320:        float x23 = (x2 + x3) * 0.5f, y23 = (y2 + y3) * 0.5f;
    #####: 1321:        float x34 = (x3 + x4) * 0.5f, y34 = (y3 + y4) * 0.5f;
    #####: 1322:        float x123 = (x12 + x23) * 0.5f, y123 = (y12 + y23) * 0.5f;
    #####: 1323:        float x234 = (x23 + x34) * 0.5f, y234 = (y23 + y34) * 0.5f;
    #####: 1324:        float x1234 = (x123 + x234) * 0.5f, y1234 = (y123 + y234) * 0.5f;
    #####: 1325:        PathBezierCubicCurveToCasteljau(path, x1, y1, x12, y12, x123, y123, x1234, y1234, tess_tol, level + 1);
    %%%%%: 1325-block 13
call    0 never executed
    #####: 1326:        PathBezierCubicCurveToCasteljau(path, x1234, y1234, x234, y234, x34, y34, x4, y4, tess_tol, level + 1);
call    0 never executed
        -: 1327:    }
    #####: 1328:}
    %%%%%: 1328-block 15
        -: 1329:
function _ZL35PathBezierQuadraticCurveToCasteljauP8ImVectorI6ImVec2Efffffffi called 0 returned 0% blocks executed 0%
    #####: 1330:static void PathBezierQuadraticCurveToCasteljau(ImVector<ImVec2>* path, float x1, float y1, float x2, float y2, float x3, float y3, float tess_tol, int level)
        -: 1331:{
    #####: 1332:    float dx = x3 - x1, dy = y3 - y1;
    #####: 1333:    float det = (x2 - x3) * dy - (y2 - y3) * dx;
    #####: 1334:    if (det * det * 4.0f < tess_tol * (dx * dx + dy * dy))
    %%%%%: 1334-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1335:    {
    #####: 1336:        path->push_back(ImVec2(x3, y3));
    %%%%%: 1336-block 3
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 1336-block 5
        -: 1337:    }
    #####: 1338:    else if (level < 10)
    %%%%%: 1338-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1339:    {
    #####: 1340:        float x12 = (x1 + x2) * 0.5f, y12 = (y1 + y2) * 0.5f;
    #####: 1341:        float x23 = (x2 + x3) * 0.5f, y23 = (y2 + y3) * 0.5f;
    #####: 1342:        float x123 = (x12 + x23) * 0.5f, y123 = (y12 + y23) * 0.5f;
    #####: 1343:        PathBezierQuadraticCurveToCasteljau(path, x1, y1, x12, y12, x123, y123, tess_tol, level + 1);
    %%%%%: 1343-block 7
call    0 never executed
    #####: 1344:        PathBezierQuadraticCurveToCasteljau(path, x123, y123, x23, y23, x3, y3, tess_tol, level + 1);
call    0 never executed
        -: 1345:    }
    #####: 1346:}
    %%%%%: 1346-block 9
        -: 1347:
function _ZN10ImDrawList22PathBezierCubicCurveToERK6ImVec2S2_S2_i called 0 returned 0% blocks executed 0%
    #####: 1348:void ImDrawList::PathBezierCubicCurveTo(const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, int num_segments)
        -: 1349:{
    #####: 1350:    ImVec2 p1 = _Path.back();
    %%%%%: 1350-block 2
call    0 never executed
    #####: 1351:    if (num_segments == 0)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1352:    {
    #####: 1353:        IM_ASSERT(_Data->CurveTessellationTol > 0.0f);
    %%%%%: 1353-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1353-block 5
call    2 never executed
    #####: 1354:        PathBezierCubicCurveToCasteljau(&_Path, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, p4.x, p4.y, _Data->CurveTessellationTol, 0); // Auto-tessellated
    %%%%%: 1354-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 1355:    }
        -: 1356:    else
        -: 1357:    {
    #####: 1358:        float t_step = 1.0f / (float)num_segments;
    #####: 1359:        for (int i_step = 1; i_step <= num_segments; i_step++)
    %%%%%: 1359-block 7
    %%%%%: 1359-block 11
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 1360:            _Path.push_back(ImBezierCubicCalc(p1, p2, p3, p4, t_step * i_step));
    %%%%%: 1360-block 8
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 1360-block 10
    $$$$$: 1360-block 13
        -: 1361:    }
    #####: 1362:}
    %%%%%: 1362-block 12
        -: 1363:
function _ZN10ImDrawList26PathBezierQuadraticCurveToERK6ImVec2S2_i called 0 returned 0% blocks executed 0%
    #####: 1364:void ImDrawList::PathBezierQuadraticCurveTo(const ImVec2& p2, const ImVec2& p3, int num_segments)
        -: 1365:{
    #####: 1366:    ImVec2 p1 = _Path.back();
    %%%%%: 1366-block 2
call    0 never executed
    #####: 1367:    if (num_segments == 0)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1368:    {
    #####: 1369:        IM_ASSERT(_Data->CurveTessellationTol > 0.0f);
    %%%%%: 1369-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1369-block 5
call    2 never executed
    #####: 1370:        PathBezierQuadraticCurveToCasteljau(&_Path, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, _Data->CurveTessellationTol, 0);// Auto-tessellated
    %%%%%: 1370-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 1371:    }
        -: 1372:    else
        -: 1373:    {
    #####: 1374:        float t_step = 1.0f / (float)num_segments;
    #####: 1375:        for (int i_step = 1; i_step <= num_segments; i_step++)
    %%%%%: 1375-block 7
    %%%%%: 1375-block 11
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 1376:            _Path.push_back(ImBezierQuadraticCalc(p1, p2, p3, t_step * i_step));
    %%%%%: 1376-block 8
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 1376-block 10
    $$$$$: 1376-block 13
        -: 1377:    }
    #####: 1378:}
    %%%%%: 1378-block 12
        -: 1379:
function _ZL18FixRectCornerFlagsi called 10114 returned 100% blocks executed 83%
    10114: 1380:static inline ImDrawFlags FixRectCornerFlags(ImDrawFlags flags)
        -: 1381:{
        -: 1382:    /*
        -: 1383:    IM_STATIC_ASSERT(ImDrawFlags_RoundCornersTopLeft == (1 << 4));
        -: 1384:#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
        -: 1385:    // Obsoleted in 1.82 (from February 2021). This code was stripped/simplified and mostly commented in 1.90 (from September 2023)
        -: 1386:    // - Legacy Support for hard coded ~0 (used to be a suggested equivalent to ImDrawCornerFlags_All)
        -: 1387:    if (flags == ~0)                    { return ImDrawFlags_RoundCornersAll; }
        -: 1388:    // - Legacy Support for hard coded 0x01 to 0x0F (matching 15 out of 16 old flags combinations). Read details in older version of this code.
        -: 1389:    if (flags >= 0x01 && flags <= 0x0F) { return (flags << 4); }
        -: 1390:    // We cannot support hard coded 0x00 with 'float rounding > 0.0f' --> replace with ImDrawFlags_RoundCornersNone or use 'float rounding = 0.0f'
        -: 1391:#endif
        -: 1392:    */
        -: 1393:    // If this assert triggers, please update your code replacing hardcoded values with new ImDrawFlags_RoundCorners* values.
        -: 1394:    // Note that ImDrawFlags_Closed (== 0x01) is an invalid flag for AddRect(), AddRectFilled(), PathRect() etc. anyway.
        -: 1395:    // See details in 1.82 Changelog as well as 2021/03/12 and 2023/09/08 entries in "API BREAKING CHANGES" section.
   10114*: 1396:    IM_ASSERT((flags & 0x0F) == 0 && "Misuse of legacy hardcoded ImDrawCornerFlags values!");
    10114: 1396-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 10114
    %%%%%: 1396-block 3
call    2 never executed
        -: 1397:
    10114: 1398:    if ((flags & ImDrawFlags_RoundCornersMask_) == 0)
    10114: 1398-block 4
branch  0 taken 7960 (fallthrough)
branch  1 taken 2154
     7960: 1399:        flags |= ImDrawFlags_RoundCornersAll;
     7960: 1399-block 5
        -: 1400:
    10114: 1401:    return flags;
    10114: 1401-block 6
        -: 1402:}
        -: 1403:
function _ZN10ImDrawList8PathRectERK6ImVec2S2_fi called 11191 returned 100% blocks executed 88%
    11191: 1404:void ImDrawList::PathRect(const ImVec2& a, const ImVec2& b, float rounding, ImDrawFlags flags)
        -: 1405:{
    11191: 1406:    if (rounding >= 0.5f)
    11191: 1406-block 2
branch  0 taken 10114 (fallthrough)
branch  1 taken 1077
        -: 1407:    {
    10114: 1408:        flags = FixRectCornerFlags(flags);
    10114: 1408-block 3
call    0 returned 10114
   10114*: 1409:        rounding = ImMin(rounding, ImFabs(b.x - a.x) * (((flags & ImDrawFlags_RoundCornersTop) == ImDrawFlags_RoundCornersTop) || ((flags & ImDrawFlags_RoundCornersBottom) == ImDrawFlags_RoundCornersBottom) ? 0.5f : 1.0f) - 1.0f);
branch  0 taken 1077 (fallthrough)
branch  1 taken 9037
     1077: 1409-block 5
branch  2 taken 1077 (fallthrough)
branch  3 taken 0
    10114: 1409-block 6
    %%%%%: 1409-block 7
    10114: 1409-block 8
call    4 returned 10114
    10114: 1410:        rounding = ImMin(rounding, ImFabs(b.y - a.y) * (((flags & ImDrawFlags_RoundCornersLeft) == ImDrawFlags_RoundCornersLeft) || ((flags & ImDrawFlags_RoundCornersRight) == ImDrawFlags_RoundCornersRight) ? 0.5f : 1.0f) - 1.0f);
branch  0 taken 2154 (fallthrough)
branch  1 taken 7960
     2154: 1410-block 10
branch  2 taken 0 (fallthrough)
branch  3 taken 2154
     7960: 1410-block 11
     2154: 1410-block 12
    10114: 1410-block 13
call    4 returned 10114
        -: 1411:    }
    11191: 1412:    if (rounding < 0.5f || (flags & ImDrawFlags_RoundCornersMask_) == ImDrawFlags_RoundCornersNone)
    11191: 1412-block 14
branch  0 taken 9038 (fallthrough)
branch  1 taken 2153
     9038: 1412-block 15
branch  2 taken 0 (fallthrough)
branch  3 taken 9038
        -: 1413:    {
     2153: 1414:        PathLineTo(a);
     2153: 1414-block 16
call    0 returned 2153
     2153: 1415:        PathLineTo(ImVec2(b.x, a.y));
call    0 returned 2153
call    1 returned 2153
branch  2 taken 2153 (fallthrough)
branch  3 taken 0 (throw)
    $$$$$: 1415-block 45
call    4 never executed
     2153: 1416:        PathLineTo(b);
     2153: 1416-block 19
call    0 returned 2153
     2153: 1417:        PathLineTo(ImVec2(a.x, b.y));
call    0 returned 2153
call    1 returned 2153
branch  2 taken 2153 (fallthrough)
branch  3 taken 0 (throw)
     2153: 1417-block 22
    $$$$$: 1417-block 46
call    4 never executed
        -: 1418:    }
        -: 1419:    else
        -: 1420:    {
     9038: 1421:        const float rounding_tl = (flags & ImDrawFlags_RoundCornersTopLeft)     ? rounding : 0.0f;
     9038: 1421-block 23
branch  0 taken 7961 (fallthrough)
branch  1 taken 1077
     7961: 1421-block 24
     1077: 1421-block 25
     9038: 1422:        const float rounding_tr = (flags & ImDrawFlags_RoundCornersTopRight)    ? rounding : 0.0f;
     9038: 1422-block 26
branch  0 taken 7961 (fallthrough)
branch  1 taken 1077
     7961: 1422-block 27
     1077: 1422-block 28
     9038: 1423:        const float rounding_br = (flags & ImDrawFlags_RoundCornersBottomRight) ? rounding : 0.0f;
     9038: 1423-block 29
branch  0 taken 7961 (fallthrough)
branch  1 taken 1077
     7961: 1423-block 30
     1077: 1423-block 31
     9038: 1424:        const float rounding_bl = (flags & ImDrawFlags_RoundCornersBottomLeft)  ? rounding : 0.0f;
     9038: 1424-block 32
branch  0 taken 7961 (fallthrough)
branch  1 taken 1077
     7961: 1424-block 33
     1077: 1424-block 34
     9038: 1425:        PathArcToFast(ImVec2(a.x + rounding_tl, a.y + rounding_tl), rounding_tl, 6, 9);
     9038: 1425-block 35
call    0 returned 9038
call    1 returned 9038
branch  2 taken 9038 (fallthrough)
branch  3 taken 0 (throw)
    $$$$$: 1425-block 47
call    4 never executed
     9038: 1426:        PathArcToFast(ImVec2(b.x - rounding_tr, a.y + rounding_tr), rounding_tr, 9, 12);
     9038: 1426-block 37
call    0 returned 9038
call    1 returned 9038
branch  2 taken 9038 (fallthrough)
branch  3 taken 0 (throw)
    $$$$$: 1426-block 48
call    4 never executed
     9038: 1427:        PathArcToFast(ImVec2(b.x - rounding_br, b.y - rounding_br), rounding_br, 0, 3);
     9038: 1427-block 39
call    0 returned 9038
call    1 returned 9038
branch  2 taken 9038 (fallthrough)
branch  3 taken 0 (throw)
    $$$$$: 1427-block 49
call    4 never executed
     9038: 1428:        PathArcToFast(ImVec2(a.x + rounding_bl, b.y - rounding_bl), rounding_bl, 3, 6);
     9038: 1428-block 41
call    0 returned 9038
call    1 returned 9038
branch  2 taken 9038 (fallthrough)
branch  3 taken 0 (throw)
     9038: 1428-block 43
        -: 1429:    }
    11191: 1430:}
    11191: 1430-block 44
        -: 1431:
function _ZN10ImDrawList7AddLineERK6ImVec2S2_jf called 32281 returned 100% blocks executed 71%
    32281: 1432:void ImDrawList::AddLine(const ImVec2& p1, const ImVec2& p2, ImU32 col, float thickness)
        -: 1433:{
    32281: 1434:    if ((col & IM_COL32_A_MASK) == 0)
    32281: 1434-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 32281
    #####: 1435:        return;
    %%%%%: 1435-block 3
    32281: 1436:    PathLineTo(p1 + ImVec2(0.5f, 0.5f));
    32281: 1436-block 4
call    0 returned 32281
call    1 returned 32281
call    2 returned 32281
branch  3 taken 32281 (fallthrough)
branch  4 taken 0 (throw)
    $$$$$: 1436-block 12
    $$$$$: 1436-block 13
call    5 never executed
    32281: 1437:    PathLineTo(p2 + ImVec2(0.5f, 0.5f));
    32281: 1437-block 7
call    0 returned 32281
call    1 returned 32281
call    2 returned 32281
branch  3 taken 32281 (fallthrough)
branch  4 taken 0 (throw)
    $$$$$: 1437-block 14
    32281: 1438:    PathStroke(col, 0, thickness);
    32281: 1438-block 10
call    0 returned 32281
        -: 1439:}
        -: 1440:
        -: 1441:// p_min = upper-left, p_max = lower-right
        -: 1442:// Note we don't render 1 pixels sized rectangles properly.
function _ZN10ImDrawList7AddRectERK6ImVec2S2_jfif called 1290 returned 100% blocks executed 44%
     1290: 1443:void ImDrawList::AddRect(const ImVec2& p_min, const ImVec2& p_max, ImU32 col, float rounding, ImDrawFlags flags, float thickness)
        -: 1444:{
     1290: 1445:    if ((col & IM_COL32_A_MASK) == 0)
     1290: 1445-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1290
    #####: 1446:        return;
    %%%%%: 1446-block 3
     1290: 1447:    if (Flags & ImDrawListFlags_AntiAliasedLines)
     1290: 1447-block 4
branch  0 taken 1290 (fallthrough)
branch  1 taken 0
     1290: 1448:        PathRect(p_min + ImVec2(0.50f, 0.50f), p_max - ImVec2(0.50f, 0.50f), rounding, flags);
     1290: 1448-block 5
call    0 returned 1290
call    1 returned 1290
call    2 returned 1290
call    3 returned 1290
call    4 returned 1290
branch  5 taken 1290 (fallthrough)
branch  6 taken 0 (throw)
     1290: 1448-block 10
    $$$$$: 1448-block 19
    $$$$$: 1448-block 20
    $$$$$: 1448-block 21
    $$$$$: 1448-block 22
call    7 never executed
        -: 1449:    else
    #####: 1450:        PathRect(p_min + ImVec2(0.50f, 0.50f), p_max - ImVec2(0.49f, 0.49f), rounding, flags); // Better looking lower-right corner and rounded non-AA shapes.
    %%%%%: 1450-block 11
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
    %%%%%: 1450-block 16
    $$$$$: 1450-block 23
    $$$$$: 1450-block 24
    $$$$$: 1450-block 25
     1290: 1451:    PathStroke(col, ImDrawFlags_Closed, thickness);
     1290: 1451-block 17
call    0 returned 1290
        -: 1452:}
        -: 1453:
function _ZN10ImDrawList13AddRectFilledERK6ImVec2S2_jfi called 122894 returned 100% blocks executed 89%
   122894: 1454:void ImDrawList::AddRectFilled(const ImVec2& p_min, const ImVec2& p_max, ImU32 col, float rounding, ImDrawFlags flags)
        -: 1455:{
   122894: 1456:    if ((col & IM_COL32_A_MASK) == 0)
   122894: 1456-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 122894
    #####: 1457:        return;
    %%%%%: 1457-block 3
   122894: 1458:    if (rounding < 0.5f || (flags & ImDrawFlags_RoundCornersMask_) == ImDrawFlags_RoundCornersNone)
   122894: 1458-block 4
branch  0 taken 9901 (fallthrough)
branch  1 taken 112993
     9901: 1458-block 5
branch  2 taken 0 (fallthrough)
branch  3 taken 9901
        -: 1459:    {
   112993: 1460:        PrimReserve(6, 4);
   112993: 1460-block 6
call    0 returned 112993
   112993: 1461:        PrimRect(p_min, p_max, col);
call    0 returned 112993
        -: 1462:    }
        -: 1463:    else
        -: 1464:    {
     9901: 1465:        PathRect(p_min, p_max, rounding, flags);
     9901: 1465-block 8
call    0 returned 9901
     9901: 1466:        PathFillConvex(col);
call    0 returned 9901
        -: 1467:    }
        -: 1468:}
        -: 1469:
        -: 1470:// p_min = upper-left, p_max = lower-right
function _ZN10ImDrawList23AddRectFilledMultiColorERK6ImVec2S2_jjjj called 0 returned 0% blocks executed 0%
    #####: 1471:void ImDrawList::AddRectFilledMultiColor(const ImVec2& p_min, const ImVec2& p_max, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left)
        -: 1472:{
    #####: 1473:    if (((col_upr_left | col_upr_right | col_bot_right | col_bot_left) & IM_COL32_A_MASK) == 0)
    %%%%%: 1473-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1474:        return;
    %%%%%: 1474-block 3
        -: 1475:
    #####: 1476:    const ImVec2 uv = _Data->TexUvWhitePixel;
    #####: 1477:    PrimReserve(6, 4);
    %%%%%: 1477-block 4
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1478:    PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx + 1)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx + 2));
    %%%%%: 1478-block 5
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1479:    PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx + 2)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx + 3));
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1480:    PrimWriteVtx(p_min, uv, col_upr_left);
call    0 never executed
    #####: 1481:    PrimWriteVtx(ImVec2(p_max.x, p_min.y), uv, col_upr_right);
call    0 never executed
call    1 never executed
    #####: 1482:    PrimWriteVtx(p_max, uv, col_bot_right);
call    0 never executed
    #####: 1483:    PrimWriteVtx(ImVec2(p_min.x, p_max.y), uv, col_bot_left);
call    0 never executed
call    1 never executed
        -: 1484:}
        -: 1485:
function _ZN10ImDrawList7AddQuadERK6ImVec2S2_S2_S2_jf called 0 returned 0% blocks executed 0%
    #####: 1486:void ImDrawList::AddQuad(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 col, float thickness)
        -: 1487:{
    #####: 1488:    if ((col & IM_COL32_A_MASK) == 0)
    %%%%%: 1488-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1489:        return;
    %%%%%: 1489-block 3
        -: 1490:
    #####: 1491:    PathLineTo(p1);
    %%%%%: 1491-block 4
call    0 never executed
    #####: 1492:    PathLineTo(p2);
call    0 never executed
    #####: 1493:    PathLineTo(p3);
call    0 never executed
    #####: 1494:    PathLineTo(p4);
call    0 never executed
    #####: 1495:    PathStroke(col, ImDrawFlags_Closed, thickness);
call    0 never executed
        -: 1496:}
        -: 1497:
function _ZN10ImDrawList13AddQuadFilledERK6ImVec2S2_S2_S2_j called 0 returned 0% blocks executed 0%
    #####: 1498:void ImDrawList::AddQuadFilled(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 col)
        -: 1499:{
    #####: 1500:    if ((col & IM_COL32_A_MASK) == 0)
    %%%%%: 1500-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1501:        return;
    %%%%%: 1501-block 3
        -: 1502:
    #####: 1503:    PathLineTo(p1);
    %%%%%: 1503-block 4
call    0 never executed
    #####: 1504:    PathLineTo(p2);
call    0 never executed
    #####: 1505:    PathLineTo(p3);
call    0 never executed
    #####: 1506:    PathLineTo(p4);
call    0 never executed
    #####: 1507:    PathFillConvex(col);
call    0 never executed
        -: 1508:}
        -: 1509:
function _ZN10ImDrawList11AddTriangleERK6ImVec2S2_S2_jf called 0 returned 0% blocks executed 0%
    #####: 1510:void ImDrawList::AddTriangle(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, ImU32 col, float thickness)
        -: 1511:{
    #####: 1512:    if ((col & IM_COL32_A_MASK) == 0)
    %%%%%: 1512-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1513:        return;
    %%%%%: 1513-block 3
        -: 1514:
    #####: 1515:    PathLineTo(p1);
    %%%%%: 1515-block 4
call    0 never executed
    #####: 1516:    PathLineTo(p2);
call    0 never executed
    #####: 1517:    PathLineTo(p3);
call    0 never executed
    #####: 1518:    PathStroke(col, ImDrawFlags_Closed, thickness);
call    0 never executed
        -: 1519:}
        -: 1520:
function _ZN10ImDrawList17AddTriangleFilledERK6ImVec2S2_S2_j called 6457 returned 100% blocks executed 86%
     6457: 1521:void ImDrawList::AddTriangleFilled(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, ImU32 col)
        -: 1522:{
     6457: 1523:    if ((col & IM_COL32_A_MASK) == 0)
     6457: 1523-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 6457
    #####: 1524:        return;
    %%%%%: 1524-block 3
        -: 1525:
     6457: 1526:    PathLineTo(p1);
     6457: 1526-block 4
call    0 returned 6457
     6457: 1527:    PathLineTo(p2);
call    0 returned 6457
     6457: 1528:    PathLineTo(p3);
call    0 returned 6457
     6457: 1529:    PathFillConvex(col);
call    0 returned 6457
        -: 1530:}
        -: 1531:
function _ZN10ImDrawList9AddCircleERK6ImVec2fjif called 0 returned 0% blocks executed 0%
    #####: 1532:void ImDrawList::AddCircle(const ImVec2& center, float radius, ImU32 col, int num_segments, float thickness)
        -: 1533:{
    #####: 1534:    if ((col & IM_COL32_A_MASK) == 0 || radius < 0.5f)
    %%%%%: 1534-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1534-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 1535:        return;
    %%%%%: 1535-block 4
        -: 1536:
    #####: 1537:    if (num_segments <= 0)
    %%%%%: 1537-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1538:    {
        -: 1539:        // Use arc with automatic segment count
    #####: 1540:        _PathArcToFastEx(center, radius - 0.5f, 0, IM_DRAWLIST_ARCFAST_SAMPLE_MAX, 0);
    %%%%%: 1540-block 6
call    0 never executed
    #####: 1541:        _Path.Size--;
        -: 1542:    }
        -: 1543:    else
        -: 1544:    {
        -: 1545:        // Explicit segment count (still clamp to avoid drawing insanely tessellated shapes)
    #####: 1546:        num_segments = ImClamp(num_segments, 3, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX);
    %%%%%: 1546-block 8
call    0 never executed
        -: 1547:
        -: 1548:        // Because we are filling a closed shape we remove 1 from the count of segments/points
    #####: 1549:        const float a_max = (IM_PI * 2.0f) * ((float)num_segments - 1.0f) / (float)num_segments;
    #####: 1550:        PathArcTo(center, radius - 0.5f, 0.0f, a_max, num_segments - 1);
call    0 never executed
        -: 1551:    }
        -: 1552:
    #####: 1553:    PathStroke(col, ImDrawFlags_Closed, thickness);
    %%%%%: 1553-block 10
call    0 never executed
        -: 1554:}
        -: 1555:
function _ZN10ImDrawList15AddCircleFilledERK6ImVec2fji called 0 returned 0% blocks executed 0%
    #####: 1556:void ImDrawList::AddCircleFilled(const ImVec2& center, float radius, ImU32 col, int num_segments)
        -: 1557:{
    #####: 1558:    if ((col & IM_COL32_A_MASK) == 0 || radius < 0.5f)
    %%%%%: 1558-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1558-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 1559:        return;
    %%%%%: 1559-block 4
        -: 1560:
    #####: 1561:    if (num_segments <= 0)
    %%%%%: 1561-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1562:    {
        -: 1563:        // Use arc with automatic segment count
    #####: 1564:        _PathArcToFastEx(center, radius, 0, IM_DRAWLIST_ARCFAST_SAMPLE_MAX, 0);
    %%%%%: 1564-block 6
call    0 never executed
    #####: 1565:        _Path.Size--;
        -: 1566:    }
        -: 1567:    else
        -: 1568:    {
        -: 1569:        // Explicit segment count (still clamp to avoid drawing insanely tessellated shapes)
    #####: 1570:        num_segments = ImClamp(num_segments, 3, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX);
    %%%%%: 1570-block 8
call    0 never executed
        -: 1571:
        -: 1572:        // Because we are filling a closed shape we remove 1 from the count of segments/points
    #####: 1573:        const float a_max = (IM_PI * 2.0f) * ((float)num_segments - 1.0f) / (float)num_segments;
    #####: 1574:        PathArcTo(center, radius, 0.0f, a_max, num_segments - 1);
call    0 never executed
        -: 1575:    }
        -: 1576:
    #####: 1577:    PathFillConvex(col);
    %%%%%: 1577-block 10
call    0 never executed
        -: 1578:}
        -: 1579:
        -: 1580:// Guaranteed to honor 'num_segments'
function _ZN10ImDrawList7AddNgonERK6ImVec2fjif called 0 returned 0% blocks executed 0%
    #####: 1581:void ImDrawList::AddNgon(const ImVec2& center, float radius, ImU32 col, int num_segments, float thickness)
        -: 1582:{
    #####: 1583:    if ((col & IM_COL32_A_MASK) == 0 || num_segments <= 2)
    %%%%%: 1583-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1583-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 1584:        return;
    %%%%%: 1584-block 4
        -: 1585:
        -: 1586:    // Because we are filling a closed shape we remove 1 from the count of segments/points
    #####: 1587:    const float a_max = (IM_PI * 2.0f) * ((float)num_segments - 1.0f) / (float)num_segments;
    #####: 1588:    PathArcTo(center, radius - 0.5f, 0.0f, a_max, num_segments - 1);
    %%%%%: 1588-block 5
call    0 never executed
    #####: 1589:    PathStroke(col, ImDrawFlags_Closed, thickness);
call    0 never executed
        -: 1590:}
        -: 1591:
        -: 1592:// Guaranteed to honor 'num_segments'
function _ZN10ImDrawList13AddNgonFilledERK6ImVec2fji called 0 returned 0% blocks executed 0%
    #####: 1593:void ImDrawList::AddNgonFilled(const ImVec2& center, float radius, ImU32 col, int num_segments)
        -: 1594:{
    #####: 1595:    if ((col & IM_COL32_A_MASK) == 0 || num_segments <= 2)
    %%%%%: 1595-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1595-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 1596:        return;
    %%%%%: 1596-block 4
        -: 1597:
        -: 1598:    // Because we are filling a closed shape we remove 1 from the count of segments/points
    #####: 1599:    const float a_max = (IM_PI * 2.0f) * ((float)num_segments - 1.0f) / (float)num_segments;
    #####: 1600:    PathArcTo(center, radius, 0.0f, a_max, num_segments - 1);
    %%%%%: 1600-block 5
call    0 never executed
    #####: 1601:    PathFillConvex(col);
call    0 never executed
        -: 1602:}
        -: 1603:
        -: 1604:// Ellipse
function _ZN10ImDrawList10AddEllipseERK6ImVec2S2_jfif called 0 returned 0% blocks executed 0%
    #####: 1605:void ImDrawList::AddEllipse(const ImVec2& center, const ImVec2& radius, ImU32 col, float rot, int num_segments, float thickness)
        -: 1606:{
    #####: 1607:    if ((col & IM_COL32_A_MASK) == 0)
    %%%%%: 1607-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1608:        return;
    %%%%%: 1608-block 3
        -: 1609:
    #####: 1610:    if (num_segments <= 0)
    %%%%%: 1610-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1611:        num_segments = _CalcCircleAutoSegmentCount(ImMax(radius.x, radius.y)); // A bit pessimistic, maybe there's a better computation to do here.
    %%%%%: 1611-block 5
call    0 never executed
call    1 never executed
        -: 1612:
        -: 1613:    // Because we are filling a closed shape we remove 1 from the count of segments/points
    #####: 1614:    const float a_max = IM_PI * 2.0f * ((float)num_segments - 1.0f) / (float)num_segments;
    #####: 1615:    PathEllipticalArcTo(center, radius, rot, 0.0f, a_max, num_segments - 1);
    %%%%%: 1615-block 8
call    0 never executed
    #####: 1616:    PathStroke(col, true, thickness);
call    0 never executed
        -: 1617:}
        -: 1618:
function _ZN10ImDrawList16AddEllipseFilledERK6ImVec2S2_jfi called 0 returned 0% blocks executed 0%
    #####: 1619:void ImDrawList::AddEllipseFilled(const ImVec2& center, const ImVec2& radius, ImU32 col, float rot, int num_segments)
        -: 1620:{
    #####: 1621:    if ((col & IM_COL32_A_MASK) == 0)
    %%%%%: 1621-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1622:        return;
    %%%%%: 1622-block 3
        -: 1623:
    #####: 1624:    if (num_segments <= 0)
    %%%%%: 1624-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1625:        num_segments = _CalcCircleAutoSegmentCount(ImMax(radius.x, radius.y)); // A bit pessimistic, maybe there's a better computation to do here.
    %%%%%: 1625-block 5
call    0 never executed
call    1 never executed
        -: 1626:
        -: 1627:    // Because we are filling a closed shape we remove 1 from the count of segments/points
    #####: 1628:    const float a_max = IM_PI * 2.0f * ((float)num_segments - 1.0f) / (float)num_segments;
    #####: 1629:    PathEllipticalArcTo(center, radius, rot, 0.0f, a_max, num_segments - 1);
    %%%%%: 1629-block 8
call    0 never executed
    #####: 1630:    PathFillConvex(col);
call    0 never executed
        -: 1631:}
        -: 1632:
        -: 1633:// Cubic Bezier takes 4 controls points
function _ZN10ImDrawList14AddBezierCubicERK6ImVec2S2_S2_S2_jfi called 0 returned 0% blocks executed 0%
    #####: 1634:void ImDrawList::AddBezierCubic(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 col, float thickness, int num_segments)
        -: 1635:{
    #####: 1636:    if ((col & IM_COL32_A_MASK) == 0)
    %%%%%: 1636-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1637:        return;
    %%%%%: 1637-block 3
        -: 1638:
    #####: 1639:    PathLineTo(p1);
    %%%%%: 1639-block 4
call    0 never executed
    #####: 1640:    PathBezierCubicCurveTo(p2, p3, p4, num_segments);
call    0 never executed
    #####: 1641:    PathStroke(col, 0, thickness);
call    0 never executed
        -: 1642:}
        -: 1643:
        -: 1644:// Quadratic Bezier takes 3 controls points
function _ZN10ImDrawList18AddBezierQuadraticERK6ImVec2S2_S2_jfi called 0 returned 0% blocks executed 0%
    #####: 1645:void ImDrawList::AddBezierQuadratic(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, ImU32 col, float thickness, int num_segments)
        -: 1646:{
    #####: 1647:    if ((col & IM_COL32_A_MASK) == 0)
    %%%%%: 1647-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1648:        return;
    %%%%%: 1648-block 3
        -: 1649:
    #####: 1650:    PathLineTo(p1);
    %%%%%: 1650-block 4
call    0 never executed
    #####: 1651:    PathBezierQuadraticCurveTo(p2, p3, num_segments);
call    0 never executed
    #####: 1652:    PathStroke(col, 0, thickness);
call    0 never executed
        -: 1653:}
        -: 1654:
function _ZN10ImDrawList7AddTextEPK6ImFontfRK6ImVec2jPKcS7_fPK6ImVec4 called 906500 returned 100% blocks executed 92%
   906500: 1655:void ImDrawList::AddText(const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end, float wrap_width, const ImVec4* cpu_fine_clip_rect)
        -: 1656:{
   906500: 1657:    if ((col & IM_COL32_A_MASK) == 0)
   906500: 1657-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 906500
    1076*: 1658:        return;
    %%%%%: 1658-block 3
     1076: 1658-block 23
        -: 1659:
        -: 1660:    // Accept null ranges
   906500: 1661:    if (text_begin == text_end || text_begin[0] == 0)
   906500: 1661-block 4
branch  0 taken 905424 (fallthrough)
branch  1 taken 1076
   905424: 1661-block 5
branch  2 taken 0 (fallthrough)
branch  3 taken 905424
     1076: 1662:        return;
     1076: 1662-block 6
   905424: 1663:    if (text_end == NULL)
   905424: 1663-block 7
branch  0 taken 470650 (fallthrough)
branch  1 taken 434774
   470650: 1664:        text_end = text_begin + strlen(text_begin);
   470650: 1664-block 8
        -: 1665:
        -: 1666:    // Pull default font/size from the shared ImDrawListSharedData instance
   905424: 1667:    if (font == NULL)
   905424: 1667-block 9
branch  0 taken 775880 (fallthrough)
branch  1 taken 129544
   775880: 1668:        font = _Data->Font;
   775880: 1668-block 10
   905424: 1669:    if (font_size == 0.0f)
   905424: 1669-block 11
branch  0 taken 775880 (fallthrough)
branch  1 taken 129544
   775880: 1670:        font_size = _Data->FontSize;
   775880: 1670-block 12
        -: 1671:
  905424*: 1672:    IM_ASSERT(font->ContainerAtlas->TexID == _CmdHeader.TextureId);  // Use high-level ImGui::PushFont() or low-level ImDrawList::PushTextureId() to change font.
   905424: 1672-block 13
branch  0 taken 0 (fallthrough)
branch  1 taken 905424
    %%%%%: 1672-block 14
call    2 never executed
        -: 1673:
   905424: 1674:    ImVec4 clip_rect = _CmdHeader.ClipRect;
   905424: 1675:    if (cpu_fine_clip_rect)
   905424: 1675-block 15
branch  0 taken 38667 (fallthrough)
branch  1 taken 866757
        -: 1676:    {
    38667: 1677:        clip_rect.x = ImMax(clip_rect.x, cpu_fine_clip_rect->x);
    38667: 1677-block 16
call    0 returned 38667
    38667: 1678:        clip_rect.y = ImMax(clip_rect.y, cpu_fine_clip_rect->y);
call    0 returned 38667
    38667: 1679:        clip_rect.z = ImMin(clip_rect.z, cpu_fine_clip_rect->z);
call    0 returned 38667
    38667: 1680:        clip_rect.w = ImMin(clip_rect.w, cpu_fine_clip_rect->w);
call    0 returned 38667
        -: 1681:    }
   905424: 1682:    font->RenderText(this, font_size, pos, col, clip_rect, text_begin, text_end, wrap_width, cpu_fine_clip_rect != NULL);
   905424: 1682-block 21
call    0 returned 905424
branch  1 taken 905424 (fallthrough)
branch  2 taken 0 (throw)
        -: 1683:}
        -: 1684:
function _ZN10ImDrawList7AddTextERK6ImVec2jPKcS4_ called 729674 returned 100% blocks executed 100%
   729674: 1685:void ImDrawList::AddText(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end)
        -: 1686:{
   729674: 1687:    AddText(NULL, 0.0f, pos, col, text_begin, text_end);
   729674: 1687-block 2
call    0 returned 729674
   729674: 1688:}
        -: 1689:
function _ZN10ImDrawList8AddImageEyRK6ImVec2S2_S2_S2_j called 0 returned 0% blocks executed 0%
    #####: 1690:void ImDrawList::AddImage(ImTextureID user_texture_id, const ImVec2& p_min, const ImVec2& p_max, const ImVec2& uv_min, const ImVec2& uv_max, ImU32 col)
        -: 1691:{
    #####: 1692:    if ((col & IM_COL32_A_MASK) == 0)
    %%%%%: 1692-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1693:        return;
    %%%%%: 1693-block 3
        -: 1694:
    #####: 1695:    const bool push_texture_id = user_texture_id != _CmdHeader.TextureId;
    #####: 1696:    if (push_texture_id)
    %%%%%: 1696-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1697:        PushTextureID(user_texture_id);
    %%%%%: 1697-block 5
call    0 never executed
        -: 1698:
    #####: 1699:    PrimReserve(6, 4);
    %%%%%: 1699-block 6
call    0 never executed
    #####: 1700:    PrimRectUV(p_min, p_max, uv_min, uv_max, col);
call    0 never executed
        -: 1701:
    #####: 1702:    if (push_texture_id)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1703:        PopTextureID();
    %%%%%: 1703-block 9
call    0 never executed
        -: 1704:}
        -: 1705:
function _ZN10ImDrawList12AddImageQuadEyRK6ImVec2S2_S2_S2_S2_S2_S2_S2_j called 0 returned 0% blocks executed 0%
    #####: 1706:void ImDrawList::AddImageQuad(ImTextureID user_texture_id, const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, const ImVec2& uv1, const ImVec2& uv2, const ImVec2& uv3, const ImVec2& uv4, ImU32 col)
        -: 1707:{
    #####: 1708:    if ((col & IM_COL32_A_MASK) == 0)
    %%%%%: 1708-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1709:        return;
    %%%%%: 1709-block 3
        -: 1710:
    #####: 1711:    const bool push_texture_id = user_texture_id != _CmdHeader.TextureId;
    #####: 1712:    if (push_texture_id)
    %%%%%: 1712-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1713:        PushTextureID(user_texture_id);
    %%%%%: 1713-block 5
call    0 never executed
        -: 1714:
    #####: 1715:    PrimReserve(6, 4);
    %%%%%: 1715-block 6
call    0 never executed
    #####: 1716:    PrimQuadUV(p1, p2, p3, p4, uv1, uv2, uv3, uv4, col);
call    0 never executed
        -: 1717:
    #####: 1718:    if (push_texture_id)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1719:        PopTextureID();
    %%%%%: 1719-block 9
call    0 never executed
        -: 1720:}
        -: 1721:
function _ZN10ImDrawList15AddImageRoundedEyRK6ImVec2S2_S2_S2_jfi called 0 returned 0% blocks executed 0%
    #####: 1722:void ImDrawList::AddImageRounded(ImTextureID user_texture_id, const ImVec2& p_min, const ImVec2& p_max, const ImVec2& uv_min, const ImVec2& uv_max, ImU32 col, float rounding, ImDrawFlags flags)
        -: 1723:{
    #####: 1724:    if ((col & IM_COL32_A_MASK) == 0)
    %%%%%: 1724-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1725:        return;
    %%%%%: 1725-block 3
        -: 1726:
    #####: 1727:    flags = FixRectCornerFlags(flags);
    %%%%%: 1727-block 4
call    0 never executed
    #####: 1728:    if (rounding < 0.5f || (flags & ImDrawFlags_RoundCornersMask_) == ImDrawFlags_RoundCornersNone)
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1728-block 6
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 1729:    {
    #####: 1730:        AddImage(user_texture_id, p_min, p_max, uv_min, uv_max, col);
    %%%%%: 1730-block 7
call    0 never executed
    #####: 1731:        return;
        -: 1732:    }
        -: 1733:
    #####: 1734:    const bool push_texture_id = user_texture_id != _CmdHeader.TextureId;
    #####: 1735:    if (push_texture_id)
    %%%%%: 1735-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1736:        PushTextureID(user_texture_id);
    %%%%%: 1736-block 10
call    0 never executed
        -: 1737:
    #####: 1738:    int vert_start_idx = VtxBuffer.Size;
    #####: 1739:    PathRect(p_min, p_max, rounding, flags);
    %%%%%: 1739-block 11
call    0 never executed
    #####: 1740:    PathFillConvex(col);
call    0 never executed
    #####: 1741:    int vert_end_idx = VtxBuffer.Size;
    #####: 1742:    ImGui::ShadeVertsLinearUV(this, vert_start_idx, vert_end_idx, p_min, p_max, uv_min, uv_max, true);
call    0 never executed
        -: 1743:
    #####: 1744:    if (push_texture_id)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1745:        PopTextureID();
    %%%%%: 1745-block 15
call    0 never executed
        -: 1746:}
        -: 1747:
        -: 1748://-----------------------------------------------------------------------------
        -: 1749:// [SECTION] ImTriangulator, ImDrawList concave polygon fill
        -: 1750://-----------------------------------------------------------------------------
        -: 1751:// Triangulate concave polygons. Based on "Triangulation by Ear Clipping" paper, O(N^2) complexity.
        -: 1752:// Reference: https://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf
        -: 1753:// Provided as a convenience for user but not used by main library.
        -: 1754://-----------------------------------------------------------------------------
        -: 1755:// - ImTriangulator [Internal]
        -: 1756:// - AddConcavePolyFilled()
        -: 1757://-----------------------------------------------------------------------------
        -: 1758:
        -: 1759:enum ImTriangulatorNodeType
        -: 1760:{
        -: 1761:    ImTriangulatorNodeType_Convex,
        -: 1762:    ImTriangulatorNodeType_Ear,
        -: 1763:    ImTriangulatorNodeType_Reflex
        -: 1764:};
        -: 1765:
        -: 1766:struct ImTriangulatorNode
        -: 1767:{
        -: 1768:    ImTriangulatorNodeType  Type;
        -: 1769:    int                     Index;
        -: 1770:    ImVec2                  Pos;
        -: 1771:    ImTriangulatorNode*     Next;
        -: 1772:    ImTriangulatorNode*     Prev;
        -: 1773:
function _ZN18ImTriangulatorNode6UnlinkEv called 0 returned 0% blocks executed 0%
    #####: 1774:    void    Unlink()        { Next->Prev = Prev; Prev->Next = Next; }
        -: 1775:};
        -: 1776:
        -: 1777:struct ImTriangulatorNodeSpan
        -: 1778:{
        -: 1779:    ImTriangulatorNode**    Data = NULL;
        -: 1780:    int                     Size = 0;
        -: 1781:
function _ZN22ImTriangulatorNodeSpan9push_backEP18ImTriangulatorNode called 0 returned 0% blocks executed 0%
    #####: 1782:    void    push_back(ImTriangulatorNode* node) { Data[Size++] = node; }
function _ZN22ImTriangulatorNodeSpan19find_erase_unsortedEi called 0 returned 0% blocks executed 0%
    #####: 1783:    void    find_erase_unsorted(int idx)        { for (int i = Size - 1; i >= 0; i--) if (Data[i]->Index == idx) { Data[i] = Data[Size - 1]; Size--; return; } }
    %%%%%: 1783-block 2
    %%%%%: 1783-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1783-block 4
    %%%%%: 1783-block 5
    %%%%%: 1783-block 6
branch  2 never executed
branch  3 never executed (fallthrough)
        -: 1784:};
        -: 1785:
        -: 1786:struct ImTriangulator
        -: 1787:{
function _ZN14ImTriangulator21EstimateTriangleCountEi called 0 returned 0% blocks executed 0%
    #####: 1788:    static int EstimateTriangleCount(int points_count)      { return (points_count < 3) ? 0 : points_count - 2; }
    %%%%%: 1788-block 2
function _ZN14ImTriangulator25EstimateScratchBufferSizeEi called 0 returned 0% blocks executed 0%
    #####: 1789:    static int EstimateScratchBufferSize(int points_count)  { return sizeof(ImTriangulatorNode) * points_count + sizeof(ImTriangulatorNode*) * points_count * 2; }
    %%%%%: 1789-block 2
        -: 1790:
        -: 1791:    void    Init(const ImVec2* points, int points_count, void* scratch_buffer);
        -: 1792:    void    GetNextTriangle(unsigned int out_triangle[3]);     // Return relative indexes for next triangle
        -: 1793:
        -: 1794:    // Internal functions
        -: 1795:    void    BuildNodes(const ImVec2* points, int points_count);
        -: 1796:    void    BuildReflexes();
        -: 1797:    void    BuildEars();
        -: 1798:    void    FlipNodeList();
        -: 1799:    bool    IsEar(int i0, int i1, int i2, const ImVec2& v0, const ImVec2& v1, const ImVec2& v2) const;
        -: 1800:    void    ReclassifyNode(ImTriangulatorNode* node);
        -: 1801:
        -: 1802:    // Internal members
        -: 1803:    int                     _TrianglesLeft = 0;
        -: 1804:    ImTriangulatorNode*     _Nodes = NULL;
        -: 1805:    ImTriangulatorNodeSpan  _Ears;
        -: 1806:    ImTriangulatorNodeSpan  _Reflexes;
        -: 1807:};
        -: 1808:
        -: 1809:// Distribute storage for nodes, ears and reflexes.
        -: 1810:// FIXME-OPT: if everything is convex, we could report it to caller and let it switch to an convex renderer
        -: 1811:// (this would require first building reflexes to bail to convex if empty, without even building nodes)
function _ZN14ImTriangulator4InitEPK6ImVec2iPv called 0 returned 0% blocks executed 0%
    #####: 1812:void ImTriangulator::Init(const ImVec2* points, int points_count, void* scratch_buffer)
        -: 1813:{
    #####: 1814:    IM_ASSERT(scratch_buffer != NULL && points_count >= 3);
    %%%%%: 1814-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1814-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1814-block 4
    %%%%%: 1814-block 5
call    4 never executed
    #####: 1815:    _TrianglesLeft = EstimateTriangleCount(points_count);
    %%%%%: 1815-block 6
call    0 never executed
    #####: 1816:    _Nodes         = (ImTriangulatorNode*)scratch_buffer;                          // points_count x Node
    #####: 1817:    _Ears.Data     = (ImTriangulatorNode**)(_Nodes + points_count);                // points_count x Node*
    #####: 1818:    _Reflexes.Data = (ImTriangulatorNode**)(_Nodes + points_count) + points_count; // points_count x Node*
    #####: 1819:    BuildNodes(points, points_count);
call    0 never executed
    #####: 1820:    BuildReflexes();
call    0 never executed
    #####: 1821:    BuildEars();
call    0 never executed
    #####: 1822:}
        -: 1823:
function _ZN14ImTriangulator10BuildNodesEPK6ImVec2i called 0 returned 0% blocks executed 0%
    #####: 1824:void ImTriangulator::BuildNodes(const ImVec2* points, int points_count)
        -: 1825:{
    #####: 1826:    for (int i = 0; i < points_count; i++)
    %%%%%: 1826-block 2
    %%%%%: 1826-block 4
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 1827:    {
    #####: 1828:        _Nodes[i].Type = ImTriangulatorNodeType_Convex;
    #####: 1829:        _Nodes[i].Index = i;
    #####: 1830:        _Nodes[i].Pos = points[i];
    #####: 1831:        _Nodes[i].Next = _Nodes + i + 1;
    #####: 1832:        _Nodes[i].Prev = _Nodes + i - 1;
    %%%%%: 1832-block 3
        -: 1833:    }
    #####: 1834:    _Nodes[0].Prev = _Nodes + points_count - 1;
    #####: 1835:    _Nodes[points_count - 1].Next = _Nodes;
    #####: 1836:}
        -: 1837:
function _ZN14ImTriangulator13BuildReflexesEv called 0 returned 0% blocks executed 0%
    #####: 1838:void ImTriangulator::BuildReflexes()
        -: 1839:{
    #####: 1840:    ImTriangulatorNode* n1 = _Nodes;
    #####: 1841:    for (int i = _TrianglesLeft; i >= 0; i--, n1 = n1->Next)
    %%%%%: 1841-block 2
    %%%%%: 1841-block 7
    %%%%%: 1841-block 8
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 1842:    {
    #####: 1843:        if (ImTriangleIsClockwise(n1->Prev->Pos, n1->Pos, n1->Next->Pos))
    %%%%%: 1843-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 1844:            continue;
    %%%%%: 1844-block 5
    #####: 1845:        n1->Type = ImTriangulatorNodeType_Reflex;
    #####: 1846:        _Reflexes.push_back(n1);
    %%%%%: 1846-block 6
call    0 never executed
        -: 1847:    }
    #####: 1848:}
        -: 1849:
function _ZN14ImTriangulator9BuildEarsEv called 0 returned 0% blocks executed 0%
    #####: 1850:void ImTriangulator::BuildEars()
        -: 1851:{
    #####: 1852:    ImTriangulatorNode* n1 = _Nodes;
    #####: 1853:    for (int i = _TrianglesLeft; i >= 0; i--, n1 = n1->Next)
    %%%%%: 1853-block 2
    %%%%%: 1853-block 9
    %%%%%: 1853-block 10
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 1854:    {
    #####: 1855:        if (n1->Type != ImTriangulatorNodeType_Convex)
    %%%%%: 1855-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1856:            continue;
    %%%%%: 1856-block 4
    #####: 1857:        if (!IsEar(n1->Prev->Index, n1->Index, n1->Next->Index, n1->Prev->Pos, n1->Pos, n1->Next->Pos))
    %%%%%: 1857-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 1858:            continue;
    %%%%%: 1858-block 7
    #####: 1859:        n1->Type = ImTriangulatorNodeType_Ear;
    #####: 1860:        _Ears.push_back(n1);
    %%%%%: 1860-block 8
call    0 never executed
        -: 1861:    }
    #####: 1862:}
        -: 1863:
function _ZN14ImTriangulator15GetNextTriangleEPj called 0 returned 0% blocks executed 0%
    #####: 1864:void ImTriangulator::GetNextTriangle(unsigned int out_triangle[3])
        -: 1865:{
    #####: 1866:    if (_Ears.Size == 0)
    %%%%%: 1866-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1867:    {
    #####: 1868:        FlipNodeList();
    %%%%%: 1868-block 3
call    0 never executed
        -: 1869:
    #####: 1870:        ImTriangulatorNode* node = _Nodes;
    #####: 1871:        for (int i = _TrianglesLeft; i >= 0; i--, node = node->Next)
    %%%%%: 1871-block 6
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 1872:            node->Type = ImTriangulatorNodeType_Convex;
    %%%%%: 1872-block 5
    #####: 1873:        _Reflexes.Size = 0;
    #####: 1874:        BuildReflexes();
    %%%%%: 1874-block 7
call    0 never executed
    #####: 1875:        BuildEars();
call    0 never executed
        -: 1876:
        -: 1877:        // If we still don't have ears, it means geometry is degenerated.
    #####: 1878:        if (_Ears.Size == 0)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1879:        {
        -: 1880:            // Return first triangle available, mimicking the behavior of convex fill.
    #####: 1881:            IM_ASSERT(_TrianglesLeft > 0); // Geometry is degenerated
    %%%%%: 1881-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1881-block 11
call    2 never executed
    #####: 1882:            _Ears.Data[0] = _Nodes;
    #####: 1883:            _Ears.Size    = 1;
    %%%%%: 1883-block 12
        -: 1884:        }
        -: 1885:    }
        -: 1886:
    #####: 1887:    ImTriangulatorNode* ear = _Ears.Data[--_Ears.Size];
    #####: 1888:    out_triangle[0] = ear->Prev->Index;
    #####: 1889:    out_triangle[1] = ear->Index;
    #####: 1890:    out_triangle[2] = ear->Next->Index;
        -: 1891:
    #####: 1892:    ear->Unlink();
    %%%%%: 1892-block 13
call    0 never executed
    #####: 1893:    if (ear == _Nodes)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1894:        _Nodes = ear->Next;
    %%%%%: 1894-block 15
        -: 1895:
    #####: 1896:    ReclassifyNode(ear->Prev);
    %%%%%: 1896-block 16
call    0 never executed
    #####: 1897:    ReclassifyNode(ear->Next);
call    0 never executed
    #####: 1898:    _TrianglesLeft--;
    #####: 1899:}
        -: 1900:
function _ZN14ImTriangulator12FlipNodeListEv called 0 returned 0% blocks executed 0%
    #####: 1901:void ImTriangulator::FlipNodeList()
        -: 1902:{
    #####: 1903:    ImTriangulatorNode* prev = _Nodes;
    #####: 1904:    ImTriangulatorNode* temp = _Nodes;
    #####: 1905:    ImTriangulatorNode* current = _Nodes->Next;
    #####: 1906:    prev->Next = prev;
    #####: 1907:    prev->Prev = prev;
    #####: 1908:    while (current != _Nodes)
    %%%%%: 1908-block 2
    %%%%%: 1908-block 4
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 1909:    {
    #####: 1910:        temp = current->Next;
        -: 1911:
    #####: 1912:        current->Next = prev;
    #####: 1913:        prev->Prev = current;
    #####: 1914:        _Nodes->Next = current;
    #####: 1915:        current->Prev = _Nodes;
        -: 1916:
    #####: 1917:        prev = current;
    #####: 1918:        current = temp;
    %%%%%: 1918-block 3
        -: 1919:    }
    #####: 1920:    _Nodes = prev;
    #####: 1921:}
        -: 1922:
        -: 1923:// A triangle is an ear is no other vertex is inside it. We can test reflexes vertices only (see reference algorithm)
function _ZNK14ImTriangulator5IsEarEiiiRK6ImVec2S2_S2_ called 0 returned 0% blocks executed 0%
    #####: 1924:bool ImTriangulator::IsEar(int i0, int i1, int i2, const ImVec2& v0, const ImVec2& v1, const ImVec2& v2) const
        -: 1925:{
    #####: 1926:    ImTriangulatorNode** p_end = _Reflexes.Data + _Reflexes.Size;
    #####: 1927:    for (ImTriangulatorNode** p = _Reflexes.Data; p < p_end; p++)
    %%%%%: 1927-block 2
    %%%%%: 1927-block 9
    %%%%%: 1927-block 10
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 1928:    {
    #####: 1929:        ImTriangulatorNode* reflex = *p;
    #####: 1930:        if (reflex->Index != i0 && reflex->Index != i1 && reflex->Index != i2)
    %%%%%: 1930-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1930-block 4
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 1930-block 5
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 1931:            if (ImTriangleContainsPoint(v0, v1, v2, reflex->Pos))
    %%%%%: 1931-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 1932:                return false;
    %%%%%: 1932-block 8
        -: 1933:    }
    #####: 1934:    return true;
    %%%%%: 1934-block 11
        -: 1935:}
        -: 1936:
function _ZN14ImTriangulator14ReclassifyNodeEP18ImTriangulatorNode called 0 returned 0% blocks executed 0%
    #####: 1937:void ImTriangulator::ReclassifyNode(ImTriangulatorNode* n1)
        -: 1938:{
        -: 1939:    // Classify node
        -: 1940:    ImTriangulatorNodeType type;
    #####: 1941:    const ImTriangulatorNode* n0 = n1->Prev;
    #####: 1942:    const ImTriangulatorNode* n2 = n1->Next;
    #####: 1943:    if (!ImTriangleIsClockwise(n0->Pos, n1->Pos, n2->Pos))
    %%%%%: 1943-block 2
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 1944:        type = ImTriangulatorNodeType_Reflex;
    %%%%%: 1944-block 4
    #####: 1945:    else if (IsEar(n0->Index, n1->Index, n2->Index, n0->Pos, n1->Pos, n2->Pos))
    %%%%%: 1945-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 1946:        type = ImTriangulatorNodeType_Ear;
    %%%%%: 1946-block 7
        -: 1947:    else
    #####: 1948:        type = ImTriangulatorNodeType_Convex;
    %%%%%: 1948-block 8
        -: 1949:
        -: 1950:    // Update lists when a type changes
    #####: 1951:    if (type == n1->Type)
    %%%%%: 1951-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1952:        return;
    %%%%%: 1952-block 10
    #####: 1953:    if (n1->Type == ImTriangulatorNodeType_Reflex)
    %%%%%: 1953-block 11
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1954:        _Reflexes.find_erase_unsorted(n1->Index);
    %%%%%: 1954-block 12
call    0 never executed
    #####: 1955:    else if (n1->Type == ImTriangulatorNodeType_Ear)
    %%%%%: 1955-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1956:        _Ears.find_erase_unsorted(n1->Index);
    %%%%%: 1956-block 14
call    0 never executed
    #####: 1957:    if (type == ImTriangulatorNodeType_Reflex)
    %%%%%: 1957-block 15
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1958:        _Reflexes.push_back(n1);
    %%%%%: 1958-block 16
call    0 never executed
    #####: 1959:    else if (type == ImTriangulatorNodeType_Ear)
    %%%%%: 1959-block 17
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1960:        _Ears.push_back(n1);
    %%%%%: 1960-block 18
call    0 never executed
    #####: 1961:    n1->Type = type;
    %%%%%: 1961-block 19
        -: 1962:}
        -: 1963:
        -: 1964:// Use ear-clipping algorithm to triangulate a simple polygon (no self-interaction, no holes).
        -: 1965:// (Reminder: we don't perform any coarse clipping/culling in ImDrawList layer!
        -: 1966:// It is up to caller to ensure not making costly calls that will be outside of visible area.
        -: 1967:// As concave fill is noticeably more expensive than other primitives, be mindful of this...
        -: 1968:// Caller can build AABB of points, and avoid filling if 'draw_list->_CmdHeader.ClipRect.Overlays(points_bb) == false')
function _ZN10ImDrawList20AddConcavePolyFilledEPK6ImVec2ij called 0 returned 0% blocks executed 0%
    #####: 1969:void ImDrawList::AddConcavePolyFilled(const ImVec2* points, const int points_count, ImU32 col)
        -: 1970:{
    #####: 1971:    if (points_count < 3 || (col & IM_COL32_A_MASK) == 0)
    %%%%%: 1971-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 1971-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 1972:        return;
    %%%%%: 1972-block 4
        -: 1973:
    #####: 1974:    const ImVec2 uv = _Data->TexUvWhitePixel;
    #####: 1975:    ImTriangulator triangulator;
        -: 1976:    unsigned int triangle[3];
    #####: 1977:    if (Flags & ImDrawListFlags_AntiAliasedFill)
    %%%%%: 1977-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1978:    {
        -: 1979:        // Anti-aliased Fill
    #####: 1980:        const float AA_SIZE = _FringeScale;
    #####: 1981:        const ImU32 col_trans = col & ~IM_COL32_A_MASK;
    #####: 1982:        const int idx_count = (points_count - 2) * 3 + points_count * 6;
    #####: 1983:        const int vtx_count = (points_count * 2);
    #####: 1984:        PrimReserve(idx_count, vtx_count);
    %%%%%: 1984-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 1985:
        -: 1986:        // Add indexes for fill
    #####: 1987:        unsigned int vtx_inner_idx = _VtxCurrentIdx;
    #####: 1988:        unsigned int vtx_outer_idx = _VtxCurrentIdx + 1;
        -: 1989:
    #####: 1990:        _Data->TempBuffer.reserve_discard((ImTriangulator::EstimateScratchBufferSize(points_count) + sizeof(ImVec2)) / sizeof(ImVec2));
    %%%%%: 1990-block 7
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####: 1991:        triangulator.Init(points, points_count, _Data->TempBuffer.Data);
    %%%%%: 1991-block 9
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1992:        while (triangulator._TrianglesLeft > 0)
    %%%%%: 1992-block 10
    %%%%%: 1992-block 13
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 1993:        {
    #####: 1994:            triangulator.GetNextTriangle(triangle);
    %%%%%: 1994-block 11
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 1995:            _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx + (triangle[0] << 1)); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + (triangle[1] << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_inner_idx + (triangle[2] << 1));
    #####: 1996:            _IdxWritePtr += 3;
    %%%%%: 1996-block 12
        -: 1997:        }
        -: 1998:
        -: 1999:        // Compute normals
    #####: 2000:        _Data->TempBuffer.reserve_discard(points_count);
    %%%%%: 2000-block 14
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 2001:        ImVec2* temp_normals = _Data->TempBuffer.Data;
    #####: 2002:        for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)
    %%%%%: 2002-block 15
    %%%%%: 2002-block 20
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 2003:        {
    #####: 2004:            const ImVec2& p0 = points[i0];
    #####: 2005:            const ImVec2& p1 = points[i1];
    #####: 2006:            float dx = p1.x - p0.x;
    #####: 2007:            float dy = p1.y - p0.y;
    #####: 2008:            IM_NORMALIZE2F_OVER_ZERO(dx, dy);
    %%%%%: 2008-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2008-block 17
call    2 never executed
    #####: 2009:            temp_normals[i0].x = dy;
    #####: 2010:            temp_normals[i0].y = -dx;
    %%%%%: 2010-block 19
        -: 2011:        }
        -: 2012:
    #####: 2013:        for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)
    %%%%%: 2013-block 21
    %%%%%: 2013-block 27
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 2014:        {
        -: 2015:            // Average normals
    #####: 2016:            const ImVec2& n0 = temp_normals[i0];
    #####: 2017:            const ImVec2& n1 = temp_normals[i1];
    #####: 2018:            float dm_x = (n0.x + n1.x) * 0.5f;
    #####: 2019:            float dm_y = (n0.y + n1.y) * 0.5f;
    #####: 2020:            IM_FIXNORMAL2F(dm_x, dm_y);
    %%%%%: 2020-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2020-block 23
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2020-block 24
    %%%%%: 2020-block 25
    #####: 2021:            dm_x *= AA_SIZE * 0.5f;
    #####: 2022:            dm_y *= AA_SIZE * 0.5f;
        -: 2023:
        -: 2024:            // Add vertices
    #####: 2025:            _VtxWritePtr[0].pos.x = (points[i1].x - dm_x); _VtxWritePtr[0].pos.y = (points[i1].y - dm_y); _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;        // Inner
    #####: 2026:            _VtxWritePtr[1].pos.x = (points[i1].x + dm_x); _VtxWritePtr[1].pos.y = (points[i1].y + dm_y); _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col_trans;  // Outer
    #####: 2027:            _VtxWritePtr += 2;
        -: 2028:
        -: 2029:            // Add indexes for fringes
    #####: 2030:            _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1)); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + (i0 << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1));
    #####: 2031:            _IdxWritePtr[3] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1)); _IdxWritePtr[4] = (ImDrawIdx)(vtx_outer_idx + (i1 << 1)); _IdxWritePtr[5] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1));
    #####: 2032:            _IdxWritePtr += 6;
    %%%%%: 2032-block 26
        -: 2033:        }
    #####: 2034:        _VtxCurrentIdx += (ImDrawIdx)vtx_count;
    %%%%%: 2034-block 28
        -: 2035:    }
        -: 2036:    else
        -: 2037:    {
        -: 2038:        // Non Anti-aliased Fill
    #####: 2039:        const int idx_count = (points_count - 2) * 3;
    #####: 2040:        const int vtx_count = points_count;
    #####: 2041:        PrimReserve(idx_count, vtx_count);
    %%%%%: 2041-block 29
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 2042:        for (int i = 0; i < vtx_count; i++)
    %%%%%: 2042-block 30
    %%%%%: 2042-block 32
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 2043:        {
    #####: 2044:            _VtxWritePtr[0].pos = points[i]; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;
    #####: 2045:            _VtxWritePtr++;
    %%%%%: 2045-block 31
        -: 2046:        }
    #####: 2047:        _Data->TempBuffer.reserve_discard((ImTriangulator::EstimateScratchBufferSize(points_count) + sizeof(ImVec2)) / sizeof(ImVec2));
    %%%%%: 2047-block 33
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####: 2048:        triangulator.Init(points, points_count, _Data->TempBuffer.Data);
    %%%%%: 2048-block 35
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 2049:        while (triangulator._TrianglesLeft > 0)
    %%%%%: 2049-block 36
    %%%%%: 2049-block 39
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 2050:        {
    #####: 2051:            triangulator.GetNextTriangle(triangle);
    %%%%%: 2051-block 37
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 2052:            _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx + triangle[0]); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx + triangle[1]); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx + triangle[2]);
    #####: 2053:            _IdxWritePtr += 3;
    %%%%%: 2053-block 38
        -: 2054:        }
    #####: 2055:        _VtxCurrentIdx += (ImDrawIdx)vtx_count;
    %%%%%: 2055-block 40
        -: 2056:    }
        -: 2057:}
        -: 2058:
        -: 2059://-----------------------------------------------------------------------------
        -: 2060:// [SECTION] ImDrawListSplitter
        -: 2061://-----------------------------------------------------------------------------
        -: 2062:// FIXME: This may be a little confusing, trying to be a little too low-level/optimal instead of just doing vector swap..
        -: 2063://-----------------------------------------------------------------------------
        -: 2064:
function _ZN18ImDrawListSplitter15ClearFreeMemoryEv called 34 returned 100% blocks executed 100%
       34: 2065:void ImDrawListSplitter::ClearFreeMemory()
        -: 2066:{
       43: 2067:    for (int i = 0; i < _Channels.Size; i++)
       34: 2067-block 2
       43: 2067-block 11
branch  0 taken 9
branch  1 taken 34 (fallthrough)
        -: 2068:    {
        9: 2069:        if (i == _Current)
        9: 2069-block 3
branch  0 taken 2 (fallthrough)
branch  1 taken 7
        2: 2070:            memset(&_Channels[i], 0, sizeof(_Channels[i]));  // Current channel is a copy of CmdBuffer/IdxBuffer, don't destruct again
        2: 2070-block 4
call    0 returned 2
        9: 2071:        _Channels[i]._CmdBuffer.clear();
        9: 2071-block 6
call    0 returned 9
call    1 returned 9
        9: 2072:        _Channels[i]._IdxBuffer.clear();
call    0 returned 9
call    1 returned 9
        -: 2073:    }
       34: 2074:    _Current = 0;
       34: 2075:    _Count = 1;
       34: 2076:    _Channels.clear();
       34: 2076-block 12
call    0 returned 34
       34: 2077:}
        -: 2078:
function _ZN18ImDrawListSplitter5SplitEP10ImDrawListi called 2154 returned 100% blocks executed 88%
     2154: 2079:void ImDrawListSplitter::Split(ImDrawList* draw_list, int channels_count)
        -: 2080:{
        -: 2081:    IM_UNUSED(draw_list);
    2154*: 2082:    IM_ASSERT(_Current == 0 && _Count <= 1 && "Nested channel splitting is not supported. Please use separate instances of ImDrawListSplitter.");
     2154: 2082-block 2
branch  0 taken 2154 (fallthrough)
branch  1 taken 0
     2154: 2082-block 3
branch  2 taken 2154 (fallthrough)
branch  3 taken 0
     2154: 2082-block 4
    %%%%%: 2082-block 5
call    4 never executed
     2154: 2083:    int old_channels_count = _Channels.Size;
     2154: 2084:    if (old_channels_count < channels_count)
     2154: 2084-block 6
branch  0 taken 2 (fallthrough)
branch  1 taken 2152
        -: 2085:    {
        2: 2086:        _Channels.reserve(channels_count); // Avoid over reserving since this is likely to stay stable
        2: 2086-block 7
call    0 returned 2
        2: 2087:        _Channels.resize(channels_count);
call    0 returned 2
        -: 2088:    }
     2154: 2089:    _Count = channels_count;
        -: 2090:
        -: 2091:    // Channels[] (24/32 bytes each) hold storage that we'll swap with draw_list->_CmdBuffer/_IdxBuffer
        -: 2092:    // The content of Channels[0] at this point doesn't matter. We clear it to make state tidy in a debugger but we don't strictly need to.
        -: 2093:    // When we switch to the next channel, we'll copy draw_list->_CmdBuffer/_IdxBuffer into Channels[0] and then Channels[1] into draw_list->CmdBuffer/_IdxBuffer
     2154: 2094:    memset(&_Channels[0], 0, sizeof(ImDrawChannel));
     2154: 2094-block 9
call    0 returned 2154
     8617: 2095:    for (int i = 1; i < channels_count; i++)
     6463: 2095-block 20
     8617: 2095-block 21
branch  0 taken 6463
branch  1 taken 2154 (fallthrough)
        -: 2096:    {
     6463: 2097:        if (i >= old_channels_count)
     6463: 2097-block 11
branch  0 taken 7 (fallthrough)
branch  1 taken 6456
        -: 2098:        {
        7: 2099:            IM_PLACEMENT_NEW(&_Channels[i]) ImDrawChannel();
        7: 2099-block 12
call    0 returned 7
call    1 returned 7
call    2 returned 7
branch  3 taken 7 (fallthrough)
branch  4 taken 0 (throw)
        7: 2099-block 15
    $$$$$: 2099-block 23
branch  5 never executed (fallthrough)
branch  6 never executed
    $$$$$: 2099-block 24
call    7 never executed
        -: 2100:        }
        -: 2101:        else
        -: 2102:        {
     6456: 2103:            _Channels[i]._CmdBuffer.resize(0);
     6456: 2103-block 16
call    0 returned 6456
call    1 returned 6456
     6456: 2104:            _Channels[i]._IdxBuffer.resize(0);
call    0 returned 6456
call    1 returned 6456
        -: 2105:        }
        -: 2106:    }
     2154: 2107:}
     2154: 2107-block 22
        -: 2108:
function _ZN18ImDrawListSplitter5MergeEP10ImDrawList called 2154 returned 100% blocks executed 90%
     2154: 2109:void ImDrawListSplitter::Merge(ImDrawList* draw_list)
        -: 2110:{
        -: 2111:    // Note that we never use or rely on _Channels.Size because it is merely a buffer that we never shrink back to 0 to keep all sub-buffers ready for use.
     2154: 2112:    if (_Count <= 1)
     2154: 2112-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 2154
    #####: 2113:        return;
    %%%%%: 2113-block 3
        -: 2114:
     2154: 2115:    SetCurrentChannel(draw_list, 0);
     2154: 2115-block 4
call    0 returned 2154
     2154: 2116:    draw_list->_PopUnusedDrawCmd();
call    0 returned 2154
        -: 2117:
        -: 2118:    // Calculate our final buffer sizes. Also fix the incorrect IdxOffset values in each command.
     2154: 2119:    int new_cmd_buffer_count = 0;
     2154: 2120:    int new_idx_buffer_count = 0;
    2154*: 2121:    ImDrawCmd* last_cmd = (_Count > 0 && draw_list->CmdBuffer.Size > 0) ? &draw_list->CmdBuffer.back() : NULL;
branch  0 taken 2154 (fallthrough)
branch  1 taken 0
     2154: 2121-block 7
branch  2 taken 2154 (fallthrough)
branch  3 taken 0
     2154: 2121-block 8
call    4 returned 2154
    %%%%%: 2121-block 9
    2154*: 2122:    int idx_offset = last_cmd ? last_cmd->IdxOffset + last_cmd->ElemCount : 0;
     2154: 2122-block 10
branch  0 taken 2154 (fallthrough)
branch  1 taken 0
     2154: 2122-block 11
    %%%%%: 2122-block 12
     8617: 2123:    for (int i = 1; i < _Count; i++)
     2154: 2123-block 13
     6463: 2123-block 36
     8617: 2123-block 37
branch  0 taken 6463
branch  1 taken 2154 (fallthrough)
        -: 2124:    {
     6463: 2125:        ImDrawChannel& ch = _Channels[i];
     6463: 2125-block 14
call    0 returned 6463
     6463: 2126:        if (ch._CmdBuffer.Size > 0 && ch._CmdBuffer.back().ElemCount == 0 && ch._CmdBuffer.back().UserCallback == NULL) // Equivalent of PopUnusedDrawCmd()
branch  0 taken 5382 (fallthrough)
branch  1 taken 1081
     5382: 2126-block 16
call    2 returned 5382
branch  3 taken 2 (fallthrough)
branch  4 taken 5380
        2: 2126-block 18
call    5 returned 2
branch  6 taken 2 (fallthrough)
branch  7 taken 0
        2: 2126-block 20
     6461: 2126-block 21
     6463: 2126-block 22
branch  8 taken 2 (fallthrough)
branch  9 taken 6461
        2: 2127:            ch._CmdBuffer.pop_back();
        2: 2127-block 23
call    0 returned 2
        -: 2128:
     6463: 2129:        if (ch._CmdBuffer.Size > 0 && last_cmd != NULL)
     6463: 2129-block 24
branch  0 taken 5380 (fallthrough)
branch  1 taken 1083
     5380: 2129-block 25
branch  2 taken 5380 (fallthrough)
branch  3 taken 0
        -: 2130:        {
        -: 2131:            // Do not include ImDrawCmd_AreSequentialIdxOffset() in the compare as we rebuild IdxOffset values ourselves.
        -: 2132:            // Manipulating IdxOffset (e.g. by reordering draw commands like done by RenderDimmedBackgroundBehindWindow()) is not supported within a splitter.
     5380: 2133:            ImDrawCmd* next_cmd = &ch._CmdBuffer[0];
     5380: 2133-block 26
call    0 returned 5380
     5380: 2134:            if (ImDrawCmd_HeaderCompare(last_cmd, next_cmd) == 0 && last_cmd->UserCallback == NULL && next_cmd->UserCallback == NULL)
branch  0 taken 3228 (fallthrough)
branch  1 taken 2152
     3228: 2134-block 28
branch  2 taken 3228 (fallthrough)
branch  3 taken 0
     3228: 2134-block 29
branch  4 taken 3228 (fallthrough)
branch  5 taken 0
        -: 2135:            {
        -: 2136:                // Merge previous channel last draw command with current channel first draw command if matching.
     3228: 2137:                last_cmd->ElemCount += next_cmd->ElemCount;
     3228: 2138:                idx_offset += next_cmd->ElemCount;
     3228: 2139:                ch._CmdBuffer.erase(ch._CmdBuffer.Data); // FIXME-OPT: Improve for multiple merges.
     3228: 2139-block 30
call    0 returned 3228
        -: 2140:            }
        -: 2141:        }
     6463: 2142:        if (ch._CmdBuffer.Size > 0)
     6463: 2142-block 31
branch  0 taken 2152 (fallthrough)
branch  1 taken 4311
     2152: 2143:            last_cmd = &ch._CmdBuffer.back();
     2152: 2143-block 32
call    0 returned 2152
     6463: 2144:        new_cmd_buffer_count += ch._CmdBuffer.Size;
     6463: 2145:        new_idx_buffer_count += ch._IdxBuffer.Size;
     8615: 2146:        for (int cmd_n = 0; cmd_n < ch._CmdBuffer.Size; cmd_n++)
     6463: 2146-block 33
     8615: 2146-block 35
branch  0 taken 2152
branch  1 taken 6463 (fallthrough)
        -: 2147:        {
     2152: 2148:            ch._CmdBuffer.Data[cmd_n].IdxOffset = idx_offset;
     2152: 2149:            idx_offset += ch._CmdBuffer.Data[cmd_n].ElemCount;
     2152: 2149-block 34
        -: 2150:        }
        -: 2151:    }
     2154: 2152:    draw_list->CmdBuffer.resize(draw_list->CmdBuffer.Size + new_cmd_buffer_count);
     2154: 2152-block 38
call    0 returned 2154
     2154: 2153:    draw_list->IdxBuffer.resize(draw_list->IdxBuffer.Size + new_idx_buffer_count);
call    0 returned 2154
        -: 2154:
        -: 2155:    // Write commands and indices in order (they are fairly small structures, we don't copy vertices only indices)
     2154: 2156:    ImDrawCmd* cmd_write = draw_list->CmdBuffer.Data + draw_list->CmdBuffer.Size - new_cmd_buffer_count;
     2154: 2157:    ImDrawIdx* idx_write = draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size - new_idx_buffer_count;
     8617: 2158:    for (int i = 1; i < _Count; i++)
     6463: 2158-block 46
     8617: 2158-block 47
branch  0 taken 6463
branch  1 taken 2154 (fallthrough)
        -: 2159:    {
     6463: 2160:        ImDrawChannel& ch = _Channels[i];
     6463: 2160-block 41
call    0 returned 6463
     6463: 2161:        if (int sz = ch._CmdBuffer.Size) { memcpy(cmd_write, ch._CmdBuffer.Data, sz * sizeof(ImDrawCmd)); cmd_write += sz; }
branch  0 taken 2152 (fallthrough)
branch  1 taken 4311
     2152: 2161-block 43
     6463: 2162:        if (int sz = ch._IdxBuffer.Size) { memcpy(idx_write, ch._IdxBuffer.Data, sz * sizeof(ImDrawIdx)); idx_write += sz; }
     6463: 2162-block 44
branch  0 taken 5380 (fallthrough)
branch  1 taken 1083
     5380: 2162-block 45
        -: 2163:    }
     2154: 2164:    draw_list->_IdxWritePtr = idx_write;
        -: 2165:
        -: 2166:    // Ensure there's always a non-callback draw command trailing the command-buffer
    2154*: 2167:    if (draw_list->CmdBuffer.Size == 0 || draw_list->CmdBuffer.back().UserCallback != NULL)
     2154: 2167-block 48
branch  0 taken 2154 (fallthrough)
branch  1 taken 0
     2154: 2167-block 49
call    2 returned 2154
branch  3 taken 0 (fallthrough)
branch  4 taken 2154
    %%%%%: 2167-block 51
     2154: 2167-block 52
     2154: 2167-block 53
branch  5 taken 0 (fallthrough)
branch  6 taken 2154
    #####: 2168:        draw_list->AddDrawCmd();
    %%%%%: 2168-block 54
call    0 never executed
        -: 2169:
        -: 2170:    // If current command is used with different settings we need to add a new command
     2154: 2171:    ImDrawCmd* curr_cmd = &draw_list->CmdBuffer.Data[draw_list->CmdBuffer.Size - 1];
     2154: 2172:    if (curr_cmd->ElemCount == 0)
     2154: 2172-block 55
branch  0 taken 0 (fallthrough)
branch  1 taken 2154
    #####: 2173:        ImDrawCmd_HeaderCopy(curr_cmd, &draw_list->_CmdHeader); // Copy ClipRect, TextureId, VtxOffset
    %%%%%: 2173-block 56
     2154: 2174:    else if (ImDrawCmd_HeaderCompare(curr_cmd, &draw_list->_CmdHeader) != 0)
     2154: 2174-block 57
branch  0 taken 1076 (fallthrough)
branch  1 taken 1078
     1076: 2175:        draw_list->AddDrawCmd();
     1076: 2175-block 58
call    0 returned 1076
        -: 2176:
     2154: 2177:    _Count = 1;
     2154: 2177-block 59
        -: 2178:}
        -: 2179:
function _ZN18ImDrawListSplitter17SetCurrentChannelEP10ImDrawListi called 93678 returned 100% blocks executed 88%
    93678: 2180:void ImDrawListSplitter::SetCurrentChannel(ImDrawList* draw_list, int idx)
        -: 2181:{
   93678*: 2182:    IM_ASSERT(idx >= 0 && idx < _Count);
    93678: 2182-block 2
branch  0 taken 93678 (fallthrough)
branch  1 taken 0
    93678: 2182-block 3
branch  2 taken 93678 (fallthrough)
branch  3 taken 0
    93678: 2182-block 4
    %%%%%: 2182-block 5
call    4 never executed
    93678: 2183:    if (_Current == idx)
    93678: 2183-block 6
branch  0 taken 12946 (fallthrough)
branch  1 taken 80732
    12946: 2184:        return;
    12946: 2184-block 7
        -: 2185:
        -: 2186:    // Overwrite ImVector (12/16 bytes), four times. This is merely a silly optimization instead of doing .swap()
    80732: 2187:    memcpy(&_Channels.Data[_Current]._CmdBuffer, &draw_list->CmdBuffer, sizeof(draw_list->CmdBuffer));
    80732: 2188:    memcpy(&_Channels.Data[_Current]._IdxBuffer, &draw_list->IdxBuffer, sizeof(draw_list->IdxBuffer));
    80732: 2189:    _Current = idx;
    80732: 2190:    memcpy(&draw_list->CmdBuffer, &_Channels.Data[idx]._CmdBuffer, sizeof(draw_list->CmdBuffer));
    80732: 2191:    memcpy(&draw_list->IdxBuffer, &_Channels.Data[idx]._IdxBuffer, sizeof(draw_list->IdxBuffer));
    80732: 2192:    draw_list->_IdxWritePtr = draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size;
        -: 2193:
        -: 2194:    // If current command is used with different settings we need to add a new command
    80732: 2195:    ImDrawCmd* curr_cmd = (draw_list->CmdBuffer.Size == 0) ? NULL : &draw_list->CmdBuffer.Data[draw_list->CmdBuffer.Size - 1];
    80732: 2195-block 8
branch  0 taken 75349 (fallthrough)
branch  1 taken 5383
    75349: 2195-block 9
     5383: 2195-block 10
    80732: 2196:    if (curr_cmd == NULL)
    80732: 2196-block 11
branch  0 taken 5383 (fallthrough)
branch  1 taken 75349
     5383: 2197:        draw_list->AddDrawCmd();
     5383: 2197-block 12
call    0 returned 5383
    75349: 2198:    else if (curr_cmd->ElemCount == 0)
    75349: 2198-block 13
branch  0 taken 2179 (fallthrough)
branch  1 taken 73170
     2179: 2199:        ImDrawCmd_HeaderCopy(curr_cmd, &draw_list->_CmdHeader); // Copy ClipRect, TextureId, VtxOffset
     2179: 2199-block 14
    73170: 2200:    else if (ImDrawCmd_HeaderCompare(curr_cmd, &draw_list->_CmdHeader) != 0)
    73170: 2200-block 15
branch  0 taken 0 (fallthrough)
branch  1 taken 73170
    #####: 2201:        draw_list->AddDrawCmd();
    %%%%%: 2201-block 16
call    0 never executed
        -: 2202:}
        -: 2203:
        -: 2204://-----------------------------------------------------------------------------
        -: 2205:// [SECTION] ImDrawData
        -: 2206://-----------------------------------------------------------------------------
        -: 2207:
function _ZN10ImDrawData5ClearEv called 1 returned 100% blocks executed 100%
        1: 2208:void ImDrawData::Clear()
        -: 2209:{
        1: 2210:    Valid = false;
        1: 2211:    CmdListsCount = TotalIdxCount = TotalVtxCount = 0;
        1: 2212:    CmdLists.resize(0); // The ImDrawList are NOT owned by ImDrawData but e.g. by ImGuiContext, so we don't clear them.
        1: 2212-block 2
call    0 returned 1
        1: 2213:    DisplayPos = DisplaySize = FramebufferScale = ImVec2(0.0f, 0.0f);
call    0 returned 1
        1: 2214:    OwnerViewport = NULL;
        1: 2215:}
        -: 2216:
        -: 2217:// Important: 'out_list' is generally going to be draw_data->CmdLists, but may be another temporary list
        -: 2218:// as long at it is expected that the result will be later merged into draw_data->CmdLists[].
function _ZN5ImGui23AddDrawListToDrawDataExEP10ImDrawDataP8ImVectorIP10ImDrawListES4_ called 15271 returned 100% blocks executed 59%
    15271: 2219:void ImGui::AddDrawListToDrawDataEx(ImDrawData* draw_data, ImVector<ImDrawList*>* out_list, ImDrawList* draw_list)
        -: 2220:{
    15271: 2221:    if (draw_list->CmdBuffer.Size == 0)
    15271: 2221-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 15271
    #####: 2222:        return;
    %%%%%: 2222-block 3
    15271: 2223:    if (draw_list->CmdBuffer.Size == 1 && draw_list->CmdBuffer[0].ElemCount == 0 && draw_list->CmdBuffer[0].UserCallback == NULL)
    15271: 2223-block 4
branch  0 taken 3230 (fallthrough)
branch  1 taken 12041
     3230: 2223-block 5
call    2 returned 3230
branch  3 taken 1076 (fallthrough)
branch  4 taken 2154
     1076: 2223-block 7
call    5 returned 1076
branch  6 taken 1076 (fallthrough)
branch  7 taken 0
     1076: 2223-block 9
    14195: 2223-block 10
    15271: 2223-block 11
branch  8 taken 1076 (fallthrough)
branch  9 taken 14195
     1076: 2224:        return;
     1076: 2224-block 12
        -: 2225:
        -: 2226:    // Draw list sanity check. Detect mismatch between PrimReserve() calls and incrementing _VtxCurrentIdx, _VtxWritePtr etc.
        -: 2227:    // May trigger for you if you are using PrimXXX functions incorrectly.
   14195*: 2228:    IM_ASSERT(draw_list->VtxBuffer.Size == 0 || draw_list->_VtxWritePtr == draw_list->VtxBuffer.Data + draw_list->VtxBuffer.Size);
    14195: 2228-block 13
branch  0 taken 14195 (fallthrough)
branch  1 taken 0
    14195: 2228-block 14
branch  2 taken 0 (fallthrough)
branch  3 taken 14195
    %%%%%: 2228-block 15
call    4 never executed
   14195*: 2229:    IM_ASSERT(draw_list->IdxBuffer.Size == 0 || draw_list->_IdxWritePtr == draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size);
    14195: 2229-block 16
branch  0 taken 14195 (fallthrough)
branch  1 taken 0
    14195: 2229-block 17
branch  2 taken 0 (fallthrough)
branch  3 taken 14195
    %%%%%: 2229-block 18
call    4 never executed
    14195: 2230:    if (!(draw_list->Flags & ImDrawListFlags_AllowVtxOffset))
    14195: 2230-block 19
branch  0 taken 0 (fallthrough)
branch  1 taken 14195
    #####: 2231:        IM_ASSERT((int)draw_list->_VtxCurrentIdx == draw_list->VtxBuffer.Size);
    %%%%%: 2231-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2231-block 21
call    2 never executed
        -: 2232:
        -: 2233:    // Check that draw_list doesn't use more vertices than indexable (default ImDrawIdx = unsigned short = 2 bytes = 64K vertices per ImDrawList = per window)
        -: 2234:    // If this assert triggers because you are drawing lots of stuff manually:
        -: 2235:    // - First, make sure you are coarse clipping yourself and not trying to draw many things outside visible bounds.
        -: 2236:    //   Be mindful that the lower-level ImDrawList API doesn't filter vertices. Use the Metrics/Debugger window to inspect draw list contents.
        -: 2237:    // - If you want large meshes with more than 64K vertices, you can either:
        -: 2238:    //   (A) Handle the ImDrawCmd::VtxOffset value in your renderer backend, and set 'io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset'.
        -: 2239:    //       Most example backends already support this from 1.71. Pre-1.71 backends won't.
        -: 2240:    //       Some graphics API such as GL ES 1/2 don't have a way to offset the starting vertex so it is not supported for them.
        -: 2241:    //   (B) Or handle 32-bit indices in your renderer backend, and uncomment '#define ImDrawIdx unsigned int' line in imconfig.h.
        -: 2242:    //       Most example backends already support this. For example, the OpenGL example code detect index size at compile-time:
        -: 2243:    //         glDrawElements(GL_TRIANGLES, (GLsizei)pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer_offset);
        -: 2244:    //       Your own engine or render API may use different parameters or function calls to specify index sizes.
        -: 2245:    //       2 and 4 bytes indices are generally supported by most graphics API.
        -: 2246:    // - If for some reason neither of those solutions works for you, a workaround is to call BeginChild()/EndChild() before reaching
        -: 2247:    //   the 64K limit to split your draw commands in multiple draw lists.
        -: 2248:    if (sizeof(ImDrawIdx) == 2)
   14195*: 2249:        IM_ASSERT(draw_list->_VtxCurrentIdx < (1 << 16) && "Too many vertices in ImDrawList using 16-bit indices. Read comment above");
    14195: 2249-block 22
branch  0 taken 0 (fallthrough)
branch  1 taken 14195
    %%%%%: 2249-block 23
call    2 never executed
        -: 2250:
        -: 2251:    // Resolve callback data pointers
    14195: 2252:    if (draw_list->_CallbacksDataBuf.Size > 0)
    14195: 2252-block 24
branch  0 taken 0 (fallthrough)
branch  1 taken 14195
    #####: 2253:        for (ImDrawCmd& cmd : draw_list->CmdBuffer)
    %%%%%: 2253-block 25
call    0 never executed
call    1 never executed
    %%%%%: 2253-block 31
    %%%%%: 2253-block 32
branch  2 never executed
branch  3 never executed (fallthrough)
    #####: 2254:            if (cmd.UserCallback != NULL && cmd.UserCallbackDataOffset != -1 && cmd.UserCallbackDataSize > 0)
    %%%%%: 2254-block 27
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2254-block 28
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2254-block 29
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 2255:                cmd.UserCallbackData = draw_list->_CallbacksDataBuf.Data + cmd.UserCallbackDataOffset;
    %%%%%: 2255-block 30
        -: 2256:
        -: 2257:    // Add to output list + records state in ImDrawData
    14195: 2258:    out_list->push_back(draw_list);
    14195: 2258-block 33
call    0 returned 14195
    14195: 2259:    draw_data->CmdListsCount++;
    14195: 2260:    draw_data->TotalVtxCount += draw_list->VtxBuffer.Size;
    14195: 2261:    draw_data->TotalIdxCount += draw_list->IdxBuffer.Size;
        -: 2262:}
        -: 2263:
function _ZN10ImDrawData11AddDrawListEP10ImDrawList called 0 returned 0% blocks executed 0%
    #####: 2264:void ImDrawData::AddDrawList(ImDrawList* draw_list)
        -: 2265:{
    #####: 2266:    IM_ASSERT(CmdLists.Size == CmdListsCount);
    %%%%%: 2266-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2266-block 3
call    2 never executed
    #####: 2267:    draw_list->_PopUnusedDrawCmd();
    %%%%%: 2267-block 4
call    0 never executed
    #####: 2268:    ImGui::AddDrawListToDrawDataEx(this, &CmdLists, draw_list);
call    0 never executed
    #####: 2269:}
        -: 2270:
        -: 2271:// For backward compatibility: convert all buffers from indexed to de-indexed, in case you cannot render indexed. Note: this is slow and most likely a waste of resources. Always prefer indexed rendering!
function _ZN10ImDrawData17DeIndexAllBuffersEv called 0 returned 0% blocks executed 0%
    #####: 2272:void ImDrawData::DeIndexAllBuffers()
        -: 2273:{
    #####: 2274:    ImVector<ImDrawVert> new_vtx_buffer;
    %%%%%: 2274-block 2
call    0 never executed
    #####: 2275:    TotalVtxCount = TotalIdxCount = 0;
    #####: 2276:    for (int i = 0; i < CmdListsCount; i++)
    %%%%%: 2276-block 18
    %%%%%: 2276-block 19
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 2277:    {
    #####: 2278:        ImDrawList* cmd_list = CmdLists[i];
    %%%%%: 2278-block 4
call    0 never executed
    #####: 2279:        if (cmd_list->IdxBuffer.empty())
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 2280:            continue;
    %%%%%: 2280-block 7
    #####: 2281:        new_vtx_buffer.resize(cmd_list->IdxBuffer.Size);
    %%%%%: 2281-block 8
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 2282:        for (int j = 0; j < cmd_list->IdxBuffer.Size; j++)
    %%%%%: 2282-block 9
    %%%%%: 2282-block 14
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2283:            new_vtx_buffer[j] = cmd_list->VtxBuffer[cmd_list->IdxBuffer[j]];
    %%%%%: 2283-block 10
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2284:        cmd_list->VtxBuffer.swap(new_vtx_buffer);
    %%%%%: 2284-block 15
call    0 never executed
    #####: 2285:        cmd_list->IdxBuffer.resize(0);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 2286:        TotalVtxCount += cmd_list->VtxBuffer.Size;
    %%%%%: 2286-block 17
        -: 2287:    }
    #####: 2288:}
    %%%%%: 2288-block 20
call    0 never executed
    $$$$$: 2288-block 22
call    1 never executed
        -: 2289:
        -: 2290:// Helper to scale the ClipRect field of each ImDrawCmd.
        -: 2291:// Use if your final output buffer is at a different scale than draw_data->DisplaySize,
        -: 2292:// or if there is a difference between your window resolution and framebuffer resolution.
function _ZN10ImDrawData14ScaleClipRectsERK6ImVec2 called 0 returned 0% blocks executed 0%
    #####: 2293:void ImDrawData::ScaleClipRects(const ImVec2& fb_scale)
        -: 2294:{
    #####: 2295:    for (ImDrawList* draw_list : CmdLists)
    %%%%%: 2295-block 2
call    0 never executed
call    1 never executed
    %%%%%: 2295-block 9
    %%%%%: 2295-block 10
branch  2 never executed
branch  3 never executed (fallthrough)
    #####: 2296:        for (ImDrawCmd& cmd : draw_list->CmdBuffer)
    %%%%%: 2296-block 4
call    0 never executed
call    1 never executed
    %%%%%: 2296-block 8
branch  2 never executed
branch  3 never executed (fallthrough)
    #####: 2297:            cmd.ClipRect = ImVec4(cmd.ClipRect.x * fb_scale.x, cmd.ClipRect.y * fb_scale.y, cmd.ClipRect.z * fb_scale.x, cmd.ClipRect.w * fb_scale.y);
    %%%%%: 2297-block 6
call    0 never executed
    #####: 2298:}
        -: 2299:
        -: 2300://-----------------------------------------------------------------------------
        -: 2301:// [SECTION] Helpers ShadeVertsXXX functions
        -: 2302://-----------------------------------------------------------------------------
        -: 2303:
        -: 2304:// Generic linear color gradient, write to RGB fields, leave A untouched.
function _ZN5ImGui38ShadeVertsLinearColorGradientKeepAlphaEP10ImDrawListii6ImVec2S2_jj called 0 returned 0% blocks executed 0%
    #####: 2305:void ImGui::ShadeVertsLinearColorGradientKeepAlpha(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, ImVec2 gradient_p0, ImVec2 gradient_p1, ImU32 col0, ImU32 col1)
        -: 2306:{
    #####: 2307:    ImVec2 gradient_extent = gradient_p1 - gradient_p0;
    %%%%%: 2307-block 2
call    0 never executed
    #####: 2308:    float gradient_inv_length2 = 1.0f / ImLengthSqr(gradient_extent);
call    0 never executed
    #####: 2309:    ImDrawVert* vert_start = draw_list->VtxBuffer.Data + vert_start_idx;
    #####: 2310:    ImDrawVert* vert_end = draw_list->VtxBuffer.Data + vert_end_idx;
    #####: 2311:    const int col0_r = (int)(col0 >> IM_COL32_R_SHIFT) & 0xFF;
    #####: 2312:    const int col0_g = (int)(col0 >> IM_COL32_G_SHIFT) & 0xFF;
    #####: 2313:    const int col0_b = (int)(col0 >> IM_COL32_B_SHIFT) & 0xFF;
    #####: 2314:    const int col_delta_r = ((int)(col1 >> IM_COL32_R_SHIFT) & 0xFF) - col0_r;
    #####: 2315:    const int col_delta_g = ((int)(col1 >> IM_COL32_G_SHIFT) & 0xFF) - col0_g;
    #####: 2316:    const int col_delta_b = ((int)(col1 >> IM_COL32_B_SHIFT) & 0xFF) - col0_b;
    #####: 2317:    for (ImDrawVert* vert = vert_start; vert < vert_end; vert++)
    %%%%%: 2317-block 9
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 2318:    {
    #####: 2319:        float d = ImDot(vert->pos - gradient_p0, gradient_extent);
    %%%%%: 2319-block 5
call    0 never executed
call    1 never executed
    #####: 2320:        float t = ImClamp(d * gradient_inv_length2, 0.0f, 1.0f);
call    0 never executed
    #####: 2321:        int r = (int)(col0_r + col_delta_r * t);
    #####: 2322:        int g = (int)(col0_g + col_delta_g * t);
    #####: 2323:        int b = (int)(col0_b + col_delta_b * t);
    #####: 2324:        vert->col = (r << IM_COL32_R_SHIFT) | (g << IM_COL32_G_SHIFT) | (b << IM_COL32_B_SHIFT) | (vert->col & IM_COL32_A_MASK);
        -: 2325:    }
    #####: 2326:}
        -: 2327:
        -: 2328:// Distribute UV over (a, b) rectangle
function _ZN5ImGui18ShadeVertsLinearUVEP10ImDrawListiiRK6ImVec2S4_S4_S4_b called 0 returned 0% blocks executed 0%
    #####: 2329:void ImGui::ShadeVertsLinearUV(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, bool clamp)
        -: 2330:{
    #####: 2331:    const ImVec2 size = b - a;
    %%%%%: 2331-block 2
call    0 never executed
    #####: 2332:    const ImVec2 uv_size = uv_b - uv_a;
call    0 never executed
        -: 2333:    const ImVec2 scale = ImVec2(
    #####: 2334:        size.x != 0.0f ? (uv_size.x / size.x) : 0.0f,
    #####: 2335:        size.y != 0.0f ? (uv_size.y / size.y) : 0.0f);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2335-block 5
    %%%%%: 2335-block 6
    %%%%%: 2335-block 7
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2335-block 8
    %%%%%: 2335-block 9
    %%%%%: 2335-block 10
call    4 never executed
        -: 2336:
    #####: 2337:    ImDrawVert* vert_start = draw_list->VtxBuffer.Data + vert_start_idx;
    #####: 2338:    ImDrawVert* vert_end = draw_list->VtxBuffer.Data + vert_end_idx;
    #####: 2339:    if (clamp)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2340:    {
    #####: 2341:        const ImVec2 min = ImMin(uv_a, uv_b);
    %%%%%: 2341-block 12
call    0 never executed
    #####: 2342:        const ImVec2 max = ImMax(uv_a, uv_b);
call    0 never executed
    #####: 2343:        for (ImDrawVert* vertex = vert_start; vertex < vert_end; ++vertex)
    %%%%%: 2343-block 21
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2344:            vertex->uv = ImClamp(uv_a + ImMul(ImVec2(vertex->pos.x, vertex->pos.y) - a, scale), min, max);
    %%%%%: 2344-block 15
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 2345:    }
        -: 2346:    else
        -: 2347:    {
    #####: 2348:        for (ImDrawVert* vertex = vert_start; vertex < vert_end; ++vertex)
    %%%%%: 2348-block 23
    %%%%%: 2348-block 29
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2349:            vertex->uv = uv_a + ImMul(ImVec2(vertex->pos.x, vertex->pos.y) - a, scale);
    %%%%%: 2349-block 24
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2350:    }
    #####: 2351:}
        -: 2352:
function _ZN5ImGui22ShadeVertsTransformPosEP10ImDrawListiiRK6ImVec2ffS4_ called 0 returned 0% blocks executed 0%
    #####: 2353:void ImGui::ShadeVertsTransformPos(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, const ImVec2& pivot_in, float cos_a, float sin_a, const ImVec2& pivot_out)
        -: 2354:{
    #####: 2355:    ImDrawVert* vert_start = draw_list->VtxBuffer.Data + vert_start_idx;
    #####: 2356:    ImDrawVert* vert_end = draw_list->VtxBuffer.Data + vert_end_idx;
    #####: 2357:    for (ImDrawVert* vertex = vert_start; vertex < vert_end; ++vertex)
    %%%%%: 2357-block 2
    %%%%%: 2357-block 7
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2358:        vertex->pos = ImRotate(vertex->pos- pivot_in, cos_a, sin_a) + pivot_out;
    %%%%%: 2358-block 3
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2359:}
        -: 2360:
        -: 2361://-----------------------------------------------------------------------------
        -: 2362:// [SECTION] ImFontConfig
        -: 2363://-----------------------------------------------------------------------------
        -: 2364:
function _ZN12ImFontConfigC2Ev called 11 returned 100% blocks executed 100%
       11: 2365:ImFontConfig::ImFontConfig()
       11: 2365-block 2
call    0 returned 11
call    1 returned 11
        -: 2366:{
       11: 2367:    memset(this, 0, sizeof(*this));
       11: 2368:    FontDataOwnedByAtlas = true;
       11: 2369:    OversampleH = 2;
       11: 2370:    OversampleV = 1;
       11: 2371:    GlyphMaxAdvanceX = FLT_MAX;
       11: 2372:    RasterizerMultiply = 1.0f;
       11: 2373:    RasterizerDensity = 1.0f;
       11: 2374:    EllipsisChar = (ImWchar)-1;
       11: 2375:}
        -: 2376:
        -: 2377://-----------------------------------------------------------------------------
        -: 2378:// [SECTION] ImFontAtlas
        -: 2379://-----------------------------------------------------------------------------
        -: 2380:
        -: 2381:// A work of art lies ahead! (. = white layer, X = black layer, others are blank)
        -: 2382:// The 2x2 white texels on the top left are the ones we'll use everywhere in Dear ImGui to render filled shapes.
        -: 2383:// (This is used when io.MouseDrawCursor = true)
        -: 2384:const int FONT_ATLAS_DEFAULT_TEX_DATA_W = 122; // Actual texture will be 2 times that + 1 spacing.
        -: 2385:const int FONT_ATLAS_DEFAULT_TEX_DATA_H = 27;
        -: 2386:static const char FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS[FONT_ATLAS_DEFAULT_TEX_DATA_W * FONT_ATLAS_DEFAULT_TEX_DATA_H + 1] =
        -: 2387:{
        -: 2388:    "..-         -XXXXXXX-    X    -           X           -XXXXXXX          -          XXXXXXX-     XX          - XX       XX "
        -: 2389:    "..-         -X.....X-   X.X   -          X.X          -X.....X          -          X.....X-    X..X         -X..X     X..X"
        -: 2390:    "---         -XXX.XXX-  X...X  -         X...X         -X....X           -           X....X-    X..X         -X...X   X...X"
        -: 2391:    "X           -  X.X  - X.....X -        X.....X        -X...X            -            X...X-    X..X         - X...X X...X "
        -: 2392:    "XX          -  X.X  -X.......X-       X.......X       -X..X.X           -           X.X..X-    X..X         -  X...X...X  "
        -: 2393:    "X.X         -  X.X  -XXXX.XXXX-       XXXX.XXXX       -X.X X.X          -          X.X X.X-    X..XXX       -   X.....X   "
        -: 2394:    "X..X        -  X.X  -   X.X   -          X.X          -XX   X.X         -         X.X   XX-    X..X..XXX    -    X...X    "
        -: 2395:    "X...X       -  X.X  -   X.X   -    XX    X.X    XX    -      X.X        -        X.X      -    X..X..X..XX  -     X.X     "
        -: 2396:    "X....X      -  X.X  -   X.X   -   X.X    X.X    X.X   -       X.X       -       X.X       -    X..X..X..X.X -    X...X    "
        -: 2397:    "X.....X     -  X.X  -   X.X   -  X..X    X.X    X..X  -        X.X      -      X.X        -XXX X..X..X..X..X-   X.....X   "
        -: 2398:    "X......X    -  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -         X.X   XX-XX   X.X         -X..XX........X..X-  X...X...X  "
        -: 2399:    "X.......X   -  X.X  -   X.X   -X.....................X-          X.X X.X-X.X X.X          -X...X...........X- X...X X...X "
        -: 2400:    "X........X  -  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -           X.X..X-X..X.X           - X..............X-X...X   X...X"
        -: 2401:    "X.........X -XXX.XXX-   X.X   -  X..X    X.X    X..X  -            X...X-X...X            -  X.............X-X..X     X..X"
        -: 2402:    "X..........X-X.....X-   X.X   -   X.X    X.X    X.X   -           X....X-X....X           -  X.............X- XX       XX "
        -: 2403:    "X......XXXXX-XXXXXXX-   X.X   -    XX    X.X    XX    -          X.....X-X.....X          -   X............X--------------"
        -: 2404:    "X...X..X    ---------   X.X   -          X.X          -          XXXXXXX-XXXXXXX          -   X...........X -             "
        -: 2405:    "X..X X..X   -       -XXXX.XXXX-       XXXX.XXXX       -------------------------------------    X..........X -             "
        -: 2406:    "X.X  X..X   -       -X.......X-       X.......X       -    XX           XX    -           -    X..........X -             "
        -: 2407:    "XX    X..X  -       - X.....X -        X.....X        -   X.X           X.X   -           -     X........X  -             "
        -: 2408:    "      X..X  -       -  X...X  -         X...X         -  X..X           X..X  -           -     X........X  -             "
        -: 2409:    "       XX   -       -   X.X   -          X.X          - X...XXXXXXXXXXXXX...X -           -     XXXXXXXXXX  -             "
        -: 2410:    "-------------       -    X    -           X           -X.....................X-           -------------------             "
        -: 2411:    "                    ----------------------------------- X...XXXXXXXXXXXXX...X -                                           "
        -: 2412:    "                                                      -  X..X           X..X  -                                           "
        -: 2413:    "                                                      -   X.X           X.X   -                                           "
        -: 2414:    "                                                      -    XX           XX    -                                           "
        -: 2415:};
        -: 2416:
        -: 2417:static const ImVec2 FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[ImGuiMouseCursor_COUNT][3] =
        -: 2418:{
        -: 2419:    // Pos ........ Size ......... Offset ......
        -: 2420:    { ImVec2( 0,3), ImVec2(12,19), ImVec2( 0, 0) }, // ImGuiMouseCursor_Arrow
        -: 2421:    { ImVec2(13,0), ImVec2( 7,16), ImVec2( 1, 8) }, // ImGuiMouseCursor_TextInput
        -: 2422:    { ImVec2(31,0), ImVec2(23,23), ImVec2(11,11) }, // ImGuiMouseCursor_ResizeAll
        -: 2423:    { ImVec2(21,0), ImVec2( 9,23), ImVec2( 4,11) }, // ImGuiMouseCursor_ResizeNS
        -: 2424:    { ImVec2(55,18),ImVec2(23, 9), ImVec2(11, 4) }, // ImGuiMouseCursor_ResizeEW
        -: 2425:    { ImVec2(73,0), ImVec2(17,17), ImVec2( 8, 8) }, // ImGuiMouseCursor_ResizeNESW
        -: 2426:    { ImVec2(55,0), ImVec2(17,17), ImVec2( 8, 8) }, // ImGuiMouseCursor_ResizeNWSE
        -: 2427:    { ImVec2(91,0), ImVec2(17,22), ImVec2( 5, 0) }, // ImGuiMouseCursor_Hand
        -: 2428:    { ImVec2(109,0),ImVec2(13,15), ImVec2( 6, 7) }, // ImGuiMouseCursor_NotAllowed
        -: 2429:};
        -: 2430:
function _ZN11ImFontAtlasC2Ev called 1 returned 100% blocks executed 100%
        1: 2431:ImFontAtlas::ImFontAtlas()
        1: 2431-block 2
call    0 returned 1
call    1 returned 1
call    2 returned 1
call    3 returned 1
call    4 returned 1
        -: 2432:{
        1: 2433:    memset(this, 0, sizeof(*this));
        1: 2434:    TexGlyphPadding = 1;
        1: 2435:    PackIdMouseCursors = PackIdLines = -1;
        1: 2436:}
        -: 2437:
function _ZN11ImFontAtlasD2Ev called 1 returned 100% blocks executed 86%
        1: 2438:ImFontAtlas::~ImFontAtlas()
        -: 2439:{
       1*: 2440:    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
        1: 2440-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 2440-block 3
call    2 never executed
        1: 2441:    Clear();
        1: 2441-block 4
call    0 returned 1
        1: 2442:}
call    0 returned 1
call    1 returned 1
call    2 returned 1
        -: 2443:
function _ZN11ImFontAtlas14ClearInputDataEv called 1 returned 100% blocks executed 95%
        1: 2444:void    ImFontAtlas::ClearInputData()
        -: 2445:{
       1*: 2446:    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
        1: 2446-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 2446-block 3
call    2 never executed
       12: 2447:    for (ImFontConfig& font_cfg : ConfigData)
        1: 2447-block 4
call    0 returned 1
call    1 returned 1
       11: 2447-block 10
       12: 2447-block 11
branch  2 taken 11
branch  3 taken 1 (fallthrough)
       11: 2448:        if (font_cfg.FontData && font_cfg.FontDataOwnedByAtlas)
       11: 2448-block 6
branch  0 taken 11 (fallthrough)
branch  1 taken 0
       11: 2448-block 7
branch  2 taken 11 (fallthrough)
branch  3 taken 0
        -: 2449:        {
       11: 2450:            IM_FREE(font_cfg.FontData);
       11: 2450-block 8
call    0 returned 11
       11: 2451:            font_cfg.FontData = NULL;
        -: 2452:        }
        -: 2453:
        -: 2454:    // When clearing this we lose access to the font name and other information used to build the font.
       11: 2455:    for (ImFont* font : Fonts)
        1: 2455-block 12
call    0 returned 1
call    1 returned 1
       10: 2455-block 17
       11: 2455-block 18
branch  2 taken 10
branch  3 taken 1 (fallthrough)
       10: 2456:        if (font->ConfigData >= ConfigData.Data && font->ConfigData < ConfigData.Data + ConfigData.Size)
       10: 2456-block 14
branch  0 taken 10 (fallthrough)
branch  1 taken 0
       10: 2456-block 15
branch  2 taken 10 (fallthrough)
branch  3 taken 0
        -: 2457:        {
       10: 2458:            font->ConfigData = NULL;
       10: 2459:            font->ConfigDataCount = 0;
       10: 2459-block 16
        -: 2460:        }
        1: 2461:    ConfigData.clear();
        1: 2461-block 19
call    0 returned 1
        1: 2462:    CustomRects.clear();
call    0 returned 1
        1: 2463:    PackIdMouseCursors = PackIdLines = -1;
        -: 2464:    // Important: we leave TexReady untouched
        1: 2465:}
        -: 2466:
function _ZN11ImFontAtlas12ClearTexDataEv called 13 returned 100% blocks executed 86%
       13: 2467:void    ImFontAtlas::ClearTexData()
        -: 2468:{
      13*: 2469:    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
       13: 2469-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 13
    %%%%%: 2469-block 3
call    2 never executed
       13: 2470:    if (TexPixelsAlpha8)
       13: 2470-block 4
branch  0 taken 1 (fallthrough)
branch  1 taken 12
        1: 2471:        IM_FREE(TexPixelsAlpha8);
        1: 2471-block 5
call    0 returned 1
       13: 2472:    if (TexPixelsRGBA32)
       13: 2472-block 6
branch  0 taken 1 (fallthrough)
branch  1 taken 12
        1: 2473:        IM_FREE(TexPixelsRGBA32);
        1: 2473-block 7
call    0 returned 1
       13: 2474:    TexPixelsAlpha8 = NULL;
       13: 2475:    TexPixelsRGBA32 = NULL;
       13: 2476:    TexPixelsUseColors = false;
        -: 2477:    // Important: we leave TexReady untouched
       13: 2478:}
        -: 2479:
function _ZN11ImFontAtlas10ClearFontsEv called 1 returned 100% blocks executed 75%
        1: 2480:void    ImFontAtlas::ClearFonts()
        -: 2481:{
       1*: 2482:    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
        1: 2482-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 2482-block 3
call    2 never executed
        1: 2483:    Fonts.clear_delete();
        1: 2483-block 4
call    0 returned 1
        1: 2484:    TexReady = false;
        1: 2485:}
        -: 2486:
function _ZN11ImFontAtlas5ClearEv called 1 returned 100% blocks executed 100%
        1: 2487:void    ImFontAtlas::Clear()
        -: 2488:{
        1: 2489:    ClearInputData();
        1: 2489-block 2
call    0 returned 1
        1: 2490:    ClearTexData();
call    0 returned 1
        1: 2491:    ClearFonts();
call    0 returned 1
        1: 2492:}
        -: 2493:
function _ZN11ImFontAtlas18GetTexDataAsAlpha8EPPhPiS2_S2_ called 1 returned 100% blocks executed 67%
        1: 2494:void    ImFontAtlas::GetTexDataAsAlpha8(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)
        -: 2495:{
        -: 2496:    // Build atlas on demand
        1: 2497:    if (TexPixelsAlpha8 == NULL)
        1: 2497-block 2
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 2498:        Build();
        1: 2498-block 3
call    0 returned 1
        -: 2499:
        1: 2500:    *out_pixels = TexPixelsAlpha8;
       1*: 2501:    if (out_width) *out_width = TexWidth;
        1: 2501-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 2501-block 5
       1*: 2502:    if (out_height) *out_height = TexHeight;
        1: 2502-block 6
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 2502-block 7
       1*: 2503:    if (out_bytes_per_pixel) *out_bytes_per_pixel = 1;
        1: 2503-block 8
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 2503-block 9
        1: 2504:}
        -: 2505:
function _ZN11ImFontAtlas18GetTexDataAsRGBA32EPPhPiS2_S2_ called 1 returned 100% blocks executed 94%
        1: 2506:void    ImFontAtlas::GetTexDataAsRGBA32(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)
        -: 2507:{
        -: 2508:    // Convert to RGBA32 format on demand
        -: 2509:    // Although it is likely to be the most commonly used format, our font rendering is 1 channel / 8 bpp
        1: 2510:    if (!TexPixelsRGBA32)
        1: 2510-block 2
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 2511:    {
        1: 2512:        unsigned char* pixels = NULL;
        1: 2513:        GetTexDataAsAlpha8(&pixels, NULL, NULL);
        1: 2513-block 3
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 2514:        if (pixels)
        1: 2514-block 4
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 2515:        {
        1: 2516:            TexPixelsRGBA32 = (unsigned int*)IM_ALLOC((size_t)TexWidth * (size_t)TexHeight * 4);
        1: 2516-block 5
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 2517:            const unsigned char* src = pixels;
        1: 2518:            unsigned int* dst = TexPixelsRGBA32;
  1048577: 2519:            for (int n = TexWidth * TexHeight; n > 0; n--)
        1: 2519-block 6
  1048577: 2519-block 8
branch  0 taken 1048576
branch  1 taken 1 (fallthrough)
  1048576: 2520:                *dst++ = IM_COL32(255, 255, 255, (unsigned int)(*src++));
  1048576: 2520-block 7
        -: 2521:        }
        -: 2522:    }
        -: 2523:
        1: 2524:    *out_pixels = (unsigned char*)TexPixelsRGBA32;
        1: 2525:    if (out_width) *out_width = TexWidth;
        1: 2525-block 10
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 2525-block 11
        1: 2526:    if (out_height) *out_height = TexHeight;
        1: 2526-block 12
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 2526-block 13
       1*: 2527:    if (out_bytes_per_pixel) *out_bytes_per_pixel = 4;
        1: 2527-block 14
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 2527-block 15
        1: 2528:}
        1: 2528-block 16
        -: 2529:
function _ZN11ImFontAtlas7AddFontEPK12ImFontConfig called 11 returned 100% blocks executed 74%
       11: 2530:ImFont* ImFontAtlas::AddFont(const ImFontConfig* font_cfg)
        -: 2531:{
      11*: 2532:    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
       11: 2532-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 11
    %%%%%: 2532-block 3
call    2 never executed
      11*: 2533:    IM_ASSERT(font_cfg->FontData != NULL && font_cfg->FontDataSize > 0);
       11: 2533-block 4
branch  0 taken 11 (fallthrough)
branch  1 taken 0
       11: 2533-block 5
branch  2 taken 11 (fallthrough)
branch  3 taken 0
       11: 2533-block 6
    %%%%%: 2533-block 7
call    4 never executed
      11*: 2534:    IM_ASSERT(font_cfg->SizePixels > 0.0f && "Is ImFontConfig struct correctly initialized?");
       11: 2534-block 8
branch  0 taken 0 (fallthrough)
branch  1 taken 11
    %%%%%: 2534-block 9
call    2 never executed
      11*: 2535:    IM_ASSERT(font_cfg->OversampleH > 0 && font_cfg->OversampleV > 0 && "Is ImFontConfig struct correctly initialized?");
       11: 2535-block 10
branch  0 taken 11 (fallthrough)
branch  1 taken 0
       11: 2535-block 11
branch  2 taken 11 (fallthrough)
branch  3 taken 0
       11: 2535-block 12
    %%%%%: 2535-block 13
call    4 never executed
        -: 2536:
        -: 2537:    // Create new font
       11: 2538:    if (!font_cfg->MergeMode)
       11: 2538-block 14
branch  0 taken 10 (fallthrough)
branch  1 taken 1
       10: 2539:        Fonts.push_back(IM_NEW(ImFont));
       10: 2539-block 15
call    0 returned 10
branch  1 taken 10 (fallthrough)
branch  2 taken 0 (throw)
       10: 2539-block 16
call    3 returned 10
call    4 returned 10
branch  5 taken 10 (fallthrough)
branch  6 taken 0 (throw)
       10: 2539-block 18
call    7 returned 10
branch  8 taken 10 (fallthrough)
branch  9 taken 0 (throw)
       10: 2539-block 19
    $$$$$: 2539-block 36
branch 10 never executed (fallthrough)
branch 11 never executed
    $$$$$: 2539-block 37
call   12 never executed
        -: 2540:    else
       1*: 2541:        IM_ASSERT(Fonts.Size > 0 && "Cannot use MergeMode for the first font"); // When using MergeMode make sure that a font has already been added before. You can use ImGui::GetIO().Fonts->AddFontDefault() to add the default imgui font.
        1: 2541-block 20
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 2541-block 21
call    2 never executed
        -: 2542:
       11: 2543:    ConfigData.push_back(*font_cfg);
       11: 2543-block 22
call    0 returned 11
       11: 2544:    ImFontConfig& new_font_cfg = ConfigData.back();
call    0 returned 11
       11: 2545:    if (new_font_cfg.DstFont == NULL)
branch  0 taken 11 (fallthrough)
branch  1 taken 0
       11: 2546:        new_font_cfg.DstFont = Fonts.back();
       11: 2546-block 25
call    0 returned 11
       11: 2547:    if (!new_font_cfg.FontDataOwnedByAtlas)
       11: 2547-block 27
branch  0 taken 0 (fallthrough)
branch  1 taken 11
        -: 2548:    {
    #####: 2549:        new_font_cfg.FontData = IM_ALLOC(new_font_cfg.FontDataSize);
    %%%%%: 2549-block 28
call    0 never executed
    #####: 2550:        new_font_cfg.FontDataOwnedByAtlas = true;
    #####: 2551:        memcpy(new_font_cfg.FontData, font_cfg->FontData, (size_t)new_font_cfg.FontDataSize);
        -: 2552:    }
        -: 2553:
       11: 2554:    if (new_font_cfg.DstFont->EllipsisChar == (ImWchar)-1)
       11: 2554-block 30
branch  0 taken 11 (fallthrough)
branch  1 taken 0
       11: 2555:        new_font_cfg.DstFont->EllipsisChar = font_cfg->EllipsisChar;
       11: 2555-block 31
        -: 2556:
       11: 2557:    ImFontAtlasUpdateConfigDataPointers(this);
       11: 2557-block 32
call    0 returned 11
        -: 2558:
        -: 2559:    // Invalidate texture
       11: 2560:    TexReady = false;
       11: 2561:    ClearTexData();
call    0 returned 11
       11: 2562:    return new_font_cfg.DstFont;
       11: 2562-block 35
        -: 2563:}
        -: 2564:
        -: 2565:// Default font TTF is compressed with stb_compress then base85 encoded (see misc/fonts/binary_to_compressed_c.cpp for encoder)
        -: 2566:static unsigned int stb_decompress_length(const unsigned char* input);
        -: 2567:static unsigned int stb_decompress(unsigned char* output, const unsigned char* input, unsigned int length);
        -: 2568:static const char*  GetDefaultCompressedFontDataTTFBase85();
function _ZL12Decode85Bytec called 11980 returned 100% blocks executed 100%
    11980: 2569:static unsigned int Decode85Byte(char c)                                    { return c >= '\\' ? c-36 : c-35; }
    11980: 2569-block 2
branch  0 taken 3280 (fallthrough)
branch  1 taken 8700
     3280: 2569-block 3
     8700: 2569-block 4
    11980: 2569-block 5
function _ZL8Decode85PKhPh called 1 returned 100% blocks executed 100%
        1: 2570:static void         Decode85(const unsigned char* src, unsigned char* dst)
        -: 2571:{
     2397: 2572:    while (*src)
        1: 2572-block 2
     2397: 2572-block 9
branch  0 taken 2396
branch  1 taken 1 (fallthrough)
        -: 2573:    {
     2396: 2574:        unsigned int tmp = Decode85Byte(src[0]) + 85 * (Decode85Byte(src[1]) + 85 * (Decode85Byte(src[2]) + 85 * (Decode85Byte(src[3]) + 85 * Decode85Byte(src[4]))));
     2396: 2574-block 3
call    0 returned 2396
call    1 returned 2396
call    2 returned 2396
call    3 returned 2396
call    4 returned 2396
     2396: 2575:        dst[0] = ((tmp >> 0) & 0xFF); dst[1] = ((tmp >> 8) & 0xFF); dst[2] = ((tmp >> 16) & 0xFF); dst[3] = ((tmp >> 24) & 0xFF);   // We can't assume little-endianness.
     2396: 2576:        src += 5;
     2396: 2577:        dst += 4;
        -: 2578:    }
        1: 2579:}
        -: 2580:
        -: 2581:// Load embedded ProggyClean.ttf at size 13, disable oversampling
function _ZN11ImFontAtlas14AddFontDefaultEPK12ImFontConfig called 1 returned 100% blocks executed 88%
        1: 2582:ImFont* ImFontAtlas::AddFontDefault(const ImFontConfig* font_cfg_template)
        -: 2583:{
       1*: 2584:    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
        1: 2584-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 2584-block 3
        1: 2584-block 4
call    2 returned 1
        1: 2585:    if (!font_cfg_template)
        1: 2585-block 5
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 2586:    {
        1: 2587:        font_cfg.OversampleH = font_cfg.OversampleV = 1;
        1: 2588:        font_cfg.PixelSnapH = true;
        1: 2588-block 6
        -: 2589:    }
        1: 2590:    if (font_cfg.SizePixels <= 0.0f)
        1: 2590-block 7
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 2591:        font_cfg.SizePixels = 13.0f * 1.0f;
        1: 2591-block 8
        1: 2592:    if (font_cfg.Name[0] == '\0')
        1: 2592-block 9
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 2593:        ImFormatString(font_cfg.Name, IM_ARRAYSIZE(font_cfg.Name), "ProggyClean.ttf, %dpx", (int)font_cfg.SizePixels);
        1: 2593-block 10
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 2594:    font_cfg.EllipsisChar = (ImWchar)0x0085;
        1: 2595:    font_cfg.GlyphOffset.y = 1.0f * IM_TRUNC(font_cfg.SizePixels / 13.0f);  // Add +1 offset per 13 units
        -: 2596:
        1: 2597:    const char* ttf_compressed_base85 = GetDefaultCompressedFontDataTTFBase85();
        1: 2597-block 11
call    0 returned 1
       1*: 2598:    const ImWchar* glyph_ranges = font_cfg.GlyphRanges != NULL ? font_cfg.GlyphRanges : GetGlyphRangesDefault();
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 2598-block 13
        1: 2598-block 14
call    2 returned 1
        1: 2599:    ImFont* font = AddFontFromMemoryCompressedBase85TTF(ttf_compressed_base85, font_cfg.SizePixels, &font_cfg, glyph_ranges);
        1: 2599-block 15
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 2600:    return font;
        1: 2600-block 16
        1: 2600-block 17
        -: 2601:}
        -: 2602:
function _ZN11ImFontAtlas18AddFontFromFileTTFEPKcfPK12ImFontConfigPKt called 10 returned 100% blocks executed 78%
       10: 2603:ImFont* ImFontAtlas::AddFontFromFileTTF(const char* filename, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)
        -: 2604:{
      10*: 2605:    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
       10: 2605-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 10
    %%%%%: 2605-block 3
call    2 never executed
       10: 2606:    size_t data_size = 0;
       10: 2607:    void* data = ImFileLoadToMemory(filename, "rb", &data_size, 0);
       10: 2607-block 4
call    0 returned 10
branch  1 taken 10 (fallthrough)
branch  2 taken 0 (throw)
       10: 2608:    if (!data)
       10: 2608-block 5
branch  0 taken 0 (fallthrough)
branch  1 taken 10
        -: 2609:    {
    #####: 2610:        IM_ASSERT_USER_ERROR(0, "Could not load font file!");
    %%%%%: 2610-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 2610-block 7
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 2610-block 8
call    5 never executed
    #####: 2611:        return NULL;
    %%%%%: 2611-block 9
        -: 2612:    }
       10: 2613:    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
       10: 2613-block 10
branch  0 taken 1 (fallthrough)
branch  1 taken 9
        1: 2613-block 11
        9: 2613-block 12
call    2 returned 9
       10: 2614:    if (font_cfg.Name[0] == '\0')
       10: 2614-block 13
branch  0 taken 10 (fallthrough)
branch  1 taken 0
        -: 2615:    {
        -: 2616:        // Store a short copy of filename into into the font name for convenience
        -: 2617:        const char* p;
      181: 2618:        for (p = filename + strlen(filename); p > filename && p[-1] != '/' && p[-1] != '\\'; p--) {}
       10: 2618-block 14
      171: 2618-block 15
      181: 2618-block 16
branch  0 taken 181 (fallthrough)
branch  1 taken 0
      181: 2618-block 17
branch  2 taken 171 (fallthrough)
branch  3 taken 10
      171: 2618-block 18
branch  4 taken 171
branch  5 taken 0 (fallthrough)
       10: 2619:        ImFormatString(font_cfg.Name, IM_ARRAYSIZE(font_cfg.Name), "%s, %.0fpx", p, size_pixels);
       10: 2619-block 19
call    0 returned 10
branch  1 taken 10 (fallthrough)
branch  2 taken 0 (throw)
        -: 2620:    }
       10: 2621:    return AddFontFromMemoryTTF(data, (int)data_size, size_pixels, &font_cfg, glyph_ranges);
       10: 2621-block 20
call    0 returned 10
branch  1 taken 10 (fallthrough)
branch  2 taken 0 (throw)
       10: 2621-block 21
        -: 2622:}
        -: 2623:
        -: 2624:// NB: Transfer ownership of 'ttf_data' to ImFontAtlas, unless font_cfg_template->FontDataOwnedByAtlas == false. Owned TTF buffer will be deleted after Build().
function _ZN11ImFontAtlas20AddFontFromMemoryTTFEPvifPK12ImFontConfigPKt called 11 returned 100% blocks executed 74%
       11: 2625:ImFont* ImFontAtlas::AddFontFromMemoryTTF(void* font_data, int font_data_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)
        -: 2626:{
      11*: 2627:    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
       11: 2627-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 11
    %%%%%: 2627-block 3
call    2 never executed
      11*: 2628:    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
       11: 2628-block 4
branch  0 taken 11 (fallthrough)
branch  1 taken 0
       11: 2628-block 5
    %%%%%: 2628-block 6
call    2 never executed
      11*: 2629:    IM_ASSERT(font_cfg.FontData == NULL);
       11: 2629-block 7
branch  0 taken 0 (fallthrough)
branch  1 taken 11
    %%%%%: 2629-block 8
call    2 never executed
      11*: 2630:    IM_ASSERT(font_data_size > 100 && "Incorrect value for font_data_size!"); // Heuristic to prevent accidentally passing a wrong value to font_data_size.
       11: 2630-block 9
branch  0 taken 0 (fallthrough)
branch  1 taken 11
    %%%%%: 2630-block 10
call    2 never executed
       11: 2631:    font_cfg.FontData = font_data;
       11: 2632:    font_cfg.FontDataSize = font_data_size;
      11*: 2633:    font_cfg.SizePixels = size_pixels > 0.0f ? size_pixels : font_cfg.SizePixels;
       11: 2633-block 11
branch  0 taken 11 (fallthrough)
branch  1 taken 0
       11: 2633-block 12
    %%%%%: 2633-block 13
       11: 2634:    if (glyph_ranges)
       11: 2634-block 14
branch  0 taken 2 (fallthrough)
branch  1 taken 9
        2: 2635:        font_cfg.GlyphRanges = glyph_ranges;
        2: 2635-block 15
       22: 2636:    return AddFont(&font_cfg);
       11: 2636-block 16
call    0 returned 11
branch  1 taken 11 (fallthrough)
branch  2 taken 0 (throw)
       11: 2636-block 17
       11: 2636-block 19
        -: 2637:}
        -: 2638:
function _ZN11ImFontAtlas30AddFontFromMemoryCompressedTTFEPKvifPK12ImFontConfigPKt called 1 returned 100% blocks executed 85%
        1: 2639:ImFont* ImFontAtlas::AddFontFromMemoryCompressedTTF(const void* compressed_ttf_data, int compressed_ttf_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)
        -: 2640:{
        1: 2641:    const unsigned int buf_decompressed_size = stb_decompress_length((const unsigned char*)compressed_ttf_data);
        1: 2641-block 2
call    0 returned 1
        1: 2642:    unsigned char* buf_decompressed_data = (unsigned char*)IM_ALLOC(buf_decompressed_size);
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 2643:    stb_decompress(buf_decompressed_data, (const unsigned char*)compressed_ttf_data, (unsigned int)compressed_ttf_size);
        1: 2643-block 4
call    0 returned 1
        -: 2644:
       1*: 2645:    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 2645-block 6
    %%%%%: 2645-block 7
call    2 never executed
       1*: 2646:    IM_ASSERT(font_cfg.FontData == NULL);
        1: 2646-block 8
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 2646-block 9
call    2 never executed
        1: 2647:    font_cfg.FontDataOwnedByAtlas = true;
        2: 2648:    return AddFontFromMemoryTTF(buf_decompressed_data, (int)buf_decompressed_size, size_pixels, &font_cfg, glyph_ranges);
        1: 2648-block 10
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 2648-block 11
        1: 2648-block 13
        -: 2649:}
        -: 2650:
function _ZN11ImFontAtlas36AddFontFromMemoryCompressedBase85TTFEPKcfPK12ImFontConfigPKt called 1 returned 100% blocks executed 100%
        1: 2651:ImFont* ImFontAtlas::AddFontFromMemoryCompressedBase85TTF(const char* compressed_ttf_data_base85, float size_pixels, const ImFontConfig* font_cfg, const ImWchar* glyph_ranges)
        -: 2652:{
        1: 2653:    int compressed_ttf_size = (((int)strlen(compressed_ttf_data_base85) + 4) / 5) * 4;
        1: 2654:    void* compressed_ttf = IM_ALLOC((size_t)compressed_ttf_size);
        1: 2654-block 2
call    0 returned 1
        1: 2655:    Decode85((const unsigned char*)compressed_ttf_data_base85, (unsigned char*)compressed_ttf);
call    0 returned 1
        1: 2656:    ImFont* font = AddFontFromMemoryCompressedTTF(compressed_ttf, compressed_ttf_size, size_pixels, font_cfg, glyph_ranges);
call    0 returned 1
        1: 2657:    IM_FREE(compressed_ttf);
call    0 returned 1
        1: 2658:    return font;
        -: 2659:}
        -: 2660:
function _ZN11ImFontAtlas20AddCustomRectRegularEii called 2 returned 100% blocks executed 85%
        2: 2661:int ImFontAtlas::AddCustomRectRegular(int width, int height)
        -: 2662:{
       2*: 2663:    IM_ASSERT(width > 0 && width <= 0xFFFF);
        2: 2663-block 2
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2: 2663-block 3
branch  2 taken 2 (fallthrough)
branch  3 taken 0
        2: 2663-block 4
    %%%%%: 2663-block 5
call    4 never executed
       2*: 2664:    IM_ASSERT(height > 0 && height <= 0xFFFF);
        2: 2664-block 6
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2: 2664-block 7
branch  2 taken 2 (fallthrough)
branch  3 taken 0
        2: 2664-block 8
    %%%%%: 2664-block 9
call    4 never executed
        2: 2665:    ImFontAtlasCustomRect r;
        2: 2665-block 10
call    0 returned 2
        2: 2666:    r.Width = (unsigned short)width;
        2: 2667:    r.Height = (unsigned short)height;
        2: 2668:    CustomRects.push_back(r);
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        2: 2669:    return CustomRects.Size - 1; // Return index
        2: 2669-block 12
        2: 2669-block 13
        -: 2670:}
        -: 2671:
function _ZN11ImFontAtlas22AddCustomRectFontGlyphEP6ImFonttiifRK6ImVec2 called 0 returned 0% blocks executed 0%
    #####: 2672:int ImFontAtlas::AddCustomRectFontGlyph(ImFont* font, ImWchar id, int width, int height, float advance_x, const ImVec2& offset)
        -: 2673:{
        -: 2674:#ifdef IMGUI_USE_WCHAR32
        -: 2675:    IM_ASSERT(id <= IM_UNICODE_CODEPOINT_MAX);
        -: 2676:#endif
    #####: 2677:    IM_ASSERT(font != NULL);
    %%%%%: 2677-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2677-block 3
call    2 never executed
    #####: 2678:    IM_ASSERT(width > 0 && width <= 0xFFFF);
    %%%%%: 2678-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2678-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2678-block 6
    %%%%%: 2678-block 7
call    4 never executed
    #####: 2679:    IM_ASSERT(height > 0 && height <= 0xFFFF);
    %%%%%: 2679-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2679-block 9
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2679-block 10
    %%%%%: 2679-block 11
call    4 never executed
    #####: 2680:    ImFontAtlasCustomRect r;
    %%%%%: 2680-block 12
call    0 never executed
    #####: 2681:    r.Width = (unsigned short)width;
    #####: 2682:    r.Height = (unsigned short)height;
    #####: 2683:    r.GlyphID = id;
    #####: 2684:    r.GlyphAdvanceX = advance_x;
    #####: 2685:    r.GlyphOffset = offset;
    #####: 2686:    r.Font = font;
    #####: 2687:    CustomRects.push_back(r);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 2688:    return CustomRects.Size - 1; // Return index
    %%%%%: 2688-block 14
    %%%%%: 2688-block 15
        -: 2689:}
        -: 2690:
function _ZNK11ImFontAtlas16CalcCustomRectUVEPK21ImFontAtlasCustomRectP6ImVec2S4_ called 0 returned 0% blocks executed 0%
    #####: 2691:void ImFontAtlas::CalcCustomRectUV(const ImFontAtlasCustomRect* rect, ImVec2* out_uv_min, ImVec2* out_uv_max) const
        -: 2692:{
    #####: 2693:    IM_ASSERT(TexWidth > 0 && TexHeight > 0);   // Font atlas needs to be built before we can calculate UV coordinates
    %%%%%: 2693-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2693-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 2693-block 4
    %%%%%: 2693-block 5
call    4 never executed
    #####: 2694:    IM_ASSERT(rect->IsPacked());                // Make sure the rectangle has been packed
    %%%%%: 2694-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    %%%%%: 2694-block 8
call    3 never executed
    #####: 2695:    *out_uv_min = ImVec2((float)rect->X * TexUvScale.x, (float)rect->Y * TexUvScale.y);
    %%%%%: 2695-block 9
call    0 never executed
    #####: 2696:    *out_uv_max = ImVec2((float)(rect->X + rect->Width) * TexUvScale.x, (float)(rect->Y + rect->Height) * TexUvScale.y);
call    0 never executed
    #####: 2697:}
        -: 2698:
function _ZN11ImFontAtlas21GetMouseCursorTexDataEiP6ImVec2S1_S1_S1_ called 0 returned 0% blocks executed 0%
    #####: 2699:bool ImFontAtlas::GetMouseCursorTexData(ImGuiMouseCursor cursor_type, ImVec2* out_offset, ImVec2* out_size, ImVec2 out_uv_border[2], ImVec2 out_uv_fill[2])
        -: 2700:{
    #####: 2701:    if (cursor_type <= ImGuiMouseCursor_None || cursor_type >= ImGuiMouseCursor_COUNT)
    %%%%%: 2701-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2701-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2702:        return false;
    %%%%%: 2702-block 4
    #####: 2703:    if (Flags & ImFontAtlasFlags_NoMouseCursors)
    %%%%%: 2703-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2704:        return false;
    %%%%%: 2704-block 6
        -: 2705:
    #####: 2706:    IM_ASSERT(PackIdMouseCursors != -1);
    %%%%%: 2706-block 7
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2706-block 8
call    2 never executed
    #####: 2707:    ImFontAtlasCustomRect* r = GetCustomRectByIndex(PackIdMouseCursors);
    %%%%%: 2707-block 9
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 2708:    ImVec2 pos = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][0] + ImVec2((float)r->X, (float)r->Y);
    %%%%%: 2708-block 10
call    0 never executed
call    1 never executed
    #####: 2709:    ImVec2 size = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][1];
    #####: 2710:    *out_size = size;
    #####: 2711:    *out_offset = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][2];
    #####: 2712:    out_uv_border[0] = (pos) * TexUvScale;
call    0 never executed
    #####: 2713:    out_uv_border[1] = (pos + size) * TexUvScale;
call    0 never executed
call    1 never executed
    #####: 2714:    pos.x += FONT_ATLAS_DEFAULT_TEX_DATA_W + 1;
    #####: 2715:    out_uv_fill[0] = (pos) * TexUvScale;
call    0 never executed
    #####: 2716:    out_uv_fill[1] = (pos + size) * TexUvScale;
call    0 never executed
call    1 never executed
    #####: 2717:    return true;
        -: 2718:}
        -: 2719:
function _ZN11ImFontAtlas5BuildEv called 1 returned 100% blocks executed 78%
        1: 2720:bool    ImFontAtlas::Build()
        -: 2721:{
       1*: 2722:    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
        1: 2722-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 2722-block 3
call    2 never executed
        -: 2723:
        -: 2724:    // Default font is none are specified
        1: 2725:    if (ConfigData.Size == 0)
        1: 2725-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 2726:        AddFontDefault();
    %%%%%: 2726-block 5
call    0 never executed
        -: 2727:
        -: 2728:    // Select builder
        -: 2729:    // - Note that we do not reassign to atlas->FontBuilderIO, since it is likely to point to static data which
        -: 2730:    //   may mess with some hot-reloading schemes. If you need to assign to this (for dynamic selection) AND are
        -: 2731:    //   using a hot-reloading scheme that messes up static data, store your own instance of ImFontBuilderIO somewhere
        -: 2732:    //   and point to it instead of pointing directly to return value of the GetBuilderXXX functions.
        1: 2733:    const ImFontBuilderIO* builder_io = FontBuilderIO;
        1: 2734:    if (builder_io == NULL)
        1: 2734-block 6
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 2735:    {
        -: 2736:#ifdef IMGUI_ENABLE_FREETYPE
        -: 2737:        builder_io = ImGuiFreeType::GetBuilderForFreeType();
        -: 2738:#elif defined(IMGUI_ENABLE_STB_TRUETYPE)
        1: 2739:        builder_io = ImFontAtlasGetBuilderForStbTruetype();
        1: 2739-block 7
call    0 returned 1
        -: 2740:#else
        -: 2741:        IM_ASSERT(0); // Invalid Build function
        -: 2742:#endif
        -: 2743:    }
        -: 2744:
        -: 2745:    // Build
        1: 2746:    return builder_io->FontBuilder_Build(this);
        1: 2746-block 8
call    0 returned 1
        -: 2747:}
        -: 2748:
function _Z39ImFontAtlasBuildMultiplyCalcLookupTablePhf called 0 returned 0% blocks executed 0%
    #####: 2749:void    ImFontAtlasBuildMultiplyCalcLookupTable(unsigned char out_table[256], float in_brighten_factor)
        -: 2750:{
    #####: 2751:    for (unsigned int i = 0; i < 256; i++)
    %%%%%: 2751-block 2
    %%%%%: 2751-block 7
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 2752:    {
    #####: 2753:        unsigned int value = (unsigned int)(i * in_brighten_factor);
    #####: 2754:        out_table[i] = value > 255 ? 255 : (value & 0xFF);
    %%%%%: 2754-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2754-block 4
    %%%%%: 2754-block 5
    %%%%%: 2754-block 6
        -: 2755:    }
    #####: 2756:}
        -: 2757:
function _Z34ImFontAtlasBuildMultiplyRectAlpha8PKhPhiiiii called 0 returned 0% blocks executed 0%
    #####: 2758:void    ImFontAtlasBuildMultiplyRectAlpha8(const unsigned char table[256], unsigned char* pixels, int x, int y, int w, int h, int stride)
        -: 2759:{
        -: 2760:    IM_ASSERT_PARANOID(w <= stride);
    #####: 2761:    unsigned char* data = pixels + x + y * stride;
    #####: 2762:    for (int j = h; j > 0; j--, data += stride - w)
    %%%%%: 2762-block 2
    %%%%%: 2762-block 6
    %%%%%: 2762-block 7
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2763:        for (int i = w; i > 0; i--, data++)
    %%%%%: 2763-block 3
    %%%%%: 2763-block 5
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2764:            *data = table[*data];
    %%%%%: 2764-block 4
    #####: 2765:}
        -: 2766:
        -: 2767:#ifdef IMGUI_ENABLE_STB_TRUETYPE
        -: 2768:// Temporary data for one source font (multiple source fonts can be merged into one destination ImFont)
        -: 2769:// (C++03 doesn't allow instancing ImVector<> with function-local types so we declare the type here.)
        -: 2770:struct ImFontBuildSrcData
        -: 2771:{
        -: 2772:    stbtt_fontinfo      FontInfo;
        -: 2773:    stbtt_pack_range    PackRange;          // Hold the list of codepoints to pack (essentially points to Codepoints.Data)
        -: 2774:    stbrp_rect*         Rects;              // Rectangle to pack. We first fill in their size and the packer will give us their position.
        -: 2775:    stbtt_packedchar*   PackedChars;        // Output glyphs
        -: 2776:    const ImWchar*      SrcRanges;          // Ranges as requested by user (user is allowed to request too much, e.g. 0x0020..0xFFFF)
        -: 2777:    int                 DstIndex;           // Index into atlas->Fonts[] and dst_tmp_array[]
        -: 2778:    int                 GlyphsHighest;      // Highest requested codepoint
        -: 2779:    int                 GlyphsCount;        // Glyph count (excluding missing glyphs and glyphs already set by an earlier source font)
        -: 2780:    ImBitVector         GlyphsSet;          // Glyph bit map (random access, 1-bit per codepoint. This will be a maximum of 8KB)
        -: 2781:    ImVector<int>       GlyphsList;         // Glyph codepoints list (flattened version of GlyphsSet)
        -: 2782:};
        -: 2783:
        -: 2784:// Temporary data for one destination ImFont* (multiple source fonts can be merged into one destination ImFont)
        -: 2785:struct ImFontBuildDstData
        -: 2786:{
        -: 2787:    int                 SrcCount;           // Number of source fonts targeting this destination font.
        -: 2788:    int                 GlyphsHighest;
        -: 2789:    int                 GlyphsCount;
        -: 2790:    ImBitVector         GlyphsSet;          // This is used to resolve collision when multiple sources are merged into a same destination font.
        -: 2791:};
        -: 2792:
function _ZL30UnpackBitVectorToFlatIndexListPK11ImBitVectorP8ImVectorIiE called 11 returned 100% blocks executed 100%
       11: 2793:static void UnpackBitVectorToFlatIndexList(const ImBitVector* in, ImVector<int>* out)
        -: 2794:{
        -: 2795:    IM_ASSERT(sizeof(in->Storage.Data[0]) == sizeof(int));
       11: 2796:    const ImU32* it_begin = in->Storage.begin();
       11: 2796-block 2
call    0 returned 11
       11: 2797:    const ImU32* it_end = in->Storage.end();
call    0 returned 11
     2020: 2798:    for (const ImU32* it = it_begin; it < it_end; it++)
     2009: 2798-block 12
     2020: 2798-block 13
branch  0 taken 2009
branch  1 taken 11 (fallthrough)
     2009: 2799:        if (ImU32 entries_32 = *it)
     2009: 2799-block 5
branch  0 taken 77 (fallthrough)
branch  1 taken 1932
     2541: 2800:            for (ImU32 bit_n = 0; bit_n < 32; bit_n++)
       77: 2800-block 6
     2464: 2800-block 10
     2541: 2800-block 11
branch  0 taken 2464
branch  1 taken 77 (fallthrough)
     2464: 2801:                if (entries_32 & ((ImU32)1 << bit_n))
     2464: 2801-block 7
branch  0 taken 2380 (fallthrough)
branch  1 taken 84
     2380: 2802:                    out->push_back((int)(((it - it_begin) << 5) + bit_n));
     2380: 2802-block 8
call    0 returned 2380
branch  1 taken 2380 (fallthrough)
branch  2 taken 0 (throw)
     2380: 2802-block 9
       11: 2803:}
       11: 2803-block 14
        -: 2804:
function _ZL31ImFontAtlasBuildWithStbTruetypeP11ImFontAtlas called 1 returned 100% blocks executed 81%
        1: 2805:static bool ImFontAtlasBuildWithStbTruetype(ImFontAtlas* atlas)
        -: 2806:{
       1*: 2807:    IM_ASSERT(atlas->ConfigData.Size > 0);
        1: 2807-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 2807-block 3
call    2 never executed
        -: 2808:
        1: 2809:    ImFontAtlasBuildInit(atlas);
        1: 2809-block 4
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -: 2810:
        -: 2811:    // Clear atlas
        1: 2812:    atlas->TexID = (ImTextureID)NULL;
        1: 2813:    atlas->TexWidth = atlas->TexHeight = 0;
        1: 2814:    atlas->TexUvScale = ImVec2(0.0f, 0.0f);
        1: 2814-block 5
call    0 returned 1
        1: 2815:    atlas->TexUvWhitePixel = ImVec2(0.0f, 0.0f);
call    0 returned 1
        1: 2816:    atlas->ClearTexData();
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -: 2817:
        -: 2818:    // Temporary storage for building
        1: 2819:    ImVector<ImFontBuildSrcData> src_tmp_array;
        1: 2819-block 8
call    0 returned 1
        1: 2820:    ImVector<ImFontBuildDstData> dst_tmp_array;
call    0 returned 1
        1: 2821:    src_tmp_array.resize(atlas->ConfigData.Size);
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 2822:    dst_tmp_array.resize(atlas->Fonts.Size);
        1: 2822-block 11
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 2823:    memset(src_tmp_array.Data, 0, (size_t)src_tmp_array.size_in_bytes());
        1: 2823-block 12
call    0 returned 1
        1: 2824:    memset(dst_tmp_array.Data, 0, (size_t)dst_tmp_array.size_in_bytes());
call    0 returned 1
        -: 2825:
        -: 2826:    // 1. Initialize font loading structure, check font data validity
       12: 2827:    for (int src_i = 0; src_i < atlas->ConfigData.Size; src_i++)
       12: 2827-block 53
branch  0 taken 11
branch  1 taken 1 (fallthrough)
        -: 2828:    {
       11: 2829:        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
       11: 2829-block 15
call    0 returned 11
       11: 2830:        ImFontConfig& cfg = atlas->ConfigData[src_i];
call    0 returned 11
      11*: 2831:        IM_ASSERT(cfg.DstFont && (!cfg.DstFont->IsLoaded() || cfg.DstFont->ContainerAtlas == atlas));
branch  0 taken 11 (fallthrough)
branch  1 taken 0
       11: 2831-block 18
call    2 returned 11
branch  3 taken 0 (fallthrough)
branch  4 taken 11
    %%%%%: 2831-block 20
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%: 2831-block 22
call    7 never executed
        -: 2832:
        -: 2833:        // Find index from cfg.DstFont (we allow the user to set cfg.DstFont. Also it makes casual debugging nicer than when storing indices)
       11: 2834:        src_tmp.DstIndex = -1;
       73: 2835:        for (int output_i = 0; output_i < atlas->Fonts.Size && src_tmp.DstIndex == -1; output_i++)
       11: 2835-block 23
       62: 2835-block 27
       73: 2835-block 28
branch  0 taken 72 (fallthrough)
branch  1 taken 1
       72: 2835-block 29
branch  2 taken 62
branch  3 taken 10 (fallthrough)
       62: 2836:            if (cfg.DstFont == atlas->Fonts[output_i])
       62: 2836-block 24
call    0 returned 62
branch  1 taken 11 (fallthrough)
branch  2 taken 51
       11: 2837:                src_tmp.DstIndex = output_i;
       11: 2837-block 26
       11: 2838:        if (src_tmp.DstIndex == -1)
       11: 2838-block 30
branch  0 taken 0 (fallthrough)
branch  1 taken 11
        -: 2839:        {
    #####: 2840:            IM_ASSERT(src_tmp.DstIndex != -1); // cfg.DstFont not pointing within atlas->Fonts[] array?
    %%%%%: 2840-block 31
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 2840-block 32
call    2 never executed
    #####: 2841:            return false;
    %%%%%: 2841-block 33
        -: 2842:        }
        -: 2843:        // Initialize helper structure for font loading and verify that the TTF/OTF data is correct
       11: 2844:        const int font_offset = stbtt_GetFontOffsetForIndex((unsigned char*)cfg.FontData, cfg.FontNo);
       11: 2844-block 34
call    0 returned 11
      11*: 2845:        IM_ASSERT(font_offset >= 0 && "FontData is incorrect, or FontNo cannot be found.");
branch  0 taken 0 (fallthrough)
branch  1 taken 11
    %%%%%: 2845-block 36
call    2 never executed
       11: 2846:        if (!stbtt_InitFont(&src_tmp.FontInfo, (unsigned char*)cfg.FontData, font_offset))
       11: 2846-block 37
call    0 returned 11
branch  1 taken 0 (fallthrough)
branch  2 taken 11
        -: 2847:        {
    #####: 2848:            IM_ASSERT(0 && "stbtt_InitFont(): failed to parse FontData. It is correct and complete? Check FontDataSize.");
    %%%%%: 2848-block 39
call    0 never executed
        -: 2849:            return false;
        -: 2850:        }
        -: 2851:
        -: 2852:        // Measure highest codepoints
       11: 2853:        ImFontBuildDstData& dst_tmp = dst_tmp_array[src_tmp.DstIndex];
       11: 2853-block 40
call    0 returned 11
       11: 2854:        src_tmp.SrcRanges = cfg.GlyphRanges ? cfg.GlyphRanges : atlas->GetGlyphRangesDefault();
branch  0 taken 2 (fallthrough)
branch  1 taken 9
        2: 2854-block 42
        9: 2854-block 43
call    2 returned 9
       22: 2855:        for (const ImWchar* src_range = src_tmp.SrcRanges; src_range[0] && src_range[1]; src_range += 2)
       11: 2855-block 44
       22: 2855-block 49
branch  0 taken 11 (fallthrough)
branch  1 taken 11
       11: 2855-block 50
branch  2 taken 11
branch  3 taken 0 (fallthrough)
        -: 2856:        {
        -: 2857:            // Check for valid range. This may also help detect *some* dangling pointers, because a common
        -: 2858:            // user error is to setup ImFontConfig::GlyphRanges with a pointer to data that isn't persistent,
        -: 2859:            // or to forget to zero-terminate the glyph range array.
      11*: 2860:            IM_ASSERT(src_range[0] <= src_range[1] && "Invalid range: is your glyph range array persistent? it is zero-terminated?");
       11: 2860-block 45
branch  0 taken 0 (fallthrough)
branch  1 taken 11
    %%%%%: 2860-block 46
call    2 never executed
       11: 2861:            src_tmp.GlyphsHighest = ImMax(src_tmp.GlyphsHighest, (int)src_range[1]);
       11: 2861-block 47
call    0 returned 11
        -: 2862:        }
       11: 2863:        dst_tmp.SrcCount++;
       11: 2864:        dst_tmp.GlyphsHighest = ImMax(dst_tmp.GlyphsHighest, src_tmp.GlyphsHighest);
       11: 2864-block 51
call    0 returned 11
        -: 2865:    }
        -: 2866:
        -: 2867:    // 2. For every requested codepoint, check for their presence in the font data, and handle redundancy or overlaps between source fonts to avoid unused glyphs.
        1: 2868:    int total_glyphs_count = 0;
       12: 2869:    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
        1: 2869-block 54
       11: 2869-block 77
       12: 2869-block 78
branch  0 taken 11
branch  1 taken 1 (fallthrough)
        -: 2870:    {
       11: 2871:        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
       11: 2871-block 55
call    0 returned 11
       11: 2872:        ImFontBuildDstData& dst_tmp = dst_tmp_array[src_tmp.DstIndex];
call    0 returned 11
       11: 2873:        src_tmp.GlyphsSet.Create(src_tmp.GlyphsHighest + 1);
call    0 returned 11
branch  1 taken 11 (fallthrough)
branch  2 taken 0 (throw)
       11: 2874:        if (dst_tmp.GlyphsSet.Storage.empty())
       11: 2874-block 58
call    0 returned 11
branch  1 taken 10 (fallthrough)
branch  2 taken 1
       10: 2875:            dst_tmp.GlyphsSet.Create(dst_tmp.GlyphsHighest + 1);
       10: 2875-block 60
call    0 returned 10
branch  1 taken 10 (fallthrough)
branch  2 taken 0 (throw)
        -: 2876:
       22: 2877:        for (const ImWchar* src_range = src_tmp.SrcRanges; src_range[0] && src_range[1]; src_range += 2)
       11: 2877-block 61
       11: 2877-block 74
       22: 2877-block 75
branch  0 taken 11 (fallthrough)
branch  1 taken 11
       11: 2877-block 76
branch  2 taken 11
branch  3 taken 0 (fallthrough)
     3949: 2878:            for (unsigned int codepoint = src_range[0]; codepoint <= src_range[1]; codepoint++)
       11: 2878-block 62
     3938: 2878-block 72
     3949: 2878-block 73
branch  0 taken 3938
branch  1 taken 11 (fallthrough)
        -: 2879:            {
    3938*: 2880:                if (dst_tmp.GlyphsSet.TestBit(codepoint))    // Don't overwrite existing glyphs. We could make this an option for MergeMode (e.g. MergeOverwrite==true)
     3938: 2880-block 63
call    0 returned 3938
branch  1 taken 0 (fallthrough)
branch  2 taken 3938
    #####: 2881:                    continue;
    %%%%%: 2881-block 65
     3938: 2882:                if (!stbtt_FindGlyphIndex(&src_tmp.FontInfo, codepoint))    // It is actually in the font?
     3938: 2882-block 66
call    0 returned 3938
branch  1 taken 1558 (fallthrough)
branch  2 taken 2380
     1558: 2883:                    continue;
     1558: 2883-block 68
        -: 2884:
        -: 2885:                // Add to avail set/counters
     2380: 2886:                src_tmp.GlyphsCount++;
     2380: 2887:                dst_tmp.GlyphsCount++;
     2380: 2888:                src_tmp.GlyphsSet.SetBit(codepoint);
     2380: 2888-block 69
call    0 returned 2380
     2380: 2889:                dst_tmp.GlyphsSet.SetBit(codepoint);
call    0 returned 2380
     2380: 2890:                total_glyphs_count++;
        -: 2891:            }
        -: 2892:    }
        -: 2893:
        -: 2894:    // 3. Unpack our bit map into a flat list (we now have all the Unicode points that we know are requested _and_ available _and_ not overlapping another)
       12: 2895:    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
        1: 2895-block 79
       11: 2895-block 86
       12: 2895-block 87
branch  0 taken 11
branch  1 taken 1 (fallthrough)
        -: 2896:    {
       11: 2897:        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
       11: 2897-block 80
call    0 returned 11
       11: 2898:        src_tmp.GlyphsList.reserve(src_tmp.GlyphsCount);
call    0 returned 11
branch  1 taken 11 (fallthrough)
branch  2 taken 0 (throw)
       11: 2899:        UnpackBitVectorToFlatIndexList(&src_tmp.GlyphsSet, &src_tmp.GlyphsList);
       11: 2899-block 82
call    0 returned 11
branch  1 taken 11 (fallthrough)
branch  2 taken 0 (throw)
       11: 2900:        src_tmp.GlyphsSet.Clear();
       11: 2900-block 83
call    0 returned 11
branch  1 taken 11 (fallthrough)
branch  2 taken 0 (throw)
      11*: 2901:        IM_ASSERT(src_tmp.GlyphsList.Size == src_tmp.GlyphsCount);
       11: 2901-block 84
branch  0 taken 0 (fallthrough)
branch  1 taken 11
    %%%%%: 2901-block 85
call    2 never executed
        -: 2902:    }
       11: 2903:    for (int dst_i = 0; dst_i < dst_tmp_array.Size; dst_i++)
        1: 2903-block 88
       10: 2903-block 91
       11: 2903-block 92
branch  0 taken 10
branch  1 taken 1 (fallthrough)
       10: 2904:        dst_tmp_array[dst_i].GlyphsSet.Clear();
       10: 2904-block 89
call    0 returned 10
call    1 returned 10
branch  2 taken 10 (fallthrough)
branch  3 taken 0 (throw)
        1: 2905:    dst_tmp_array.clear();
        1: 2905-block 93
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -: 2906:
        -: 2907:    // Allocate packing character data and flag packed characters buffer as non-packed (x0=y0=x1=y1=0)
        -: 2908:    // (We technically don't need to zero-clear buf_rects, but let's do it for the sake of sanity)
        1: 2909:    ImVector<stbrp_rect> buf_rects;
        1: 2909-block 94
call    0 returned 1
        1: 2910:    ImVector<stbtt_packedchar> buf_packedchars;
call    0 returned 1
        1: 2911:    buf_rects.resize(total_glyphs_count);
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 2912:    buf_packedchars.resize(total_glyphs_count);
        1: 2912-block 97
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 2913:    memset(buf_rects.Data, 0, (size_t)buf_rects.size_in_bytes());
        1: 2913-block 98
call    0 returned 1
        1: 2914:    memset(buf_packedchars.Data, 0, (size_t)buf_packedchars.size_in_bytes());
call    0 returned 1
        -: 2915:
        -: 2916:    // 4. Gather glyphs sizes so we can pack them in our virtual canvas.
        1: 2917:    int total_surface = 0;
        1: 2918:    int buf_rects_out_n = 0;
        1: 2919:    int buf_packedchars_out_n = 0;
       12: 2920:    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
       11: 2920-block 118
       12: 2920-block 119
branch  0 taken 11
branch  1 taken 1 (fallthrough)
        -: 2921:    {
       11: 2922:        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
       11: 2922-block 101
call    0 returned 11
      11*: 2923:        if (src_tmp.GlyphsCount == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 11
    #####: 2924:            continue;
    %%%%%: 2924-block 103
        -: 2925:
       11: 2926:        src_tmp.Rects = &buf_rects[buf_rects_out_n];
       11: 2926-block 104
call    0 returned 11
       11: 2927:        src_tmp.PackedChars = &buf_packedchars[buf_packedchars_out_n];
call    0 returned 11
       11: 2928:        buf_rects_out_n += src_tmp.GlyphsCount;
       11: 2929:        buf_packedchars_out_n += src_tmp.GlyphsCount;
        -: 2930:
        -: 2931:        // Convert our ranges in the format stb_truetype wants
       11: 2932:        ImFontConfig& cfg = atlas->ConfigData[src_i];
call    0 returned 11
       11: 2933:        src_tmp.PackRange.font_size = cfg.SizePixels * cfg.RasterizerDensity;
       11: 2934:        src_tmp.PackRange.first_unicode_codepoint_in_range = 0;
       11: 2935:        src_tmp.PackRange.array_of_unicode_codepoints = src_tmp.GlyphsList.Data;
       11: 2936:        src_tmp.PackRange.num_chars = src_tmp.GlyphsList.Size;
       11: 2937:        src_tmp.PackRange.chardata_for_range = src_tmp.PackedChars;
       11: 2938:        src_tmp.PackRange.h_oversample = (unsigned char)cfg.OversampleH;
       11: 2939:        src_tmp.PackRange.v_oversample = (unsigned char)cfg.OversampleV;
        -: 2940:
        -: 2941:        // Gather the sizes of all rectangles we will need to pack (this loop is based on stbtt_PackFontRangesGatherRects)
      11*: 2942:        const float scale = (cfg.SizePixels > 0.0f) ? stbtt_ScaleForPixelHeight(&src_tmp.FontInfo, cfg.SizePixels * cfg.RasterizerDensity) : stbtt_ScaleForMappingEmToPixels(&src_tmp.FontInfo, -cfg.SizePixels * cfg.RasterizerDensity);
branch  0 taken 11 (fallthrough)
branch  1 taken 0
       11: 2942-block 108
call    2 returned 11
    %%%%%: 2942-block 109
call    3 never executed
       11: 2943:        const int padding = atlas->TexGlyphPadding;
     2391: 2944:        for (int glyph_i = 0; glyph_i < src_tmp.GlyphsList.Size; glyph_i++)
       11: 2944-block 110
     2391: 2944-block 117
branch  0 taken 2380
branch  1 taken 11 (fallthrough)
        -: 2945:        {
        -: 2946:            int x0, y0, x1, y1;
     2380: 2947:            const int glyph_index_in_font = stbtt_FindGlyphIndex(&src_tmp.FontInfo, src_tmp.GlyphsList[glyph_i]);
     2380: 2947-block 111
call    0 returned 2380
call    1 returned 2380
    2380*: 2948:            IM_ASSERT(glyph_index_in_font != 0);
branch  0 taken 0 (fallthrough)
branch  1 taken 2380
    %%%%%: 2948-block 114
call    2 never executed
     2380: 2949:            stbtt_GetGlyphBitmapBoxSubpixel(&src_tmp.FontInfo, glyph_index_in_font, scale * cfg.OversampleH, scale * cfg.OversampleV, 0, 0, &x0, &y0, &x1, &y1);
     2380: 2949-block 115
call    0 returned 2380
branch  1 taken 2380 (fallthrough)
branch  2 taken 0 (throw)
     2380: 2950:            src_tmp.Rects[glyph_i].w = (stbrp_coord)(x1 - x0 + padding + cfg.OversampleH - 1);
     2380: 2951:            src_tmp.Rects[glyph_i].h = (stbrp_coord)(y1 - y0 + padding + cfg.OversampleV - 1);
     2380: 2952:            total_surface += src_tmp.Rects[glyph_i].w * src_tmp.Rects[glyph_i].h;
     2380: 2952-block 116
        -: 2953:        }
        -: 2954:    }
        -: 2955:
        -: 2956:    // We need a width for the skyline algorithm, any width!
        -: 2957:    // The exact width doesn't really matter much, but some API/GPU have texture size limitations and increasing width can decrease height.
        -: 2958:    // User can override TexDesiredWidth and TexGlyphPadding if they wish, otherwise we use a simple heuristic to select the width based on expected surface.
        1: 2959:    const int surface_sqrt = (int)ImSqrt((float)total_surface) + 1;
        1: 2960:    atlas->TexHeight = 0;
        1: 2961:    if (atlas->TexDesiredWidth > 0)
        1: 2961-block 120
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 2962:        atlas->TexWidth = atlas->TexDesiredWidth;
    %%%%%: 2962-block 121
        -: 2963:    else
       1*: 2964:        atlas->TexWidth = (surface_sqrt >= 4096 * 0.7f) ? 4096 : (surface_sqrt >= 2048 * 0.7f) ? 2048 : (surface_sqrt >= 1024 * 0.7f) ? 1024 : 512;
        1: 2964-block 122
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 2964-block 123
        1: 2964-block 124
branch  2 taken 0 (fallthrough)
branch  3 taken 1
    %%%%%: 2964-block 125
        1: 2964-block 126
branch  4 taken 1 (fallthrough)
branch  5 taken 0
        1: 2964-block 127
    %%%%%: 2964-block 128
        1: 2964-block 129
        1: 2964-block 130
        1: 2964-block 131
        -: 2965:
        -: 2966:    // 5. Start packing
        -: 2967:    // Pack our extra data rectangles first, so it will be on the upper-left corner of our texture (UV will have small values).
        1: 2968:    const int TEX_HEIGHT_MAX = 1024 * 32;
        1: 2969:    stbtt_pack_context spc = {};
        1: 2970:    stbtt_PackBegin(&spc, NULL, atlas->TexWidth, TEX_HEIGHT_MAX, 0, atlas->TexGlyphPadding, NULL);
        1: 2970-block 132
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 2971:    ImFontAtlasBuildPackCustomRects(atlas, spc.pack_info);
        1: 2971-block 133
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -: 2972:
        -: 2973:    // 6. Pack each source font. No rendering yet, we are working with rectangles in an infinitely tall texture at this point.
       12: 2974:    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
        1: 2974-block 134
       11: 2974-block 145
       12: 2974-block 146
branch  0 taken 11
branch  1 taken 1 (fallthrough)
        -: 2975:    {
       11: 2976:        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
       11: 2976-block 135
call    0 returned 11
      11*: 2977:        if (src_tmp.GlyphsCount == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 11
    #####: 2978:            continue;
    %%%%%: 2978-block 137
        -: 2979:
       11: 2980:        stbrp_pack_rects((stbrp_context*)spc.pack_info, src_tmp.Rects, src_tmp.GlyphsCount);
       11: 2980-block 138
call    0 returned 11
branch  1 taken 11 (fallthrough)
branch  2 taken 0 (throw)
        -: 2981:
        -: 2982:        // Extend texture height and mark missing glyphs as non-packed so we won't render them.
        -: 2983:        // FIXME: We are not handling packing failure here (would happen if we got off TEX_HEIGHT_MAX or if a single if larger than TexWidth?)
     2391: 2984:        for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++)
       11: 2984-block 139
     2380: 2984-block 143
     2391: 2984-block 144
branch  0 taken 2380
branch  1 taken 11 (fallthrough)
     2380: 2985:            if (src_tmp.Rects[glyph_i].was_packed)
     2380: 2985-block 140
branch  0 taken 2380 (fallthrough)
branch  1 taken 0
     2380: 2986:                atlas->TexHeight = ImMax(atlas->TexHeight, src_tmp.Rects[glyph_i].y + src_tmp.Rects[glyph_i].h);
     2380: 2986-block 141
call    0 returned 2380
        -: 2987:    }
        -: 2988:
        -: 2989:    // 7. Allocate texture
       1*: 2990:    atlas->TexHeight = (atlas->Flags & ImFontAtlasFlags_NoPowerOfTwoHeight) ? (atlas->TexHeight + 1) : ImUpperPowerOfTwo(atlas->TexHeight);
        1: 2990-block 147
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 2990-block 148
        1: 2990-block 149
call    2 returned 1
        1: 2991:    atlas->TexUvScale = ImVec2(1.0f / atlas->TexWidth, 1.0f / atlas->TexHeight);
        1: 2991-block 150
call    0 returned 1
        1: 2992:    atlas->TexPixelsAlpha8 = (unsigned char*)IM_ALLOC(atlas->TexWidth * atlas->TexHeight);
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 2993:    memset(atlas->TexPixelsAlpha8, 0, atlas->TexWidth * atlas->TexHeight);
        1: 2994:    spc.pixels = atlas->TexPixelsAlpha8;
        1: 2995:    spc.height = atlas->TexHeight;
        -: 2996:
        -: 2997:    // 8. Render/rasterize font characters into the texture
       12: 2998:    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
        1: 2998-block 152
       11: 2998-block 167
       12: 2998-block 168
branch  0 taken 11
branch  1 taken 1 (fallthrough)
        -: 2999:    {
       11: 3000:        ImFontConfig& cfg = atlas->ConfigData[src_i];
       11: 3000-block 153
call    0 returned 11
       11: 3001:        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
call    0 returned 11
      11*: 3002:        if (src_tmp.GlyphsCount == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 11
    #####: 3003:            continue;
    %%%%%: 3003-block 156
        -: 3004:
       11: 3005:        stbtt_PackFontRangesRenderIntoRects(&spc, &src_tmp.FontInfo, &src_tmp.PackRange, 1, src_tmp.Rects);
       11: 3005-block 157
call    0 returned 11
branch  1 taken 11 (fallthrough)
branch  2 taken 0 (throw)
        -: 3006:
        -: 3007:        // Apply multiply operator
       11: 3008:        if (cfg.RasterizerMultiply != 1.0f)
       11: 3008-block 158
branch  0 taken 0 (fallthrough)
branch  1 taken 11
        -: 3009:        {
        -: 3010:            unsigned char multiply_table[256];
    #####: 3011:            ImFontAtlasBuildMultiplyCalcLookupTable(multiply_table, cfg.RasterizerMultiply);
    %%%%%: 3011-block 159
call    0 never executed
    #####: 3012:            stbrp_rect* r = &src_tmp.Rects[0];
    #####: 3013:            for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++, r++)
    %%%%%: 3013-block 163
    %%%%%: 3013-block 164
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3014:                if (r->was_packed)
    %%%%%: 3014-block 161
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3015:                    ImFontAtlasBuildMultiplyRectAlpha8(multiply_table, atlas->TexPixelsAlpha8, r->x, r->y, r->w, r->h, atlas->TexWidth * 1);
    %%%%%: 3015-block 162
call    0 never executed
        -: 3016:        }
       11: 3017:        src_tmp.Rects = NULL;
       11: 3017-block 166
        -: 3018:    }
        -: 3019:
        -: 3020:    // End packing
        1: 3021:    stbtt_PackEnd(&spc);
        1: 3021-block 169
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 3022:    buf_rects.clear();
        1: 3022-block 170
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -: 3023:
        -: 3024:    // 9. Setup ImFont and glyphs for runtime
       12: 3025:    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
        1: 3025-block 171
       11: 3025-block 184
       12: 3025-block 185
branch  0 taken 11
branch  1 taken 1 (fallthrough)
        -: 3026:    {
        -: 3027:        // When merging fonts with MergeMode=true:
        -: 3028:        // - We can have multiple input fonts writing into a same destination font.
        -: 3029:        // - dst_font->ConfigData is != from cfg which is our source configuration.
       11: 3030:        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
       11: 3030-block 172
call    0 returned 11
       11: 3031:        ImFontConfig& cfg = atlas->ConfigData[src_i];
call    0 returned 11
       11: 3032:        ImFont* dst_font = cfg.DstFont;
        -: 3033:
       11: 3034:        const float font_scale = stbtt_ScaleForPixelHeight(&src_tmp.FontInfo, cfg.SizePixels);
call    0 returned 11
        -: 3035:        int unscaled_ascent, unscaled_descent, unscaled_line_gap;
       11: 3036:        stbtt_GetFontVMetrics(&src_tmp.FontInfo, &unscaled_ascent, &unscaled_descent, &unscaled_line_gap);
call    0 returned 11
        -: 3037:
       11: 3038:        const float ascent = ImCeil(unscaled_ascent * font_scale);
       11: 3039:        const float descent = ImFloor(unscaled_descent * font_scale);
call    0 returned 11
       11: 3040:        ImFontAtlasBuildSetupFont(atlas, dst_font, &cfg, ascent, descent);
call    0 returned 11
branch  1 taken 11 (fallthrough)
branch  2 taken 0 (throw)
       11: 3041:        const float font_off_x = cfg.GlyphOffset.x;
       11: 3042:        const float font_off_y = cfg.GlyphOffset.y + IM_ROUND(dst_font->Ascent);
        -: 3043:
       11: 3044:        const float inv_rasterization_scale = 1.0f / cfg.RasterizerDensity;
        -: 3045:
     2391: 3046:        for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++)
       11: 3046-block 178
     2380: 3046-block 182
     2391: 3046-block 183
branch  0 taken 2380
branch  1 taken 11 (fallthrough)
        -: 3047:        {
        -: 3048:            // Register glyph
     2380: 3049:            const int codepoint = src_tmp.GlyphsList[glyph_i];
     2380: 3049-block 179
call    0 returned 2380
     2380: 3050:            const stbtt_packedchar& pc = src_tmp.PackedChars[glyph_i];
        -: 3051:            stbtt_aligned_quad q;
     2380: 3052:            float unused_x = 0.0f, unused_y = 0.0f;
     2380: 3053:            stbtt_GetPackedQuad(src_tmp.PackedChars, atlas->TexWidth, atlas->TexHeight, glyph_i, &unused_x, &unused_y, &q, 0);
call    0 returned 2380
     2380: 3054:            float x0 = q.x0 * inv_rasterization_scale + font_off_x;
     2380: 3055:            float y0 = q.y0 * inv_rasterization_scale + font_off_y;
     2380: 3056:            float x1 = q.x1 * inv_rasterization_scale + font_off_x;
     2380: 3057:            float y1 = q.y1 * inv_rasterization_scale + font_off_y;
     2380: 3058:            dst_font->AddGlyph(&cfg, (ImWchar)codepoint, x0, y0, x1, y1, q.s0, q.t0, q.s1, q.t1, pc.xadvance * inv_rasterization_scale);
call    0 returned 2380
branch  1 taken 2380 (fallthrough)
branch  2 taken 0 (throw)
        -: 3059:        }
        -: 3060:    }
        -: 3061:
        -: 3062:    // Cleanup
        1: 3063:    src_tmp_array.clear_destruct();
        1: 3063-block 186
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -: 3064:
        1: 3065:    ImFontAtlasBuildFinish(atlas);
        1: 3065-block 187
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 3066:    return true;
        1: 3067:}
        1: 3067-block 188
call    0 returned 1
call    1 returned 1
        1: 3067-block 190
call    2 returned 1
call    3 returned 1
    $$$$$: 3067-block 197
call    4 never executed
    $$$$$: 3067-block 199
call    5 never executed
    $$$$$: 3067-block 201
call    6 never executed
    $$$$$: 3067-block 203
call    7 never executed
        -: 3068:
function _Z35ImFontAtlasGetBuilderForStbTruetypev called 1 returned 100% blocks executed 100%
        1: 3069:const ImFontBuilderIO* ImFontAtlasGetBuilderForStbTruetype()
        -: 3070:{
        -: 3071:    static ImFontBuilderIO io;
        1: 3072:    io.FontBuilder_Build = ImFontAtlasBuildWithStbTruetype;
        1: 3073:    return &io;
        1: 3073-block 2
        -: 3074:}
        -: 3075:
        -: 3076:#endif // IMGUI_ENABLE_STB_TRUETYPE
        -: 3077:
function _Z35ImFontAtlasUpdateConfigDataPointersP11ImFontAtlas called 11 returned 100% blocks executed 100%
       11: 3078:void ImFontAtlasUpdateConfigDataPointers(ImFontAtlas* atlas)
        -: 3079:{
       77: 3080:    for (ImFontConfig& font_cfg : atlas->ConfigData)
       11: 3080-block 2
call    0 returned 11
call    1 returned 11
       77: 3080-block 7
branch  2 taken 66
branch  3 taken 11 (fallthrough)
        -: 3081:    {
       66: 3082:        ImFont* font = font_cfg.DstFont;
       66: 3083:        if (!font_cfg.MergeMode)
       66: 3083-block 4
branch  0 taken 62 (fallthrough)
branch  1 taken 4
        -: 3084:        {
       62: 3085:            font->ConfigData = &font_cfg;
       62: 3086:            font->ConfigDataCount = 0;
       62: 3086-block 5
        -: 3087:        }
       66: 3088:        font->ConfigDataCount++;
       66: 3088-block 6
        -: 3089:    }
       11: 3090:}
        -: 3091:
function _Z25ImFontAtlasBuildSetupFontP11ImFontAtlasP6ImFontP12ImFontConfigff called 11 returned 100% blocks executed 83%
       11: 3092:void ImFontAtlasBuildSetupFont(ImFontAtlas* atlas, ImFont* font, ImFontConfig* font_config, float ascent, float descent)
        -: 3093:{
       11: 3094:    if (!font_config->MergeMode)
       11: 3094-block 2
branch  0 taken 10 (fallthrough)
branch  1 taken 1
        -: 3095:    {
       10: 3096:        font->ClearOutputData();
       10: 3096-block 3
call    0 returned 10
       10: 3097:        font->FontSize = font_config->SizePixels;
      10*: 3098:        IM_ASSERT(font->ConfigData == font_config);
branch  0 taken 0 (fallthrough)
branch  1 taken 10
    %%%%%: 3098-block 5
call    2 never executed
       10: 3099:        font->ContainerAtlas = atlas;
       10: 3100:        font->Ascent = ascent;
       10: 3101:        font->Descent = descent;
       10: 3101-block 6
        -: 3102:    }
       11: 3103:}
        -: 3104:
function _Z31ImFontAtlasBuildPackCustomRectsP11ImFontAtlasPv called 1 returned 100% blocks executed 86%
        1: 3105:void ImFontAtlasBuildPackCustomRects(ImFontAtlas* atlas, void* stbrp_context_opaque)
        -: 3106:{
        1: 3107:    stbrp_context* pack_context = (stbrp_context*)stbrp_context_opaque;
       1*: 3108:    IM_ASSERT(pack_context != NULL);
        1: 3108-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 3108-block 3
call    2 never executed
        -: 3109:
        1: 3110:    ImVector<ImFontAtlasCustomRect>& user_rects = atlas->CustomRects;
       1*: 3111:    IM_ASSERT(user_rects.Size >= 1); // We expect at least the default custom rects to be registered, else something went wrong.
        1: 3111-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 3111-block 5
call    2 never executed
        -: 3112:#ifdef __GNUC__
       1*: 3113:    if (user_rects.Size < 1) { __builtin_unreachable(); } // Workaround for GCC bug if IM_ASSERT() is defined to conditionally throw (see #5343)
        1: 3113-block 6
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 3113-block 7
call    2 never executed
        -: 3114:#endif
        -: 3115:
        1: 3116:    ImVector<stbrp_rect> pack_rects;
        1: 3116-block 8
call    0 returned 1
        1: 3117:    pack_rects.resize(user_rects.Size);
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1: 3118:    memset(pack_rects.Data, 0, (size_t)pack_rects.size_in_bytes());
        1: 3118-block 10
call    0 returned 1
        3: 3119:    for (int i = 0; i < user_rects.Size; i++)
        3: 3119-block 17
branch  0 taken 2
branch  1 taken 1 (fallthrough)
        -: 3120:    {
        2: 3121:        pack_rects[i].w = user_rects[i].Width;
        2: 3121-block 12
call    0 returned 2
call    1 returned 2
        2: 3122:        pack_rects[i].h = user_rects[i].Height;
call    0 returned 2
call    1 returned 2
        -: 3123:    }
        1: 3124:    stbrp_pack_rects(pack_context, &pack_rects[0], pack_rects.Size);
        1: 3124-block 18
call    0 returned 1
call    1 returned 1
branch  2 taken 1 (fallthrough)
branch  3 taken 0 (throw)
        3: 3125:    for (int i = 0; i < pack_rects.Size; i++)
        1: 3125-block 20
        2: 3125-block 39
        3: 3125-block 40
branch  0 taken 2
branch  1 taken 1 (fallthrough)
        2: 3126:        if (pack_rects[i].was_packed)
        2: 3126-block 21
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0
        -: 3127:        {
        2: 3128:            user_rects[i].X = (unsigned short)pack_rects[i].x;
        2: 3128-block 23
call    0 returned 2
call    1 returned 2
        2: 3129:            user_rects[i].Y = (unsigned short)pack_rects[i].y;
call    0 returned 2
call    1 returned 2
       2*: 3130:            IM_ASSERT(pack_rects[i].w == user_rects[i].Width && pack_rects[i].h == user_rects[i].Height);
call    0 returned 2
call    1 returned 2
branch  2 taken 2 (fallthrough)
branch  3 taken 0
        2: 3130-block 30
call    4 returned 2
call    5 returned 2
branch  6 taken 2 (fallthrough)
branch  7 taken 0
        2: 3130-block 33
    %%%%%: 3130-block 34
call    8 never executed
        2: 3131:            atlas->TexHeight = ImMax(atlas->TexHeight, pack_rects[i].y + pack_rects[i].h);
        2: 3131-block 35
call    0 returned 2
call    1 returned 2
call    2 returned 2
        -: 3132:        }
        1: 3133:}
        1: 3133-block 41
call    0 returned 1
    $$$$$: 3133-block 43
call    1 never executed
        -: 3134:
function _Z40ImFontAtlasBuildRender8bppRectFromStringP11ImFontAtlasiiiiPKcch called 2 returned 100% blocks executed 89%
        2: 3135:void ImFontAtlasBuildRender8bppRectFromString(ImFontAtlas* atlas, int x, int y, int w, int h, const char* in_str, char in_marker_char, unsigned char in_marker_pixel_value)
        -: 3136:{
       2*: 3137:    IM_ASSERT(x >= 0 && x + w <= atlas->TexWidth);
        2: 3137-block 2
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2: 3137-block 3
branch  2 taken 2 (fallthrough)
branch  3 taken 0
        2: 3137-block 4
    %%%%%: 3137-block 5
call    4 never executed
       2*: 3138:    IM_ASSERT(y >= 0 && y + h <= atlas->TexHeight);
        2: 3138-block 6
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2: 3138-block 7
branch  2 taken 2 (fallthrough)
branch  3 taken 0
        2: 3138-block 8
    %%%%%: 3138-block 9
call    4 never executed
        2: 3139:    unsigned char* out_pixel = atlas->TexPixelsAlpha8 + x + (y * atlas->TexWidth);
       56: 3140:    for (int off_y = 0; off_y < h; off_y++, out_pixel += atlas->TexWidth, in_str += w)
        2: 3140-block 10
       54: 3140-block 17
       56: 3140-block 18
branch  0 taken 54
branch  1 taken 2 (fallthrough)
     6642: 3141:        for (int off_x = 0; off_x < w; off_x++)
       54: 3141-block 11
     6642: 3141-block 16
branch  0 taken 6588
branch  1 taken 54 (fallthrough)
     6588: 3142:            out_pixel[off_x] = (in_str[off_x] == in_marker_char) ? in_marker_pixel_value : 0x00;
     6588: 3142-block 12
branch  0 taken 1124 (fallthrough)
branch  1 taken 5464
     1124: 3142-block 13
     5464: 3142-block 14
     6588: 3142-block 15
        2: 3143:}
        -: 3144:
function _Z41ImFontAtlasBuildRender32bppRectFromStringP11ImFontAtlasiiiiPKccj called 0 returned 0% blocks executed 0%
    #####: 3145:void ImFontAtlasBuildRender32bppRectFromString(ImFontAtlas* atlas, int x, int y, int w, int h, const char* in_str, char in_marker_char, unsigned int in_marker_pixel_value)
        -: 3146:{
    #####: 3147:    IM_ASSERT(x >= 0 && x + w <= atlas->TexWidth);
    %%%%%: 3147-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3147-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3147-block 4
    %%%%%: 3147-block 5
call    4 never executed
    #####: 3148:    IM_ASSERT(y >= 0 && y + h <= atlas->TexHeight);
    %%%%%: 3148-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3148-block 7
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3148-block 8
    %%%%%: 3148-block 9
call    4 never executed
    #####: 3149:    unsigned int* out_pixel = atlas->TexPixelsRGBA32 + x + (y * atlas->TexWidth);
    #####: 3150:    for (int off_y = 0; off_y < h; off_y++, out_pixel += atlas->TexWidth, in_str += w)
    %%%%%: 3150-block 10
    %%%%%: 3150-block 17
    %%%%%: 3150-block 18
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3151:        for (int off_x = 0; off_x < w; off_x++)
    %%%%%: 3151-block 11
    %%%%%: 3151-block 16
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3152:            out_pixel[off_x] = (in_str[off_x] == in_marker_char) ? in_marker_pixel_value : IM_COL32_BLACK_TRANS;
    %%%%%: 3152-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3152-block 13
    %%%%%: 3152-block 14
    %%%%%: 3152-block 15
    #####: 3153:}
        -: 3154:
function _ZL36ImFontAtlasBuildRenderDefaultTexDataP11ImFontAtlas called 1 returned 100% blocks executed 52%
        1: 3155:static void ImFontAtlasBuildRenderDefaultTexData(ImFontAtlas* atlas)
        -: 3156:{
        1: 3157:    ImFontAtlasCustomRect* r = atlas->GetCustomRectByIndex(atlas->PackIdMouseCursors);
        1: 3157-block 2
call    0 returned 1
       1*: 3158:    IM_ASSERT(r->IsPacked());
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    %%%%%: 3158-block 5
call    3 never executed
        -: 3159:
        1: 3160:    const int w = atlas->TexWidth;
        1: 3161:    if (!(atlas->Flags & ImFontAtlasFlags_NoMouseCursors))
        1: 3161-block 6
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 3162:    {
        -: 3163:        // Render/copy pixels
       1*: 3164:        IM_ASSERT(r->Width == FONT_ATLAS_DEFAULT_TEX_DATA_W * 2 + 1 && r->Height == FONT_ATLAS_DEFAULT_TEX_DATA_H);
        1: 3164-block 7
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 3164-block 8
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1: 3164-block 9
    %%%%%: 3164-block 10
call    4 never executed
        1: 3165:        const int x_for_white = r->X;
        1: 3166:        const int x_for_black = r->X + FONT_ATLAS_DEFAULT_TEX_DATA_W + 1;
        1: 3167:        if (atlas->TexPixelsAlpha8 != NULL)
        1: 3167-block 11
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 3168:        {
        1: 3169:            ImFontAtlasBuildRender8bppRectFromString(atlas, x_for_white, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, '.', 0xFF);
        1: 3169-block 12
call    0 returned 1
        1: 3170:            ImFontAtlasBuildRender8bppRectFromString(atlas, x_for_black, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, 'X', 0xFF);
call    0 returned 1
        -: 3171:        }
        -: 3172:        else
        -: 3173:        {
    #####: 3174:            ImFontAtlasBuildRender32bppRectFromString(atlas, x_for_white, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, '.', IM_COL32_WHITE);
    %%%%%: 3174-block 14
call    0 never executed
    #####: 3175:            ImFontAtlasBuildRender32bppRectFromString(atlas, x_for_black, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, 'X', IM_COL32_WHITE);
call    0 never executed
        -: 3176:        }
        -: 3177:    }
        -: 3178:    else
        -: 3179:    {
        -: 3180:        // Render 4 white pixels
    #####: 3181:        IM_ASSERT(r->Width == 2 && r->Height == 2);
    %%%%%: 3181-block 16
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3181-block 17
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3181-block 18
    %%%%%: 3181-block 19
call    4 never executed
    #####: 3182:        const int offset = (int)r->X + (int)r->Y * w;
    #####: 3183:        if (atlas->TexPixelsAlpha8 != NULL)
    %%%%%: 3183-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3184:        {
    #####: 3185:            atlas->TexPixelsAlpha8[offset] = atlas->TexPixelsAlpha8[offset + 1] = atlas->TexPixelsAlpha8[offset + w] = atlas->TexPixelsAlpha8[offset + w + 1] = 0xFF;
    %%%%%: 3185-block 21
        -: 3186:        }
        -: 3187:        else
        -: 3188:        {
    #####: 3189:            atlas->TexPixelsRGBA32[offset] = atlas->TexPixelsRGBA32[offset + 1] = atlas->TexPixelsRGBA32[offset + w] = atlas->TexPixelsRGBA32[offset + w + 1] = IM_COL32_WHITE;
    %%%%%: 3189-block 22
        -: 3190:        }
        -: 3191:    }
        1: 3192:    atlas->TexUvWhitePixel = ImVec2((r->X + 0.5f) * atlas->TexUvScale.x, (r->Y + 0.5f) * atlas->TexUvScale.y);
        1: 3192-block 23
call    0 returned 1
        1: 3193:}
        -: 3194:
function _ZL34ImFontAtlasBuildRenderLinesTexDataP11ImFontAtlas called 1 returned 100% blocks executed 68%
        1: 3195:static void ImFontAtlasBuildRenderLinesTexData(ImFontAtlas* atlas)
        -: 3196:{
        1: 3197:    if (atlas->Flags & ImFontAtlasFlags_NoBakedLines)
        1: 3197-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 3198:        return;
    %%%%%: 3198-block 3
        -: 3199:
        -: 3200:    // This generates a triangular shape in the texture, with the various line widths stacked on top of each other to allow interpolation between them
        1: 3201:    ImFontAtlasCustomRect* r = atlas->GetCustomRectByIndex(atlas->PackIdLines);
        1: 3201-block 4
call    0 returned 1
       1*: 3202:    IM_ASSERT(r->IsPacked());
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    %%%%%: 3202-block 7
call    3 never executed
       65: 3203:    for (unsigned int n = 0; n < IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 1; n++) // +1 because of the zero-width row
        1: 3203-block 8
       65: 3203-block 38
branch  0 taken 64
branch  1 taken 1 (fallthrough)
        -: 3204:    {
        -: 3205:        // Each line consists of at least two empty pixels at the ends, with a line of solid pixels in the middle
       64: 3206:        unsigned int y = n;
       64: 3207:        unsigned int line_width = n;
       64: 3208:        unsigned int pad_left = (r->Width - line_width) / 2;
       64: 3209:        unsigned int pad_right = r->Width - (pad_left + line_width);
        -: 3210:
        -: 3211:        // Write each slice
      64*: 3212:        IM_ASSERT(pad_left + line_width + pad_right == r->Width && y < r->Height); // Make sure we're inside the texture bounds before we start writing pixels
       64: 3212-block 9
branch  0 taken 64 (fallthrough)
branch  1 taken 0
       64: 3212-block 10
branch  2 taken 64 (fallthrough)
branch  3 taken 0
       64: 3212-block 11
    %%%%%: 3212-block 12
call    4 never executed
       64: 3213:        if (atlas->TexPixelsAlpha8 != NULL)
       64: 3213-block 13
branch  0 taken 64 (fallthrough)
branch  1 taken 0
        -: 3214:        {
       64: 3215:            unsigned char* write_ptr = &atlas->TexPixelsAlpha8[r->X + ((r->Y + y) * atlas->TexWidth)];
     1120: 3216:            for (unsigned int i = 0; i < pad_left; i++)
       64: 3216-block 14
     1120: 3216-block 16
branch  0 taken 1056
branch  1 taken 64 (fallthrough)
     1056: 3217:                *(write_ptr + i) = 0x00;
     1056: 3217-block 15
        -: 3218:
     2080: 3219:            for (unsigned int i = 0; i < line_width; i++)
       64: 3219-block 17
     2080: 3219-block 19
branch  0 taken 2016
branch  1 taken 64 (fallthrough)
     2016: 3220:                *(write_ptr + pad_left + i) = 0xFF;
     2016: 3220-block 18
        -: 3221:
     1152: 3222:            for (unsigned int i = 0; i < pad_right; i++)
       64: 3222-block 20
     1152: 3222-block 22
branch  0 taken 1088
branch  1 taken 64
     1088: 3223:                *(write_ptr + pad_left + line_width + i) = 0x00;
     1088: 3223-block 21
        -: 3224:        }
        -: 3225:        else
        -: 3226:        {
    #####: 3227:            unsigned int* write_ptr = &atlas->TexPixelsRGBA32[r->X + ((r->Y + y) * atlas->TexWidth)];
    #####: 3228:            for (unsigned int i = 0; i < pad_left; i++)
    %%%%%: 3228-block 23
    %%%%%: 3228-block 25
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3229:                *(write_ptr + i) = IM_COL32(255, 255, 255, 0);
    %%%%%: 3229-block 24
        -: 3230:
    #####: 3231:            for (unsigned int i = 0; i < line_width; i++)
    %%%%%: 3231-block 26
    %%%%%: 3231-block 28
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3232:                *(write_ptr + pad_left + i) = IM_COL32_WHITE;
    %%%%%: 3232-block 27
        -: 3233:
    #####: 3234:            for (unsigned int i = 0; i < pad_right; i++)
    %%%%%: 3234-block 29
    %%%%%: 3234-block 31
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3235:                *(write_ptr + pad_left + line_width + i) = IM_COL32(255, 255, 255, 0);
    %%%%%: 3235-block 30
        -: 3236:        }
        -: 3237:
        -: 3238:        // Calculate UVs for this line
       64: 3239:        ImVec2 uv0 = ImVec2((float)(r->X + pad_left - 1), (float)(r->Y + y)) * atlas->TexUvScale;
       64: 3239-block 32
call    0 returned 64
call    1 returned 64
       64: 3240:        ImVec2 uv1 = ImVec2((float)(r->X + pad_left + line_width + 1), (float)(r->Y + y + 1)) * atlas->TexUvScale;
call    0 returned 64
call    1 returned 64
       64: 3241:        float half_v = (uv0.y + uv1.y) * 0.5f; // Calculate a constant V in the middle of the row to avoid sampling artifacts
       64: 3242:        atlas->TexUvLines[n] = ImVec4(uv0.x, half_v, uv1.x, half_v);
call    0 returned 64
        -: 3243:    }
        -: 3244:}
        -: 3245:
        -: 3246:// Note: this is called / shared by both the stb_truetype and the FreeType builder
function _Z20ImFontAtlasBuildInitP11ImFontAtlas called 1 returned 100% blocks executed 88%
        1: 3247:void ImFontAtlasBuildInit(ImFontAtlas* atlas)
        -: 3248:{
        -: 3249:    // Round font size
        -: 3250:    // - We started rounding in 1.90 WIP (18991) as our layout system currently doesn't support non-rounded font size well yet.
        -: 3251:    // - Note that using io.FontGlobalScale or SetWindowFontScale(), with are legacy-ish, partially supported features, can still lead to unrounded sizes.
        -: 3252:    // - We may support it better later and remove this rounding.
       12: 3253:    for (ImFontConfig& cfg : atlas->ConfigData)
        1: 3253-block 2
call    0 returned 1
call    1 returned 1
       12: 3253-block 6
branch  2 taken 11
branch  3 taken 1 (fallthrough)
       11: 3254:       cfg.SizePixels = ImTrunc(cfg.SizePixels);
       11: 3254-block 4
call    0 returned 11
        -: 3255:
        -: 3256:    // Register texture region for mouse cursors or standard white pixels
        1: 3257:    if (atlas->PackIdMouseCursors < 0)
        1: 3257-block 7
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 3258:    {
        1: 3259:        if (!(atlas->Flags & ImFontAtlasFlags_NoMouseCursors))
        1: 3259-block 8
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 3260:            atlas->PackIdMouseCursors = atlas->AddCustomRectRegular(FONT_ATLAS_DEFAULT_TEX_DATA_W * 2 + 1, FONT_ATLAS_DEFAULT_TEX_DATA_H);
        1: 3260-block 9
call    0 returned 1
        -: 3261:        else
    #####: 3262:            atlas->PackIdMouseCursors = atlas->AddCustomRectRegular(2, 2);
    %%%%%: 3262-block 11
call    0 never executed
        -: 3263:    }
        -: 3264:
        -: 3265:    // Register texture region for thick lines
        -: 3266:    // The +2 here is to give space for the end caps, whilst height +1 is to accommodate the fact we have a zero-width row
        1: 3267:    if (atlas->PackIdLines < 0)
        1: 3267-block 13
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 3268:    {
        1: 3269:        if (!(atlas->Flags & ImFontAtlasFlags_NoBakedLines))
        1: 3269-block 14
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 3270:            atlas->PackIdLines = atlas->AddCustomRectRegular(IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 2, IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 1);
        1: 3270-block 15
call    0 returned 1
        -: 3271:    }
        1: 3272:}
        -: 3273:
        -: 3274:// This is called/shared by both the stb_truetype and the FreeType builder.
function _Z22ImFontAtlasBuildFinishP11ImFontAtlas called 1 returned 100% blocks executed 68%
        1: 3275:void ImFontAtlasBuildFinish(ImFontAtlas* atlas)
        -: 3276:{
        -: 3277:    // Render into our custom data blocks
       1*: 3278:    IM_ASSERT(atlas->TexPixelsAlpha8 != NULL || atlas->TexPixelsRGBA32 != NULL);
        1: 3278-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 3278-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3278-block 4
call    4 never executed
        1: 3279:    ImFontAtlasBuildRenderDefaultTexData(atlas);
        1: 3279-block 5
call    0 returned 1
        1: 3280:    ImFontAtlasBuildRenderLinesTexData(atlas);
call    0 returned 1
        -: 3281:
        -: 3282:    // Register custom rectangle glyphs
        3: 3283:    for (int i = 0; i < atlas->CustomRects.Size; i++)
        2: 3283-block 17
        3: 3283-block 18
branch  0 taken 2
branch  1 taken 1 (fallthrough)
        -: 3284:    {
        2: 3285:        const ImFontAtlasCustomRect* r = &atlas->CustomRects[i];
        2: 3285-block 8
call    0 returned 2
       2*: 3286:        if (r->Font == NULL || r->GlyphID == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%: 3286-block 10
branch  2 never executed (fallthrough)
branch  3 never executed
        2: 3287:            continue;
        2: 3287-block 11
        -: 3288:
        -: 3289:        // Will ignore ImFontConfig settings: GlyphMinAdvanceX, GlyphMinAdvanceY, GlyphExtraSpacing, PixelSnapH
    #####: 3290:        IM_ASSERT(r->Font->ContainerAtlas == atlas);
    %%%%%: 3290-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3290-block 13
call    2 never executed
    #####: 3291:        ImVec2 uv0, uv1;
    #####: 3292:        atlas->CalcCustomRectUV(r, &uv0, &uv1);
    %%%%%: 3292-block 14
call    0 never executed
    #####: 3293:        r->Font->AddGlyph(NULL, (ImWchar)r->GlyphID, r->GlyphOffset.x, r->GlyphOffset.y, r->GlyphOffset.x + r->Width, r->GlyphOffset.y + r->Height, uv0.x, uv0.y, uv1.x, uv1.y, r->GlyphAdvanceX);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 3294:    }
        -: 3295:
        -: 3296:    // Build all fonts lookup tables
       11: 3297:    for (ImFont* font : atlas->Fonts)
        1: 3297-block 19
call    0 returned 1
call    1 returned 1
       10: 3297-block 23
       11: 3297-block 24
branch  2 taken 10
branch  3 taken 1 (fallthrough)
       10: 3298:        if (font->DirtyLookupTables)
       10: 3298-block 21
branch  0 taken 10 (fallthrough)
branch  1 taken 0
       10: 3299:            font->BuildLookupTable();
       10: 3299-block 22
call    0 returned 10
        -: 3300:
        1: 3301:    atlas->TexReady = true;
        1: 3302:}
        1: 3302-block 25
        -: 3303:
        -: 3304:// Retrieve list of range (2 int per range, values are inclusive)
function _ZN11ImFontAtlas21GetGlyphRangesDefaultEv called 10 returned 100% blocks executed 100%
       10: 3305:const ImWchar*   ImFontAtlas::GetGlyphRangesDefault()
        -: 3306:{
        -: 3307:    static const ImWchar ranges[] =
        -: 3308:    {
        -: 3309:        0x0020, 0x00FF, // Basic Latin + Latin Supplement
        -: 3310:        0,
        -: 3311:    };
       10: 3312:    return &ranges[0];
       10: 3312-block 2
        -: 3313:}
        -: 3314:
function _ZN11ImFontAtlas19GetGlyphRangesGreekEv called 0 returned 0% blocks executed 0%
    #####: 3315:const ImWchar*   ImFontAtlas::GetGlyphRangesGreek()
        -: 3316:{
        -: 3317:    static const ImWchar ranges[] =
        -: 3318:    {
        -: 3319:        0x0020, 0x00FF, // Basic Latin + Latin Supplement
        -: 3320:        0x0370, 0x03FF, // Greek and Coptic
        -: 3321:        0,
        -: 3322:    };
    #####: 3323:    return &ranges[0];
    %%%%%: 3323-block 2
        -: 3324:}
        -: 3325:
function _ZN11ImFontAtlas20GetGlyphRangesKoreanEv called 0 returned 0% blocks executed 0%
    #####: 3326:const ImWchar*  ImFontAtlas::GetGlyphRangesKorean()
        -: 3327:{
        -: 3328:    static const ImWchar ranges[] =
        -: 3329:    {
        -: 3330:        0x0020, 0x00FF, // Basic Latin + Latin Supplement
        -: 3331:        0x3131, 0x3163, // Korean alphabets
        -: 3332:        0xAC00, 0xD7A3, // Korean characters
        -: 3333:        0xFFFD, 0xFFFD, // Invalid
        -: 3334:        0,
        -: 3335:    };
    #####: 3336:    return &ranges[0];
    %%%%%: 3336-block 2
        -: 3337:}
        -: 3338:
function _ZN11ImFontAtlas25GetGlyphRangesChineseFullEv called 0 returned 0% blocks executed 0%
    #####: 3339:const ImWchar*  ImFontAtlas::GetGlyphRangesChineseFull()
        -: 3340:{
        -: 3341:    static const ImWchar ranges[] =
        -: 3342:    {
        -: 3343:        0x0020, 0x00FF, // Basic Latin + Latin Supplement
        -: 3344:        0x2000, 0x206F, // General Punctuation
        -: 3345:        0x3000, 0x30FF, // CJK Symbols and Punctuations, Hiragana, Katakana
        -: 3346:        0x31F0, 0x31FF, // Katakana Phonetic Extensions
        -: 3347:        0xFF00, 0xFFEF, // Half-width characters
        -: 3348:        0xFFFD, 0xFFFD, // Invalid
        -: 3349:        0x4e00, 0x9FAF, // CJK Ideograms
        -: 3350:        0,
        -: 3351:    };
    #####: 3352:    return &ranges[0];
    %%%%%: 3352-block 2
        -: 3353:}
        -: 3354:
function _ZL35UnpackAccumulativeOffsetsIntoRangesiPKsiPt called 0 returned 0% blocks executed 0%
    #####: 3355:static void UnpackAccumulativeOffsetsIntoRanges(int base_codepoint, const short* accumulative_offsets, int accumulative_offsets_count, ImWchar* out_ranges)
        -: 3356:{
    #####: 3357:    for (int n = 0; n < accumulative_offsets_count; n++, out_ranges += 2)
    %%%%%: 3357-block 2
    %%%%%: 3357-block 4
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 3358:    {
    #####: 3359:        out_ranges[0] = out_ranges[1] = (ImWchar)(base_codepoint + accumulative_offsets[n]);
    #####: 3360:        base_codepoint += accumulative_offsets[n];
    %%%%%: 3360-block 3
        -: 3361:    }
    #####: 3362:    out_ranges[0] = 0;
    #####: 3363:}
        -: 3364:
        -: 3365://-------------------------------------------------------------------------
        -: 3366:// [SECTION] ImFontAtlas glyph ranges helpers
        -: 3367://-------------------------------------------------------------------------
        -: 3368:
function _ZN11ImFontAtlas37GetGlyphRangesChineseSimplifiedCommonEv called 0 returned 0% blocks executed 0%
    #####: 3369:const ImWchar*  ImFontAtlas::GetGlyphRangesChineseSimplifiedCommon()
        -: 3370:{
        -: 3371:    // Store 2500 regularly used characters for Simplified Chinese.
        -: 3372:    // Sourced from https://zh.wiktionary.org/wiki/%E9%99%84%E5%BD%95:%E7%8E%B0%E4%BB%A3%E6%B1%89%E8%AF%AD%E5%B8%B8%E7%94%A8%E5%AD%97%E8%A1%A8
        -: 3373:    // This table covers 97.97% of all characters used during the month in July, 1987.
        -: 3374:    // You can use ImFontGlyphRangesBuilder to create your own ranges derived from this, by merging existing ranges or adding new characters.
        -: 3375:    // (Stored as accumulative offsets from the initial unicode codepoint 0x4E00. This encoding is designed to helps us compact the source code size.)
        -: 3376:    static const short accumulative_offsets_from_0x4E00[] =
        -: 3377:    {
        -: 3378:        0,1,2,4,1,1,1,1,2,1,3,2,1,2,2,1,1,1,1,1,5,2,1,2,3,3,3,2,2,4,1,1,1,2,1,5,2,3,1,2,1,2,1,1,2,1,1,2,2,1,4,1,1,1,1,5,10,1,2,19,2,1,2,1,2,1,2,1,2,
        -: 3379:        1,5,1,6,3,2,1,2,2,1,1,1,4,8,5,1,1,4,1,1,3,1,2,1,5,1,2,1,1,1,10,1,1,5,2,4,6,1,4,2,2,2,12,2,1,1,6,1,1,1,4,1,1,4,6,5,1,4,2,2,4,10,7,1,1,4,2,4,
        -: 3380:        2,1,4,3,6,10,12,5,7,2,14,2,9,1,1,6,7,10,4,7,13,1,5,4,8,4,1,1,2,28,5,6,1,1,5,2,5,20,2,2,9,8,11,2,9,17,1,8,6,8,27,4,6,9,20,11,27,6,68,2,2,1,1,
        -: 3381:        1,2,1,2,2,7,6,11,3,3,1,1,3,1,2,1,1,1,1,1,3,1,1,8,3,4,1,5,7,2,1,4,4,8,4,2,1,2,1,1,4,5,6,3,6,2,12,3,1,3,9,2,4,3,4,1,5,3,3,1,3,7,1,5,1,1,1,1,2,
        -: 3382:        3,4,5,2,3,2,6,1,1,2,1,7,1,7,3,4,5,15,2,2,1,5,3,22,19,2,1,1,1,1,2,5,1,1,1,6,1,1,12,8,2,9,18,22,4,1,1,5,1,16,1,2,7,10,15,1,1,6,2,4,1,2,4,1,6,
        -: 3383:        1,1,3,2,4,1,6,4,5,1,2,1,1,2,1,10,3,1,3,2,1,9,3,2,5,7,2,19,4,3,6,1,1,1,1,1,4,3,2,1,1,1,2,5,3,1,1,1,2,2,1,1,2,1,1,2,1,3,1,1,1,3,7,1,4,1,1,2,1,
        -: 3384:        1,2,1,2,4,4,3,8,1,1,1,2,1,3,5,1,3,1,3,4,6,2,2,14,4,6,6,11,9,1,15,3,1,28,5,2,5,5,3,1,3,4,5,4,6,14,3,2,3,5,21,2,7,20,10,1,2,19,2,4,28,28,2,3,
        -: 3385:        2,1,14,4,1,26,28,42,12,40,3,52,79,5,14,17,3,2,2,11,3,4,6,3,1,8,2,23,4,5,8,10,4,2,7,3,5,1,1,6,3,1,2,2,2,5,28,1,1,7,7,20,5,3,29,3,17,26,1,8,4,
        -: 3386:        27,3,6,11,23,5,3,4,6,13,24,16,6,5,10,25,35,7,3,2,3,3,14,3,6,2,6,1,4,2,3,8,2,1,1,3,3,3,4,1,1,13,2,2,4,5,2,1,14,14,1,2,2,1,4,5,2,3,1,14,3,12,
        -: 3387:        3,17,2,16,5,1,2,1,8,9,3,19,4,2,2,4,17,25,21,20,28,75,1,10,29,103,4,1,2,1,1,4,2,4,1,2,3,24,2,2,2,1,1,2,1,3,8,1,1,1,2,1,1,3,1,1,1,6,1,5,3,1,1,
        -: 3388:        1,3,4,1,1,5,2,1,5,6,13,9,16,1,1,1,1,3,2,3,2,4,5,2,5,2,2,3,7,13,7,2,2,1,1,1,1,2,3,3,2,1,6,4,9,2,1,14,2,14,2,1,18,3,4,14,4,11,41,15,23,15,23,
        -: 3389:        176,1,3,4,1,1,1,1,5,3,1,2,3,7,3,1,1,2,1,2,4,4,6,2,4,1,9,7,1,10,5,8,16,29,1,1,2,2,3,1,3,5,2,4,5,4,1,1,2,2,3,3,7,1,6,10,1,17,1,44,4,6,2,1,1,6,
        -: 3390:        5,4,2,10,1,6,9,2,8,1,24,1,2,13,7,8,8,2,1,4,1,3,1,3,3,5,2,5,10,9,4,9,12,2,1,6,1,10,1,1,7,7,4,10,8,3,1,13,4,3,1,6,1,3,5,2,1,2,17,16,5,2,16,6,
        -: 3391:        1,4,2,1,3,3,6,8,5,11,11,1,3,3,2,4,6,10,9,5,7,4,7,4,7,1,1,4,2,1,3,6,8,7,1,6,11,5,5,3,24,9,4,2,7,13,5,1,8,82,16,61,1,1,1,4,2,2,16,10,3,8,1,1,
        -: 3392:        6,4,2,1,3,1,1,1,4,3,8,4,2,2,1,1,1,1,1,6,3,5,1,1,4,6,9,2,1,1,1,2,1,7,2,1,6,1,5,4,4,3,1,8,1,3,3,1,3,2,2,2,2,3,1,6,1,2,1,2,1,3,7,1,8,2,1,2,1,5,
        -: 3393:        2,5,3,5,10,1,2,1,1,3,2,5,11,3,9,3,5,1,1,5,9,1,2,1,5,7,9,9,8,1,3,3,3,6,8,2,3,2,1,1,32,6,1,2,15,9,3,7,13,1,3,10,13,2,14,1,13,10,2,1,3,10,4,15,
        -: 3394:        2,15,15,10,1,3,9,6,9,32,25,26,47,7,3,2,3,1,6,3,4,3,2,8,5,4,1,9,4,2,2,19,10,6,2,3,8,1,2,2,4,2,1,9,4,4,4,6,4,8,9,2,3,1,1,1,1,3,5,5,1,3,8,4,6,
        -: 3395:        2,1,4,12,1,5,3,7,13,2,5,8,1,6,1,2,5,14,6,1,5,2,4,8,15,5,1,23,6,62,2,10,1,1,8,1,2,2,10,4,2,2,9,2,1,1,3,2,3,1,5,3,3,2,1,3,8,1,1,1,11,3,1,1,4,
        -: 3396:        3,7,1,14,1,2,3,12,5,2,5,1,6,7,5,7,14,11,1,3,1,8,9,12,2,1,11,8,4,4,2,6,10,9,13,1,1,3,1,5,1,3,2,4,4,1,18,2,3,14,11,4,29,4,2,7,1,3,13,9,2,2,5,
        -: 3397:        3,5,20,7,16,8,5,72,34,6,4,22,12,12,28,45,36,9,7,39,9,191,1,1,1,4,11,8,4,9,2,3,22,1,1,1,1,4,17,1,7,7,1,11,31,10,2,4,8,2,3,2,1,4,2,16,4,32,2,
        -: 3398:        3,19,13,4,9,1,5,2,14,8,1,1,3,6,19,6,5,1,16,6,2,10,8,5,1,2,3,1,5,5,1,11,6,6,1,3,3,2,6,3,8,1,1,4,10,7,5,7,7,5,8,9,2,1,3,4,1,1,3,1,3,3,2,6,16,
        -: 3399:        1,4,6,3,1,10,6,1,3,15,2,9,2,10,25,13,9,16,6,2,2,10,11,4,3,9,1,2,6,6,5,4,30,40,1,10,7,12,14,33,6,3,6,7,3,1,3,1,11,14,4,9,5,12,11,49,18,51,31,
        -: 3400:        140,31,2,2,1,5,1,8,1,10,1,4,4,3,24,1,10,1,3,6,6,16,3,4,5,2,1,4,2,57,10,6,22,2,22,3,7,22,6,10,11,36,18,16,33,36,2,5,5,1,1,1,4,10,1,4,13,2,7,
        -: 3401:        5,2,9,3,4,1,7,43,3,7,3,9,14,7,9,1,11,1,1,3,7,4,18,13,1,14,1,3,6,10,73,2,2,30,6,1,11,18,19,13,22,3,46,42,37,89,7,3,16,34,2,2,3,9,1,7,1,1,1,2,
        -: 3402:        2,4,10,7,3,10,3,9,5,28,9,2,6,13,7,3,1,3,10,2,7,2,11,3,6,21,54,85,2,1,4,2,2,1,39,3,21,2,2,5,1,1,1,4,1,1,3,4,15,1,3,2,4,4,2,3,8,2,20,1,8,7,13,
        -: 3403:        4,1,26,6,2,9,34,4,21,52,10,4,4,1,5,12,2,11,1,7,2,30,12,44,2,30,1,1,3,6,16,9,17,39,82,2,2,24,7,1,7,3,16,9,14,44,2,1,2,1,2,3,5,2,4,1,6,7,5,3,
        -: 3404:        2,6,1,11,5,11,2,1,18,19,8,1,3,24,29,2,1,3,5,2,2,1,13,6,5,1,46,11,3,5,1,1,5,8,2,10,6,12,6,3,7,11,2,4,16,13,2,5,1,1,2,2,5,2,28,5,2,23,10,8,4,
        -: 3405:        4,22,39,95,38,8,14,9,5,1,13,5,4,3,13,12,11,1,9,1,27,37,2,5,4,4,63,211,95,2,2,2,1,3,5,2,1,1,2,2,1,1,1,3,2,4,1,2,1,1,5,2,2,1,1,2,3,1,3,1,1,1,
        -: 3406:        3,1,4,2,1,3,6,1,1,3,7,15,5,3,2,5,3,9,11,4,2,22,1,6,3,8,7,1,4,28,4,16,3,3,25,4,4,27,27,1,4,1,2,2,7,1,3,5,2,28,8,2,14,1,8,6,16,25,3,3,3,14,3,
        -: 3407:        3,1,1,2,1,4,6,3,8,4,1,1,1,2,3,6,10,6,2,3,18,3,2,5,5,4,3,1,5,2,5,4,23,7,6,12,6,4,17,11,9,5,1,1,10,5,12,1,1,11,26,33,7,3,6,1,17,7,1,5,12,1,11,
        -: 3408:        2,4,1,8,14,17,23,1,2,1,7,8,16,11,9,6,5,2,6,4,16,2,8,14,1,11,8,9,1,1,1,9,25,4,11,19,7,2,15,2,12,8,52,7,5,19,2,16,4,36,8,1,16,8,24,26,4,6,2,9,
        -: 3409:        5,4,36,3,28,12,25,15,37,27,17,12,59,38,5,32,127,1,2,9,17,14,4,1,2,1,1,8,11,50,4,14,2,19,16,4,17,5,4,5,26,12,45,2,23,45,104,30,12,8,3,10,2,2,
        -: 3410:        3,3,1,4,20,7,2,9,6,15,2,20,1,3,16,4,11,15,6,134,2,5,59,1,2,2,2,1,9,17,3,26,137,10,211,59,1,2,4,1,4,1,1,1,2,6,2,3,1,1,2,3,2,3,1,3,4,4,2,3,3,
        -: 3411:        1,4,3,1,7,2,2,3,1,2,1,3,3,3,2,2,3,2,1,3,14,6,1,3,2,9,6,15,27,9,34,145,1,1,2,1,1,1,1,2,1,1,1,1,2,2,2,3,1,2,1,1,1,2,3,5,8,3,5,2,4,1,3,2,2,2,12,
        -: 3412:        4,1,1,1,10,4,5,1,20,4,16,1,15,9,5,12,2,9,2,5,4,2,26,19,7,1,26,4,30,12,15,42,1,6,8,172,1,1,4,2,1,1,11,2,2,4,2,1,2,1,10,8,1,2,1,4,5,1,2,5,1,8,
        -: 3413:        4,1,3,4,2,1,6,2,1,3,4,1,2,1,1,1,1,12,5,7,2,4,3,1,1,1,3,3,6,1,2,2,3,3,3,2,1,2,12,14,11,6,6,4,12,2,8,1,7,10,1,35,7,4,13,15,4,3,23,21,28,52,5,
        -: 3414:        26,5,6,1,7,10,2,7,53,3,2,1,1,1,2,163,532,1,10,11,1,3,3,4,8,2,8,6,2,2,23,22,4,2,2,4,2,1,3,1,3,3,5,9,8,2,1,2,8,1,10,2,12,21,20,15,105,2,3,1,1,
        -: 3415:        3,2,3,1,1,2,5,1,4,15,11,19,1,1,1,1,5,4,5,1,1,2,5,3,5,12,1,2,5,1,11,1,1,15,9,1,4,5,3,26,8,2,1,3,1,1,15,19,2,12,1,2,5,2,7,2,19,2,20,6,26,7,5,
        -: 3416:        2,2,7,34,21,13,70,2,128,1,1,2,1,1,2,1,1,3,2,2,2,15,1,4,1,3,4,42,10,6,1,49,85,8,1,2,1,1,4,4,2,3,6,1,5,7,4,3,211,4,1,2,1,2,5,1,2,4,2,2,6,5,6,
        -: 3417:        10,3,4,48,100,6,2,16,296,5,27,387,2,2,3,7,16,8,5,38,15,39,21,9,10,3,7,59,13,27,21,47,5,21,6
        -: 3418:    };
        -: 3419:    static ImWchar base_ranges[] = // not zero-terminated
        -: 3420:    {
        -: 3421:        0x0020, 0x00FF, // Basic Latin + Latin Supplement
        -: 3422:        0x2000, 0x206F, // General Punctuation
        -: 3423:        0x3000, 0x30FF, // CJK Symbols and Punctuations, Hiragana, Katakana
        -: 3424:        0x31F0, 0x31FF, // Katakana Phonetic Extensions
        -: 3425:        0xFF00, 0xFFEF, // Half-width characters
        -: 3426:        0xFFFD, 0xFFFD  // Invalid
        -: 3427:    };
        -: 3428:    static ImWchar full_ranges[IM_ARRAYSIZE(base_ranges) + IM_ARRAYSIZE(accumulative_offsets_from_0x4E00) * 2 + 1] = { 0 };
    #####: 3429:    if (!full_ranges[0])
    %%%%%: 3429-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3430:    {
    #####: 3431:        memcpy(full_ranges, base_ranges, sizeof(base_ranges));
    #####: 3432:        UnpackAccumulativeOffsetsIntoRanges(0x4E00, accumulative_offsets_from_0x4E00, IM_ARRAYSIZE(accumulative_offsets_from_0x4E00), full_ranges + IM_ARRAYSIZE(base_ranges));
    %%%%%: 3432-block 3
call    0 never executed
        -: 3433:    }
    #####: 3434:    return &full_ranges[0];
    %%%%%: 3434-block 4
        -: 3435:}
        -: 3436:
function _ZN11ImFontAtlas22GetGlyphRangesJapaneseEv called 0 returned 0% blocks executed 0%
    #####: 3437:const ImWchar*  ImFontAtlas::GetGlyphRangesJapanese()
        -: 3438:{
        -: 3439:    // 2999 ideograms code points for Japanese
        -: 3440:    // - 2136 Joyo (meaning "for regular use" or "for common use") Kanji code points
        -: 3441:    // - 863 Jinmeiyo (meaning "for personal name") Kanji code points
        -: 3442:    // - Sourced from official information provided by the government agencies of Japan:
        -: 3443:    //   - List of Joyo Kanji by the Agency for Cultural Affairs
        -: 3444:    //     - https://www.bunka.go.jp/kokugo_nihongo/sisaku/joho/joho/kijun/naikaku/kanji/
        -: 3445:    //   - List of Jinmeiyo Kanji by the Ministry of Justice
        -: 3446:    //     - http://www.moj.go.jp/MINJI/minji86.html
        -: 3447:    //   - Available under the terms of the Creative Commons Attribution 4.0 International (CC BY 4.0).
        -: 3448:    //     - https://creativecommons.org/licenses/by/4.0/legalcode
        -: 3449:    // - You can generate this code by the script at:
        -: 3450:    //   - https://github.com/vaiorabbit/everyday_use_kanji
        -: 3451:    // - References:
        -: 3452:    //   - List of Joyo Kanji
        -: 3453:    //     - (Wikipedia) https://en.wikipedia.org/wiki/List_of_j%C5%8Dy%C5%8D_kanji
        -: 3454:    //   - List of Jinmeiyo Kanji
        -: 3455:    //     - (Wikipedia) https://en.wikipedia.org/wiki/Jinmeiy%C5%8D_kanji
        -: 3456:    // - Missing 1 Joyo Kanji: U+20B9F (Kun'yomi: Shikaru, On'yomi: Shitsu,shichi), see https://github.com/ocornut/imgui/pull/3627 for details.
        -: 3457:    // You can use ImFontGlyphRangesBuilder to create your own ranges derived from this, by merging existing ranges or adding new characters.
        -: 3458:    // (Stored as accumulative offsets from the initial unicode codepoint 0x4E00. This encoding is designed to helps us compact the source code size.)
        -: 3459:    static const short accumulative_offsets_from_0x4E00[] =
        -: 3460:    {
        -: 3461:        0,1,2,4,1,1,1,1,2,1,3,3,2,2,1,5,3,5,7,5,6,1,2,1,7,2,6,3,1,8,1,1,4,1,1,18,2,11,2,6,2,1,2,1,5,1,2,1,3,1,2,1,2,3,3,1,1,2,3,1,1,1,12,7,9,1,4,5,1,
        -: 3462:        1,2,1,10,1,1,9,2,2,4,5,6,9,3,1,1,1,1,9,3,18,5,2,2,2,2,1,6,3,7,1,1,1,1,2,2,4,2,1,23,2,10,4,3,5,2,4,10,2,4,13,1,6,1,9,3,1,1,6,6,7,6,3,1,2,11,3,
        -: 3463:        2,2,3,2,15,2,2,5,4,3,6,4,1,2,5,2,12,16,6,13,9,13,2,1,1,7,16,4,7,1,19,1,5,1,2,2,7,7,8,2,6,5,4,9,18,7,4,5,9,13,11,8,15,2,1,1,1,2,1,2,2,1,2,2,8,
        -: 3464:        2,9,3,3,1,1,4,4,1,1,1,4,9,1,4,3,5,5,2,7,5,3,4,8,2,1,13,2,3,3,1,14,1,1,4,5,1,3,6,1,5,2,1,1,3,3,3,3,1,1,2,7,6,6,7,1,4,7,6,1,1,1,1,1,12,3,3,9,5,
        -: 3465:        2,6,1,5,6,1,2,3,18,2,4,14,4,1,3,6,1,1,6,3,5,5,3,2,2,2,2,12,3,1,4,2,3,2,3,11,1,7,4,1,2,1,3,17,1,9,1,24,1,1,4,2,2,4,1,2,7,1,1,1,3,1,2,2,4,15,1,
        -: 3466:        1,2,1,1,2,1,5,2,5,20,2,5,9,1,10,8,7,6,1,1,1,1,1,1,6,2,1,2,8,1,1,1,1,5,1,1,3,1,1,1,1,3,1,1,12,4,1,3,1,1,1,1,1,10,3,1,7,5,13,1,2,3,4,6,1,1,30,
        -: 3467:        2,9,9,1,15,38,11,3,1,8,24,7,1,9,8,10,2,1,9,31,2,13,6,2,9,4,49,5,2,15,2,1,10,2,1,1,1,2,2,6,15,30,35,3,14,18,8,1,16,10,28,12,19,45,38,1,3,2,3,
        -: 3468:        13,2,1,7,3,6,5,3,4,3,1,5,7,8,1,5,3,18,5,3,6,1,21,4,24,9,24,40,3,14,3,21,3,2,1,2,4,2,3,1,15,15,6,5,1,1,3,1,5,6,1,9,7,3,3,2,1,4,3,8,21,5,16,4,
        -: 3469:        5,2,10,11,11,3,6,3,2,9,3,6,13,1,2,1,1,1,1,11,12,6,6,1,4,2,6,5,2,1,1,3,3,6,13,3,1,1,5,1,2,3,3,14,2,1,2,2,2,5,1,9,5,1,1,6,12,3,12,3,4,13,2,14,
        -: 3470:        2,8,1,17,5,1,16,4,2,2,21,8,9,6,23,20,12,25,19,9,38,8,3,21,40,25,33,13,4,3,1,4,1,2,4,1,2,5,26,2,1,1,2,1,3,6,2,1,1,1,1,1,1,2,3,1,1,1,9,2,3,1,1,
        -: 3471:        1,3,6,3,2,1,1,6,6,1,8,2,2,2,1,4,1,2,3,2,7,3,2,4,1,2,1,2,2,1,1,1,1,1,3,1,2,5,4,10,9,4,9,1,1,1,1,1,1,5,3,2,1,6,4,9,6,1,10,2,31,17,8,3,7,5,40,1,
        -: 3472:        7,7,1,6,5,2,10,7,8,4,15,39,25,6,28,47,18,10,7,1,3,1,1,2,1,1,1,3,3,3,1,1,1,3,4,2,1,4,1,3,6,10,7,8,6,2,2,1,3,3,2,5,8,7,9,12,2,15,1,1,4,1,2,1,1,
        -: 3473:        1,3,2,1,3,3,5,6,2,3,2,10,1,4,2,8,1,1,1,11,6,1,21,4,16,3,1,3,1,4,2,3,6,5,1,3,1,1,3,3,4,6,1,1,10,4,2,7,10,4,7,4,2,9,4,3,1,1,1,4,1,8,3,4,1,3,1,
        -: 3474:        6,1,4,2,1,4,7,2,1,8,1,4,5,1,1,2,2,4,6,2,7,1,10,1,1,3,4,11,10,8,21,4,6,1,3,5,2,1,2,28,5,5,2,3,13,1,2,3,1,4,2,1,5,20,3,8,11,1,3,3,3,1,8,10,9,2,
        -: 3475:        10,9,2,3,1,1,2,4,1,8,3,6,1,7,8,6,11,1,4,29,8,4,3,1,2,7,13,1,4,1,6,2,6,12,12,2,20,3,2,3,6,4,8,9,2,7,34,5,1,18,6,1,1,4,4,5,7,9,1,2,2,4,3,4,1,7,
        -: 3476:        2,2,2,6,2,3,25,5,3,6,1,4,6,7,4,2,1,4,2,13,6,4,4,3,1,5,3,4,4,3,2,1,1,4,1,2,1,1,3,1,11,1,6,3,1,7,3,6,2,8,8,6,9,3,4,11,3,2,10,12,2,5,11,1,6,4,5,
        -: 3477:        3,1,8,5,4,6,6,3,5,1,1,3,2,1,2,2,6,17,12,1,10,1,6,12,1,6,6,19,9,6,16,1,13,4,4,15,7,17,6,11,9,15,12,6,7,2,1,2,2,15,9,3,21,4,6,49,18,7,3,2,3,1,
        -: 3478:        6,8,2,2,6,2,9,1,3,6,4,4,1,2,16,2,5,2,1,6,2,3,5,3,1,2,5,1,2,1,9,3,1,8,6,4,8,11,3,1,1,1,1,3,1,13,8,4,1,3,2,2,1,4,1,11,1,5,2,1,5,2,5,8,6,1,1,7,
        -: 3479:        4,3,8,3,2,7,2,1,5,1,5,2,4,7,6,2,8,5,1,11,4,5,3,6,18,1,2,13,3,3,1,21,1,1,4,1,4,1,1,1,8,1,2,2,7,1,2,4,2,2,9,2,1,1,1,4,3,6,3,12,5,1,1,1,5,6,3,2,
        -: 3480:        4,8,2,2,4,2,7,1,8,9,5,2,3,2,1,3,2,13,7,14,6,5,1,1,2,1,4,2,23,2,1,1,6,3,1,4,1,15,3,1,7,3,9,14,1,3,1,4,1,1,5,8,1,3,8,3,8,15,11,4,14,4,4,2,5,5,
        -: 3481:        1,7,1,6,14,7,7,8,5,15,4,8,6,5,6,2,1,13,1,20,15,11,9,2,5,6,2,11,2,6,2,5,1,5,8,4,13,19,25,4,1,1,11,1,34,2,5,9,14,6,2,2,6,1,1,14,1,3,14,13,1,6,
        -: 3482:        12,21,14,14,6,32,17,8,32,9,28,1,2,4,11,8,3,1,14,2,5,15,1,1,1,1,3,6,4,1,3,4,11,3,1,1,11,30,1,5,1,4,1,5,8,1,1,3,2,4,3,17,35,2,6,12,17,3,1,6,2,
        -: 3483:        1,1,12,2,7,3,3,2,1,16,2,8,3,6,5,4,7,3,3,8,1,9,8,5,1,2,1,3,2,8,1,2,9,12,1,1,2,3,8,3,24,12,4,3,7,5,8,3,3,3,3,3,3,1,23,10,3,1,2,2,6,3,1,16,1,16,
        -: 3484:        22,3,10,4,11,6,9,7,7,3,6,2,2,2,4,10,2,1,1,2,8,7,1,6,4,1,3,3,3,5,10,12,12,2,3,12,8,15,1,1,16,6,6,1,5,9,11,4,11,4,2,6,12,1,17,5,13,1,4,9,5,1,11,
        -: 3485:        2,1,8,1,5,7,28,8,3,5,10,2,17,3,38,22,1,2,18,12,10,4,38,18,1,4,44,19,4,1,8,4,1,12,1,4,31,12,1,14,7,75,7,5,10,6,6,13,3,2,11,11,3,2,5,28,15,6,18,
        -: 3486:        18,5,6,4,3,16,1,7,18,7,36,3,5,3,1,7,1,9,1,10,7,2,4,2,6,2,9,7,4,3,32,12,3,7,10,2,23,16,3,1,12,3,31,4,11,1,3,8,9,5,1,30,15,6,12,3,2,2,11,19,9,
        -: 3487:        14,2,6,2,3,19,13,17,5,3,3,25,3,14,1,1,1,36,1,3,2,19,3,13,36,9,13,31,6,4,16,34,2,5,4,2,3,3,5,1,1,1,4,3,1,17,3,2,3,5,3,1,3,2,3,5,6,3,12,11,1,3,
        -: 3488:        1,2,26,7,12,7,2,14,3,3,7,7,11,25,25,28,16,4,36,1,2,1,6,2,1,9,3,27,17,4,3,4,13,4,1,3,2,2,1,10,4,2,4,6,3,8,2,1,18,1,1,24,2,2,4,33,2,3,63,7,1,6,
        -: 3489:        40,7,3,4,4,2,4,15,18,1,16,1,1,11,2,41,14,1,3,18,13,3,2,4,16,2,17,7,15,24,7,18,13,44,2,2,3,6,1,1,7,5,1,7,1,4,3,3,5,10,8,2,3,1,8,1,1,27,4,2,1,
        -: 3490:        12,1,2,1,10,6,1,6,7,5,2,3,7,11,5,11,3,6,6,2,3,15,4,9,1,1,2,1,2,11,2,8,12,8,5,4,2,3,1,5,2,2,1,14,1,12,11,4,1,11,17,17,4,3,2,5,5,7,3,1,5,9,9,8,
        -: 3491:        2,5,6,6,13,13,2,1,2,6,1,2,2,49,4,9,1,2,10,16,7,8,4,3,2,23,4,58,3,29,1,14,19,19,11,11,2,7,5,1,3,4,6,2,18,5,12,12,17,17,3,3,2,4,1,6,2,3,4,3,1,
        -: 3492:        1,1,1,5,1,1,9,1,3,1,3,6,1,8,1,1,2,6,4,14,3,1,4,11,4,1,3,32,1,2,4,13,4,1,2,4,2,1,3,1,11,1,4,2,1,4,4,6,3,5,1,6,5,7,6,3,23,3,5,3,5,3,3,13,3,9,10,
        -: 3493:        1,12,10,2,3,18,13,7,160,52,4,2,2,3,2,14,5,4,12,4,6,4,1,20,4,11,6,2,12,27,1,4,1,2,2,7,4,5,2,28,3,7,25,8,3,19,3,6,10,2,2,1,10,2,5,4,1,3,4,1,5,
        -: 3494:        3,2,6,9,3,6,2,16,3,3,16,4,5,5,3,2,1,2,16,15,8,2,6,21,2,4,1,22,5,8,1,1,21,11,2,1,11,11,19,13,12,4,2,3,2,3,6,1,8,11,1,4,2,9,5,2,1,11,2,9,1,1,2,
        -: 3495:        14,31,9,3,4,21,14,4,8,1,7,2,2,2,5,1,4,20,3,3,4,10,1,11,9,8,2,1,4,5,14,12,14,2,17,9,6,31,4,14,1,20,13,26,5,2,7,3,6,13,2,4,2,19,6,2,2,18,9,3,5,
        -: 3496:        12,12,14,4,6,2,3,6,9,5,22,4,5,25,6,4,8,5,2,6,27,2,35,2,16,3,7,8,8,6,6,5,9,17,2,20,6,19,2,13,3,1,1,1,4,17,12,2,14,7,1,4,18,12,38,33,2,10,1,1,
        -: 3497:        2,13,14,17,11,50,6,33,20,26,74,16,23,45,50,13,38,33,6,6,7,4,4,2,1,3,2,5,8,7,8,9,3,11,21,9,13,1,3,10,6,7,1,2,2,18,5,5,1,9,9,2,68,9,19,13,2,5,
        -: 3498:        1,4,4,7,4,13,3,9,10,21,17,3,26,2,1,5,2,4,5,4,1,7,4,7,3,4,2,1,6,1,1,20,4,1,9,2,2,1,3,3,2,3,2,1,1,1,20,2,3,1,6,2,3,6,2,4,8,1,3,2,10,3,5,3,4,4,
        -: 3499:        3,4,16,1,6,1,10,2,4,2,1,1,2,10,11,2,2,3,1,24,31,4,10,10,2,5,12,16,164,15,4,16,7,9,15,19,17,1,2,1,1,5,1,1,1,1,1,3,1,4,3,1,3,1,3,1,2,1,1,3,3,7,
        -: 3500:        2,8,1,2,2,2,1,3,4,3,7,8,12,92,2,10,3,1,3,14,5,25,16,42,4,7,7,4,2,21,5,27,26,27,21,25,30,31,2,1,5,13,3,22,5,6,6,11,9,12,1,5,9,7,5,5,22,60,3,5,
        -: 3501:        13,1,1,8,1,1,3,3,2,1,9,3,3,18,4,1,2,3,7,6,3,1,2,3,9,1,3,1,3,2,1,3,1,1,1,2,1,11,3,1,6,9,1,3,2,3,1,2,1,5,1,1,4,3,4,1,2,2,4,4,1,7,2,1,2,2,3,5,13,
        -: 3502:        18,3,4,14,9,9,4,16,3,7,5,8,2,6,48,28,3,1,1,4,2,14,8,2,9,2,1,15,2,4,3,2,10,16,12,8,7,1,1,3,1,1,1,2,7,4,1,6,4,38,39,16,23,7,15,15,3,2,12,7,21,
        -: 3503:        37,27,6,5,4,8,2,10,8,8,6,5,1,2,1,3,24,1,16,17,9,23,10,17,6,1,51,55,44,13,294,9,3,6,2,4,2,2,15,1,1,1,13,21,17,68,14,8,9,4,1,4,9,3,11,7,1,1,1,
        -: 3504:        5,6,3,2,1,1,1,2,3,8,1,2,2,4,1,5,5,2,1,4,3,7,13,4,1,4,1,3,1,1,1,5,5,10,1,6,1,5,2,1,5,2,4,1,4,5,7,3,18,2,9,11,32,4,3,3,2,4,7,11,16,9,11,8,13,38,
        -: 3505:        32,8,4,2,1,1,2,1,2,4,4,1,1,1,4,1,21,3,11,1,16,1,1,6,1,3,2,4,9,8,57,7,44,1,3,3,13,3,10,1,1,7,5,2,7,21,47,63,3,15,4,7,1,16,1,1,2,8,2,3,42,15,4,
        -: 3506:        1,29,7,22,10,3,78,16,12,20,18,4,67,11,5,1,3,15,6,21,31,32,27,18,13,71,35,5,142,4,10,1,2,50,19,33,16,35,37,16,19,27,7,1,133,19,1,4,8,7,20,1,4,
        -: 3507:        4,1,10,3,1,6,1,2,51,5,40,15,24,43,22928,11,1,13,154,70,3,1,1,7,4,10,1,2,1,1,2,1,2,1,2,2,1,1,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,
        -: 3508:        3,2,1,1,1,1,2,1,1,
        -: 3509:    };
        -: 3510:    static ImWchar base_ranges[] = // not zero-terminated
        -: 3511:    {
        -: 3512:        0x0020, 0x00FF, // Basic Latin + Latin Supplement
        -: 3513:        0x3000, 0x30FF, // CJK Symbols and Punctuations, Hiragana, Katakana
        -: 3514:        0x31F0, 0x31FF, // Katakana Phonetic Extensions
        -: 3515:        0xFF00, 0xFFEF, // Half-width characters
        -: 3516:        0xFFFD, 0xFFFD  // Invalid
        -: 3517:    };
        -: 3518:    static ImWchar full_ranges[IM_ARRAYSIZE(base_ranges) + IM_ARRAYSIZE(accumulative_offsets_from_0x4E00)*2 + 1] = { 0 };
    #####: 3519:    if (!full_ranges[0])
    %%%%%: 3519-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3520:    {
    #####: 3521:        memcpy(full_ranges, base_ranges, sizeof(base_ranges));
    #####: 3522:        UnpackAccumulativeOffsetsIntoRanges(0x4E00, accumulative_offsets_from_0x4E00, IM_ARRAYSIZE(accumulative_offsets_from_0x4E00), full_ranges + IM_ARRAYSIZE(base_ranges));
    %%%%%: 3522-block 3
call    0 never executed
        -: 3523:    }
    #####: 3524:    return &full_ranges[0];
    %%%%%: 3524-block 4
        -: 3525:}
        -: 3526:
function _ZN11ImFontAtlas22GetGlyphRangesCyrillicEv called 0 returned 0% blocks executed 0%
    #####: 3527:const ImWchar*  ImFontAtlas::GetGlyphRangesCyrillic()
        -: 3528:{
        -: 3529:    static const ImWchar ranges[] =
        -: 3530:    {
        -: 3531:        0x0020, 0x00FF, // Basic Latin + Latin Supplement
        -: 3532:        0x0400, 0x052F, // Cyrillic + Cyrillic Supplement
        -: 3533:        0x2DE0, 0x2DFF, // Cyrillic Extended-A
        -: 3534:        0xA640, 0xA69F, // Cyrillic Extended-B
        -: 3535:        0,
        -: 3536:    };
    #####: 3537:    return &ranges[0];
    %%%%%: 3537-block 2
        -: 3538:}
        -: 3539:
function _ZN11ImFontAtlas18GetGlyphRangesThaiEv called 0 returned 0% blocks executed 0%
    #####: 3540:const ImWchar*  ImFontAtlas::GetGlyphRangesThai()
        -: 3541:{
        -: 3542:    static const ImWchar ranges[] =
        -: 3543:    {
        -: 3544:        0x0020, 0x00FF, // Basic Latin
        -: 3545:        0x2010, 0x205E, // Punctuations
        -: 3546:        0x0E00, 0x0E7F, // Thai
        -: 3547:        0,
        -: 3548:    };
    #####: 3549:    return &ranges[0];
    %%%%%: 3549-block 2
        -: 3550:}
        -: 3551:
function _ZN11ImFontAtlas24GetGlyphRangesVietnameseEv called 0 returned 0% blocks executed 0%
    #####: 3552:const ImWchar*  ImFontAtlas::GetGlyphRangesVietnamese()
        -: 3553:{
        -: 3554:    static const ImWchar ranges[] =
        -: 3555:    {
        -: 3556:        0x0020, 0x00FF, // Basic Latin
        -: 3557:        0x0102, 0x0103,
        -: 3558:        0x0110, 0x0111,
        -: 3559:        0x0128, 0x0129,
        -: 3560:        0x0168, 0x0169,
        -: 3561:        0x01A0, 0x01A1,
        -: 3562:        0x01AF, 0x01B0,
        -: 3563:        0x1EA0, 0x1EF9,
        -: 3564:        0,
        -: 3565:    };
    #####: 3566:    return &ranges[0];
    %%%%%: 3566-block 2
        -: 3567:}
        -: 3568:
        -: 3569://-----------------------------------------------------------------------------
        -: 3570:// [SECTION] ImFontGlyphRangesBuilder
        -: 3571://-----------------------------------------------------------------------------
        -: 3572:
function _ZN24ImFontGlyphRangesBuilder7AddTextEPKcS1_ called 0 returned 0% blocks executed 0%
    #####: 3573:void ImFontGlyphRangesBuilder::AddText(const char* text, const char* text_end)
        -: 3574:{
    #####: 3575:    while (text_end ? (text < text_end) : *text)
    %%%%%: 3575-block 2
    %%%%%: 3575-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3575-block 9
    %%%%%: 3575-block 10
    %%%%%: 3575-block 11
branch  2 never executed
branch  3 never executed (fallthrough)
        -: 3576:    {
    #####: 3577:        unsigned int c = 0;
    #####: 3578:        int c_len = ImTextCharFromUtf8(&c, text, text_end);
    %%%%%: 3578-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3579:        text += c_len;
    #####: 3580:        if (c_len == 0)
    %%%%%: 3580-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3581:            break;
    %%%%%: 3581-block 5
    #####: 3582:        AddChar((ImWchar)c);
    %%%%%: 3582-block 6
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 3583:    }
    #####: 3584:}
    %%%%%: 3584-block 12
        -: 3585:
function _ZN24ImFontGlyphRangesBuilder9AddRangesEPKt called 0 returned 0% blocks executed 0%
    #####: 3586:void ImFontGlyphRangesBuilder::AddRanges(const ImWchar* ranges)
        -: 3587:{
    #####: 3588:    for (; ranges[0]; ranges += 2)
    %%%%%: 3588-block 2
    %%%%%: 3588-block 8
    %%%%%: 3588-block 9
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3589:        for (unsigned int c = ranges[0]; c <= ranges[1] && c <= IM_UNICODE_CODEPOINT_MAX; c++) //-V560
    %%%%%: 3589-block 3
    %%%%%: 3589-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3589-block 7
branch  2 never executed
branch  3 never executed (fallthrough)
    #####: 3590:            AddChar((ImWchar)c);
    %%%%%: 3590-block 4
call    0 never executed
    #####: 3591:}
        -: 3592:
function _ZN24ImFontGlyphRangesBuilder11BuildRangesEP8ImVectorItE called 0 returned 0% blocks executed 0%
    #####: 3593:void ImFontGlyphRangesBuilder::BuildRanges(ImVector<ImWchar>* out_ranges)
        -: 3594:{
    #####: 3595:    const int max_codepoint = IM_UNICODE_CODEPOINT_MAX;
    #####: 3596:    for (int n = 0; n <= max_codepoint; n++)
    %%%%%: 3596-block 2
    %%%%%: 3596-block 16
    %%%%%: 3596-block 17
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3597:        if (GetBit(n))
    %%%%%: 3597-block 3
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -: 3598:        {
    #####: 3599:            out_ranges->push_back((ImWchar)n);
    %%%%%: 3599-block 5
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    $$$$$: 3599-block 20
call    3 never executed
    #####: 3600:            while (n < max_codepoint && GetBit(n + 1))
    %%%%%: 3600-block 6
    %%%%%: 3600-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3600-block 9
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 3600-block 11
    %%%%%: 3600-block 12
    %%%%%: 3600-block 13
branch  5 never executed
branch  6 never executed (fallthrough)
    #####: 3601:                n++;
    %%%%%: 3601-block 7
    #####: 3602:            out_ranges->push_back((ImWchar)n);
    %%%%%: 3602-block 14
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 3602-block 15
    $$$$$: 3602-block 21
call    3 never executed
        -: 3603:        }
    #####: 3604:    out_ranges->push_back(0);
    %%%%%: 3604-block 18
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 3605:}
    %%%%%: 3605-block 19
        -: 3606:
        -: 3607://-----------------------------------------------------------------------------
        -: 3608:// [SECTION] ImFont
        -: 3609://-----------------------------------------------------------------------------
        -: 3610:
function _ZN6ImFontC2Ev called 11 returned 100% blocks executed 100%
       11: 3611:ImFont::ImFont()
       11: 3611-block 2
call    0 returned 11
call    1 returned 11
call    2 returned 11
        -: 3612:{
       11: 3613:    FontSize = 0.0f;
       11: 3614:    FallbackAdvanceX = 0.0f;
       11: 3615:    FallbackChar = (ImWchar)-1;
       11: 3616:    EllipsisChar = (ImWchar)-1;
       11: 3617:    EllipsisWidth = EllipsisCharStep = 0.0f;
       11: 3618:    EllipsisCharCount = 0;
       11: 3619:    FallbackGlyph = NULL;
       11: 3620:    ContainerAtlas = NULL;
       11: 3621:    ConfigData = NULL;
       11: 3622:    ConfigDataCount = 0;
       11: 3623:    DirtyLookupTables = false;
       11: 3624:    Scale = 1.0f;
       11: 3625:    Ascent = Descent = 0.0f;
       11: 3626:    MetricsTotalSurface = 0;
       11: 3627:    memset(Used4kPagesMap, 0, sizeof(Used4kPagesMap));
       11: 3628:}
        -: 3629:
function _ZN6ImFontD2Ev called 11 returned 100% blocks executed 100%
       11: 3630:ImFont::~ImFont()
        -: 3631:{
       11: 3632:    ClearOutputData();
       11: 3632-block 2
call    0 returned 11
       11: 3633:}
call    0 returned 11
call    1 returned 11
call    2 returned 11
        -: 3634:
function _ZN6ImFont15ClearOutputDataEv called 21 returned 100% blocks executed 100%
       21: 3635:void    ImFont::ClearOutputData()
        -: 3636:{
       21: 3637:    FontSize = 0.0f;
       21: 3638:    FallbackAdvanceX = 0.0f;
       21: 3639:    Glyphs.clear();
       21: 3639-block 2
call    0 returned 21
       21: 3640:    IndexAdvanceX.clear();
call    0 returned 21
       21: 3641:    IndexLookup.clear();
call    0 returned 21
       21: 3642:    FallbackGlyph = NULL;
       21: 3643:    ContainerAtlas = NULL;
       21: 3644:    DirtyLookupTables = true;
       21: 3645:    Ascent = Descent = 0.0f;
       21: 3646:    MetricsTotalSurface = 0;
       21: 3647:}
        -: 3648:
function _ZL22FindFirstExistingGlyphP6ImFontPKti called 29 returned 100% blocks executed 100%
       29: 3649:static ImWchar FindFirstExistingGlyph(ImFont* font, const ImWchar* candidate_chars, int candidate_chars_count)
        -: 3650:{
       57: 3651:    for (int n = 0; n < candidate_chars_count; n++)
       29: 3651-block 2
       28: 3651-block 6
       57: 3651-block 7
branch  0 taken 48
branch  1 taken 9 (fallthrough)
       48: 3652:        if (font->FindGlyphNoFallback(candidate_chars[n]) != NULL)
       48: 3652-block 3
call    0 returned 48
branch  1 taken 20 (fallthrough)
branch  2 taken 28
       20: 3653:            return candidate_chars[n];
       20: 3653-block 5
        9: 3654:    return (ImWchar)-1;
        9: 3654-block 8
        -: 3655:}
        -: 3656:
function _ZN6ImFont16BuildLookupTableEv called 10 returned 100% blocks executed 93%
       10: 3657:void ImFont::BuildLookupTable()
        -: 3658:{
       10: 3659:    int max_codepoint = 0;
     2390: 3660:    for (int i = 0; i != Glyphs.Size; i++)
       10: 3660-block 2
     2390: 3660-block 6
branch  0 taken 2380
branch  1 taken 10 (fallthrough)
     2380: 3661:        max_codepoint = ImMax(max_codepoint, (int)Glyphs[i].Codepoint);
     2380: 3661-block 3
call    0 returned 2380
call    1 returned 2380
        -: 3662:
        -: 3663:    // Build lookup table
      10*: 3664:    IM_ASSERT(Glyphs.Size > 0 && "Font has not loaded glyph!");
       10: 3664-block 7
branch  0 taken 0 (fallthrough)
branch  1 taken 10
    %%%%%: 3664-block 8
call    2 never executed
      10*: 3665:    IM_ASSERT(Glyphs.Size < 0xFFFF); // -1 is reserved
       10: 3665-block 9
branch  0 taken 0 (fallthrough)
branch  1 taken 10
    %%%%%: 3665-block 10
call    2 never executed
       10: 3666:    IndexAdvanceX.clear();
       10: 3666-block 11
call    0 returned 10
branch  1 taken 10 (fallthrough)
branch  2 taken 0 (throw)
       10: 3667:    IndexLookup.clear();
       10: 3667-block 12
call    0 returned 10
branch  1 taken 10 (fallthrough)
branch  2 taken 0 (throw)
       10: 3668:    DirtyLookupTables = false;
       10: 3669:    memset(Used4kPagesMap, 0, sizeof(Used4kPagesMap));
       10: 3670:    GrowIndex(max_codepoint + 1);
       10: 3670-block 13
call    0 returned 10
branch  1 taken 10 (fallthrough)
branch  2 taken 0 (throw)
     2390: 3671:    for (int i = 0; i < Glyphs.Size; i++)
       10: 3671-block 14
     2390: 3671-block 20
branch  0 taken 2380
branch  1 taken 10 (fallthrough)
        -: 3672:    {
     2380: 3673:        int codepoint = (int)Glyphs[i].Codepoint;
     2380: 3673-block 15
call    0 returned 2380
     2380: 3674:        IndexAdvanceX[codepoint] = Glyphs[i].AdvanceX;
call    0 returned 2380
call    1 returned 2380
     2380: 3675:        IndexLookup[codepoint] = (ImWchar)i;
call    0 returned 2380
        -: 3676:
        -: 3677:        // Mark 4K page as used
     2380: 3678:        const int page_n = codepoint / 4096;
     2380: 3679:        Used4kPagesMap[page_n >> 3] |= 1 << (page_n & 7);
        -: 3680:    }
        -: 3681:
        -: 3682:    // Create a glyph to handle TAB
        -: 3683:    // FIXME: Needs proper TAB handling but it needs to be contextualized (or we could arbitrary say that each string starts at "column 0" ?)
       10: 3684:    if (FindGlyph((ImWchar)' '))
       10: 3684-block 21
call    0 returned 10
branch  1 taken 10 (fallthrough)
branch  2 taken 0
        -: 3685:    {
       10: 3686:        if (Glyphs.back().Codepoint != '\t')   // So we can call this function multiple times (FIXME: Flaky)
       10: 3686-block 23
call    0 returned 10
branch  1 taken 10 (fallthrough)
branch  2 taken 0
       10: 3687:            Glyphs.resize(Glyphs.Size + 1);
       10: 3687-block 25
call    0 returned 10
branch  1 taken 10 (fallthrough)
branch  2 taken 0 (throw)
       10: 3688:        ImFontGlyph& tab_glyph = Glyphs.back();
       10: 3688-block 26
call    0 returned 10
       10: 3689:        tab_glyph = *FindGlyph((ImWchar)' ');
call    0 returned 10
       10: 3690:        tab_glyph.Codepoint = '\t';
       10: 3691:        tab_glyph.AdvanceX *= IM_TABSIZE;
       10: 3692:        IndexAdvanceX[(int)tab_glyph.Codepoint] = (float)tab_glyph.AdvanceX;
call    0 returned 10
       10: 3693:        IndexLookup[(int)tab_glyph.Codepoint] = (ImWchar)(Glyphs.Size - 1);
call    0 returned 10
        -: 3694:    }
        -: 3695:
        -: 3696:    // Mark special glyphs as not visible (note that AddGlyph already mark as non-visible glyphs with zero-size polygons)
       10: 3697:    SetGlyphVisible((ImWchar)' ', false);
       10: 3697-block 31
call    0 returned 10
branch  1 taken 10 (fallthrough)
branch  2 taken 0 (throw)
       10: 3698:    SetGlyphVisible((ImWchar)'\t', false);
       10: 3698-block 32
call    0 returned 10
branch  1 taken 10 (fallthrough)
branch  2 taken 0 (throw)
        -: 3699:
        -: 3700:    // Setup Fallback character
       10: 3701:    const ImWchar fallback_chars[] = { (ImWchar)IM_UNICODE_CODEPOINT_INVALID, (ImWchar)'?', (ImWchar)' ' };
       10: 3702:    FallbackGlyph = FindGlyphNoFallback(FallbackChar);
       10: 3702-block 33
call    0 returned 10
       10: 3703:    if (FallbackGlyph == NULL)
branch  0 taken 10 (fallthrough)
branch  1 taken 0
        -: 3704:    {
       10: 3705:        FallbackChar = FindFirstExistingGlyph(this, fallback_chars, IM_ARRAYSIZE(fallback_chars));
       10: 3705-block 35
call    0 returned 10
branch  1 taken 10 (fallthrough)
branch  2 taken 0 (throw)
       10: 3706:        FallbackGlyph = FindGlyphNoFallback(FallbackChar);
       10: 3706-block 36
call    0 returned 10
       10: 3707:        if (FallbackGlyph == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 10
        -: 3708:        {
    #####: 3709:            FallbackGlyph = &Glyphs.back();
    %%%%%: 3709-block 38
call    0 never executed
    #####: 3710:            FallbackChar = (ImWchar)FallbackGlyph->Codepoint;
        -: 3711:        }
        -: 3712:    }
       10: 3713:    FallbackAdvanceX = FallbackGlyph->AdvanceX;
    64012: 3714:    for (int i = 0; i < max_codepoint + 1; i++)
       10: 3714-block 40
    64002: 3714-block 45
    64012: 3714-block 46
branch  0 taken 64002
branch  1 taken 10 (fallthrough)
    64002: 3715:        if (IndexAdvanceX[i] < 0.0f)
    64002: 3715-block 41
call    0 returned 64002
branch  1 taken 61612 (fallthrough)
branch  2 taken 2390
    61612: 3716:            IndexAdvanceX[i] = FallbackAdvanceX;
    61612: 3716-block 43
call    0 returned 61612
        -: 3717:
        -: 3718:    // Setup Ellipsis character. It is required for rendering elided text. We prefer using U+2026 (horizontal ellipsis).
        -: 3719:    // However some old fonts may contain ellipsis at U+0085. Here we auto-detect most suitable ellipsis character.
        -: 3720:    // FIXME: Note that 0x2026 is rarely included in our font ranges. Because of this we are more likely to use three individual dots.
       10: 3721:    const ImWchar ellipsis_chars[] = { (ImWchar)0x2026, (ImWchar)0x0085 };
       10: 3722:    const ImWchar dots_chars[] = { (ImWchar)'.', (ImWchar)0xFF0E };
       10: 3723:    if (EllipsisChar == (ImWchar)-1)
       10: 3723-block 47
branch  0 taken 9 (fallthrough)
branch  1 taken 1
        9: 3724:        EllipsisChar = FindFirstExistingGlyph(this, ellipsis_chars, IM_ARRAYSIZE(ellipsis_chars));
        9: 3724-block 48
call    0 returned 9
branch  1 taken 9 (fallthrough)
branch  2 taken 0 (throw)
        9: 3724-block 49
       10: 3725:    const ImWchar dot_char = FindFirstExistingGlyph(this, dots_chars, IM_ARRAYSIZE(dots_chars));
       10: 3725-block 50
call    0 returned 10
branch  1 taken 10 (fallthrough)
branch  2 taken 0 (throw)
       10: 3726:    if (EllipsisChar != (ImWchar)-1)
       10: 3726-block 51
branch  0 taken 1 (fallthrough)
branch  1 taken 9
        -: 3727:    {
        1: 3728:        EllipsisCharCount = 1;
        1: 3729:        EllipsisWidth = EllipsisCharStep = FindGlyph(EllipsisChar)->X1;
        1: 3729-block 52
call    0 returned 1
        -: 3730:    }
        9: 3731:    else if (dot_char != (ImWchar)-1)
        9: 3731-block 54
branch  0 taken 9 (fallthrough)
branch  1 taken 0
        -: 3732:    {
        9: 3733:        const ImFontGlyph* glyph = FindGlyph(dot_char);
        9: 3733-block 55
call    0 returned 9
        9: 3734:        EllipsisChar = dot_char;
        9: 3735:        EllipsisCharCount = 3;
        9: 3736:        EllipsisCharStep = (glyph->X1 - glyph->X0) + 1.0f;
        9: 3737:        EllipsisWidth = EllipsisCharStep * 3.0f - 1.0f;
        -: 3738:    }
       10: 3739:}
       10: 3739-block 57
        -: 3740:
        -: 3741:// API is designed this way to avoid exposing the 4K page size
        -: 3742:// e.g. use with IsGlyphRangeUnused(0, 255)
function _ZN6ImFont18IsGlyphRangeUnusedEjj called 0 returned 0% blocks executed 0%
    #####: 3743:bool ImFont::IsGlyphRangeUnused(unsigned int c_begin, unsigned int c_last)
        -: 3744:{
    #####: 3745:    unsigned int page_begin = (c_begin / 4096);
    #####: 3746:    unsigned int page_last = (c_last / 4096);
    #####: 3747:    for (unsigned int page_n = page_begin; page_n <= page_last; page_n++)
    %%%%%: 3747-block 2
    %%%%%: 3747-block 6
    %%%%%: 3747-block 7
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3748:        if ((page_n >> 3) < sizeof(Used4kPagesMap))
    %%%%%: 3748-block 3
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3749:            if (Used4kPagesMap[page_n >> 3] & (1 << (page_n & 7)))
    %%%%%: 3749-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3750:                return false;
    %%%%%: 3750-block 5
    #####: 3751:    return true;
    %%%%%: 3751-block 8
        -: 3752:}
        -: 3753:
function _ZN6ImFont15SetGlyphVisibleEtb called 20 returned 100% blocks executed 86%
       20: 3754:void ImFont::SetGlyphVisible(ImWchar c, bool visible)
        -: 3755:{
       20: 3756:    if (ImFontGlyph* glyph = (ImFontGlyph*)(void*)FindGlyph((ImWchar)c))
       20: 3756-block 2
call    0 returned 20
branch  1 taken 20 (fallthrough)
branch  2 taken 0
      20*: 3757:        glyph->Visible = visible ? 1 : 0;
       20: 3757-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 20
    %%%%%: 3757-block 5
       20: 3757-block 6
       20: 3757-block 7
       20: 3758:}
        -: 3759:
function _ZN6ImFont9GrowIndexEi called 10 returned 100% blocks executed 70%
       10: 3760:void ImFont::GrowIndex(int new_size)
        -: 3761:{
      10*: 3762:    IM_ASSERT(IndexAdvanceX.Size == IndexLookup.Size);
       10: 3762-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 10
    %%%%%: 3762-block 3
call    2 never executed
       10: 3763:    if (new_size <= IndexLookup.Size)
       10: 3763-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 10
    #####: 3764:        return;
    %%%%%: 3764-block 5
       10: 3765:    IndexAdvanceX.resize(new_size, -1.0f);
       10: 3765-block 6
call    0 returned 10
branch  1 taken 10 (fallthrough)
branch  2 taken 0 (throw)
    $$$$$: 3765-block 10
call    3 never executed
       10: 3766:    IndexLookup.resize(new_size, (ImWchar)-1);
       10: 3766-block 7
call    0 returned 10
branch  1 taken 10 (fallthrough)
branch  2 taken 0 (throw)
       10: 3766-block 8
        -: 3767:}
        -: 3768:
        -: 3769:// x0/y0/x1/y1 are offset from the character upper-left layout position, in pixels. Therefore x0/y0 are often fairly close to zero.
        -: 3770:// Not to be mistaken with texture coordinates, which are held by u0/v0/u1/v1 in normalized format (0.0..1.0 on each texture axis).
        -: 3771:// 'cfg' is not necessarily == 'this->ConfigData' because multiple source fonts+configs can be used to build one target font.
function _ZN6ImFont8AddGlyphEPK12ImFontConfigtfffffffff called 2380 returned 100% blocks executed 94%
     2380: 3772:void ImFont::AddGlyph(const ImFontConfig* cfg, ImWchar codepoint, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x)
        -: 3773:{
     2380: 3774:    if (cfg != NULL)
     2380: 3774-block 2
branch  0 taken 2380 (fallthrough)
branch  1 taken 0
        -: 3775:    {
        -: 3776:        // Clamp & recenter if needed
     2380: 3777:        const float advance_x_original = advance_x;
     2380: 3778:        advance_x = ImClamp(advance_x, cfg->GlyphMinAdvanceX, cfg->GlyphMaxAdvanceX);
     2380: 3778-block 3
call    0 returned 2380
     2380: 3779:        if (advance_x != advance_x_original)
branch  0 taken 462 (fallthrough)
branch  1 taken 1918
        -: 3780:        {
     462*: 3781:            float char_off_x = cfg->PixelSnapH ? ImTrunc((advance_x - advance_x_original) * 0.5f) : (advance_x - advance_x_original) * 0.5f;
      462: 3781-block 5
branch  0 taken 462 (fallthrough)
branch  1 taken 0
      462: 3781-block 6
call    2 returned 462
    %%%%%: 3781-block 7
      462: 3782:            x0 += char_off_x;
      462: 3783:            x1 += char_off_x;
      462: 3783-block 8
        -: 3784:        }
        -: 3785:
        -: 3786:        // Snap to pixel
     2380: 3787:        if (cfg->PixelSnapH)
     2380: 3787-block 9
branch  0 taken 685 (fallthrough)
branch  1 taken 1695
      685: 3788:            advance_x = IM_ROUND(advance_x);
      685: 3788-block 10
        -: 3789:
        -: 3790:        // Bake spacing
     2380: 3791:        advance_x += cfg->GlyphExtraSpacing.x;
     2380: 3791-block 11
        -: 3792:    }
        -: 3793:
     2380: 3794:    Glyphs.resize(Glyphs.Size + 1);
     2380: 3794-block 12
call    0 returned 2380
     2380: 3795:    ImFontGlyph& glyph = Glyphs.back();
call    0 returned 2380
     2380: 3796:    glyph.Codepoint = (unsigned int)codepoint;
     2380: 3797:    glyph.Visible = (x0 != x1) && (y0 != y1);
branch  0 taken 2371 (fallthrough)
branch  1 taken 9
     2371: 3797-block 15
branch  2 taken 2358 (fallthrough)
branch  3 taken 13
     2358: 3797-block 16
       22: 3797-block 17
     2380: 3798:    glyph.Colored = false;
     2380: 3799:    glyph.X0 = x0;
     2380: 3800:    glyph.Y0 = y0;
     2380: 3801:    glyph.X1 = x1;
     2380: 3802:    glyph.Y1 = y1;
     2380: 3803:    glyph.U0 = u0;
     2380: 3804:    glyph.V0 = v0;
     2380: 3805:    glyph.U1 = u1;
     2380: 3806:    glyph.V1 = v1;
     2380: 3807:    glyph.AdvanceX = advance_x;
        -: 3808:
        -: 3809:    // Compute rough surface usage metrics (+1 to account for average padding, +0.99 to round)
        -: 3810:    // We use (U1-U0)*TexWidth instead of X1-X0 to account for oversampling.
     2380: 3811:    float pad = ContainerAtlas->TexGlyphPadding + 0.99f;
     2380: 3812:    DirtyLookupTables = true;
     2380: 3813:    MetricsTotalSurface += (int)((glyph.U1 - glyph.U0) * ContainerAtlas->TexWidth + pad) * (int)((glyph.V1 - glyph.V0) * ContainerAtlas->TexHeight + pad);
     2380: 3814:}
        -: 3815:
function _ZN6ImFont12AddRemapCharEttb called 0 returned 0% blocks executed 0%
    #####: 3816:void ImFont::AddRemapChar(ImWchar dst, ImWchar src, bool overwrite_dst)
        -: 3817:{
    #####: 3818:    IM_ASSERT(IndexLookup.Size > 0);    // Currently this can only be called AFTER the font has been built, aka after calling ImFontAtlas::GetTexDataAs*() function.
    %%%%%: 3818-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3818-block 3
call    2 never executed
    #####: 3819:    unsigned int index_size = (unsigned int)IndexLookup.Size;
        -: 3820:
    #####: 3821:    if (dst < index_size && IndexLookup.Data[dst] == (ImWchar)-1 && !overwrite_dst) // 'dst' already exists
    %%%%%: 3821-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3821-block 5
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3821-block 6
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 3822:        return;
    %%%%%: 3822-block 7
    #####: 3823:    if (src >= index_size && dst >= index_size) // both 'dst' and 'src' don't exist -> no-op
    %%%%%: 3823-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3823-block 9
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3824:        return;
    %%%%%: 3824-block 10
        -: 3825:
    #####: 3826:    GrowIndex(dst + 1);
    %%%%%: 3826-block 11
call    0 never executed
    #####: 3827:    IndexLookup[dst] = (src < index_size) ? IndexLookup.Data[src] : (ImWchar)-1;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3827-block 13
    %%%%%: 3827-block 14
    %%%%%: 3827-block 15
call    2 never executed
    #####: 3828:    IndexAdvanceX[dst] = (src < index_size) ? IndexAdvanceX.Data[src] : 1.0f;
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3828-block 17
    %%%%%: 3828-block 18
    %%%%%: 3828-block 19
call    2 never executed
        -: 3829:}
        -: 3830:
function _ZNK6ImFont9FindGlyphEt called 1636146 returned 100% blocks executed 67%
  1636146: 3831:const ImFontGlyph* ImFont::FindGlyph(ImWchar c) const
        -: 3832:{
  1636146: 3833:    if (c >= (size_t)IndexLookup.Size)
  1636146: 3833-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1636146
    #####: 3834:        return FallbackGlyph;
    %%%%%: 3834-block 3
  1636146: 3835:    const ImWchar i = IndexLookup.Data[c];
  1636146: 3836:    if (i == (ImWchar)-1)
  1636146: 3836-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 1636146
    #####: 3837:        return FallbackGlyph;
    %%%%%: 3837-block 5
  1636146: 3838:    return &Glyphs.Data[i];
  1636146: 3838-block 6
        -: 3839:}
        -: 3840:
function _ZNK6ImFont19FindGlyphNoFallbackEt called 68 returned 100% blocks executed 100%
       68: 3841:const ImFontGlyph* ImFont::FindGlyphNoFallback(ImWchar c) const
        -: 3842:{
       68: 3843:    if (c >= (size_t)IndexLookup.Size)
       68: 3843-block 2
branch  0 taken 28 (fallthrough)
branch  1 taken 40
       28: 3844:        return NULL;
       28: 3844-block 3
       40: 3845:    const ImWchar i = IndexLookup.Data[c];
       40: 3846:    if (i == (ImWchar)-1)
       40: 3846-block 4
branch  0 taken 10 (fallthrough)
branch  1 taken 30
       10: 3847:        return NULL;
       10: 3847-block 5
       30: 3848:    return &Glyphs.Data[i];
       30: 3848-block 6
        -: 3849:}
        -: 3850:
        -: 3851:// Wrapping skips upcoming blanks
function _ZL26CalcWordWrapNextLineStartAPKcS0_ called 0 returned 0% blocks executed 0%
    #####: 3852:static inline const char* CalcWordWrapNextLineStartA(const char* text, const char* text_end)
        -: 3853:{
    #####: 3854:    while (text < text_end && ImCharIsBlankA(*text))
    %%%%%: 3854-block 2
    %%%%%: 3854-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3854-block 5
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    %%%%%: 3854-block 7
    %%%%%: 3854-block 8
    %%%%%: 3854-block 9
branch  5 never executed
branch  6 never executed (fallthrough)
    #####: 3855:        text++;
    %%%%%: 3855-block 3
    #####: 3856:    if (*text == '\n')
    %%%%%: 3856-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3857:        text++;
    %%%%%: 3857-block 11
    #####: 3858:    return text;
    %%%%%: 3858-block 12
        -: 3859:}
        -: 3860:
        -: 3861:// Simple word-wrapping for English, not full-featured. Please submit failing cases!
        -: 3862:// This will return the next location to wrap from. If no wrapping if necessary, this will fast-forward to e.g. text_end.
        -: 3863:// FIXME: Much possible improvements (don't cut things like "word !", "word!!!" but cut within "word,,,,", more sensible support for punctuations, support for Unicode punctuations, etc.)
function _ZNK6ImFont21CalcWordWrapPositionAEfPKcS1_f called 0 returned 0% blocks executed 0%
    #####: 3864:const char* ImFont::CalcWordWrapPositionA(float scale, const char* text, const char* text_end, float wrap_width) const
        -: 3865:{
        -: 3866:    // For references, possible wrap point marked with ^
        -: 3867:    //  "aaa bbb, ccc,ddd. eee   fff. ggg!"
        -: 3868:    //      ^    ^    ^   ^   ^__    ^    ^
        -: 3869:
        -: 3870:    // List of hardcoded separators: .,;!?'"
        -: 3871:
        -: 3872:    // Skip extra blanks after a line returns (that includes not counting them in width computation)
        -: 3873:    // e.g. "Hello    world" --> "Hello" "World"
        -: 3874:
        -: 3875:    // Cut words that cannot possibly fit within one line.
        -: 3876:    // e.g.: "The tropical fish" with ~5 characters worth of width --> "The tr" "opical" "fish"
    #####: 3877:    float line_width = 0.0f;
    #####: 3878:    float word_width = 0.0f;
    #####: 3879:    float blank_width = 0.0f;
    #####: 3880:    wrap_width /= scale; // We work with unscaled widths to avoid scaling every characters
        -: 3881:
    #####: 3882:    const char* word_end = text;
    #####: 3883:    const char* prev_word_end = NULL;
    #####: 3884:    bool inside_word = true;
        -: 3885:
    #####: 3886:    const char* s = text;
    #####: 3887:    IM_ASSERT(text_end != NULL);
    %%%%%: 3887-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3887-block 3
call    2 never executed
    #####: 3888:    while (s < text_end)
    %%%%%: 3888-block 4
    %%%%%: 3888-block 43
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 3889:    {
    #####: 3890:        unsigned int c = (unsigned int)*s;
        -: 3891:        const char* next_s;
    #####: 3892:        if (c < 0x80)
    %%%%%: 3892-block 5
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3893:            next_s = s + 1;
    %%%%%: 3893-block 6
        -: 3894:        else
    #####: 3895:            next_s = s + ImTextCharFromUtf8(&c, s, text_end);
    %%%%%: 3895-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 3895-block 8
        -: 3896:
    #####: 3897:        if (c < 32)
    %%%%%: 3897-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3898:        {
    #####: 3899:            if (c == '\n')
    %%%%%: 3899-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3900:            {
    #####: 3901:                line_width = word_width = blank_width = 0.0f;
    #####: 3902:                inside_word = true;
    #####: 3903:                s = next_s;
    #####: 3904:                continue;
    %%%%%: 3904-block 11
    %%%%%: 3904-block 42
        -: 3905:            }
    #####: 3906:            if (c == '\r')
    %%%%%: 3906-block 12
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3907:            {
    #####: 3908:                s = next_s;
    #####: 3909:                continue;
    %%%%%: 3909-block 13
        -: 3910:            }
        -: 3911:        }
        -: 3912:
    #####: 3913:        const float char_width = ((int)c < IndexAdvanceX.Size ? IndexAdvanceX.Data[c] : FallbackAdvanceX);
    %%%%%: 3913-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3913-block 15
    %%%%%: 3913-block 16
    #####: 3914:        if (ImCharIsBlankW(c))
    %%%%%: 3914-block 17
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
        -: 3915:        {
    #####: 3916:            if (inside_word)
    %%%%%: 3916-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3917:            {
    #####: 3918:                line_width += blank_width;
    #####: 3919:                blank_width = 0.0f;
    #####: 3920:                word_end = s;
    %%%%%: 3920-block 20
        -: 3921:            }
    #####: 3922:            blank_width += char_width;
    #####: 3923:            inside_word = false;
    %%%%%: 3923-block 21
        -: 3924:        }
        -: 3925:        else
        -: 3926:        {
    #####: 3927:            word_width += char_width;
    #####: 3928:            if (inside_word)
    %%%%%: 3928-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3929:            {
    #####: 3930:                word_end = next_s;
    %%%%%: 3930-block 23
        -: 3931:            }
        -: 3932:            else
        -: 3933:            {
    #####: 3934:                prev_word_end = word_end;
    #####: 3935:                line_width += word_width + blank_width;
    #####: 3936:                word_width = blank_width = 0.0f;
    %%%%%: 3936-block 24
        -: 3937:            }
        -: 3938:
        -: 3939:            // Allow wrapping after punctuation.
    #####: 3940:            inside_word = (c != '.' && c != ',' && c != ';' && c != '!' && c != '?' && c != '\"');
    %%%%%: 3940-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3940-block 26
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 3940-block 27
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 3940-block 28
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 3940-block 29
branch  8 never executed (fallthrough)
branch  9 never executed
    %%%%%: 3940-block 30
branch 10 never executed (fallthrough)
branch 11 never executed
    %%%%%: 3940-block 31
    %%%%%: 3940-block 32
    %%%%%: 3940-block 33
        -: 3941:        }
        -: 3942:
        -: 3943:        // We ignore blank width at the end of the line (they can be skipped)
    #####: 3944:        if (line_width + word_width > wrap_width)
    %%%%%: 3944-block 34
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3945:        {
        -: 3946:            // Words that cannot possibly fit within an entire line will be cut anywhere.
    #####: 3947:            if (word_width < wrap_width)
    %%%%%: 3947-block 35
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3948:                s = prev_word_end ? prev_word_end : word_end;
    %%%%%: 3948-block 36
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3948-block 37
    %%%%%: 3948-block 38
    %%%%%: 3948-block 39
    #####: 3949:            break;
    %%%%%: 3949-block 40
        -: 3950:        }
        -: 3951:
    #####: 3952:        s = next_s;
    %%%%%: 3952-block 41
        -: 3953:    }
        -: 3954:
        -: 3955:    // Wrap_width is too small to fit anything. Force displaying 1 character to minimize the height discontinuity.
        -: 3956:    // +1 may not be a character start point in UTF-8 but it's ok because caller loops use (text >= word_wrap_eol).
    #####: 3957:    if (s == text && text < text_end)
    %%%%%: 3957-block 44
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 3957-block 45
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3958:        return s + 1;
    %%%%%: 3958-block 46
    #####: 3959:    return s;
    %%%%%: 3959-block 47
        -: 3960:}
        -: 3961:
function _ZNK6ImFont13CalcTextSizeAEfffPKcS1_PS1_ called 551353 returned 100% blocks executed 61%
   551353: 3962:ImVec2 ImFont::CalcTextSizeA(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end, const char** remaining) const
        -: 3963:{
   551353: 3964:    if (!text_end)
   551353: 3964-block 2
branch  0 taken 57082 (fallthrough)
branch  1 taken 494271
    57082: 3965:        text_end = text_begin + strlen(text_begin); // FIXME-OPT: Need to avoid this.
    57082: 3965-block 3
        -: 3966:
   551353: 3967:    const float line_height = size;
   551353: 3968:    const float scale = size / FontSize;
        -: 3969:
   551353: 3970:    ImVec2 text_size = ImVec2(0, 0);
   551353: 3971:    float line_width = 0.0f;
        -: 3972:
   551353: 3973:    const bool word_wrap_enabled = (wrap_width > 0.0f);
   551353: 3974:    const char* word_wrap_eol = NULL;
        -: 3975:
   551353: 3976:    const char* s = text_begin;
  2592135: 3977:    while (s < text_end)
   551353: 3977-block 4
  2592135: 3977-block 31
branch  0 taken 2046163
branch  1 taken 545972 (fallthrough)
        -: 3978:    {
  2046163: 3979:        if (word_wrap_enabled)
  2046163: 3979-block 5
branch  0 taken 0 (fallthrough)
branch  1 taken 2046163
        -: 3980:        {
        -: 3981:            // Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.
    #####: 3982:            if (!word_wrap_eol)
    %%%%%: 3982-block 6
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3983:                word_wrap_eol = CalcWordWrapPositionA(scale, s, text_end, wrap_width - line_width);
    %%%%%: 3983-block 7
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 3983-block 8
        -: 3984:
    #####: 3985:            if (s >= word_wrap_eol)
    %%%%%: 3985-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3986:            {
    #####: 3987:                if (text_size.x < line_width)
    %%%%%: 3987-block 10
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3988:                    text_size.x = line_width;
    %%%%%: 3988-block 11
    #####: 3989:                text_size.y += line_height;
    #####: 3990:                line_width = 0.0f;
    #####: 3991:                word_wrap_eol = NULL;
    #####: 3992:                s = CalcWordWrapNextLineStartA(s, text_end); // Wrapping skips upcoming blanks
    %%%%%: 3992-block 12
call    0 never executed
    #####: 3993:                continue;
    %%%%%: 3993-block 30
        -: 3994:            }
        -: 3995:        }
        -: 3996:
        -: 3997:        // Decode and advance source
  2046163: 3998:        const char* prev_s = s;
  2046163: 3999:        unsigned int c = (unsigned int)*s;
  2046163: 4000:        if (c < 0x80)
  2046163: 4000-block 14
branch  0 taken 2033316 (fallthrough)
branch  1 taken 12847
  2033316: 4001:            s += 1;
  2033316: 4001-block 15
        -: 4002:        else
    12847: 4003:            s += ImTextCharFromUtf8(&c, s, text_end);
    12847: 4003-block 16
call    0 returned 12847
branch  1 taken 12847 (fallthrough)
branch  2 taken 0 (throw)
    12847: 4003-block 17
        -: 4004:
  2046163: 4005:        if (c < 32)
  2046163: 4005-block 18
branch  0 taken 0 (fallthrough)
branch  1 taken 2046163
        -: 4006:        {
    #####: 4007:            if (c == '\n')
    %%%%%: 4007-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4008:            {
    #####: 4009:                text_size.x = ImMax(text_size.x, line_width);
    %%%%%: 4009-block 20
call    0 never executed
    #####: 4010:                text_size.y += line_height;
    #####: 4011:                line_width = 0.0f;
    #####: 4012:                continue;
        -: 4013:            }
    #####: 4014:            if (c == '\r')
    %%%%%: 4014-block 22
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4015:                continue;
    %%%%%: 4015-block 23
        -: 4016:        }
        -: 4017:
 2046163*: 4018:        const float char_width = ((int)c < IndexAdvanceX.Size ? IndexAdvanceX.Data[c] : FallbackAdvanceX) * scale;
  2046163: 4018-block 24
branch  0 taken 2046163 (fallthrough)
branch  1 taken 0
  2046163: 4018-block 25
    %%%%%: 4018-block 26
  2046163: 4019:        if (line_width + char_width >= max_width)
  2046163: 4019-block 27
branch  0 taken 5381 (fallthrough)
branch  1 taken 2040782
        -: 4020:        {
     5381: 4021:            s = prev_s;
     5381: 4022:            break;
     5381: 4022-block 28
        -: 4023:        }
        -: 4024:
  2040782: 4025:        line_width += char_width;
  2040782: 4025-block 29
        -: 4026:    }
        -: 4027:
   551353: 4028:    if (text_size.x < line_width)
   551353: 4028-block 32
branch  0 taken 534201 (fallthrough)
branch  1 taken 17152
   534201: 4029:        text_size.x = line_width;
   534201: 4029-block 33
        -: 4030:
   551353: 4031:    if (line_width > 0 || text_size.y == 0.0f)
   551353: 4031-block 34
branch  0 taken 17152 (fallthrough)
branch  1 taken 534201
    17152: 4031-block 35
branch  2 taken 17152 (fallthrough)
branch  3 taken 0
   551353: 4032:        text_size.y += line_height;
   551353: 4032-block 36
        -: 4033:
   551353: 4034:    if (remaining)
   551353: 4034-block 37
branch  0 taken 5381 (fallthrough)
branch  1 taken 545972
     5381: 4035:        *remaining = s;
     5381: 4035-block 38
        -: 4036:
   551353: 4037:    return text_size;
   551353: 4037-block 39
   551353: 4037-block 40
        -: 4038:}
        -: 4039:
        -: 4040:// Note: as with every ImDrawList drawing function, this expects that the font atlas texture is bound.
function _ZNK6ImFont10RenderCharEP10ImDrawListfRK6ImVec2jt called 1076 returned 100% blocks executed 82%
     1076: 4041:void ImFont::RenderChar(ImDrawList* draw_list, float size, const ImVec2& pos, ImU32 col, ImWchar c) const
        -: 4042:{
     1076: 4043:    const ImFontGlyph* glyph = FindGlyph(c);
     1076: 4043-block 2
call    0 returned 1076
     1076: 4044:    if (!glyph || !glyph->Visible)
branch  0 taken 1076 (fallthrough)
branch  1 taken 0
     1076: 4044-block 4
branch  2 taken 0 (fallthrough)
branch  3 taken 1076
    #####: 4045:        return;
    %%%%%: 4045-block 5
     1076: 4046:    if (glyph->Colored)
     1076: 4046-block 6
branch  0 taken 0 (fallthrough)
branch  1 taken 1076
    #####: 4047:        col |= ~IM_COL32_A_MASK;
    %%%%%: 4047-block 7
    1076*: 4048:    float scale = (size >= 0.0f) ? (size / FontSize) : 1.0f;
     1076: 4048-block 8
branch  0 taken 1076 (fallthrough)
branch  1 taken 0
     1076: 4048-block 9
    %%%%%: 4048-block 10
     1076: 4049:    float x = IM_TRUNC(pos.x);
     1076: 4050:    float y = IM_TRUNC(pos.y);
     1076: 4051:    draw_list->PrimReserve(6, 4);
     1076: 4051-block 11
call    0 returned 1076
     1076: 4052:    draw_list->PrimRectUV(ImVec2(x + glyph->X0 * scale, y + glyph->Y0 * scale), ImVec2(x + glyph->X1 * scale, y + glyph->Y1 * scale), ImVec2(glyph->U0, glyph->V0), ImVec2(glyph->U1, glyph->V1), col);
call    0 returned 1076
call    1 returned 1076
call    2 returned 1076
call    3 returned 1076
call    4 returned 1076
        -: 4053:}
        -: 4054:
        -: 4055:// Note: as with every ImDrawList drawing function, this expects that the font atlas texture is bound.
function _ZNK6ImFont10RenderTextEP10ImDrawListfRK6ImVec2jRK6ImVec4PKcS9_fb called 905424 returned 100% blocks executed 41%
   905424: 4056:void ImFont::RenderText(ImDrawList* draw_list, float size, const ImVec2& pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, float wrap_width, bool cpu_fine_clip) const
        -: 4057:{
   905424: 4058:    if (!text_end)
   905424: 4058-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 905424
    #####: 4059:        text_end = text_begin + strlen(text_begin); // ImGui:: functions generally already provides a valid text_end, so this is merely to handle direct calls.
    %%%%%: 4059-block 3
        -: 4060:
        -: 4061:    // Align to be pixel perfect
   905424: 4062:    float x = IM_TRUNC(pos.x);
   905424: 4063:    float y = IM_TRUNC(pos.y);
   905424: 4064:    if (y > clip_rect.w)
   905424: 4064-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 905424
    #####: 4065:        return;
    %%%%%: 4065-block 5
        -: 4066:
   905424: 4067:    const float start_x = x;
   905424: 4068:    const float scale = size / FontSize;
   905424: 4069:    const float line_height = FontSize * scale;
   905424: 4070:    const bool word_wrap_enabled = (wrap_width > 0.0f);
        -: 4071:
        -: 4072:    // Fast-forward to first visible line
   905424: 4073:    const char* s = text_begin;
   905424: 4074:    if (y + line_height < clip_rect.y)
   905424: 4074-block 6
branch  0 taken 0 (fallthrough)
branch  1 taken 905424
    #####: 4075:        while (y + line_height < clip_rect.y && s < text_end)
    %%%%%: 4075-block 7
    %%%%%: 4075-block 19
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4075-block 20
branch  2 never executed
branch  3 never executed (fallthrough)
        -: 4076:        {
    #####: 4077:            const char* line_end = (const char*)memchr(s, '\n', text_end - s);
    #####: 4078:            if (word_wrap_enabled)
    %%%%%: 4078-block 8
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4079:            {
        -: 4080:                // FIXME-OPT: This is not optimal as do first do a search for \n before calling CalcWordWrapPositionA().
        -: 4081:                // If the specs for CalcWordWrapPositionA() were reworked to optionally return on \n we could combine both.
        -: 4082:                // However it is still better than nothing performing the fast-forward!
    #####: 4083:                s = CalcWordWrapPositionA(scale, s, line_end ? line_end : text_end, wrap_width);
    %%%%%: 4083-block 9
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4083-block 10
    %%%%%: 4083-block 11
    %%%%%: 4083-block 12
call    2 never executed
    #####: 4084:                s = CalcWordWrapNextLineStartA(s, text_end);
call    0 never executed
        -: 4085:            }
        -: 4086:            else
        -: 4087:            {
    #####: 4088:                s = line_end ? line_end + 1 : text_end;
    %%%%%: 4088-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4088-block 15
    %%%%%: 4088-block 16
    %%%%%: 4088-block 17
        -: 4089:            }
    #####: 4090:            y += line_height;
    %%%%%: 4090-block 18
        -: 4091:        }
        -: 4092:
        -: 4093:    // For large text, scan for the last visible line in order to avoid over-reserving in the call to PrimReserve()
        -: 4094:    // Note that very large horizontal line will still be affected by the issue (e.g. a one megabyte string buffer without a newline will likely crash atm)
  905424*: 4095:    if (text_end - s > 10000 && !word_wrap_enabled)
   905424: 4095-block 21
branch  0 taken 0 (fallthrough)
branch  1 taken 905424
    %%%%%: 4095-block 22
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 4096:    {
    #####: 4097:        const char* s_end = s;
    #####: 4098:        float y_end = y;
    #####: 4099:        while (y_end < clip_rect.w && s_end < text_end)
    %%%%%: 4099-block 23
    %%%%%: 4099-block 28
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4099-block 29
branch  2 never executed
branch  3 never executed (fallthrough)
        -: 4100:        {
    #####: 4101:            s_end = (const char*)memchr(s_end, '\n', text_end - s_end);
    #####: 4102:            s_end = s_end ? s_end + 1 : text_end;
    %%%%%: 4102-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4102-block 25
    %%%%%: 4102-block 26
    #####: 4103:            y_end += line_height;
    %%%%%: 4103-block 27
        -: 4104:        }
    #####: 4105:        text_end = s_end;
    %%%%%: 4105-block 30
        -: 4106:    }
   905424: 4107:    if (s == text_end)
   905424: 4107-block 31
branch  0 taken 0 (fallthrough)
branch  1 taken 905424
    #####: 4108:        return;
    %%%%%: 4108-block 32
        -: 4109:
        -: 4110:    // Reserve vertices for remaining worse case (over-reserving is useful and easily amortized)
   905424: 4111:    const int vtx_count_max = (int)(text_end - s) * 4;
   905424: 4112:    const int idx_count_max = (int)(text_end - s) * 6;
   905424: 4113:    const int idx_expected_size = draw_list->IdxBuffer.Size + idx_count_max;
   905424: 4114:    draw_list->PrimReserve(idx_count_max, vtx_count_max);
   905424: 4114-block 33
call    0 returned 905424
   905424: 4115:    ImDrawVert*  vtx_write = draw_list->_VtxWritePtr;
   905424: 4116:    ImDrawIdx*   idx_write = draw_list->_IdxWritePtr;
   905424: 4117:    unsigned int vtx_index = draw_list->_VtxCurrentIdx;
        -: 4118:
   905424: 4119:    const ImU32 col_untinted = col | ~IM_COL32_A_MASK;
   905424: 4120:    const char* word_wrap_eol = NULL;
        -: 4121:
  2540444: 4122:    while (s < text_end)
  2540444: 4122-block 79
branch  0 taken 1635020
branch  1 taken 905424 (fallthrough)
        -: 4123:    {
  1635020: 4124:        if (word_wrap_enabled)
  1635020: 4124-block 35
branch  0 taken 0 (fallthrough)
branch  1 taken 1635020
        -: 4125:        {
        -: 4126:            // Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.
    #####: 4127:            if (!word_wrap_eol)
    %%%%%: 4127-block 36
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4128:                word_wrap_eol = CalcWordWrapPositionA(scale, s, text_end, wrap_width - (x - start_x));
    %%%%%: 4128-block 37
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%: 4128-block 38
        -: 4129:
    #####: 4130:            if (s >= word_wrap_eol)
    %%%%%: 4130-block 39
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4131:            {
    #####: 4132:                x = start_x;
    #####: 4133:                y += line_height;
    #####: 4134:                if (y > clip_rect.w)
    %%%%%: 4134-block 40
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4135:                    break; // break out of main loop
    %%%%%: 4135-block 41
    %%%%%: 4135-block 77
    #####: 4136:                word_wrap_eol = NULL;
    #####: 4137:                s = CalcWordWrapNextLineStartA(s, text_end); // Wrapping skips upcoming blanks
    %%%%%: 4137-block 42
call    0 never executed
    #####: 4138:                continue;
    %%%%%: 4138-block 78
        -: 4139:            }
        -: 4140:        }
        -: 4141:
        -: 4142:        // Decode and advance source
  1635020: 4143:        unsigned int c = (unsigned int)*s;
  1635020: 4144:        if (c < 0x80)
  1635020: 4144-block 44
branch  0 taken 1624325 (fallthrough)
branch  1 taken 10695
  1624325: 4145:            s += 1;
  1624325: 4145-block 45
        -: 4146:        else
    10695: 4147:            s += ImTextCharFromUtf8(&c, s, text_end);
    10695: 4147-block 46
call    0 returned 10695
branch  1 taken 10695 (fallthrough)
branch  2 taken 0 (throw)
    10695: 4147-block 47
        -: 4148:
  1635020: 4149:        if (c < 32)
  1635020: 4149-block 48
branch  0 taken 0 (fallthrough)
branch  1 taken 1635020
        -: 4150:        {
    #####: 4151:            if (c == '\n')
    %%%%%: 4151-block 49
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4152:            {
    #####: 4153:                x = start_x;
    #####: 4154:                y += line_height;
    #####: 4155:                if (y > clip_rect.w)
    %%%%%: 4155-block 50
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4156:                    break; // break out of main loop
    %%%%%: 4156-block 51
    #####: 4157:                continue;
    %%%%%: 4157-block 52
        -: 4158:            }
    #####: 4159:            if (c == '\r')
    %%%%%: 4159-block 53
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4160:                continue;
    %%%%%: 4160-block 54
        -: 4161:        }
        -: 4162:
  1635020: 4163:        const ImFontGlyph* glyph = FindGlyph((ImWchar)c);
  1635020: 4163-block 55
call    0 returned 1635020
 1635020*: 4164:        if (glyph == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 1635020
    #####: 4165:            continue;
    %%%%%: 4165-block 57
        -: 4166:
  1635020: 4167:        float char_width = glyph->AdvanceX * scale;
  1635020: 4168:        if (glyph->Visible)
  1635020: 4168-block 58
branch  0 taken 1419092 (fallthrough)
branch  1 taken 215928
        -: 4169:        {
        -: 4170:            // We don't do a second finer clipping test on the Y axis as we've already skipped anything before clip_rect.y and exit once we pass clip_rect.w
  1419092: 4171:            float x1 = x + glyph->X0 * scale;
  1419092: 4172:            float x2 = x + glyph->X1 * scale;
  1419092: 4173:            float y1 = y + glyph->Y0 * scale;
  1419092: 4174:            float y2 = y + glyph->Y1 * scale;
  1419092: 4175:            if (x1 <= clip_rect.z && x2 >= clip_rect.x)
  1419092: 4175-block 59
branch  0 taken 938972 (fallthrough)
branch  1 taken 480120
   938972: 4175-block 60
branch  2 taken 938972 (fallthrough)
branch  3 taken 0
        -: 4176:            {
        -: 4177:                // Render a character
   938972: 4178:                float u1 = glyph->U0;
   938972: 4179:                float v1 = glyph->V0;
   938972: 4180:                float u2 = glyph->U1;
   938972: 4181:                float v2 = glyph->V1;
        -: 4182:
        -: 4183:                // CPU side clipping used to fit text in their frame when the frame is too small. Only does clipping for axis aligned quads.
   938972: 4184:                if (cpu_fine_clip)
   938972: 4184-block 61
branch  0 taken 67715 (fallthrough)
branch  1 taken 871257
        -: 4185:                {
    67715: 4186:                    if (x1 < clip_rect.x)
    67715: 4186-block 62
branch  0 taken 0 (fallthrough)
branch  1 taken 67715
        -: 4187:                    {
    #####: 4188:                        u1 = u1 + (1.0f - (x2 - clip_rect.x) / (x2 - x1)) * (u2 - u1);
    #####: 4189:                        x1 = clip_rect.x;
    %%%%%: 4189-block 63
        -: 4190:                    }
    67715: 4191:                    if (y1 < clip_rect.y)
    67715: 4191-block 64
branch  0 taken 0 (fallthrough)
branch  1 taken 67715
        -: 4192:                    {
    #####: 4193:                        v1 = v1 + (1.0f - (y2 - clip_rect.y) / (y2 - y1)) * (v2 - v1);
    #####: 4194:                        y1 = clip_rect.y;
    %%%%%: 4194-block 65
        -: 4195:                    }
    67715: 4196:                    if (x2 > clip_rect.z)
    67715: 4196-block 66
branch  0 taken 25824 (fallthrough)
branch  1 taken 41891
        -: 4197:                    {
    25824: 4198:                        u2 = u1 + ((clip_rect.z - x1) / (x2 - x1)) * (u2 - u1);
    25824: 4199:                        x2 = clip_rect.z;
    25824: 4199-block 67
        -: 4200:                    }
    67715: 4201:                    if (y2 > clip_rect.w)
    67715: 4201-block 68
branch  0 taken 0 (fallthrough)
branch  1 taken 67715
        -: 4202:                    {
    #####: 4203:                        v2 = v1 + ((clip_rect.w - y1) / (y2 - y1)) * (v2 - v1);
    #####: 4204:                        y2 = clip_rect.w;
    %%%%%: 4204-block 69
        -: 4205:                    }
   67715*: 4206:                    if (y1 >= y2)
    67715: 4206-block 70
branch  0 taken 0 (fallthrough)
branch  1 taken 67715
        -: 4207:                    {
    #####: 4208:                        x += char_width;
    #####: 4209:                        continue;
    %%%%%: 4209-block 71
        -: 4210:                    }
        -: 4211:                }
        -: 4212:
        -: 4213:                // Support for untinted glyphs
  938972*: 4214:                ImU32 glyph_col = glyph->Colored ? col_untinted : col;
   938972: 4214-block 72
branch  0 taken 938972 (fallthrough)
branch  1 taken 0
   938972: 4214-block 73
    %%%%%: 4214-block 74
        -: 4215:
        -: 4216:                // We are NOT calling PrimRectUV() here because non-inlined causes too much overhead in a debug builds. Inlined here:
        -: 4217:                {
   938972: 4218:                    vtx_write[0].pos.x = x1; vtx_write[0].pos.y = y1; vtx_write[0].col = glyph_col; vtx_write[0].uv.x = u1; vtx_write[0].uv.y = v1;
   938972: 4219:                    vtx_write[1].pos.x = x2; vtx_write[1].pos.y = y1; vtx_write[1].col = glyph_col; vtx_write[1].uv.x = u2; vtx_write[1].uv.y = v1;
   938972: 4220:                    vtx_write[2].pos.x = x2; vtx_write[2].pos.y = y2; vtx_write[2].col = glyph_col; vtx_write[2].uv.x = u2; vtx_write[2].uv.y = v2;
   938972: 4221:                    vtx_write[3].pos.x = x1; vtx_write[3].pos.y = y2; vtx_write[3].col = glyph_col; vtx_write[3].uv.x = u1; vtx_write[3].uv.y = v2;
   938972: 4222:                    idx_write[0] = (ImDrawIdx)(vtx_index); idx_write[1] = (ImDrawIdx)(vtx_index + 1); idx_write[2] = (ImDrawIdx)(vtx_index + 2);
   938972: 4223:                    idx_write[3] = (ImDrawIdx)(vtx_index); idx_write[4] = (ImDrawIdx)(vtx_index + 2); idx_write[5] = (ImDrawIdx)(vtx_index + 3);
   938972: 4224:                    vtx_write += 4;
   938972: 4225:                    vtx_index += 4;
   938972: 4226:                    idx_write += 6;
   938972: 4226-block 75
        -: 4227:                }
        -: 4228:            }
        -: 4229:        }
  1635020: 4230:        x += char_width;
  1635020: 4230-block 76
        -: 4231:    }
        -: 4232:
        -: 4233:    // Give back unused vertices (clipped ones, blanks) ~ this is essentially a PrimUnreserve() action.
   905424: 4234:    draw_list->VtxBuffer.Size = (int)(vtx_write - draw_list->VtxBuffer.Data); // Same as calling shrink()
   905424: 4235:    draw_list->IdxBuffer.Size = (int)(idx_write - draw_list->IdxBuffer.Data);
   905424: 4236:    draw_list->CmdBuffer[draw_list->CmdBuffer.Size - 1].ElemCount -= (idx_expected_size - draw_list->IdxBuffer.Size);
   905424: 4236-block 80
call    0 returned 905424
   905424: 4237:    draw_list->_VtxWritePtr = vtx_write;
   905424: 4238:    draw_list->_IdxWritePtr = idx_write;
   905424: 4239:    draw_list->_VtxCurrentIdx = vtx_index;
        -: 4240:}
        -: 4241:
        -: 4242://-----------------------------------------------------------------------------
        -: 4243:// [SECTION] ImGui Internal Render Helpers
        -: 4244://-----------------------------------------------------------------------------
        -: 4245:// Vaguely redesigned to stop accessing ImGui global state:
        -: 4246:// - RenderArrow()
        -: 4247:// - RenderBullet()
        -: 4248:// - RenderCheckMark()
        -: 4249:// - RenderArrowDockMenu()
        -: 4250:// - RenderArrowPointingAt()
        -: 4251:// - RenderRectFilledRangeH()
        -: 4252:// - RenderRectFilledWithHole()
        -: 4253://-----------------------------------------------------------------------------
        -: 4254:// Function in need of a redesign (legacy mess)
        -: 4255:// - RenderColorRectWithAlphaCheckerboard()
        -: 4256://-----------------------------------------------------------------------------
        -: 4257:
        -: 4258:// Render an arrow aimed to be aligned with text (p_min is a position in the same space text would be positioned). To e.g. denote expanded/collapsed state
function _ZN5ImGui11RenderArrowEP10ImDrawList6ImVec2j8ImGuiDirf called 1077 returned 100% blocks executed 55%
     1077: 4259:void ImGui::RenderArrow(ImDrawList* draw_list, ImVec2 pos, ImU32 col, ImGuiDir dir, float scale)
        -: 4260:{
     1077: 4261:    const float h = draw_list->_Data->FontSize * 1.00f;
     1077: 4262:    float r = h * 0.40f * scale;
     1077: 4263:    ImVec2 center = pos + ImVec2(h * 0.50f, h * 0.50f * scale);
     1077: 4263-block 2
call    0 returned 1077
call    1 returned 1077
        -: 4264:
     1077: 4265:    ImVec2 a, b, c;
     1077: 4266:    switch (dir)
branch  0 taken 1077
branch  1 taken 0
branch  2 taken 0
branch  3 taken 0
        -: 4267:    {
     1077: 4268:    case ImGuiDir_Up:
        -: 4269:    case ImGuiDir_Down:
    1077*: 4270:        if (dir == ImGuiDir_Up) r = -r;
     1077: 4270-block 5
branch  0 taken 0 (fallthrough)
branch  1 taken 1077
    %%%%%: 4270-block 6
     1077: 4271:        a = ImVec2(+0.000f, +0.750f) * r;
     1077: 4271-block 7
call    0 returned 1077
call    1 returned 1077
     1077: 4272:        b = ImVec2(-0.866f, -0.750f) * r;
call    0 returned 1077
call    1 returned 1077
     1077: 4273:        c = ImVec2(+0.866f, -0.750f) * r;
call    0 returned 1077
call    1 returned 1077
     1077: 4274:        break;
    #####: 4275:    case ImGuiDir_Left:
        -: 4276:    case ImGuiDir_Right:
    #####: 4277:        if (dir == ImGuiDir_Left) r = -r;
    %%%%%: 4277-block 14
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4277-block 15
    #####: 4278:        a = ImVec2(+0.750f, +0.000f) * r;
    %%%%%: 4278-block 16
call    0 never executed
call    1 never executed
    #####: 4279:        b = ImVec2(-0.750f, +0.866f) * r;
call    0 never executed
call    1 never executed
    #####: 4280:        c = ImVec2(-0.750f, -0.866f) * r;
call    0 never executed
call    1 never executed
    #####: 4281:        break;
    #####: 4282:    case ImGuiDir_None:
        -: 4283:    case ImGuiDir_COUNT:
    #####: 4284:        IM_ASSERT(0);
    %%%%%: 4284-block 23
call    0 never executed
        -: 4285:        break;
        -: 4286:    }
     1077: 4287:    draw_list->AddTriangleFilled(center + a, center + b, center + c, col);
     1077: 4287-block 24
call    0 returned 1077
call    1 returned 1077
call    2 returned 1077
call    3 returned 1077
branch  4 taken 1077 (fallthrough)
branch  5 taken 0 (throw)
    $$$$$: 4287-block 29
    $$$$$: 4287-block 30
    $$$$$: 4287-block 31
     1077: 4288:}
     1077: 4288-block 28
        -: 4289:
function _ZN5ImGui12RenderBulletEP10ImDrawList6ImVec2j called 0 returned 0% blocks executed 0%
    #####: 4290:void ImGui::RenderBullet(ImDrawList* draw_list, ImVec2 pos, ImU32 col)
        -: 4291:{
        -: 4292:    // FIXME-OPT: This should be baked in font.
    #####: 4293:    draw_list->AddCircleFilled(pos, draw_list->_Data->FontSize * 0.20f, col, 8);
    %%%%%: 4293-block 2
call    0 never executed
    #####: 4294:}
        -: 4295:
function _ZN5ImGui15RenderCheckMarkEP10ImDrawList6ImVec2jf called 0 returned 0% blocks executed 0%
    #####: 4296:void ImGui::RenderCheckMark(ImDrawList* draw_list, ImVec2 pos, ImU32 col, float sz)
        -: 4297:{
    #####: 4298:    float thickness = ImMax(sz / 5.0f, 1.0f);
    %%%%%: 4298-block 2
call    0 never executed
    #####: 4299:    sz -= thickness * 0.5f;
    #####: 4300:    pos += ImVec2(thickness * 0.25f, thickness * 0.25f);
call    0 never executed
call    1 never executed
        -: 4301:
    #####: 4302:    float third = sz / 3.0f;
    #####: 4303:    float bx = pos.x + third;
    #####: 4304:    float by = pos.y + sz - third * 0.5f;
    #####: 4305:    draw_list->PathLineTo(ImVec2(bx - third, by - third));
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$: 4305-block 13
call    4 never executed
    #####: 4306:    draw_list->PathLineTo(ImVec2(bx, by));
    %%%%%: 4306-block 7
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$: 4306-block 14
call    4 never executed
    #####: 4307:    draw_list->PathLineTo(ImVec2(bx + third * 2.0f, by - third * 2.0f));
    %%%%%: 4307-block 9
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####: 4308:    draw_list->PathStroke(col, 0, thickness);
    %%%%%: 4308-block 11
call    0 never executed
    #####: 4309:}
        -: 4310:
        -: 4311:// Render an arrow. 'pos' is position of the arrow tip. half_sz.x is length from base to tip. half_sz.y is length on each side.
function _ZN5ImGui21RenderArrowPointingAtEP10ImDrawList6ImVec2S2_8ImGuiDirj called 5380 returned 100% blocks executed 26%
     5380: 4312:void ImGui::RenderArrowPointingAt(ImDrawList* draw_list, ImVec2 pos, ImVec2 half_sz, ImGuiDir direction, ImU32 col)
        -: 4313:{
     5380: 4314:    switch (direction)
     5380: 4314-block 2
branch  0 taken 0
branch  1 taken 0
branch  2 taken 0
branch  3 taken 5380
branch  4 taken 0
branch  5 taken 0
        -: 4315:    {
    #####: 4316:    case ImGuiDir_Left:  draw_list->AddTriangleFilled(ImVec2(pos.x + half_sz.x, pos.y - half_sz.y), ImVec2(pos.x + half_sz.x, pos.y + half_sz.y), pos, col); return;
    %%%%%: 4316-block 3
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 4316-block 6
    $$$$$: 4316-block 21
    $$$$$: 4316-block 22
call    5 never executed
    #####: 4317:    case ImGuiDir_Right: draw_list->AddTriangleFilled(ImVec2(pos.x - half_sz.x, pos.y + half_sz.y), ImVec2(pos.x - half_sz.x, pos.y - half_sz.y), pos, col); return;
    %%%%%: 4317-block 7
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 4317-block 10
    $$$$$: 4317-block 23
    $$$$$: 4317-block 24
call    5 never executed
    #####: 4318:    case ImGuiDir_Up:    draw_list->AddTriangleFilled(ImVec2(pos.x + half_sz.x, pos.y + half_sz.y), ImVec2(pos.x - half_sz.x, pos.y + half_sz.y), pos, col); return;
    %%%%%: 4318-block 11
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 4318-block 14
    $$$$$: 4318-block 25
    $$$$$: 4318-block 26
call    5 never executed
     5380: 4319:    case ImGuiDir_Down:  draw_list->AddTriangleFilled(ImVec2(pos.x - half_sz.x, pos.y - half_sz.y), ImVec2(pos.x + half_sz.x, pos.y - half_sz.y), pos, col); return;
     5380: 4319-block 15
call    0 returned 5380
call    1 returned 5380
call    2 returned 5380
branch  3 taken 5380 (fallthrough)
branch  4 taken 0 (throw)
     5380: 4319-block 18
    $$$$$: 4319-block 27
    #####: 4320:    case ImGuiDir_None: case ImGuiDir_COUNT: break; // Fix warnings
    %%%%%: 4320-block 19
        -: 4321:    }
        -: 4322:}
        -: 4323:
        -: 4324:// This is less wide than RenderArrow() and we use in dock nodes instead of the regular RenderArrow() to denote a change of functionality,
        -: 4325:// and because the saved space means that the left-most tab label can stay at exactly the same position as the label of a loose window.
function _ZN5ImGui19RenderArrowDockMenuEP10ImDrawList6ImVec2fj called 5380 returned 100% blocks executed 69%
     5380: 4326:void ImGui::RenderArrowDockMenu(ImDrawList* draw_list, ImVec2 p_min, float sz, ImU32 col)
        -: 4327:{
     5380: 4328:    draw_list->AddRectFilled(p_min + ImVec2(sz * 0.20f, sz * 0.15f), p_min + ImVec2(sz * 0.80f, sz * 0.30f), col);
     5380: 4328-block 2
call    0 returned 5380
call    1 returned 5380
call    2 returned 5380
call    3 returned 5380
call    4 returned 5380
branch  5 taken 5380 (fallthrough)
branch  6 taken 0 (throw)
    $$$$$: 4328-block 12
    $$$$$: 4328-block 13
    $$$$$: 4328-block 14
    $$$$$: 4328-block 15
call    7 never executed
     5380: 4329:    RenderArrowPointingAt(draw_list, p_min + ImVec2(sz * 0.50f, sz * 0.85f), ImVec2(sz * 0.30f, sz * 0.40f), ImGuiDir_Down, col);
     5380: 4329-block 7
call    0 returned 5380
call    1 returned 5380
call    2 returned 5380
call    3 returned 5380
branch  4 taken 5380 (fallthrough)
branch  5 taken 0 (throw)
    $$$$$: 4329-block 16
     5380: 4330:}
     5380: 4330-block 11
        -: 4331:
function _ZL8ImAcos01f called 0 returned 0% blocks executed 0%
    #####: 4332:static inline float ImAcos01(float x)
        -: 4333:{
    #####: 4334:    if (x <= 0.0f) return IM_PI * 0.5f;
    %%%%%: 4334-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4334-block 3
    #####: 4335:    if (x >= 1.0f) return 0.0f;
    %%%%%: 4335-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4335-block 5
    #####: 4336:    return ImAcos(x);
    %%%%%: 4336-block 6
        -: 4337:    //return (-0.69813170079773212f * x * x - 0.87266462599716477f) * x + 1.5707963267948966f; // Cheap approximation, may be enough for what we do.
        -: 4338:}
        -: 4339:
        -: 4340:// FIXME: Cleanup and move code to ImDrawList.
function _ZN5ImGui22RenderRectFilledRangeHEP10ImDrawListRK6ImRectjfff called 0 returned 0% blocks executed 0%
    #####: 4341:void ImGui::RenderRectFilledRangeH(ImDrawList* draw_list, const ImRect& rect, ImU32 col, float x_start_norm, float x_end_norm, float rounding)
        -: 4342:{
    #####: 4343:    if (x_end_norm == x_start_norm)
    %%%%%: 4343-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4344:        return;
    %%%%%: 4344-block 3
    %%%%%: 4344-block 61
    #####: 4345:    if (x_start_norm > x_end_norm)
    %%%%%: 4345-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4346:        ImSwap(x_start_norm, x_end_norm);
    %%%%%: 4346-block 5
call    0 never executed
        -: 4347:
    #####: 4348:    ImVec2 p0 = ImVec2(ImLerp(rect.Min.x, rect.Max.x, x_start_norm), rect.Min.y);
    %%%%%: 4348-block 6
call    0 never executed
call    1 never executed
    #####: 4349:    ImVec2 p1 = ImVec2(ImLerp(rect.Min.x, rect.Max.x, x_end_norm), rect.Max.y);
call    0 never executed
call    1 never executed
    #####: 4350:    if (rounding == 0.0f)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4351:    {
    #####: 4352:        draw_list->AddRectFilled(p0, p1, col, 0.0f);
    %%%%%: 4352-block 11
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####: 4353:        return;
    %%%%%: 4353-block 12
        -: 4354:    }
        -: 4355:
    #####: 4356:    rounding = ImClamp(ImMin((rect.Max.x - rect.Min.x) * 0.5f, (rect.Max.y - rect.Min.y) * 0.5f) - 1.0f, 0.0f, rounding);
    %%%%%: 4356-block 13
call    0 never executed
call    1 never executed
    #####: 4357:    const float inv_rounding = 1.0f / rounding;
    #####: 4358:    const float arc0_b = ImAcos01(1.0f - (p0.x - rect.Min.x) * inv_rounding);
call    0 never executed
    #####: 4359:    const float arc0_e = ImAcos01(1.0f - (p1.x - rect.Min.x) * inv_rounding);
call    0 never executed
    #####: 4360:    const float half_pi = IM_PI * 0.5f; // We will == compare to this because we know this is the exact value ImAcos01 can return.
    #####: 4361:    const float x0 = ImMax(p0.x, rect.Min.x + rounding);
call    0 never executed
    #####: 4362:    if (arc0_b == arc0_e)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4363:    {
    #####: 4364:        draw_list->PathLineTo(ImVec2(x0, p1.y));
    %%%%%: 4364-block 19
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$: 4364-block 63
    #####: 4365:        draw_list->PathLineTo(ImVec2(x0, p0.y));
    %%%%%: 4365-block 21
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 4365-block 23
    $$$$$: 4365-block 64
        -: 4366:    }
    #####: 4367:    else if (arc0_b == 0.0f && arc0_e == half_pi)
    %%%%%: 4367-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4367-block 25
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 4368:    {
    #####: 4369:        draw_list->PathArcToFast(ImVec2(x0, p1.y - rounding), rounding, 3, 6); // BL
    %%%%%: 4369-block 26
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$: 4369-block 65
    #####: 4370:        draw_list->PathArcToFast(ImVec2(x0, p0.y + rounding), rounding, 6, 9); // TR
    %%%%%: 4370-block 28
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 4370-block 30
    $$$$$: 4370-block 66
        -: 4371:    }
        -: 4372:    else
        -: 4373:    {
    #####: 4374:        draw_list->PathArcTo(ImVec2(x0, p1.y - rounding), rounding, IM_PI - arc0_e, IM_PI - arc0_b); // BL
    %%%%%: 4374-block 31
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$: 4374-block 67
    #####: 4375:        draw_list->PathArcTo(ImVec2(x0, p0.y + rounding), rounding, IM_PI + arc0_b, IM_PI + arc0_e); // TR
    %%%%%: 4375-block 33
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 4375-block 35
    $$$$$: 4375-block 68
        -: 4376:    }
    #####: 4377:    if (p1.x > rect.Min.x + rounding)
    %%%%%: 4377-block 36
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4378:    {
    #####: 4379:        const float arc1_b = ImAcos01(1.0f - (rect.Max.x - p1.x) * inv_rounding);
    %%%%%: 4379-block 37
call    0 never executed
    #####: 4380:        const float arc1_e = ImAcos01(1.0f - (rect.Max.x - p0.x) * inv_rounding);
call    0 never executed
    #####: 4381:        const float x1 = ImMin(p1.x, rect.Max.x - rounding);
call    0 never executed
    #####: 4382:        if (arc1_b == arc1_e)
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4383:        {
    #####: 4384:            draw_list->PathLineTo(ImVec2(x1, p0.y));
    %%%%%: 4384-block 41
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$: 4384-block 69
    #####: 4385:            draw_list->PathLineTo(ImVec2(x1, p1.y));
    %%%%%: 4385-block 43
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 4385-block 45
    $$$$$: 4385-block 70
        -: 4386:        }
    #####: 4387:        else if (arc1_b == 0.0f && arc1_e == half_pi)
    %%%%%: 4387-block 46
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4387-block 47
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 4388:        {
    #####: 4389:            draw_list->PathArcToFast(ImVec2(x1, p0.y + rounding), rounding, 9, 12); // TR
    %%%%%: 4389-block 48
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$: 4389-block 71
    #####: 4390:            draw_list->PathArcToFast(ImVec2(x1, p1.y - rounding), rounding, 0, 3);  // BR
    %%%%%: 4390-block 50
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 4390-block 52
    $$$$$: 4390-block 72
        -: 4391:        }
        -: 4392:        else
        -: 4393:        {
    #####: 4394:            draw_list->PathArcTo(ImVec2(x1, p0.y + rounding), rounding, -arc1_e, -arc1_b); // TR
    %%%%%: 4394-block 53
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    $$$$$: 4394-block 73
    #####: 4395:            draw_list->PathArcTo(ImVec2(x1, p1.y - rounding), rounding, +arc1_b, +arc1_e); // BR
    %%%%%: 4395-block 55
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%: 4395-block 57
    $$$$$: 4395-block 74
        -: 4396:        }
        -: 4397:    }
    #####: 4398:    draw_list->PathFillConvex(col);
    %%%%%: 4398-block 59
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -: 4399:}
        -: 4400:
function _ZN5ImGui24RenderRectFilledWithHoleEP10ImDrawListRK6ImRectS4_jf called 0 returned 0% blocks executed 0%
    #####: 4401:void ImGui::RenderRectFilledWithHole(ImDrawList* draw_list, const ImRect& outer, const ImRect& inner, ImU32 col, float rounding)
        -: 4402:{
    #####: 4403:    const bool fill_L = (inner.Min.x > outer.Min.x);
    #####: 4404:    const bool fill_R = (inner.Max.x < outer.Max.x);
    #####: 4405:    const bool fill_U = (inner.Min.y > outer.Min.y);
    #####: 4406:    const bool fill_D = (inner.Max.y < outer.Max.y);
    #####: 4407:    if (fill_L) draw_list->AddRectFilled(ImVec2(outer.Min.x, inner.Min.y), ImVec2(inner.Min.x, inner.Max.y), col, rounding, ImDrawFlags_RoundCornersNone | (fill_U ? 0 : ImDrawFlags_RoundCornersTopLeft)    | (fill_D ? 0 : ImDrawFlags_RoundCornersBottomLeft));
    %%%%%: 4407-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4407-block 3
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4407-block 4
    %%%%%: 4407-block 5
    %%%%%: 4407-block 6
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 4407-block 7
    %%%%%: 4407-block 8
    %%%%%: 4407-block 9
call    6 never executed
call    7 never executed
call    8 never executed
branch  9 never executed (fallthrough)
branch 10 never executed (throw)
    %%%%%: 4407-block 12
    $$$$$: 4407-block 71
    $$$$$: 4407-block 72
call   11 never executed
    #####: 4408:    if (fill_R) draw_list->AddRectFilled(ImVec2(inner.Max.x, inner.Min.y), ImVec2(outer.Max.x, inner.Max.y), col, rounding, ImDrawFlags_RoundCornersNone | (fill_U ? 0 : ImDrawFlags_RoundCornersTopRight)   | (fill_D ? 0 : ImDrawFlags_RoundCornersBottomRight));
    %%%%%: 4408-block 13
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4408-block 14
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4408-block 15
    %%%%%: 4408-block 16
    %%%%%: 4408-block 17
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 4408-block 18
    %%%%%: 4408-block 19
    %%%%%: 4408-block 20
call    6 never executed
call    7 never executed
call    8 never executed
branch  9 never executed (fallthrough)
branch 10 never executed (throw)
    %%%%%: 4408-block 23
    $$$$$: 4408-block 73
    $$$$$: 4408-block 74
call   11 never executed
    #####: 4409:    if (fill_U) draw_list->AddRectFilled(ImVec2(inner.Min.x, outer.Min.y), ImVec2(inner.Max.x, inner.Min.y), col, rounding, ImDrawFlags_RoundCornersNone | (fill_L ? 0 : ImDrawFlags_RoundCornersTopLeft)    | (fill_R ? 0 : ImDrawFlags_RoundCornersTopRight));
    %%%%%: 4409-block 24
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4409-block 25
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4409-block 26
    %%%%%: 4409-block 27
    %%%%%: 4409-block 28
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 4409-block 29
    %%%%%: 4409-block 30
    %%%%%: 4409-block 31
call    6 never executed
call    7 never executed
call    8 never executed
branch  9 never executed (fallthrough)
branch 10 never executed (throw)
    %%%%%: 4409-block 34
    $$$$$: 4409-block 75
    $$$$$: 4409-block 76
call   11 never executed
    #####: 4410:    if (fill_D) draw_list->AddRectFilled(ImVec2(inner.Min.x, inner.Max.y), ImVec2(inner.Max.x, outer.Max.y), col, rounding, ImDrawFlags_RoundCornersNone | (fill_L ? 0 : ImDrawFlags_RoundCornersBottomLeft) | (fill_R ? 0 : ImDrawFlags_RoundCornersBottomRight));
    %%%%%: 4410-block 35
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4410-block 36
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4410-block 37
    %%%%%: 4410-block 38
    %%%%%: 4410-block 39
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 4410-block 40
    %%%%%: 4410-block 41
    %%%%%: 4410-block 42
call    6 never executed
call    7 never executed
call    8 never executed
branch  9 never executed (fallthrough)
branch 10 never executed (throw)
    %%%%%: 4410-block 45
    $$$$$: 4410-block 77
    $$$$$: 4410-block 78
call   11 never executed
    #####: 4411:    if (fill_L && fill_U) draw_list->AddRectFilled(ImVec2(outer.Min.x, outer.Min.y), ImVec2(inner.Min.x, inner.Min.y), col, rounding, ImDrawFlags_RoundCornersTopLeft);
    %%%%%: 4411-block 46
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4411-block 47
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4411-block 48
call    4 never executed
call    5 never executed
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed (throw)
    %%%%%: 4411-block 51
    $$$$$: 4411-block 79
    $$$$$: 4411-block 80
call    9 never executed
    #####: 4412:    if (fill_R && fill_U) draw_list->AddRectFilled(ImVec2(inner.Max.x, outer.Min.y), ImVec2(outer.Max.x, inner.Min.y), col, rounding, ImDrawFlags_RoundCornersTopRight);
    %%%%%: 4412-block 52
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4412-block 53
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4412-block 54
call    4 never executed
call    5 never executed
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed (throw)
    %%%%%: 4412-block 57
    $$$$$: 4412-block 81
    $$$$$: 4412-block 82
call    9 never executed
    #####: 4413:    if (fill_L && fill_D) draw_list->AddRectFilled(ImVec2(outer.Min.x, inner.Max.y), ImVec2(inner.Min.x, outer.Max.y), col, rounding, ImDrawFlags_RoundCornersBottomLeft);
    %%%%%: 4413-block 58
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4413-block 59
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4413-block 60
call    4 never executed
call    5 never executed
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed (throw)
    %%%%%: 4413-block 63
    $$$$$: 4413-block 83
    $$$$$: 4413-block 84
call    9 never executed
    #####: 4414:    if (fill_R && fill_D) draw_list->AddRectFilled(ImVec2(inner.Max.x, inner.Max.y), ImVec2(outer.Max.x, outer.Max.y), col, rounding, ImDrawFlags_RoundCornersBottomRight);
    %%%%%: 4414-block 64
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4414-block 65
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4414-block 66
call    4 never executed
call    5 never executed
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed (throw)
    %%%%%: 4414-block 69
    $$$$$: 4414-block 85
    #####: 4415:}
    %%%%%: 4415-block 70
        -: 4416:
function _ZN5ImGui30CalcRoundingFlagsForRectInRectERK6ImRectS2_f called 5380 returned 100% blocks executed 78%
     5380: 4417:ImDrawFlags ImGui::CalcRoundingFlagsForRectInRect(const ImRect& r_in, const ImRect& r_outer, float threshold)
        -: 4418:{
     5380: 4419:    bool round_l = r_in.Min.x <= r_outer.Min.x + threshold;
     5380: 4420:    bool round_r = r_in.Max.x >= r_outer.Max.x - threshold;
     5380: 4421:    bool round_t = r_in.Min.y <= r_outer.Min.y + threshold;
     5380: 4422:    bool round_b = r_in.Max.y >= r_outer.Max.y - threshold;
        -: 4423:    return ImDrawFlags_RoundCornersNone
     5380: 4424:        | ((round_t && round_l) ? ImDrawFlags_RoundCornersTopLeft : 0) | ((round_t && round_r) ? ImDrawFlags_RoundCornersTopRight : 0)
     5380: 4424-block 2
branch  0 taken 3228 (fallthrough)
branch  1 taken 2152
     3228: 4424-block 3
branch  2 taken 1076 (fallthrough)
branch  3 taken 2152
     1076: 4424-block 4
     4304: 4424-block 5
     5380: 4424-block 6
branch  4 taken 3228 (fallthrough)
branch  5 taken 2152
     3228: 4424-block 7
branch  6 taken 1076 (fallthrough)
branch  7 taken 2152
     1076: 4424-block 8
     4304: 4424-block 9
    5380*: 4425:        | ((round_b && round_l) ? ImDrawFlags_RoundCornersBottomLeft : 0) | ((round_b && round_r) ? ImDrawFlags_RoundCornersBottomRight : 0);
     5380: 4425-block 10
branch  0 taken 0 (fallthrough)
branch  1 taken 5380
    %%%%%: 4425-block 11
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4425-block 12
     5380: 4425-block 13
     5380: 4425-block 14
branch  4 taken 0 (fallthrough)
branch  5 taken 5380
    %%%%%: 4425-block 15
branch  6 never executed (fallthrough)
branch  7 never executed
    %%%%%: 4425-block 16
     5380: 4425-block 17
     5380: 4425-block 18
        -: 4426:}
        -: 4427:
        -: 4428:// Helper for ColorPicker4()
        -: 4429:// NB: This is rather brittle and will show artifact when rounding this enabled if rounded corners overlap multiple cells. Caller currently responsible for avoiding that.
        -: 4430:// Spent a non reasonable amount of time trying to getting this right for ColorButton with rounding+anti-aliasing+ImGuiColorEditFlags_HalfAlphaPreview flag + various grid sizes and offsets, and eventually gave up... probably more reasonable to disable rounding altogether.
        -: 4431:// FIXME: uses ImGui::GetColorU32
function _ZN5ImGui36RenderColorRectWithAlphaCheckerboardEP10ImDrawList6ImVec2S2_jfS2_fi called 0 returned 0% blocks executed 0%
    #####: 4432:void ImGui::RenderColorRectWithAlphaCheckerboard(ImDrawList* draw_list, ImVec2 p_min, ImVec2 p_max, ImU32 col, float grid_step, ImVec2 grid_off, float rounding, ImDrawFlags flags)
        -: 4433:{
    #####: 4434:    if ((flags & ImDrawFlags_RoundCornersMask_) == 0)
    %%%%%: 4434-block 2
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4435:        flags = ImDrawFlags_RoundCornersDefault_;
    %%%%%: 4435-block 3
    #####: 4436:    if (((col & IM_COL32_A_MASK) >> IM_COL32_A_SHIFT) < 0xFF)
    %%%%%: 4436-block 4
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 4437:    {
    #####: 4438:        ImU32 col_bg1 = GetColorU32(ImAlphaBlendColors(IM_COL32(204, 204, 204, 255), col));
    %%%%%: 4438-block 5
call    0 never executed
call    1 never executed
    #####: 4439:        ImU32 col_bg2 = GetColorU32(ImAlphaBlendColors(IM_COL32(128, 128, 128, 255), col));
call    0 never executed
call    1 never executed
    #####: 4440:        draw_list->AddRectFilled(p_min, p_max, col_bg1, rounding, flags);
call    0 never executed
        -: 4441:
    #####: 4442:        int yi = 0;
    #####: 4443:        for (float y = p_min.y + grid_off.y; y < p_max.y; y += grid_step, yi++)
    %%%%%: 4443-block 40
    %%%%%: 4443-block 41
branch  0 never executed
branch  1 never executed
        -: 4444:        {
    #####: 4445:            float y1 = ImClamp(y, p_min.y, p_max.y), y2 = ImMin(y + grid_step, p_max.y);
    %%%%%: 4445-block 11
call    0 never executed
call    1 never executed
    #####: 4446:            if (y2 <= y1)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4447:                continue;
    %%%%%: 4447-block 14
    #####: 4448:            for (float x = p_min.x + grid_off.x + (yi & 1) * grid_step; x < p_max.x; x += grid_step * 2.0f)
    %%%%%: 4448-block 15
    %%%%%: 4448-block 38
    %%%%%: 4448-block 39
branch  0 never executed
branch  1 never executed (fallthrough)
        -: 4449:            {
    #####: 4450:                float x1 = ImClamp(x, p_min.x, p_max.x), x2 = ImMin(x + grid_step, p_max.x);
    %%%%%: 4450-block 16
call    0 never executed
call    1 never executed
    #####: 4451:                if (x2 <= x1)
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 4452:                    continue;
    %%%%%: 4452-block 19
    #####: 4453:                ImDrawFlags cell_flags = ImDrawFlags_RoundCornersNone;
    #####: 4454:                if (y1 <= p_min.y) { if (x1 <= p_min.x) cell_flags |= ImDrawFlags_RoundCornersTopLeft; if (x2 >= p_max.x) cell_flags |= ImDrawFlags_RoundCornersTopRight; }
    %%%%%: 4454-block 20
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4454-block 21
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4454-block 22
    %%%%%: 4454-block 23
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 4454-block 24
    #####: 4455:                if (y2 >= p_max.y) { if (x1 <= p_min.x) cell_flags |= ImDrawFlags_RoundCornersBottomLeft; if (x2 >= p_max.x) cell_flags |= ImDrawFlags_RoundCornersBottomRight; }
    %%%%%: 4455-block 25
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4455-block 26
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4455-block 27
    %%%%%: 4455-block 28
branch  4 never executed (fallthrough)
branch  5 never executed
    %%%%%: 4455-block 29
        -: 4456:
        -: 4457:                // Combine flags
    #####: 4458:                cell_flags = (flags == ImDrawFlags_RoundCornersNone || cell_flags == ImDrawFlags_RoundCornersNone) ? ImDrawFlags_RoundCornersNone : (cell_flags & flags);
    %%%%%: 4458-block 30
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%: 4458-block 31
branch  2 never executed (fallthrough)
branch  3 never executed
    %%%%%: 4458-block 32
    %%%%%: 4458-block 33
    #####: 4459:                draw_list->AddRectFilled(ImVec2(x1, y1), ImVec2(x2, y2), col_bg2, rounding, cell_flags);
    %%%%%: 4459-block 34
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%: 4459-block 37
    $$$$$: 4459-block 44
        -: 4460:            }
        -: 4461:        }
        -: 4462:    }
        -: 4463:    else
        -: 4464:    {
    #####: 4465:        draw_list->AddRectFilled(p_min, p_max, col, rounding, flags);
    %%%%%: 4465-block 42
call    0 never executed
        -: 4466:    }
    #####: 4467:}
    %%%%%: 4467-block 43
        -: 4468:
        -: 4469://-----------------------------------------------------------------------------
        -: 4470:// [SECTION] Decompression code
        -: 4471://-----------------------------------------------------------------------------
        -: 4472:// Compressed with stb_compress() then converted to a C array and encoded as base85.
        -: 4473:// Use the program in misc/fonts/binary_to_compressed_c.cpp to create the array from a TTF file.
        -: 4474:// The purpose of encoding as base85 instead of "0x00,0x01,..." style is only save on _source code_ size.
        -: 4475:// Decompression from stb.h (public domain) by Sean Barrett https://github.com/nothings/stb/blob/master/stb.h
        -: 4476://-----------------------------------------------------------------------------
        -: 4477:
function _ZL21stb_decompress_lengthPKh called 2 returned 100% blocks executed 100%
        2: 4478:static unsigned int stb_decompress_length(const unsigned char *input)
        -: 4479:{
        2: 4480:    return (input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11];
        2: 4480-block 2
        -: 4481:}
        -: 4482:
        -: 4483:static unsigned char *stb__barrier_out_e, *stb__barrier_out_b;
        -: 4484:static const unsigned char *stb__barrier_in_b;
        -: 4485:static unsigned char *stb__dout;
function _ZL10stb__matchPKhj called 2321 returned 100% blocks executed 70%
     2321: 4486:static void stb__match(const unsigned char *data, unsigned int length)
        -: 4487:{
        -: 4488:    // INVERSE of memmove... write each byte before copying the next...
    2321*: 4489:    IM_ASSERT(stb__dout + length <= stb__barrier_out_e);
     2321: 4489-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 2321
    %%%%%: 4489-block 3
call    2 never executed
    2321*: 4490:    if (stb__dout + length > stb__barrier_out_e) { stb__dout += length; return; }
     2321: 4490-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 2321
    %%%%%: 4490-block 5
    2321*: 4491:    if (data < stb__barrier_out_b) { stb__dout = stb__barrier_out_e+1; return; }
     2321: 4491-block 6
branch  0 taken 0 (fallthrough)
branch  1 taken 2321
    %%%%%: 4491-block 7
    40891: 4492:    while (length--) *stb__dout++ = *data++;
     2321: 4492-block 8
    38570: 4492-block 9
    40891: 4492-block 10
branch  0 taken 38570
branch  1 taken 2321 (fallthrough)
        -: 4493:}
        -: 4494:
function _ZL8stb__litPKhj called 660 returned 100% blocks executed 62%
      660: 4495:static void stb__lit(const unsigned char *data, unsigned int length)
        -: 4496:{
     660*: 4497:    IM_ASSERT(stb__dout + length <= stb__barrier_out_e);
      660: 4497-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 660
    %%%%%: 4497-block 3
call    2 never executed
     660*: 4498:    if (stb__dout + length > stb__barrier_out_e) { stb__dout += length; return; }
      660: 4498-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 660
    %%%%%: 4498-block 5
     660*: 4499:    if (data < stb__barrier_in_b) { stb__dout = stb__barrier_out_e+1; return; }
      660: 4499-block 6
branch  0 taken 0 (fallthrough)
branch  1 taken 660
    %%%%%: 4499-block 7
      660: 4500:    memcpy(stb__dout, data, length);
      660: 4501:    stb__dout += length;
      660: 4501-block 8
        -: 4502:}
        -: 4503:
        -: 4504:#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
        -: 4505:#define stb__in3(x)   ((i[x] << 16) + stb__in2((x)+1))
        -: 4506:#define stb__in4(x)   ((i[x] << 24) + stb__in3((x)+1))
        -: 4507:
function _ZL20stb_decompress_tokenPKh called 2982 returned 100% blocks executed 72%
     2982: 4508:static const unsigned char *stb_decompress_token(const unsigned char *i)
        -: 4509:{
     2982: 4510:    if (*i >= 0x20) { // use fewer if's for cases that expand small
     2982: 4510-block 2
branch  0 taken 2863 (fallthrough)
branch  1 taken 119
     2863: 4511:        if (*i >= 0x80)       stb__match(stb__dout-i[1]-1, i[0] - 0x80 + 1), i += 2;
     2863: 4511-block 3
branch  0 taken 818 (fallthrough)
branch  1 taken 2045
      818: 4511-block 4
call    2 returned 818
     2045: 4512:        else if (*i >= 0x40)  stb__match(stb__dout-(stb__in2(0) - 0x4000 + 1), i[2]+1), i += 3;
     2045: 4512-block 6
branch  0 taken 1392 (fallthrough)
branch  1 taken 653
     1392: 4512-block 7
call    2 returned 1392
      653: 4513:        else /* *i >= 0x20 */ stb__lit(i+1, i[0] - 0x20 + 1), i += 1 + (i[0] - 0x20 + 1);
      653: 4513-block 9
call    0 returned 653
        -: 4514:    } else { // more ifs for cases that expand large, since overhead is amortized
      119: 4515:        if (*i >= 0x18)       stb__match(stb__dout-(stb__in3(0) - 0x180000 + 1), i[3]+1), i += 4;
      119: 4515-block 11
branch  0 taken 111 (fallthrough)
branch  1 taken 8
      111: 4515-block 12
call    2 returned 111
       8*: 4516:        else if (*i >= 0x10)  stb__match(stb__dout-(stb__in3(0) - 0x100000 + 1), stb__in2(3)+1), i += 5;
        8: 4516-block 14
branch  0 taken 0 (fallthrough)
branch  1 taken 8
    %%%%%: 4516-block 15
call    2 never executed
        8: 4517:        else if (*i >= 0x08)  stb__lit(i+2, stb__in2(0) - 0x0800 + 1), i += 2 + (stb__in2(0) - 0x0800 + 1);
        8: 4517-block 17
branch  0 taken 7 (fallthrough)
branch  1 taken 1
        7: 4517-block 18
call    2 returned 7
       1*: 4518:        else if (*i == 0x07)  stb__lit(i+3, stb__in2(1) + 1), i += 3 + (stb__in2(1) + 1);
        1: 4518-block 20
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 4518-block 21
call    2 never executed
       1*: 4519:        else if (*i == 0x06)  stb__match(stb__dout-(stb__in3(1)+1), i[4]+1), i += 5;
        1: 4519-block 23
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 4519-block 24
call    2 never executed
       1*: 4520:        else if (*i == 0x04)  stb__match(stb__dout-(stb__in3(1)+1), stb__in2(4)+1), i += 6;
        1: 4520-block 26
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 4520-block 27
call    2 never executed
        -: 4521:    }
     2982: 4522:    return i;
     2982: 4522-block 29
        -: 4523:}
        -: 4524:
function _ZL11stb_adler32jPhj called 1 returned 100% blocks executed 91%
        1: 4525:static unsigned int stb_adler32(unsigned int adler32, unsigned char *buffer, unsigned int buflen)
        -: 4526:{
        1: 4527:    const unsigned long ADLER_MOD = 65521;
        1: 4528:    unsigned long s1 = adler32 & 0xffff, s2 = adler32 >> 16;
        1: 4529:    unsigned long blocklen = buflen % 5552;
        -: 4530:
        -: 4531:    unsigned long i;
        9: 4532:    while (buflen) {
        1: 4532-block 2
        9: 4532-block 10
branch  0 taken 8
branch  1 taken 1 (fallthrough)
     5159: 4533:        for (i=0; i + 7 < blocklen; i += 8) {
        8: 4533-block 3
     5159: 4533-block 5
branch  0 taken 5151
branch  1 taken 8 (fallthrough)
     5151: 4534:            s1 += buffer[0], s2 += s1;
     5151: 4535:            s1 += buffer[1], s2 += s1;
     5151: 4536:            s1 += buffer[2], s2 += s1;
     5151: 4537:            s1 += buffer[3], s2 += s1;
     5151: 4538:            s1 += buffer[4], s2 += s1;
     5151: 4539:            s1 += buffer[5], s2 += s1;
     5151: 4540:            s1 += buffer[6], s2 += s1;
     5151: 4541:            s1 += buffer[7], s2 += s1;
        -: 4542:
     5151: 4543:            buffer += 8;
     5151: 4543-block 4
        -: 4544:        }
        -: 4545:
       8*: 4546:        for (; i < blocklen; ++i)
        8: 4546-block 6
        8: 4546-block 8
branch  0 taken 0
branch  1 taken 8 (fallthrough)
    #####: 4547:            s1 += *buffer++, s2 += s1;
    %%%%%: 4547-block 7
        -: 4548:
        8: 4549:        s1 %= ADLER_MOD, s2 %= ADLER_MOD;
        8: 4550:        buflen -= blocklen;
        8: 4551:        blocklen = 5552;
        8: 4551-block 9
        -: 4552:    }
        1: 4553:    return (unsigned int)(s2 << 16) + (unsigned int)s1;
        1: 4553-block 11
        -: 4554:}
        -: 4555:
function _ZL14stb_decompressPhPKhj called 1 returned 100% blocks executed 68%
        1: 4556:static unsigned int stb_decompress(unsigned char *output, const unsigned char *i, unsigned int /*length*/)
        -: 4557:{
       1*: 4558:    if (stb__in4(0) != 0x57bC0000) return 0;
        1: 4558-block 2
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 4558-block 3
       1*: 4559:    if (stb__in4(4) != 0)          return 0; // error! stream is > 4GB
        1: 4559-block 4
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 4559-block 5
        1: 4560:    const unsigned int olen = stb_decompress_length(i);
        1: 4560-block 6
call    0 returned 1
        1: 4561:    stb__barrier_in_b = i;
        1: 4562:    stb__barrier_out_e = output + olen;
        1: 4563:    stb__barrier_out_b = output;
        1: 4564:    i += 16;
        -: 4565:
        1: 4566:    stb__dout = output;
        -: 4567:    for (;;) {
     2982: 4568:        const unsigned char *old_i = i;
     2982: 4569:        i = stb_decompress_token(i);
     2982: 4569-block 8
call    0 returned 2982
     2982: 4570:        if (i == old_i) {
branch  0 taken 1 (fallthrough)
branch  1 taken 2981
        1: 4571:            if (*i == 0x05 && i[1] == 0xfa) {
        1: 4571-block 10
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 4571-block 11
branch  2 taken 1 (fallthrough)
branch  3 taken 0
       1*: 4572:                IM_ASSERT(stb__dout == output + olen);
        1: 4572-block 12
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 4572-block 13
call    2 never executed
       1*: 4573:                if (stb__dout != output + olen) return 0;
        1: 4573-block 14
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 4573-block 15
        1: 4574:                if (stb_adler32(1, output, olen) != (unsigned int) stb__in4(2))
        1: 4574-block 16
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    #####: 4575:                    return 0;
    %%%%%: 4575-block 18
        1: 4576:                return olen;
        1: 4576-block 19
        -: 4577:            } else {
    #####: 4578:                IM_ASSERT(0); /* NOTREACHED */
    %%%%%: 4578-block 20
call    0 never executed
        -: 4579:                return 0;
        -: 4580:            }
        -: 4581:        }
    2981*: 4582:        IM_ASSERT(stb__dout <= output + olen);
     2981: 4582-block 21
branch  0 taken 0 (fallthrough)
branch  1 taken 2981
    %%%%%: 4582-block 22
call    2 never executed
     2981: 4583:        if (stb__dout > output + olen)
     2981: 4583-block 23
branch  0 taken 0 (fallthrough)
branch  1 taken 2981
    #####: 4584:            return 0;
    %%%%%: 4584-block 24
     2981: 4585:    }
     2981: 4585-block 25
        -: 4586:}
        -: 4587:
        -: 4588://-----------------------------------------------------------------------------
        -: 4589:// [SECTION] Default font data (ProggyClean.ttf)
        -: 4590://-----------------------------------------------------------------------------
        -: 4591:// ProggyClean.ttf
        -: 4592:// Copyright (c) 2004, 2005 Tristan Grimmer
        -: 4593:// MIT license (see License.txt in http://www.proggyfonts.net/index.php?menu=download)
        -: 4594:// Download and more information at http://www.proggyfonts.net or http://upperboundsinteractive.com/fonts.php
        -: 4595://-----------------------------------------------------------------------------
        -: 4596:// File: 'ProggyClean.ttf' (41208 bytes)
        -: 4597:// Exported using misc/fonts/binary_to_compressed_c.cpp (with compression + base85 string encoding).
        -: 4598:// The purpose of encoding as base85 instead of "0x00,0x01,..." style is only save on _source code_ size.
        -: 4599://-----------------------------------------------------------------------------
        -: 4600:static const char proggy_clean_ttf_compressed_data_base85[11980 + 1] =
        -: 4601:    "7])#######hV0qs'/###[),##/l:$#Q6>##5[n42>c-TH`->>#/e>11NNV=Bv(*:.F?uu#(gRU.o0XGH`$vhLG1hxt9?W`#,5LsCp#-i>.r$<$6pD>Lb';9Crc6tgXmKVeU2cD4Eo3R/"
        -: 4602:    "2*>]b(MC;$jPfY.;h^`IWM9<Lh2TlS+f-s$o6Q<BWH`YiU.xfLq$N;$0iR/GX:U(jcW2p/W*q?-qmnUCI;jHSAiFWM.R*kU@C=GH?a9wp8f$e.-4^Qg1)Q-GL(lf(r/7GrRgwV%MS=C#"
        -: 4603:    "`8ND>Qo#t'X#(v#Y9w0#1D$CIf;W'#pWUPXOuxXuU(H9M(1<q-UE31#^-V'8IRUo7Qf./L>=Ke$$'5F%)]0^#0X@U.a<r:QLtFsLcL6##lOj)#.Y5<-R&KgLwqJfLgN&;Q?gI^#DY2uL"
        -: 4604:    "i@^rMl9t=cWq6##weg>$FBjVQTSDgEKnIS7EM9>ZY9w0#L;>>#Mx&4Mvt//L[MkA#W@lK.N'[0#7RL_&#w+F%HtG9M#XL`N&.,GM4Pg;-<nLENhvx>-VsM.M0rJfLH2eTM`*oJMHRC`N"
        -: 4605:    "kfimM2J,W-jXS:)r0wK#@Fge$U>`w'N7G#$#fB#$E^$#:9:hk+eOe--6x)F7*E%?76%^GMHePW-Z5l'&GiF#$956:rS?dA#fiK:)Yr+`&#0j@'DbG&#^$PG.Ll+DNa<XCMKEV*N)LN/N"
        -: 4606:    "*b=%Q6pia-Xg8I$<MR&,VdJe$<(7G;Ckl'&hF;;$<_=X(b.RS%%)###MPBuuE1V:v&cX&#2m#(&cV]`k9OhLMbn%s$G2,B$BfD3X*sp5#l,$R#]x_X1xKX%b5U*[r5iMfUo9U`N99hG)"
        -: 4607:    "tm+/Us9pG)XPu`<0s-)WTt(gCRxIg(%6sfh=ktMKn3j)<6<b5Sk_/0(^]AaN#(p/L>&VZ>1i%h1S9u5o@YaaW$e+b<TWFn/Z:Oh(Cx2$lNEoN^e)#CFY@@I;BOQ*sRwZtZxRcU7uW6CX"
        -: 4608:    "ow0i(?$Q[cjOd[P4d)]>ROPOpxTO7Stwi1::iB1q)C_=dV26J;2,]7op$]uQr@_V7$q^%lQwtuHY]=DX,n3L#0PHDO4f9>dC@O>HBuKPpP*E,N+b3L#lpR/MrTEH.IAQk.a>D[.e;mc."
        -: 4609:    "x]Ip.PH^'/aqUO/$1WxLoW0[iLA<QT;5HKD+@qQ'NQ(3_PLhE48R.qAPSwQ0/WK?Z,[x?-J;jQTWA0X@KJ(_Y8N-:/M74:/-ZpKrUss?d#dZq]DAbkU*JqkL+nwX@@47`5>w=4h(9.`G"
        -: 4610:    "CRUxHPeR`5Mjol(dUWxZa(>STrPkrJiWx`5U7F#.g*jrohGg`cg:lSTvEY/EV_7H4Q9[Z%cnv;JQYZ5q.l7Zeas:HOIZOB?G<Nald$qs]@]L<J7bR*>gv:[7MI2k).'2($5FNP&EQ(,)"
        -: 4611:    "U]W]+fh18.vsai00);D3@4ku5P?DP8aJt+;qUM]=+b'8@;mViBKx0DE[-auGl8:PJ&Dj+M6OC]O^((##]`0i)drT;-7X`=-H3[igUnPG-NZlo.#k@h#=Ork$m>a>$-?Tm$UV(?#P6YY#"
        -: 4612:    "'/###xe7q.73rI3*pP/$1>s9)W,JrM7SN]'/4C#v$U`0#V.[0>xQsH$fEmPMgY2u7Kh(G%siIfLSoS+MK2eTM$=5,M8p`A.;_R%#u[K#$x4AG8.kK/HSB==-'Ie/QTtG?-.*^N-4B/ZM"
        -: 4613:    "_3YlQC7(p7q)&](`6_c)$/*JL(L-^(]$wIM`dPtOdGA,U3:w2M-0<q-]L_?^)1vw'.,MRsqVr.L;aN&#/EgJ)PBc[-f>+WomX2u7lqM2iEumMTcsF?-aT=Z-97UEnXglEn1K-bnEO`gu"
        -: 4614:    "Ft(c%=;Am_Qs@jLooI&NX;]0#j4#F14;gl8-GQpgwhrq8'=l_f-b49'UOqkLu7-##oDY2L(te+Mch&gLYtJ,MEtJfLh'x'M=$CS-ZZ%P]8bZ>#S?YY#%Q&q'3^Fw&?D)UDNrocM3A76/"
        -: 4615:    "/oL?#h7gl85[qW/NDOk%16ij;+:1a'iNIdb-ou8.P*w,v5#EI$TWS>Pot-R*H'-SEpA:g)f+O$%%`kA#G=8RMmG1&O`>to8bC]T&$,n.LoO>29sp3dt-52U%VM#q7'DHpg+#Z9%H[K<L"
        -: 4616:    "%a2E-grWVM3@2=-k22tL]4$##6We'8UJCKE[d_=%wI;'6X-GsLX4j^SgJ$##R*w,vP3wK#iiW&#*h^D&R?jp7+/u&#(AP##XU8c$fSYW-J95_-Dp[g9wcO&#M-h1OcJlc-*vpw0xUX&#"
        -: 4617:    "OQFKNX@QI'IoPp7nb,QU//MQ&ZDkKP)X<WSVL(68uVl&#c'[0#(s1X&xm$Y%B7*K:eDA323j998GXbA#pwMs-jgD$9QISB-A_(aN4xoFM^@C58D0+Q+q3n0#3U1InDjF682-SjMXJK)("
        -: 4618:    "h$hxua_K]ul92%'BOU&#BRRh-slg8KDlr:%L71Ka:.A;%YULjDPmL<LYs8i#XwJOYaKPKc1h:'9Ke,g)b),78=I39B;xiY$bgGw-&.Zi9InXDuYa%G*f2Bq7mn9^#p1vv%#(Wi-;/Z5h"
        -: 4619:    "o;#2:;%d&#x9v68C5g?ntX0X)pT`;%pB3q7mgGN)3%(P8nTd5L7GeA-GL@+%J3u2:(Yf>et`e;)f#Km8&+DC$I46>#Kr]]u-[=99tts1.qb#q72g1WJO81q+eN'03'eM>&1XxY-caEnO"
        -: 4620:    "j%2n8)),?ILR5^.Ibn<-X-Mq7[a82Lq:F&#ce+S9wsCK*x`569E8ew'He]h:sI[2LM$[guka3ZRd6:t%IG:;$%YiJ:Nq=?eAw;/:nnDq0(CYcMpG)qLN4$##&J<j$UpK<Q4a1]MupW^-"
        -: 4621:    "sj_$%[HK%'F####QRZJ::Y3EGl4'@%FkiAOg#p[##O`gukTfBHagL<LHw%q&OV0##F=6/:chIm0@eCP8X]:kFI%hl8hgO@RcBhS-@Qb$%+m=hPDLg*%K8ln(wcf3/'DW-$.lR?n[nCH-"
        -: 4622:    "eXOONTJlh:.RYF%3'p6sq:UIMA945&^HFS87@$EP2iG<-lCO$%c`uKGD3rC$x0BL8aFn--`ke%#HMP'vh1/R&O_J9'um,.<tx[@%wsJk&bUT2`0uMv7gg#qp/ij.L56'hl;.s5CUrxjO"
        -: 4623:    "M7-##.l+Au'A&O:-T72L]P`&=;ctp'XScX*rU.>-XTt,%OVU4)S1+R-#dg0/Nn?Ku1^0f$B*P:Rowwm-`0PKjYDDM'3]d39VZHEl4,.j']Pk-M.h^&:0FACm$maq-&sgw0t7/6(^xtk%"
        -: 4624:    "LuH88Fj-ekm>GA#_>568x6(OFRl-IZp`&b,_P'$M<Jnq79VsJW/mWS*PUiq76;]/NM_>hLbxfc$mj`,O;&%W2m`Zh:/)Uetw:aJ%]K9h:TcF]u_-Sj9,VK3M.*'&0D[Ca]J9gp8,kAW]"
        -: 4625:    "%(?A%R$f<->Zts'^kn=-^@c4%-pY6qI%J%1IGxfLU9CP8cbPlXv);C=b),<2mOvP8up,UVf3839acAWAW-W?#ao/^#%KYo8fRULNd2.>%m]UK:n%r$'sw]J;5pAoO_#2mO3n,'=H5(et"
        -: 4626:    "Hg*`+RLgv>=4U8guD$I%D:W>-r5V*%j*W:Kvej.Lp$<M-SGZ':+Q_k+uvOSLiEo(<aD/K<CCc`'Lx>'?;++O'>()jLR-^u68PHm8ZFWe+ej8h:9r6L*0//c&iH&R8pRbA#Kjm%upV1g:"
        -: 4627:    "a_#Ur7FuA#(tRh#.Y5K+@?3<-8m0$PEn;J:rh6?I6uG<-`wMU'ircp0LaE_OtlMb&1#6T.#FDKu#1Lw%u%+GM+X'e?YLfjM[VO0MbuFp7;>Q&#WIo)0@F%q7c#4XAXN-U&VB<HFF*qL("
        -: 4628:    "$/V,;(kXZejWO`<[5?\?ewY(*9=%wDc;,u<'9t3W-(H1th3+G]ucQ]kLs7df($/*JL]@*t7Bu_G3_7mp7<iaQjO@.kLg;x3B0lqp7Hf,^Ze7-##@/c58Mo(3;knp0%)A7?-W+eI'o8)b<"
        -: 4629:    "nKnw'Ho8C=Y>pqB>0ie&jhZ[?iLR@@_AvA-iQC(=ksRZRVp7`.=+NpBC%rh&3]R:8XDmE5^V8O(x<<aG/1N$#FX$0V5Y6x'aErI3I$7x%E`v<-BY,)%-?Psf*l?%C3.mM(=/M0:JxG'?"
        -: 4630:    "7WhH%o'a<-80g0NBxoO(GH<dM]n.+%q@jH?f.UsJ2Ggs&4<-e47&Kl+f//9@`b+?.TeN_&B8Ss?v;^Trk;f#YvJkl&w$]>-+k?'(<S:68tq*WoDfZu';mM?8X[ma8W%*`-=;D.(nc7/;"
        -: 4631:    ")g:T1=^J$&BRV(-lTmNB6xqB[@0*o.erM*<SWF]u2=st-*(6v>^](H.aREZSi,#1:[IXaZFOm<-ui#qUq2$##Ri;u75OK#(RtaW-K-F`S+cF]uN`-KMQ%rP/Xri.LRcB##=YL3BgM/3M"
        -: 4632:    "D?@f&1'BW-)Ju<L25gl8uhVm1hL$##*8###'A3/LkKW+(^rWX?5W_8g)a(m&K8P>#bmmWCMkk&#TR`C,5d>g)F;t,4:@_l8G/5h4vUd%&%950:VXD'QdWoY-F$BtUwmfe$YqL'8(PWX("
        -: 4633:    "P?^@Po3$##`MSs?DWBZ/S>+4%>fX,VWv/w'KD`LP5IbH;rTV>n3cEK8U#bX]l-/V+^lj3;vlMb&[5YQ8#pekX9JP3XUC72L,,?+Ni&co7ApnO*5NK,((W-i:$,kp'UDAO(G0Sq7MVjJs"
        -: 4634:    "bIu)'Z,*[>br5fX^:FPAWr-m2KgL<LUN098kTF&#lvo58=/vjDo;.;)Ka*hLR#/k=rKbxuV`>Q_nN6'8uTG&#1T5g)uLv:873UpTLgH+#FgpH'_o1780Ph8KmxQJ8#H72L4@768@Tm&Q"
        -: 4635:    "h4CB/5OvmA&,Q&QbUoi$a_%3M01H)4x7I^&KQVgtFnV+;[Pc>[m4k//,]1?#`VY[Jr*3&&slRfLiVZJ:]?=K3Sw=[$=uRB?3xk48@aeg<Z'<$#4H)6,>e0jT6'N#(q%.O=?2S]u*(m<-"
        -: 4636:    "V8J'(1)G][68hW$5'q[GC&5j`TE?m'esFGNRM)j,ffZ?-qx8;->g4t*:CIP/[Qap7/9'#(1sao7w-.qNUdkJ)tCF&#B^;xGvn2r9FEPFFFcL@.iFNkTve$m%#QvQS8U@)2Z+3K:AKM5i"
        -: 4637:    "sZ88+dKQ)W6>J%CL<KE>`.d*(B`-n8D9oK<Up]c$X$(,)M8Zt7/[rdkqTgl-0cuGMv'?>-XV1q['-5k'cAZ69e;D_?$ZPP&s^+7])$*$#@QYi9,5P&#9r+$%CE=68>K8r0=dSC%%(@p7"
        -: 4638:    ".m7jilQ02'0-VWAg<a/''3u.=4L$Y)6k/K:_[3=&jvL<L0C/2'v:^;-DIBW,B4E68:kZ;%?8(Q8BH=kO65BW?xSG&#@uU,DS*,?.+(o(#1vCS8#CHF>TlGW'b)Tq7VT9q^*^$$.:&N@@"
        -: 4639:    "$&)WHtPm*5_rO0&e%K&#-30j(E4#'Zb.o/(Tpm$>K'f@[PvFl,hfINTNU6u'0pao7%XUp9]5.>%h`8_=VYbxuel.NTSsJfLacFu3B'lQSu/m6-Oqem8T+oE--$0a/k]uj9EwsG>%veR*"
        -: 4640:    "hv^BFpQj:K'#SJ,sB-'#](j.Lg92rTw-*n%@/;39rrJF,l#qV%OrtBeC6/,;qB3ebNW[?,Hqj2L.1NP&GjUR=1D8QaS3Up&@*9wP?+lo7b?@%'k4`p0Z$22%K3+iCZj?XJN4Nm&+YF]u"
        -: 4641:    "@-W$U%VEQ/,,>>#)D<h#`)h0:<Q6909ua+&VU%n2:cG3FJ-%@Bj-DgLr`Hw&HAKjKjseK</xKT*)B,N9X3]krc12t'pgTV(Lv-tL[xg_%=M_q7a^x?7Ubd>#%8cY#YZ?=,`Wdxu/ae&#"
        -: 4642:    "w6)R89tI#6@s'(6Bf7a&?S=^ZI_kS&ai`&=tE72L_D,;^R)7[$s<Eh#c&)q.MXI%#v9ROa5FZO%sF7q7Nwb&#ptUJ:aqJe$Sl68%.D###EC><?-aF&#RNQv>o8lKN%5/$(vdfq7+ebA#"
        -: 4643:    "u1p]ovUKW&Y%q]'>$1@-[xfn$7ZTp7mM,G,Ko7a&Gu%G[RMxJs[0MM%wci.LFDK)(<c`Q8N)jEIF*+?P2a8g%)$q]o2aH8C&<SibC/q,(e:v;-b#6[$NtDZ84Je2KNvB#$P5?tQ3nt(0"
        -: 4644:    "d=j.LQf./Ll33+(;q3L-w=8dX$#WF&uIJ@-bfI>%:_i2B5CsR8&9Z&#=mPEnm0f`<&c)QL5uJ#%u%lJj+D-r;BoF&#4DoS97h5g)E#o:&S4weDF,9^Hoe`h*L+_a*NrLW-1pG_&2UdB8"
        -: 4645:    "6e%B/:=>)N4xeW.*wft-;$'58-ESqr<b?UI(_%@[P46>#U`'6AQ]m&6/`Z>#S?YY#Vc;r7U2&326d=w&H####?TZ`*4?&.MK?LP8Vxg>$[QXc%QJv92.(Db*B)gb*BM9dM*hJMAo*c&#"
        -: 4646:    "b0v=Pjer]$gG&JXDf->'StvU7505l9$AFvgYRI^&<^b68?j#q9QX4SM'RO#&sL1IM.rJfLUAj221]d##DW=m83u5;'bYx,*Sl0hL(W;;$doB&O/TQ:(Z^xBdLjL<Lni;''X.`$#8+1GD"
        -: 4647:    ":k$YUWsbn8ogh6rxZ2Z9]%nd+>V#*8U_72Lh+2Q8Cj0i:6hp&$C/:p(HK>T8Y[gHQ4`4)'$Ab(Nof%V'8hL&#<NEdtg(n'=S1A(Q1/I&4([%dM`,Iu'1:_hL>SfD07&6D<fp8dHM7/g+"
        -: 4648:    "tlPN9J*rKaPct&?'uBCem^jn%9_K)<,C5K3s=5g&GmJb*[SYq7K;TRLGCsM-$$;S%:Y@r7AK0pprpL<Lrh,q7e/%KWK:50I^+m'vi`3?%Zp+<-d+$L-Sv:@.o19n$s0&39;kn;S%BSq*"
        -: 4649:    "$3WoJSCLweV[aZ'MQIjO<7;X-X;&+dMLvu#^UsGEC9WEc[X(wI7#2.(F0jV*eZf<-Qv3J-c+J5AlrB#$p(H68LvEA'q3n0#m,[`*8Ft)FcYgEud]CWfm68,(aLA$@EFTgLXoBq/UPlp7"
        -: 4650:    ":d[/;r_ix=:TF`S5H-b<LI&HY(K=h#)]Lk$K14lVfm:x$H<3^Ql<M`$OhapBnkup'D#L$Pb_`N*g]2e;X/Dtg,bsj&K#2[-:iYr'_wgH)NUIR8a1n#S?Yej'h8^58UbZd+^FKD*T@;6A"
        -: 4651:    "7aQC[K8d-(v6GI$x:T<&'Gp5Uf>@M.*J:;$-rv29'M]8qMv-tLp,'886iaC=Hb*YJoKJ,(j%K=H`K.v9HggqBIiZu'QvBT.#=)0ukruV&.)3=(^1`o*Pj4<-<aN((^7('#Z0wK#5GX@7"
        -: 4652:    "u][`*S^43933A4rl][`*O4CgLEl]v$1Q3AeF37dbXk,.)vj#x'd`;qgbQR%FW,2(?LO=s%Sc68%NP'##Aotl8x=BE#j1UD([3$M(]UI2LX3RpKN@;/#f'f/&_mt&F)XdF<9t4)Qa.*kT"
        -: 4653:    "LwQ'(TTB9.xH'>#MJ+gLq9-##@HuZPN0]u:h7.T..G:;$/Usj(T7`Q8tT72LnYl<-qx8;-HV7Q-&Xdx%1a,hC=0u+HlsV>nuIQL-5<N?)NBS)QN*_I,?&)2'IM%L3I)X((e/dl2&8'<M"
        -: 4654:    ":^#M*Q+[T.Xri.LYS3v%fF`68h;b-X[/En'CR.q7E)p'/kle2HM,u;^%OKC-N+Ll%F9CF<Nf'^#t2L,;27W:0O@6##U6W7:$rJfLWHj$#)woqBefIZ.PK<b*t7ed;p*_m;4ExK#h@&]>"
        -: 4655:    "_>@kXQtMacfD.m-VAb8;IReM3$wf0''hra*so568'Ip&vRs849'MRYSp%:t:h5qSgwpEr$B>Q,;s(C#$)`svQuF$##-D,##,g68@2[T;.XSdN9Qe)rpt._K-#5wF)sP'##p#C0c%-Gb%"
        -: 4656:    "hd+<-j'Ai*x&&HMkT]C'OSl##5RG[JXaHN;d'uA#x._U;.`PU@(Z3dt4r152@:v,'R.Sj'w#0<-;kPI)FfJ&#AYJ&#//)>-k=m=*XnK$>=)72L]0I%>.G690a:$##<,);?;72#?x9+d;"
        -: 4657:    "^V'9;jY@;)br#q^YQpx:X#Te$Z^'=-=bGhLf:D6&bNwZ9-ZD#n^9HhLMr5G;']d&6'wYmTFmL<LD)F^%[tC'8;+9E#C$g%#5Y>q9wI>P(9mI[>kC-ekLC/R&CH+s'B;K-M6$EB%is00:"
        -: 4658:    "+A4[7xks.LrNk0&E)wILYF@2L'0Nb$+pv<(2.768/FrY&h$^3i&@+G%JT'<-,v`3;_)I9M^AE]CN?Cl2AZg+%4iTpT3<n-&%H%b<FDj2M<hH=&Eh<2Len$b*aTX=-8QxN)k11IM1c^j%"
        -: 4659:    "9s<L<NFSo)B?+<-(GxsF,^-Eh@$4dXhN$+#rxK8'je'D7k`e;)2pYwPA'_p9&@^18ml1^[@g4t*[JOa*[=Qp7(qJ_oOL^('7fB&Hq-:sf,sNj8xq^>$U4O]GKx'm9)b@p7YsvK3w^YR-"
        -: 4660:    "CdQ*:Ir<($u&)#(&?L9Rg3H)4fiEp^iI9O8KnTj,]H?D*r7'M;PwZ9K0E^k&-cpI;.p/6_vwoFMV<->#%Xi.LxVnrU(4&8/P+:hLSKj$#U%]49t'I:rgMi'FL@a:0Y-uA[39',(vbma*"
        -: 4661:    "hU%<-SRF`Tt:542R_VV$p@[p8DV[A,?1839FWdF<TddF<9Ah-6&9tWoDlh]&1SpGMq>Ti1O*H&#(AL8[_P%.M>v^-))qOT*F5Cq0`Ye%+$B6i:7@0IX<N+T+0MlMBPQ*Vj>SsD<U4JHY"
        -: 4662:    "8kD2)2fU/M#$e.)T4,_=8hLim[&);?UkK'-x?'(:siIfL<$pFM`i<?%W(mGDHM%>iWP,##P`%/L<eXi:@Z9C.7o=@(pXdAO/NLQ8lPl+HPOQa8wD8=^GlPa8TKI1CjhsCTSLJM'/Wl>-"
        -: 4663:    "S(qw%sf/@%#B6;/U7K]uZbi^Oc^2n<bhPmUkMw>%t<)'mEVE''n`WnJra$^TKvX5B>;_aSEK',(hwa0:i4G?.Bci.(X[?b*($,=-n<.Q%`(X=?+@Am*Js0&=3bh8K]mL<LoNs'6,'85`"
        -: 4664:    "0?t/'_U59@]ddF<#LdF<eWdF<OuN/45rY<-L@&#+fm>69=Lb,OcZV/);TTm8VI;?%OtJ<(b4mq7M6:u?KRdF<gR@2L=FNU-<b[(9c/ML3m;Z[$oF3g)GAWqpARc=<ROu7cL5l;-[A]%/"
        -: 4665:    "+fsd;l#SafT/f*W]0=O'$(Tb<[)*@e775R-:Yob%g*>l*:xP?Yb.5)%w_I?7uk5JC+FS(m#i'k.'a0i)9<7b'fs'59hq$*5Uhv##pi^8+hIEBF`nvo`;'l0.^S1<-wUK2/Coh58KKhLj"
        -: 4666:    "M=SO*rfO`+qC`W-On.=AJ56>>i2@2LH6A:&5q`?9I3@@'04&p2/LVa*T-4<-i3;M9UvZd+N7>b*eIwg:CC)c<>nO&#<IGe;__.thjZl<%w(Wk2xmp4Q@I#I9,DF]u7-P=.-_:YJ]aS@V"
        -: 4667:    "?6*C()dOp7:WL,b&3Rg/.cmM9&r^>$(>.Z-I&J(Q0Hd5Q%7Co-b`-c<N(6r@ip+AurK<m86QIth*#v;-OBqi+L7wDE-Ir8K['m+DDSLwK&/.?-V%U_%3:qKNu$_b*B-kp7NaD'QdWQPK"
        -: 4668:    "Yq[@>P)hI;*_F]u`Rb[.j8_Q/<&>uu+VsH$sM9TA%?)(vmJ80),P7E>)tjD%2L=-t#fK[%`v=Q8<FfNkgg^oIbah*#8/Qt$F&:K*-(N/'+1vMB,u()-a.VUU*#[e%gAAO(S>WlA2);Sa"
        -: 4669:    ">gXm8YB`1d@K#n]76-a$U,mF<fX]idqd)<3,]J7JmW4`6]uks=4-72L(jEk+:bJ0M^q-8Dm_Z?0olP1C9Sa&H[d&c$ooQUj]Exd*3ZM@-WGW2%s',B-_M%>%Ul:#/'xoFM9QX-$.QN'>"
        -: 4670:    "[%$Z$uF6pA6Ki2O5:8w*vP1<-1`[G,)-m#>0`P&#eb#.3i)rtB61(o'$?X3B</R90;eZ]%Ncq;-Tl]#F>2Qft^ae_5tKL9MUe9b*sLEQ95C&`=G?@Mj=wh*'3E>=-<)Gt*Iw)'QG:`@I"
        -: 4671:    "wOf7&]1i'S01B+Ev/Nac#9S;=;YQpg_6U`*kVY39xK,[/6Aj7:'1Bm-_1EYfa1+o&o4hp7KN_Q(OlIo@S%;jVdn0'1<Vc52=u`3^o-n1'g4v58Hj&6_t7$##?M)c<$bgQ_'SY((-xkA#"
        -: 4672:    "Y(,p'H9rIVY-b,'%bCPF7.J<Up^,(dU1VY*5#WkTU>h19w,WQhLI)3S#f$2(eb,jr*b;3Vw]*7NH%$c4Vs,eD9>XW8?N]o+(*pgC%/72LV-u<Hp,3@e^9UB1J+ak9-TN/mhKPg+AJYd$"
        -: 4673:    "MlvAF_jCK*.O-^(63adMT->W%iewS8W6m2rtCpo'RS1R84=@paTKt)>=%&1[)*vp'u+x,VrwN;&]kuO9JDbg=pO$J*.jVe;u'm0dr9l,<*wMK*Oe=g8lV_KEBFkO'oU]^=[-792#ok,)"
        -: 4674:    "i]lR8qQ2oA8wcRCZ^7w/Njh;?.stX?Q1>S1q4Bn$)K1<-rGdO'$Wr.Lc.CG)$/*JL4tNR/,SVO3,aUw'DJN:)Ss;wGn9A32ijw%FL+Z0Fn.U9;reSq)bmI32U==5ALuG&#Vf1398/pVo"
        -: 4675:    "1*c-(aY168o<`JsSbk-,1N;$>0:OUas(3:8Z972LSfF8eb=c-;>SPw7.6hn3m`9^Xkn(r.qS[0;T%&Qc=+STRxX'q1BNk3&*eu2;&8q$&x>Q#Q7^Tf+6<(d%ZVmj2bDi%.3L2n+4W'$P"
        -: 4676:    "iDDG)g,r%+?,$@?uou5tSe2aN_AQU*<h`e-GI7)?OK2A.d7_c)?wQ5AS@DL3r#7fSkgl6-++D:'A,uq7SvlB$pcpH'q3n0#_%dY#xCpr-l<F0NR@-##FEV6NTF6##$l84N1w?AO>'IAO"
        -: 4677:    "URQ##V^Fv-XFbGM7Fl(N<3DhLGF%q.1rC$#:T__&Pi68%0xi_&[qFJ(77j_&JWoF.V735&T,[R*:xFR*K5>>#`bW-?4Ne_&6Ne_&6Ne_&n`kr-#GJcM6X;uM6X;uM(.a..^2TkL%oR(#"
        -: 4678:    ";u.T%fAr%4tJ8&><1=GHZ_+m9/#H1F^R#SC#*N=BA9(D?v[UiFY>>^8p,KKF.W]L29uLkLlu/+4T<XoIB&hx=T1PcDaB&;HH+-AFr?(m9HZV)FKS8JCw;SD=6[^/DZUL`EUDf]GGlG&>"
        -: 4679:    "w$)F./^n3+rlo+DB;5sIYGNk+i1t-69Jg--0pao7Sm#K)pdHW&;LuDNH@H>#/X-TI(;P>#,Gc>#0Su>#4`1?#8lC?#<xU?#@.i?#D:%@#HF7@#LRI@#P_[@#Tkn@#Xw*A#]-=A#a9OA#"
        -: 4680:    "d<F&#*;G##.GY##2Sl##6`($#:l:$#>xL$#B.`$#F:r$#JF.%#NR@%#R_R%#Vke%#Zww%#_-4&#3^Rh%Sflr-k'MS.o?.5/sWel/wpEM0%3'/1)K^f1-d>G21&v(35>V`39V7A4=onx4"
        -: 4681:    "A1OY5EI0;6Ibgr6M$HS7Q<)58C5w,;WoA*#[%T*#`1g*#d=#+#hI5+#lUG+#pbY+#tnl+#x$),#&1;,#*=M,#.I`,#2Ur,#6b.-#;w[H#iQtA#m^0B#qjBB#uvTB##-hB#'9$C#+E6C#"
        -: 4682:    "/QHC#3^ZC#7jmC#;v)D#?,<D#C8ND#GDaD#KPsD#O]/E#g1A5#KA*1#gC17#MGd;#8(02#L-d3#rWM4#Hga1#,<w0#T.j<#O#'2#CYN1#qa^:#_4m3#o@/=#eG8=#t8J5#`+78#4uI-#"
        -: 4683:    "m3B2#SB[8#Q0@8#i[*9#iOn8#1Nm;#^sN9#qh<9#:=x-#P;K2#$%X9#bC+.#Rg;<#mN=.#MTF.#RZO.#2?)4#Y#(/#[)1/#b;L/#dAU/#0Sv;#lY$0#n`-0#sf60#(F24#wrH0#%/e0#"
        -: 4684:    "TmD<#%JSMFove:CTBEXI:<eh2g)B,3h2^G3i;#d3jD>)4kMYD4lVu`4m`:&5niUA5@(A5BA1]PBB:xlBCC=2CDLXMCEUtiCf&0g2'tN?PGT4CPGT4CPGT4CPGT4CPGT4CPGT4CPGT4CP"
        -: 4685:    "GT4CPGT4CPGT4CPGT4CPGT4CPGT4CP-qekC`.9kEg^+F$kwViFJTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5o,^<-28ZI'O?;xp"
        -: 4686:    "O?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xp;7q-#lLYI:xvD=#";
        -: 4687:
function _ZL37GetDefaultCompressedFontDataTTFBase85v called 1 returned 100% blocks executed 100%
        1: 4688:static const char* GetDefaultCompressedFontDataTTFBase85()
        -: 4689:{
        1: 4690:    return proggy_clean_ttf_compressed_data_base85;
        1: 4690-block 2
        -: 4691:}
        -: 4692:
        -: 4693:#endif // #ifndef IMGUI_DISABLE
